using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Development.Attributes;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

[ResetStaticFields]
public class SleepingBag : DecayEntity
{
	public enum BagAssignMode
	{
		Allowed = 0,
		TeamAndFriendlyContacts = 1,
		None = 2,
		LAST = 2
	}

	public enum BagResultType
	{
		Ok,
		TooManyBags,
		BagBlocked,
		TargetIsPlayingTutorial
	}

	public struct CanAssignBedResult
	{
		public BagResultType Result;

		public int Count;

		public int Max;
	}

	public enum SleepingBagResetReason
	{
		Respawned,
		Placed,
		Death
	}

	[NonSerialized]
	public ulong deployerUserID;

	public GameObject renameDialog;

	public GameObject assignDialog;

	public float secondsBetweenReuses = 300f;

	public bool perPlayerRespawnCooldown;

	private Dictionary<ulong, float> playerCooldowns = new Dictionary<ulong, float>();

	public string niceName = "Unnamed Bag";

	public Vector3 spawnOffset = Vector3.zero;

	public RespawnType RespawnType = (RespawnType)1;

	public bool isStatic;

	public bool canBePublic;

	public bool canReassignToFriends = true;

	public const Flags IsPublicFlag = Flags.Reserved3;

	public const Flags DestroyAfterUseFlag = Flags.Reserved14;

	public static Phrase bagLimitPhrase = new Phrase("bag_limit_update", "You are now at {0}/{1} bags");

	public static Phrase bagLimitReachedPhrase = new Phrase("bag_limit_reached", "You have reached your bag limit!");

	public Phrase assignOtherBagPhrase = new Phrase("assigned_other_bag_limit", "You have assigned {0} a bag, they are now at {0}/{1} bags");

	public Phrase assignedBagPhrase = new Phrase("assigned_bag_limit", "You have been assigned a bag, you are now at {0}/{1} bags");

	public Phrase cannotAssignBedNoPlayerPhrase = new Phrase("cannot_assign_bag_limit_noplayer", "You cannot assign a bag to this player, they have reached their bag limit!");

	public Phrase cannotAssignBedPhrase = new Phrase("cannot_assign_bag_limit", "You cannot assign {0} a bag, they have reached their bag limit!");

	public Phrase cannotMakeBedPhrase = new Phrase("cannot_make_bed_limit", "You cannot take ownership of the bed, you are at your bag limit");

	public Phrase bedAssigningBlocked = new Phrase("bag_assign_blocked", "That player has blocked bag assignment");

	public static Phrase tutorialPhrase = new Phrase("bag_assign_tutorial", "Cannot assign bags to players mid-tutorial");

	public float unlockTime;

	public static List<SleepingBag> sleepingBags = new List<SleepingBag>();

	private bool notifyPlayerOnServerInit;

	private static Dictionary<ulong, List<SleepingBag>> bagsPerPlayer = new Dictionary<ulong, List<SleepingBag>>();

	public virtual float unlockSeconds
	{
		get
		{
			if (unlockTime < Time.realtimeSinceStartup)
			{
				return 0f;
			}
			return unlockTime - Time.realtimeSinceStartup;
		}
	}

	public bool IsTutorialBag
	{
		get
		{
			if (net != null && net.group != null)
			{
				return net.group.restricted;
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SleepingBag.OnRpcMessage", 0);
		try
		{
			if (rpc == 3057055788u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AssignToFriend "));
				}
				TimeWarning val2 = TimeWarning.New("AssignToFriend", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3057055788u, "AssignToFriend", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							AssignToFriend(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AssignToFriend");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1335950295 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Rename "));
				}
				TimeWarning val2 = TimeWarning.New("Rename", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1335950295u, "Rename", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Rename(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Rename");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 42669546 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_MakeBed "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_MakeBed", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(42669546u, "RPC_MakeBed", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_MakeBed(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_MakeBed");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 393812086 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_MakePublic "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_MakePublic", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(393812086u, "RPC_MakePublic", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RPC_MakePublic(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_MakePublic");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsPublic()
	{
		return HasFlag(Flags.Reserved3);
	}

	private float EvaluatedSecondsBetweenReuses()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Expected I4, but got Unknown
		float num = 0f;
		RespawnType respawnType = RespawnType;
		switch (respawnType - 1)
		{
		case 0:
		case 2:
			num = ConVar.Server.respawnTimeAdditionBag;
			break;
		case 1:
		case 3:
			num = ConVar.Server.respawnTimeAdditionBed;
			break;
		}
		return secondsBetweenReuses + num;
	}

	public virtual float GetUnlockSeconds(ulong playerID)
	{
		if (playerCooldowns.TryGetValue(playerID, out var value) && value > unlockTime)
		{
			return Mathf.Max(0f, value - Time.realtimeSinceStartup);
		}
		return unlockSeconds;
	}

	public virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers)
	{
		object obj = Interface.CallHook("OnSleepingBagValidCheck", (object)this, (object)playerID, (object)ignoreTimers);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (deployerUserID == playerID)
		{
			if (!ignoreTimers)
			{
				return unlockTime < Time.realtimeSinceStartup;
			}
			return true;
		}
		return false;
	}

	public static CanAssignBedResult? CanAssignBed(BasePlayer player, SleepingBag newBag, ulong targetPlayer, int countOffset = 1, int maxOffset = 0, SleepingBag ignore = null)
	{
		int num = ConVar.Server.max_sleeping_bags + maxOffset;
		if (player.IsInTutorial)
		{
			return null;
		}
		if (num < 0)
		{
			return null;
		}
		int num2 = countOffset;
		BasePlayer basePlayer = BasePlayer.FindByID(targetPlayer);
		BagAssignMode bagAssignMode = (BagAssignMode)Mathf.Clamp(((Object)(object)basePlayer != (Object)null) ? basePlayer.GetInfoInt("client.bagassignmode", 0) : 0, 0, 2);
		int max = num;
		CanAssignBedResult value;
		if ((Object)(object)player != (Object)(object)basePlayer)
		{
			switch (bagAssignMode)
			{
			case BagAssignMode.Allowed:
			{
				BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
				if ((Object)(object)activeGameMode != (Object)null && (activeGameMode.fogOfWar || !activeGameMode.ingameMap))
				{
					num--;
				}
				break;
			}
			case BagAssignMode.None:
				value = default(CanAssignBedResult);
				value.Result = BagResultType.BagBlocked;
				return value;
			case BagAssignMode.TeamAndFriendlyContacts:
			{
				if (!((Object)(object)basePlayer != (Object)null))
				{
					break;
				}
				bool flag = false;
				if (basePlayer.Team != null && basePlayer.Team.members.Contains(player.userID))
				{
					flag = true;
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo relations = RelationshipManager.ServerInstance.GetRelationships(targetPlayer).GetRelations(player.userID);
					if (relations != null && relations.type == RelationshipManager.RelationshipType.Friend)
					{
						flag = true;
					}
					if (!flag && (Object)(object)ClanManager.ServerInstance != (Object)null && basePlayer.clanId != 0L && basePlayer.clanId == player.clanId)
					{
						flag = true;
					}
				}
				if (!flag)
				{
					value = default(CanAssignBedResult);
					value.Result = BagResultType.BagBlocked;
					return value;
				}
				break;
			}
			}
			if ((Object)(object)basePlayer != (Object)(object)player && (Object)(object)basePlayer != (Object)null && basePlayer.IsInTutorial)
			{
				value = default(CanAssignBedResult);
				value.Result = BagResultType.TargetIsPlayingTutorial;
				return value;
			}
		}
		foreach (SleepingBag sleepingBag in sleepingBags)
		{
			if ((Object)(object)sleepingBag != (Object)(object)ignore && sleepingBag.deployerUserID == targetPlayer)
			{
				num2++;
				if (num2 > num)
				{
					value = default(CanAssignBedResult);
					value.Count = num2;
					value.Max = max;
					value.Result = BagResultType.TooManyBags;
					return value;
				}
			}
		}
		value = default(CanAssignBedResult);
		value.Count = num2;
		value.Max = max;
		value.Result = BagResultType.Ok;
		return value;
	}

	public static Planner.CanBuildResult? CanBuildBed(BasePlayer player, Construction construction)
	{
		GameObject obj = GameManager.server.FindPrefab(construction.prefabID);
		if (((obj != null) ? obj.GetComponent<BaseEntity>() : null) is SleepingBag)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(player, null, player.userID);
			if (canAssignBedResult.HasValue)
			{
				Planner.CanBuildResult value;
				if (canAssignBedResult.Value.Result == BagResultType.Ok)
				{
					value = default(Planner.CanBuildResult);
					value.Result = true;
					value.Phrase = bagLimitPhrase;
					value.Arguments = new string[2]
					{
						canAssignBedResult.Value.Count.ToString(),
						canAssignBedResult.Value.Max.ToString()
					};
					return value;
				}
				value = default(Planner.CanBuildResult);
				value.Result = false;
				value.Phrase = bagLimitReachedPhrase;
				return value;
			}
		}
		return null;
	}

	public static SleepingBag[] FindForPlayer(ulong playerID, bool ignoreTimers)
	{
		return sleepingBags.Where((SleepingBag x) => x.ValidForPlayer(playerID, ignoreTimers)).ToArray();
	}

	public static void FindForPlayer(ulong playerID, bool ignoreTimers, List<SleepingBag> result)
	{
		foreach (SleepingBag sleepingBag in sleepingBags)
		{
			if (sleepingBag.ValidForPlayer(playerID, ignoreTimers))
			{
				result.Add(sleepingBag);
			}
		}
	}

	public static bool SpawnPlayer(BasePlayer player, NetworkableId sleepingBag)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Invalid comparison between Unknown and I4
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player2 = player;
		SleepingBag[] array = FindForPlayer(player2.userID, ignoreTimers: true);
		SleepingBag sleepingBag2 = array.FirstOrDefault((SleepingBag x) => x.ValidForPlayer(player2.userID, ignoreTimers: false) && x.net.ID == sleepingBag && x.unlockTime < Time.realtimeSinceStartup);
		if ((Object)(object)sleepingBag2 == (Object)null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnPlayerRespawn", (object)player, (object)sleepingBag2);
		if (obj is SleepingBag)
		{
			sleepingBag2 = (SleepingBag)obj;
		}
		if (sleepingBag2 is StaticRespawnArea staticRespawnArea && !staticRespawnArea.IsAuthed(player2.userID))
		{
			return false;
		}
		if ((int)sleepingBag2.GetRespawnState(player2.userID) != 1)
		{
			return false;
		}
		sleepingBag2.GetSpawnPos(out var pos, out var rot);
		player2.RespawnAt(pos, rot, sleepingBag2);
		sleepingBag2.PostPlayerSpawn(player2);
		SleepingBag[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			SetBagTimer(array2[i], pos, SleepingBagResetReason.Respawned, player2);
		}
		if (sleepingBag2.HasFlag(Flags.Reserved14))
		{
			sleepingBag2.Kill();
		}
		return true;
	}

	public static void AddBagForPlayer(SleepingBag bag, ulong user, bool networkUpdate = true)
	{
		if (user == 0L)
		{
			return;
		}
		if (!bagsPerPlayer.TryGetValue(user, out var value))
		{
			value = new List<SleepingBag>();
			bagsPerPlayer[user] = value;
		}
		if (!value.Contains(bag))
		{
			value.Add(bag);
			if (networkUpdate)
			{
				RelationshipManager.FindByID(user)?.SendNetworkUpdate();
			}
		}
	}

	public static void RemoveBagForPlayer(SleepingBag bag, ulong user)
	{
		if (user != 0L && bagsPerPlayer.TryGetValue(user, out var value))
		{
			if (value.Remove(bag))
			{
				RelationshipManager.FindByID(user)?.SendNetworkUpdate();
			}
			if (value.Count == 0)
			{
				bagsPerPlayer.Remove(user);
			}
		}
	}

	public static void OnBagChangedOwnership(SleepingBag bag, ulong oldUser)
	{
		if (bag.deployerUserID != oldUser)
		{
			RemoveBagForPlayer(bag, oldUser);
			AddBagForPlayer(bag, bag.deployerUserID);
		}
	}

	public static void ClearTutorialBagsForPlayer(ulong userId)
	{
		if (userId == 0L || !bagsPerPlayer.TryGetValue(userId, out var _))
		{
			return;
		}
		List<SleepingBag> list = Pool.Get<List<SleepingBag>>();
		foreach (SleepingBag item in bagsPerPlayer[userId])
		{
			if (item.net != null && item.net.group != null && item.net.group.restricted)
			{
				list.Add(item);
			}
		}
		foreach (SleepingBag item2 in list)
		{
			item2.deployerUserID = 0uL;
			RemoveBagForPlayer(item2, userId);
		}
		Pool.FreeUnmanaged<SleepingBag>(ref list);
	}

	public static int GetSleepingBagCount(ulong userId)
	{
		if (userId == 0L)
		{
			return 0;
		}
		if (!bagsPerPlayer.TryGetValue(userId, out var value))
		{
			return 0;
		}
		return value.Count;
	}

	public static bool TrySpawnPlayer(BasePlayer player, NetworkableId sleepingBag, out string errorMessage)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (!player.IsDead())
		{
			errorMessage = "Couldn't spawn - player is not dead!";
			return false;
		}
		if (player.CanRespawn())
		{
			if (SpawnPlayer(player, sleepingBag))
			{
				player.MarkRespawn();
				errorMessage = null;
				return true;
			}
			errorMessage = "Couldn't spawn in sleeping bag!";
			return false;
		}
		errorMessage = "You can't respawn again so quickly, wait a while";
		return false;
	}

	public virtual void SetUnlockTime(float newTime)
	{
		unlockTime = newTime;
	}

	public void SetUnlockTimeForPlayer(ulong player, float time)
	{
		playerCooldowns.TryGetValue(player, out var value);
		playerCooldowns[player] = Mathf.Max(value, time);
	}

	public void ResetUnlockTimeForPlayer(ulong player)
	{
		playerCooldowns.Remove(player);
	}

	public static bool DestroyBag(ulong userID, NetworkableId sleepingBag)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		SleepingBag sleepingBag2 = FindForPlayer(userID, ignoreTimers: true).FirstOrDefault((SleepingBag x) => x.net.ID == sleepingBag);
		if ((Object)(object)sleepingBag2 == (Object)null)
		{
			return false;
		}
		if (Interface.CallHook("OnSleepingBagDestroy", (object)sleepingBag2, (object)userID) != null)
		{
			return false;
		}
		RemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);
		sleepingBag2.deployerUserID = 0uL;
		if (sleepingBag2.HasFlag(Flags.Reserved14))
		{
			sleepingBag2.Kill();
		}
		else
		{
			sleepingBag2.SendNetworkUpdate();
		}
		BasePlayer basePlayer = BasePlayer.FindByID(userID);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SendRespawnOptions();
			Interface.CallHook("OnSleepingBagDestroyed", (object)sleepingBag2, (object)userID);
			Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);
		}
		return true;
	}

	public static void ResetTimersForPlayer(BasePlayer player)
	{
		SleepingBag[] array = FindForPlayer(player.userID, ignoreTimers: true);
		foreach (SleepingBag obj in array)
		{
			obj.unlockTime = 0f;
			obj.ResetUnlockTimeForPlayer(player.userID);
		}
	}

	public virtual void GetSpawnPos(out Vector3 pos, out Quaternion rot)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		pos = ((Component)this).transform.position + spawnOffset;
		Quaternion rotation = ((Component)this).transform.rotation;
		rot = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
	}

	public void SetPublic(bool isPublic)
	{
		SetFlag(Flags.Reserved3, isPublic);
	}

	public void SetDeployedBy(BasePlayer player)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)player == (Object)null))
		{
			deployerUserID = player.userID;
			SetBagTimer(this, ((Component)this).transform.position, SleepingBagResetReason.Placed, player);
			SendNetworkUpdate();
			notifyPlayerOnServerInit = true;
		}
	}

	public static void OnPlayerDeath(BasePlayer player)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		SleepingBag[] array = FindForPlayer(player.userID, ignoreTimers: true);
		for (int i = 0; i < array.Length; i++)
		{
			SetBagTimer(array[i], ((Component)player).transform.position, SleepingBagResetReason.Death, player);
		}
	}

	public static void SetBagTimer(SleepingBag bag, Vector3 position, SleepingBagResetReason reason, BasePlayer forPlayer)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		float? num = null;
		if ((Object)(object)activeGameMode != (Object)null)
		{
			num = activeGameMode.EvaluateSleepingBagReset(bag, position, reason);
		}
		if (num.HasValue)
		{
			bag.SetUnlockTime(Time.realtimeSinceStartup + num.Value);
			return;
		}
		if (reason == SleepingBagResetReason.Respawned && Vector3.Distance(position, ((Component)bag).transform.position) <= ConVar.Server.respawnresetrange)
		{
			if (bag.perPlayerRespawnCooldown)
			{
				bag.SetUnlockTimeForPlayer(forPlayer.userID, Time.realtimeSinceStartup + bag.EvaluatedSecondsBetweenReuses());
			}
			else
			{
				bag.SetUnlockTime(Time.realtimeSinceStartup + bag.EvaluatedSecondsBetweenReuses());
			}
			bag.SendNetworkUpdate();
		}
		if (reason != SleepingBagResetReason.Placed)
		{
			return;
		}
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		SleepingBag[] array = sleepingBags.Where((SleepingBag x) => x.deployerUserID != 0L && x.deployerUserID == bag.deployerUserID && x.unlockTime > Time.realtimeSinceStartup).ToArray();
		foreach (SleepingBag sleepingBag in array)
		{
			if (bag.unlockTime > realtimeSinceStartup && Vector3.Distance(((Component)sleepingBag).transform.position, position) <= ConVar.Server.respawnresetrange)
			{
				realtimeSinceStartup = bag.unlockTime;
			}
		}
		float num2 = Mathf.Max(realtimeSinceStartup, Time.realtimeSinceStartup + bag.EvaluatedSecondsBetweenReuses());
		if ((Object)(object)forPlayer != (Object)null && forPlayer.IsInTutorial)
		{
			num2 = 0f;
		}
		bag.SetUnlockTime(num2);
		bag.SendNetworkUpdate();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!sleepingBags.Contains(this))
		{
			sleepingBags.Add(this);
			if (deployerUserID != 0L)
			{
				AddBagForPlayer(this, deployerUserID, !Application.isLoadingSave);
			}
		}
		if (notifyPlayerOnServerInit)
		{
			notifyPlayerOnServerInit = false;
			NotifyPlayer(deployerUserID);
		}
	}

	public override void OnPlaced(BasePlayer player)
	{
		SetDeployedBy(player);
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		((FacepunchBehaviour)this).Invoke((Action)DelayedPlayerNotify, 0.1f);
	}

	private void DelayedPlayerNotify()
	{
		NotifyPlayer(deployerUserID);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		AddBagForPlayer(this, deployerUserID, !Application.isLoadingSave);
	}

	private void NotifyPlayer(ulong id)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(id);
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsConnected)
		{
			basePlayer.SendRespawnOptions();
		}
	}

	public override void DoServerDestroy()
	{
		base.DoServerDestroy();
		sleepingBags.RemoveAll((SleepingBag x) => (Object)(object)x == (Object)(object)this);
		RemoveBagForPlayer(this, deployerUserID);
		NotifyPlayer(deployerUserID);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.sleepingBag = Pool.Get<SleepingBag>();
		info.msg.sleepingBag.name = niceName;
		if (info.forDisk)
		{
			info.msg.sleepingBag.deployerID = deployerUserID;
			return;
		}
		info.msg.sleepingBag.clientAssigned = deployerUserID == info.forConnection.userid;
		info.msg.sleepingBag.isAssigned = deployerUserID != 0;
	}

	public override bool CanUseNetworkCache(Connection connection)
	{
		return false;
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return true;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Rename(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		string text = msg.read.String(256, false);
		if (Interface.CallHook("CanRenameBed", (object)msg.player, (object)this, (object)text) == null)
		{
			text = WordFilter.Filter(text);
			if (string.IsNullOrEmpty(text))
			{
				text = "Unnamed Sleeping Bag";
			}
			if (text.Length > 24)
			{
				text = text.Substring(0, 22) + "..";
			}
			niceName = text;
			SendNetworkUpdate();
			NotifyPlayer(deployerUserID);
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		if (!msg.player.CanInteract() || deployerUserID != (ulong)msg.player.userID || !canReassignToFriends)
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num == 0L || Interface.CallHook("CanAssignBed", (object)msg.player, (object)this, (object)num) != null)
		{
			return;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, num);
			if (canAssignBedResult.HasValue)
			{
				BasePlayer basePlayer = RelationshipManager.FindByID(num);
				if (canAssignBedResult.Value.Result == BagResultType.TooManyBags)
				{
					if ((Object)(object)basePlayer == (Object)null)
					{
						msg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedNoPlayerPhrase, false);
					}
					else
					{
						string playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);
						msg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedPhrase, false, playerNameStreamSafe);
					}
				}
				else if (canAssignBedResult.Value.Result == BagResultType.BagBlocked)
				{
					msg.player.ShowToast(GameTip.Styles.Error, bedAssigningBlocked, false);
				}
				else if (canAssignBedResult.Value.Result == BagResultType.TargetIsPlayingTutorial)
				{
					msg.player.ShowToast(GameTip.Styles.Error, tutorialPhrase, false);
				}
				else
				{
					basePlayer?.ShowToast(GameTip.Styles.Blue_Long, assignedBagPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, (GetSleepingBagCount(msg.player.userID) - 1).ToString(), canAssignBedResult.Value.Max.ToString());
				}
				if (canAssignBedResult.Value.Result != 0)
				{
					return;
				}
			}
		}
		ulong num2 = deployerUserID;
		deployerUserID = num;
		NotifyPlayer(num2);
		NotifyPlayer(deployerUserID);
		OnBagChangedOwnership(this, num2);
		Analytics.Azure.OnSleepingBagAssigned(msg.player, this, num);
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public virtual void RPC_MakePublic(RPCMessage msg)
	{
		if (!canBePublic || !msg.player.CanInteract() || (deployerUserID != (ulong)msg.player.userID && !msg.player.CanBuild()))
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag == IsPublic() || Interface.CallHook("CanSetBedPublic", (object)msg.player, (object)this) != null)
		{
			return;
		}
		SetPublic(flag);
		if (!IsPublic())
		{
			if (ConVar.Server.max_sleeping_bags > 0)
			{
				CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);
				if (canAssignBedResult.HasValue)
				{
					if (canAssignBedResult.Value.Result == BagResultType.Ok)
					{
						msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					}
					else
					{
						msg.player.ShowToast(GameTip.Styles.Blue_Long, cannotMakeBedPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					}
					if (canAssignBedResult.Value.Result != 0)
					{
						return;
					}
				}
			}
			ulong num = deployerUserID;
			deployerUserID = msg.player.userID;
			NotifyPlayer(num);
			NotifyPlayer(deployerUserID);
			OnBagChangedOwnership(this, num);
			Analytics.Azure.OnSleepingBagAssigned(msg.player, this, deployerUserID = msg.player.userID);
		}
		else
		{
			Analytics.Azure.OnSleepingBagAssigned(msg.player, this, 0uL);
		}
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_MakeBed(RPCMessage msg)
	{
		if (!canBePublic || !IsPublic() || !msg.player.CanInteract())
		{
			return;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);
			if (canAssignBedResult.HasValue)
			{
				if (canAssignBedResult.Value.Result != 0)
				{
					msg.player.ShowToast(GameTip.Styles.Red_Normal, cannotMakeBedPhrase, false);
				}
				else
				{
					msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
				}
				if (canAssignBedResult.Value.Result != 0)
				{
					return;
				}
			}
		}
		ulong num = deployerUserID;
		deployerUserID = msg.player.userID;
		NotifyPlayer(num);
		NotifyPlayer(deployerUserID);
		OnBagChangedOwnership(this, num);
		Interface.CallHook("OnBedMade", (object)this, (object)msg.player);
		SendNetworkUpdate();
	}

	protected virtual void PostPlayerSpawn(BasePlayer p)
	{
		p.SendRespawnOptions();
	}

	public virtual RespawnState GetRespawnState(ulong userID)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (!WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: false))
		{
			if (!TriggerNoRespawnZone.InAnyNoRespawnZone(((Component)this).transform.position))
			{
				return (RespawnState)1;
			}
			return (RespawnState)4;
		}
		return (RespawnState)3;
	}

	public virtual bool IsMobile()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Invalid comparison between Unknown and I4
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity is BaseVehicle)
		{
			return true;
		}
		return (int)RespawnType == 4;
	}

	public override string Admin_Who()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine(base.Admin_Who());
		stringBuilder.AppendLine($"Assigned bag ID: {deployerUserID}");
		stringBuilder.AppendLine("Assigned player name: " + Admin.GetPlayerName(deployerUserID));
		stringBuilder.AppendLine("Bag Name:" + niceName);
		return stringBuilder.ToString();
	}

	public override void OnDeployableCorpseSpawned(BaseEntity corpse)
	{
		base.OnDeployableCorpseSpawned(corpse);
		if (corpse is SleepingBag sleepingBag)
		{
			sleepingBag.deployerUserID = deployerUserID;
			sleepingBag.niceName = niceName;
			sleepingBag.SetFlag(Flags.Reserved14, b: true);
			AddBagForPlayer(sleepingBag, deployerUserID);
		}
	}

	public override bool ShouldDropDeployableCorpse(HitInfo info)
	{
		if (!base.ShouldDropDeployableCorpse(info))
		{
			return false;
		}
		if (HasFlag(Flags.Reserved14))
		{
			return false;
		}
		return true;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.sleepingBag != null)
		{
			niceName = info.msg.sleepingBag.name;
			deployerUserID = info.msg.sleepingBag.deployerID;
		}
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (base.ShouldDisplayPickupOption(player) && player.IsBuildingAuthed())
		{
			return true;
		}
		if (base.ShouldDisplayPickupOption(player))
		{
			return (ulong)player.userID == deployerUserID;
		}
		return false;
	}
}


public enum BagAssignMode
{
	Allowed = 0,
	TeamAndFriendlyContacts = 1,
	None = 2,
	LAST = 2
}


public enum BagResultType
{
	Ok,
	TooManyBags,
	BagBlocked,
	TargetIsPlayingTutorial
}


public struct CanAssignBedResult
{
	public BagResultType Result;

	public int Count;

	public int Max;
}


public enum SleepingBagResetReason
{
	Respawned,
	Placed,
	Death
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SleepingBagCamper : SleepingBag
{
	public EntityRef<BaseVehicleSeat> AssociatedSeat;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SleepingBagCamper.OnRpcMessage", 0);
		try
		{
			if (rpc == 2177887503u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerClearBed "));
				}
				TimeWarning val2 = TimeWarning.New("ServerClearBed", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2177887503u, "ServerClearBed", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerClearBed(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerClearBed");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Reserved3, b: true);
	}

	protected override void PostPlayerSpawn(BasePlayer p)
	{
		base.PostPlayerSpawn(p);
		BaseVehicleSeat baseVehicleSeat = AssociatedSeat.Get(base.isServer);
		if ((Object)(object)baseVehicleSeat != (Object)null)
		{
			if (p.IsConnected)
			{
				p.EndSleeping();
			}
			baseVehicleSeat.MountPlayer(p);
		}
	}

	public void SetSeat(BaseVehicleSeat seat, bool sendNetworkUpdate = false)
	{
		AssociatedSeat.Set(seat);
		if (sendNetworkUpdate)
		{
			SendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.sleepingBagCamper = Pool.Get<SleepingBagCamper>();
			info.msg.sleepingBagCamper.seatID = AssociatedSeat.uid;
		}
	}

	public override RespawnState GetRespawnState(ulong userID)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Invalid comparison between Unknown and I4
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		RespawnState respawnState = base.GetRespawnState(userID);
		if ((int)respawnState != 1)
		{
			return respawnState;
		}
		if (AssociatedSeat.IsValid(base.isServer))
		{
			BasePlayer mounted = AssociatedSeat.Get(base.isServer).GetMounted();
			if ((Object)(object)mounted != (Object)null && (ulong)mounted.userID != userID)
			{
				return (RespawnState)2;
			}
		}
		return (RespawnState)1;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void ServerClearBed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && AssociatedSeat.IsValid(base.isServer) && !((Object)(object)AssociatedSeat.Get(base.isServer).GetMounted() != (Object)(object)player))
		{
			ulong userID = deployerUserID;
			SleepingBag.RemoveBagForPlayer(this, deployerUserID);
			deployerUserID = 0uL;
			SendNetworkUpdate();
			BasePlayer basePlayer = BasePlayer.FindByID(userID);
			if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsDestroyed)
			{
				basePlayer.SendRespawnOptions();
			}
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class SlotMachine : BaseMountable
{
	public enum SlotFaces
	{
		Scrap,
		Rope,
		Apple,
		LowGrade,
		Wood,
		Bandage,
		Charcoal,
		Gunpowder,
		Rust,
		Meat,
		Hammer,
		Sulfur,
		TechScrap,
		Frags,
		Cloth,
		LuckySeven
	}

	[ServerVar]
	public static int ForcePayoutIndex = -1;

	[Header("Slot Machine")]
	public Transform Reel1;

	public Transform Reel2;

	public Transform Reel3;

	public Transform Arm;

	public AnimationCurve Curve;

	public int Reel1Spins = 16;

	public int Reel2Spins = 48;

	public int Reel3Spins = 80;

	public int MaxReelSpins = 96;

	public float SpinDuration = 2f;

	private int SpinResult1;

	private int SpinResult2;

	private int SpinResult3;

	private int SpinResultPrevious1;

	private int SpinResultPrevious2;

	private int SpinResultPrevious3;

	private float SpinTime;

	public GameObjectRef StoragePrefab;

	public EntityRef StorageInstance;

	public SoundDefinition SpinSound;

	public SlotMachinePayoutDisplay PayoutDisplay;

	public SlotMachinePayoutSettings PayoutSettings;

	public Transform HandIkTarget;

	private const Flags HasScrapForSpin = Flags.Reserved1;

	private const Flags IsSpinningFlag = Flags.Reserved2;

	public Material PayoutIconMaterial;

	public bool UseTimeOfDayAdjustedSprite = true;

	public MeshRenderer[] PulseRenderers;

	public float PulseSpeed = 5f;

	[ColorUsage(true, true)]
	public Color PulseFrom;

	[ColorUsage(true, true)]
	public Color PulseTo;

	private BasePlayer CurrentSpinPlayer;

	private bool IsSpinning => HasFlag(Flags.Reserved2);

	public int CurrentMultiplier { get; private set; } = 1;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SlotMachine.OnRpcMessage", 0);
		try
		{
			if (rpc == 1251063754 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Deposit "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Deposit", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1251063754u, "RPC_Deposit", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_Deposit(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Deposit");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1455840454 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Spin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Spin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1455840454u, "RPC_Spin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							RPC_Spin(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Spin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3942337446u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestMultiplierChange "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestMultiplierChange", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3942337446u, "Server_RequestMultiplierChange", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3942337446u, "Server_RequestMultiplierChange", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_RequestMultiplierChange(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in Server_RequestMultiplierChange");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Save(SaveInfo info)
	{
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.slotMachine = Pool.Get<SlotMachine>();
		info.msg.slotMachine.oldResult1 = SpinResultPrevious1;
		info.msg.slotMachine.oldResult2 = SpinResultPrevious2;
		info.msg.slotMachine.oldResult3 = SpinResultPrevious3;
		info.msg.slotMachine.newResult1 = SpinResult1;
		info.msg.slotMachine.newResult2 = SpinResult2;
		info.msg.slotMachine.newResult3 = SpinResult3;
		info.msg.slotMachine.isSpinning = IsSpinning;
		info.msg.slotMachine.spinTime = SpinTime;
		info.msg.slotMachine.storageID = StorageInstance.uid;
		info.msg.slotMachine.multiplier = CurrentMultiplier;
	}

	public override void Load(LoadInfo info)
	{
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.slotMachine != null)
		{
			SpinResultPrevious1 = info.msg.slotMachine.oldResult1;
			SpinResultPrevious2 = info.msg.slotMachine.oldResult2;
			SpinResultPrevious3 = info.msg.slotMachine.oldResult3;
			SpinResult1 = info.msg.slotMachine.newResult1;
			SpinResult2 = info.msg.slotMachine.newResult2;
			SpinResult3 = info.msg.slotMachine.newResult3;
			CurrentMultiplier = info.msg.slotMachine.multiplier;
			if (base.isServer)
			{
				SpinTime = info.msg.slotMachine.spinTime;
			}
			StorageInstance.uid = info.msg.slotMachine.storageID;
			if (info.fromDisk && base.isServer)
			{
				SetFlag(Flags.Reserved2, b: false);
			}
		}
	}

	public override float GetComfort()
	{
		return 1f;
	}

	public override void Spawn()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(StoragePrefab.resourcePath);
			baseEntity.Spawn();
			baseEntity.SetParent(this);
			StorageInstance.Set(baseEntity);
		}
	}

	internal override void DoServerDestroy()
	{
		SlotMachineStorage slotMachineStorage = StorageInstance.Get(base.isServer) as SlotMachineStorage;
		if (slotMachineStorage.IsValid())
		{
			slotMachineStorage.DropItems();
		}
		base.DoServerDestroy();
	}

	private int GetBettingAmount()
	{
		SlotMachineStorage component = ((Component)StorageInstance.Get(base.isServer)).GetComponent<SlotMachineStorage>();
		if ((Object)(object)component == (Object)null)
		{
			return 0;
		}
		return component.inventory.GetSlot(0)?.amount ?? 0;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Spin(RPCMessage rpc)
	{
		if (IsSpinning || (Object)(object)rpc.player != (Object)(object)GetMounted())
		{
			return;
		}
		SlotMachineStorage component = ((Component)StorageInstance.Get(base.isServer)).GetComponent<SlotMachineStorage>();
		int num = (int)PayoutSettings.SpinCost.amount * CurrentMultiplier;
		if (GetBettingAmount() < num || (Object)(object)rpc.player == (Object)null)
		{
			return;
		}
		(CurrentSpinPlayer = rpc.player).inventory.loot.Clear();
		Item slot = component.inventory.GetSlot(0);
		int amount = 0;
		if (slot != null)
		{
			if (slot.amount > num)
			{
				slot.MarkDirty();
				slot.amount -= num;
				amount = slot.amount;
			}
			else
			{
				slot.amount -= num;
				slot.RemoveFromContainer();
			}
		}
		component.UpdateAmount(amount);
		SetFlag(Flags.Reserved2, b: true);
		SpinResultPrevious1 = SpinResult1;
		SpinResultPrevious2 = SpinResult2;
		SpinResultPrevious3 = SpinResult3;
		CalculateSpinResults();
		SpinTime = Time.time;
		ClientRPC(RpcTarget.NetworkGroup("RPC_OnSpin"), (sbyte)SpinResult1, (sbyte)SpinResult2, (sbyte)SpinResult3);
		((FacepunchBehaviour)this).Invoke((Action)CheckPayout, SpinDuration);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Deposit(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null) && !HasFlag(Flags.Reserved2) && StorageInstance.IsValid(base.isServer))
		{
			((Component)StorageInstance.Get(base.isServer)).GetComponent<StorageContainer>().PlayerOpenLoot(player, "", doPositionChecks: false);
		}
	}

	private void CheckPayout()
	{
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if ((Object)(object)PayoutSettings != (Object)null)
		{
			if (CalculatePayout(out var info, out var bonus))
			{
				int num = ((int)info.Item.amount + bonus) * CurrentMultiplier;
				BaseEntity baseEntity = StorageInstance.Get(serverside: true);
				if ((Object)(object)baseEntity != (Object)null && baseEntity is SlotMachineStorage slotMachineStorage)
				{
					Item slot = slotMachineStorage.inventory.GetSlot(1);
					if (slot != null)
					{
						slot.amount += num;
						slot.MarkDirty();
					}
					else
					{
						ItemManager.Create(info.Item.itemDef, num, 0uL).MoveToContainer(slotMachineStorage.inventory, 1);
					}
				}
				if (CurrentSpinPlayer.IsValid() && (Object)(object)CurrentSpinPlayer == (Object)(object)GetMounted())
				{
					CurrentSpinPlayer.ChatMessage($"You received {num}x {info.Item.itemDef.displayName.english} for slots payout!");
				}
				Analytics.Azure.OnGamblingResult(CurrentSpinPlayer, this, (int)PayoutSettings.SpinCost.amount * CurrentMultiplier, num, null);
				if (info.OverrideWinEffect != null && info.OverrideWinEffect.isValid)
				{
					Effect.server.Run(info.OverrideWinEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
				else if (PayoutSettings.DefaultWinEffect != null && PayoutSettings.DefaultWinEffect.isValid)
				{
					Effect.server.Run(PayoutSettings.DefaultWinEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
				if (info.OverrideWinEffect != null && info.OverrideWinEffect.isValid)
				{
					flag = true;
				}
			}
			else
			{
				Analytics.Azure.OnGamblingResult(CurrentSpinPlayer, this, (int)PayoutSettings.SpinCost.amount * CurrentMultiplier, 0, null);
			}
		}
		else
		{
			Debug.LogError((object)$"Failed to process spin results: PayoutSettings != null {(Object)(object)PayoutSettings != (Object)null} CurrentSpinPlayer.IsValid {CurrentSpinPlayer.IsValid()} CurrentSpinPlayer == mounted {(Object)(object)CurrentSpinPlayer == (Object)(object)GetMounted()}");
		}
		if (!flag)
		{
			SetFlag(Flags.Reserved2, b: false);
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedSpinningReset, 4f);
		}
		CurrentSpinPlayer = null;
	}

	private void DelayedSpinningReset()
	{
		SetFlag(Flags.Reserved2, b: false);
	}

	private void CalculateSpinResults()
	{
		if (ForcePayoutIndex != -1)
		{
			SpinResult1 = PayoutSettings.Payouts[ForcePayoutIndex].Result1;
			SpinResult2 = PayoutSettings.Payouts[ForcePayoutIndex].Result2;
			SpinResult3 = PayoutSettings.Payouts[ForcePayoutIndex].Result3;
		}
		else
		{
			SpinResult1 = RandomSpinResult();
			SpinResult2 = RandomSpinResult();
			SpinResult3 = RandomSpinResult();
		}
	}

	private int RandomSpinResult()
	{
		int num = new Random(Random.Range(0, 1000)).Next(0, PayoutSettings.TotalStops);
		int num2 = 0;
		int num3 = 0;
		int[] virtualFaces = PayoutSettings.VirtualFaces;
		foreach (int num4 in virtualFaces)
		{
			if (num < num4 + num2)
			{
				return num3;
			}
			num2 += num4;
			num3++;
		}
		return 15;
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		BaseEntity baseEntity = StorageInstance.Get(serverside: true);
		if ((Object)(object)baseEntity != (Object)null && baseEntity is SlotMachineStorage slotMachineStorage)
		{
			slotMachineStorage.inventory.GetSlot(1)?.MoveToContainer(player.inventory.containerMain);
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void Server_RequestMultiplierChange(RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)GetMounted()) && !HasFlag(Flags.Reserved2))
		{
			CurrentMultiplier = Mathf.Clamp(msg.read.Int32(), 1, 5);
			OnBettingScrapUpdated(GetBettingAmount());
			SendNetworkUpdate();
		}
	}

	public void OnBettingScrapUpdated(int amount)
	{
		SetFlag(Flags.Reserved1, (float)amount >= PayoutSettings.SpinCost.amount * (float)CurrentMultiplier);
	}

	private bool CalculatePayout(out SlotMachinePayoutSettings.PayoutInfo info, out int bonus)
	{
		info = default(SlotMachinePayoutSettings.PayoutInfo);
		bonus = 0;
		SlotMachinePayoutSettings.IndividualPayouts[] facePayouts = PayoutSettings.FacePayouts;
		for (int i = 0; i < facePayouts.Length; i++)
		{
			SlotMachinePayoutSettings.IndividualPayouts individualPayouts = facePayouts[i];
			if (individualPayouts.Result == SpinResult1)
			{
				bonus += (int)individualPayouts.Item.amount;
			}
			if (individualPayouts.Result == SpinResult2)
			{
				bonus += (int)individualPayouts.Item.amount;
			}
			if (individualPayouts.Result == SpinResult3)
			{
				bonus += (int)individualPayouts.Item.amount;
			}
			if (bonus > 0)
			{
				info.Item = new ItemAmount(individualPayouts.Item.itemDef);
			}
		}
		SlotMachinePayoutSettings.PayoutInfo[] payouts = PayoutSettings.Payouts;
		for (int i = 0; i < payouts.Length; i++)
		{
			SlotMachinePayoutSettings.PayoutInfo payoutInfo = payouts[i];
			if (payoutInfo.Result1 == SpinResult1 && payoutInfo.Result2 == SpinResult2 && payoutInfo.Result3 == SpinResult3)
			{
				info = payoutInfo;
				return true;
			}
		}
		return bonus > 0;
	}
}


public enum SlotFaces
{
	Scrap,
	Rope,
	Apple,
	LowGrade,
	Wood,
	Bandage,
	Charcoal,
	Gunpowder,
	Rust,
	Meat,
	Hammer,
	Sulfur,
	TechScrap,
	Frags,
	Cloth,
	LuckySeven
}


using System;
using Network;
using UnityEngine;

public class SlotMachineStorage : StorageContainer
{
	public int Amount;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SlotMachineStorage.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsPlayerValid(BasePlayer player)
	{
		if (!player.isMounted || (Object)(object)player.GetMounted() != (Object)(object)GetParentEntity())
		{
			return false;
		}
		return true;
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (!IsPlayerValid(player))
		{
			return false;
		}
		return base.PlayerOpenLoot(player, panelToOpen);
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		UpdateAmount(base.inventory.GetSlot(0)?.amount ?? 0);
	}

	public void UpdateAmount(int amount)
	{
		if (Amount != amount)
		{
			Amount = amount;
			(GetParentEntity() as SlotMachine).OnBettingScrapUpdated(amount);
			ClientRPC(RpcTarget.NetworkGroup("RPC_UpdateAmount"), Amount);
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!IsPlayerValid(player))
		{
			return false;
		}
		return base.CanBeLooted(player);
	}
}


using System;
using CompanionServer;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SmartAlarm : AppIOEntity, ISubscribable
{
	public const Flags Flag_HasCustomMessage = Flags.Reserved6;

	public static readonly Phrase DefaultNotificationTitle = new Phrase("app.alarm.title", "Alarm");

	public static readonly Phrase DefaultNotificationBody = new Phrase("app.alarm.body", "Your base is under attack!");

	[Header("Smart Alarm")]
	public GameObjectRef SetupNotificationDialog;

	public Animator Animator;

	public readonly NotificationList _subscriptions = new NotificationList();

	public string _notificationTitle = "";

	public string _notificationBody = "";

	public float _lastSentTime;

	public override AppEntityType Type => (AppEntityType)2;

	public override bool Value { get; set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SmartAlarm.OnRpcMessage", 0);
		try
		{
			if (rpc == 3292290572u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetNotificationTextImpl "));
				}
				TimeWarning val2 = TimeWarning.New("SetNotificationTextImpl", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3292290572u, "SetNotificationTextImpl", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3292290572u, "SetNotificationTextImpl", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage notificationTextImpl = rPCMessage;
							SetNotificationTextImpl(notificationTextImpl);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetNotificationTextImpl");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4207149767u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StartSetupNotification "));
				}
				TimeWarning val2 = TimeWarning.New("StartSetupNotification", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4207149767u, "StartSetupNotification", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4207149767u, "StartSetupNotification", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							StartSetupNotification(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in StartSetupNotification");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool AddSubscription(ulong steamId)
	{
		return _subscriptions.AddSubscription(steamId);
	}

	public bool RemoveSubscription(ulong steamId)
	{
		return _subscriptions.RemoveSubscription(steamId);
	}

	public bool HasSubscription(ulong steamId)
	{
		return _subscriptions.HasSubscription(steamId);
	}

	public override void InitShared()
	{
		base.InitShared();
		_notificationTitle = DefaultNotificationTitle.translated;
		_notificationBody = DefaultNotificationBody.translated;
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		Value = inputAmount > 0;
		if (Value == IsOn())
		{
			return;
		}
		SetFlag(Flags.On, Value);
		BroadcastValueChange();
		float num = Mathf.Max(App.alarmcooldown, 15f);
		if (Value && Time.realtimeSinceStartup - _lastSentTime >= num)
		{
			BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
			if ((Object)(object)buildingPrivilege != (Object)null)
			{
				_subscriptions.IntersectWith(buildingPrivilege.authorizedPlayers);
			}
			_subscriptions.SendNotification(NotificationChannel.SmartAlarm, _notificationTitle, _notificationBody, "alarm");
			_lastSentTime = Time.realtimeSinceStartup;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.smartAlarm = Pool.Get<SmartAlarm>();
			info.msg.smartAlarm.notificationTitle = _notificationTitle;
			info.msg.smartAlarm.notificationBody = _notificationBody;
			info.msg.smartAlarm.subscriptions = _subscriptions.ToList();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk && info.msg.smartAlarm != null)
		{
			_notificationTitle = info.msg.smartAlarm.notificationTitle;
			_notificationBody = info.msg.smartAlarm.notificationBody;
			_subscriptions.LoadFrom(info.msg.smartAlarm.subscriptions);
		}
	}

	protected override void OnPairedWithPlayer(BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null) && !HasSubscription(player.userID) && !AddSubscription(player.userID))
		{
			player.ClientRPC(RpcTarget.Player("HandleCompanionPairingResult", player), 7);
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void StartSetupNotification(RPCMessage rpc)
	{
		if (rpc.player.CanInteract())
		{
			BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
			if (!((Object)(object)buildingPrivilege != (Object)null) || buildingPrivilege.CanAdministrate(rpc.player))
			{
				ClientRPC(RpcTarget.Player("SetupNotification", rpc.player), _notificationTitle, _notificationBody);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	private void SetNotificationTextImpl(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
		if (!((Object)(object)buildingPrivilege != (Object)null) || buildingPrivilege.CanAdministrate(rpc.player))
		{
			string text = rpc.read.String(128, false);
			string text2 = rpc.read.String(512, false);
			if (!string.IsNullOrWhiteSpace(text))
			{
				_notificationTitle = text;
			}
			if (!string.IsNullOrWhiteSpace(text2))
			{
				_notificationBody = text2;
			}
			SetFlag(Flags.Reserved6, b: true);
		}
	}
}


using System;
using ConVar;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SmartSwitch : AppIOEntity
{
	[Header("Smart Switch")]
	public Animator ReceiverAnimator;

	public override AppEntityType Type => (AppEntityType)1;

	public override bool Value
	{
		get
		{
			return IsOn();
		}
		set
		{
			SetSwitch(value);
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SmartSwitch.OnRpcMessage", 0);
		try
		{
			if (rpc == 2810053005u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ToggleSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("ToggleSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2810053005u, "ToggleSwitch", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2810053005u, "ToggleSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ToggleSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ToggleSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool WantsPower(int inputIndex)
	{
		if (inputIndex == 0)
		{
			return IsOn();
		}
		return false;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Busy, b: false);
	}

	public override void ResetIOState()
	{
		SetFlag(Flags.On, b: false);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsOn())
		{
			return 0;
		}
		return GetCurrentEnergy();
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		if (inputSlot != 0)
		{
			return currentEnergy;
		}
		return base.CalculateCurrentEnergy(inputAmount, inputSlot);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 1 && inputAmount > 0)
		{
			SetSwitch(wantsOn: true);
		}
		if (inputSlot == 2 && inputAmount > 0)
		{
			SetSwitch(wantsOn: false);
		}
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public void SetSwitch(bool wantsOn)
	{
		if (wantsOn != IsOn())
		{
			SetFlag(Flags.On, wantsOn);
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).Invoke((Action)Unbusy, 0.5f);
			SendNetworkUpdateImmediate();
			MarkDirty();
			BroadcastValueChange();
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ToggleSwitch(RPCMessage msg)
	{
		if (PlayerCanToggle(msg.player))
		{
			SetSwitch(!IsOn());
		}
	}

	public void Unbusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	private static bool PlayerCanToggle(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null)
		{
			return player.CanBuild();
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Network;
using UnityEngine;

public class SnakeHazard : WildlifeHazard
{
	public static Phrase SnakeHazardFailedTipPhrase = new Phrase("toast.snake_hazard_failed", "Jump immediately when a Snake hisses to avoid its attack.");

	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 5f;

	public List<ModifierDefintion> FailModifierEffects;

	private BasePlayer playerToAttack;

	private float slitherRate = 0.05f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SnakeHazard.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	protected override void OnHazardFailed(BasePlayer player)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		base.OnHazardFailed(player);
		if (!((Object)(object)player == (Object)null))
		{
			ClientRPC(RpcTarget.Player("CL_SnakeHazardFailed", player));
			if (GamePhysics.LineOfSight(((Component)this).transform.position + Vector3.up * 0.25f, ((Component)player).transform.position + Vector3.up * 0.25f, 1075904769))
			{
				playerToAttack = player;
				((FacepunchBehaviour)this).Invoke((Action)ApplyAttackToPlayer, 0.3f);
				ClientRPC(RpcTarget.NetworkGroup("CL_Attack"));
			}
		}
	}

	private void ApplyAttackToPlayer()
	{
		if ((Object)(object)playerToAttack == (Object)null)
		{
			return;
		}
		if (!playerToAttack.OnAttacked(Damage, DamageType, this, ignoreShield: false))
		{
			playerToAttack = null;
			return;
		}
		if (FailModifierEffects != null && (Object)(object)playerToAttack.modifiers != (Object)null)
		{
			playerToAttack.modifiers.Add(FailModifierEffects);
		}
		playerToAttack = null;
	}

	public override void StartReposition()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		base.StartReposition();
		if (!base.IsCorpse)
		{
			if (base.isServer)
			{
				ClientRPC(RpcTarget.NetworkGroup("CL_RepositionDisappear"), repositionTo);
			}
			((FacepunchBehaviour)this).InvokeRepeating((Action)SlitherTick, 0.2f, slitherRate);
			((FacepunchBehaviour)this).Invoke((Action)StartDelayedTeleport, SlitherDuration + 0.2f);
		}
	}

	private void SlitherTick()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.MoveTowards(((Component)this).transform.position, repositionTo, SlitherSpeed * slitherRate);
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(val + Vector3.up * 1f, Vector3.down, ref val2, 5f, 8388608))
		{
			val = ((RaycastHit)(ref val2)).point;
		}
		((Component)this).transform.position = val;
		try
		{
			syncPosition = true;
			NetworkPositionTick();
		}
		finally
		{
			syncPosition = false;
		}
	}

	private void StartDelayedTeleport()
	{
		if (!base.IsCorpse)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SlitherTick);
			SetFlag(Flags.Disabled, b: true);
			((FacepunchBehaviour)this).Invoke((Action)EndDelayedTeleport, 2f);
		}
	}

	private void EndDelayedTeleport()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.Disabled, b: false);
		ServerPosition = repositionTo;
		SendNetworkUpdate_Position();
		if (base.isServer)
		{
			if (PrefabRepositionEffect != null && PrefabRepositionEffect.isValid)
			{
				Effect.server.Run(PrefabReappearEffect.resourcePath, ServerPosition, Vector3.up);
			}
			ClientRPC(RpcTarget.NetworkGroup("CL_RepositionReappear"), repositionLookAtPos);
		}
	}

	protected override bool ShouldStartHazard(BasePlayer player)
	{
		if (!base.ShouldStartHazard(player))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)SlitherTick))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)StartDelayedTeleport))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)EndDelayedTeleport))
		{
			return false;
		}
		return true;
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		CancelSnakeInvokes();
	}

	public override void OnKilled()
	{
		base.OnKilled();
		CancelSnakeInvokes();
	}

	private void CancelSnakeInvokes()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)SlitherTick);
		((FacepunchBehaviour)this).CancelInvoke((Action)StartDelayedTeleport);
		((FacepunchBehaviour)this).CancelInvoke((Action)EndDelayedTeleport);
		((FacepunchBehaviour)this).CancelInvoke((Action)ApplyAttackToPlayer);
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Snowmobile : GroundVehicle, VehicleChassisVisuals<Snowmobile>.IClientWheelUser, IPrefabPreProcess, CarPhysics<Snowmobile>.ICar, TriggerHurtNotChild.IHurtTriggerUser
{
	[SerializeField]
	[Header("Snowmobile")]
	private Transform centreOfMassTransform;

	[SerializeField]
	private GameObjectRef itemStoragePrefab;

	[SerializeField]
	private VisualCarWheel wheelSkiFL;

	[SerializeField]
	private VisualCarWheel wheelSkiFR;

	[SerializeField]
	private VisualCarWheel wheelTreadFL;

	[SerializeField]
	private VisualCarWheel wheelTreadFR;

	[SerializeField]
	private VisualCarWheel wheelTreadRL;

	[SerializeField]
	private VisualCarWheel wheelTreadRR;

	[SerializeField]
	public CarSettings carSettings;

	[SerializeField]
	public int engineKW = 59;

	[SerializeField]
	public float idleFuelPerSec = 0.03f;

	[SerializeField]
	public float maxFuelPerSec = 0.15f;

	[SerializeField]
	public float airControlStability = 10f;

	[SerializeField]
	public float airControlPower = 40f;

	[SerializeField]
	public float badTerrainDrag = 1f;

	[SerializeField]
	public ProtectionProperties riderProtection;

	[SerializeField]
	public float hurtTriggerMinSpeed = 1f;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerFront;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerRear;

	[Header("Snowmobile Visuals")]
	public float minGroundFXSpeed;

	[SerializeField]
	private SnowmobileChassisVisuals chassisVisuals;

	[SerializeField]
	private VehicleLight[] lights;

	[SerializeField]
	private Transform steeringLeftIK;

	[SerializeField]
	private Transform steeringRightIK;

	[SerializeField]
	private Transform leftFootIK;

	[SerializeField]
	private Transform rightFootIK;

	[SerializeField]
	private Transform starterKey;

	[SerializeField]
	private Vector3 engineOffKeyRot;

	[SerializeField]
	private Vector3 engineOnKeyRot;

	[ServerVar(Help = "How long before a snowmobile loses all its health while outside")]
	public static float outsideDecayMinutes = 1440f;

	[ServerVar(Help = "Allow mounting as a passenger when there's no driver")]
	public static bool allowPassengerOnly = false;

	[ServerVar(Help = "If true, snowmobile goes fast on all terrain types")]
	public static bool allTerrain = false;

	private float _throttle;

	private float _brake;

	private float _mass = -1f;

	public const Flags Flag_Slowmode = Flags.Reserved8;

	private EntityRef<StorageContainer> itemStorageInstance;

	private float cachedFuelFraction;

	private const float FORCE_MULTIPLIER = 10f;

	private float _steer;

	public CarPhysics<Snowmobile> carPhysics;

	public VehicleTerrainHandler serverTerrainHandler;

	private CarWheel[] wheels;

	public TimeSince timeSinceLastUsed;

	private const float DECAY_TICK_TIME = 60f;

	public float prevTerrainModDrag;

	public TimeSince timeSinceTerrainModCheck;

	public float ThrottleInput
	{
		get
		{
			if (!engineController.IsOn)
			{
				return 0f;
			}
			return _throttle;
		}
		protected set
		{
			_throttle = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public float BrakeInput
	{
		get
		{
			return _brake;
		}
		protected set
		{
			_brake = Mathf.Clamp(value, 0f, 1f);
		}
	}

	public bool IsBraking => BrakeInput > 0f;

	public float SteerAngle
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.SteerAngle;
			}
			return 0f;
		}
	}

	public override float DriveWheelVelocity
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.DriveWheelVelocity;
			}
			return 0f;
		}
	}

	public float DriveWheelSlip
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.DriveWheelSlip;
			}
			return 0f;
		}
	}

	public float MaxSteerAngle => carSettings.maxSteerAngle;

	public bool InSlowMode
	{
		get
		{
			return HasFlag(Flags.Reserved8);
		}
		private set
		{
			if (InSlowMode != value)
			{
				SetFlag(Flags.Reserved8, value);
			}
		}
	}

	private float Mass
	{
		get
		{
			if (base.isServer)
			{
				return rigidBody.mass;
			}
			return _mass;
		}
	}

	public float SteerInput
	{
		get
		{
			return _steer;
		}
		protected set
		{
			_steer = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public VehicleTerrainHandler.Surface OnSurface
	{
		get
		{
			if (serverTerrainHandler == null)
			{
				return VehicleTerrainHandler.Surface.Default;
			}
			return serverTerrainHandler.OnSurface;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Snowmobile.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 924237371 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenItemStorage "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenItemStorage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(924237371u, "RPC_OpenItemStorage", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_OpenItemStorage(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_OpenItemStorage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.snowmobile != null)
		{
			itemStorageInstance.uid = info.msg.snowmobile.storageID;
			engineController.FuelSystem.SetInstanceID(info.msg.snowmobile.fuelStorageID);
			cachedFuelFraction = info.msg.snowmobile.fuelFraction;
		}
	}

	public float GetMaxDriveForce()
	{
		return (float)engineKW * 10f * GetPerformanceFraction();
	}

	public override float GetMaxForwardSpeed()
	{
		return GetMaxDriveForce() / Mass * 15f;
	}

	public override float GetThrottleInput()
	{
		return ThrottleInput;
	}

	public override float GetBrakeInput()
	{
		return BrakeInput;
	}

	public bool GetSteerSpeedMod(float speed)
	{
		return false;
	}

	public virtual float GetSteerMaxMult(float speed)
	{
		return 1f;
	}

	public float GetPerformanceFraction()
	{
		float num = Mathf.InverseLerp(0.25f, 0.5f, base.healthFraction);
		return Mathf.Lerp(0.5f, 1f, num);
	}

	public float GetFuelFraction()
	{
		if (base.isServer)
		{
			return engineController.FuelSystem.GetFuelFraction();
		}
		return cachedFuelFraction;
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		if (!PlayerIsMounted(player))
		{
			return !IsOn();
		}
		return true;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && GameInfo.HasAchievements && !old.HasFlag(Flags.On) && next.HasFlag(Flags.On))
		{
			BasePlayer driver = GetDriver();
			if ((Object)(object)driver != (Object)null && (Object)(object)driver.FindTrigger<TriggerSnowmobileAchievement>() != (Object)null)
			{
				driver.GiveAchievement("DRIVE_SNOWMOBILE");
			}
		}
	}

	private bool CanPlayerSeeMountPoint(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (!GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position, 0.25f, 2162688, (QueryTriggerInteraction)0))
		{
			return !GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position + Vector3.up * 0.5f, 0.25f, 2162688, (QueryTriggerInteraction)0);
		}
		return false;
	}

	public float GetSteerInput()
	{
		return SteerInput;
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		rigidBody.centerOfMass = centreOfMassTransform.localPosition;
		rigidBody.inertiaTensor = new Vector3(450f, 200f, 200f);
		carPhysics = new CarPhysics<Snowmobile>(this, ((Component)this).transform, rigidBody, carSettings);
		serverTerrainHandler = new VehicleTerrainHandler(this);
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.15f, 0.02f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)SnowmobileDecay, Random.Range(30f, 60f), 60f, 6f);
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Snowmobile.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			float speed = GetSpeed();
			carPhysics.FixedUpdate(Time.fixedDeltaTime, speed);
			serverTerrainHandler.FixedUpdate();
			if (IsOn())
			{
				float fuelPerSecond = Mathf.Lerp(idleFuelPerSec, maxFuelPerSec, Mathf.Abs(ThrottleInput));
				engineController.TickFuel(fuelPerSecond);
			}
			engineController.CheckEngineState();
			RaycastHit val2 = default(RaycastHit);
			if (!carPhysics.IsGrounded() && Physics.Raycast(((Component)this).transform.position, Vector3.down, ref val2, 10f, 1218511105, (QueryTriggerInteraction)1))
			{
				Vector3 normal = ((RaycastHit)(ref val2)).normal;
				Vector3 right = ((Component)this).transform.right;
				right.y = 0f;
				normal = Vector3.ProjectOnPlane(normal, right);
				float num = Vector3.Angle(normal, Vector3.up);
				Vector3 angularVelocity = rigidBody.angularVelocity;
				float num2 = ((Vector3)(ref angularVelocity)).magnitude * 57.29578f * airControlStability / airControlPower;
				if (num <= 45f)
				{
					Vector3 val3 = Vector3.Cross(Quaternion.AngleAxis(num2, rigidBody.angularVelocity) * ((Component)this).transform.up, normal) * airControlPower * airControlPower;
					rigidBody.AddTorque(val3);
				}
			}
			((Component)hurtTriggerFront).gameObject.SetActive(speed > hurtTriggerMinSpeed);
			((Component)hurtTriggerRear).gameObject.SetActive(speed < 0f - hurtTriggerMinSpeed);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!IsDriver(player))
		{
			return;
		}
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		if (inputState.IsDown(BUTTON.FIRE_THIRD))
		{
			SteerInput += inputState.MouseDelta().x * 0.1f;
		}
		else
		{
			SteerInput = 0f;
			if (inputState.IsDown(BUTTON.LEFT))
			{
				SteerInput = -1f;
			}
			else if (inputState.IsDown(BUTTON.RIGHT))
			{
				SteerInput = 1f;
			}
		}
		float num = 0f;
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			num = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			num = -1f;
		}
		ThrottleInput = 0f;
		BrakeInput = 0f;
		if (GetSpeed() > 3f && num < -0.1f)
		{
			ThrottleInput = 0f;
			BrakeInput = 0f - num;
		}
		else
		{
			ThrottleInput = num;
			BrakeInput = 0f;
		}
		if (engineController.IsOff && ((inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD)) || (inputState.IsDown(BUTTON.BACKWARD) && !inputState.WasDown(BUTTON.BACKWARD))))
		{
			engineController.TryStartEngine(player);
		}
	}

	public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
	{
		float maxDriveForce = GetMaxDriveForce();
		float num = Mathf.Lerp(0.3f, 0.75f, GetPerformanceFraction());
		float num2 = MathEx.BiasedLerp(1f - absSpeed / topSpeed, num);
		return maxDriveForce * num2;
	}

	public override float GetModifiedDrag()
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		float num = base.GetModifiedDrag();
		if (!allTerrain)
		{
			VehicleTerrainHandler.Surface onSurface = serverTerrainHandler.OnSurface;
			if (serverTerrainHandler.IsGrounded && onSurface != VehicleTerrainHandler.Surface.Frictionless && onSurface != VehicleTerrainHandler.Surface.Sand && onSurface != VehicleTerrainHandler.Surface.Snow && onSurface != VehicleTerrainHandler.Surface.Ice)
			{
				float num2 = Mathf.Max(num, badTerrainDrag);
				num = (prevTerrainModDrag = ((!(num2 <= prevTerrainModDrag)) ? Mathf.MoveTowards(prevTerrainModDrag, num2, 0.33f * TimeSince.op_Implicit(timeSinceTerrainModCheck)) : prevTerrainModDrag));
			}
			else
			{
				prevTerrainModDrag = 0f;
			}
		}
		timeSinceTerrainModCheck = TimeSince.op_Implicit(0f);
		InSlowMode = num >= badTerrainDrag;
		return num;
	}

	public override float MaxVelocity()
	{
		return Mathf.Max(GetMaxForwardSpeed() * 1.3f, 30f);
	}

	public CarWheel[] GetWheels()
	{
		if (wheels == null)
		{
			wheels = new CarWheel[6] { wheelSkiFL, wheelSkiFR, wheelTreadFL, wheelTreadFR, wheelTreadRL, wheelTreadRR };
		}
		return wheels;
	}

	public float GetWheelsMidPos()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		return (((Component)wheelSkiFL.wheelCollider).transform.localPosition.z - ((Component)wheelTreadRL.wheelCollider).transform.localPosition.z) * 0.5f;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.snowmobile = Pool.Get<Snowmobile>();
		info.msg.snowmobile.steerInput = SteerInput;
		info.msg.snowmobile.driveWheelVel = DriveWheelVelocity;
		info.msg.snowmobile.throttleInput = ThrottleInput;
		info.msg.snowmobile.brakeInput = BrakeInput;
		info.msg.snowmobile.storageID = itemStorageInstance.uid;
		info.msg.snowmobile.fuelStorageID = GetFuelSystem().GetInstanceID();
		info.msg.snowmobile.fuelFraction = GetFuelFraction();
	}

	public override int StartingFuelUnits()
	{
		return 0;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned && child.prefabID == itemStoragePrefab.GetEntity().prefabID)
		{
			itemStorageInstance.Set((StorageContainer)child);
		}
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot)
		{
			StorageContainer storageContainer = itemStorageInstance.Get(base.isServer);
			if ((Object)(object)storageContainer != (Object)null && storageContainer.IsValid())
			{
				storageContainer.DropItems();
			}
		}
		base.DoServerDestroy();
	}

	public override bool MeetsEngineRequirements()
	{
		return HasDriver();
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (allowPassengerOnly)
		{
			base.AttemptMount(player, doMountChecks);
		}
		else if (MountEligable(player) && CanPlayerSeeMountPoint(player))
		{
			BaseMountable baseMountable = ((HasDriver() || player.IsRestrained) ? GetIdealMountPointFor(player) : mountPoints[0].mountable);
			if ((Object)(object)baseMountable != (Object)null)
			{
				baseMountable.AttemptMount(player, doMountChecks);
			}
			if (PlayerIsMounted(player))
			{
				PlayerMounted(player, baseMountable);
			}
		}
	}

	public void SnowmobileDecay()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		if (!IsDead() && !(TimeSince.op_Implicit(timeSinceLastUsed) < 2700f))
		{
			float num = (IsOutside() ? outsideDecayMinutes : float.PositiveInfinity);
			if (!float.IsPositiveInfinity(num))
			{
				float num2 = 1f / num;
				Hurt(MaxHealth() * num2, DamageType.Decay, this, useProtection: false);
			}
		}
	}

	public StorageContainer GetItemContainer()
	{
		BaseEntity baseEntity = itemStorageInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as StorageContainer;
		}
		return null;
	}

	private void UpdateClients()
	{
		if (HasDriver())
		{
			byte num = (byte)((ThrottleInput + 1f) * 7f);
			byte b = (byte)(BrakeInput * 15f);
			byte arg = (byte)(num + (b << 4));
			ClientRPC(RpcTarget.NetworkGroup("SnowmobileUpdate"), SteerInput, arg, DriveWheelVelocity, GetFuelFraction());
		}
	}

	public override void OnEngineStartFailed()
	{
		ClientRPC(RpcTarget.NetworkGroup("EngineStartFailed"));
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		riderProtection.Scale(info.damageTypes);
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player) && IsDriver(player))
		{
			GetFuelSystem().LootFuel(player);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_OpenItemStorage(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player))
		{
			StorageContainer itemContainer = GetItemContainer();
			if ((Object)(object)itemContainer != (Object)null)
			{
				itemContainer.PlayerOpenLoot(player);
			}
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SpinnerWheel : Signage
{
	public Transform wheel;

	public float velocity;

	public Quaternion targetRotation = Quaternion.identity;

	[Header("Sound")]
	public SoundDefinition spinLoopSoundDef;

	public SoundDefinition spinStartSoundDef;

	public SoundDefinition spinAccentSoundDef;

	public SoundDefinition spinStopSoundDef;

	public float minTimeBetweenSpinAccentSounds = 0.3f;

	public float spinAccentAngleDelta = 180f;

	private Sound spinSound;

	private SoundModulation.Modulator spinSoundGain;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SpinnerWheel.OnRpcMessage", 0);
		try
		{
			if (rpc == 3019675107u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_AnyoneSpin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_AnyoneSpin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3019675107u, "RPC_AnyoneSpin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_AnyoneSpin(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_AnyoneSpin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1455840454 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Spin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Spin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1455840454u, "RPC_Spin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							RPC_Spin(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Spin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual bool AllowPlayerSpins()
	{
		return true;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.spinnerWheel = Pool.Get<SpinnerWheel>();
		SpinnerWheel spinnerWheel = info.msg.spinnerWheel;
		Quaternion localRotation = wheel.localRotation;
		spinnerWheel.spin = ((Quaternion)(ref localRotation)).eulerAngles;
	}

	public override void Load(LoadInfo info)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.spinnerWheel != null)
		{
			Quaternion localRotation = Quaternion.Euler(info.msg.spinnerWheel.spin);
			if (base.isServer && info.fromDisk)
			{
				localRotation = Quaternion.identity;
			}
			if (base.isServer)
			{
				((Component)wheel).transform.localRotation = localRotation;
			}
		}
	}

	public virtual float GetMaxSpinSpeed()
	{
		return 720f;
	}

	public virtual void Update_Server()
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (velocity > 0f)
		{
			float num = Mathf.Clamp(GetMaxSpinSpeed() * velocity, 0f, GetMaxSpinSpeed());
			velocity -= Time.deltaTime * Mathf.Clamp(velocity / 2f, 0.1f, 1f);
			if (velocity < 0f)
			{
				velocity = 0f;
				ToggleChildEntityColliders(state: true);
			}
			wheel.Rotate(Vector3.up, num * Time.deltaTime, (Space)1);
			SendNetworkUpdate();
		}
	}

	public void Update_Client()
	{
	}

	public void Update()
	{
		if (base.isClient)
		{
			Update_Client();
		}
		if (base.isServer)
		{
			Update_Server();
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Spin(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && AllowPlayerSpins() && (AnyoneSpin() || rpc.player.CanBuild()) && Interface.CallHook("OnSpinWheel", (object)rpc.player, (object)this) == null && !(velocity > 15f))
		{
			velocity += Random.Range(4f, 7f);
			ToggleChildEntityColliders(state: false);
		}
	}

	private void ToggleChildEntityColliders(bool state)
	{
		foreach (BaseEntity child in children)
		{
			if (child is DroppedItem droppedItem && (Object)(object)droppedItem.childCollider != (Object)null)
			{
				droppedItem.childCollider.enabled = state;
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_AnyoneSpin(RPCMessage rpc)
	{
		if (rpc.player.CanInteract())
		{
			SetFlag(Flags.Reserved3, rpc.read.Bit());
		}
	}

	public bool AnyoneSpin()
	{
		return HasFlag(Flags.Reserved3);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class SpinUpWeapon : BaseProjectile, ITurretNotify
{
	public float timeBetweenSpinToggle = 1f;

	public float spinUpTime = 1f;

	public GameObjectRef bulletEffect;

	public float projectileThicknessOverride = 0.5f;

	public bool showSpinProgress = true;

	public float spinningMoveSpeedScale = 0.7f;

	public float conditionLossPerSecondSpinning = 1f;

	public ItemModWearable BackpackWearable;

	public const Flags FullySpunFlag = Flags.Reserved10;

	public const Flags SpinningFlag = Flags.Reserved11;

	public const Flags ShootingFlag = Flags.Reserved12;

	private const float bulletSpeed = 375f;

	private float lastSpinToggleTime = float.NegativeInfinity;

	public override ItemModWearable WearableWhileEquipped
	{
		get
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null && ownerPlayer.inventory.HasBackpackItem())
			{
				return null;
			}
			return BackpackWearable;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SpinUpWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 2014484270 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetSpinButton "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetSpinButton", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2014484270u, "Server_SetSpinButton", this, player, 8uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(2014484270u, "Server_SetSpinButton", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_SetSpinButton(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_SetSpinButton");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override float GetOverrideProjectileThickness(Projectile projectile)
	{
		return projectileThicknessOverride;
	}

	public bool IsSpinning()
	{
		return HasFlag(Flags.Reserved11);
	}

	public bool IsFullySpun()
	{
		return HasFlag(Flags.Reserved10);
	}

	public override void ServerReload()
	{
		SetFlag(Flags.Reserved12, b: false);
		base.ServerReload();
	}

	public override void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
		if (!ServerIsReloading())
		{
			SetFlag(Flags.Reserved12, b: true);
			((FacepunchBehaviour)this).Invoke((Action)StopMainTrigger, repeatDelay * 1.1f);
		}
		base.ServerUse(damageModifier, speedModifier, originOverride, useBulletThickness);
	}

	public override void SetGenericVisible(bool visible)
	{
		base.SetGenericVisible(visible);
		SetFlag(Flags.Reserved11, visible);
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null && ownerPlayer.IsNpc)
		{
			SetFlag(Flags.Reserved11, !IsDisabled());
		}
		else
		{
			SetFlag(Flags.Reserved11, b: false);
			SetFlag(Flags.Reserved10, b: false);
			lastSpinToggleTime = float.NegativeInfinity;
		}
		if (IsDisabled())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateConditionLoss);
			((FacepunchBehaviour)this).CancelInvoke((Action)SetFullySpun);
		}
		else
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateConditionLoss, 0f, 1f);
		}
	}

	public void UpdateConditionLoss()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!((Object)(object)ownerPlayer == (Object)null) && !ownerPlayer.IsNpc && IsSpinning())
		{
			GetOwnerItem()?.LoseCondition(conditionLossPerSecondSpinning);
		}
	}

	public void FireFakeBulletServer(float aimconeToUse)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		bool flag = (Object)(object)ownerPlayer != (Object)null;
		Vector3 val = (flag ? ownerPlayer.eyes.BodyForward() : MuzzlePoint.forward);
		Vector3 val2 = (flag ? ownerPlayer.eyes.position : MuzzlePoint.position);
		Vector3 inputVec = val;
		inputVec = AimConeUtil.GetModifiedAimConeDirection(aimconeToUse, inputVec);
		List<Connection> list = Pool.Get<List<Connection>>();
		foreach (Connection subscriber in net.group.subscribers)
		{
			BasePlayer basePlayer = subscriber.player as BasePlayer;
			if (!((Object)(object)basePlayer == (Object)null) && !ShouldNetworkTo(basePlayer))
			{
				list.Add(subscriber);
			}
		}
		if (list.Count > 0)
		{
			CreateProjectileEffectClientside(bulletEffect.resourcePath, val2 + inputVec * 2f, inputVec * 375f, 0, flag ? ownerPlayer.net.connection : null, IsSilenced(), forceClientsideEffects: true, list);
		}
		Pool.FreeUnmanaged<Connection>(ref list);
	}

	public void StopMainTrigger()
	{
		SetFlag(Flags.Reserved12, b: false);
	}

	public override void DidAttackServerside()
	{
		base.DidAttackServerside();
		SetFlag(Flags.Reserved12, b: true);
		((FacepunchBehaviour)this).Invoke((Action)StopMainTrigger, repeatDelay * 1.1f);
		if (ServerOcclusion.OcclusionEnabled)
		{
			DoFakeBullets();
		}
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(8uL)]
	private void Server_SetSpinButton(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (!(Time.realtimeSinceStartup < lastSpinToggleTime + 1f))
		{
			SetFlag(Flags.Reserved11, flag);
			((FacepunchBehaviour)this).CancelInvoke((Action)SetFullySpun);
			if (flag)
			{
				((FacepunchBehaviour)this).Invoke((Action)SetFullySpun, spinUpTime);
			}
			else
			{
				SetFlag(Flags.Reserved10, b: false);
			}
			lastSpinToggleTime = Time.realtimeSinceStartup;
		}
	}

	public void SetFullySpun()
	{
		SetFlag(Flags.Reserved10, b: true);
	}

	public void WarmupTick(bool wantsShoot)
	{
		if (wantsShoot)
		{
			SetFlag(Flags.Reserved11, b: true);
			if (!((FacepunchBehaviour)this).IsInvoking((Action)SetFullySpun))
			{
				((FacepunchBehaviour)this).Invoke((Action)SetFullySpun, spinUpTime);
			}
			lastSpinToggleTime = Time.realtimeSinceStartup;
		}
		else if (Time.realtimeSinceStartup > lastSpinToggleTime + 10f)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SetFullySpun);
			SetFlag(Flags.Reserved11, b: false);
			SetFlag(Flags.Reserved10, b: false);
		}
	}

	public bool CanShoot()
	{
		return IsFullySpun();
	}

	public void OnAddedRemovedToTurret(bool added)
	{
		SetFlag(Flags.Reserved11, b: false);
		SetFlag(Flags.Reserved10, b: false);
		if (added)
		{
			lastSpinToggleTime = float.NegativeInfinity;
			return;
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)UpdateConditionLoss);
		((FacepunchBehaviour)this).CancelInvoke((Action)SetFullySpun);
	}

	private void DoFakeBullets()
	{
		float num = repeatDelay / 4f;
		if (!((FacepunchBehaviour)this).IsInvoking((Action)FakeBullet1))
		{
			((FacepunchBehaviour)this).Invoke((Action)FakeBullet1, num);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)FakeBullet2))
		{
			((FacepunchBehaviour)this).Invoke((Action)FakeBullet2, num * 2f);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)FakeBullet3))
		{
			((FacepunchBehaviour)this).Invoke((Action)FakeBullet3, num * 3f);
		}
	}

	private void FakeBullet()
	{
		if (base.isServer)
		{
			FireFakeBulletServer(aimCone * 3f);
		}
	}

	private void FakeBullet1()
	{
		FakeBullet();
	}

	private void FakeBullet2()
	{
		FakeBullet();
	}

	private void FakeBullet3()
	{
		FakeBullet();
	}

	private void CancelFakeBullets()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)FakeBullet1);
		((FacepunchBehaviour)this).CancelInvoke((Action)FakeBullet2);
		((FacepunchBehaviour)this).CancelInvoke((Action)FakeBullet3);
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class SpookySpeaker : IOEntity
{
	public SoundPlayer soundPlayer;

	public float soundSpacing = 12f;

	public float soundSpacingRand = 5f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SpookySpeaker.OnRpcMessage", 0);
		try
		{
			if (rpc == 2523893445u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetWantsOn "));
				}
				TimeWarning val2 = TimeWarning.New("SetWantsOn", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2523893445u, "SetWantsOn", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage wantsOn = rPCMessage;
							SetWantsOn(wantsOn);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetWantsOn");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		UpdateInvokes();
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		if (inputSlot == 1)
		{
			SetTargetState(state: false);
		}
		if (inputSlot == 0)
		{
			SetTargetState(state: true);
		}
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	private void SetTargetState(bool state)
	{
		SetFlag(Flags.On, state);
		UpdateInvokes();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SetWantsOn(RPCMessage msg)
	{
		bool targetState = msg.read.Bit();
		SetTargetState(targetState);
	}

	public void UpdateInvokes()
	{
		if (IsOn())
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)SendPlaySound, soundSpacing, soundSpacing, soundSpacingRand);
			((FacepunchBehaviour)this).Invoke((Action)DelayedOff, 7200f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SendPlaySound);
			((FacepunchBehaviour)this).CancelInvoke((Action)DelayedOff);
		}
	}

	public void SendPlaySound()
	{
		ClientRPC(RpcTarget.NetworkGroup("PlaySpookySound"));
	}

	public void DelayedOff()
	{
		SetFlag(Flags.On, b: false);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

public class SprayCan : HeldEntity
{
	private enum SprayFailReason
	{
		None,
		MountedBlocked,
		IOConnection,
		LineOfSight,
		SkinNotOwned,
		InvalidItem
	}

	private struct ContainerSet
	{
		public int ContainerIndex;

		public uint PrefabId;
	}

	public struct IOPreserveInfo
	{
		public IOEntity connectedTo;

		public int connectedToSlot;

		public Vector3[] linePoints;

		public float[] slackLevels;

		public IOEntity.LineAnchor[] lineAnchors;

		public Vector3 worldSpaceLineEndRotation;

		public Vector3 originPosition;

		public Vector3 originRotation;

		public WireTool.WireColour wireColour;
	}

	private struct CodeLockPreserveInfo
	{
		public string code;

		public string guestCode;

		public bool isLocked;

		public List<ulong> whitelistPlayers;

		public List<ulong> guestPlayers;
	}

	private struct OtherEntityPreserveInfo
	{
		public IOPreserveInfo info;

		public IOEntity connectedEntity;

		public int index;

		public bool isOutput;
	}

	public struct ChildPreserveInfo
	{
		public BaseEntity TargetEntity;

		public uint TargetBone;

		public Vector3 LocalPosition;

		public Quaternion LocalRotation;
	}

	public const float MaxFreeSprayDistanceFromStart = 10f;

	public const float MaxFreeSprayStartingDistance = 3f;

	private SprayCanSpray_Freehand paintingLine;

	public const Flags IsFreeSpraying = Flags.Reserved1;

	public SoundDefinition SpraySound;

	public GameObjectRef SkinSelectPanel;

	public float SprayCooldown = 2f;

	public float ConditionLossPerSpray = 10f;

	public float ConditionLossPerReskin = 10f;

	public GameObjectRef LinePrefab;

	public Color[] SprayColours = (Color[])(object)new Color[0];

	public float[] SprayWidths = new float[3] { 0.1f, 0.2f, 0.3f };

	public ParticleSystem worldSpaceSprayFx;

	public GameObjectRef ReskinEffect;

	public ItemDefinition SprayDecalItem;

	public GameObjectRef SprayDecalEntityRef;

	public SteamInventoryItem FreeSprayUnlockItem;

	public MinMaxGradient DecalSprayGradient;

	public SoundDefinition SprayLoopDef;

	public static Phrase FreeSprayNamePhrase = new Phrase("freespray_radial", "Free Spray");

	public static Phrase FreeSprayDescPhrase = new Phrase("freespray_radial_desc", "Spray shapes freely with various colors");

	public static Phrase BuildingSkinColourPhrase = new Phrase("buildingskin_colour", "Set colour");

	public static Phrase BuildingSkinColourDescPhrase = new Phrase("buildingskin_colour_desc", "Set the block to the highlighted colour");

	public static readonly Phrase DoorMustBeClosed = new Phrase("error_doormustbeclosed", "Door must be closed");

	public static readonly Phrase NeedDoorAccess = new Phrase("error_needdooraccess", "Need door access");

	public static readonly Phrase CannotReskinThatDoor = new Phrase("error_cannotreskindoor", "Cannot reskin that door");

	public static readonly Phrase RecentlyDamaged = new Phrase("error_reskin_recentlydamaged", "Cannot reskin an object that was recently damaged");

	public static readonly Phrase ExplosivesActive = new Phrase("error_explosivesactive", "Cannot reskin an object with explosives attached");

	public static readonly Phrase PlayerInAir = new Phrase("error_playerinair", "You must be on the ground");

	public static readonly Phrase BlockedByPlayer = new Phrase("error_blockedbyplayer_reskin", "Blocked by intersecting player");

	public static readonly Phrase BlockedBySomething = new Phrase("error_blockedbysomething", "Blocked by something");

	public static readonly Phrase PlayerIsMounted = new Phrase("error_playerismounted", "Player {0} is mounted");

	[FormerlySerializedAs("ShippingCOntainerColourLookup")]
	public ConstructionSkin_ColourLookup ShippingContainerColourLookup;

	public const string ENEMY_BASE_STAT = "sprayed_enemy_base";

	private Phrase lastSprayError;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SprayCan.OnRpcMessage", 0);
		try
		{
			if (rpc == 3490735573u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BeginFreehandSpray "));
				}
				TimeWarning val2 = TimeWarning.New("BeginFreehandSpray", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3490735573u, "BeginFreehandSpray", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							BeginFreehandSpray(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in BeginFreehandSpray");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 151738090 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ChangeItemSkin "));
				}
				TimeWarning val2 = TimeWarning.New("ChangeItemSkin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(151738090u, "ChangeItemSkin", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(151738090u, "ChangeItemSkin", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ChangeItemSkin(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ChangeItemSkin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 688080035 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ChangeWallpaper "));
				}
				TimeWarning val2 = TimeWarning.New("ChangeWallpaper", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(688080035u, "ChangeWallpaper", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(688080035u, "ChangeWallpaper", this, player))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(688080035u, "ChangeWallpaper", this, player, 5f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							ChangeWallpaper(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in ChangeWallpaper");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 396000799 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - CreateSpray "));
				}
				TimeWarning val2 = TimeWarning.New("CreateSpray", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(396000799u, "CreateSpray", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							CreateSpray(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in CreateSpray");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 14517645 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetBlockColourId "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetBlockColourId", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(14517645u, "Server_SetBlockColourId", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(14517645u, "Server_SetBlockColourId", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							Server_SetBlockColourId(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in Server_SetBlockColourId");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void BeginFreehandSpray(RPCMessage msg)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		if (!IsBusy() && CanSprayFreehand(msg.player))
		{
			Vector3 val = msg.read.Vector3();
			Vector3 atNormal = msg.read.Vector3();
			int num = msg.read.Int32();
			int num2 = msg.read.Int32();
			if (num >= 0 && num < SprayColours.Length && num2 >= 0 && num2 < SprayWidths.Length && !(Vector3.Distance(val, ((Component)GetOwnerPlayer()).transform.position) > 3f))
			{
				SprayCanSpray_Freehand sprayCanSpray_Freehand = GameManager.server.CreateEntity(LinePrefab.resourcePath, val, Quaternion.identity) as SprayCanSpray_Freehand;
				sprayCanSpray_Freehand.AddInitialPoint(atNormal);
				sprayCanSpray_Freehand.SetColour(SprayColours[num]);
				sprayCanSpray_Freehand.SetWidth(SprayWidths[num2]);
				sprayCanSpray_Freehand.EnableChanges(msg.player);
				sprayCanSpray_Freehand.Spawn();
				paintingLine = sprayCanSpray_Freehand;
				ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), num);
				SetFlag(Flags.Busy, b: true);
				SetFlag(Flags.Reserved1, b: true);
				CheckAchievementPosition(val);
			}
		}
	}

	public void ClearPaintingLine(bool allowNewSprayImmediately)
	{
		paintingLine = null;
		if (!base.UsingInfiniteAmmoCheat)
		{
			LoseCondition(ConditionLossPerSpray);
		}
		if (allowNewSprayImmediately)
		{
			ClearBusy();
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)ClearBusy, 0.1f);
		}
	}

	public bool CanSprayFreehand(BasePlayer player)
	{
		if (player.UnlockAllSkins)
		{
			return true;
		}
		if ((Object)(object)FreeSprayUnlockItem != (Object)null)
		{
			if (!player.blueprints.steamInventory.HasItem(FreeSprayUnlockItem.id))
			{
				return FreeSprayUnlockItem.HasUnlocked(player.userID);
			}
			return true;
		}
		return false;
	}

	private bool IsSprayBlockedByTrigger(Vector3 pos)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return true;
		}
		TriggerNoSpray triggerNoSpray = ownerPlayer.FindTrigger<TriggerNoSpray>();
		if ((Object)(object)triggerNoSpray == (Object)null)
		{
			return false;
		}
		return !triggerNoSpray.IsPositionValid(pos);
	}

	private bool ValidateEntityAndSkin(BasePlayer player, BaseNetworkable targetEnt, int targetSkin)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		if (IsBusy())
		{
			return false;
		}
		if ((Object)(object)player == (Object)null || !player.CanBuild())
		{
			return false;
		}
		if (!player.IsOnGround())
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInAir, false);
			return false;
		}
		bool unlockAllSkins = player.UnlockAllSkins;
		if (targetSkin != 0 && !unlockAllSkins && !player.blueprints.CheckSkinOwnership(targetSkin, player.userID))
		{
			SprayFailResponse(SprayFailReason.SkinNotOwned);
			return false;
		}
		if ((Object)(object)targetEnt != (Object)null && targetEnt is BaseEntity baseEntity)
		{
			OBB val = baseEntity.WorldSpaceBounds();
			Vector3 position = ((OBB)(ref val)).ClosestPoint(player.eyes.position);
			if (!player.IsVisible(position, 3f))
			{
				SprayFailResponse(SprayFailReason.LineOfSight);
				return false;
			}
			if (targetEnt is Door door)
			{
				if (!door.GetPlayerLockPermission(player))
				{
					player.ShowToast(GameTip.Styles.Error, NeedDoorAccess, false);
					return false;
				}
				if (door.IsOpen())
				{
					player.ShowToast(GameTip.Styles.Error, DoorMustBeClosed, false);
					return false;
				}
				if ((Object)(object)door.GetParentEntity() != (Object)null && door.GetParentEntity() is HotAirBalloonArmor)
				{
					player.ShowToast(GameTip.Styles.Error, CannotReskinThatDoor, false);
					return false;
				}
			}
			if (targetEnt is BaseCombatEntity { SecondsSinceAttacked: <30f } baseCombatEntity)
			{
				player.ShowToast(GameTip.Styles.Error, RecentlyDamaged, false, (30f - baseCombatEntity.SecondsSinceAttacked).ToString("N0"));
				return false;
			}
			foreach (BaseEntity child in targetEnt.children)
			{
				if (child is TimedExplosive)
				{
					player.ShowToast(GameTip.Styles.Error, ExplosivesActive, false);
					return false;
				}
			}
			if (targetEnt is SimpleBuildingBlock || targetEnt is Gate)
			{
				PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					Vis.Entities(baseEntity.WorldSpaceBounds(), (List<BaseEntity>)(object)val2, -2145386240, (QueryTriggerInteraction)2);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
					{
						if (!((Object)(object)item == (Object)null) && !item.isClient && !((Object)(object)item == (Object)(object)baseEntity) && !(item is BuildingBlock) && !(item is SimpleBuildingBlock) && !(item is Door) && !(item is BaseOven) && !(item is Barricade))
						{
							player.ShowBlockedByEntityToast(item, BlockedBySomething);
							return false;
						}
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
		}
		if ((Object)(object)targetEnt != (Object)null && targetEnt is BaseLock baseLock)
		{
			return baseLock.GetPlayerLockPermission(player);
		}
		return true;
	}

	private bool ValidateWallpaperReskin(BasePlayer player, BuildingBlock block, int side, int targetSkin)
	{
		if ((Object)(object)player == (Object)null || !player.CanBuild())
		{
			return false;
		}
		if (!player.IsOnGround())
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInAir, false);
			return false;
		}
		bool unlockAllSkins = player.UnlockAllSkins;
		if (targetSkin != 0 && !unlockAllSkins && !player.blueprints.CheckSkinOwnership(targetSkin, player.userID))
		{
			SprayFailResponse(SprayFailReason.SkinNotOwned);
			return false;
		}
		if (!block.HasWallpaper(side))
		{
			return false;
		}
		if (!block.CanSeeWallpaperSocket(player, side))
		{
			return false;
		}
		return true;
	}

	private void SprayFailResponse(SprayFailReason reason)
	{
		ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 0, (int)reason);
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	private void ChangeItemSkin(RPCMessage msg)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b39: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0413: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_0426: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_066a: Unknown result type (might be due to invalid IL or missing references)
		//IL_066c: Unknown result type (might be due to invalid IL or missing references)
		//IL_065f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0686: Unknown result type (might be due to invalid IL or missing references)
		//IL_068b: Unknown result type (might be due to invalid IL or missing references)
		//IL_068d: Unknown result type (might be due to invalid IL or missing references)
		//IL_067b: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a87: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a9f: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId uid = msg.read.EntityID();
		int targetSkin = msg.read.Int32();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		if (!ValidateEntityAndSkin(msg.player, baseNetworkable, targetSkin))
		{
			return;
		}
		if ((Object)(object)baseNetworkable != (Object)null)
		{
			BaseEntity baseEntity2 = baseNetworkable as BaseEntity;
			if (baseEntity2 != null)
			{
				if (!GetItemDefinitionForEntity(baseEntity2, out var def, useRedirect: false))
				{
					FailResponse(SprayFailReason.InvalidItem);
					return;
				}
				ItemDefinition itemDefinition = null;
				ulong num = ItemDefinition.FindSkin(((Object)(object)def.isRedirectOf != (Object)null) ? def.isRedirectOf.itemid : def.itemid, targetSkin);
				ItemSkinDirectory.Skin skin = (((Object)(object)def.isRedirectOf != (Object)null) ? def.isRedirectOf : def).skins.FirstOrDefault((ItemSkinDirectory.Skin x) => x.id == targetSkin);
				if (Interface.CallHook("OnEntityReskin", (object)baseEntity2, (object)skin, (object)msg.player) != null)
				{
					return;
				}
				if ((Object)(object)skin.invItem != (Object)null && skin.invItem is ItemSkin itemSkin)
				{
					if ((Object)(object)itemSkin.Redirect != (Object)null)
					{
						itemDefinition = itemSkin.Redirect;
					}
					else if (Object.op_Implicit((Object)(object)def) && (Object)(object)def.isRedirectOf != (Object)null)
					{
						itemDefinition = def.isRedirectOf;
					}
				}
				else if ((Object)(object)def.isRedirectOf != (Object)null || (Object.op_Implicit((Object)(object)def) && (Object)(object)def.isRedirectOf != (Object)null))
				{
					itemDefinition = def.isRedirectOf;
				}
				if ((Object)(object)itemDefinition == (Object)null)
				{
					baseEntity2.skinID = num;
					baseEntity2.SendNetworkUpdate();
					Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);
				}
				else
				{
					if (!CanEntityBeRespawned(baseEntity2, out var reason2, out var culpritPlayer))
					{
						if (reason2 == SprayFailReason.MountedBlocked)
						{
							lastSprayError = Phrase.op_Implicit(string.Format(PlayerIsMounted.translated, NameHelper.GetPlayerNameStreamSafe(msg.player, culpritPlayer)));
							msg.player.ShowToast(GameTip.Styles.Error, lastSprayError, false);
						}
						FailResponse(reason2);
						return;
					}
					if (!GetEntityPrefabPath(itemDefinition, out var resourcePath))
					{
						Debug.LogWarning((object)("Cannot find resource path of redirect entity to spawn! " + ((Object)((Component)itemDefinition).gameObject).name));
						FailResponse(SprayFailReason.InvalidItem);
						return;
					}
					if (SimpleUpgrade.IsUpgradeBlocked(baseEntity2, itemDefinition, msg.player))
					{
						msg.player.ShowToast(GameTip.Styles.Error, BlockedByPlayer, false);
						return;
					}
					CodeLockPreserveInfo codeLockPreserveInfo = default(CodeLockPreserveInfo);
					if (baseEntity2 is CodeLock codeLock)
					{
						codeLockPreserveInfo.code = codeLock.code;
						codeLockPreserveInfo.guestCode = codeLock.guestCode;
						codeLockPreserveInfo.isLocked = codeLock.IsLocked();
						codeLockPreserveInfo.whitelistPlayers = Pool.Get<List<ulong>>();
						codeLockPreserveInfo.guestPlayers = Pool.Get<List<ulong>>();
						codeLockPreserveInfo.whitelistPlayers.AddRange(codeLock.whitelistPlayers);
						codeLockPreserveInfo.guestPlayers.AddRange(codeLock.guestPlayers);
					}
					Vector3 localPosition = ((Component)baseEntity2).transform.localPosition;
					Quaternion localRotation = ((Component)baseEntity2).transform.localRotation;
					BaseEntity baseEntity3 = baseEntity2.GetParentEntity();
					float health = baseEntity2.Health();
					EntityRef[] slots = baseEntity2.GetSlots();
					ulong ownerID = baseEntity2.OwnerID;
					float lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);
					int soilSaturation = ((baseEntity2 is PlanterBox planterBox) ? planterBox.soilSaturation : 0);
					bool flag = baseEntity2 is DecayEntity decayEntity && decayEntity.HasFlag(Flags.Reserved2);
					HashSet<PlayerNameID> hashSet = null;
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge)
					{
						hashSet = new HashSet<PlayerNameID>(buildingPrivlidge.authorizedPlayers);
					}
					bool flag2 = baseEntity2 is Door || baseEntity2 is BuildingPrivlidge || baseEntity2 is BoxStorage || baseEntity2 is PlanterBox;
					Dictionary<ContainerSet, List<Item>> dictionary2 = new Dictionary<ContainerSet, List<Item>>();
					SaveEntityStorage(baseEntity2, dictionary2, 0);
					List<ChildPreserveInfo> list = Pool.Get<List<ChildPreserveInfo>>();
					if (flag2)
					{
						foreach (BaseEntity child in baseEntity2.children)
						{
							list.Add(new ChildPreserveInfo
							{
								TargetEntity = child,
								TargetBone = child.parentBone,
								LocalPosition = ((Component)child).transform.localPosition,
								LocalRotation = ((Component)child).transform.localRotation
							});
						}
						foreach (ChildPreserveInfo item in list)
						{
							item.TargetEntity.SetParent(null, worldPositionStays: true);
						}
					}
					else
					{
						for (int i = 0; i < baseEntity2.children.Count; i++)
						{
							SaveEntityStorage(baseEntity2.children[i], dictionary2, -1);
						}
					}
					IOPreserveInfo[] array = null;
					IOPreserveInfo[] array2 = null;
					List<OtherEntityPreserveInfo> list2 = new List<OtherEntityPreserveInfo>();
					if (baseEntity2 is IOEntity iOEntity)
					{
						array = new IOPreserveInfo[iOEntity.outputs.Length];
						for (int j = 0; j < iOEntity.outputs.Length; j++)
						{
							IOEntity.IOSlot iOSlot = iOEntity.outputs[j];
							IOEntity iOEntity2 = iOSlot.connectedTo.Get();
							if ((Object)(object)iOEntity2 != (Object)null)
							{
								iOSlot.Preserve(ref array[j]);
								IOPreserveInfo target = default(IOPreserveInfo);
								iOEntity2.inputs[iOSlot.connectedToSlot].Preserve(ref target);
								list2.Add(new OtherEntityPreserveInfo
								{
									info = target,
									connectedEntity = iOEntity2,
									index = iOSlot.connectedToSlot,
									isOutput = false
								});
							}
						}
						array2 = new IOPreserveInfo[iOEntity.inputs.Length];
						for (int k = 0; k < iOEntity.inputs.Length; k++)
						{
							IOEntity.IOSlot iOSlot2 = iOEntity.inputs[k];
							IOEntity iOEntity3 = iOSlot2.connectedTo.Get();
							if ((Object)(object)iOEntity3 != (Object)null)
							{
								iOSlot2.Preserve(ref array2[k]);
								IOPreserveInfo target2 = default(IOPreserveInfo);
								iOEntity3.outputs[iOSlot2.connectedToSlot].Preserve(ref target2);
								list2.Add(new OtherEntityPreserveInfo
								{
									info = target2,
									connectedEntity = iOEntity3,
									index = iOSlot2.connectedToSlot,
									isOutput = true
								});
							}
						}
					}
					baseEntity2.Kill();
					baseEntity2 = GameManager.server.CreateEntity(resourcePath, ((Object)(object)baseEntity3 != (Object)null) ? ((Component)baseEntity3).transform.TransformPoint(localPosition) : localPosition, ((Object)(object)baseEntity3 != (Object)null) ? (((Component)baseEntity3).transform.rotation * localRotation) : localRotation);
					baseEntity2.SetParent(baseEntity3);
					((Component)baseEntity2).transform.localPosition = localPosition;
					((Component)baseEntity2).transform.localRotation = localRotation;
					baseEntity2.OwnerID = ownerID;
					if (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) && (Object)(object)def2.isRedirectOf != (Object)null)
					{
						baseEntity2.skinID = 0uL;
					}
					else
					{
						baseEntity2.skinID = num;
					}
					if (baseEntity2 is DecayEntity decayEntity2)
					{
						decayEntity2.AttachToBuilding(null);
					}
					if (baseEntity2 is PlanterBox planterBox2)
					{
						planterBox2.soilSaturation = soilSaturation;
					}
					baseEntity2.Spawn();
					if (baseEntity2 is IOEntity iOEntity4)
					{
						if (array != null)
						{
							for (int l = 0; l < iOEntity4.outputs.Length; l++)
							{
								iOEntity4.outputs[l].Restore(array[l]);
							}
						}
						if (array2 != null)
						{
							for (int m = 0; m < iOEntity4.inputs.Length; m++)
							{
								if ((Object)(object)array2[m].connectedTo != (Object)null)
								{
									iOEntity4.inputs[m].Restore(array2[m]);
								}
							}
						}
						PooledList<IOEntity> val = Pool.Get<PooledList<IOEntity>>();
						try
						{
							foreach (OtherEntityPreserveInfo item2 in list2)
							{
								IOPreserveInfo info = item2.info;
								info.connectedTo = iOEntity4;
								if ((Object)(object)item2.connectedEntity != (Object)null)
								{
									if (item2.isOutput)
									{
										item2.connectedEntity.outputs[item2.index].Restore(info);
										((List<IOEntity>)(object)val).Add(item2.connectedEntity);
									}
									else
									{
										item2.connectedEntity.inputs[item2.index].Restore(info);
										((List<IOEntity>)(object)val).Add(item2.connectedEntity);
									}
								}
							}
							foreach (IOEntity item3 in (List<IOEntity>)(object)val)
							{
								item3.SendNetworkUpdate();
							}
						}
						finally
						{
							((IDisposable)val)?.Dispose();
						}
					}
					if (baseEntity2 is BaseCombatEntity baseCombatEntity2)
					{
						baseCombatEntity2.SetHealth(health);
						baseCombatEntity2.lastAttackedTime = lastAttackedTime;
					}
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge2 && hashSet != null)
					{
						buildingPrivlidge2.authorizedPlayers = hashSet;
					}
					if (baseEntity2 is CodeLock codeLock2)
					{
						baseEntity3.SetSlot(Slot.Lock, codeLock2);
						codeLock2.SetParent(baseEntity3, baseEntity3.GetSlotAnchorName(Slot.Lock));
						codeLock2.code = codeLockPreserveInfo.code;
						codeLock2.guestCode = codeLockPreserveInfo.guestCode;
						codeLock2.SetFlag(Flags.Locked, codeLockPreserveInfo.isLocked);
						codeLock2.whitelistPlayers.AddRange(codeLockPreserveInfo.whitelistPlayers);
						codeLock2.guestPlayers.AddRange(codeLockPreserveInfo.guestPlayers);
						Pool.FreeUnmanaged<ulong>(ref codeLockPreserveInfo.whitelistPlayers);
						Pool.FreeUnmanaged<ulong>(ref codeLockPreserveInfo.guestPlayers);
					}
					if (dictionary2.Count > 0)
					{
						RestoreEntityStorage(baseEntity2, 0, dictionary2);
						if (!flag2)
						{
							for (int n = 0; n < baseEntity2.children.Count; n++)
							{
								RestoreEntityStorage(baseEntity2.children[n], -1, dictionary2);
							}
						}
						foreach (KeyValuePair<ContainerSet, List<Item>> item4 in dictionary2)
						{
							foreach (Item item5 in item4.Value)
							{
								Debug.Log((object)$"Deleting {item5} as it has no new container");
								item5.Remove();
							}
						}
						Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);
					}
					if (flag2)
					{
						foreach (ChildPreserveInfo item6 in list)
						{
							item6.TargetEntity.SetParent(baseEntity2, item6.TargetBone, worldPositionStays: true);
							((Component)item6.TargetEntity).transform.localPosition = item6.LocalPosition;
							((Component)item6.TargetEntity).transform.localRotation = item6.LocalRotation;
							item6.TargetEntity.SendNetworkUpdate();
						}
						baseEntity2.SetSlots(slots);
					}
					Pool.FreeUnmanaged<ChildPreserveInfo>(ref list);
					if (baseEntity2 is ISprayCallback sprayCallback)
					{
						sprayCallback.OnReskinned(msg.player);
					}
					if (baseEntity2 is DecayEntity decayEntity3 && !flag)
					{
						decayEntity3.StopBeingDemolishable();
					}
				}
				Interface.CallHook("OnEntityReskinned", (object)baseEntity2, (object)skin, (object)msg.player);
				ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 1, baseEntity2.net.ID);
			}
		}
		if (!base.UsingInfiniteAmmoCheat)
		{
			LoseCondition(ConditionLossPerReskin);
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ClearBusy, SprayCooldown);
		void FailResponse(SprayFailReason reason)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 0, (int)reason);
		}
		static void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary<ContainerSet, List<Item>> copy)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity2)
			{
				ContainerSet containerSet2 = default(ContainerSet);
				containerSet2.ContainerIndex = index;
				containerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key2 = containerSet2;
				if (copy.ContainsKey(key2))
				{
					foreach (Item item7 in copy[key2])
					{
						item7.MoveToContainer(itemContainerEntity2.inventory);
					}
					copy.Remove(key2);
				}
			}
		}
		static void SaveEntityStorage(BaseEntity baseEntity, Dictionary<ContainerSet, List<Item>> dictionary, int index)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity)
			{
				ContainerSet containerSet = default(ContainerSet);
				containerSet.ContainerIndex = index;
				containerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key = containerSet;
				if (!dictionary.ContainsKey(key))
				{
					dictionary.Add(key, new List<Item>());
					foreach (Item item8 in itemContainerEntity.inventory.itemList)
					{
						dictionary[key].Add(item8);
					}
					{
						foreach (Item item9 in dictionary[key])
						{
							item9.RemoveFromContainer();
						}
						return;
					}
				}
				Debug.Log((object)"Multiple containers with the same prefab id being added during vehicle reskin");
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server.MaxDistance(5f)]
	private void ChangeWallpaper(RPCMessage msg)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId uid = msg.read.EntityID();
		int targetSkin = msg.read.Int32();
		int side = ((!msg.read.Bool()) ? 1 : 0);
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		if (!(baseNetworkable is BuildingBlock buildingBlock) || !buildingBlock.HasWallpaper(side))
		{
			SprayFailResponse(SprayFailReason.InvalidItem);
		}
		else if (ValidateWallpaperReskin(msg.player, baseNetworkable as BuildingBlock, side, targetSkin))
		{
			ulong id = ItemDefinition.FindSkin(WallpaperSettings.GetItemDefForCategory(WallpaperPlanner.Settings.GetCategory(buildingBlock, side)).itemid, targetSkin);
			buildingBlock.SetWallpaper(id, side);
			Analytics.Azure.OnWallpaperPlaced(msg.player, buildingBlock, id, side, reskin: true);
			ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 1, buildingBlock.net.ID);
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearBusy, SprayCooldown);
		}
	}

	private bool GetEntityPrefabPath(ItemDefinition def, out string resourcePath)
	{
		resourcePath = string.Empty;
		ItemModDeployable itemModDeployable = default(ItemModDeployable);
		if (((Component)def).TryGetComponent<ItemModDeployable>(ref itemModDeployable))
		{
			resourcePath = itemModDeployable.entityPrefab.resourcePath;
			return true;
		}
		ItemModEntity itemModEntity = default(ItemModEntity);
		if (((Component)def).TryGetComponent<ItemModEntity>(ref itemModEntity))
		{
			resourcePath = itemModEntity.entityPrefab.resourcePath;
			return true;
		}
		ItemModEntityReference itemModEntityReference = default(ItemModEntityReference);
		if (((Component)def).TryGetComponent<ItemModEntityReference>(ref itemModEntityReference))
		{
			resourcePath = itemModEntityReference.entityPrefab.resourcePath;
			return true;
		}
		return false;
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void CreateSpray(RPCMessage msg)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		if (IsBusy())
		{
			return;
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ClearBusy, SprayCooldown);
		Vector3 val = msg.read.Vector3();
		Vector3 val2 = msg.read.Vector3();
		Vector3 val3 = msg.read.Vector3();
		int num = msg.read.Int32();
		if (Vector3.Distance(val, ((Component)this).transform.position) > 4.5f)
		{
			return;
		}
		Plane val4 = default(Plane);
		((Plane)(ref val4))..ctor(val2, val);
		Vector3 val5 = ((Plane)(ref val4)).ClosestPointOnPlane(val3) - val;
		Quaternion val6 = Quaternion.LookRotation(((Vector3)(ref val5)).normalized, val2);
		val6 *= Quaternion.Euler(0f, 0f, 90f);
		bool flag = false;
		if (msg.player.IsDeveloper)
		{
			flag = true;
		}
		if (num != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(num, msg.player.userID))
		{
			Debug.Log((object)$"SprayCan.ChangeItemSkin player does not have item :{num}:");
		}
		else if (Interface.CallHook("OnSprayCreate", (object)this, (object)val, (object)val6) == null)
		{
			ulong num2 = ItemDefinition.FindSkin(SprayDecalItem.itemid, num);
			BaseEntity baseEntity = GameManager.server.CreateEntity(SprayDecalEntityRef.resourcePath, val, val6);
			baseEntity.skinID = num2;
			baseEntity.OnDeployed(null, GetOwnerPlayer(), GetItem());
			baseEntity.Spawn();
			CheckAchievementPosition(val);
			if (!base.UsingInfiniteAmmoCheat)
			{
				LoseCondition(ConditionLossPerSpray);
			}
		}
	}

	private void CheckAchievementPosition(Vector3 pos)
	{
	}

	private void LoseCondition(float amount)
	{
		GetOwnerItem()?.LoseCondition(amount);
	}

	public void ClearBusy()
	{
		SetFlag(Flags.Busy, b: false);
		SetFlag(Flags.Reserved1, b: false);
	}

	public override void OnHeldChanged()
	{
		if (IsDisabled())
		{
			ClearBusy();
			if ((Object)(object)paintingLine != (Object)null)
			{
				paintingLine.Kill();
			}
			paintingLine = null;
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Server_SetBlockColourId(RPCMessage msg)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId uid = msg.read.EntityID();
		uint num = msg.read.UInt32();
		BasePlayer player = msg.player;
		SetFlag(Flags.Busy, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ClearBusy, 0.1f);
		if (!((Object)(object)player == (Object)null) && player.CanBuild())
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			BuildingBlock buildingBlock = BaseNetworkable.serverEntities.Find(uid) as BuildingBlock;
			if ((Object)(object)buildingBlock != (Object)null && !(player.Distance((BaseEntity)buildingBlock) > 4f))
			{
				uint customColour = buildingBlock.customColour;
				buildingBlock.SetCustomColour(num);
				Analytics.Azure.OnBuildingBlockColorChanged(ownerPlayer, buildingBlock, customColour, num);
			}
		}
	}

	private bool CanEntityBeRespawned(BaseEntity targetEntity, out SprayFailReason reason, out BasePlayer culpritPlayer)
	{
		if (targetEntity is BaseMountable baseMountable && baseMountable.AnyMounted())
		{
			reason = SprayFailReason.MountedBlocked;
			culpritPlayer = baseMountable.GetMounted();
			return false;
		}
		if (targetEntity.isServer && targetEntity is BaseVehicle baseVehicle && (baseVehicle.HasDriver() || baseVehicle.AnyMounted()))
		{
			reason = SprayFailReason.MountedBlocked;
			culpritPlayer = baseVehicle.GetMounted();
			return false;
		}
		reason = SprayFailReason.None;
		culpritPlayer = null;
		return true;
	}

	public static bool GetItemDefinitionForEntity(BaseEntity be, out ItemDefinition def, bool useRedirect = true)
	{
		def = null;
		if (be is BaseCombatEntity baseCombatEntity)
		{
			if (baseCombatEntity.pickup.enabled && (Object)(object)baseCombatEntity.pickup.itemTarget != (Object)null)
			{
				def = baseCombatEntity.pickup.itemTarget;
			}
			else if (baseCombatEntity.repair.enabled && (Object)(object)baseCombatEntity.repair.itemTarget != (Object)null)
			{
				def = baseCombatEntity.repair.itemTarget;
			}
		}
		if (be is CodeLock codeLock)
		{
			def = codeLock.itemType;
		}
		if (useRedirect && (Object)(object)def != (Object)null && (Object)(object)def.isRedirectOf != (Object)null)
		{
			def = def.isRedirectOf;
		}
		return (Object)(object)def != (Object)null;
	}
}


private enum SprayFailReason
{
	None,
	MountedBlocked,
	IOConnection,
	LineOfSight,
	SkinNotOwned,
	InvalidItem
}


private struct ContainerSet
{
	public int ContainerIndex;

	public uint PrefabId;
}


using UnityEngine;

public struct IOPreserveInfo
{
	public IOEntity connectedTo;

	public int connectedToSlot;

	public Vector3[] linePoints;

	public float[] slackLevels;

	public IOEntity.LineAnchor[] lineAnchors;

	public Vector3 worldSpaceLineEndRotation;

	public Vector3 originPosition;

	public Vector3 originRotation;

	public WireTool.WireColour wireColour;
}


using System.Collections.Generic;

private struct CodeLockPreserveInfo
{
	public string code;

	public string guestCode;

	public bool isLocked;

	public List<ulong> whitelistPlayers;

	public List<ulong> guestPlayers;
}


private struct OtherEntityPreserveInfo
{
	public IOPreserveInfo info;

	public IOEntity connectedEntity;

	public int index;

	public bool isOutput;
}


using UnityEngine;

public struct ChildPreserveInfo
{
	public BaseEntity TargetEntity;

	public uint TargetBone;

	public Vector3 LocalPosition;

	public Quaternion LocalRotation;
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class SprayCanSpray : DecayEntity, ISplashable
{
	private DateTime sprayTimestamp;

	[NonSerialized]
	public ulong sprayedByPlayer;

	public static ListHashSet<SprayCanSpray> AllSprays = new ListHashSet<SprayCanSpray>();

	[NonSerialized]
	public int splashThreshold;

	public override bool BypassInsideDecayMultiplier => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SprayCanSpray.OnRpcMessage", 0);
		try
		{
			if (rpc == 2774110739u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestWaterClear "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestWaterClear", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_RequestWaterClear(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_RequestWaterClear");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.spray == null)
		{
			info.msg.spray = Pool.Get<Spray>();
		}
		info.msg.spray.sprayedBy = sprayedByPlayer;
		info.msg.spray.timestamp = sprayTimestamp.ToBinary();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.spray != null)
		{
			sprayedByPlayer = info.msg.spray.sprayedBy;
			sprayTimestamp = DateTime.FromBinary(info.msg.spray.timestamp);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		sprayTimestamp = DateTime.Now;
		sprayedByPlayer = deployedBy.userID;
		if (Global.MaxSpraysPerPlayer > 0 && sprayedByPlayer != 0L)
		{
			int num = -1;
			DateTime now = DateTime.Now;
			int num2 = 0;
			for (int i = 0; i < AllSprays.Count; i++)
			{
				if (AllSprays[i].sprayedByPlayer == sprayedByPlayer)
				{
					num2++;
					if (num == -1 || AllSprays[i].sprayTimestamp < now)
					{
						num = i;
						now = AllSprays[i].sprayTimestamp;
					}
				}
			}
			if (num2 >= Global.MaxSpraysPerPlayer && num != -1)
			{
				AllSprays[num].Kill();
			}
		}
		if ((Object)(object)deployedBy == (Object)null || !deployedBy.IsBuildingAuthed())
		{
			((FacepunchBehaviour)this).Invoke((Action)ApplyOutOfAuthConditionPenalty, 1f);
		}
	}

	public void ApplyOutOfAuthConditionPenalty()
	{
		if (!IsFullySpawned())
		{
			((FacepunchBehaviour)this).Invoke((Action)ApplyOutOfAuthConditionPenalty, 1f);
			return;
		}
		float amount = MaxHealth() * (1f - Global.SprayOutOfAuthMultiplier);
		Hurt(amount, DamageType.Decay);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)RainCheck, 60f, 180f, 30f);
		if (!AllSprays.Contains(this))
		{
			AllSprays.Add(this);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (AllSprays.Contains(this))
		{
			AllSprays.Remove(this);
		}
	}

	public void RainCheck()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		if (Climate.GetRain(((Component)this).transform.position) > 0f && IsOutside())
		{
			Kill();
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		return amount > splashThreshold;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		if (!base.IsDestroyed)
		{
			Kill();
		}
		return 1;
	}

	[RPC_Server]
	private void Server_RequestWaterClear(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && Menu_WaterClear_ShowIf(player) && Interface.CallHook("OnSprayRemove", (object)this, (object)player) == null)
		{
			Kill();
		}
	}

	public bool Menu_WaterClear_ShowIf(BasePlayer player)
	{
		if ((Object)(object)player.GetHeldEntity() != (Object)null && player.GetHeldEntity() is BaseLiquidVessel baseLiquidVessel)
		{
			return baseLiquidVessel.AmountHeld() > 0;
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SprayCanSpray_Freehand : SprayCanSpray
{
	public AlignedLineDrawer LineDrawer;

	public List<AlignedLineDrawer.LinePoint> LinePoints = new List<AlignedLineDrawer.LinePoint>();

	public Color colour = Color.white;

	public float width;

	public EntityRef<BasePlayer> editingPlayer;

	public GroundWatch groundWatch;

	public MeshCollider meshCollider;

	public const int MaxLinePointLength = 60;

	public const float SimplifyTolerance = 0.008f;

	private bool AcceptingChanges => editingPlayer.IsValid(serverside: true);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SprayCanSpray_Freehand.OnRpcMessage", 0);
		try
		{
			if (rpc == 2020094435 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_AddPointMidSpray "));
				}
				TimeWarning val2 = TimeWarning.New("Server_AddPointMidSpray", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_AddPointMidSpray(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_AddPointMidSpray");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 117883393 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_FinishEditing "));
				}
				TimeWarning val2 = TimeWarning.New("Server_FinishEditing", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						Server_FinishEditing(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in Server_FinishEditing");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool ShouldNetworkOwnerInfo()
	{
		return true;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (LinePoints == null || LinePoints.Count == 0)
		{
			Kill();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.sprayLine == null)
		{
			info.msg.sprayLine = Pool.Get<SprayLine>();
		}
		if (info.msg.sprayLine.linePoints == null)
		{
			info.msg.sprayLine.linePoints = Pool.Get<List<LinePoint>>();
		}
		bool flag = AcceptingChanges && info.forDisk;
		if (LinePoints != null && !flag)
		{
			CopyPoints(LinePoints, info.msg.sprayLine.linePoints);
		}
		info.msg.sprayLine.width = width;
		info.msg.sprayLine.colour = new Vector3(colour.r, colour.g, colour.b);
		if (!info.forDisk)
		{
			info.msg.sprayLine.editingPlayer = editingPlayer.uid;
		}
	}

	public void SetColour(Color newColour)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		colour = newColour;
	}

	public void SetWidth(float lineWidth)
	{
		width = lineWidth;
	}

	[RPC_Server]
	private void Server_AddPointMidSpray(RPCMessage msg)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (AcceptingChanges && !((Object)(object)editingPlayer.Get(serverside: true) != (Object)(object)msg.player) && LinePoints.Count + 1 <= 60)
		{
			Vector3 val = msg.read.Vector3();
			Vector3 worldNormal = msg.read.Vector3();
			if (!(Vector3.Distance(val, LinePoints[0].LocalPosition) >= 10f))
			{
				LinePoints.Add(new AlignedLineDrawer.LinePoint
				{
					LocalPosition = val,
					WorldNormal = worldNormal
				});
				UpdateGroundWatch();
				SendNetworkUpdate();
			}
		}
	}

	public void EnableChanges(BasePlayer byPlayer)
	{
		base.OwnerID = byPlayer.userID;
		editingPlayer.Set(byPlayer);
		((FacepunchBehaviour)this).Invoke((Action)TimeoutEditing, 30f);
	}

	public void TimeoutEditing()
	{
		if (editingPlayer.IsSet)
		{
			editingPlayer.Set(null);
			SendNetworkUpdate();
			Kill();
		}
	}

	[RPC_Server]
	private void Server_FinishEditing(RPCMessage msg)
	{
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = editingPlayer.Get(serverside: true);
		if ((Object)(object)msg.player != (Object)(object)basePlayer)
		{
			return;
		}
		bool allowNewSprayImmediately = msg.read.Int32() == 1;
		if ((Object)(object)basePlayer != (Object)null && (Object)(object)basePlayer.GetHeldEntity() != (Object)null && basePlayer.GetHeldEntity() is SprayCan sprayCan)
		{
			sprayCan.ClearPaintingLine(allowNewSprayImmediately);
		}
		editingPlayer.Set(null);
		SprayList val = msg.read.Proto<SprayList>((SprayList)null);
		try
		{
			int count = val.linePoints.Count;
			if (count > 70)
			{
				Kill();
				return;
			}
			if (LinePoints.Count <= 1)
			{
				Kill();
				return;
			}
			((FacepunchBehaviour)this).CancelInvoke((Action)TimeoutEditing);
			LinePoints.Clear();
			for (int i = 0; i < count; i++)
			{
				if (((Vector3)(ref val.linePoints[i].localPosition)).sqrMagnitude < 100f)
				{
					LinePoints.Add(new AlignedLineDrawer.LinePoint
					{
						LocalPosition = val.linePoints[i].localPosition,
						WorldNormal = val.linePoints[i].worldNormal
					});
				}
			}
			OnDeployed(null, basePlayer, null);
			UpdateGroundWatch();
			SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void AddInitialPoint(Vector3 atNormal)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		LinePoints = new List<AlignedLineDrawer.LinePoint>
		{
			new AlignedLineDrawer.LinePoint
			{
				LocalPosition = Vector3.zero,
				WorldNormal = atNormal
			}
		};
	}

	private void UpdateGroundWatch()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && LinePoints.Count > 1)
		{
			Vector3 groundPosition = Vector3.Lerp(LinePoints[0].LocalPosition, LinePoints[LinePoints.Count - 1].LocalPosition, 0.5f);
			if ((Object)(object)groundWatch != (Object)null)
			{
				groundWatch.groundPosition = groundPosition;
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.sprayLine != null)
		{
			if (info.msg.sprayLine.linePoints != null)
			{
				LinePoints.Clear();
				CopyPoints(info.msg.sprayLine.linePoints, LinePoints);
			}
			colour = new Color(info.msg.sprayLine.colour.x, info.msg.sprayLine.colour.y, info.msg.sprayLine.colour.z);
			width = info.msg.sprayLine.width;
			editingPlayer.uid = info.msg.sprayLine.editingPlayer;
			UpdateGroundWatch();
		}
	}

	public void CopyPoints(List<AlignedLineDrawer.LinePoint> from, List<LinePoint> to)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		to.Clear();
		foreach (AlignedLineDrawer.LinePoint item in from)
		{
			LinePoint val = Pool.Get<LinePoint>();
			val.localPosition = item.LocalPosition;
			val.worldNormal = item.WorldNormal;
			to.Add(val);
		}
	}

	public void CopyPoints(List<AlignedLineDrawer.LinePoint> from, List<Vector3> to)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		to.Clear();
		foreach (AlignedLineDrawer.LinePoint item in from)
		{
			to.Add(item.LocalPosition);
			to.Add(item.WorldNormal);
		}
	}

	public void CopyPoints(List<LinePoint> from, List<AlignedLineDrawer.LinePoint> to)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		to.Clear();
		foreach (LinePoint item in from)
		{
			to.Add(new AlignedLineDrawer.LinePoint
			{
				LocalPosition = item.localPosition,
				WorldNormal = item.worldNormal
			});
		}
	}

	public static void CopyPoints(List<AlignedLineDrawer.LinePoint> from, List<AlignedLineDrawer.LinePoint> to)
	{
		to.Clear();
		foreach (AlignedLineDrawer.LinePoint item in from)
		{
			to.Add(item);
		}
	}

	public override void ResetState()
	{
		base.ResetState();
		editingPlayer.Set(null);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;

public class StagedResourceEntity : ResourceEntity
{
	[Serializable]
	public class ResourceStage
	{
		public float health;

		public GameObject instance;
	}

	public List<ResourceStage> stages = new List<ResourceStage>();

	protected int stage;

	public GameObjectRef changeStageEffect;

	public MeshLOD ResourceMeshLod;

	public MeshCollider ResourceMeshCollider;

	public GameObject gibSourceTest;

	private StagedResourceEntityInfo cachedInfo;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StagedResourceEntity.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.resource != null)
		{
			int num = info.msg.resource.stage;
			if (info.fromDisk && base.isServer)
			{
				health = startHealth;
				num = 0;
			}
			if (num != stage)
			{
				stage = num;
				UpdateStage();
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.resource == null)
		{
			info.msg.resource = Pool.Get<BaseResource>();
		}
		info.msg.resource.health = Health();
		info.msg.resource.stage = stage;
	}

	protected override void OnHealthChanged()
	{
		((FacepunchBehaviour)this).Invoke((Action)UpdateNetworkStage, 0.1f);
	}

	public virtual void UpdateNetworkStage()
	{
		if (FindBestStage() != stage)
		{
			stage = FindBestStage();
			SendNetworkUpdate();
			UpdateStage();
		}
	}

	private int FindBestStage()
	{
		float num = Mathf.InverseLerp(0f, MaxHealth(), Health());
		StagedResourceEntityInfo.ResourceStage[] array = GetInfo().Stages;
		for (int i = 0; i < array.Length; i++)
		{
			if (num >= array[i].Health)
			{
				return i;
			}
		}
		return array.Length - 1;
	}

	private StagedResourceEntityInfo GetInfo()
	{
		if (cachedInfo != null)
		{
			return cachedInfo;
		}
		if (base.isServer)
		{
			cachedInfo = PrefabAttribute.server.Find<StagedResourceEntityInfo>(prefabID);
		}
		return cachedInfo;
	}

	private void UpdateStage()
	{
		if (GetInfo().Stages.Length != 0)
		{
			ResourceMeshCollider.sharedMesh = cachedInfo.GetCollisionMesh(stage);
			GroundWatch.PhysicsChanged(((Component)this).gameObject);
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class ResourceStage
{
	public float health;

	public GameObject instance;
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

[Factory("stash")]
public class StashContainer : StorageContainer
{
	public static class StashContainerFlags
	{
		public const Flags Hidden = Flags.Reserved5;
	}

	public Transform visuals;

	public float burriedOffset;

	public float raisedOffset;

	public GameObjectRef buryEffect;

	public float uncoverRange = 3f;

	public float uncoverTime = 2f;

	[ServerVar(Name = "reveal_tick_rate")]
	public static float PlayerDetectionTickRate = 0.5f;

	private float lastToggleTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StashContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 4130263076u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_HideStash "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_HideStash", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4130263076u, "RPC_HideStash", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_HideStash(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_HideStash");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool PlayerInRange(BasePlayer ply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3.Distance(((Component)this).transform.position, ((Component)ply).transform.position) <= uncoverRange)
		{
			Vector3 val = ((Component)this).transform.position - ply.eyes.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			if (Vector3.Dot(ply.eyes.BodyForward(), normalized) > 0.95f)
			{
				return true;
			}
		}
		return false;
	}

	public override void InitShared()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		((Component)visuals).transform.localPosition = Vector3Ex.WithY(((Component)visuals).transform.localPosition, raisedOffset);
	}

	public void DoOccludedCheck()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (Physics.SphereCast(new Ray(((Component)this).transform.position + Vector3.up * 5f, Vector3.down), 0.25f, 5f, 2097152) && Interface.CallHook("OnStashOcclude", (object)this) == null)
		{
			DropItems();
			Kill();
		}
	}

	public void OnPhysicsNeighbourChanged()
	{
		if (!((FacepunchBehaviour)this).IsInvoking((Action)DoOccludedCheck))
		{
			((FacepunchBehaviour)this).Invoke((Action)DoOccludedCheck, Random.Range(5f, 10f));
		}
	}

	private void RemoveFromNetworkRange()
	{
		base.limitNetworking = true;
	}

	private void ReturnToNetworkRange()
	{
		if (base.limitNetworking)
		{
			base.limitNetworking = false;
			SendNetworkUpdateImmediate();
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)RemoveFromNetworkRange);
	}

	public void SetHidden(bool isHidden)
	{
		if (!(Time.realtimeSinceStartup - lastToggleTime < 3f) && isHidden != HasFlag(Flags.Reserved5))
		{
			if (isHidden)
			{
				((FacepunchBehaviour)this).Invoke((Action)RemoveFromNetworkRange, 3f);
			}
			else
			{
				ReturnToNetworkRange();
			}
			lastToggleTime = Time.realtimeSinceStartup;
			((FacepunchBehaviour)this).Invoke((Action)Decay, 259200f);
			if (base.isServer)
			{
				SetFlag(Flags.Reserved5, isHidden);
			}
		}
	}

	public void DisableNetworking()
	{
		base.limitNetworking = true;
		SetFlag(Flags.Disabled, b: true);
	}

	public void Decay()
	{
		Kill();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetHidden(isHidden: false);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (IsHidden())
		{
			RemoveFromNetworkRange();
		}
	}

	public void ToggleHidden()
	{
		SetHidden(!IsHidden());
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_HideStash(RPCMessage rpc)
	{
		if (Interface.CallHook("CanHideStash", (object)rpc.player, (object)this) == null)
		{
			Analytics.Azure.OnStashHidden(rpc.player, this);
			SetHidden(isHidden: true);
			Interface.CallHook("OnStashHidden", (object)this, (object)rpc.player);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool num = (old & Flags.Reserved5) == Flags.Reserved5;
		bool flag = (next & Flags.Reserved5) == Flags.Reserved5;
		if (num != flag)
		{
			float num2 = (flag ? burriedOffset : raisedOffset);
			LeanTween.cancel(((Component)visuals).gameObject);
			LeanTween.moveLocalY(((Component)visuals).gameObject, num2, 1f);
		}
	}

	public bool IsHidden()
	{
		return HasFlag(Flags.Reserved5);
	}
}


public static class StashContainerFlags
{
	public const Flags Hidden = Flags.Reserved5;
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class StaticInstrument : BaseMountable
{
	public AnimatorOverrideController AnimatorOverride;

	public bool ShowDeployAnimation;

	public InstrumentKeyController KeyController;

	public bool ShouldSuppressHandsAnimationLayer;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StaticInstrument.OnRpcMessage", 0);
		try
		{
			if (rpc == 1625188589 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_PlayNote "));
				}
				TimeWarning val2 = TimeWarning.New("Server_PlayNote", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_PlayNote(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_PlayNote");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 705843933 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_StopNote "));
				}
				TimeWarning val2 = TimeWarning.New("Server_StopNote", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						Server_StopNote(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in Server_StopNote");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	private void Server_PlayNote(RPCMessage msg)
	{
		int arg = msg.read.Int32();
		int arg2 = msg.read.Int32();
		int arg3 = msg.read.Int32();
		float num = msg.read.Float();
		if (!FloatEx.IsNaNOrInfinity(num))
		{
			KeyController.ProcessServerPlayedNote(GetMounted());
			ClientRPC(RpcTarget.NetworkGroup("Client_PlayNote"), arg, arg2, arg3, num);
		}
	}

	[RPC_Server]
	private void Server_StopNote(RPCMessage msg)
	{
		int arg = msg.read.Int32();
		int arg2 = msg.read.Int32();
		int arg3 = msg.read.Int32();
		ClientRPC(RpcTarget.NetworkGroup("Client_StopNote"), arg, arg2, arg3);
	}

	public override bool IsInstrument()
	{
		return true;
	}
}


using System;
using System.Linq;
using System.Threading.Tasks;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class SteamInventory : EntityComponent<BasePlayer>
{
	public IPlayerItem[] Items;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SteamInventory.OnRpcMessage", 0);
		try
		{
			if (rpc == 643458331 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdateSteamInventory "));
				}
				TimeWarning val2 = TimeWarning.New("UpdateSteamInventory", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!BaseEntity.RPC_Server.FromOwner.Test(643458331u, "UpdateSteamInventory", GetBaseEntity(), player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							BaseEntity.RPCMessage rPCMessage = default(BaseEntity.RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							BaseEntity.RPCMessage msg2 = rPCMessage;
							UpdateSteamInventory(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in UpdateSteamInventory");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool HasItem(int itemid)
	{
		if (base.baseEntity.UnlockAllSkins)
		{
			return true;
		}
		if (Items == null)
		{
			return false;
		}
		IPlayerItem[] items = Items;
		for (int i = 0; i < items.Length; i++)
		{
			if (items[i].DefinitionId == itemid)
			{
				return true;
			}
		}
		return false;
	}

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.FromOwner(false)]
	private async Task UpdateSteamInventory(BaseEntity.RPCMessage msg)
	{
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		if (array == null)
		{
			Debug.LogWarning((object)"UpdateSteamInventory: Data is null");
			return;
		}
		IPlayerInventory val = await PlatformService.Instance.DeserializeInventory(array);
		if (val == null)
		{
			Debug.LogWarning((object)"UpdateSteamInventory: result is null");
		}
		else if ((Object)(object)base.baseEntity == (Object)null)
		{
			Debug.LogWarning((object)"UpdateSteamInventory: player is null");
		}
		else if (!val.BelongsTo((ulong)base.baseEntity.userID))
		{
			Debug.LogWarning((object)$"UpdateSteamPlayer: inventory belongs to someone else (userID={base.baseEntity.userID.Get()})");
		}
		else if (Object.op_Implicit((Object)(object)((Component)this).gameObject))
		{
			Items = val.Items.ToArray();
			Interface.CallHook("OnSteamInventoryUpdated", (object)this);
			((IDisposable)val).Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class StorageContainer : DecayEntity, IItemContainerEntity, IIdealSlotEntity, ILootableEntity, IInventoryProvider, LootPanel.IHasLootPanel, IContainerSounds, PlayerInventory.ICanMoveFrom
{
	[Header("Storage Container")]
	public static readonly Phrase LockedMessage = new Phrase("storage.locked", "Can't loot right now");

	public static readonly Phrase InUseMessage = new Phrase("storage.in_use", "Already in use");

	public int inventorySlots = 6;

	public bool dropsLoot = true;

	public float dropLootDestroyPercent;

	public bool dropFloats;

	public bool isLootable = true;

	public bool isLockable = true;

	public bool isMonitorable;

	public string panelName = "generic";

	public Phrase panelTitle = new Phrase("loot", "Loot");

	public ItemContainer.ContentsType allowedContents;

	public ItemDefinition allowedItem;

	public ItemDefinition allowedItem2;

	public ItemDefinition[] allowedItems;

	public ItemDefinition[] blockedItems;

	public int maxStackSize;

	public bool needsBuildingPrivilegeToUse;

	public bool requireAuthIfNotLocked;

	[ServerVar]
	public static bool canRequireAuthIfNoLock = false;

	public bool mustBeMountedToUse;

	public SoundDefinition openSound;

	public SoundDefinition closeSound;

	[Header("Item Dropping")]
	public Vector3 dropPosition;

	public Vector3 dropVelocity = Vector3.forward;

	public ItemCategory onlyAcceptCategory = ItemCategory.All;

	public bool onlyOneUser;

	[ServerVar]
	public static bool dropCorpseOnDeath;

	[ServerVar]
	public static float corpseItemsSavedPercent = 0.5f;

	public ItemContainer _inventory;

	public Phrase LootPanelTitle => panelTitle;

	public ItemContainer inventory => _inventory;

	public Transform Transform => ((Component)this).transform;

	public bool DropsLoot => dropsLoot;

	public bool DropFloats => dropFloats;

	public float DestroyLootPercent
	{
		get
		{
			if (!ShouldDropDeployableCorpse(lastAttacker, lastDamage))
			{
				return dropLootDestroyPercent;
			}
			return 0f;
		}
	}

	public ulong LastLootedBy { get; set; }

	public BasePlayer LastLootedByPlayer { get; set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StorageContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 331989034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(331989034u, "RPC_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.yellow;
		Gizmos.DrawCube(dropPosition, Vector3.one * 0.1f);
		Gizmos.color = Color.white;
		Gizmos.DrawRay(dropPosition, dropVelocity);
	}

	public bool MoveAllInventoryItems(ItemContainer from)
	{
		return MoveAllInventoryItems(from, _inventory);
	}

	public static bool MoveAllInventoryItems(ItemContainer source, ItemContainer dest)
	{
		bool flag = true;
		for (int i = 0; i < Mathf.Min(source.capacity, dest.capacity); i++)
		{
			Item slot = source.GetSlot(i);
			if (slot != null)
			{
				bool flag2 = slot.MoveToContainer(dest);
				if (flag && !flag2)
				{
					flag = false;
				}
			}
		}
		return flag;
	}

	public virtual void ReceiveInventoryFromItem(Item item)
	{
		if (item.contents != null)
		{
			MoveAllInventoryItems(item.contents, _inventory);
		}
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		bool num = (Object)(object)GetSlot(Slot.Lock) != (Object)null;
		string translated = pickup.itemTarget.displayName.translated;
		if (num)
		{
			lastPickupError = Phrase.op_Implicit(string.Format(PickupErrors.ItemHasLock.translated, translated));
			return false;
		}
		if (pickup.requireEmptyInv && _inventory != null && !inventory.IsEmpty())
		{
			lastPickupError = Phrase.op_Implicit(string.Format(PickupErrors.ItemInventoryMustBeEmpty.translated, translated));
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public override void OnPickedUp(Item createdItem, BasePlayer player)
	{
		base.OnPickedUp(createdItem, player);
		if (createdItem != null && createdItem.contents != null)
		{
			MoveAllInventoryItems(_inventory, createdItem.contents);
			return;
		}
		for (int i = 0; i < _inventory.capacity; i++)
		{
			Item slot = _inventory.GetSlot(i);
			if (slot != null)
			{
				slot.RemoveFromContainer();
				player.GiveItem(slot, GiveItemReason.PickedUp);
			}
		}
	}

	public override void ServerInit()
	{
		if (_inventory == null)
		{
			CreateInventory(giveUID: true);
			OnInventoryFirstCreated(_inventory);
		}
		else
		{
			_inventory.SetBlacklist(blockedItems);
		}
		base.ServerInit();
	}

	public virtual void OnInventoryFirstCreated(ItemContainer container)
	{
	}

	public virtual void OnItemAddedOrRemoved(Item item, bool added)
	{
	}

	public virtual void OnItemAddedToStack(Item item, int amount)
	{
	}

	public virtual void OnItemRemovedFromStack(Item item, int amount)
	{
	}

	public virtual void OnItemPositionChanged(Item item, int from, int to)
	{
	}

	public virtual bool ItemFilter(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("OnItemFilter", (object)item, (object)this, (object)targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (onlyAcceptCategory == ItemCategory.All)
		{
			return true;
		}
		return item.info.category == onlyAcceptCategory;
	}

	public void CreateInventory(bool giveUID)
	{
		Debug.Assert(_inventory == null, "Double init of inventory!");
		_inventory = Pool.Get<ItemContainer>();
		_inventory.entityOwner = this;
		_inventory.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
		_inventory.SetOnlyAllowedItems(allowedItems, allowedItem, allowedItem2);
		_inventory.SetBlacklist(blockedItems);
		_inventory.maxStackSize = maxStackSize;
		_inventory.ServerInitialize(null, inventorySlots);
		if (giveUID)
		{
			_inventory.GiveUID();
		}
		_inventory.onDirty += OnInventoryDirty;
		_inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
		_inventory.onItemAddedToStack = OnItemAddedToStack;
		_inventory.onItemRemovedFromStack = OnItemRemovedFromStack;
		_inventory.onItemPositionChanged = OnItemPositionChanged;
		_inventory.canAcceptItem = ItemFilter;
	}

	public override void PreServerLoad()
	{
		base.PreServerLoad();
		CreateInventory(giveUID: false);
	}

	protected virtual void OnInventoryDirty()
	{
		InvalidateNetworkCache();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (_inventory != null && !((ItemContainerId)(ref _inventory.uid)).IsValid)
		{
			_inventory.GiveUID();
		}
		SetFlag(Flags.Open, b: false);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (_inventory != null)
		{
			Pool.Free<ItemContainer>(ref _inventory);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (isLootable)
		{
			BasePlayer player = rpc.player;
			if (Object.op_Implicit((Object)(object)player) && player.CanInteract())
			{
				PlayerOpenLoot(player);
			}
		}
	}

	public virtual string GetPanelName()
	{
		return panelName;
	}

	public virtual bool CanMoveFrom(BasePlayer player, Item item)
	{
		return !_inventory.IsLocked();
	}

	public virtual bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		if (!CanBeLooted(player))
		{
			return false;
		}
		BaseLock @lock = GetLock();
		if ((Object)(object)@lock != (Object)null && !@lock.OnTryToOpen(player))
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
			return false;
		}
		return true;
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if ((needsBuildingPrivilegeToUse || ShouldRequireAuthIfNoCodelock(this, requireAuthIfNotLocked)) && !player.CanBuild())
		{
			return false;
		}
		if (mustBeMountedToUse && !player.isMounted)
		{
			return false;
		}
		return base.CanBeLooted(player);
	}

	public virtual void AddContainers(PlayerLoot loot)
	{
		loot.AddContainer(_inventory);
	}

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", (object)player, (object)this) != null)
		{
			return false;
		}
		if (IsLocked() || IsTransferring())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, LockedMessage, false);
			return false;
		}
		if (onlyOneUser && IsOpen())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, InUseMessage, false);
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = panelName;
		}
		if (!CanOpenLootPanel(player, panelToOpen))
		{
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			AddContainers(player.inventory.loot);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), panelToOpen);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", (object)player, (object)this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			if (_inventory != null)
			{
				info.msg.storageBox = Pool.Get<StorageBox>();
				info.msg.storageBox.contents = _inventory.Save();
			}
			else
			{
				Debug.LogWarning((object)("Storage container without inventory: " + ((object)this).ToString()));
			}
		}
	}

	public override void OnDied(HitInfo info)
	{
		DropItems(info?.Initiator);
		base.OnDied(info);
	}

	public override void OnDeployableCorpseSpawned(BaseEntity corpse)
	{
		base.OnDeployableCorpseSpawned(corpse);
		if (corpse is ContainerCorpse containerCorpse)
		{
			containerCorpse.TakeFrom(new ItemContainer[1] { inventory }, corpseItemsSavedPercent);
		}
	}

	public virtual void DropItems(BaseEntity initiator = null)
	{
		DropItems(this, initiator);
	}

	public static void DropItems(IItemContainerEntity containerEntity, BaseEntity initiator = null)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		ItemContainer itemContainer = containerEntity.inventory;
		if (itemContainer == null || itemContainer.itemList == null || itemContainer.itemList.Count == 0 || !containerEntity.DropsLoot)
		{
			return;
		}
		if (containerEntity.ShouldDropItemsIndividually() || (itemContainer.itemList.Count == 1 && !containerEntity.DropFloats))
		{
			if ((Object)(object)initiator != (Object)null)
			{
				containerEntity.DropBonusItems(initiator, itemContainer);
			}
			DropUtil.DropItems(itemContainer, containerEntity.GetDropPosition());
		}
		else
		{
			string prefab = (containerEntity.DropFloats ? "assets/prefabs/misc/item drop/item_drop_buoyant.prefab" : "assets/prefabs/misc/item drop/item_drop.prefab");
			_ = (Object)(object)itemContainer.Drop(prefab, containerEntity.GetDropPosition(), containerEntity.Transform.rotation, containerEntity.DestroyLootPercent) != (Object)null;
		}
	}

	public virtual void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
	}

	public override Vector3 GetDropPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		return ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint(dropPosition);
	}

	public override Vector3 GetDropVelocity()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 inheritedDropVelocity = GetInheritedDropVelocity();
		Matrix4x4 localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		return inheritedDropVelocity + ((Matrix4x4)(ref localToWorldMatrix)).MultiplyVector(dropPosition);
	}

	public virtual bool ShouldDropItemsIndividually()
	{
		return false;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.storageBox != null)
		{
			if (_inventory != null)
			{
				_inventory.Load(info.msg.storageBox.contents);
				_inventory.capacity = inventorySlots;
			}
			else
			{
				Debug.LogWarning((object)("Storage container without inventory: " + ((object)this).ToString()));
			}
		}
	}

	public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		return -1;
	}

	public virtual ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return default(ItemContainerId);
	}

	public virtual void GetAllInventories(List<ItemContainer> list)
	{
		list.Add(inventory);
	}

	public static bool ShouldRequireAuthIfNoCodelock(BaseEntity container, bool containerRequiresAuth)
	{
		if (canRequireAuthIfNoLock && containerRequiresAuth)
		{
			return (Object)(object)container.GetLock() == (Object)null;
		}
		return false;
	}

	public override bool HasSlot(Slot slot)
	{
		if (isLockable && slot == Slot.Lock)
		{
			return true;
		}
		if (isMonitorable && slot == Slot.StorageMonitor)
		{
			return true;
		}
		return base.HasSlot(slot);
	}

	public bool OccupiedCheck(BasePlayer player = null)
	{
		if ((Object)(object)player != (Object)null && (Object)(object)player.inventory.loot.entitySource == (Object)(object)this)
		{
			return true;
		}
		if (onlyOneUser)
		{
			return !IsOpen();
		}
		return true;
	}

	protected bool HasAttachedStorageAdaptor()
	{
		if (children == null)
		{
			return false;
		}
		foreach (BaseEntity child in children)
		{
			if (child is IndustrialStorageAdaptor)
			{
				return true;
			}
		}
		return false;
	}

	protected bool HasAttachedStorageMonitor()
	{
		if (children == null)
		{
			return false;
		}
		foreach (BaseEntity child in children)
		{
			if (child is StorageMonitor)
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class SurveyCrater : BaseCombatEntity
{
	private ResourceDispenser resourceDispenser;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SurveyCrater.OnRpcMessage", 0);
		try
		{
			if (rpc == 3491246334u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AnalysisComplete "));
				}
				TimeWarning val2 = TimeWarning.New("AnalysisComplete", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						AnalysisComplete(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in AnalysisComplete");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 1800f);
	}

	public override void OnAttacked(HitInfo info)
	{
		_ = base.isServer;
		base.OnAttacked(info);
	}

	public void RemoveMe()
	{
		Kill();
	}

	[RPC_Server]
	public void AnalysisComplete(RPCMessage msg)
	{
		Interface.CallHook("OnAnalysisComplete", (object)this, (object)msg.player);
	}

	public override float BoundsPadding()
	{
		return 2f;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Telephone : ContainerIOEntity, ICassettePlayer
{
	public enum CallState
	{
		Idle,
		Dialing,
		Ringing,
		InProcess
	}

	public enum DialFailReason
	{
		TimedOut,
		Engaged,
		WrongNumber,
		CallSelf,
		RemoteHangUp,
		NetworkBusy,
		TimeOutDuringCall,
		SelfHangUp
	}

	public const int MaxPhoneNameLength = 30;

	public const int MaxSavedNumbers = 10;

	public Transform PhoneHotspot;

	public Transform AnsweringMachineHotspot;

	public Transform[] HandsetRoots;

	public ItemDefinition[] ValidCassettes;

	public Transform ParentedHandsetTransform;

	public LineRenderer CableLineRenderer;

	public Transform CableStartPoint;

	public Transform CableEndPoint;

	public float LineDroopAmount = 0.25f;

	public PhoneController Controller;

	public Cassette cachedCassette { get; private set; }

	public BaseEntity ToBaseEntity => this;

	public uint AnsweringMessageId
	{
		get
		{
			if (!((Object)(object)cachedCassette != (Object)null))
			{
				return 0u;
			}
			return cachedCassette.AudioId;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Telephone.OnRpcMessage", 0);
		try
		{
			if (rpc == 1529322558 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AnswerPhone "));
				}
				TimeWarning val2 = TimeWarning.New("AnswerPhone", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1529322558u, "AnswerPhone", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							AnswerPhone(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AnswerPhone");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2754362156u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearCurrentUser "));
				}
				TimeWarning val2 = TimeWarning.New("ClearCurrentUser", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2754362156u, "ClearCurrentUser", this, player, 9f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ClearCurrentUser(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ClearCurrentUser");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1095090232 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - InitiateCall "));
				}
				TimeWarning val2 = TimeWarning.New("InitiateCall", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1095090232u, "InitiateCall", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							InitiateCall(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in InitiateCall");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2606442785u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_AddSavedNumber "));
				}
				TimeWarning val2 = TimeWarning.New("Server_AddSavedNumber", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2606442785u, "Server_AddSavedNumber", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2606442785u, "Server_AddSavedNumber", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							Server_AddSavedNumber(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in Server_AddSavedNumber");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1402406333 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RemoveSavedNumber "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RemoveSavedNumber", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1402406333u, "Server_RemoveSavedNumber", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1402406333u, "Server_RemoveSavedNumber", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							Server_RemoveSavedNumber(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in Server_RemoveSavedNumber");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 942544266 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestPhoneDirectory "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestPhoneDirectory", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(942544266u, "Server_RequestPhoneDirectory", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(942544266u, "Server_RequestPhoneDirectory", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							Server_RequestPhoneDirectory(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in Server_RequestPhoneDirectory");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1240133378 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerDeleteVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerDeleteVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1240133378u, "ServerDeleteVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1240133378u, "ServerDeleteVoicemail", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							ServerDeleteVoicemail(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in ServerDeleteVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1221129498 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerHangUp "));
				}
				TimeWarning val2 = TimeWarning.New("ServerHangUp", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg9 = rPCMessage;
						ServerHangUp(msg9);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex8)
				{
					Debug.LogException(ex8);
					player.Kick("RPC Error in ServerHangUp");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 239260010 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerPlayVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerPlayVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(239260010u, "ServerPlayVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(239260010u, "ServerPlayVoicemail", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg10 = rPCMessage;
							ServerPlayVoicemail(msg10);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogException(ex9);
						player.Kick("RPC Error in ServerPlayVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 189198880 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerSendVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerSendVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(189198880u, "ServerSendVoicemail", this, player, 5uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg11 = rPCMessage;
							ServerSendVoicemail(msg11);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogException(ex10);
						player.Kick("RPC Error in ServerSendVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2760189029u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerStopVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerStopVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2760189029u, "ServerStopVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2760189029u, "ServerStopVoicemail", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg12 = rPCMessage;
							ServerStopVoicemail(msg12);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogException(ex11);
						player.Kick("RPC Error in ServerStopVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3900772076u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetCurrentUser "));
				}
				TimeWarning val2 = TimeWarning.New("SetCurrentUser", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3900772076u, "SetCurrentUser", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage currentUser = rPCMessage;
							SetCurrentUser(currentUser);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex12)
					{
						Debug.LogException(ex12);
						player.Kick("RPC Error in SetCurrentUser");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2760249627u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdatePhoneName "));
				}
				TimeWarning val2 = TimeWarning.New("UpdatePhoneName", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2760249627u, "UpdatePhoneName", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2760249627u, "UpdatePhoneName", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg13 = rPCMessage;
							UpdatePhoneName(msg13);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex13)
					{
						Debug.LogException(ex13);
						player.Kick("RPC Error in UpdatePhoneName");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg?.telephone == null)
		{
			return;
		}
		Controller.PhoneNumber = info.msg.telephone.phoneNumber;
		Controller.PhoneName = info.msg.telephone.phoneName;
		Controller.lastDialedNumber = info.msg.telephone.lastNumber;
		Controller.savedVoicemail = Pool.Get<List<VoicemailEntry>>();
		foreach (VoicemailEntry item in info.msg.telephone.voicemail)
		{
			Controller.savedVoicemail.Add(item);
			item.ShouldPool = false;
		}
		if (!info.fromDisk)
		{
			Controller.currentPlayerRef.uid = info.msg.telephone.usingPlayer;
		}
		PhoneDirectory savedNumbers = Controller.savedNumbers;
		if (savedNumbers != null)
		{
			savedNumbers.ResetToPool();
		}
		Controller.savedNumbers = info.msg.telephone.savedNumbers;
		if (Controller.savedNumbers != null)
		{
			Controller.savedNumbers.ShouldPool = false;
		}
		if (info.fromDisk)
		{
			SetFlag(Flags.Busy, b: false);
		}
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if ((Object)(object)Controller.currentPlayer != (Object)null)
		{
			string translatedNameFromEntity = ConstructionErrors.GetTranslatedNameFromEntity(Controller.currentPlayer, player);
			lastPickupError = Phrase.op_Implicit(string.Format(PickupErrors.ItemBeingUsedByPlayer.translated, pickup.itemTarget.displayName.translated, translatedNameFromEntity));
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer)
		{
			if (Controller.RequirePower && next.HasFlag(Flags.Busy) && !next.HasFlag(Flags.Reserved8))
			{
				Controller.ServerHangUp();
			}
			if (old.HasFlag(Flags.Busy) != next.HasFlag(Flags.Busy))
			{
				if (next.HasFlag(Flags.Busy))
				{
					if (!((FacepunchBehaviour)this).IsInvoking((Action)Controller.WatchForDisconnects))
					{
						((FacepunchBehaviour)this).InvokeRepeating((Action)Controller.WatchForDisconnects, 0f, 0.1f);
					}
				}
				else
				{
					((FacepunchBehaviour)this).CancelInvoke((Action)Controller.WatchForDisconnects);
				}
			}
		}
		Controller.OnFlagsChanged(old, next);
	}

	public override void Save(SaveInfo info)
	{
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.telephone == null)
		{
			info.msg.telephone = Pool.Get<Telephone>();
		}
		info.msg.telephone.phoneNumber = Controller.PhoneNumber;
		info.msg.telephone.phoneName = Controller.PhoneName;
		info.msg.telephone.lastNumber = Controller.lastDialedNumber;
		info.msg.telephone.savedNumbers = Controller.savedNumbers;
		if (Controller.savedVoicemail != null)
		{
			info.msg.telephone.voicemail = Pool.Get<List<VoicemailEntry>>();
			foreach (VoicemailEntry item in Controller.savedVoicemail)
			{
				info.msg.telephone.voicemail.Add(item);
			}
		}
		if (!info.forDisk)
		{
			info.msg.telephone.usingPlayer = Controller.currentPlayerRef.uid;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Controller.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Controller.PostServerLoad();
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Controller.DoServerDestroy();
	}

	[RPC_Server.MaxDistance(9f)]
	[RPC_Server]
	public void ClearCurrentUser(RPCMessage msg)
	{
		Controller.ClearCurrentUser(msg);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void SetCurrentUser(RPCMessage msg)
	{
		Controller.SetCurrentUser(msg);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void InitiateCall(RPCMessage msg)
	{
		Controller.InitiateCall(msg);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void AnswerPhone(RPCMessage msg)
	{
		Controller.AnswerPhone(msg);
	}

	[RPC_Server]
	private void ServerHangUp(RPCMessage msg)
	{
		Controller.ServerHangUp(msg);
	}

	public void OnCassetteInserted(Cassette c)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		cachedCassette = c;
		ClientRPC(RpcTarget.NetworkGroup("ClientOnCassetteChanged"), c.net.ID);
	}

	public void OnCassetteRemoved(Cassette c)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		cachedCassette = null;
		Controller.DeleteAllVoicemail();
		((BaseEntity)this).ClientRPC(RpcTarget.NetworkGroup("ClientOnCassetteChanged"), default(NetworkableId));
	}

	private bool CanAcceptItem(Item item, int targetSlot)
	{
		ItemDefinition[] validCassettes = ValidCassettes;
		for (int i = 0; i < validCassettes.Length; i++)
		{
			if ((Object)(object)validCassettes[i] == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void UpdatePhoneName(RPCMessage msg)
	{
		Controller.UpdatePhoneName(msg);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void Server_RequestPhoneDirectory(RPCMessage msg)
	{
		Controller.Server_RequestPhoneDirectory(msg);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void Server_AddSavedNumber(RPCMessage msg)
	{
		Controller.Server_AddSavedNumber(msg);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void Server_RemoveSavedNumber(RPCMessage msg)
	{
		Controller.Server_RemoveSavedNumber(msg);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	public void ServerSendVoicemail(RPCMessage msg)
	{
		Controller.ServerSendVoicemail(msg);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void ServerPlayVoicemail(RPCMessage msg)
	{
		Controller.ServerPlayVoicemail(msg);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	public void ServerStopVoicemail(RPCMessage msg)
	{
		Controller.ServerStopVoicemail(msg);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void ServerDeleteVoicemail(RPCMessage msg)
	{
		Controller.ServerDeleteVoicemail(msg);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (Controller.serverState == CallState.Ringing || Controller.serverState == CallState.InProcess)
		{
			return base.GetPassthroughAmount(outputSlot);
		}
		return 0;
	}
}


public enum CallState
{
	Idle,
	Dialing,
	Ringing,
	InProcess
}


public enum DialFailReason
{
	TimedOut,
	Engaged,
	WrongNumber,
	CallSelf,
	RemoteHangUp,
	NetworkBusy,
	TimeOutDuringCall,
	SelfHangUp
}


using System;
using Network;
using Rust.Demo;
using UnityEngine;

public class ThrownBoomerang : BaseEntity
{
	[Header("References")]
	public ItemDefinition boomerangItem;

	[Header("Settings")]
	public float timeToReturnOnArc = 3f;

	public float secondsUntilStartArc = 0.9f;

	public float lerpSpeed = 20f;

	private const float CATCH_DISTANCE = 1.5f;

	private const float HOMING_TO_PLAYER_DISTANCE = 6f;

	private Vector3 lastMoveDirection;

	private Vector3 gravityVelocity = Vector3.zero;

	private bool calculated;

	private float returnTimer;

	private float timeToReturn;

	private Vector3 startLocation;

	private Vector3 midLocation;

	private Vector3 endLocation;

	private Vector3 spawnLocation = Vector3.zero;

	private ThrownBoomerangServerProjectile projectile;

	private BasePlayer creatorPlayer;

	private Boomerang originEntityItem;

	[NonSerialized]
	public ItemOwnershipShare ItemOwnership;

	[NonSerialized]
	public float Condition;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ThrownBoomerang.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private void DoBoomerangMove()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		if (Reader.IsActive && Reader.Active.IsScrubbing)
		{
			return;
		}
		float deltaTime = Time.deltaTime;
		float num = 15f;
		Vector3 val;
		if (!calculated)
		{
			returnTimer = 0f;
			startLocation = ((Component)this).transform.position;
			endLocation = spawnLocation;
			endLocation += Vector3.up * 1.2f;
			val = endLocation - startLocation;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			Vector3 val2 = Vector3.Cross(Vector3.up, normalized);
			midLocation = (startLocation + endLocation) / 2f;
			midLocation += val2 * num;
			if (base.isServer)
			{
				projectile.ProjectileHandleMovement(state: false);
			}
			calculated = true;
		}
		BasePlayer basePlayer = null;
		if (base.isServer)
		{
			basePlayer = creatorPlayer;
		}
		if ((Object)(object)basePlayer != (Object)null && Vector3.Distance(((Component)basePlayer).transform.position, spawnLocation) <= 6f && IsValidPlayer(basePlayer))
		{
			endLocation = ((Component)basePlayer).transform.position;
			endLocation += Vector3.up * 1.5f;
			val = endLocation - startLocation;
			Vector3 normalized2 = ((Vector3)(ref val)).normalized;
			Vector3 val3 = Vector3.Cross(Vector3.up, normalized2);
			midLocation = (startLocation + endLocation) / 2f;
			midLocation += val3 * num;
		}
		float num2 = returnTimer / timeToReturnOnArc;
		Vector3 val4 = FakePhysicsRope.GetRationalBezierPoint(startLocation, midLocation, endLocation, Mathf.Clamp01(num2));
		if (num2 >= 1f)
		{
			gravityVelocity += Vector3.down * 9.81f * deltaTime;
			lastMoveDirection += gravityVelocity * deltaTime;
			val4 = ((Component)this).transform.position + lastMoveDirection;
		}
		else if (num2 > 0.95f)
		{
			val4 += Vector3.down * 0.03f;
		}
		Vector3 val5 = val4 - ((Component)this).transform.position;
		if (val5 != Vector3.zero && base.isServer)
		{
			projectile.SetVelocity(val5);
			((Component)this).transform.rotation = Quaternion.Slerp(((Component)this).transform.rotation, Quaternion.LookRotation(((Vector3)(ref val5)).normalized), deltaTime * 2f);
		}
		((Component)this).transform.position = Vector3.MoveTowards(((Component)this).transform.position, val4, deltaTime * lerpSpeed);
		if (num2 <= 1f)
		{
			lastMoveDirection = val5;
		}
		returnTimer += deltaTime;
	}

	private bool IsValidPlayer(BasePlayer ply)
	{
		if ((Object)(object)ply == (Object)null)
		{
			return false;
		}
		if (ply.IsDead())
		{
			return false;
		}
		if (ply.IsSleeping())
		{
			return false;
		}
		return true;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (base.isClient)
		{
			return;
		}
		spawnLocation = ((Component)this).transform.position;
		projectile = ((Component)this).GetComponent<ThrownBoomerangServerProjectile>();
		if (Object.op_Implicit((Object)(object)projectile))
		{
			projectile.InitializeVelocity(((Component)this).transform.forward * projectile.speed);
			projectile.ProjectileHandleMovement(state: true);
			projectile.SetStartPosition(spawnLocation);
			((FacepunchBehaviour)this).InvokeRepeating((Action)DoBoomerangMove, secondsUntilStartArc, 0f);
			if (!(creatorEntity is BasePlayer basePlayer))
			{
				return;
			}
			creatorPlayer = basePlayer;
			base.OwnerID = creatorPlayer.userID;
			creatorEntity = creatorPlayer;
			Item activeItem = creatorPlayer.GetActiveItem();
			if (activeItem != null)
			{
				if (activeItem.GetHeldEntity() is Boomerang boomerang)
				{
					originEntityItem = boomerang;
				}
				ItemOwnership = activeItem.TakeOwnershipShare();
			}
			((FacepunchBehaviour)this).Invoke((Action)LateRPC, 0.1f);
			((FacepunchBehaviour)this).InvokeRepeating((Action)CheckReturnToHand, secondsUntilStartArc, 0f);
		}
		else
		{
			KillThrownBoomerang();
		}
	}

	private void LateRPC()
	{
		Item activeItem = creatorPlayer.GetActiveItem();
		if (activeItem != null && activeItem.GetHeldEntity() is Boomerang)
		{
			ClientRPC(RpcTarget.Player("SetClientPlayer", creatorPlayer), activeItem.uid.Value);
		}
	}

	public void CreateWorldModel(HitInfo info, Vector3 attackDir)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Max(projectile.scanRange, projectile.radius);
		num /= 2f;
		Item item = ItemManager.Create(boomerangItem, 1, 0uL);
		BaseEntity baseEntity = null;
		bool flag = false;
		if ((Object)(object)info.HitEntity == (Object)null || !info.HitEntity.IsValid())
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld + -attackDir * num * 0.3f, Quaternion.LookRotation(-attackDir));
			flag = info.HitMaterial != Projectile.WaterMaterialID();
			if (!info.HitEntity.IsValid())
			{
				flag = false;
			}
		}
		else if (info.HitBone == 0)
		{
			Vector3 hitPositionLocal = info.HitPositionLocal;
			baseEntity = item.CreateWorldObject(hitPositionLocal, Quaternion.LookRotation(((Component)info.HitEntity).transform.InverseTransformDirection(((Vector3)(ref attackDir)).normalized)), info.HitEntity);
			flag = false;
		}
		else
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(((Component)info.HitEntity).transform.InverseTransformDirection(((Vector3)(ref attackDir)).normalized)));
			flag = false;
		}
		if (flag)
		{
			DroppedItem droppedItem = baseEntity as DroppedItem;
			if ((Object)(object)droppedItem != (Object)null)
			{
				droppedItem.StickIn();
			}
			else
			{
				((Component)baseEntity).GetComponent<Rigidbody>().isKinematic = true;
			}
		}
		else
		{
			((Component)baseEntity).GetComponent<Rigidbody>().AddTorque(((Vector3)(ref attackDir)).normalized * Random.Range(5f, 10f), (ForceMode)1);
		}
		item.condition = Condition;
		item.SetItemOwnership(ItemOwnership);
		baseEntity.OwnerID = base.OwnerID;
		baseEntity.creatorEntity = creatorEntity;
	}

	public void OnHit()
	{
		if ((Object)(object)originEntityItem != (Object)null)
		{
			Item item = originEntityItem.GetItem();
			if (item != null)
			{
				float num = item.maxCondition * 0.1f;
				Condition -= num;
				item.UseItem();
				item.SetParent(null);
			}
		}
	}

	private void KillThrownBoomerang()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)CheckReturnToHand);
		Kill();
	}

	public void CheckReturnToHand()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)creatorPlayer == (Object)null) && !creatorPlayer.IsDead() && !creatorPlayer.IsSleeping() && Vector3.Distance(((Component)creatorPlayer).transform.position, ((Component)this).transform.position) <= 1.5f)
		{
			Item activeItem = creatorPlayer.GetActiveItem();
			if (activeItem != null && activeItem.GetHeldEntity() is Boomerang { HasThrown: not false } boomerang && !((Object)(object)boomerang != (Object)(object)originEntityItem))
			{
				boomerang.SetHasThrown(thrown: false);
				KillThrownBoomerang();
			}
		}
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class ThrownWeapon : AttackEntity
{
	[Header("Throw Weapon")]
	public GameObjectRef prefabToThrow;

	public float maxThrowVelocity = 10f;

	public float tumbleVelocity;

	public Vector3 overrideAngle = Vector3.zero;

	public bool canStick = true;

	public bool canThrowUnderwater = true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ThrownWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 1513023343 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoDrop "));
				}
				TimeWarning val2 = TimeWarning.New("DoDrop", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1513023343u, "DoDrop", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoDrop(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoDrop");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1974840882 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoThrow "));
				}
				TimeWarning val2 = TimeWarning.New("DoThrow", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1974840882u, "DoThrow", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							DoThrow(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in DoThrow");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return player.GetInheritedThrowVelocity(direction);
	}

	public void ServerThrow(Vector3 targetPosition)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || !HasItemAmount() || HasAttackCooldown())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null || (!canThrowUnderwater && ownerPlayer.IsHeadUnderwater()))
		{
			return;
		}
		Vector3 position = ownerPlayer.eyes.position;
		Vector3 val = ownerPlayer.eyes.BodyForward();
		float num = 1f;
		SignalBroadcast(Signal.Throw, string.Empty);
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, position, Quaternion.LookRotation((overrideAngle == Vector3.zero) ? (-val) : overrideAngle));
		if ((Object)(object)baseEntity == (Object)null)
		{
			return;
		}
		baseEntity.SetCreatorEntity(ownerPlayer);
		Vector3 val2 = val + Quaternion.AngleAxis(10f, Vector3.right) * Vector3.up;
		float num2 = GetThrowVelocity(position, targetPosition, val2);
		if (float.IsNaN(num2))
		{
			val2 = val + Quaternion.AngleAxis(20f, Vector3.right) * Vector3.up;
			num2 = GetThrowVelocity(position, targetPosition, val2);
			if (float.IsNaN(num2))
			{
				num2 = 5f;
			}
		}
		baseEntity.SetVelocity(val2 * num2 * num);
		if (tumbleVelocity > 0f)
		{
			baseEntity.SetAngularVelocity(new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f)) * tumbleVelocity);
		}
		baseEntity.Spawn();
		StartAttackCooldown(repeatDelay);
		UseItemAmount(1);
		if ((Object)(object)(baseEntity as TimedExplosive) != (Object)null)
		{
			Analytics.Azure.OnExplosiveLaunched(ownerPlayer, baseEntity);
		}
	}

	private float GetThrowVelocity(Vector3 throwPos, Vector3 targetPos, Vector3 aimDir)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = targetPos - throwPos;
		Vector2 val2 = new Vector2(val.x, val.z);
		float magnitude = ((Vector2)(ref val2)).magnitude;
		float y = val.y;
		val2 = new Vector2(aimDir.x, aimDir.z);
		float magnitude2 = ((Vector2)(ref val2)).magnitude;
		float y2 = aimDir.y;
		float y3 = Physics.gravity.y;
		return Mathf.Sqrt(0.5f * y3 * magnitude * magnitude / (magnitude2 * (magnitude2 * y - y2 * magnitude)));
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void DoThrow(RPCMessage msg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		if (!HasItemAmount() || HasAttackCooldown())
		{
			return;
		}
		Vector3 val = msg.read.Vector3();
		Vector3 val2 = msg.read.Vector3();
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		float num = Mathf.Clamp01(msg.read.Float());
		if (Vector3Ex.IsNaNOrInfinity(normalized) || FloatEx.IsNaNOrInfinity(num))
		{
			return;
		}
		if (msg.player.isMounted || msg.player.HasParent())
		{
			val = msg.player.eyes.position;
		}
		else if (!ValidateEyePos(msg.player, val))
		{
			return;
		}
		if (!canThrowUnderwater && msg.player.IsHeadUnderwater())
		{
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, val, Quaternion.LookRotation((overrideAngle == Vector3.zero) ? (-normalized) : overrideAngle));
		if (!((Object)(object)baseEntity == (Object)null))
		{
			Item ownerItem = GetOwnerItem();
			if (ownerItem != null && ownerItem.instanceData != null && ownerItem.HasFlag(Item.Flag.IsOn))
			{
				((Component)baseEntity).gameObject.SendMessage("SetFrequency", (object)GetOwnerItem().instanceData.dataInt, (SendMessageOptions)1);
			}
			baseEntity.SetCreatorEntity(msg.player);
			baseEntity.skinID = skinID;
			baseEntity.SetVelocity(GetInheritedVelocity(msg.player, normalized) + normalized * maxThrowVelocity * num + msg.player.estimatedVelocity * 0.5f);
			if (tumbleVelocity > 0f)
			{
				baseEntity.SetAngularVelocity(new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f)) * tumbleVelocity);
			}
			baseEntity.Spawn();
			if (baseEntity is TimedExplosive timedExplosive)
			{
				ItemOwnershipShare itemOwnership = ownerItem.TakeOwnershipShare();
				timedExplosive.ItemOwnership = itemOwnership;
				timedExplosive.SetCreator(msg.player);
			}
			SetUpThrownWeapon(baseEntity);
			StartAttackCooldown(repeatDelay);
			Interface.CallHook("OnExplosiveThrown", (object)msg.player, (object)baseEntity, (object)this);
			UseItemAmount(1, reduceItemOwnership: false);
		}
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void DoDrop(RPCMessage msg)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		if (!HasItemAmount() || HasAttackCooldown() || (!canThrowUnderwater && msg.player.IsHeadUnderwater()))
		{
			return;
		}
		Vector3 val = msg.read.Vector3();
		Vector3 val2 = msg.read.Vector3();
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		if (msg.player.isMounted || msg.player.HasParent())
		{
			val = msg.player.eyes.position;
		}
		else if (!ValidateEyePos(msg.player, val))
		{
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, val, Quaternion.LookRotation(Vector3.up));
		if ((Object)(object)baseEntity == (Object)null)
		{
			return;
		}
		RaycastHit hit = default(RaycastHit);
		if (canStick && Physics.SphereCast(new Ray(val, normalized), 0.05f, ref hit, 1.5f, 1237003025))
		{
			Vector3 point = ((RaycastHit)(ref hit)).point;
			Vector3 normal = ((RaycastHit)(ref hit)).normal;
			BaseEntity entity = hit.GetEntity();
			Collider collider = ((RaycastHit)(ref hit)).collider;
			if (Object.op_Implicit((Object)(object)entity) && entity is StabilityEntity && baseEntity is TimedExplosive)
			{
				entity = entity.ToServer<BaseEntity>();
				TimedExplosive timedExplosive = baseEntity as TimedExplosive;
				timedExplosive.onlyDamageParent = true;
				timedExplosive.DoStick(point, normal, entity, collider);
				Analytics.Azure.OnExplosiveLaunched(msg.player, timedExplosive);
			}
			else
			{
				baseEntity.SetVelocity(normalized);
			}
		}
		else
		{
			baseEntity.SetVelocity(normalized);
		}
		baseEntity.creatorEntity = msg.player;
		baseEntity.skinID = skinID;
		baseEntity.Spawn();
		SetUpThrownWeapon(baseEntity);
		StartAttackCooldown(repeatDelay);
		Interface.CallHook("OnExplosiveDropped", (object)msg.player, (object)baseEntity, (object)this);
		UseItemAmount(1);
	}

	protected virtual void SetUpThrownWeapon(BaseEntity ent)
	{
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class TimerSwitch : IOEntity
{
	public float timerLength = 10f;

	public Transform timerDrum;

	private float timePassed;

	private float input1Amount;

	private float serverStartTime = -1f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TimerSwitch.OnRpcMessage", 0);
		try
		{
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SVSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SVSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4167839872u, "SVSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SVSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SVSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public float GetPassedTime()
	{
		return timePassed;
	}

	public override void ResetIOState()
	{
		base.ResetIOState();
		SetFlag(Flags.On, b: false);
		if (((FacepunchBehaviour)this).IsInvoking((Action)AdvanceTime))
		{
			EndTimer();
		}
	}

	public override bool WantsPassthroughPower()
	{
		if (IsPowered())
		{
			return IsOn();
		}
		return false;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsPowered() || !IsOn())
		{
			return 0;
		}
		return base.GetPassthroughAmount(outputSlot);
	}

	public override bool WantsPower(int inputIndex)
	{
		return inputIndex == 0;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		switch (inputSlot)
		{
		case 0:
			base.UpdateFromInput(inputAmount, inputSlot);
			if (IsPowered())
			{
				if (timePassed != 0f && !((FacepunchBehaviour)this).IsInvoking((Action)AdvanceTime))
				{
					SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
					SwitchPressed();
				}
			}
			else if (((FacepunchBehaviour)this).IsInvoking((Action)AdvanceTime))
			{
				EndTimer();
				SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
				SendNetworkUpdate_Flags();
			}
			break;
		case 1:
			if (input1Amount != (float)inputAmount)
			{
				if (inputAmount > 0)
				{
					SwitchPressed();
				}
				input1Amount = inputAmount;
			}
			break;
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SVSwitch(RPCMessage msg)
	{
		SwitchPressed();
	}

	public void SwitchPressed()
	{
		if (!IsOn() && IsPowered())
		{
			StartTimer();
			SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
			MarkDirty();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (timePassed == 0f)
		{
			if (IsOn())
			{
				SetFlag(Flags.On, b: false);
			}
		}
		else
		{
			SwitchPressed();
		}
	}

	public void AdvanceTime()
	{
		if (timePassed < 0f)
		{
			timePassed = 0f;
		}
		timePassed = Time.realtimeSinceStartup - serverStartTime;
		if (timePassed >= timerLength)
		{
			EndTimer();
		}
	}

	public void StartTimer()
	{
		serverStartTime = Time.realtimeSinceStartup;
		timePassed = 0f;
		((FacepunchBehaviour)this).InvokeRepeating((Action)AdvanceTime, 0f, 0.1f);
	}

	public void EndTimer()
	{
		serverStartTime = 0f;
		timePassed = 0f;
		((FacepunchBehaviour)this).CancelInvoke((Action)AdvanceTime);
		SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
		MarkDirty();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity.genericFloat1 = GetPassedTime();
		info.msg.ioEntity.genericFloat2 = timerLength;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			timePassed = info.msg.ioEntity.genericFloat1;
			timerLength = info.msg.ioEntity.genericFloat2;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class TinCanAlarm : DecayEntity, IDetector
{
	[Space]
	public LineRenderer lineRenderer;

	public Transform wireOrigin;

	public Transform wireOriginClient;

	public PlayerDetectionTrigger trigger;

	public Transform wireEndCollider;

	public GroundWatch groundWatch;

	public GroundWatch wireGroundWatch;

	public Animator animator;

	[Space]
	public SoundDefinition alarmSoundDef;

	public SoundDefinition armSoundDef;

	public Vector3 endPoint;

	private const Flags Flag_Used = Flags.Reserved5;

	public BaseEntity lastTriggerEntity;

	public float lastTriggerTime;

	private BasePlayer usingPlayer;

	[Space]
	public float maxWireLength = 10f;

	private const int WIRE_PLACEMENT_LAYER = 1084293377;

	public Transform WireOrigin
	{
		get
		{
			_ = base.isServer;
			return wireOrigin;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TinCanAlarm.OnRpcMessage", 0);
		try
		{
			if (rpc == 3384266798u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SetEndPoint "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SetEndPoint", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_SetEndPoint(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_SetEndPoint");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3516830045u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_StartArming "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_StartArming", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3516830045u, "SERVER_StartArming", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_StartArming(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_StartArming");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3508772935u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_StopArming "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_StopArming", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg4 = rPCMessage;
						SERVER_StopArming(msg4);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex3)
				{
					Debug.LogException(ex3);
					player.Kick("RPC Error in SERVER_StopArming");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsUsed()
	{
		return HasFlag(Flags.Reserved5);
	}

	private bool IsArmed()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return endPoint != Vector3.zero;
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (base.ShouldDisplayPickupOption(player))
		{
			return (Object)(object)player.GetBuildingPrivilege() != (Object)null;
		}
		return false;
	}

	public bool ShouldTrigger()
	{
		return IsArmed();
	}

	public void OnObjects()
	{
	}

	public void OnObjectAdded(GameObject obj, Collider col)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = obj.ToBaseEntity();
		if (!((Object)(object)baseEntity != (Object)null))
		{
			return;
		}
		if (baseEntity is BuildingBlock && IsGoingThroughWalls(endPoint))
		{
			CutWire();
			return;
		}
		if (baseEntity is BasePlayer { isMounted: not false } basePlayer)
		{
			baseEntity = basePlayer.GetMounted();
		}
		else
		{
			BaseEntity baseEntity2 = baseEntity.GetParentEntity();
			if ((Object)(object)baseEntity2 != (Object)null)
			{
				baseEntity = baseEntity2;
			}
		}
		if ((!(Time.realtimeSinceStartup - lastTriggerTime < 1f) || !((Object)(object)baseEntity == (Object)(object)lastTriggerEntity)) && (baseEntity is BasePlayer || baseEntity is Door || baseEntity is BaseNpc || baseEntity is BaseVehicle || baseEntity is Elevator || baseEntity is Lift))
		{
			lastTriggerTime = Time.realtimeSinceStartup;
			lastTriggerEntity = baseEntity;
			TriggerAlarm();
		}
	}

	public void OnEmpty()
	{
	}

	public void TriggerAlarm()
	{
		ClientRPC(RpcTarget.NetworkGroup("RPC_TriggerAlarm"));
	}

	public void ServerOnWireDeploying()
	{
		if (!usingPlayer.IsValid() || !usingPlayer.IsConnected)
		{
			PlayerStopsArming(usingPlayer);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void SERVER_StartArming(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsUsed() && player.CanBuild())
		{
			PlayerStartsArming(player);
		}
	}

	[RPC_Server]
	public void SERVER_StopArming(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player.CanBuild())
		{
			PlayerStopsArming(player);
		}
	}

	public void PlayerStartsArming(BasePlayer player)
	{
		if (!IsUsed() && !((Object)(object)player == (Object)null))
		{
			usingPlayer = player;
			SetFlag(Flags.Reserved5, b: true);
			if (((FacepunchBehaviour)this).IsInvoking((Action)ServerOnWireDeploying))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ServerOnWireDeploying);
			}
			((FacepunchBehaviour)this).InvokeRepeating((Action)ServerOnWireDeploying, 0f, 0f);
			ClientRPC(RpcTarget.Player("CLIENT_StartArming", player));
		}
	}

	public void PlayerStopsArming(BasePlayer player)
	{
		usingPlayer = null;
		SetFlag(Flags.Reserved5, b: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ServerOnWireDeploying);
		ClientRPC(RpcTarget.Player("CLIENT_StopArming", player));
	}

	public void CutWire()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TriggerAlarm();
		endPoint = Vector3.zero;
		SendNetworkUpdate();
	}

	private void UpdateWireTip()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			if (!IsArmed())
			{
				ComponentExtensions.SetActive<Transform>(wireEndCollider, false);
				return;
			}
			wireEndCollider.position = endPoint;
			ComponentExtensions.SetActive<Transform>(wireEndCollider, true);
		}
	}

	private void OnGroundMissing()
	{
		if (!base.IsDestroyed && !base.isClient)
		{
			if (!groundWatch.OnGround())
			{
				Kill(DestroyMode.Gib);
			}
			else if (!wireGroundWatch.OnGround())
			{
				CutWire();
			}
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		if (base.isServer)
		{
			PlayerStartsArming(deployedBy);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (info.hasDamage && !info.damageTypes.Has(DamageType.Heat))
		{
			TriggerAlarm();
		}
	}

	private void UpdateTrigger()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		if (!IsArmed())
		{
			ComponentExtensions.SetActive<PlayerDetectionTrigger>(trigger, false);
			return;
		}
		ComponentExtensions.SetActive<PlayerDetectionTrigger>(trigger, true);
		Vector3 position = wireOrigin.position;
		Vector3 val = endPoint;
		Vector3 position2 = (position + val) / 2f;
		Vector3 val2 = val - position;
		float magnitude = ((Vector3)(ref val2)).magnitude;
		((Component)trigger).transform.position = position2;
		Vector3 localScale = ((Component)trigger).transform.localScale;
		localScale.z = magnitude;
		((Component)trigger).transform.rotation = Quaternion.LookRotation(val2);
		((Component)trigger).transform.localScale = new Vector3(0.15f, 0.15f, localScale.z);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.tinCanAlarm = Pool.Get<TinCanAlarm>();
		info.msg.tinCanAlarm.endPoint = endPoint;
		UpdateTrigger();
		UpdateWireTip();
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.tinCanAlarm != null)
		{
			endPoint = info.msg.tinCanAlarm.endPoint;
			UpdateTrigger();
			if (info.fromDisk && !usingPlayer.IsValid())
			{
				PlayerStopsArming(usingPlayer);
			}
		}
	}

	[RPC_Server]
	public void RPC_SetEndPoint(RPCMessage msg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		Vector3 val = msg.read.Vector3();
		if (player.CanBuild() && player.IsVisibleAndCanSee(val) && !IsGoingThroughWalls(val) && IsInValidVolume(val) && IsOnValidEntities(val) && !(Vector3.Distance(wireOrigin.position, val) > maxWireLength))
		{
			endPoint = val;
			SendNetworkUpdate();
			PlayerStopsArming(player);
		}
	}

	private bool IsGoingThroughWalls(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		float maxDistance = Vector3.Distance(wireOrigin.position, position);
		Vector3 val = position - wireOrigin.position;
		RaycastHit hitInfo;
		bool flag = GamePhysics.Trace(new Ray(wireOrigin.position, val), 0f, out hitInfo, maxDistance, 1218519297, (QueryTriggerInteraction)1, this);
		if (!flag)
		{
			flag = GamePhysics.Trace(new Ray(position, -val), 0f, out var _, maxDistance, 1218519297, (QueryTriggerInteraction)1, this);
		}
		return flag;
	}

	private bool IsInValidVolume(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(position, 0.1f, list, 536870912, (QueryTriggerInteraction)2);
		bool result = true;
		foreach (Collider item in list)
		{
			if (((Component)item).gameObject.HasCustomTag(GameObjectTag.BlockPlacement))
			{
				result = false;
				break;
			}
			if (!((Object)(object)item.GetMonument() != (Object)null))
			{
				ColliderInfo component = ((Component)item).GetComponent<ColliderInfo>();
				if (!((Object)(object)component != (Object)null) || !component.HasFlag(ColliderInfo.Flags.Tunnels))
				{
					result = false;
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private bool IsOnValidEntities(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, 0.1f, list, 1084293377, (QueryTriggerInteraction)2);
		bool result = true;
		foreach (BaseEntity item in list)
		{
			if (item is AnimatedBuildingBlock || item is ElevatorLift || item is Elevator)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}
}


using System;
using Network;
using UnityEngine;

public class Toolgun : Hammer
{
	public GameObjectRef attackEffect;

	public GameObjectRef beamEffect;

	public GameObjectRef beamImpactEffect;

	public GameObjectRef errorEffect;

	public GameObjectRef beamEffectClassic;

	public GameObjectRef beamImpactEffectClassic;

	public Transform muzzlePoint;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Toolgun.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void DoAttackShared(HitInfo info)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			ClientRPC(RpcTarget.NetworkGroup("EffectSpawn"), info.HitPositionWorld, info.HitNormalWorld);
		}
		base.DoAttackShared(info);
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class TorchDeployableLightSource : StorageContainer, ISplashable, IIgniteable, IAlwaysOn
{
	public ItemDefinition[] AllowedTorches;

	public Transform TorchRoot;

	public const Flags HasTorch = Flags.Reserved1;

	public const Flags UseBuiltInFx = Flags.Reserved2;

	public const Flags AlwaysOn = Flags.Reserved3;

	public ItemDefinition[] BuiltInFxItems = new ItemDefinition[0];

	private EntityRef<TorchWeapon> spawnedTorch;

	private ItemDefinition spawnedTorchDef;

	private Item CurrentTorch => base.inventory.GetSlot(0);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TorchDeployableLightSource.OnRpcMessage", 0);
		try
		{
			if (rpc == 3305620958u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestTurnOnOff "));
				}
				TimeWarning val2 = TimeWarning.New("RequestTurnOnOff", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3305620958u, "RequestTurnOnOff", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RequestTurnOnOff(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RequestTurnOnOff");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		ItemDefinition[] allowedTorches = AllowedTorches;
		for (int i = 0; i < allowedTorches.Length; i++)
		{
			if ((Object)(object)allowedTorches[i] == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	private bool ShouldUseBuiltInFx(ItemDefinition def)
	{
		if ((Object)(object)def == (Object)null)
		{
			return false;
		}
		ItemDefinition[] builtInFxItems = BuiltInFxItems;
		for (int i = 0; i < builtInFxItems.Length; i++)
		{
			if ((Object)(object)builtInFxItems[i] == (Object)(object)def)
			{
				return true;
			}
		}
		return false;
	}

	private void UpdateTorch()
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		Item item = CurrentTorch;
		if (item != null && item.isBroken)
		{
			item = null;
		}
		ItemDefinition itemDefinition = item?.info;
		if ((Object)(object)itemDefinition != (Object)(object)spawnedTorchDef)
		{
			spawnedTorchDef = itemDefinition;
			SetFlag(Flags.Reserved2, ShouldUseBuiltInFx(itemDefinition), recursive: false, networkupdate: false);
			TorchWeapon torchWeapon = spawnedTorch.Get(serverside: true);
			if ((Object)(object)torchWeapon != (Object)null)
			{
				torchWeapon.Kill();
			}
			spawnedTorch.Set(null);
			if ((Object)(object)itemDefinition != (Object)null)
			{
				TorchWeapon component = ((Component)GameManager.server.CreateEntity(((Component)itemDefinition).GetComponent<ItemModEntity>().entityPrefab.resourcePath, TorchRoot.position, TorchRoot.rotation)).GetComponent<TorchWeapon>();
				component.SetParent(this, worldPositionStays: true);
				component.SetFlag(Flags.Reserved1, b: true);
				component.Spawn();
				spawnedTorch.Set(component);
			}
			else
			{
				SetFlag(Flags.On, b: false);
			}
		}
		SetFlag(Flags.Reserved1, (Object)(object)spawnedTorch.Get(serverside: true) != (Object)null);
		if (!HasFlag(Flags.Reserved1) && ((FacepunchBehaviour)this).IsInvoking((Action)TickTorchDurability))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TickTorchDurability);
		}
	}

	private void TickTorchDurability()
	{
		Item currentTorch = CurrentTorch;
		if (currentTorch != null && !IsAlwaysOn())
		{
			currentTorch.LoseCondition(1f / 12f);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		foreach (BaseEntity child in children)
		{
			if (child is TorchWeapon torchWeapon)
			{
				spawnedTorch.Set(torchWeapon);
				torchWeapon.SetFlag(Flags.On, IsOn());
				break;
			}
		}
		if (HasFlag(Flags.Reserved1) && IsOn())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)TickTorchDurability, 1f, 1f);
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		UpdateTorch();
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RequestTurnOnOff(RPCMessage msg)
	{
		bool wantsOn = msg.read.Bit();
		TryToggle(wantsOn);
	}

	private void TryToggle(bool wantsOn)
	{
		if (CurrentTorch == null)
		{
			return;
		}
		TorchWeapon torchWeapon = spawnedTorch.Get(serverside: true);
		if (!((Object)(object)torchWeapon == (Object)null))
		{
			torchWeapon.SetFlag(Flags.On, wantsOn);
			SetFlag(Flags.On, wantsOn);
			if (HasFlag(Flags.Reserved1) && wantsOn)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)TickTorchDurability, 1f, 1f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)TickTorchDurability);
			}
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if (HasFlag(Flags.Reserved1))
		{
			return IsOn();
		}
		return false;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		TryToggle(wantsOn: false);
		return 10;
	}

	public void Ignite(Vector3 fromPos)
	{
		TryToggle(wantsOn: true);
	}

	public bool CanIgnite()
	{
		if (HasFlag(Flags.Reserved1))
		{
			return !IsOn();
		}
		return false;
	}

	public virtual bool IsAlwaysOn()
	{
		if (HasFlag(Flags.Reserved3))
		{
			return Creative.alwaysOnEnabled;
		}
		return false;
	}

	public void SetAlwaysOn(bool flag)
	{
		SetFlag(Flags.Reserved3, flag);
		AlwaysOnToggled(flag);
	}

	public void AlwaysOnToggled(bool flag)
	{
		if (flag)
		{
			if (AllowedTorches == null || AllowedTorches.Length == 0 || base.inventory == null)
			{
				return;
			}
			if (!HasFlag(Flags.Reserved1))
			{
				ItemDefinition itemDefinition = AllowedTorches[0];
				if ((Object)(object)itemDefinition == (Object)null)
				{
					return;
				}
				ItemManager.Create(itemDefinition, 1, 0uL).MoveToContainer(base.inventory, 0, allowStack: false);
			}
		}
		TryToggle(flag);
	}
}


using System;
using ConVar;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class TorchWeapon : BaseMelee
{
	[NonSerialized]
	public const float FuelTickAmount = 1f / 12f;

	[Header("TorchWeapon")]
	public AnimatorOverrideController LitHoldAnimationOverride;

	public bool ExtinguishUnderwater = true;

	public bool UseTurnOnOffAnimations;

	public GameObjectRef litStrikeFX;

	public const Flags IsInHolder = Flags.Reserved1;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TorchWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 2235491565u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Extinguish "));
				}
				TimeWarning val2 = TimeWarning.New("Extinguish", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(2235491565u, "Extinguish", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Extinguish(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Extinguish");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3010584743u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Ignite "));
				}
				TimeWarning val2 = TimeWarning.New("Ignite", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3010584743u, "Ignite", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Ignite(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Ignite");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void GetAttackStats(HitInfo info)
	{
		base.GetAttackStats(info);
		if (HasFlag(Flags.On))
		{
			info.damageTypes.Add(DamageType.Heat, 1f);
		}
	}

	public override float GetConditionLoss()
	{
		return base.GetConditionLoss() + (HasFlag(Flags.On) ? 6f : 0f);
	}

	public void SetIsOn(bool isOn)
	{
		if (isOn)
		{
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.OnFire, b: true);
			((FacepunchBehaviour)this).InvokeRepeating((Action)UseFuel, 1f, 1f);
		}
		else
		{
			SetFlag(Flags.On, b: false);
			SetFlag(Flags.OnFire, b: false);
			((FacepunchBehaviour)this).CancelInvoke((Action)UseFuel);
		}
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Ignite(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			SetIsOn(isOn: true);
		}
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Extinguish(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			SetIsOn(isOn: false);
		}
	}

	public void UseFuel()
	{
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			ownerItem.LoseCondition(1f / 12f);
			SingletonComponent<NpcFireManager>.Instance.Move(this);
		}
	}

	public override void OnHeldChanged()
	{
		if (IsDisabled())
		{
			SetIsOn(isOn: false);
		}
	}

	public override string GetStrikeEffectPath(string materialName)
	{
		for (int i = 0; i < materialStrikeFX.Count; i++)
		{
			if (materialStrikeFX[i].materialName == materialName && materialStrikeFX[i].fx.isValid)
			{
				return materialStrikeFX[i].fx.resourcePath;
			}
		}
		if (HasFlag(Flags.On) && litStrikeFX.isValid)
		{
			return litStrikeFX.resourcePath;
		}
		return strikeFX.resourcePath;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

public class TrainCar : BaseVehicle, ITrainCollidable, IPrefabPreProcess, TriggerHurtNotChild.IHurtTriggerUser, TrainTrackSpline.ITrainTrackUser
{
	public enum TrainCarType
	{
		Wagon,
		Engine,
		Other
	}

	[SerializeField]
	[Header("Train Car")]
	public float corpseSeconds = 60f;

	[SerializeField]
	public TriggerTrainCollisions frontCollisionTrigger;

	[SerializeField]
	public TriggerTrainCollisions rearCollisionTrigger;

	[SerializeField]
	public float collisionDamageDivide = 100000f;

	[SerializeField]
	public float derailCollisionForce = 130000f;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerFront;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerRear;

	[SerializeField]
	private GameObject[] hurtOrRepelTriggersInternal;

	[SerializeField]
	public float hurtTriggerMinSpeed = 1f;

	[SerializeField]
	public Transform centreOfMassTransform;

	[SerializeField]
	public Transform frontBogiePivot;

	[SerializeField]
	public bool frontBogieCanRotate = true;

	[SerializeField]
	public Transform rearBogiePivot;

	[SerializeField]
	public bool rearBogieCanRotate = true;

	[SerializeField]
	private Transform[] wheelVisuals;

	[SerializeField]
	public float wheelRadius = 0.615f;

	[FormerlySerializedAs("fxFinalExplosion")]
	[SerializeField]
	public GameObjectRef fxDestroyed;

	[SerializeField]
	public TriggerParent platformParentTrigger;

	public GameObjectRef collisionEffect;

	public Transform frontCoupling;

	public Transform frontCouplingPivot;

	public Transform rearCoupling;

	public Transform rearCouplingPivot;

	[SerializeField]
	public SoundDefinition coupleSound;

	[SerializeField]
	private SoundDefinition uncoupleSound;

	[SerializeField]
	private TrainCarAudio trainCarAudio;

	[SerializeField]
	[FormerlySerializedAs("frontCoupleFx")]
	public ParticleSystem frontCouplingChangedFx;

	[FormerlySerializedAs("rearCoupleFx")]
	[SerializeField]
	public ParticleSystem rearCouplingChangedFx;

	[FormerlySerializedAs("fxCoupling")]
	[SerializeField]
	public ParticleSystem newCouplingFX;

	[SerializeField]
	private float decayTimeMultiplier = 1f;

	[ReadOnly]
	[SerializeField]
	public Vector3 frontBogieLocalOffset;

	[SerializeField]
	[ReadOnly]
	public Vector3 rearBogieLocalOffset;

	[SerializeField]
	private GameObjectRef itemStoragePrefab;

	private EntityRef<StorageContainer> itemStorageInstance;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population = 2.3f;

	[ServerVar(Help = "Ratio of wagons to train engines that spawn")]
	public static int wagons_per_engine = 2;

	[ServerVar(Help = "How long before a train car despawns")]
	public static float decayminutes = 30f;

	[ServerVar(Help = "Chance to miss per m/s of velocity for turrets shooting players on moving trains", Name = "trainturretinaccuratepervelocity")]
	public static float TrainTurretInaccuratePerVelocity = 0.1f;

	[ReadOnly]
	public float DistFrontWheelToFrontCoupling;

	[ReadOnly]
	public float DistFrontWheelToBackCoupling;

	public TrainCouplingController coupling;

	[NonSerialized]
	public TrainTrackSpline.TrackSelection localTrackSelection;

	public const Flags Flag_LinedUpToUnload = Flags.Reserved4;

	public static float TRAINCAR_MAX_SPEED = 25f;

	protected bool trainDebug;

	public CompleteTrain completeTrain;

	[NonSerialized]
	public float savedTrackSpeed;

	private bool frontAtEndOfLine;

	private bool rearAtEndOfLine;

	public float frontBogieYRot;

	public float rearBogieYRot;

	public Vector3 spawnOrigin;

	private bool coupledBackwards;

	public TrainTrackSpline _frontTrackSection;

	public float distFrontToBackWheel;

	public float initialSpawnTime;

	public float decayingFor;

	public float decayTickSpacing = 60f;

	public float lastDecayTick;

	public TriggerTrainCollisions FrontCollisionTrigger => frontCollisionTrigger;

	public TriggerTrainCollisions RearCollisionTrigger => rearCollisionTrigger;

	public virtual TrainCarType CarType => TrainCarType.Wagon;

	public bool LinedUpToUnload => HasFlag(Flags.Reserved4);

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	public Vector3 Position => ((Component)this).transform.position;

	public float FrontWheelSplineDist { get; set; }

	public bool FrontAtEndOfLine => frontAtEndOfLine;

	public bool RearAtEndOfLine => rearAtEndOfLine;

	public virtual bool networkUpdateOnCompleteTrainChange => false;

	public TrainTrackSpline FrontTrackSection
	{
		get
		{
			return _frontTrackSection;
		}
		set
		{
			if ((Object)(object)_frontTrackSection != (Object)(object)value)
			{
				if ((Object)(object)_frontTrackSection != (Object)null)
				{
					_frontTrackSection.DeregisterTrackUser(this);
				}
				_frontTrackSection = value;
				if ((Object)(object)_frontTrackSection != (Object)null)
				{
					_frontTrackSection.RegisterTrackUser(this);
				}
			}
		}
	}

	public TrainTrackSpline RearTrackSection { get; set; }

	public bool IsAtAStation
	{
		get
		{
			if ((Object)(object)FrontTrackSection != (Object)null)
			{
				return FrontTrackSection.isStation;
			}
			return false;
		}
	}

	public bool IsOnAboveGroundSpawnRail
	{
		get
		{
			if ((Object)(object)FrontTrackSection != (Object)null)
			{
				return FrontTrackSection.aboveGroundSpawn;
			}
			return false;
		}
	}

	public bool RecentlySpawned => Time.time < initialSpawnTime + 2f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TrainCar.OnRpcMessage", 0);
		try
		{
			if (rpc == 924237371 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenItemStorage "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenItemStorage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(924237371u, "RPC_OpenItemStorage", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_OpenItemStorage(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenItemStorage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3930273067u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_WantsUncouple "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_WantsUncouple", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						RPC_WantsUncouple(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in RPC_WantsUncouple");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		base.PreProcess(process, rootObj, name, serverside, clientside, bundling);
		if (!((Object)(object)frontBogiePivot == (Object)null) && !((Object)(object)rearBogiePivot == (Object)null))
		{
			frontBogieLocalOffset = ((Component)this).transform.InverseTransformPoint(frontBogiePivot.position);
			float num = ((!((Object)(object)frontCoupling != (Object)null)) ? (((Bounds)(ref bounds)).extents.z + ((Bounds)(ref bounds)).center.z) : ((Component)this).transform.InverseTransformPoint(frontCoupling.position).z);
			float num2 = ((!((Object)(object)rearCoupling != (Object)null)) ? (0f - ((Bounds)(ref bounds)).extents.z + ((Bounds)(ref bounds)).center.z) : ((Component)this).transform.InverseTransformPoint(rearCoupling.position).z);
			DistFrontWheelToFrontCoupling = num - frontBogieLocalOffset.z;
			DistFrontWheelToBackCoupling = 0f - num2 + frontBogieLocalOffset.z;
			rearBogieLocalOffset = ((Component)this).transform.InverseTransformPoint(rearBogiePivot.position);
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		coupling = new TrainCouplingController(this);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.baseTrain != null && base.isServer)
		{
			frontBogieYRot = info.msg.baseTrain.frontBogieYRot;
			rearBogieYRot = info.msg.baseTrain.rearBogieYRot;
			itemStorageInstance.uid = info.msg.baseTrain.itemStorageID;
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next && base.isServer)
		{
			ServerFlagsChanged(old, next);
		}
	}

	public bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger)
	{
		return false;
	}

	public override float InheritedVelocityScale()
	{
		return 0.5f;
	}

	public virtual void SetTrackSelection(TrainTrackSpline.TrackSelection trackSelection)
	{
		if (localTrackSelection != trackSelection)
		{
			localTrackSelection = trackSelection;
			if (base.isServer)
			{
				ClientRPC(RpcTarget.NetworkGroup("SetTrackSelection"), (sbyte)localTrackSelection);
			}
		}
	}

	public bool PlayerIsOnPlatform(BasePlayer player)
	{
		return (Object)(object)player.GetParentEntity() == (Object)(object)this;
	}

	public override void ServerInit()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		spawnOrigin = ((Component)this).transform.position;
		distFrontToBackWheel = Vector3.Distance(GetFrontWheelPos(), GetRearWheelPos());
		rigidBody.centerOfMass = centreOfMassTransform.localPosition;
		UpdateCompleteTrain();
		lastDecayTick = Time.time;
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.15f, 0.02f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayTick, Random.Range(20f, 40f), decayTickSpacing, decayTickSpacing * 0.1f);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (base.health <= 0f)
		{
			ActualDeath();
			return;
		}
		SetFlag(Flags.Reserved2, b: false);
		SetFlag(Flags.Reserved3, b: false);
	}

	public override void Spawn()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		initialSpawnTime = Time.time;
		if (TrainTrackSpline.TryFindTrackNear(GetFrontWheelPos(), 15f, out var splineResult, out var distResult))
		{
			FrontWheelSplineDist = distResult;
			Vector3 tangent;
			Vector3 positionAndTangent = splineResult.GetPositionAndTangent(FrontWheelSplineDist, ((Component)this).transform.forward, out tangent);
			SetTheRestFromFrontWheelData(ref splineResult, positionAndTangent, tangent, localTrackSelection, null, instantMove: true);
			FrontTrackSection = splineResult;
			if (!Application.isLoadingSave && !SpaceIsClear())
			{
				((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0f);
			}
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0f);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.baseTrain = Pool.Get<BaseTrain>();
		info.msg.baseTrain.time = GetNetworkTime();
		info.msg.baseTrain.frontBogieYRot = frontBogieYRot;
		info.msg.baseTrain.rearBogieYRot = rearBogieYRot;
		info.msg.baseTrain.itemStorageID = itemStorageInstance.uid;
		if (coupling.frontCoupling.TryGetCoupledToID(out var id))
		{
			info.msg.baseTrain.frontCouplingID = id;
			info.msg.baseTrain.frontCouplingToFront = coupling.frontCoupling.CoupledTo.isFrontCoupling;
		}
		if (coupling.rearCoupling.TryGetCoupledToID(out id))
		{
			info.msg.baseTrain.rearCouplingID = id;
			info.msg.baseTrain.rearCouplingToFront = coupling.rearCoupling.CoupledTo.isFrontCoupling;
		}
	}

	public virtual void ServerFlagsChanged(Flags old, Flags next)
	{
		if (isSpawned && (next.HasFlag(Flags.Reserved2) != old.HasFlag(Flags.Reserved2) || next.HasFlag(Flags.Reserved3) != old.HasFlag(Flags.Reserved3)))
		{
			UpdateCompleteTrain();
		}
	}

	public void UpdateCompleteTrain()
	{
		List<TrainCar> result = Pool.Get<List<TrainCar>>();
		coupling.GetAll(ref result);
		SetNewCompleteTrain(new CompleteTrain(result));
	}

	public void SetNewCompleteTrain(CompleteTrain ct)
	{
		if (completeTrain != ct)
		{
			RemoveFromCompleteTrain();
			completeTrain = ct;
			coupledBackwards = ct.GetIsCoupledBackwards(this);
			if (networkUpdateOnCompleteTrainChange)
			{
				SendNetworkUpdate();
			}
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (!RecentlySpawned)
		{
			base.Hurt(info);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_OpenItemStorage(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player))
		{
			StorageContainer itemContainer = GetItemContainer();
			if ((Object)(object)itemContainer != (Object)null)
			{
				itemContainer.PlayerOpenLoot(player);
			}
		}
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && itemStoragePrefab != null && itemStoragePrefab.isValid)
		{
			BaseEntity entity = itemStoragePrefab.GetEntity();
			if ((Object)(object)entity != (Object)null && child.prefabID == entity.prefabID)
			{
				itemStorageInstance.Set((StorageContainer)child);
			}
		}
	}

	public StorageContainer GetItemContainer()
	{
		BaseEntity baseEntity = itemStorageInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as StorageContainer;
		}
		return null;
	}

	public override void OnDied(HitInfo info)
	{
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		float num = info?.damageTypes.Get(DamageType.AntiVehicle) ?? 0f;
		float num2 = info?.damageTypes.Get(DamageType.Explosion) ?? 0f;
		float num3 = info?.damageTypes.Total() ?? 0f;
		if ((num + num2) / num3 > 0.5f || vehicle.cinematictrains || corpseSeconds == 0f)
		{
			if (HasDriver())
			{
				GetDriver().Hurt(float.MaxValue);
			}
			base.OnDied(info);
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)ActualDeath, corpseSeconds);
		}
		if (base.IsDestroyed && fxDestroyed.isValid)
		{
			Effect.server.Run(fxDestroyed.resourcePath, GetExplosionPos(), Vector3.up, null, broadcast: true);
		}
	}

	public virtual Vector3 GetExplosionPos()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetCentreOfTrainPos();
	}

	public void ActualDeath()
	{
		Kill(DestroyMode.Gib);
	}

	public override void DoRepair(BasePlayer player)
	{
		base.DoRepair(player);
		if (IsDead() && Health() > 0f)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ActualDeath);
			lifestate = LifeState.Alive;
		}
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return Mathf.Abs(GetTrackSpeed()) * 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
	}

	public override void DoServerDestroy()
	{
		if ((Object)(object)FrontTrackSection != (Object)null)
		{
			FrontTrackSection.DeregisterTrackUser(this);
		}
		coupling.Uncouple(front: true);
		coupling.Uncouple(front: false);
		RemoveFromCompleteTrain();
		if (vehicle.vehiclesdroploot)
		{
			StorageContainer storageContainer = itemStorageInstance.Get(base.isServer);
			if ((Object)(object)storageContainer != (Object)null && storageContainer.IsValid())
			{
				storageContainer.DropItems();
			}
		}
		base.DoServerDestroy();
	}

	public void RemoveFromCompleteTrain()
	{
		if (completeTrain != null)
		{
			if (completeTrain.ContainsOnly(this))
			{
				completeTrain.Dispose();
				completeTrain = null;
			}
			else
			{
				completeTrain.RemoveTrainCar(this);
			}
		}
	}

	public override bool MountEligable(BasePlayer player)
	{
		if (IsDead())
		{
			return false;
		}
		return base.MountEligable(player);
	}

	public override float MaxVelocity()
	{
		return TRAINCAR_MAX_SPEED;
	}

	public float GetTrackSpeed()
	{
		if (completeTrain == null)
		{
			return 0f;
		}
		return completeTrain.GetTrackSpeedFor(this);
	}

	public bool IsCoupledBackwards()
	{
		if (completeTrain == null)
		{
			return false;
		}
		return coupledBackwards;
	}

	public float GetPrevTrackSpeed()
	{
		if (completeTrain == null)
		{
			return 0f;
		}
		return completeTrain.GetPrevTrackSpeedFor(this);
	}

	public override Vector3 GetLocalVelocityServer()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.forward * GetTrackSpeed();
	}

	public bool AnyPlayersOnTrainCar()
	{
		if (AnyMounted())
		{
			return true;
		}
		if ((Object)(object)platformParentTrigger != (Object)null && platformParentTrigger.HasAnyEntityContents)
		{
			foreach (BaseEntity entityContent in platformParentTrigger.entityContents)
			{
				if ((Object)(object)entityContent.ToPlayer() != (Object)null)
				{
					return true;
				}
			}
		}
		return false;
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("TrainCar.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (completeTrain != null)
			{
				completeTrain.UpdateTick(Time.fixedDeltaTime);
				float trackSpeed = GetTrackSpeed();
				((Component)hurtTriggerFront).gameObject.SetActive(!coupling.IsFrontCoupled && trackSpeed > hurtTriggerMinSpeed);
				((Component)hurtTriggerRear).gameObject.SetActive(!coupling.IsRearCoupled && trackSpeed < 0f - hurtTriggerMinSpeed);
				GameObject[] array = hurtOrRepelTriggersInternal;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(Mathf.Abs(trackSpeed) > hurtTriggerMinSpeed);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void PostVehicleFixedUpdate()
	{
		base.PostVehicleFixedUpdate();
		if (completeTrain != null)
		{
			completeTrain.ResetUpdateTick();
		}
	}

	public Vector3 GetCentreOfTrainPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * ((Bounds)(ref bounds)).center;
	}

	public Vector3 GetFrontOfTrainPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * (((Bounds)(ref bounds)).center + Vector3.forward * ((Bounds)(ref bounds)).extents.z);
	}

	public Vector3 GetRearOfTrainPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * (((Bounds)(ref bounds)).center - Vector3.forward * ((Bounds)(ref bounds)).extents.z);
	}

	public void FrontTrainCarTick(TrainTrackSpline.TrackSelection trackSelection, float dt)
	{
		float distToMove = GetTrackSpeed() * dt;
		TrainTrackSpline preferredAltTrack = (((Object)(object)RearTrackSection != (Object)(object)FrontTrackSection) ? RearTrackSection : null);
		MoveFrontWheelsAlongTrackSpline(FrontTrackSection, FrontWheelSplineDist, distToMove, preferredAltTrack, trackSelection);
	}

	public void OtherTrainCarTick(TrainTrackSpline theirTrackSpline, float prevSplineDist, float distanceOffset)
	{
		MoveFrontWheelsAlongTrackSpline(theirTrackSpline, prevSplineDist, distanceOffset, FrontTrackSection, TrainTrackSpline.TrackSelection.Default);
	}

	public bool TryGetNextTrainCar(Vector3 forwardDir, out TrainCar result)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return TryGetTrainCar(next: true, forwardDir, out result);
	}

	public bool TryGetPrevTrainCar(Vector3 forwardDir, out TrainCar result)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return TryGetTrainCar(next: false, forwardDir, out result);
	}

	public bool TryGetTrainCar(bool next, Vector3 forwardDir, out TrainCar result)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		result = null;
		if (completeTrain == null)
		{
			return false;
		}
		return completeTrain.TryGetAdjacentTrainCar(this, next, forwardDir, out result);
	}

	public void MoveFrontWheelsAlongTrackSpline(TrainTrackSpline trackSpline, float prevSplineDist, float distToMove, TrainTrackSpline preferredAltTrack, TrainTrackSpline.TrackSelection trackSelection)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		TrainTrackSpline.MoveResult moveResult = trackSpline.MoveAlongSpline(tReq: new TrainTrackSpline.TrackRequest(trackSelection, preferredAltTrack, null), prevSplineDist: prevSplineDist, askerForward: ((Component)this).transform.forward, distMoved: distToMove);
		TrainTrackSpline frontTS = moveResult.spline;
		FrontWheelSplineDist = moveResult.distAlongSpline;
		frontAtEndOfLine = moveResult.atEndOfLine;
		Vector3 tangent;
		Vector3 positionAndTangent = frontTS.GetPositionAndTangent(FrontWheelSplineDist, ((Component)this).transform.forward, out tangent);
		SetTheRestFromFrontWheelData(ref frontTS, positionAndTangent, tangent, trackSelection, trackSpline, instantMove: false);
		FrontTrackSection = frontTS;
	}

	public Vector3 GetFrontWheelPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * frontBogieLocalOffset;
	}

	public Vector3 GetRearWheelPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * rearBogieLocalOffset;
	}

	public void SetTheRestFromFrontWheelData(ref TrainTrackSpline frontTS, Vector3 targetFrontWheelPos, Vector3 targetFrontWheelTangent, TrainTrackSpline.TrackSelection trackSelection, TrainTrackSpline additionalAlt, bool instantMove)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		TrainTrackSpline.TrackRequest tReq = new TrainTrackSpline.TrackRequest(trackSelection, RearTrackSection, additionalAlt);
		TrainTrackSpline.MoveResult moveResult = frontTS.MoveAlongSpline(FrontWheelSplineDist, ((Component)this).transform.forward, 0f - distFrontToBackWheel, tReq);
		TrainTrackSpline spline = moveResult.spline;
		float distAlongSpline = moveResult.distAlongSpline;
		rearAtEndOfLine = moveResult.atEndOfLine;
		Vector3 tangent;
		Vector3 positionAndTangent = spline.GetPositionAndTangent(distAlongSpline, ((Component)this).transform.forward, out tangent);
		if (rearAtEndOfLine)
		{
			moveResult = spline.MoveAlongSpline(tReq: new TrainTrackSpline.TrackRequest(trackSelection, spline, additionalAlt), prevSplineDist: distAlongSpline, askerForward: ((Component)this).transform.forward, distMoved: distFrontToBackWheel);
			frontTS = moveResult.spline;
			FrontWheelSplineDist = moveResult.distAlongSpline;
			frontAtEndOfLine = moveResult.atEndOfLine;
			targetFrontWheelPos = frontTS.GetPositionAndTangent(FrontWheelSplineDist, ((Component)this).transform.forward, out targetFrontWheelTangent);
		}
		RearTrackSection = spline;
		Vector3 val = targetFrontWheelPos - positionAndTangent;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = targetFrontWheelPos - Quaternion.LookRotation(normalized) * frontBogieLocalOffset;
		if (instantMove)
		{
			((Component)this).transform.position = val2;
			if (((Vector3)(ref normalized)).magnitude == 0f)
			{
				((Component)this).transform.rotation = Quaternion.identity;
			}
			else
			{
				((Component)this).transform.rotation = Quaternion.LookRotation(normalized);
			}
		}
		else
		{
			((Component)this).transform.position = val2;
			if (((Vector3)(ref normalized)).magnitude == 0f)
			{
				((Component)this).transform.rotation = Quaternion.identity;
			}
			else
			{
				((Component)this).transform.rotation = Quaternion.LookRotation(normalized);
			}
		}
		frontBogieYRot = Vector3.SignedAngle(((Component)this).transform.forward, targetFrontWheelTangent, ((Component)this).transform.up);
		rearBogieYRot = Vector3.SignedAngle(((Component)this).transform.forward, tangent, ((Component)this).transform.up);
		if (Application.isEditor)
		{
			Debug.DrawLine(targetFrontWheelPos, positionAndTangent, Color.magenta, 0.2f);
			Debug.DrawLine(rigidBody.position, val2, Color.yellow, 0.2f);
			Debug.DrawRay(val2, Vector3.up, Color.yellow, 0.2f);
		}
	}

	public float GetForces()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		float num = ((Component)this).transform.localEulerAngles.x;
		if (num > 180f)
		{
			num -= 360f;
		}
		return 0f + num / 90f * (0f - Physics.gravity.y) * RealisticMass * 0.33f + GetThrottleForce();
	}

	protected virtual float GetThrottleForce()
	{
		return 0f;
	}

	public virtual bool HasThrottleInput()
	{
		return false;
	}

	public float ApplyCollisionDamage(float forceMagnitude)
	{
		float num = ((!(forceMagnitude > derailCollisionForce)) ? (Mathf.Pow(forceMagnitude, 1.3f) / collisionDamageDivide) : float.MaxValue);
		Hurt(num, DamageType.Collision, this, useProtection: false);
		return num;
	}

	public bool SpaceIsClear()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapOBB(WorldSpaceBounds(), list, 32768, (QueryTriggerInteraction)1);
		foreach (Collider item in list)
		{
			if (!ColliderIsPartOfTrain(item))
			{
				Pool.FreeUnmanaged<Collider>(ref list);
				return false;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return true;
	}

	public bool ColliderIsPartOfTrain(Collider collider)
	{
		BaseEntity baseEntity = collider.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return false;
		}
		if ((Object)(object)baseEntity == (Object)(object)this)
		{
			return true;
		}
		BaseEntity baseEntity2 = baseEntity.parentEntity.Get(base.isServer);
		if (baseEntity2.IsValid())
		{
			return (Object)(object)baseEntity2 == (Object)(object)this;
		}
		return false;
	}

	public void UpdateClients()
	{
		if (IsMoving())
		{
			ClientRPC(RpcTarget.NetworkGroup("BaseTrainUpdate"), GetNetworkTime(), frontBogieYRot, rearBogieYRot);
		}
	}

	public void DecayTick()
	{
		if (completeTrain == null)
		{
			return;
		}
		bool flag = HasDriver() || completeTrain.AnyPlayersOnTrain();
		if (flag)
		{
			decayingFor = 0f;
		}
		float num = GetDecayMinutes(flag) * 60f;
		float time = Time.time;
		float num2 = time - lastDecayTick;
		lastDecayTick = time;
		if (num != float.PositiveInfinity)
		{
			decayingFor += num2;
			if (decayingFor >= num && CanDieFromDecayNow())
			{
				ActualDeath();
			}
		}
	}

	public virtual float GetDecayMinutes(bool hasPassengers)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		bool flag = IsAtAStation && Vector3.Distance(spawnOrigin, ((Component)this).transform.position) < 50f;
		if (hasPassengers || AnyPlayersNearby(30f) || flag || IsOnAboveGroundSpawnRail)
		{
			return float.PositiveInfinity;
		}
		return decayminutes * decayTimeMultiplier;
	}

	public virtual bool CanDieFromDecayNow()
	{
		if (CarType != TrainCarType.Engine)
		{
			return !completeTrain.IncludesAnEngine();
		}
		return true;
	}

	public bool AnyPlayersNearby(float maxDist)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return BaseNetworkable.HasCloseConnections(((Component)this).transform.position, maxDist);
	}

	[RPC_Server]
	public void RPC_WantsUncouple(RPCMessage msg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !(Vector3.SqrMagnitude(((Component)this).transform.position - ((Component)player).transform.position) > 200f) && Interface.CallHook("OnTrainCarUncouple", (object)this, (object)msg.player) == null)
		{
			bool front = msg.read.Bit();
			coupling.Uncouple(front);
		}
	}
}


public enum TrainCarType
{
	Wagon,
	Engine,
	Other
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class TrainCarUnloadable : TrainCar
{
	public enum WagonType
	{
		Ore,
		Lootboxes,
		Fuel
	}

	[SerializeField]
	[Header("Train Car Unloadable")]
	private GameObjectRef storagePrefab;

	[SerializeField]
	private BoxCollider[] unloadingAreas;

	[SerializeField]
	private TrainCarFuelHatches fuelHatches;

	[SerializeField]
	private Transform orePlaneVisuals;

	[SerializeField]
	private Transform orePlaneColliderDetailed;

	[SerializeField]
	private Transform orePlaneColliderWorld;

	[SerializeField]
	[Range(0f, 1f)]
	public float vacuumStretchPercent = 0.5f;

	[SerializeField]
	private ParticleSystemContainer unloadingFXContainer;

	[SerializeField]
	private ParticleSystem unloadingFX;

	public WagonType wagonType;

	private int lootTypeIndex = -1;

	private List<EntityRef<LootContainer>> lootContainers = new List<EntityRef<LootContainer>>();

	private Vector3 _oreScale = Vector3.one;

	private float animPercent;

	private float prevAnimTime;

	[ServerVar(Help = "How long before an unloadable train car despawns afer being unloaded")]
	public static float decayminutesafterunload = 10f;

	private EntityRef<StorageContainer> storageInstance;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TrainCarUnloadable.OnRpcMessage", 0);
		try
		{
			if (rpc == 4254195175u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Open "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Open", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4254195175u, "RPC_Open", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Open(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Open");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old.HasFlag(Flags.Reserved4) != next.HasFlag(Flags.Reserved4) && (Object)(object)fuelHatches != (Object)null)
		{
			fuelHatches.LinedUpStateChanged(base.LinedUpToUnload);
		}
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		base.OnChildAdded(child);
		if (IsDead() || base.IsDestroyed)
		{
			return;
		}
		LootContainer lootContainer = default(LootContainer);
		if (((Component)child).TryGetComponent<LootContainer>(ref lootContainer))
		{
			if (base.isServer)
			{
				lootContainer.inventory.SetLocked(!IsEmpty());
			}
			lootContainers.Add(new EntityRef<LootContainer>(lootContainer.net.ID));
		}
		if (base.isServer && child.prefabID == storagePrefab.GetEntity().prefabID)
		{
			StorageContainer storageContainer = (StorageContainer)child;
			storageInstance.Set(storageContainer);
			if (!Application.isLoadingSave)
			{
				FillWithLoot(storageContainer);
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.baseTrain != null)
		{
			lootTypeIndex = info.msg.baseTrain.lootTypeIndex;
			if (base.isServer)
			{
				SetVisualOreLevel(info.msg.baseTrain.lootPercent);
			}
		}
	}

	public bool IsEmpty()
	{
		return GetOrePercent() == 0f;
	}

	public bool TryGetLootType(out TrainWagonLootData.LootOption lootOption)
	{
		return TrainWagonLootData.instance.TryGetLootFromIndex(lootTypeIndex, out lootOption);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		return !IsEmpty();
	}

	public int GetFilledLootAmount()
	{
		if (TryGetLootType(out var lootOption))
		{
			return lootOption.maxLootAmount;
		}
		Debug.LogWarning((object)(((object)this).GetType().Name + ": Called GetFilledLootAmount without a lootTypeIndex set."));
		return 0;
	}

	public void SetVisualOreLevel(float percent)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)orePlaneColliderDetailed == (Object)null))
		{
			_oreScale.y = Mathf.Clamp01(percent);
			orePlaneColliderDetailed.localScale = _oreScale;
			if (base.isClient)
			{
				orePlaneVisuals.localScale = _oreScale;
				((Component)orePlaneVisuals).gameObject.SetActive(percent > 0f);
			}
			if (base.isServer)
			{
				orePlaneColliderWorld.localScale = _oreScale;
			}
		}
	}

	private void AnimateUnload(float startPercent)
	{
		prevAnimTime = Time.time;
		animPercent = startPercent;
		if (base.isClient && (Object)(object)unloadingFXContainer != (Object)null)
		{
			unloadingFXContainer.Play();
		}
		((FacepunchBehaviour)this).InvokeRepeating((Action)UnloadAnimTick, 0f, 0f);
	}

	private void UnloadAnimTick()
	{
		animPercent -= (Time.time - prevAnimTime) / 40f;
		SetVisualOreLevel(animPercent);
		prevAnimTime = Time.time;
		if (animPercent <= 0f)
		{
			EndUnloadAnim();
		}
	}

	private void EndUnloadAnim()
	{
		if (base.isClient && (Object)(object)unloadingFXContainer != (Object)null)
		{
			unloadingFXContainer.Stop();
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)UnloadAnimTick);
	}

	public float GetOrePercent()
	{
		if (base.isServer)
		{
			return TrainWagonLootData.GetOrePercent(lootTypeIndex, GetStorageContainer());
		}
		return 0f;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseTrain.lootTypeIndex = lootTypeIndex;
		info.msg.baseTrain.lootPercent = GetOrePercent();
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot)
		{
			foreach (EntityRef<LootContainer> lootContainer2 in lootContainers)
			{
				LootContainer lootContainer = lootContainer2.Get(base.isServer);
				if ((Object)(object)lootContainer != (Object)null && lootContainer.inventory != null && !lootContainer.inventory.IsLocked())
				{
					lootContainer.DropItems();
				}
			}
		}
		base.DoServerDestroy();
	}

	public bool IsLinedUpToUnload(BoxCollider unloaderBounds)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		BoxCollider[] array = unloadingAreas;
		foreach (BoxCollider val in array)
		{
			Bounds val2 = ((Collider)unloaderBounds).bounds;
			if (((Bounds)(ref val2)).Intersects(((Collider)val).bounds))
			{
				return true;
			}
		}
		return false;
	}

	public void FillWithLoot(StorageContainer sc)
	{
		sc.inventory.Clear();
		ItemManager.DoRemoves();
		TrainWagonLootData.LootOption lootOption = TrainWagonLootData.instance.GetLootOption(wagonType, out lootTypeIndex);
		int amount = Random.Range(lootOption.minLootAmount, lootOption.maxLootAmount);
		ItemDefinition itemToCreate = ItemManager.FindItemDefinition(lootOption.lootItem.itemid);
		sc.inventory.AddItem(itemToCreate, amount, 0uL, ItemContainer.LimitStack.All);
		sc.inventory.SetLocked(isLocked: true);
		SetVisualOreLevel(GetOrePercent());
		SendNetworkUpdate();
	}

	public void EmptyOutLoot(StorageContainer sc)
	{
		sc.inventory.Clear();
		ItemManager.DoRemoves();
		SetVisualOreLevel(GetOrePercent());
		SendNetworkUpdate();
	}

	public void BeginUnloadAnimation()
	{
		float orePercent = GetOrePercent();
		AnimateUnload(orePercent);
		ClientRPC(RpcTarget.NetworkGroup("RPC_AnimateUnload"), orePercent);
	}

	public void EndEmptyProcess()
	{
		float orePercent = GetOrePercent();
		if (!(orePercent > 0f))
		{
			lootTypeIndex = -1;
			foreach (EntityRef<LootContainer> lootContainer2 in lootContainers)
			{
				LootContainer lootContainer = lootContainer2.Get(base.isServer);
				if ((Object)(object)lootContainer != (Object)null && lootContainer.inventory != null)
				{
					lootContainer.inventory.SetLocked(isLocked: false);
				}
			}
		}
		SetVisualOreLevel(orePercent);
		ClientRPC(RpcTarget.NetworkGroup("RPC_StopAnimateUnload"), orePercent);
		decayingFor = 0f;
	}

	public StorageContainer GetStorageContainer()
	{
		StorageContainer storageContainer = storageInstance.Get(base.isServer);
		if (storageContainer.IsValid())
		{
			return storageContainer;
		}
		return null;
	}

	protected override float GetDecayMinutes(bool hasPassengers)
	{
		if ((wagonType == WagonType.Ore || wagonType == WagonType.Fuel) && !hasPassengers && IsEmpty())
		{
			return decayminutesafterunload;
		}
		return base.GetDecayMinutes(hasPassengers);
	}

	protected override bool CanDieFromDecayNow()
	{
		if (IsEmpty())
		{
			return true;
		}
		return base.CanDieFromDecayNow();
	}

	public override bool AdminFixUp(int tier)
	{
		if (!base.AdminFixUp(tier))
		{
			return false;
		}
		StorageContainer storageContainer = GetStorageContainer();
		if (storageContainer.IsValid())
		{
			if (tier > 1)
			{
				FillWithLoot(storageContainer);
			}
			else
			{
				EmptyOutLoot(storageContainer);
			}
		}
		return true;
	}

	public float MinDistToUnloadingArea(Vector3 point)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		point.y = 0f;
		BoxCollider[] array = unloadingAreas;
		foreach (BoxCollider val in array)
		{
			Vector3 val2 = ((Component)val).transform.position + ((Component)val).transform.rotation * val.center;
			val2.y = 0f;
			float num2 = Vector3.Distance(point, val2);
			if (num2 < num)
			{
				num = num2;
			}
		}
		return num;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_Open(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			StorageContainer storageContainer = GetStorageContainer();
			if (storageContainer.IsValid())
			{
				storageContainer.PlayerOpenLoot(player);
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
			}
		}
	}

	public void SetLootPercentage(float value)
	{
		TrainWagonLootData.SetOrePercent(lootTypeIndex, GetStorageContainer(), value);
	}
}


public enum WagonType
{
	Ore,
	Lootboxes,
	Fuel
}


using System;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using Rust.UI;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

public class TrainEngine : TrainCar, IEngineControllerUser, IEntity
{
	private enum LeverStyle
	{
		WorkCart,
		Locomotive
	}

	public enum EngineSpeeds
	{
		Rev_Hi,
		Rev_Med,
		Rev_Lo,
		Zero,
		Fwd_Lo,
		Fwd_Med,
		Fwd_Hi
	}

	[Header("Train Engine")]
	[SerializeField]
	public Transform leftHandLever;

	[SerializeField]
	public Transform rightHandLever;

	[SerializeField]
	public Transform leftHandGrip;

	[SerializeField]
	public Transform rightHandGrip;

	[SerializeField]
	private LeverStyle leverStyle;

	[SerializeField]
	public Canvas monitorCanvas;

	[SerializeField]
	public RustText monitorText;

	[SerializeField]
	private LocomotiveExtraVisuals gauges;

	[SerializeField]
	public float engineForce = 50000f;

	[SerializeField]
	public float maxSpeed = 12f;

	[SerializeField]
	public float engineStartupTime = 1f;

	[SerializeField]
	public GameObjectRef fuelStoragePrefab;

	[SerializeField]
	public float idleFuelPerSec = 0.05f;

	[SerializeField]
	public float maxFuelPerSec = 0.15f;

	[SerializeField]
	public ProtectionProperties driverProtection;

	[SerializeField]
	public bool lootablesAreOnPlatform;

	[SerializeField]
	private bool mustMountFromPlatform = true;

	[SerializeField]
	private VehicleLight[] onLights;

	[SerializeField]
	public VehicleLight[] headlights;

	[SerializeField]
	private VehicleLight[] notMovingLights;

	[SerializeField]
	private VehicleLight[] movingForwardLights;

	[FormerlySerializedAs("movingBackwardsLights")]
	[SerializeField]
	private VehicleLight[] movingBackwardLights;

	[SerializeField]
	public ParticleSystemContainer fxEngineOn;

	[SerializeField]
	public ParticleSystemContainer fxLightDamage;

	[SerializeField]
	public ParticleSystemContainer fxMediumDamage;

	[SerializeField]
	public ParticleSystemContainer fxHeavyDamage;

	[SerializeField]
	public ParticleSystemContainer fxEngineTrouble;

	[SerializeField]
	public BoxCollider engineWorldCol;

	[SerializeField]
	public float engineDamageToSlow = 150f;

	[SerializeField]
	public float engineDamageTimeframe = 10f;

	[SerializeField]
	public float engineSlowedTime = 10f;

	[SerializeField]
	public float engineSlowedMaxVel = 4f;

	[SerializeField]
	private ParticleSystemContainer[] sparks;

	[SerializeField]
	[FormerlySerializedAs("brakeSparkLights")]
	private Light[] sparkLights;

	[SerializeField]
	private TrainEngineAudio trainAudio;

	public const Flags Flag_HazardAhead = Flags.Reserved6;

	public const Flags Flag_Horn = Flags.Reserved8;

	public const Flags Flag_AltColor = Flags.Reserved9;

	public const Flags Flag_EngineSlowed = Flags.Reserved10;

	public VehicleEngineController<TrainEngine> engineController;

	public const float HAZARD_CHECK_EVERY = 1f;

	public const float HAZARD_DIST_MAX = 325f;

	public const float HAZARD_DIST_MIN = 20f;

	public const float HAZARD_SPEED_MIN = 4.5f;

	public float buttonHoldTime;

	public static readonly EngineSpeeds MaxThrottle = EngineSpeeds.Fwd_Hi;

	public static readonly EngineSpeeds MinThrottle = EngineSpeeds.Rev_Hi;

	public EngineDamageOverTime engineDamage;

	public Vector3 engineLocalOffset;

	private int __sync_FuelAmountSync;

	private int __sync_NumConnectedCarsSync;

	private int __sync_LinedUpToUnloadSync;

	public bool LightsAreOn => HasFlag(Flags.Reserved5);

	public bool CloseToHazard => HasFlag(Flags.Reserved6);

	public bool EngineIsSlowed => HasFlag(Flags.Reserved10);

	public EngineSpeeds CurThrottleSetting { get; set; } = EngineSpeeds.Zero;

	public override TrainCarType CarType => TrainCarType.Engine;

	[Sync(Autosave = true)]
	private int FuelAmountSync
	{
		[CompilerGenerated]
		get
		{
			return __sync_FuelAmountSync;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_FuelAmountSync, value))
			{
				__sync_FuelAmountSync = value;
				byte nameID = __GetWeaverID("FuelAmountSync");
				QueueSyncVar(nameID);
			}
		}
	}

	[Sync(Autosave = true)]
	private int NumConnectedCarsSync
	{
		[CompilerGenerated]
		get
		{
			return __sync_NumConnectedCarsSync;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_NumConnectedCarsSync, value))
			{
				__sync_NumConnectedCarsSync = value;
				byte nameID = __GetWeaverID("NumConnectedCarsSync");
				QueueSyncVar(nameID);
			}
		}
	}

	[Sync(Autosave = true, Pack = false)]
	private int LinedUpToUnloadSync
	{
		[CompilerGenerated]
		get
		{
			return __sync_LinedUpToUnloadSync;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_LinedUpToUnloadSync, value))
			{
				__sync_LinedUpToUnloadSync = value;
				byte nameID = __GetWeaverID("LinedUpToUnloadSync");
				SV_SyncVarSend(nameID);
			}
		}
	}

	public override bool networkUpdateOnCompleteTrainChange => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TrainEngine.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		EntityFuelSystem fuelSystem = new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
		engineController = new VehicleEngineController<TrainEngine>(this, fuelSystem, base.isServer, engineStartupTime);
		if (base.isServer)
		{
			bool b = SeedRandom.Range((uint)net.ID.Value, 0, 2) == 0;
			SetFlag(Flags.Reserved9, b);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.trainEngine != null)
		{
			engineController.FuelSystem.SetInstanceID(info.msg.trainEngine.fuelStorageID);
			SetThrottle((EngineSpeeds)info.msg.trainEngine.throttleSetting);
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		if (player.isMounted)
		{
			return false;
		}
		if (lootablesAreOnPlatform)
		{
			return PlayerIsOnPlatform(player);
		}
		Vector3 localVelocity = GetLocalVelocity();
		if (((Vector3)(ref localVelocity)).magnitude < 2f)
		{
			return true;
		}
		return PlayerIsOnPlatform(player);
	}

	public float GetEnginePowerMultiplier(float minPercent)
	{
		if (base.healthFraction > 0.4f)
		{
			return 1f;
		}
		return Mathf.Lerp(minPercent, 1f, base.healthFraction / 0.4f);
	}

	public float GetThrottleFraction()
	{
		return CurThrottleSetting switch
		{
			EngineSpeeds.Rev_Hi => -1f, 
			EngineSpeeds.Rev_Med => -0.5f, 
			EngineSpeeds.Rev_Lo => -0.2f, 
			EngineSpeeds.Zero => 0f, 
			EngineSpeeds.Fwd_Lo => 0.2f, 
			EngineSpeeds.Fwd_Med => 0.5f, 
			EngineSpeeds.Fwd_Hi => 1f, 
			_ => 0f, 
		};
	}

	public bool IsNearDesiredSpeed(float leeway)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Dot(((Component)this).transform.forward, GetLocalVelocity());
		float num2 = maxSpeed * GetThrottleFraction();
		if (num2 < 0f)
		{
			return num - leeway <= num2;
		}
		return num + leeway >= num2;
	}

	public override void SetTrackSelection(TrainTrackSpline.TrackSelection trackSelection)
	{
		base.SetTrackSelection(trackSelection);
	}

	public void SetThrottle(EngineSpeeds throttle)
	{
		if (CurThrottleSetting != throttle)
		{
			CurThrottleSetting = throttle;
			if (base.isServer)
			{
				ClientRPC(RpcTarget.NetworkGroup("SetThrottle"), (sbyte)throttle);
			}
		}
	}

	public bool CanMount(BasePlayer player)
	{
		if (mustMountFromPlatform)
		{
			return PlayerIsOnPlatform(player);
		}
		return true;
	}

	public override void ServerInit()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		engineDamage = new EngineDamageOverTime(engineDamageToSlow, engineDamageTimeframe, OnEngineTookHeavyDamage);
		engineLocalOffset = ((Component)this).transform.InverseTransformPoint(((Component)engineWorldCol).transform.position + ((Component)engineWorldCol).transform.rotation * engineWorldCol.center);
	}

	public override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned)
		{
			GetFuelSystem().CheckNewChild(child);
		}
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("TrainEngine.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			engineController.CheckEngineState();
			if (engineController.IsOn)
			{
				float fuelPerSecond = Mathf.Lerp(idleFuelPerSec, maxFuelPerSec, Mathf.Abs(GetThrottleFraction()));
				engineController.TickFuel(fuelPerSecond);
				FuelAmountSync = engineController.FuelSystem.GetFuelAmount();
				NumConnectedCarsSync = completeTrain.NumTrainCars;
				LinedUpToUnloadSync = completeTrain.LinedUpToUnload;
			}
			else if (LightsAreOn && !HasDriver())
			{
				SetFlag(Flags.Reserved5, b: false);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.trainEngine = Pool.Get<TrainEngine>();
		info.msg.trainEngine.throttleSetting = (int)CurThrottleSetting;
		info.msg.trainEngine.fuelStorageID = GetFuelSystem().GetInstanceID();
	}

	public override IFuelSystem GetFuelSystem()
	{
		return engineController.FuelSystem;
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			SetFlag(Flags.Reserved5, !LightsAreOn);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (!IsDriver(player))
		{
			return;
		}
		if (engineController.IsOff)
		{
			if ((inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD)) || (inputState.IsDown(BUTTON.BACKWARD) && !inputState.WasDown(BUTTON.BACKWARD)))
			{
				engineController.TryStartEngine(player);
			}
			SetFlag(Flags.Reserved8, b: false);
		}
		else
		{
			if (!ProcessThrottleInput(BUTTON.FORWARD, IncreaseThrottle))
			{
				ProcessThrottleInput(BUTTON.BACKWARD, DecreaseThrottle);
			}
			SetFlag(Flags.Reserved8, inputState.IsDown(BUTTON.FIRE_PRIMARY));
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			SetTrackSelection(TrainTrackSpline.TrackSelection.Left);
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			SetTrackSelection(TrainTrackSpline.TrackSelection.Right);
		}
		else
		{
			SetTrackSelection(TrainTrackSpline.TrackSelection.Default);
		}
		bool ProcessThrottleInput(BUTTON button, Action action)
		{
			if (inputState.IsDown(button))
			{
				if (!inputState.WasDown(button))
				{
					action();
					buttonHoldTime = 0f;
				}
				else
				{
					buttonHoldTime += Player.clientTickInterval;
					if (buttonHoldTime > 0.55f)
					{
						action();
						buttonHoldTime = 0.4f;
					}
				}
				return true;
			}
			return false;
		}
	}

	public override void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerDismounted(player, seat);
		SetFlag(Flags.Reserved8, b: false);
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		driverProtection.Scale(info.damageTypes);
	}

	public bool MeetsEngineRequirements()
	{
		if (!HasDriver() && CurThrottleSetting == EngineSpeeds.Zero)
		{
			return false;
		}
		if (!completeTrain.AnyPlayersOnTrain())
		{
			return vehicle.trainskeeprunning;
		}
		return true;
	}

	public void OnEngineStartFailed()
	{
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (CanMount(player))
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

	protected override float GetThrottleForce()
	{
		if (IsDead() || base.IsDestroyed)
		{
			return 0f;
		}
		float num = 0f;
		float num2 = (engineController.IsOn ? GetThrottleFraction() : 0f);
		float num3 = maxSpeed * num2;
		float curTopSpeed = GetCurTopSpeed();
		num3 = Mathf.Clamp(num3, 0f - curTopSpeed, curTopSpeed);
		float trackSpeed = GetTrackSpeed();
		if (num2 > 0f && trackSpeed < num3)
		{
			num += GetCurEngineForce();
		}
		else if (num2 < 0f && trackSpeed > num3)
		{
			num -= GetCurEngineForce();
		}
		return num;
	}

	public override bool HasThrottleInput()
	{
		if (engineController.IsOn)
		{
			return CurThrottleSetting != EngineSpeeds.Zero;
		}
		return false;
	}

	public override void Hurt(HitInfo info)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (engineDamage != null && Vector3.SqrMagnitude(engineLocalOffset - info.HitPositionLocal) < 2f)
		{
			engineDamage.TakeDamage(info.damageTypes.Total());
		}
		base.Hurt(info);
	}

	public void StopEngine()
	{
		engineController.StopEngine();
	}

	public override Vector3 GetExplosionPos()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)engineWorldCol).transform.position + engineWorldCol.center;
	}

	public void IncreaseThrottle()
	{
		if (CurThrottleSetting != MaxThrottle)
		{
			SetThrottle(CurThrottleSetting + 1);
		}
	}

	public void DecreaseThrottle()
	{
		if (CurThrottleSetting != MinThrottle)
		{
			SetThrottle(CurThrottleSetting - 1);
		}
	}

	public void SetZeroThrottle()
	{
		SetThrottle(EngineSpeeds.Zero);
	}

	public override void ServerFlagsChanged(Flags old, Flags next)
	{
		base.ServerFlagsChanged(old, next);
		if (next.HasFlag(Flags.On) && !old.HasFlag(Flags.On))
		{
			SetFlag(Flags.Reserved5, b: true);
			((FacepunchBehaviour)this).InvokeRandomized((Action)CheckForHazards, 0f, 1f, 0.1f);
		}
		else if (!next.HasFlag(Flags.On) && old.HasFlag(Flags.On))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckForHazards);
			SetFlag(Flags.Reserved6, b: false);
		}
	}

	public void CheckForHazards()
	{
		float trackSpeed = GetTrackSpeed();
		if (trackSpeed > 4.5f || trackSpeed < -4.5f)
		{
			float maxHazardDist = Mathf.Lerp(40f, 325f, Mathf.Abs(trackSpeed) * 0.05f);
			SetFlag(Flags.Reserved6, base.FrontTrackSection.HasValidHazardWithin(this, base.FrontWheelSplineDist, 20f, maxHazardDist, localTrackSelection, trackSpeed, base.RearTrackSection, null));
		}
		else
		{
			SetFlag(Flags.Reserved6, b: false);
		}
	}

	public void OnEngineTookHeavyDamage()
	{
		SetFlag(Flags.Reserved10, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ResetEngineToNormal, engineSlowedTime);
	}

	public void ResetEngineToNormal()
	{
		SetFlag(Flags.Reserved10, b: false);
	}

	public float GetCurTopSpeed()
	{
		float num = maxSpeed * GetEnginePowerMultiplier(0.5f);
		if (EngineIsSlowed)
		{
			num = Mathf.Clamp(num, 0f - engineSlowedMaxVel, engineSlowedMaxVel);
		}
		return num;
	}

	public float GetCurEngineForce()
	{
		return engineForce * GetEnginePowerMultiplier(0.75f);
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			GetFuelSystem().LootFuel(player);
		}
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId iD;
		switch (id)
		{
		case 0:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: FuelAmountSync for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_FuelAmountSync);
			return true;
		case 1:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: NumConnectedCarsSync for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_NumConnectedCarsSync);
			return true;
		case 2:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: LinedUpToUnloadSync for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_LinedUpToUnloadSync);
			return true;
		default:
			return false;
		}
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		return false;
	}

	private byte __GetWeaverID(string propertyName)
	{
		return propertyName switch
		{
			"FuelAmountSync" => 0, 
			"NumConnectedCarsSync" => 1, 
			"LinedUpToUnloadSync" => 2, 
			_ => 0, 
		};
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteSyncVar(0, val);
		WriteSyncVar(1, val);
		WriteSyncVar(2, val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		return true;
	}

	protected override void ResetSyncVars()
	{
		__sync_FuelAmountSync = 0;
		__sync_NumConnectedCarsSync = 0;
		__sync_LinedUpToUnloadSync = 0;
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


private enum LeverStyle
{
	WorkCart,
	Locomotive
}


public enum EngineSpeeds
{
	Rev_Hi,
	Rev_Med,
	Rev_Lo,
	Zero,
	Fwd_Lo,
	Fwd_Med,
	Fwd_Hi
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class TravellingVendor : BaseEntity, VehicleChassisVisuals<TravellingVendor>.IClientWheelUser, IPathListener
{
	private enum TravellingVendorState
	{
		Stopped,
		Travelling,
		Waiting,
		Aligning
	}

	public static class TravellingVendorFlags
	{
		public const Flags Braking = Flags.Reserved1;

		public const Flags IndicateLeft = Flags.Reserved2;

		public const Flags IndicateRight = Flags.Reserved4;

		public const Flags Lights = Flags.Reserved5;

		public const Flags Hazards = Flags.Reserved6;
	}

	[Flags]
	private enum WheelIsGroundedFlags
	{
		RearLeft = 1,
		RearRight = 2,
		FrontLeft = 4,
		FrontRight = 8
	}

	[Serializable]
	private struct VendorTargetInfo
	{
		public float lastSeenTime;

		public float lastBlockingTime;

		public float blockingAccumulator;

		public float ignoredUntil;

		public bool IsIgnored => ignoredUntil > Time.time;
	}

	[Header("Visuals")]
	public TravellingVendorVisuals visuals;

	[Header("Sounds")]
	public TravellingVendorSounds sounds;

	public SoundPlayer BuySound;

	[SerializeField]
	[Header("References")]
	private VisualCarWheel wheelFL;

	[SerializeField]
	private VisualCarWheel wheelFR;

	[SerializeField]
	private VisualCarWheel wheelRL;

	[SerializeField]
	private VisualCarWheel wheelRR;

	public float client_steering_left;

	public float client_steering_right;

	public Vector3 client_velocity = Vector3.zero;

	private WheelIsGroundedFlags client_wheel_flags;

	public TimeSince timeSinceLastUpdate;

	public VehicleLight headlight;

	public VehicleLight rearLights;

	public VehicleLight rearLeftIndicator;

	public VehicleLight rearRightIndicator;

	private static Collider[] spawncheckColliders = (Collider[])(object)new Collider[2];

	public const string PREFAB_PATH = "assets/prefabs/npc/travelling vendor/travellingvendor.prefab";

	[Header("General")]
	public bool DoAI = true;

	public float ObstacleCheckTime = 0.33f;

	public float MarkerUpdateTime = 0.05f;

	public float TimeBetweenPullovers = 120f;

	[Header("Engine Config")]
	public float motorForceConstant = 300f;

	public float brakeForceConstant = 500f;

	public float acceleration = 2f;

	[Header("Steer Config")]
	public float wheelbase = 3.3f;

	public float rearTrack = 1.6f;

	public float steeringSmoothing = 0.1f;

	public float downforceCoefficient = 10f;

	public float maxSteerAngle = 80f;

	[Header("Trade")]
	public GameObjectRef vendingMachineRef;

	public GameObjectRef vendingMachineFrontRef;

	[Header("Pullover")]
	public float maxPulloverAngleDifference = 15f;

	[Header("Other")]
	public static int obstacleMask = 196608;

	[Header("References")]
	public GameObjectRef mapMarkerEntityPrefab;

	public GameObjectRef preventBuildingPrefab;

	public GameObjectRef backfireEffect;

	public Transform backfirePosition;

	private TriggerVehiclePush pusher;

	private TriggerPlayerForce forcer;

	public NPCVendingMachine vendingMachine;

	[Header("Spline")]
	public float splineMovementSpeed = 2f;

	public Vector3 splineOffset;

	[ServerVar]
	public static bool should_spawn = true;

	[ServerVar]
	public static bool attempt_pullovers = true;

	[ServerVar]
	public static float alive_time_seconds = 1800f;

	[ServerVar]
	public static bool should_destroy_buildings = false;

	[ReplicatedVar(Saved = true)]
	public static float max_speed = 5f;

	private float smoothedSteering;

	private float brakes;

	private float throttle;

	private float targetThrottle = 3f;

	private bool handbrake = true;

	private float steeringAngle;

	private float currentMaxSpeed;

	private Rigidbody myRigidbody;

	private List<RaycastHit> obstacleHits;

	private List<RaycastHit> pulloverHits;

	private Vector3 destination;

	private bool instantLeave;

	private float waitTimeAccumulator;

	private float aliveTimer;

	private TimeSince timeSinceBackfire;

	private bool pullingOver;

	private Vector3 pulloverPosition = Vector3.zero;

	private float pullOverTimer;

	private Vector3 pulloverTangent = Vector3.zero;

	private bool overrideSteering;

	private BaseEntity preventBuildingInstance;

	private RaycastHit hit;

	private TravellingVendorState internalState;

	private WheelIsGroundedFlags wheelFlags;

	private SimpleSplineTranslator splineTranslator;

	private MapMarker mapMarkerInstance;

	private bool globaIndicatorLeft;

	private TimeSince timeSincePlayerDetected;

	private float slowdownStartSpeed;

	private List<Vector3> currentPath;

	private int currentPathIndex;

	private float atDestinationDistance = 8f;

	private bool followingSpine;

	private int splineId = -1;

	private WorldSpline spline;

	private ListDictionary<BasePlayer, VendorTargetInfo> playerRecords;

	private List<BasePlayer> localPlayers;

	private int searchRange = 10;

	private float allowedVendorBlockTime = 1f;

	public Vector3 Velocity => client_velocity;

	public float DriveWheelVelocity => ((Vector3)(ref client_velocity)).magnitude;

	public float SteerAngle => (client_steering_left + client_steering_right) / 2f;

	public float MaxSteerAngle => maxSteerAngle;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TravellingVendor.OnRpcMessage", 0);
		try
		{
			if (rpc == 831304742 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_OpenMenu "));
				}
				TimeWarning val2 = TimeWarning.New("SV_OpenMenu", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(831304742u, "SV_OpenMenu", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_OpenMenu(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_OpenMenu");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public float GetThrottleInput()
	{
		return 1f;
	}

	[ServerVar(Name = "spawn")]
	public static string svspawntravellingvendor(Arg args)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)SpawnTravellingVendor(((Component)args.Player()).transform.position) != (Object)null))
		{
			return "Failed to spawn Travelling Vendor. Is there a ring road present?";
		}
		return "Spawned Travelling Vendor.";
	}

	[ServerVar(Name = "startevent")]
	public static string svspawntravellingvendorevent(Arg args)
	{
		if (!((Object)(object)SpawnTravellingVendorForEvent() != (Object)null))
		{
			return "Failed to spawn Travelling Vendor.";
		}
		return "Spawned Travelling Vendor.";
	}

	public static TravellingVendor SpawnTravellingVendor(Vector3 position)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		RuntimePath runtimePath = new RuntimePath();
		PathList pathList = null;
		float num = float.PositiveInfinity;
		foreach (PathList mainRoad in TerrainMeta.Path.MainRoads)
		{
			_ = Vector3.zero;
			float num2 = float.PositiveInfinity;
			Vector3[] points = mainRoad.Path.Points;
			foreach (Vector3 val in points)
			{
				float num3 = Vector3.Distance(val, position);
				if (num3 < num2)
				{
					num2 = num3;
				}
			}
			if (num2 < num)
			{
				pathList = mainRoad;
				num = num2;
			}
		}
		if (pathList == null)
		{
			Debug.Log((object)"Couldn't find road to spawn on.");
			return null;
		}
		Vector3 startPoint = pathList.Path.GetStartPoint();
		pathList.Path.GetEndPoint();
		int num4 = pathList.Path.Points.Length - 1;
		IAIPathNode[] nodes = new RuntimePathNode[num4];
		runtimePath.Nodes = nodes;
		IAIPathNode iAIPathNode = null;
		int num5 = 0;
		int num6 = pathList.Path.MaxIndex - 1;
		for (int j = pathList.Path.MinIndex; j <= num6; j++)
		{
			IAIPathNode iAIPathNode2 = new RuntimePathNode(pathList.Path.Points[j] + Vector3.up * 1f);
			if (iAIPathNode != null)
			{
				iAIPathNode2.AddLink(iAIPathNode);
				iAIPathNode.AddLink(iAIPathNode2);
			}
			runtimePath.Nodes[num5] = iAIPathNode2;
			iAIPathNode = iAIPathNode2;
			num5++;
		}
		runtimePath.Nodes[0].AddLink(runtimePath.Nodes[runtimePath.Nodes.Length - 1]);
		runtimePath.Nodes[runtimePath.Nodes.Length - 1].AddLink(runtimePath.Nodes[0]);
		int num7 = Mathf.CeilToInt(pathList.Path.Length / 500f);
		num7 = Mathf.Clamp(num7, 1, 3);
		num7++;
		for (int k = 0; k < num7; k++)
		{
			int num8 = Random.Range(0, pathList.Path.Points.Length);
			RuntimeInterestNode interestNode = new RuntimeInterestNode(pathList.Path.Points[num8] + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode);
		}
		Vector3 val2 = runtimePath.Nodes[1].Position - startPoint;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/travelling vendor/travellingvendor.prefab", startPoint + Vector3.up * 2f, Quaternion.LookRotation(normalized));
		TravellingVendor travellingVendor = null;
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			travellingVendor = ((Component)baseEntity).GetComponent<TravellingVendor>();
			if (Object.op_Implicit((Object)(object)travellingVendor))
			{
				travellingVendor.Spawn();
				travellingVendor.InstallPath(runtimePath, 1);
			}
			else
			{
				baseEntity.Kill();
			}
		}
		return travellingVendor;
	}

	private static (bool Valid, int Index) GetSpawnPoint(Vector3[] points)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		int num = Random.Range(0, points.Length);
		for (int i = 0; i < 15; i++)
		{
			if (CheckSpawnPosition(points[num]))
			{
				return (Valid: true, Index: num);
			}
			num = Random.Range(0, points.Length);
		}
		Debug.Log((object)("Failed to spawn a travelling vendor after " + 15 + " attempts."));
		return (Valid: false, Index: 0);
	}

	public static TravellingVendor SpawnTravellingVendorForEvent()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		RuntimePath runtimePath = new RuntimePath();
		PathList pathList = null;
		if (TerrainMeta.Path.MainRoads.Count == 0)
		{
			Debug.Log((object)"Can't spawn Travelling Vendor: No roads available to spawn on.");
			return null;
		}
		foreach (PathList mainRoad in TerrainMeta.Path.MainRoads)
		{
			if (mainRoad.Path.GetStartPoint() == mainRoad.Path.GetEndPoint())
			{
				pathList = mainRoad;
				break;
			}
		}
		if (pathList == null)
		{
			Debug.Log((object)"Can't spawn Travelling Vendor: can't find Ring Road.");
			return null;
		}
		if (pathList.Path.Points.Length == 0)
		{
			Debug.Log((object)"Can't spawn Travelling Vendor: Road has no points.");
			return null;
		}
		int num = pathList.Path.Points.Length - 1;
		IAIPathNode[] nodes = new RuntimePathNode[num];
		runtimePath.Nodes = nodes;
		IAIPathNode iAIPathNode = null;
		int num2 = 0;
		int num3 = pathList.Path.MaxIndex - 1;
		for (int i = pathList.Path.MinIndex; i <= num3; i++)
		{
			IAIPathNode iAIPathNode2 = new RuntimePathNode(pathList.Path.Points[i] + Vector3.up * 1f);
			if (iAIPathNode != null)
			{
				iAIPathNode2.AddLink(iAIPathNode);
				iAIPathNode.AddLink(iAIPathNode2);
			}
			runtimePath.Nodes[num2] = iAIPathNode2;
			iAIPathNode = iAIPathNode2;
			num2++;
		}
		runtimePath.Nodes[0].AddLink(runtimePath.Nodes[runtimePath.Nodes.Length - 1]);
		runtimePath.Nodes[runtimePath.Nodes.Length - 1].AddLink(runtimePath.Nodes[0]);
		int num4 = Mathf.CeilToInt(pathList.Path.Length / 500f);
		num4 = Mathf.Clamp(num4, 1, 3);
		num4++;
		for (int j = 0; j < num4; j++)
		{
			int num5 = Random.Range(0, pathList.Path.Points.Length);
			RuntimeInterestNode interestNode = new RuntimeInterestNode(pathList.Path.Points[num5] + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode);
		}
		(bool, int) spawnPoint = GetSpawnPoint(pathList.Path.Points);
		if (spawnPoint.Item1)
		{
			int item = spawnPoint.Item2;
			Vector3 val = pathList.Path.Points[(item + 1) % pathList.Path.Points.Length] - pathList.Path.Points[item];
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/travelling vendor/travellingvendor.prefab", pathList.Path.Points[item] + Vector3.up * 2f, Quaternion.LookRotation(normalized));
			TravellingVendor travellingVendor = null;
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				travellingVendor = ((Component)baseEntity).GetComponent<TravellingVendor>();
				if (Object.op_Implicit((Object)(object)travellingVendor))
				{
					travellingVendor.Spawn();
					travellingVendor.InstallPath(runtimePath, (item + 1) % pathList.Path.Points.Length);
				}
				else
				{
					baseEntity.Kill();
				}
			}
			return travellingVendor;
		}
		return null;
	}

	private static bool CheckSpawnPosition(Vector3 testPosition)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (TerrainMeta.TopologyMap.GetTopology(testPosition, 1024))
		{
			return false;
		}
		Physics.OverlapSphereNonAlloc(testPosition, 0.3f, spawncheckColliders, obstacleMask | 0x8000000);
		bool flag = false;
		Collider[] array = spawncheckColliders;
		foreach (Collider val in array)
		{
			if (!((Object)(object)val == (Object)null) && !((Component)val).CompareTag("IgnoreCollider"))
			{
				flag = true;
				break;
			}
		}
		return !flag;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (child.prefabID == vendingMachineRef.GetEntity().prefabID && !Application.isLoadingSave)
		{
			vendingMachine = child as NPCVendingMachine;
			if (base.isServer && (Object)(object)vendingMachine != (Object)null)
			{
				vendingMachine.SetFlag(Flags.Reserved4, b: false);
				vendingMachine.UpdateMapMarker();
				vendingMachine.ChangeRefillTime(alive_time_seconds * 0.334f);
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SV_OpenMenu(RPCMessage msg)
	{
		if ((Object)(object)vendingMachine == (Object)null)
		{
			vendingMachine = ((Component)this).GetComponentInChildren<NPCVendingMachine>();
		}
		if (Interface.CallHook("OnVendingShopOpen", (object)vendingMachine, (object)msg.player) == null)
		{
			vendingMachine.OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", (object)vendingMachine, (object)msg.player);
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override bool IsDebugging()
	{
		return false;
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		BaseCombatEntity baseCombatEntity = info.Initiator as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity != (Object)null)
		{
			baseCombatEntity.MarkHostileFor();
		}
	}

	public void CreateMapMarker()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)mapMarkerInstance != (Object)null)
		{
			mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerEntityPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.Spawn();
		mapMarkerInstance = baseEntity as MapMarker;
	}

	public void CreatePreventBuilding()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)preventBuildingInstance != (Object)null)
		{
			preventBuildingInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(preventBuildingPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		preventBuildingInstance = baseEntity;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		UpdateWheelFlags();
		info.msg.travellingVendor = Pool.Get<TravellingVendor>();
		info.msg.travellingVendor.steeringAngle = wheelFL.wheelCollider.steerAngle;
		info.msg.travellingVendor.velocity = (IsFollowingSpline() ? (((Component)this).transform.forward * splineTranslator.Speed) : myRigidbody.velocity);
		info.msg.travellingVendor.wheelFlags = (int)wheelFlags;
	}

	public override void ServerInit()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (!base.isClient)
		{
			myRigidbody = ((Component)this).GetComponent<Rigidbody>();
			obstacleHits = Pool.Get<List<RaycastHit>>();
			pulloverHits = Pool.Get<List<RaycastHit>>();
			currentMaxSpeed = max_speed;
			timeSinceBackfire = TimeSince.op_Implicit(0f);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Reserved1, b: false);
			SetFlag(Flags.Reserved5, b: false);
			NightCheck();
			pusher = ((Component)this).GetComponentInChildren<TriggerVehiclePush>();
			forcer = ((Component)this).GetComponentInChildren<TriggerPlayerForce>();
			CreateMapMarker();
			CreatePreventBuilding();
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateObstacles, 0f, ObstacleCheckTime);
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateMarker, 0f, MarkerUpdateTime);
			((FacepunchBehaviour)this).InvokeRepeating((Action)BuildingCheck, 1f, 3f);
			((FacepunchBehaviour)this).InvokeRepeating((Action)NightCheck, 0f, 120f);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if ((Object)(object)preventBuildingInstance != (Object)null && preventBuildingInstance.IsValid())
		{
			preventBuildingInstance.Kill();
		}
		if ((Object)(object)mapMarkerInstance != (Object)null && mapMarkerInstance.IsValid())
		{
			mapMarkerInstance.Kill();
		}
		if (localPlayers != null)
		{
			Pool.FreeUnmanaged<BasePlayer>(ref localPlayers);
		}
		if (obstacleHits != null)
		{
			Pool.FreeUnmanaged<RaycastHit>(ref obstacleHits);
		}
		if (pulloverHits != null)
		{
			Pool.FreeUnmanaged<RaycastHit>(ref pulloverHits);
		}
		if (currentPath != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref currentPath);
		}
	}

	private void StartBackfire()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(backfireEffect.resourcePath, this, 0u, backfirePosition.localPosition, Vector3.zero);
	}

	private void StartHorn()
	{
		ClientRPC(RpcTarget.NetworkGroup("CL_PlayerDetected"));
	}

	private void FixedUpdate()
	{
		if (!base.isClient && DoAI && HasPath())
		{
			ProcessLifetime();
			ProcessHandbrake();
			if (!IsFollowingSpline())
			{
				DoSteering();
				ApplyDownforce();
			}
			ProcessState();
			FetchTargets();
			SendNetworkUpdate();
		}
	}

	private void ProcessHandbrake()
	{
		if (handbrake && !(aliveTimer <= 5f) && wheelFL.wheelCollider.isGrounded && wheelFR.wheelCollider.isGrounded)
		{
			handbrake = false;
			wheelFL.wheelCollider.brakeTorque = 0f;
			wheelFR.wheelCollider.brakeTorque = 0f;
			wheelRL.wheelCollider.brakeTorque = 0f;
			wheelRR.wheelCollider.brakeTorque = 0f;
		}
	}

	private void SetGlobalIndicator()
	{
		if (HasFlag(Flags.Reserved6))
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		if (globaIndicatorLeft)
		{
			SetFlag(Flags.Reserved2, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved4, b: true);
		}
	}

	private void TurnOffIndicators()
	{
		if (HasFlag(Flags.Reserved2) || HasFlag(Flags.Reserved4))
		{
			SetFlag(Flags.Reserved2, b: false);
			SetFlag(Flags.Reserved4, b: false);
		}
	}

	private void UpdateMarker()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)mapMarkerInstance == (Object)null))
		{
			((Component)mapMarkerInstance).transform.SetPositionAndRotation(((Component)this).transform.position, ((Component)this).transform.rotation);
			mapMarkerInstance.SendNetworkUpdate();
		}
	}

	private void NightCheck()
	{
		bool flag = (Object)(object)TOD_Sky.Instance != (Object)null && (TOD_Sky.Instance.Cycle.Hour > 19f || TOD_Sky.Instance.Cycle.Hour < 8f);
		if (HasFlag(Flags.Reserved5) != flag)
		{
			SetFlag(Flags.Reserved5, flag);
		}
	}

	private void ProcessLifetime()
	{
		aliveTimer += Time.deltaTime;
		if (!(aliveTimer >= alive_time_seconds))
		{
			return;
		}
		if (localPlayers.Count > 0)
		{
			aliveTimer += 120f;
			return;
		}
		if ((Object)(object)mapMarkerInstance != (Object)null)
		{
			mapMarkerInstance.Kill();
		}
		if ((Object)(object)preventBuildingInstance != (Object)null)
		{
			preventBuildingInstance.Kill();
		}
		TravellingVendorEvent.currentVendor = null;
		Kill();
	}

	private void ProcessState()
	{
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return;
		}
		if (internalState == TravellingVendorState.Stopped)
		{
			targetThrottle = 0f;
			if (HasPath())
			{
				internalState = TravellingVendorState.Travelling;
			}
		}
		if (internalState == TravellingVendorState.Travelling)
		{
			targetThrottle = 2f;
			if (instantLeave)
			{
				instantLeave = false;
			}
			if (overrideSteering)
			{
				overrideSteering = false;
			}
			if (!IsFollowingSpline())
			{
				if (!pullingOver)
				{
					AdvancePath();
					pullOverTimer += Time.deltaTime;
					if (pullOverTimer > TimeBetweenPullovers && attempt_pullovers)
					{
						pullingOver = true;
					}
				}
				else
				{
					HandlePullover();
				}
			}
			if (CheckForObstacle())
			{
				instantLeave = true;
				SetWaiting();
				return;
			}
			if (!IsFollowingSpline())
			{
				ApplyForceAtWheels();
			}
			else
			{
				TravelOnSpline();
			}
			if (IsValidPatrons())
			{
				if (pulloverPosition != Vector3.zero)
				{
					return;
				}
				SetWaiting();
			}
		}
		if (internalState == TravellingVendorState.Aligning)
		{
			targetThrottle = 0.2f;
			Vector3 val = currentPath[GetPathIndexAhead(3)] - currentPath[GetPathIndexAhead(2)];
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			float steerAngle = ((Vector3.Dot(((Component)this).transform.right, normalized) <= 0f) ? (0f - MaxSteerAngle) : MaxSteerAngle);
			if (Vector3.Angle(((Component)this).transform.forward, pulloverTangent) > 5f)
			{
				wheelFL.wheelCollider.steerAngle = steerAngle;
				wheelFR.wheelCollider.steerAngle = steerAngle;
				ApplyForceAtWheels();
			}
			else
			{
				overrideSteering = false;
				SetPulloverWaiting();
			}
		}
		if (internalState != TravellingVendorState.Waiting)
		{
			return;
		}
		targetThrottle = 0f;
		if (!IsFollowingSpline())
		{
			ApplyBrakesAtWheels();
		}
		else
		{
			SlowOnSpline();
		}
		if (CheckForObstacle())
		{
			return;
		}
		if (!IsValidPatrons() || instantLeave)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)SetTravelling))
			{
				float num = 0f;
				if (waitTimeAccumulator > 0f)
				{
					num = GetWaitAccumulator();
				}
				float num2 = 10f + num;
				((FacepunchBehaviour)this).Invoke((Action)SetTravelling, instantLeave ? 0f : num2);
				if (!instantLeave)
				{
					((FacepunchBehaviour)this).Invoke((Action)SetGlobalIndicator, num2 - 5f);
				}
			}
		}
		else if (((FacepunchBehaviour)this).IsInvoking((Action)SetTravelling))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SetTravelling);
		}
	}

	private void HandlePullover()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (pulloverPosition == Vector3.zero && !FindPullingOverSpot())
		{
			ResetPullover();
			pulloverPosition = Vector3.zero;
			currentMaxSpeed = 1f;
		}
		else
		{
			if (!AtDestination())
			{
				return;
			}
			if (Vector3.Angle(((Component)this).transform.forward, pulloverTangent) > 5f && pulloverPosition != Vector3.zero)
			{
				Vector3 position = pulloverPosition + pulloverTangent * 2f;
				if (!IsPositionClear(position, 2f))
				{
					SetPulloverWaiting();
					return;
				}
				overrideSteering = true;
				internalState = TravellingVendorState.Aligning;
				SetFlag(Flags.Reserved1, b: false);
			}
			else
			{
				SetPulloverWaiting();
			}
		}
	}

	private void SetPulloverWaiting()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		currentPathIndex = GetPathIndexAhead(4);
		SetDestination(currentPath[currentPathIndex]);
		SetWaiting();
		TurnOffIndicators();
		SetFlag(Flags.Reserved6, b: true);
		waitTimeAccumulator += 60f;
		ResetPullover();
	}

	private bool FindPullingOverSpot()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		pulloverHits.Clear();
		bool flag = Random.value > 0.5f;
		Vector3 val = currentPath[GetPathIndexAhead(3)] - currentPath[GetPathIndexAhead(2)];
		pulloverTangent = ((Vector3)(ref val)).normalized;
		Vector3 val2 = Vector3.Cross(((Component)this).transform.up, pulloverTangent);
		Vector3 val3 = Vector3.Cross(pulloverTangent, ((Component)this).transform.up);
		if (!TryFindClearPulloverPoint(flag, out var testedPosition))
		{
			flag = !flag;
			if (!TryFindClearPulloverPoint(flag, out testedPosition))
			{
				return false;
			}
		}
		globaIndicatorLeft = !flag;
		if (flag)
		{
			SetFlag(Flags.Reserved2, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved4, b: true);
		}
		if ((Object)(object)preventBuildingInstance != (Object)null)
		{
			preventBuildingInstance.SetParent(null);
			((Component)preventBuildingInstance).transform.position = pulloverPosition;
		}
		pulloverPosition = testedPosition;
		SetDestination(pulloverPosition, 2f);
		return true;
	}

	private Vector3 GetAdjustedPulloverPoint(bool onLeft)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		Vector3 side = (onLeft ? Vector3.Cross(pulloverTangent, ((Component)this).transform.up) : Vector3.Cross(((Component)this).transform.up, pulloverTangent));
		Vector3 pulloverPointFromSide = GetPulloverPointFromSide(side);
		float height = TerrainMeta.HeightMap.GetHeight(pulloverPointFromSide);
		pulloverPointFromSide.y = height + 1f;
		return pulloverPointFromSide;
	}

	private bool TryFindClearPulloverPoint(bool onLeft, out Vector3 testedPosition)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 adjustedPulloverPoint = GetAdjustedPulloverPoint(onLeft);
		Vector3 val = adjustedPulloverPoint - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		testedPosition = adjustedPulloverPoint;
		bool num = IsDirectionClear(normalized, adjustedPulloverPoint);
		bool flag = IsPositionClear(adjustedPulloverPoint);
		return num && flag;
	}

	private Vector3 GetPulloverPointFromSide(Vector3 side, bool inFront = true)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (inFront)
		{
			return currentPath[GetPathIndexAhead(2)] + side * 3.2f + pulloverTangent * 3f;
		}
		return currentPath[GetPathIndexAhead(-2)] + side * 3.2f + pulloverTangent * 3f;
	}

	private bool IsPositionClear(Vector3 position, float radiusCheck = 4.5f)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(position, radiusCheck, list, obstacleMask, (QueryTriggerInteraction)2);
		bool result = true;
		if (list == null)
		{
			return false;
		}
		if (list.Count > 0)
		{
			foreach (Collider item in list)
			{
				if (!((Object)(object)item == (Object)null) && !((Object)(object)((Component)item).gameObject == (Object)null) && !((Object)(object)((Component)item).transform == (Object)null) && !((Component)item).transform.IsChildOf(((Component)this).transform) && !((Object)(object)((Component)item).transform == (Object)(object)((Component)this).transform) && !((Component)item).CompareTag("IgnoreCollider"))
				{
					result = false;
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private bool IsDirectionClear(Vector3 direction, Vector3 point)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		UpdateObstacleList(pulloverHits, direction, 3.5f);
		foreach (RaycastHit pulloverHit in pulloverHits)
		{
			RaycastHit current = pulloverHit;
			if (!((Component)((RaycastHit)(ref current)).collider).CompareTag("IgnoreCollider") && !((Component)((RaycastHit)(ref current)).collider).CompareTag("Main Terrain") && !((Component)((RaycastHit)(ref current)).collider).transform.IsChildOf(((Component)this).transform) && !((Object)(object)((Component)((RaycastHit)(ref current)).collider).transform == (Object)(object)((Component)this).transform))
			{
				return false;
			}
		}
		float height = TerrainMeta.HeightMap.GetHeight(point);
		Vector3 testPos = point;
		testPos.y = height + 1f;
		if (Vector3Ex.DotDegrees(((Component)this).transform.up, GetTerrainNormal(testPos)) >= maxPulloverAngleDifference)
		{
			return false;
		}
		return true;
	}

	private Vector3 GetTerrainNormal(Vector3 testPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (TransformUtil.GetGroundInfo(testPos, out hit, 100f, LayerMask.op_Implicit(8388608)))
		{
			return ((RaycastHit)(ref hit)).normal;
		}
		return Vector3.zero;
	}

	private void SetWaiting()
	{
		internalState = TravellingVendorState.Waiting;
		((Behaviour)forcer).enabled = false;
		((Behaviour)pusher).enabled = false;
		SetFlag(Flags.Reserved1, b: true);
		targetThrottle = 0f;
		brakes = 1f;
	}

	private void SetTravelling()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)preventBuildingInstance != (Object)null && preventBuildingInstance.parentEntity.uid != net.ID)
		{
			preventBuildingInstance.SetParent(this);
			((Component)preventBuildingInstance).transform.localPosition = Vector3.zero;
		}
		((Behaviour)forcer).enabled = true;
		((Behaviour)pusher).enabled = true;
		if (TimeSince.op_Implicit(timeSinceBackfire) > 30f && Random.value < 0.6f)
		{
			timeSinceBackfire = TimeSince.op_Implicit(0f);
			((FacepunchBehaviour)this).Invoke((Action)StartBackfire, Random.Range(1f, 4f));
		}
		if (HasFlag(Flags.Reserved6))
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)TurnOffIndicators))
		{
			((FacepunchBehaviour)this).Invoke((Action)TurnOffIndicators, 3f, 0f);
		}
		SetFlag(Flags.Reserved1, b: false);
		internalState = TravellingVendorState.Travelling;
		brakes = 0f;
	}

	private void AdvancePath()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (currentPath != null)
		{
			if (PathComplete())
			{
				currentPathIndex = 0;
				flag = true;
			}
			else if (AtDestination())
			{
				currentPathIndex = GetPathIndexAhead(2);
				flag = true;
			}
			if (flag)
			{
				SetDestination(currentPath[currentPathIndex]);
			}
		}
	}

	private int GetPathIndexAhead(int ahead)
	{
		if (currentPath == null)
		{
			return 0;
		}
		return (currentPathIndex + ahead) % currentPath.Count;
	}

	private void ResetPullover()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		pullingOver = false;
		pullOverTimer = 0f;
		pulloverPosition = Vector3.zero;
		pulloverTangent = Vector3.zero;
	}

	private float GetWaitAccumulator()
	{
		float result = waitTimeAccumulator;
		waitTimeAccumulator = 0f;
		return result;
	}

	public void ScaleSidewaysFriction(float scale)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		float stiffness = 0.75f + 0.75f * scale;
		WheelFrictionCurve sidewaysFriction = wheelFL.wheelCollider.sidewaysFriction;
		((WheelFrictionCurve)(ref sidewaysFriction)).stiffness = stiffness;
		wheelFL.wheelCollider.sidewaysFriction = sidewaysFriction;
		wheelFR.wheelCollider.sidewaysFriction = sidewaysFriction;
		wheelRL.wheelCollider.sidewaysFriction = sidewaysFriction;
		wheelRR.wheelCollider.sidewaysFriction = sidewaysFriction;
	}

	private void ApplyDownforce()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		myRigidbody.AddForce(-((Component)this).transform.up * downforceCoefficient);
	}

	private void UpdateWheelFlags()
	{
		if (wheelFL.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.FrontLeft;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.FrontLeft;
		}
		if (wheelFR.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.FrontRight;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.FrontRight;
		}
		if (wheelRL.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.RearLeft;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.RearLeft;
		}
		if (wheelRR.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.RearRight;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.RearRight;
		}
	}

	private void BuildingCheck()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(WorldSpaceBounds(), list, 1075937536, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!(item is Barricade barricade))
			{
				if (!(item is LootContainer lootContainer))
				{
					if (!(item is ConstructableEntity constructableEntity))
					{
						if (!(item is TreeEntity treeEntity))
						{
							if (!(item is DecayEntity decayEntity))
							{
								if (item is TrainCar { isServer: not false } trainCar && trainCar.IsAlive())
								{
									trainCar.Kill(DestroyMode.Gib);
								}
							}
							else if (should_destroy_buildings && (Object)(object)decayEntity.parentEntity.Get(serverside: true) != (Object)(object)this && decayEntity.isServer && decayEntity.IsAlive())
							{
								decayEntity.Kill(DestroyMode.Gib);
							}
						}
						else if (treeEntity.isServer)
						{
							treeEntity.Kill();
						}
					}
					else if (constructableEntity.isServer && constructableEntity.IsAlive())
					{
						constructableEntity.Kill(DestroyMode.Gib);
					}
				}
				else if (lootContainer.isServer && lootContainer.IsAlive())
				{
					lootContainer.Kill(DestroyMode.Gib);
				}
			}
			else if (barricade.isServer && barricade.IsAlive())
			{
				barricade.Kill(DestroyMode.Gib);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private bool CheckForObstacle()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		if (obstacleHits == null)
		{
			return false;
		}
		if (obstacleHits.Count <= 0)
		{
			return false;
		}
		foreach (RaycastHit obstacleHit in obstacleHits)
		{
			RaycastHit current = obstacleHit;
			if ((Object)(object)((RaycastHit)(ref current)).collider == (Object)null)
			{
				continue;
			}
			if (((RaycastHit)(ref current)).collider.ToBaseEntity() is BradleyAPC)
			{
				obstacleHits.Clear();
				return true;
			}
			if (!(((RaycastHit)(ref current)).collider.ToBaseEntity() is BasePlayer basePlayer) || IsPlayerIgnored(basePlayer) || basePlayer.IsFlying || IsInvalidPlayer(basePlayer))
			{
				continue;
			}
			if (TimeSince.op_Implicit(timeSincePlayerDetected) > 10f)
			{
				((FacepunchBehaviour)this).Invoke((Action)StartHorn, (float)Random.Range(1, 4));
				timeSincePlayerDetected = TimeSince.op_Implicit(0f);
			}
			if (playerRecords.ContainsKey(basePlayer))
			{
				VendorTargetInfo vendorTargetInfo = playerRecords[basePlayer];
				if (vendorTargetInfo.lastBlockingTime > Time.time + 60f)
				{
					vendorTargetInfo.blockingAccumulator = 0f;
					vendorTargetInfo.lastBlockingTime = Time.time;
					playerRecords[basePlayer] = vendorTargetInfo;
					continue;
				}
				vendorTargetInfo.lastBlockingTime = Time.time;
				vendorTargetInfo.blockingAccumulator += Time.deltaTime;
				if (vendorTargetInfo.blockingAccumulator > allowedVendorBlockTime)
				{
					IgnorePlayer(basePlayer);
				}
				else
				{
					playerRecords[basePlayer] = vendorTargetInfo;
				}
			}
			else
			{
				playerRecords.Add(basePlayer, new VendorTargetInfo
				{
					blockingAccumulator = Time.deltaTime,
					ignoredUntil = 0f,
					lastBlockingTime = Time.time,
					lastSeenTime = Time.time
				});
			}
			obstacleHits.Clear();
			return true;
		}
		return false;
	}

	private void UpdateObstacles()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		UpdateObstacleList(obstacleHits, ((Component)this).transform.forward);
	}

	private void UpdateObstacleList(List<RaycastHit> hits, Vector3 forward, float checkRadius = 2.5f)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		hits.Clear();
		GamePhysics.TraceAll(new Ray(((Component)this).transform.position + ((Component)this).transform.forward * (((Bounds)(ref bounds)).extents.z / 0.6f - 1f), forward), checkRadius, hits, 15f, obstacleMask | 1 | 0x8000, (QueryTriggerInteraction)1, this);
	}

	private void DoSteering()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 velocity = myRigidbody.velocity;
		float magnitude = ((Vector3)(ref velocity)).magnitude;
		velocity = myRigidbody.velocity;
		float num = Mathf.InverseLerp(5f, 1.5f, magnitude * Mathf.Abs(Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward)));
		ScaleSidewaysFriction(1f - num);
		if (!overrideSteering)
		{
			Vector3 val = ((Component)this).transform.InverseTransformPoint(destination);
			steeringAngle = Mathf.Atan2(val.x, val.z);
			steeringAngle *= 57.29578f;
			float num2 = steeringSmoothing * Time.deltaTime;
			smoothedSteering = Mathf.Lerp(smoothedSteering, steeringAngle, num2);
			wheelFL.wheelCollider.steerAngle = smoothedSteering;
			wheelFR.wheelCollider.steerAngle = smoothedSteering;
		}
	}

	private void ApplyForceAtWheels()
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (handbrake)
		{
			wheelFL.wheelCollider.brakeTorque = 1000f;
			wheelFR.wheelCollider.brakeTorque = 1000f;
			wheelRL.wheelCollider.brakeTorque = 1000f;
			wheelRR.wheelCollider.brakeTorque = 1000f;
			return;
		}
		throttle = Mathf.MoveTowards(throttle, targetThrottle, acceleration * Time.deltaTime);
		float num = throttle * motorForceConstant * 5f;
		Vector3 velocity = myRigidbody.velocity;
		bool flag = ((Vector3)(ref velocity)).magnitude >= max_speed;
		wheelFL.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		wheelFR.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		wheelRL.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		wheelRR.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		if (wheelFL.wheelCollider.isGrounded)
		{
			wheelFL.wheelCollider.motorTorque = num / 4f;
		}
		if (wheelFR.wheelCollider.isGrounded)
		{
			wheelFR.wheelCollider.motorTorque = num / 4f;
		}
		if (wheelRL.wheelCollider.isGrounded)
		{
			wheelRL.wheelCollider.motorTorque = num / 4f;
		}
		if (wheelRR.wheelCollider.isGrounded)
		{
			wheelRR.wheelCollider.motorTorque = num / 4f;
		}
	}

	private void ApplyBrakesAtWheels()
	{
		brakes = Mathf.Clamp(brakes, 0f, 1f);
		wheelFL.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelFR.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelRL.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelRR.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelFR.wheelCollider.motorTorque = 0f;
		wheelFL.wheelCollider.motorTorque = 0f;
		wheelRL.wheelCollider.motorTorque = 0f;
		wheelRR.wheelCollider.motorTorque = 0f;
	}

	private float CalculateSteeringAngle(float radius)
	{
		return Mathf.Atan(wheelbase / radius);
	}

	private void HandleSplineMovement()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		splineTranslator.SetOffset(splineOffset);
		splineTranslator.Update(Time.deltaTime);
		splineTranslator.GetCurrentPositionAndTangent(out var position, out var tangent);
		((Component)this).transform.position = Vector3.Lerp(((Component)this).transform.position, position, Time.deltaTime * splineMovementSpeed * 10f);
		Vector3 val = splineTranslator.PeekNextPositionFollowingDirection();
		tangent = val - position;
		Vector3 normalized = ((Vector3)(ref tangent)).normalized;
		((Component)this).transform.forward = normalized;
		Vector3 val2 = ((Component)this).transform.InverseTransformPoint(val);
		steeringAngle = Mathf.Atan2(val2.x, val2.z);
		steeringAngle *= 57.29578f;
		wheelFL.wheelCollider.steerAngle = steeringAngle;
		wheelFR.wheelCollider.steerAngle = steeringAngle;
	}

	private void TravelOnSpline()
	{
		splineTranslator.SetSpeed(splineMovementSpeed);
		slowdownStartSpeed = splineMovementSpeed;
		HandleSplineMovement();
	}

	private void SlowOnSpline()
	{
		splineTranslator.SetSpeed(slowdownStartSpeed);
		HandleSplineMovement();
		slowdownStartSpeed = Mathf.MoveTowards(slowdownStartSpeed, 0f, Time.deltaTime * 2f);
	}

	private void StopSplineMovement()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		overrideSteering = false;
		myRigidbody.isKinematic = false;
		int num = FindClosestNode() + 2 % currentPath.Count;
		currentPathIndex = num;
		SetDestination(currentPath[currentPathIndex]);
	}

	public void OnSplinePathTrigger(int pathId, WorldSpline spline, int direction)
	{
		if (splineId == -1 && (Object)(object)this.spline != (Object)(object)spline)
		{
			if (splineTranslator == null)
			{
				splineTranslator = new SimpleSplineTranslator();
			}
			myRigidbody.isKinematic = true;
			splineTranslator.SetSpline(spline).SetSpeed(splineMovementSpeed).SetDirection(direction)
				.CalculateStartingDistance();
			splineId = pathId;
			this.spline = spline;
			if (!((FacepunchBehaviour)this).IsInvoking((Action)CheckForSplineStart))
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)CheckForSplineStart, 0f, 1f);
			}
		}
		else if (splineId != pathId)
		{
			StopSplineMovement();
			splineId = -1;
			followingSpine = false;
		}
	}

	public void OnBasePathTrigger(int pathId, BasePath path)
	{
	}

	private void CheckForSplineStart()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		float start = splineTranslator.GetStart();
		Vector3 positionAtDistance = splineTranslator.GetPositionAtDistance(start, out var _);
		positionAtDistance += splineOffset;
		Vector3 val = ((Component)spline).transform.TransformPoint(positionAtDistance);
		if (Vector3Ex.Distance2D(((Component)this).transform.position, val) < 1.5f)
		{
			overrideSteering = true;
			followingSpine = true;
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckForSplineStart);
		}
	}

	public void InstallPath(RuntimePath path, int initialDestination)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (currentPath == null)
		{
			currentPath = Pool.Get<List<Vector3>>();
		}
		currentPath.Clear();
		IAIPathNode[] nodes = path.Nodes;
		foreach (IAIPathNode iAIPathNode in nodes)
		{
			currentPath.Add(iAIPathNode.Position);
		}
		currentPathIndex = initialDestination;
		SetDestination(currentPath[currentPathIndex]);
	}

	private bool HasPath()
	{
		if (currentPath != null)
		{
			return currentPath.Count > 0;
		}
		return false;
	}

	private bool IsFollowingSpline()
	{
		return followingSpine;
	}

	private void ClearPath()
	{
		currentPath.Clear();
		currentPathIndex = -1;
	}

	private bool IndexValid(int index)
	{
		if (!HasPath())
		{
			return false;
		}
		if (index >= 0)
		{
			return index < currentPath.Count;
		}
		return false;
	}

	private Vector3 GetCurrentPathDestination()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return ((Component)this).transform.position;
		}
		return currentPath[currentPathIndex];
	}

	private bool PathComplete()
	{
		if (HasPath())
		{
			if (currentPathIndex == currentPath.Count - 1)
			{
				return AtDestination();
			}
			return false;
		}
		return true;
	}

	public void SetDestination(Vector3 dest, float destinationDistance = 8f)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		atDestinationDistance = destinationDistance;
		destination = dest;
	}

	public bool AtDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(((Component)this).transform.position, destination) <= atDestinationDistance;
	}

	private int FindClosestNode()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		int result = 0;
		for (int i = 0; i < currentPath.Count; i++)
		{
			Vector3 val = currentPath[i];
			float num2 = Vector3Ex.Distance2D(((Component)this).transform.position, val);
			if (num2 < num)
			{
				num = num2;
				result = i;
			}
		}
		return result;
	}

	private void FetchTargets()
	{
		if (playerRecords == null)
		{
			playerRecords = new ListDictionary<BasePlayer, VendorTargetInfo>();
		}
		if (localPlayers == null)
		{
			localPlayers = Pool.Get<List<BasePlayer>>();
		}
		List<BaseEntity> foundEntities = Pool.Get<List<BaseEntity>>();
		FetchCycle(foundEntities);
		Pool.FreeUnmanaged<BaseEntity>(ref foundEntities);
	}

	private void FetchCycle(List<BaseEntity> foundEntities)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Vis.Entities(((Component)this).transform.position, searchRange, foundEntities, 133120, (QueryTriggerInteraction)2);
		localPlayers.Clear();
		foreach (BaseEntity foundEntity in foundEntities)
		{
			if (!(foundEntity is BasePlayer basePlayer) || basePlayer is HumanNPC || basePlayer is NPCPlayer || IsInvalidPlayer(basePlayer))
			{
				continue;
			}
			if (playerRecords.ContainsKey(basePlayer))
			{
				VendorTargetInfo vendorTargetInfo = playerRecords[basePlayer];
				vendorTargetInfo.lastSeenTime = Time.time;
				playerRecords[basePlayer] = vendorTargetInfo;
				if (!IsPlayerIgnored(basePlayer))
				{
					localPlayers.Add(basePlayer);
				}
			}
			else
			{
				playerRecords.Add(basePlayer, new VendorTargetInfo
				{
					blockingAccumulator = 0f,
					ignoredUntil = 0f,
					lastBlockingTime = 0f,
					lastSeenTime = Time.time
				});
				localPlayers.Add(basePlayer);
			}
		}
	}

	private bool IsInvalidPlayer(BasePlayer player)
	{
		int result = (int)(0u | (player.IsDead() ? 1u : 0u) | (player.IsSleeping() ? 1u : 0u) | (player.IsHostile() ? 1u : 0u)) | (player.isClient ? 1 : 0);
		if (player.IsHostile())
		{
			IgnorePlayer(player);
		}
		return (byte)result != 0;
	}

	private void IgnorePlayer(BasePlayer player)
	{
		if (localPlayers.Contains(player))
		{
			localPlayers.Remove(player);
		}
		float num = 90f;
		if (playerRecords.ContainsKey(player))
		{
			VendorTargetInfo vendorTargetInfo = playerRecords[player];
			vendorTargetInfo.ignoredUntil = Time.time + num;
			playerRecords[player] = vendorTargetInfo;
		}
		else
		{
			playerRecords.Add(player, new VendorTargetInfo
			{
				blockingAccumulator = 0f,
				ignoredUntil = num,
				lastBlockingTime = 0f,
				lastSeenTime = Time.time
			});
		}
	}

	private bool IsValidPatrons()
	{
		List<BasePlayer> list = localPlayers;
		if ((list != null && list.Count == 0) || localPlayers == null)
		{
			return false;
		}
		return localPlayers.Count > 0;
	}

	private bool IsPlayerIgnored(BasePlayer player)
	{
		if (playerRecords.ContainsKey(player))
		{
			return playerRecords[player].IsIgnored;
		}
		return false;
	}
}


private enum TravellingVendorState
{
	Stopped,
	Travelling,
	Waiting,
	Aligning
}


public static class TravellingVendorFlags
{
	public const Flags Braking = Flags.Reserved1;

	public const Flags IndicateLeft = Flags.Reserved2;

	public const Flags IndicateRight = Flags.Reserved4;

	public const Flags Lights = Flags.Reserved5;

	public const Flags Hazards = Flags.Reserved6;
}


using System;

[Flags]
private enum WheelIsGroundedFlags
{
	RearLeft = 1,
	RearRight = 2,
	FrontLeft = 4,
	FrontRight = 8
}


using System;
using UnityEngine;

[Serializable]
private struct VendorTargetInfo
{
	public float lastSeenTime;

	public float lastBlockingTime;

	public float blockingAccumulator;

	public float ignoredUntil;

	public bool IsIgnored => ignoredUntil > Time.time;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;

[ExecuteInEditMode]
public class TreeEntity : ResourceEntity, IPrefabPreProcess
{
	[Header("Falling")]
	public bool fallOnDied = true;

	public float fallDuration = 1.5f;

	public GameObjectRef fallStartSound;

	public GameObjectRef fallImpactSound;

	public GameObjectRef fallImpactParticles;

	public SoundDefinition fallLeavesLoopDef;

	[NonSerialized]
	public bool[] usedHeights = new bool[20];

	public bool impactSoundPlayed;

	private float treeDistanceUponFalling;

	public GameObjectRef prefab;

	public bool hasBonusGame = true;

	public GameObjectRef bonusHitEffect;

	public GameObjectRef bonusHitSound;

	public Collider serverCollider;

	public Collider clientCollider;

	public SoundDefinition smallCrackSoundDef;

	public SoundDefinition medCrackSoundDef;

	private float lastAttackDamage;

	[Header("Tree Addition Settings")]
	public bool spawnTreeAddition;

	public GameObjectRef treeAdditionPrefab;

	public float treeAdditionSpawnChance = 0.1f;

	public Vector3 treeAdditionSpawnPosition;

	public Vector3 treeAdditionSpawnRotation;

	private BaseEntity treeAdditionRef;

	[NonSerialized]
	public BaseEntity xMarker;

	private int currentBonusLevel;

	private float lastDirection = -1f;

	private float lastHitTime;

	private int lastHitMarkerIndex = -1;

	private float nextBirdTime;

	private uint birdCycleIndex;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TreeEntity.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
	}

	public override float BoundsPadding()
	{
		return 1f;
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0336: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		bool canGather = info.CanGather;
		float num = Time.time - lastHitTime;
		lastHitTime = Time.time;
		DoBirds();
		if (!hasBonusGame || !canGather || (Object)(object)info.Initiator == (Object)null || (BonusActive() && !DidHitMarker(info)))
		{
			base.OnAttacked(info);
			return;
		}
		if ((Object)(object)xMarker != (Object)null && !info.DidGather && info.gatherScale > 0f)
		{
			xMarker.ClientRPC(null, "MarkerHit", currentBonusLevel);
			currentBonusLevel++;
			info.gatherScale = 1f + Mathf.Clamp((float)currentBonusLevel * 0.125f, 0f, 1f);
		}
		Vector3 val = (((Object)(object)xMarker != (Object)null) ? ((Component)xMarker).transform.position : info.HitPositionWorld);
		CleanupMarker();
		TreeMarkerData treeMarkerData = PrefabAttribute.server.Find<TreeMarkerData>(prefabID);
		if (treeMarkerData != null)
		{
			Vector3 nearbyPoint = treeMarkerData.GetNearbyPoint(((Component)this).transform.InverseTransformPoint(val), ref lastHitMarkerIndex, out var normal);
			nearbyPoint = ((Component)this).transform.TransformPoint(nearbyPoint);
			Quaternion rot = QuaternionEx.LookRotationNormal(((Component)this).transform.TransformDirection(normal));
			xMarker = GameManager.server.CreateEntity("assets/content/nature/treesprefabs/trees/effects/tree_marking_nospherecast.prefab", nearbyPoint, rot);
		}
		else
		{
			Vector3 val2 = Vector3Ex.Direction2D(((Component)this).transform.position, val);
			Vector3 val3 = Vector3.Cross(val2, Vector3.up);
			float num2 = lastDirection;
			float num3 = Random.Range(0.5f, 0.5f);
			Vector3 val4 = Vector3.Lerp(-val2, val3 * num2, num3);
			Vector3 val5 = ((Component)this).transform.InverseTransformDirection(((Vector3)(ref val4)).normalized) * 2.5f;
			val5 = ((Component)this).transform.InverseTransformPoint(serverCollider.ClosestPoint(((Component)this).transform.TransformPoint(val5)));
			Vector3 val6 = ((Component)this).transform.TransformPoint(val5);
			Vector3 val7 = ((Component)this).transform.InverseTransformPoint(info.HitPositionWorld);
			val5.y = val7.y;
			Vector3 val8 = ((Component)this).transform.InverseTransformPoint(info.Initiator.CenterPoint());
			float num4 = Mathf.Max(0.75f, val8.y);
			float num5 = val8.y + 0.5f;
			val5.y = Mathf.Clamp(val5.y + Random.Range(0.1f, 0.2f) * ((Random.Range(0, 2) == 0) ? (-1f) : 1f), num4, num5);
			Vector3 val9 = Vector3Ex.Direction2D(((Component)this).transform.position, val6);
			Vector3 val10 = val9;
			val9 = ((Component)this).transform.InverseTransformDirection(val9);
			Quaternion val11 = QuaternionEx.LookRotationNormal(-val9, Vector3.zero);
			val5 = ((Component)this).transform.TransformPoint(val5);
			val11 = QuaternionEx.LookRotationNormal(-val10, Vector3.zero);
			val5 = serverCollider.ClosestPoint(val5);
			Line val12 = default(Line);
			((Line)(ref val12))..ctor(((Component)serverCollider).transform.TransformPoint(new Vector3(0f, 10f, 0f)), ((Component)serverCollider).transform.TransformPoint(new Vector3(0f, -10f, 0f)));
			val11 = QuaternionEx.LookRotationNormal(-Vector3Ex.Direction(((Line)(ref val12)).ClosestPoint(val5), val5));
			xMarker = GameManager.server.CreateEntity("assets/content/nature/treesprefabs/trees/effects/tree_marking.prefab", val5, val11);
		}
		xMarker.Spawn();
		if (num > 5f)
		{
			StartBonusGame();
		}
		base.OnAttacked(info);
		if (health > 0f)
		{
			lastAttackDamage = info.damageTypes.Total();
			int num6 = Mathf.CeilToInt(health / lastAttackDamage);
			if (num6 < 2)
			{
				ClientRPC(null, "CrackSound", 1);
			}
			else if (num6 < 5)
			{
				ClientRPC(null, "CrackSound", 0);
			}
		}
	}

	public override void ServerInit()
	{
		if ((Object)(object)serverCollider == (Object)null)
		{
			serverCollider = clientCollider ?? ((Component)this).GetComponentInChildren<Collider>();
		}
		base.ServerInit();
		lastDirection = ((Random.Range(0, 2) != 0) ? 1 : (-1));
		TryAddTreeAddition();
	}

	public override void ServerInitPostNetworkGroupAssign()
	{
		base.ServerInitPostNetworkGroupAssign();
		TreeManager.OnTreeSpawned(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		CleanupMarker();
		TryKillTreeAddition();
		TreeManager.OnTreeDestroyed(this);
	}

	public bool DidHitMarker(HitInfo info)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)xMarker == (Object)null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnTreeMarkerHit", (object)this, (object)info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PrefabAttribute.server.Find<TreeMarkerData>(prefabID) != null)
		{
			Bounds val = default(Bounds);
			((Bounds)(ref val))..ctor(((Component)xMarker).transform.position, Vector3.one * 0.2f);
			if (((Bounds)(ref val)).Contains(info.HitPositionWorld))
			{
				return true;
			}
		}
		else
		{
			Vector3 val2 = Vector3Ex.Direction2D(((Component)this).transform.position, ((Component)xMarker).transform.position);
			Vector3 attackNormal = info.attackNormal;
			float num = Vector3.Dot(val2, attackNormal);
			float num2 = Vector3.Distance(((Component)xMarker).transform.position, info.HitPositionWorld);
			if (num >= 0.3f && num2 <= 0.2f)
			{
				return true;
			}
		}
		return false;
	}

	public void StartBonusGame()
	{
		if (((FacepunchBehaviour)this).IsInvoking((Action)StopBonusGame))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)StopBonusGame);
		}
		((FacepunchBehaviour)this).Invoke((Action)StopBonusGame, 60f);
	}

	public void StopBonusGame()
	{
		CleanupMarker();
		lastHitTime = 0f;
		currentBonusLevel = 0;
	}

	public bool BonusActive()
	{
		return (Object)(object)xMarker != (Object)null;
	}

	private void DoBirds()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && !(Time.realtimeSinceStartup < nextBirdTime) && !(((Bounds)(ref bounds)).extents.y < 6f))
		{
			uint num = (uint)(int)net.ID.Value + birdCycleIndex;
			if (SeedRandom.Range(ref num, 0, 2) == 0)
			{
				Effect.server.Run("assets/prefabs/npc/birds/birdemission.prefab", ((Component)this).transform.position + Vector3.up * Random.Range(((Bounds)(ref bounds)).extents.y * 0.65f, ((Bounds)(ref bounds)).extents.y * 0.9f), Vector3.up);
			}
			birdCycleIndex++;
			nextBirdTime = Time.realtimeSinceStartup + 90f;
		}
	}

	public void CleanupMarker()
	{
		if (Object.op_Implicit((Object)(object)xMarker))
		{
			xMarker.Kill();
		}
		xMarker = null;
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		if (isKilled)
		{
			return;
		}
		isKilled = true;
		CleanupMarker();
		if (base.isServer)
		{
			StabilityEntity.UpdateSurroundingsQueue updateSurroundingsQueue = StabilityEntity.updateSurroundingsQueue;
			OBB val = WorldSpaceBounds();
			((ObjectWorkQueue<Bounds>)updateSurroundingsQueue).Add(((OBB)(ref val)).ToBounds());
			TryKillTreeAddition();
		}
		if (fallOnDied)
		{
			Collider val2 = serverCollider;
			if (Object.op_Implicit((Object)(object)val2))
			{
				val2.enabled = false;
			}
			Vector3 val3 = info.attackNormal;
			if (val3 == Vector3.zero)
			{
				val3 = Vector3Ex.Direction2D(((Component)this).transform.position, info.PointStart);
			}
			PooledList<TimedExplosive> val4 = Pool.Get<PooledList<TimedExplosive>>();
			try
			{
				foreach (BaseEntity child in children)
				{
					if (child is TimedExplosive item)
					{
						((List<TimedExplosive>)(object)val4).Add(item);
					}
				}
				foreach (TimedExplosive item2 in (List<TimedExplosive>)(object)val4)
				{
					item2.UnStick();
				}
				OnFallServer();
				ClientRPC(RpcTarget.NetworkGroup("TreeFall"), val3);
				((FacepunchBehaviour)this).Invoke((Action)DelayedKill, fallDuration + 1f);
				return;
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
		}
		DelayedKill();
	}

	protected virtual void OnFallServer()
	{
	}

	public void DelayedKill()
	{
		Kill();
	}

	private void TryAddTreeAddition()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		if (spawnTreeAddition && treeAdditionPrefab.isValid && Random.value <= treeAdditionSpawnChance && !((Object)(object)treeAdditionRef != (Object)null))
		{
			treeAdditionRef = GameManager.server.CreateEntity(treeAdditionPrefab.resourcePath, Vector3.zero, Quaternion.identity);
			((Component)treeAdditionRef).transform.position = ((Component)this).transform.TransformPoint(treeAdditionSpawnPosition);
			((Component)treeAdditionRef).transform.rotation = ((Component)this).transform.rotation * Quaternion.Euler(treeAdditionSpawnRotation);
			if ((Object)(object)((Component)treeAdditionRef).GetComponent<Poolable>() != (Object)null)
			{
				((Component)treeAdditionRef).gameObject.AwakeFromInstantiate();
			}
			treeAdditionRef.Spawn();
			treeAdditionRef.SendNetworkUpdate();
		}
	}

	private void TryKillTreeAddition()
	{
		if (spawnTreeAddition && (Object)(object)treeAdditionRef != (Object)null)
		{
			if (treeAdditionRef is BaseCombatEntity baseCombatEntity)
			{
				baseCombatEntity.Die();
			}
			else
			{
				treeAdditionRef.Kill(DestroyMode.Gib);
			}
			treeAdditionRef = null;
		}
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (serverside)
		{
			globalBroadcast = Tree.global_broadcast;
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;
using UnityEngine.Assertions;

public class TreeManager : BaseEntity
{
	private struct ToProcess
	{
		public struct Telemetry
		{
			public TimeSpan InitialTime;

			public TimeSpan IterativeTime;

			public int FramesToComplete;

			public void Report(BasePlayer player)
			{
				TimeSpan timeSpan = InitialTime + IterativeTime;
				TimeSpan timeSpan2 = new TimeSpan((long)(PlayerBudgetMS * 10000f * (float)FramesToComplete));
				TimeSpan timeSpan3 = timeSpan - timeSpan2;
				TimeSpan timeSpan4 = timeSpan / FramesToComplete;
				RustLog.Log(RustLog.EntryType.Network, 1, ((Component)player).gameObject, "TreeManager: Initial: {0}ms, Iterative: {1}ms, Total: {2}ms({3}ms/frame), Overspent: {4}ms", InitialTime.TotalMilliseconds, IterativeTime.TotalMilliseconds, timeSpan.TotalMilliseconds, timeSpan4.TotalMilliseconds, timeSpan3.TotalMilliseconds);
			}
		}

		public BasePlayer Player;

		public BitArray SentCells;

		public int Left;

		public int Range;

		public int OldCellIndex;

		public int LastProcessedIndex;

		public Telemetry Stats;
	}

	private struct TreeCell
	{
		public TreeList TreeList;

		public MemoryStream SerializedCell;

		public bool IsDirty;
	}

	public static ListHashSet<BaseEntity> entities = new ListHashSet<BaseEntity>();

	public static TreeManager server;

	[ServerVar]
	public static bool EnableTreeStreaming = true;

	[ServerVar]
	public static float PlayerBudgetMS = 0.01f;

	[ServerVar]
	public static float UpdateBudgetMS = 1f;

	private const string CellSizeHelp = "Define cell size(in m) of a grid for trees  - only has effect on world load and must be > 1. This affects how much data we send per tree cell(bigger the cell - more trees we have to send). The smaller the cell, the more cells we have to process and the more memory we need per player to track what's left to send(gridSize ^ 2 / 8 bytes). We readjust CellSize to ensure gridSize never exceeds 512.";

	[ServerVar(Help = "Define cell size(in m) of a grid for trees  - only has effect on world load and must be > 1. This affects how much data we send per tree cell(bigger the cell - more trees we have to send). The smaller the cell, the more cells we have to process and the more memory we need per player to track what's left to send(gridSize ^ 2 / 8 bytes). We readjust CellSize to ensure gridSize never exceeds 512.")]
	public static int CellSize = 100;

	private const string UseLazySerializationHelp = "Instead of reserializing grid cell on every tree add/removal(which can cost 0.25ms on 4.5k world), defer it to the streaming update. This reduces amount of times we need to serialize the tree list, but causes the player queue to take longer to process, as that's where evaluation happens.";

	[ServerVar(Help = "Instead of reserializing grid cell on every tree add/removal(which can cost 0.25ms on 4.5k world), defer it to the streaming update. This reduces amount of times we need to serialize the tree list, but causes the player queue to take longer to process, as that's where evaluation happens.")]
	public static bool UseLazySerialization = true;

	private List<ToProcess> playersToProcess = new List<ToProcess>(100);

	private int gridSize = 64;

	private List<TreeCell> treesGrid;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TreeManager.OnRpcMessage", 0);
		try
		{
			if (rpc == 1907121457 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestTrees "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestTrees", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1907121457u, "SERVER_RequestTrees", this, player, 0uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_RequestTrees(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_RequestTrees");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static Vector3 ProtoHalf3ToVec3(Half3 half3)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result = default(Vector3);
		result.x = Mathf.HalfToFloat((ushort)half3.x);
		result.y = Mathf.HalfToFloat((ushort)half3.y);
		result.z = Mathf.HalfToFloat((ushort)half3.z);
		return result;
	}

	public static Half3 Vec3ToProtoHalf3(Vector3 vec3)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Half3 result = default(Half3);
		result.x = Mathf.FloatToHalf(vec3.x);
		result.y = Mathf.FloatToHalf(vec3.y);
		result.z = Mathf.FloatToHalf(vec3.z);
		return result;
	}

	public int GetTreeCount()
	{
		if ((Object)(object)server == (Object)(object)this)
		{
			return entities.Count;
		}
		return -1;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		server = this;
		InitTreeGrid();
	}

	private void InitTreeGrid()
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Expected O, but got Unknown
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		if (CellSize <= 0)
		{
			CellSize = 100;
		}
		gridSize = (int)Mathf.Ceil((float)World.Size / (float)CellSize);
		gridSize = Math.Clamp(gridSize, 1, 512);
		if (gridSize == 512)
		{
			CellSize = (int)Mathf.Ceil((float)World.Size / (float)gridSize);
		}
		RustLog.Log(RustLog.EntryType.Network, 1, null, "TreeManager: using {0}x{0} grid with cell size {1}", gridSize, CellSize);
		treesGrid = new List<TreeCell>(gridSize * gridSize);
		for (int i = 0; i < gridSize * gridSize; i++)
		{
			TreeCell item = default(TreeCell);
			item.TreeList = new TreeList();
			item.TreeList.trees = new List<Tree>();
			item.SerializedCell = new MemoryStream();
			treesGrid.Add(item);
		}
		Enumerator<BaseEntity> enumerator = entities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseEntity current = enumerator.Current;
				Vector2i val = ToCellIndices(current.ServerPosition);
				Tree val2 = Pool.Get<Tree>();
				ExtractTreeNetworkData(current, val2);
				treesGrid[val.y * gridSize + val.x].TreeList.trees.Add(val2);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (TreeCell item2 in treesGrid)
		{
			ProtoStreamExtensions.WriteToStream((IProto)(object)item2.TreeList, (Stream)item2.SerializedCell, false, 2097152);
		}
	}

	public void SendPendingTrees()
	{
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		playersToProcess.RemoveAll((ToProcess record) => (Object)(object)record.Player == (Object)null);
		if (playersToProcess.IsEmpty())
		{
			return;
		}
		playersToProcess.Sort((ToProcess left, ToProcess right) => right.Left - left.Left);
		Stopwatch stopwatch = Pool.Get<Stopwatch>();
		Stopwatch stopwatch2 = Pool.Get<Stopwatch>();
		stopwatch.Start();
		for (int i = 0; i < playersToProcess.Count; i++)
		{
			if (stopwatch.Elapsed.TotalMilliseconds > (double)UpdateBudgetMS)
			{
				break;
			}
			TimeWarning val = TimeWarning.New("Player", 0);
			try
			{
				stopwatch2.Restart();
				ToProcess record2 = playersToProcess[i];
				Vector2i val2 = ToCellIndices(record2.Player.ServerPosition);
				if (record2.OldCellIndex != val2.y * gridSize + val2.x)
				{
					record2.LastProcessedIndex = -1;
					record2.Range = 1;
					record2.OldCellIndex = val2.y * gridSize + val2.x;
				}
				int num = record2.Range;
				while (stopwatch2.Elapsed.TotalMilliseconds < (double)PlayerBudgetMS && record2.Left > 0)
				{
					int num2 = Math.Max(val2.x - num / 2, 0);
					int num3 = Math.Max(val2.y - num / 2, 0);
					int num4 = Math.Min(num2 + num, gridSize - 1);
					int num5 = Math.Min(num3 + num, gridSize - 1);
					for (int j = num2; j <= num4; j++)
					{
						if (SendToPlayer(num3 * gridSize + j, ref record2) && stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
						{
							stopwatch2.Stop();
							break;
						}
					}
					if (stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
					{
						stopwatch2.Stop();
						break;
					}
					if (num5 - num3 > 1)
					{
						for (int k = num3 + 1; k <= num5 - 1; k++)
						{
							if (SendToPlayer(k * gridSize + num2, ref record2) && stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
							{
								stopwatch2.Stop();
								break;
							}
							if (num4 != num2 && SendToPlayer(k * gridSize + num4, ref record2) && stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
							{
								stopwatch2.Stop();
								break;
							}
						}
					}
					if (stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
					{
						stopwatch2.Stop();
						break;
					}
					if (num5 != num3)
					{
						for (int l = num2; l <= num4; l++)
						{
							if (SendToPlayer(num5 * gridSize + l, ref record2) && stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
							{
								stopwatch2.Stop();
								break;
							}
						}
					}
					if (stopwatch2.IsRunning)
					{
						num++;
						record2.LastProcessedIndex = -1;
					}
				}
				record2.Range = num;
				stopwatch2.Stop();
				ToProcess.Telemetry stats = record2.Stats;
				stats.IterativeTime += stopwatch2.Elapsed;
				stats.FramesToComplete++;
				record2.Stats = stats;
				playersToProcess[i] = record2;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		Pool.FreeUnmanaged(ref stopwatch2);
		Pool.FreeUnmanaged(ref stopwatch);
		playersToProcess.RemoveAll(delegate(ToProcess record)
		{
			if (record.Left == 0)
			{
				record.Stats.Report(record.Player);
				return true;
			}
			return false;
		});
		static bool SendToPlayer(int index, ref ToProcess record)
		{
			if (record.LastProcessedIndex >= index || record.SentCells[index])
			{
				return false;
			}
			record.LastProcessedIndex = index;
			record.SentCells[index] = true;
			record.Left--;
			Debug.Assert(record.Left >= 0);
			TreeCell value = server.treesGrid[index];
			if (value.TreeList.trees.IsEmpty())
			{
				return false;
			}
			if (UseLazySerialization && value.IsDirty)
			{
				TimeWarning val3 = TimeWarning.New("LazySerialize", 0);
				try
				{
					value.SerializedCell.SetLength(0L);
					ProtoStreamExtensions.WriteToStream((IProto)(object)value.TreeList, (Stream)value.SerializedCell, false, 2097152);
					value.IsDirty = false;
					server.treesGrid[index] = value;
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			TimeWarning val4 = TimeWarning.New("RPC", 0);
			try
			{
				server.ClientRPC(RpcTarget.Player("CLIENT_ReceiveTrees", record.Player), value.SerializedCell);
				return true;
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
		}
	}

	public static void StartTreesBatch(BasePlayer player)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		Stopwatch stopwatch = Stopwatch.StartNew();
		int num = server.gridSize * server.gridSize;
		BitArray bitArray = new BitArray(num);
		Vector2i val = ToCellIndices(player.ServerPosition);
		int num2 = Math.Max(val.x - 1, 0);
		int num3 = Math.Max(val.y - 1, 0);
		int num4 = Math.Min(num2 + 3, server.gridSize - 1);
		int num5 = Math.Min(num3 + 3, server.gridSize - 1);
		for (int i = num3; i <= num5; i++)
		{
			for (int j = num2; j <= num4; j++)
			{
				int index = i * server.gridSize + j;
				TreeCell value = server.treesGrid[index];
				if (!value.TreeList.trees.IsEmpty())
				{
					if (UseLazySerialization && value.IsDirty)
					{
						TimeWarning val2 = TimeWarning.New("LazySerialize", 0);
						try
						{
							value.SerializedCell.SetLength(0L);
							ProtoStreamExtensions.WriteToStream((IProto)(object)value.TreeList, (Stream)value.SerializedCell, false, 2097152);
							value.IsDirty = false;
							server.treesGrid[index] = value;
						}
						finally
						{
							((IDisposable)val2)?.Dispose();
						}
					}
					server.ClientRPC(RpcTarget.Player("CLIENT_ReceiveTrees", player), value.SerializedCell);
				}
				bitArray[index] = true;
				num--;
			}
		}
		stopwatch.Stop();
		ToProcess toProcess = default(ToProcess);
		toProcess.Player = player;
		toProcess.SentCells = bitArray;
		toProcess.Left = num;
		toProcess.Range = 4;
		toProcess.OldCellIndex = val.y * server.gridSize + val.x;
		toProcess.LastProcessedIndex = -1;
		toProcess.Stats = new ToProcess.Telemetry
		{
			InitialTime = stopwatch.Elapsed,
			FramesToComplete = 1
		};
		ToProcess item = toProcess;
		server.playersToProcess.Add(item);
	}

	private static Vector2i ToCellIndices(Vector3 worldPos)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)World.Size / 2f;
		Vector2 val = Vector3Ex.XZ2D(worldPos) + new Vector2(num, num);
		val.x = Mathf.Clamp(val.x, 0f, (float)(World.Size - 1));
		val.y = Mathf.Clamp(val.y, 0f, (float)(World.Size - 1));
		return new Vector2i((int)(val.x / (float)CellSize), (int)(val.y / (float)CellSize));
	}

	public static void OnTreeDestroyed(BaseEntity billboardEntity)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		entities.Remove(billboardEntity);
		if (Application.isLoading || Application.isQuitting)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("TreeManager.OnTreeDestroyed", 0);
		try
		{
			Vector2i val2 = ToCellIndices(billboardEntity.ServerPosition);
			int index = val2.y * server.gridSize + val2.x;
			TreeCell value = server.treesGrid[index];
			List<Tree> trees = value.TreeList.trees;
			for (int i = 0; i < trees.Count; i++)
			{
				if (trees[i].netId == billboardEntity.net.ID)
				{
					Tree val3 = trees[i];
					Pool.Free<Tree>(ref val3);
					trees.RemoveAt(i);
					if (UseLazySerialization)
					{
						value.IsDirty = true;
						server.treesGrid[index] = value;
					}
					else
					{
						value.SerializedCell.SetLength(0L);
						ProtoStreamExtensions.WriteToStream((IProto)(object)value.TreeList, (Stream)value.SerializedCell, false, 2097152);
					}
					break;
				}
			}
			server.ClientRPC(RpcTarget.NetworkGroup("CLIENT_TreeDestroyed"), billboardEntity.net.ID);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void OnTreeSpawned(BaseEntity billboardEntity)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		if (billboardEntity.net.group != null && billboardEntity.net.group.restricted)
		{
			return;
		}
		entities.Add(billboardEntity);
		if (Application.isLoading || Application.isQuitting)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("TreeManager.OnTreeSpawned", 0);
		try
		{
			Vector2i val2 = ToCellIndices(billboardEntity.ServerPosition);
			int index = val2.y * server.gridSize + val2.x;
			Tree val3 = Pool.Get<Tree>();
			ExtractTreeNetworkData(billboardEntity, val3);
			TreeCell value = server.treesGrid[index];
			value.TreeList.trees.Add(val3);
			if (UseLazySerialization)
			{
				value.IsDirty = true;
				server.treesGrid[index] = value;
			}
			else
			{
				value.SerializedCell.SetLength(0L);
				ProtoStreamExtensions.WriteToStream((IProto)(object)value.TreeList, (Stream)value.SerializedCell, false, 2097152);
			}
			List<Connection> list = Pool.Get<List<Connection>>();
			foreach (Connection subscriber in server.net.group.subscribers)
			{
				bool flag = true;
				for (int i = 0; i < server.playersToProcess.Count; i++)
				{
					ToProcess toProcess = server.playersToProcess[i];
					if (toProcess.Player.Connection == subscriber && !toProcess.SentCells[index])
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					list.Add(subscriber);
				}
			}
			if (!list.IsEmpty())
			{
				Tree val4 = Pool.Get<Tree>();
				try
				{
					ExtractTreeNetworkData(billboardEntity, val4);
					server.ClientRPC(RpcTarget.Players("CLIENT_TreeSpawned", list), val4);
				}
				finally
				{
					((IDisposable)val4)?.Dispose();
				}
			}
			Pool.FreeUnmanaged<Connection>(ref list);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void ExtractTreeNetworkData(BaseEntity billboardEntity, Tree tree)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		tree.netId = billboardEntity.net.ID;
		tree.prefabId = billboardEntity.prefabID;
		tree.position = Vec3ToProtoHalf3(((Component)billboardEntity).transform.position);
		tree.scale = ((Component)billboardEntity).transform.lossyScale.y;
	}

	public static void SendSnapshot(BasePlayer player)
	{
		Stopwatch stopwatch = Stopwatch.StartNew();
		BufferList<BaseEntity> values = entities.Values;
		TreeList val = null;
		for (int i = 0; i < values.Count; i++)
		{
			BaseEntity billboardEntity = values[i];
			Tree val2 = Pool.Get<Tree>();
			ExtractTreeNetworkData(billboardEntity, val2);
			if (val == null)
			{
				val = Pool.Get<TreeList>();
				val.trees = Pool.Get<List<Tree>>();
			}
			val.trees.Add(val2);
			if (val.trees.Count >= ConVar.Server.maxpacketsize_globaltrees)
			{
				server.ClientRPC(RpcTarget.Player("CLIENT_ReceiveTrees", player), val);
				val.Dispose();
				val = null;
			}
		}
		if (val != null)
		{
			server.ClientRPC(RpcTarget.Player("CLIENT_ReceiveTrees", player), val);
			val.Dispose();
			val = null;
		}
		stopwatch.Stop();
		RustLog.Log(RustLog.EntryType.Network, 1, ((Component)player).gameObject, "Took {0}ms to send {1} global trees to {2}", stopwatch.Elapsed.TotalMilliseconds, values.Count, player);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(0uL)]
	private void SERVER_RequestTrees(RPCMessage msg)
	{
		if (EnableTreeStreaming)
		{
			StartTreesBatch(msg.player);
		}
		else
		{
			SendSnapshot(msg.player);
		}
	}
}


using System;
using System.Collections;
using UnityEngine;

private struct ToProcess
{
	public struct Telemetry
	{
		public TimeSpan InitialTime;

		public TimeSpan IterativeTime;

		public int FramesToComplete;

		public void Report(BasePlayer player)
		{
			TimeSpan timeSpan = InitialTime + IterativeTime;
			TimeSpan timeSpan2 = new TimeSpan((long)(PlayerBudgetMS * 10000f * (float)FramesToComplete));
			TimeSpan timeSpan3 = timeSpan - timeSpan2;
			TimeSpan timeSpan4 = timeSpan / FramesToComplete;
			RustLog.Log(RustLog.EntryType.Network, 1, ((Component)player).gameObject, "TreeManager: Initial: {0}ms, Iterative: {1}ms, Total: {2}ms({3}ms/frame), Overspent: {4}ms", InitialTime.TotalMilliseconds, IterativeTime.TotalMilliseconds, timeSpan.TotalMilliseconds, timeSpan4.TotalMilliseconds, timeSpan3.TotalMilliseconds);
		}
	}

	public BasePlayer Player;

	public BitArray SentCells;

	public int Left;

	public int Range;

	public int OldCellIndex;

	public int LastProcessedIndex;

	public Telemetry Stats;
}


using System;
using UnityEngine;

public struct Telemetry
{
	public TimeSpan InitialTime;

	public TimeSpan IterativeTime;

	public int FramesToComplete;

	public void Report(BasePlayer player)
	{
		TimeSpan timeSpan = InitialTime + IterativeTime;
		TimeSpan timeSpan2 = new TimeSpan((long)(PlayerBudgetMS * 10000f * (float)FramesToComplete));
		TimeSpan timeSpan3 = timeSpan - timeSpan2;
		TimeSpan timeSpan4 = timeSpan / FramesToComplete;
		RustLog.Log(RustLog.EntryType.Network, 1, ((Component)player).gameObject, "TreeManager: Initial: {0}ms, Iterative: {1}ms, Total: {2}ms({3}ms/frame), Overspent: {4}ms", InitialTime.TotalMilliseconds, IterativeTime.TotalMilliseconds, timeSpan.TotalMilliseconds, timeSpan4.TotalMilliseconds, timeSpan3.TotalMilliseconds);
	}
}


using System.IO;
using ProtoBuf;

private struct TreeCell
{
	public TreeList TreeList;

	public MemoryStream SerializedCell;

	public bool IsDirty;
}


using System;
using Facepunch;
using Network;
using ProtoBuf;
using Rust.UI;
using Sonar;
using UnityEngine;

public class Tugboat : MotorRowboat
{
	private const Flags Flag_Horn = Flags.Reserved18;

	[SerializeField]
	[Header("Tugboat")]
	private Canvas monitorCanvas;

	[SerializeField]
	private RustText fuelText;

	[SerializeField]
	private RustText speedText;

	[SerializeField]
	private ParticleSystemContainer exhaustEffect;

	[SerializeField]
	private SoundDefinition lightsToggleSound;

	[SerializeField]
	private Transform steeringWheelLeftHandTarget;

	[SerializeField]
	private Transform steeringWheelRightHandTarget;

	[SerializeField]
	private SonarSystem sonar;

	[SerializeField]
	private TugboatSounds tugboatSounds;

	[SerializeField]
	private CanvasGroup canvasGroup;

	[SerializeField]
	private EmissionToggle emissionToggle;

	[SerializeField]
	private AnimationCurve emissionCurve;

	[SerializeField]
	private ParticleSystemContainer fxLightDamage;

	[SerializeField]
	private ParticleSystemContainer fxMediumDamage;

	[SerializeField]
	private ParticleSystemContainer fxHeavyDamage;

	[SerializeField]
	private GameObject heavyDamageLights;

	[SerializeField]
	private TriggerParent parentTrigger;

	[Help("how long until boat corpses despawn (excluding tugboat)")]
	[ServerVar]
	public static float tugcorpseseconds = 7200f;

	[ServerVar(Help = "How long before a tugboat loses all its health while outside")]
	public static float tugdecayminutes = 2160f;

	[ServerVar(Help = "How long until decay begins after the tugboat was last used")]
	public static float tugdecaystartdelayminutes = 1440f;

	public bool LightsAreOn => HasFlag(Flags.Reserved5);

	protected override bool AllowKinematicDrift => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Tugboat.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}

	public override float MaxVelocity()
	{
		return 15f;
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("Tugboat.VehicleFixedUpdate", 0);
		try
		{
			int fuelAmount = fuelSystem.GetFuelAmount();
			base.VehicleFixedUpdate();
			int fuelAmount2 = fuelSystem.GetFuelAmount();
			if (fuelAmount2 != fuelAmount)
			{
				ClientRPC(RpcTarget.NetworkGroup("SetFuelAmount"), fuelAmount2);
			}
			if (LightsAreOn && !IsOn())
			{
				SetFlag(Flags.Reserved5, b: false);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.simpleUint = Pool.Get<SimpleUInt>();
		info.msg.simpleUint.value = (uint)fuelSystem.GetFuelAmount();
	}

	public override void BoatDecay()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!base.IsDying)
		{
			BaseBoat.WaterVehicleDecay(this, 60f, TimeSince.op_Implicit(timeSinceLastUsedFuel), tugdecayminutes, tugdecayminutes, tugdecaystartdelayminutes, preventDecayIndoors);
		}
	}

	public override int StartingFuelUnits()
	{
		return 0;
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			if (!IsOn())
			{
				SetFlag(Flags.Reserved5, b: false);
			}
			else
			{
				SetFlag(Flags.Reserved5, !LightsAreOn);
			}
		}
	}

	protected override void EnterCorpseState()
	{
		((FacepunchBehaviour)this).Invoke((Action)base.ActualDeath, tugcorpseseconds);
	}

	public override bool AnyPlayersOnBoat()
	{
		if (base.AnyPlayersOnBoat())
		{
			return true;
		}
		if ((Object)(object)parentTrigger != (Object)null && parentTrigger.HasAnyEntityContents)
		{
			foreach (BaseEntity entityContent in parentTrigger.entityContents)
			{
				if ((Object)(object)entityContent.ToPlayer() != (Object)null)
				{
					return true;
				}
			}
		}
		return false;
	}

	public override bool BuoyancySleep(bool inWater)
	{
		SetToKinematic();
		return true;
	}

	public override bool BuoyancyWake()
	{
		SetToNonKinematic();
		return true;
	}

	public override void DriverInput(InputState inputState, BasePlayer player)
	{
		base.DriverInput(inputState, player);
		bool flag = inputState.IsDown(BUTTON.FIRE_PRIMARY);
		if (flag != HasFlag(Flags.Reserved18))
		{
			SetFlag(Flags.Reserved18, flag);
		}
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override bool ForceDeployableSetParent()
	{
		return true;
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (IsOn())
		{
			return false;
		}
		if (!IsStationary() || (!(pusher.WaterFactor() <= 0.6f) && !IsFlipped()))
		{
			return false;
		}
		if (!IsFlipped() && pusher.IsStandingOnEntity(this, 1218652417))
		{
			return false;
		}
		if (pusher.IsBuildingBlockedByVehicle())
		{
			return false;
		}
		Vector3 val = ((Component)this).transform.TransformPoint(-Vector3.up);
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(val, waves: true, volumes: false, this);
		if (val.y - waterInfo.surfaceLevel > 2f)
		{
			return false;
		}
		if (base.IsDying)
		{
			return false;
		}
		if (!pusher.isMounted && pusher.IsOnGround())
		{
			return base.healthFraction > 0f;
		}
		return false;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Network.Visibility;
using ProtoBuf;
using UnityEngine;

public class TutorialIsland : BaseEntity, IEntityPingSource
{
	public struct IslandBounds
	{
		public OBB WorldBounds;

		public uint Id;

		public bool Contains(Vector3 pos)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return ((OBB)(ref WorldBounds)).Contains(pos);
		}
	}

	public EntityRef<BasePlayer> ForPlayer;

	public Transform InitialSpawnPoint;

	public Transform MidMissionSpawnPoint;

	public int SpawnLocationIndex;

	public TutorialNPC StartTutorialNPC;

	public TutorialContainer TutorialContainer;

	public MonumentNavMesh MonumentNavMesh;

	public MeshTerrainRoot MeshTerrain;

	public Transform KayakPoint;

	public BaseMission FinalMission;

	[Range(0f, 24f)]
	public float TimeOfDay = 18f;

	public ItemDefinition rockDefinition;

	public WeatherPreset Weather;

	[Header("Debugging")]
	public BaseMission TestMission;

	private TutorialBuildTarget[] buildTargets;

	public static Phrase NoTutorialIslandsAvailablePhrase = new Phrase("no_tutorial_islands_available", "No Tutorial Islands are currently available, please try again later...");

	public static Phrase TutorialIslandStartCooldown = new Phrase("tutorial_island_start_cooldown", "Please wait {0} seconds before starting the tutorial again");

	public static ListHashSet<IslandBounds> BoundsListServer = new ListHashSet<IslandBounds>();

	public static float TutorialBoundsSize = 400f;

	[ServerVar(Saved = true)]
	public static bool SpawnTutorialIslandForNewPlayer = true;

	private static ListHashSet<TutorialIsland> ActiveIslandsServer = new ListHashSet<TutorialIsland>();

	[ServerVar(Saved = true)]
	public static bool EnforceTrespassChecks = true;

	[ServerVar(Help = "Will place the tutorial as close as possible to this pos, only for debugging")]
	public static Vector3 OverrideTutorialLocation = Vector3.zero;

	private const string TutorialIslandAssetPath = "assets/prefabs/missions/tutorialisland/tutorialisland.prefab";

	private static float _tutorialWorldStart = 0f;

	public static Bounds WorldBoundsMinusTutorialIslands;

	private static List<Vector3> islandSpawnLocations;

	private static List<int> freeIslandLocations;

	private float tutorialDuration;

	private float disconnectedDuration;

	private bool readyToStartConversation;

	private float tickRate = 1f;

	private Vector3 kayakAnchorPoint = Vector3.zero;

	private Kayak kayakToAnchor;

	private TimeSince rockCheck;

	public static float TutorialWorldStart
	{
		get
		{
			if (_tutorialWorldStart <= 0f)
			{
				_tutorialWorldStart = ValidBounds.GetMaximumPoint() - TutorialBoundsSize;
			}
			return _tutorialWorldStart;
		}
	}

	public static float TutorialWorldNetworkThreshold => TutorialWorldStart - TutorialBoundsSize;

	public static int MaxTutorialIslandCount => islandSpawnLocations?.Count ?? 0;

	public TimeSpan TutorialDuration => TimeSpan.FromSeconds(tutorialDuration);

	public float DisconnectTimeOutDuration
	{
		get
		{
			if (AvailableIslandCount() > 0)
			{
				return 900f;
			}
			return 300f;
		}
	}

	public static bool HasAvailableTutorialIsland
	{
		get
		{
			if (Server.tutorialEnabled)
			{
				return freeIslandLocations.Count > 0;
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TutorialIsland.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static ListHashSet<TutorialIsland> GetTutorialList(bool isServer)
	{
		if (isServer)
		{
			return ActiveIslandsServer;
		}
		return null;
	}

	public static uint GetTutorialGroupId(int index)
	{
		return (uint)(2 + index);
	}

	public static bool IsTutorialNetworkGroup(uint grp)
	{
		if (grp > 1)
		{
			return grp < 1000;
		}
		return false;
	}

	public static void GenerateIslandSpawnPoints(bool loadingSave = false)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		if (islandSpawnLocations != null && islandSpawnLocations.Count > 0)
		{
			return;
		}
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(0f - ValidBounds.GetMaximumPointTutorial(), 0f, 0f - ValidBounds.GetMaximumPointTutorial());
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(ValidBounds.GetMaximumPointTutorial(), 0f, ValidBounds.GetMaximumPointTutorial());
		Vector3 cellSize = default(Vector3);
		((Vector3)(ref cellSize))..ctor(400f, 0f, 400f);
		islandSpawnLocations = TutorialIslandSpawner.GetEdgeSpawnPoints(val, val2 - val, cellSize, 1, out WorldBoundsMinusTutorialIslands);
		freeIslandLocations = new List<int>();
		for (int i = 0; i < islandSpawnLocations.Count; i++)
		{
			freeIslandLocations.Add(i);
		}
		int num = 0;
		foreach (Vector3 islandSpawnLocation in islandSpawnLocations)
		{
			Group tutorialGroup = GetTutorialGroup(num++);
			OBB val3 = new OBB(islandSpawnLocation, Quaternion.identity, new Bounds(new Vector3(0f, 25f, 0f), new Vector3(400f, 80f, 400f)));
			tutorialGroup.bounds = ((OBB)(ref val3)).ToBounds();
			tutorialGroup.restricted = true;
		}
	}

	public static Group GetTutorialGroup(int index)
	{
		return Net.sv.visibility.Get((uint)(BaseNetworkable.LimboNetworkGroup.ID + 1 + index));
	}

	public static int AvailableIslandCount()
	{
		return freeIslandLocations.Count;
	}

	public static bool ShouldPlayerResumeTutorial(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		return player.IsInTutorial;
	}

	public static bool ShouldPlayerBeAskedToStartTutorial(BasePlayer player)
	{
		if (!Server.tutorialEnabled)
		{
			return false;
		}
		if (player.IsNpc || player.IsBot)
		{
			return false;
		}
		if (player.IsInTutorial)
		{
			return false;
		}
		if (!SpawnTutorialIslandForNewPlayer)
		{
			return false;
		}
		if (!HasAvailableTutorialIsland)
		{
			return false;
		}
		bool infoBool = player.GetInfoBool("client.hasdeclinedtutorial", defaultVal: false);
		if (!player.GetInfoBool("client.hascompletedtutorial", defaultVal: false))
		{
			return !infoBool;
		}
		return false;
	}

	public static TutorialIsland RestoreOrCreateIslandForPlayer(BasePlayer player, bool triggerAnalytics)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		if (player.IsNpc || player.IsBot)
		{
			return null;
		}
		bool flag = !player.HasPlayerFlag(BasePlayer.PlayerFlags.IsInTutorial);
		TutorialIsland tutorialIsland = (flag ? CreateIslandForPlayer(player) : player.GetCurrentTutorialIsland());
		if (!flag && (Object)(object)tutorialIsland != (Object)null)
		{
			SetupGroup(tutorialIsland.SpawnLocationIndex, ((Component)tutorialIsland).transform.position, ((Component)tutorialIsland).transform.rotation);
		}
		if ((Object)(object)tutorialIsland == (Object)null)
		{
			return null;
		}
		tutorialIsland.UpdateNetworkGroup();
		player.SetPlayerFlag(BasePlayer.PlayerFlags.IsInTutorial, b: true);
		if (flag)
		{
			player.net.SwitchGroup(tutorialIsland.net.group);
			player.Teleport(tutorialIsland.InitialSpawnPoint.position);
			player.ForceUpdateTriggers();
			((Component)player).transform.rotation = tutorialIsland.InitialSpawnPoint.rotation;
			player.OnStartedTutorial();
			player.inventory.GiveDefaultItems();
			if (triggerAnalytics)
			{
				Analytics.Azure.OnTutorialStarted(player);
			}
		}
		else
		{
			player.net.SwitchGroup(BaseNetworkable.LimboNetworkGroup);
			player.UpdateNetworkGroup();
			foreach (BaseEntity child in tutorialIsland.children)
			{
				if (child is TutorialContainer tutorialContainer)
				{
					tutorialIsland.TutorialContainer = tutorialContainer;
				}
			}
		}
		player.UpdateNetworkGroup();
		player.SendNetworkUpdateImmediate();
		player.ClientRPC(RpcTarget.Player("OnTutorialStarted", player), tutorialIsland.TimeOfDay, ((Object)tutorialIsland.Weather).name);
		tutorialIsland.TestMission = null;
		if (flag)
		{
			if (tutorialIsland.TestMission == null)
			{
				((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)tutorialIsland.StartInitialConversation, 1.5f);
			}
			else
			{
				Debug.LogWarning((object)"Starting test mission instead of initial conversation, clear TestMission field to test actual tutorial");
			}
			if (tutorialIsland.TestMission != null)
			{
				BaseMission.AssignMission(player, tutorialIsland.StartTutorialNPC, tutorialIsland.TestMission);
			}
		}
		Debug.Log((object)(player.displayName + " is being placed on a tutorial island"));
		return tutorialIsland;
	}

	private static TutorialIsland CreateIslandForPlayer(BasePlayer player)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 worldPos;
		Quaternion worldRot;
		int unusedTutorialIslandLocationRotation = GetUnusedTutorialIslandLocationRotation(out worldPos, out worldRot);
		if (unusedTutorialIslandLocationRotation == -1)
		{
			return null;
		}
		Group val = SetupGroup(unusedTutorialIslandLocationRotation, worldPos, worldRot);
		TutorialIsland tutorialIsland = GameManager.server.CreateEntity("assets/prefabs/missions/tutorialisland/tutorialisland.prefab", worldPos, worldRot) as TutorialIsland;
		tutorialIsland.SpawnLocationIndex = unusedTutorialIslandLocationRotation;
		tutorialIsland.GenerateNavMesh();
		ActiveIslandsServer.Add(tutorialIsland);
		AddIslandBounds(tutorialIsland.WorldSpaceBounds(), val.ID, isServer: true);
		tutorialIsland.ForPlayer.Set(player);
		tutorialIsland.Spawn();
		return tutorialIsland;
	}

	private static Group SetupGroup(int spawnLocationIndex, Vector3 worldPos, Quaternion worldRot)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		Group tutorialGroup = GetTutorialGroup(spawnLocationIndex);
		OBB val = new OBB(worldPos, worldRot, new Bounds(new Vector3(0f, 25f, 0f), new Vector3(400f, 80f, 400f)));
		tutorialGroup.bounds = ((OBB)(ref val)).ToBounds();
		tutorialGroup.restricted = true;
		return tutorialGroup;
	}

	private static int GetUnusedTutorialIslandLocationRotation(out Vector3 worldPos, out Quaternion worldRot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		worldRot = Quaternion.identity;
		worldPos = Vector3.zero;
		if (AvailableIslandCount() == 0)
		{
			return -1;
		}
		if (OverrideTutorialLocation != Vector3.zero)
		{
			int num = -1;
			float num2 = float.MaxValue;
			for (int i = 0; i < freeIslandLocations.Count; i++)
			{
				float num3 = Vector3.Distance(OverrideTutorialLocation, islandSpawnLocations[freeIslandLocations[i]]);
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
			worldPos = islandSpawnLocations[num];
			freeIslandLocations.RemoveAt(num);
			return num;
		}
		int num4 = freeIslandLocations[0];
		worldPos = islandSpawnLocations[num4];
		freeIslandLocations.RemoveAt(0);
		float height = TerrainMeta.HeightMap.GetHeight(worldPos);
		if (worldPos.y < height)
		{
			worldPos.y = height;
		}
		return num4;
	}

	public static void AddIslandFromSave(TutorialIsland island)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)("Island being added! Location index: " + island.SpawnLocationIndex));
		if (ActiveIslandsServer.Contains(island))
		{
			Debug.Log((object)"Warning, attempting to add duplicate Island!");
			return;
		}
		ActiveIslandsServer.Add(island);
		AddIslandBounds(island.WorldSpaceBounds(), GetTutorialGroupId(island.SpawnLocationIndex), isServer: true);
		freeIslandLocations.Remove(island.SpawnLocationIndex);
		Debug.Log((object)("Free locations remaining: " + freeIslandLocations.Count + ". Next Index: " + freeIslandLocations[0]));
		island.GenerateNavMesh();
	}

	public void GenerateNavMesh()
	{
		if (!((Object)(object)MonumentNavMesh == (Object)null))
		{
			((MonoBehaviour)this).StartCoroutine(UpdateNavMesh());
		}
	}

	public IEnumerator UpdateNavMesh()
	{
		yield return ((MonoBehaviour)this).StartCoroutine(MonumentNavMesh.UpdateNavMeshAndWait());
	}

	private void StartInitialConversation()
	{
		BasePlayer basePlayer = ForPlayer.Get(base.isServer);
		if ((Object)(object)basePlayer != (Object)null && (basePlayer.IsSleeping() || basePlayer.IsDucked()))
		{
			((FacepunchBehaviour)this).Invoke((Action)StartInitialConversation, 0.1f);
		}
		else if (!readyToStartConversation)
		{
			readyToStartConversation = true;
			((FacepunchBehaviour)this).Invoke((Action)StartInitialConversation, 0.5f);
		}
		else
		{
			StartTutorialNPC.Server_BeginTalking(ForPlayer.Get(base.isServer));
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)InitSpawnGroups, 1f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)Tick, tickRate, tickRate, 0.1f);
	}

	private void InitSpawnGroups()
	{
		List<SpawnGroup> list = Pool.Get<List<SpawnGroup>>();
		((Component)this).gameObject.GetComponentsInChildren<SpawnGroup>(list);
		foreach (SpawnGroup item in list)
		{
			if ((Object)(object)item != (Object)null)
			{
				item.Spawn();
			}
		}
		Pool.FreeUnmanaged<SpawnGroup>(ref list);
	}

	public void OnPlayerBuiltConstruction(BasePlayer player)
	{
		ClientRPC(RpcTarget.Player("ClientOnPlayerBuiltConstruction", player));
	}

	public override void Save(SaveInfo info)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.tutorialIsland == null)
		{
			info.msg.tutorialIsland = Pool.Get<TutorialIsland>();
		}
		TutorialIsland tutorialIsland = info.msg.tutorialIsland;
		tutorialIsland.targetPlayer = ForPlayer.uid;
		tutorialIsland.disconnectDuration = disconnectedDuration;
		tutorialIsland.spawnLocationIndex = SpawnLocationIndex;
		if (info.forDisk)
		{
			tutorialIsland.tutorialDuration = tutorialDuration;
		}
	}

	public void GetBuildTargets(List<TutorialBuildTarget> targetList, uint targetPrefab)
	{
		TutorialBuildTarget[] array = buildTargets;
		foreach (TutorialBuildTarget tutorialBuildTarget in array)
		{
			if (tutorialBuildTarget.TargetPrefab.isValid && tutorialBuildTarget.TargetPrefab.Get().prefabID == targetPrefab)
			{
				targetList.Add(tutorialBuildTarget);
			}
		}
	}

	public Vector3 GetWorldPosOfBuildTarget(int index)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (buildTargets.Length != 0)
		{
			return ((Component)buildTargets[index]).transform.position;
		}
		return ((Component)this).transform.position;
	}

	public void StartEndingCinematic(BasePlayer player)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		BaseMountable mounted = player.GetMounted();
		Vector3 pos = Vector3Ex.WithY(((Component)player).transform.position, Env.oceanlevel);
		if ((Object)(object)mounted != (Object)null && (Object)(object)mounted.VehicleParent() != (Object)null)
		{
			kayakToAnchor = mounted.VehicleParent() as Kayak;
			if ((Object)(object)kayakToAnchor != (Object)null)
			{
				kayakToAnchor.PrepareForTutorialCinematic(KayakPoint.rotation);
				kayakAnchorPoint = pos;
				kayakToAnchor.rigidBody.isKinematic = true;
				kayakToAnchor.rigidBody.useGravity = false;
				((FacepunchBehaviour)this).InvokeRepeating((Action)AnchorKayak, 0f, 0f);
			}
		}
		CinematicScenePlaybackEntity obj = GameManager.server.CreateEntity("assets/prefabs/missions/tutorialisland/endtutorialcinematic.prefab", pos, KayakPoint.rotation) as CinematicScenePlaybackEntity;
		obj.AssignPlayer(player);
		obj.Spawn();
	}

	private void AnchorKayak()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)kayakToAnchor != (Object)null)
		{
			((Component)kayakToAnchor).transform.position = kayakAnchorPoint;
		}
	}

	public void OnPlayerCompletedTutorial(BasePlayer player, bool isQuit, bool triggerAnalytics)
	{
		if ((Object)(object)ForPlayer.Get(serverside: true) != (Object)(object)player)
		{
			Debug.LogWarning((object)$"Attempting to complete tutorial for non-matching player {ForPlayer.Get(serverside: true)} != {player}");
			return;
		}
		_ = player.IsInTutorial;
		if (triggerAnalytics)
		{
			if (isQuit)
			{
				BaseMission.MissionInstance activeMissionInstance = player.GetActiveMissionInstance();
				Analytics.Azure.OnTutorialQuit(player, (activeMissionInstance != null && activeMissionInstance.GetMission() != null) ? activeMissionInstance.GetMission().shortname : "NULL");
			}
			else
			{
				Analytics.Azure.OnTutorialCompleted(player, tutorialDuration);
				player.GiveAchievement("COMPLETE_TUTORIAL", allowTutorial: true);
			}
		}
		((FacepunchBehaviour)this).Invoke((Action)KillPlayerAtEndOfTutorial, 0.1f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)DelayedCompleteTutorial, 0.5f, 0.5f);
	}

	private void KillPlayerAtEndOfTutorial()
	{
		Debug.Log((object)"Kill player");
		BasePlayer basePlayer = ForPlayer.Get(serverside: true);
		basePlayer.ClientRPC(RpcTarget.Player("NotifyTutorialCompleted", basePlayer));
		basePlayer.ClearTutorial();
		ServerMgr.SendReplicatedVars(basePlayer.Connection);
		DeathInfo val = Pool.Get<DeathInfo>();
		val.attackerName = "scientistnpc_full_any";
		if (basePlayer.IsGod())
		{
			basePlayer.net.connection.info.Set("global.god", "0");
		}
		basePlayer.SetOverrideDeathBlow(val);
		basePlayer.Hurt(9999f);
		if (basePlayer.IsGod())
		{
			Debug.LogWarning((object)("Attempting to kill player " + basePlayer.displayName + " at end of tutorial but god mode is active!"));
		}
		basePlayer.ClearTutorial_PostDeath();
	}

	private void DelayedCompleteTutorial()
	{
		BasePlayer basePlayer = ForPlayer.Get(serverside: true);
		if (!((Object)(object)basePlayer != (Object)null) || !basePlayer.IsDead())
		{
			ForPlayer.Set(null);
			Return();
		}
	}

	public void Return()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(WorldSpaceBounds(), list, -1, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!(item is BasePlayer) && !(item is TutorialIsland) && !item.isClient && !item.IsDestroyed)
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		BasePlayer basePlayer = ForPlayer.Get(serverside: true);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.AbandonActiveMission();
		}
		ForPlayer.Set(null);
		ReturnIsland(this);
		disconnectedDuration = 0f;
	}

	private static void ReturnIsland(TutorialIsland island)
	{
		freeIslandLocations.Add(island.SpawnLocationIndex);
		island.Kill();
	}

	public void Tick()
	{
		TickPlayerConnectionStatus();
	}

	private void TickPlayerConnectionStatus()
	{
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = ForPlayer.Get(base.isServer);
		tutorialDuration += tickRate;
		if ((Object)(object)basePlayer == (Object)null || basePlayer.IsSleeping())
		{
			disconnectedDuration += tickRate;
			if (disconnectedDuration >= DisconnectTimeOutDuration)
			{
				if ((Object)(object)basePlayer != (Object)null)
				{
					basePlayer.ClearTutorial();
					basePlayer.Hurt(99999f);
					basePlayer.ClearTutorial_PostDeath();
					basePlayer.ClientRPCPlayer(null, basePlayer, "NotifyTutorialCompleted");
				}
				Return();
			}
			return;
		}
		disconnectedDuration = 0f;
		if (!((Object)(object)basePlayer != (Object)null) || !((Object)(object)rockDefinition != (Object)null) || !(TimeSince.op_Implicit(rockCheck) > 10f))
		{
			return;
		}
		rockCheck = TimeSince.op_Implicit(0f);
		if (!SearchPlayerForItem(rockDefinition, basePlayer) && basePlayer.inventory.HasEmptySlotInBeltOrMain())
		{
			Item item = ItemManager.Create(rockDefinition, 1, 0uL);
			if (!basePlayer.inventory.GiveItem(item))
			{
				item.Remove();
			}
		}
	}

	private bool SearchPlayerForItem(ItemDefinition targetItem, BasePlayer player)
	{
		foreach (Item item in player.inventory.containerBelt.itemList)
		{
			if ((Object)(object)item.info == (Object)(object)targetItem || (Object)(object)item.info.isRedirectOf == (Object)(object)targetItem)
			{
				return true;
			}
		}
		foreach (Item item2 in player.inventory.containerMain.itemList)
		{
			if ((Object)(object)item2.info == (Object)(object)targetItem || (Object)(object)item2.info.isRedirectOf == (Object)(object)targetItem)
			{
				return true;
			}
		}
		foreach (Item item3 in player.inventory.containerWear.itemList)
		{
			if ((Object)(object)item3.info == (Object)(object)targetItem || (Object)(object)item3.info.isRedirectOf == (Object)(object)targetItem)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsPingValid(MapNote note)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		TutorialBuildTarget[] array = buildTargets;
		foreach (TutorialBuildTarget tutorialBuildTarget in array)
		{
			if (((Component)tutorialBuildTarget).gameObject.activeSelf && Vector3.Distance(((Component)tutorialBuildTarget).transform.position, note.worldPosition) < 0.1f)
			{
				return true;
			}
		}
		Vector3 val = note.worldPosition - KayakPoint.position;
		if (((Vector3)(ref val)).sqrMagnitude < 10f)
		{
			return true;
		}
		return false;
	}

	public static TutorialIsland GetClosestTutorialIsland(Vector3 position, float maxRange)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		float num2 = float.MaxValue;
		for (int i = 0; i < ActiveIslandsServer.Count; i++)
		{
			TutorialIsland tutorialIsland = ActiveIslandsServer[i];
			if ((Object)(object)tutorialIsland != (Object)null)
			{
				float num3 = tutorialIsland.Distance2D(position);
				if (num3 < maxRange && num3 < num2)
				{
					num2 = num3;
					num = i;
				}
			}
		}
		if (num < 0)
		{
			return null;
		}
		return ActiveIslandsServer[num];
	}

	public void OnPlayerStartedMission(BasePlayer player)
	{
		TutorialBuildTarget[] array = buildTargets;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateActive(player);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.tutorialIsland != null)
		{
			TutorialIsland tutorialIsland = info.msg.tutorialIsland;
			ForPlayer.uid = tutorialIsland.targetPlayer;
			SpawnLocationIndex = tutorialIsland.spawnLocationIndex;
			disconnectedDuration = tutorialIsland.disconnectDuration;
			tutorialDuration = tutorialIsland.tutorialDuration;
			if (base.isServer && info.fromDisk)
			{
				AddIslandFromSave(this);
			}
		}
	}

	public bool CheckPlacement(Construction toConstruct, Construction.Target target, ref Construction.Placement placement)
	{
		TutorialBuildTarget[] array = buildTargets;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].IsValid(toConstruct, target, ref placement))
			{
				return true;
			}
		}
		return false;
	}

	public bool CheckPlacement(BasePlayer forPlayer, Deployable deployable, Vector3 worldPosition, Quaternion worldRotation)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		TutorialBuildTarget[] array = buildTargets;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].IsValid(forPlayer, deployable, worldPosition, worldRotation))
			{
				return true;
			}
		}
		return false;
	}

	public override void InitShared()
	{
		base.InitShared();
		buildTargets = ((Component)this).GetComponentsInChildren<TutorialBuildTarget>();
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer && ActiveIslandsServer.Contains(this))
		{
			RemoveIslandBounds(GetTutorialGroupId(SpawnLocationIndex), isServer: true);
			ActiveIslandsServer.Remove(this);
		}
	}

	private static void AddIslandBounds(OBB worldBounds, uint netId, bool isServer)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (isServer)
		{
			BoundsListServer.Add(new IslandBounds
			{
				Id = netId,
				WorldBounds = worldBounds
			});
		}
	}

	private static void RemoveIslandBounds(uint netId, bool isServer)
	{
		if (!isServer)
		{
			return;
		}
		for (int i = 0; i < BoundsListServer.Count; i++)
		{
			if (BoundsListServer[i].Id == netId)
			{
				BoundsListServer.RemoveAt(i);
				break;
			}
		}
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override bool ForceDeployableSetParent()
	{
		return true;
	}
}


using UnityEngine;

public struct IslandBounds
{
	public OBB WorldBounds;

	public uint Id;

	public bool Contains(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref WorldBounds)).Contains(pos);
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using Rust.Modular;
using UnityEngine;
using UnityEngine.Assertions;

public class VehicleModuleCamper : VehicleModuleSeating
{
	public GameObjectRef SleepingBagEntity;

	public Transform[] SleepingBagPoints;

	public GameObjectRef LockerEntity;

	public Transform LockerPoint;

	public GameObjectRef BbqEntity;

	public Transform BbqPoint;

	public GameObjectRef StorageEntity;

	public Transform StoragePoint;

	public EntityRef<BaseOven> activeBbq;

	public EntityRef<Locker> activeLocker;

	public EntityRef<StorageContainer> activeStorage;

	private bool wasLoaded;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehicleModuleCamper.OnRpcMessage", 0);
		try
		{
			if (rpc == 2501069650u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLocker "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLocker", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2501069650u, "RPC_OpenLocker", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_OpenLocker(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenLocker");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4185921214u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenStorage "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenStorage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4185921214u, "RPC_OpenStorage", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_OpenStorage(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_OpenStorage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		activeBbq.Set(null);
		activeLocker.Set(null);
		activeStorage.Set(null);
		wasLoaded = false;
	}

	public override void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.ModuleAdded(vehicle, firstSocketIndex);
		if (!base.isServer)
		{
			return;
		}
		if (!Application.isLoadingSave && !wasLoaded)
		{
			for (int i = 0; i < SleepingBagPoints.Length; i++)
			{
				SleepingBagCamper sleepingBagCamper = base.gameManager.CreateEntity(SleepingBagEntity.resourcePath, SleepingBagPoints[i].localPosition, SleepingBagPoints[i].localRotation) as SleepingBagCamper;
				if ((Object)(object)sleepingBagCamper != (Object)null)
				{
					sleepingBagCamper.SetParent(this);
					sleepingBagCamper.SetSeat(GetSeatAtIndex(i));
					sleepingBagCamper.Spawn();
				}
			}
			PostConditionalRefresh();
			return;
		}
		int num = 0;
		foreach (BaseEntity child in children)
		{
			if (child is SleepingBagCamper sleepingBagCamper2)
			{
				sleepingBagCamper2.SetSeat(GetSeatAtIndex(num++), sendNetworkUpdate: true);
			}
			else if (child is IItemContainerEntity itemContainerEntity)
			{
				ItemContainer inventory = itemContainerEntity.inventory;
				inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			}
		}
	}

	protected override Vector3 ModifySeatPositionLocalSpace(int index, Vector3 desiredPos)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		CamperSeatConfig seatConfig = GetSeatConfig();
		if ((Object)(object)seatConfig != (Object)null && seatConfig.SeatPositions.Length > index)
		{
			return seatConfig.SeatPositions[index].localPosition;
		}
		return base.ModifySeatPositionLocalSpace(index, desiredPos);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		wasLoaded = true;
	}

	public override void Spawn()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			Locker locker = base.gameManager.CreateEntity(LockerEntity.resourcePath, LockerPoint.localPosition, LockerPoint.localRotation) as Locker;
			locker.SetParent(this);
			locker.Spawn();
			ItemContainer inventory = locker.inventory;
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			activeLocker.Set(locker);
			BaseOven baseOven = base.gameManager.CreateEntity(BbqEntity.resourcePath, BbqPoint.localPosition, BbqPoint.localRotation) as BaseOven;
			baseOven.SetParent(this);
			baseOven.Spawn();
			ItemContainer inventory2 = baseOven.inventory;
			inventory2.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory2.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			activeBbq.Set(baseOven);
			StorageContainer storageContainer = base.gameManager.CreateEntity(StorageEntity.resourcePath, StoragePoint.localPosition, StoragePoint.localRotation) as StorageContainer;
			storageContainer.SetParent(this);
			storageContainer.Spawn();
			ItemContainer inventory3 = storageContainer.inventory;
			inventory3.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory3.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			activeStorage.Set(storageContainer);
			PostConditionalRefresh();
		}
	}

	private void OnItemAddedRemoved(Item item, bool add)
	{
		AssociatedItemInstance?.LockUnlock(!CanBeMovedNowOnVehicle());
	}

	protected override bool CanBeMovedNowOnVehicle()
	{
		foreach (BaseEntity child in children)
		{
			if (child is IItemContainerEntity itemContainerEntity && !itemContainerEntity.IsUnityNull() && !itemContainerEntity.inventory.IsEmpty())
			{
				return false;
			}
		}
		return true;
	}

	protected override void PostConditionalRefresh()
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		base.PostConditionalRefresh();
		if (base.isClient)
		{
			return;
		}
		CamperSeatConfig seatConfig = GetSeatConfig();
		if ((Object)(object)seatConfig != (Object)null && mountPoints != null)
		{
			for (int i = 0; i < mountPoints.Count; i++)
			{
				if ((Object)(object)mountPoints[i].mountable != (Object)null)
				{
					((Component)mountPoints[i].mountable).transform.position = seatConfig.SeatPositions[i].position;
					mountPoints[i].mountable.SendNetworkUpdate();
				}
			}
		}
		if (activeBbq.IsValid(base.isServer) && (Object)(object)seatConfig != (Object)null)
		{
			BaseOven baseOven = activeBbq.Get(serverside: true);
			((Component)baseOven).transform.position = seatConfig.StovePosition.position;
			((Component)baseOven).transform.rotation = seatConfig.StovePosition.rotation;
			baseOven.SendNetworkUpdate();
		}
		if (activeStorage.IsValid(base.isServer) && (Object)(object)seatConfig != (Object)null)
		{
			StorageContainer storageContainer = activeStorage.Get(base.isServer);
			((Component)storageContainer).transform.position = seatConfig.StoragePosition.position;
			((Component)storageContainer).transform.rotation = seatConfig.StoragePosition.rotation;
			storageContainer.SendNetworkUpdate();
		}
	}

	private CamperSeatConfig GetSeatConfig()
	{
		List<ConditionalObject> list = GetConditionals();
		CamperSeatConfig result = null;
		CamperSeatConfig camperSeatConfig = default(CamperSeatConfig);
		foreach (ConditionalObject item in list)
		{
			if (item.gameObject.activeSelf && item.gameObject.TryGetComponent<CamperSeatConfig>(ref camperSeatConfig))
			{
				result = camperSeatConfig;
			}
		}
		return result;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.camperModule == null)
		{
			info.msg.camperModule = Pool.Get<CamperModule>();
		}
		info.msg.camperModule.bbqId = activeBbq.uid;
		info.msg.camperModule.lockerId = activeLocker.uid;
		info.msg.camperModule.storageID = activeStorage.uid;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_OpenLocker(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			IItemContainerEntity itemContainerEntity = activeLocker.Get(base.isServer);
			if (!itemContainerEntity.IsUnityNull())
			{
				itemContainerEntity.PlayerOpenLoot(player);
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
			}
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_OpenStorage(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			IItemContainerEntity itemContainerEntity = activeStorage.Get(base.isServer);
			if (!itemContainerEntity.IsUnityNull())
			{
				itemContainerEntity.PlayerOpenLoot(player);
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
			}
		}
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot)
		{
			if (activeStorage.IsValid(base.isServer))
			{
				activeStorage.Get(base.isServer).DropItems();
			}
			if (activeBbq.IsValid(base.isServer))
			{
				activeBbq.Get(base.isServer).DropItems();
			}
			if (activeLocker.IsValid(base.isServer))
			{
				activeLocker.Get(base.isServer).DropItems();
			}
		}
		base.DoServerDestroy();
	}

	public IItemContainerEntity GetContainer()
	{
		Locker locker = activeLocker.Get(base.isServer);
		if ((Object)(object)locker != (Object)null && locker.IsValid() && !locker.inventory.IsEmpty())
		{
			return locker;
		}
		BaseOven baseOven = activeBbq.Get(base.isServer);
		if ((Object)(object)baseOven != (Object)null && baseOven.IsValid() && !baseOven.inventory.IsEmpty())
		{
			return baseOven;
		}
		StorageContainer storageContainer = activeStorage.Get(base.isServer);
		if ((Object)(object)storageContainer != (Object)null && storageContainer.IsValid() && !storageContainer.inventory.IsEmpty())
		{
			return storageContainer;
		}
		return null;
	}

	public override string Admin_Who()
	{
		StringBuilder stringBuilder = new StringBuilder();
		int num = 0;
		foreach (BaseEntity child in children)
		{
			if (child is SleepingBagCamper sleepingBagCamper)
			{
				stringBuilder.AppendLine($"Bag {num++}:");
				stringBuilder.AppendLine(sleepingBagCamper.Admin_Who());
			}
		}
		return stringBuilder.ToString();
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (base.IsOnAVehicle && base.Vehicle.IsDead())
		{
			return base.CanBeLooted(player);
		}
		if (base.CanBeLooted(player))
		{
			return IsOnThisModule(player);
		}
		return false;
	}

	public override bool IsOnThisModule(BasePlayer player)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (base.IsOnThisModule(player))
		{
			return true;
		}
		if (!player.isMounted)
		{
			return false;
		}
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(((Component)this).transform, bounds);
		return ((OBB)(ref val)).Contains(player.CenterPoint());
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.camperModule != null)
		{
			activeBbq.uid = info.msg.camperModule.bbqId;
			activeLocker.uid = info.msg.camperModule.lockerId;
			activeStorage.uid = info.msg.camperModule.storageID;
		}
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class VehicleModuleSeating : BaseVehicleModule, IPrefabPreProcess
{
	[Serializable]
	public class MountHotSpot
	{
		public Transform transform;

		public Vector2 size;
	}

	[Serializable]
	public class Seating
	{
		[Header("Seating & Controls")]
		public bool doorsAreLockable = true;

		[Obsolete("Use BaseVehicle.mountPoints instead")]
		[HideInInspector]
		public MountPointInfo[] mountPoints;

		public Transform steeringWheel;

		public Transform accelPedal;

		public Transform brakePedal;

		public Transform steeringWheelLeftGrip;

		public Transform steeringWheelRightGrip;

		public Transform accelPedalGrip;

		public Transform brakePedalGrip;

		public MountHotSpot[] mountHotSpots;

		[Header("Dashboard")]
		public Transform speedometer;

		public Transform fuelGauge;

		public Renderer dashboardRenderer;

		[Range(0f, 3f)]
		public int checkEngineLightMatIndex = 2;

		[ColorUsage(true, true)]
		public Color checkEngineLightEmission;

		[Range(0f, 3f)]
		public int fuelLightMatIndex = 3;

		[ColorUsage(true, true)]
		public Color fuelLightEmission;
	}

	[SerializeField]
	private ProtectionProperties passengerProtection;

	[SerializeField]
	private ModularCarCodeLockVisuals codeLockVisuals;

	[SerializeField]
	private Seating seating;

	[SerializeField]
	[HideInInspector]
	private Vector3 steerAngle;

	[HideInInspector]
	[SerializeField]
	private Vector3 accelAngle;

	[SerializeField]
	[HideInInspector]
	private Vector3 brakeAngle;

	[SerializeField]
	[HideInInspector]
	private Vector3 speedometerAngle;

	[SerializeField]
	[HideInInspector]
	private Vector3 fuelAngle;

	[Header("Horn")]
	[SerializeField]
	private SoundDefinition hornLoop;

	[SerializeField]
	private SoundDefinition hornStart;

	private const Flags FLAG_HORN = Flags.Reserved8;

	private float steerPercent;

	private float throttlePercent;

	private float brakePercent;

	private bool? checkEngineLightOn;

	private bool? fuelLightOn;

	protected IVehicleLockUser VehicleLockUser;

	private MaterialPropertyBlock dashboardLightPB;

	private static int emissionColorID = Shader.PropertyToID("_EmissionColor");

	private BasePlayer hornPlayer;

	public override bool HasSeating => mountPoints.Count > 0;

	public ModularCar Car { get; private set; }

	protected bool IsOnACar => (Object)(object)Car != (Object)null;

	protected bool IsOnAVehicleLockUser => VehicleLockUser != null;

	public bool DoorsAreLockable => seating.doorsAreLockable;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehicleModuleSeating.OnRpcMessage", 0);
		try
		{
			if (rpc == 2791546333u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_DestroyLock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_DestroyLock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2791546333u, "RPC_DestroyLock", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_DestroyLock(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_DestroyLock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if ((Object)(object)seating.steeringWheel != (Object)null)
		{
			steerAngle = seating.steeringWheel.localEulerAngles;
		}
		if ((Object)(object)seating.accelPedal != (Object)null)
		{
			accelAngle = seating.accelPedal.localEulerAngles;
		}
		if ((Object)(object)seating.brakePedal != (Object)null)
		{
			brakeAngle = seating.brakePedal.localEulerAngles;
		}
		if ((Object)(object)seating.speedometer != (Object)null)
		{
			speedometerAngle = new Vector3(-160f, 0f, -40f);
		}
		if ((Object)(object)seating.fuelGauge != (Object)null)
		{
			fuelAngle = seating.fuelGauge.localEulerAngles;
		}
	}

	public virtual bool IsOnThisModule(BasePlayer player)
	{
		BaseMountable mounted = player.GetMounted();
		if ((Object)(object)mounted != (Object)null)
		{
			return (Object)(object)(mounted.GetParentEntity() as VehicleModuleSeating) == (Object)(object)this;
		}
		return false;
	}

	public bool HasADriverSeat()
	{
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (mountPoint.isDriver)
			{
				return true;
			}
		}
		return false;
	}

	public override void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex)
	{
		base.ModuleAdded(vehicle, firstSocketIndex);
		Car = vehicle as ModularCar;
		VehicleLockUser = vehicle as IVehicleLockUser;
		if (!HasSeating || !base.isServer)
		{
			return;
		}
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (mountPoint.mountable is ModularCarSeat modularCarSeat)
			{
				modularCarSeat.associatedSeatingModule = this;
			}
		}
	}

	public override void ModuleRemoved()
	{
		base.ModuleRemoved();
		Car = null;
		VehicleLockUser = null;
	}

	public bool PlayerCanDestroyLock(BasePlayer player)
	{
		if (!IsOnAVehicleLockUser || (Object)(object)player == (Object)null)
		{
			return false;
		}
		if (base.Vehicle.IsDead())
		{
			return false;
		}
		if (!HasADriverSeat())
		{
			return false;
		}
		if (!VehicleLockUser.PlayerCanDestroyLock(player, this))
		{
			return false;
		}
		if (player.isMounted)
		{
			return !VehicleLockUser.PlayerHasUnlockPermission(player);
		}
		return true;
	}

	protected BaseVehicleSeat GetSeatAtIndex(int index)
	{
		return mountPoints[index].mountable as BaseVehicleSeat;
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		if ((Object)(object)passengerProtection != (Object)null)
		{
			passengerProtection.Scale(info.damageTypes);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if ((Object)(object)hornLoop != (Object)null && IsOnThisModule(player))
		{
			bool flag = inputState.IsDown(BUTTON.FIRE_PRIMARY);
			if (flag != HasFlag(Flags.Reserved8))
			{
				SetFlag(Flags.Reserved8, flag);
			}
			if (flag)
			{
				Interface.CallHook("OnVehicleHornPressed", (object)this, (object)player);
				hornPlayer = player;
			}
		}
	}

	public override void OnPlayerDismountedVehicle(BasePlayer player)
	{
		base.OnPlayerDismountedVehicle(player);
		if (HasFlag(Flags.Reserved8) && (Object)(object)player == (Object)(object)hornPlayer)
		{
			SetFlag(Flags.Reserved8, b: false);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_DestroyLock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (IsOnAVehicleLockUser && PlayerCanDestroyLock(player))
		{
			VehicleLockUser.RemoveLock();
		}
	}

	protected virtual Vector3 ModifySeatPositionLocalSpace(int index, Vector3 desiredPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return desiredPos;
	}

	public override void OnEngineStateChanged(VehicleEngineController<GroundVehicle>.EngineState oldState, VehicleEngineController<GroundVehicle>.EngineState newState)
	{
		base.OnEngineStateChanged(oldState, newState);
		if (!GameInfo.HasAchievements || base.isClient || newState != VehicleEngineController<GroundVehicle>.EngineState.On || mountPoints == null)
		{
			return;
		}
		bool flag = true;
		foreach (BaseVehicleModule attachedModuleEntity in Car.AttachedModuleEntities)
		{
			if (attachedModuleEntity is VehicleModuleEngine { AtPeakPerformance: false })
			{
				flag = false;
				break;
			}
		}
		if (!flag)
		{
			return;
		}
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if ((Object)(object)mountPoint.mountable.GetMounted() != (Object)null)
			{
				mountPoint.mountable.GetMounted().GiveAchievement("BUCKLE_UP");
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class MountHotSpot
{
	public Transform transform;

	public Vector2 size;
}


using System;
using UnityEngine;

[Serializable]
public class Seating
{
	[Header("Seating & Controls")]
	public bool doorsAreLockable = true;

	[Obsolete("Use BaseVehicle.mountPoints instead")]
	[HideInInspector]
	public MountPointInfo[] mountPoints;

	public Transform steeringWheel;

	public Transform accelPedal;

	public Transform brakePedal;

	public Transform steeringWheelLeftGrip;

	public Transform steeringWheelRightGrip;

	public Transform accelPedalGrip;

	public Transform brakePedalGrip;

	public MountHotSpot[] mountHotSpots;

	[Header("Dashboard")]
	public Transform speedometer;

	public Transform fuelGauge;

	public Renderer dashboardRenderer;

	[Range(0f, 3f)]
	public int checkEngineLightMatIndex = 2;

	[ColorUsage(true, true)]
	public Color checkEngineLightEmission;

	[Range(0f, 3f)]
	public int fuelLightMatIndex = 3;

	[ColorUsage(true, true)]
	public Color fuelLightEmission;
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class VehicleModuleStorage : VehicleModuleSeating
{
	[Serializable]
	public class Storage
	{
		public GameObjectRef storageUnitPrefab;

		public Transform storageUnitPoint;
	}

	[SerializeField]
	private Storage storage;

	private EntityRef storageUnitInstance;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehicleModuleStorage.OnRpcMessage", 0);
		try
		{
			if (rpc == 4254195175u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Open "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Open", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4254195175u, "RPC_Open", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Open(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Open");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 425471188 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TryOpenWithKeycode "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TryOpenWithKeycode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(425471188u, "RPC_TryOpenWithKeycode", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_TryOpenWithKeycode(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_TryOpenWithKeycode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public IItemContainerEntity GetContainer()
	{
		BaseEntity baseEntity = storageUnitInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as IItemContainerEntity;
		}
		return null;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		storageUnitInstance.uid = info.msg.simpleUID.uid;
	}

	public override void Spawn()
	{
		base.Spawn();
		if (!Application.isLoadingSave && ((Component)storage.storageUnitPoint).gameObject.activeSelf)
		{
			CreateStorageEntity();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		IItemContainerEntity container = GetContainer();
		if (!container.IsUnityNull())
		{
			ItemContainer inventory = container.inventory;
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
		}
	}

	private void OnItemAddedRemoved(Item item, bool add)
	{
		AssociatedItemInstance?.LockUnlock(!CanBeMovedNowOnVehicle());
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot)
		{
			IItemContainerEntity container = GetContainer();
			if (!container.IsUnityNull())
			{
				container.DropItems();
			}
		}
		base.DoServerDestroy();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.simpleUID = Pool.Get<SimpleUID>();
		info.msg.simpleUID.uid = storageUnitInstance.uid;
	}

	public void CreateStorageEntity()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (IsFullySpawned() && base.isServer && !storageUnitInstance.IsValid(base.isServer))
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(storage.storageUnitPrefab.resourcePath, storage.storageUnitPoint.localPosition, storage.storageUnitPoint.localRotation);
			storageUnitInstance.Set(baseEntity);
			baseEntity.SetParent(this);
			baseEntity.Spawn();
			ItemContainer inventory = GetContainer().inventory;
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
		}
	}

	public void DestroyStorageEntity()
	{
		if (!IsFullySpawned() || !base.isServer)
		{
			return;
		}
		BaseEntity baseEntity = storageUnitInstance.Get(base.isServer);
		if (baseEntity.IsValid())
		{
			if (baseEntity is BaseCombatEntity baseCombatEntity)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill();
			}
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_Open(RPCMessage msg)
	{
		TryOpen(msg.player);
	}

	private bool TryOpen(BasePlayer player)
	{
		if (!player.IsValid() || !CanBeLooted(player))
		{
			return false;
		}
		IItemContainerEntity container = GetContainer();
		if (!container.IsUnityNull())
		{
			container.PlayerOpenLoot(player);
		}
		else
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
		}
		return true;
	}

	protected override bool CanBeMovedNowOnVehicle()
	{
		IItemContainerEntity container = GetContainer();
		if (!container.IsUnityNull() && !container.inventory.IsEmpty())
		{
			return false;
		}
		return true;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_TryOpenWithKeycode(RPCMessage msg)
	{
		if (!base.IsOnACar)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			string codeEntered = msg.read.String(256, false);
			if (base.Car.CarLock.TryOpenWithCode(player, codeEntered))
			{
				TryOpen(player);
			}
			else
			{
				base.Car.ClientRPC(RpcTarget.NetworkGroup("CodeEntryFailed"));
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class Storage
{
	public GameObjectRef storageUnitPrefab;

	public Transform storageUnitPoint;
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class VehicleModuleTaxi : VehicleModuleStorage
{
	[SerializeField]
	[Header("Taxi")]
	private SoundDefinition kickButtonSound;

	[SerializeField]
	private SphereCollider kickButtonCollider;

	[SerializeField]
	private float maxKickVelocity = 4f;

	private Vector3 KickButtonPos => ((Component)kickButtonCollider).transform.position + ((Component)kickButtonCollider).transform.rotation * kickButtonCollider.center;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehicleModuleTaxi.OnRpcMessage", 0);
		try
		{
			if (rpc == 2714639811u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_KickPassengers "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_KickPassengers", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2714639811u, "RPC_KickPassengers", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_KickPassengers(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_KickPassengers");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private bool CanKickPassengers(BasePlayer player)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (!base.IsOnAVehicle)
		{
			return false;
		}
		if (base.Vehicle.GetSpeed() > maxKickVelocity)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (!base.Vehicle.PlayerIsMounted(player))
		{
			return false;
		}
		Vector3 val = KickButtonPos - ((Component)player).transform.position;
		if (Vector3.Dot(val, ((Component)player).transform.forward) < 0f)
		{
			return ((Vector3)(ref val)).sqrMagnitude < 4f;
		}
		return false;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_KickPassengers(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanKickPassengers(player))
		{
			KickPassengers();
		}
	}

	private void KickPassengers()
	{
		if (!base.IsOnAVehicle)
		{
			return;
		}
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			BaseMountable mountable = mountPoint.mountable;
			BasePlayer mounted = mountable.GetMounted();
			if ((Object)(object)mounted != (Object)null && mountable.HasValidDismountPosition(mounted))
			{
				mountable.AttemptDismount(mounted);
			}
		}
	}
}


using System;
using System.Linq;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class VehiclePrivilege : SimplePrivilege
{
	public GameObject assignDialog;

	public bool SupportFriendListAdd;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehiclePrivilege.OnRpcMessage", 0);
		try
		{
			if (rpc == 82205621 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AddAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("AddAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(82205621u, "AddAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							AddAuthorize(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AddAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1092560690 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AddSelfAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("AddSelfAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1092560690u, "AddSelfAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							AddSelfAuthorize(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in AddSelfAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 253307592 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearList "));
				}
				TimeWarning val2 = TimeWarning.New("ClearList", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(253307592u, "ClearList", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							ClearList(rpc4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in ClearList");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3617985969u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RemoveSelfAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("RemoveSelfAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3617985969u, "RemoveSelfAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc5 = rPCMessage;
							RemoveSelfAuthorize(rpc5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RemoveSelfAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsDriver(BasePlayer player)
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return false;
		}
		BaseVehicle baseVehicle = baseEntity as BaseVehicle;
		if ((Object)(object)baseVehicle == (Object)null)
		{
			return false;
		}
		return baseVehicle.IsDriver(player);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void AddSelfAuthorize(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsDriver(rpc.player) && Interface.CallHook("OnCupboardAuthorize", (object)this, (object)rpc.player) == null)
		{
			AddPlayer(rpc.player);
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void AddAuthorize(RPCMessage rpc)
	{
		if (SupportFriendListAdd && rpc.player.CanInteract() && IsAuthed(rpc.player) && IsDriver(rpc.player))
		{
			ulong targetPlayerId = rpc.read.UInt64();
			AddPlayer(rpc.player, targetPlayerId);
			SendNetworkUpdate();
		}
	}

	public void AddPlayer(BasePlayer granter, ulong targetPlayerId)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Expected O, but got Unknown
		if (!AtMaxAuthCapacity())
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == targetPlayerId);
			PlayerNameID val = new PlayerNameID();
			val.userid = targetPlayerId;
			string username = BasePlayer.FindByID(targetPlayerId)?.displayName ?? "unknown";
			val.username = username;
			authorizedPlayers.Add(val);
			Analytics.Azure.OnEntityAuthChanged(this, granter, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", targetPlayerId);
			UpdateMaxAuthCapacity();
		}
	}

	public void AddPlayer(BasePlayer player)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Expected O, but got Unknown
		if (!AtMaxAuthCapacity())
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == (ulong)player.userID);
			PlayerNameID val = new PlayerNameID();
			val.userid = player.userID;
			val.username = player.displayName;
			authorizedPlayers.Add(val);
			Analytics.Azure.OnEntityAuthChanged(this, player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", player.userID);
			UpdateMaxAuthCapacity();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (rpc2.player.CanInteract() && IsDriver(rpc2.player) && Interface.CallHook("OnCupboardDeauthorize", (object)this, (object)rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == (ulong)rpc2.player.userID);
			Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "removed", rpc2.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void ClearList(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsDriver(rpc.player) && Interface.CallHook("OnCupboardClearList", (object)this, (object)rpc.player) == null)
		{
			authorizedPlayers.Clear();
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class VendingMachine : ContainerIOEntity, IUGCBrowserEntity, IFoodSpoilModifier, PlayerInventory.ICanMoveFrom
{
	public static class VendingMachineFlags
	{
		public const Flags EmptyInv = Flags.Reserved1;

		public const Flags IsVending = Flags.Reserved2;

		public const Flags Broadcasting = Flags.Reserved4;

		public const Flags OutOfStock = Flags.Reserved5;

		public const Flags NoDirectAccess = Flags.Reserved6;
	}

	private enum HistoryCategory
	{
		History,
		BestSold,
		MostRevenue
	}

	[Serializable]
	public class PurchaseDetails
	{
		public int itemId;

		public int amount;

		public int priceId;

		public int price;

		public int timestamp;

		public bool itemIsBp;

		public bool priceIsBp;
	}

	[Header("VendingMachine")]
	public static readonly Phrase WaitForVendingMessage = new Phrase("vendingmachine.wait", "Please wait...");

	public GameObjectRef adminMenuPrefab;

	public string customerPanel = "";

	public SellOrderContainer sellOrders;

	public SoundPlayer buySound;

	public string shopName = "A Shop";

	public int maxCurrencyVolume = 1;

	public Vector3 localDropPosition = Vector3.zero;

	public GameObjectRef mapMarkerPrefab;

	public bool IsLocalized;

	[Range(0f, 1f)]
	public float PoweredFoodSpoilageRateMultiplier = 0.1f;

	public int PowerConsumption = 5;

	private Action fullUpdateCached;

	private ulong nameLastEditedBy;

	protected BasePlayer vend_Player;

	private int vend_sellOrderID;

	private int vend_numberOfTransactions;

	public bool transactionActive;

	private VendingMachineMapMarker myMarker;

	private bool industrialItemIncoming;

	public static readonly Phrase TooManySellOrders = new Phrase("error_toomanysellorders", "Too many sell orders");

	[ServerVar]
	public static int max_returned = 100;

	[ServerVar]
	public static int max_processed = 10000;

	[ServerVar]
	public static int max_history = 10000;

	private List<PurchaseDetails> purchaseHistory = new List<PurchaseDetails>();

	private Dictionary<ulong, int> uniqueCustomers = new Dictionary<ulong, int>();

	public ItemDefinition blueprintBaseDef => ItemManager.blueprintBaseDef;

	public uint[] GetContentCRCs => null;

	public UGCType ContentType => UGCType.VendingMachine;

	public List<ulong> EditingHistory => new List<ulong> { nameLastEditedBy };

	public BaseNetworkable UgcEntity
	{
		get
		{
			if (!(this is NPCVendingMachine))
			{
				return this;
			}
			return null;
		}
	}

	public string ContentString => shopName;

	public virtual EraRestriction CurrentEraRestriction => (EraRestriction)7;

	public virtual bool ShouldRecordStats => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VendingMachine.OnRpcMessage", 0);
		try
		{
			if (rpc == 3011053703u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BuyItem "));
				}
				TimeWarning val2 = TimeWarning.New("BuyItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3011053703u, "BuyItem", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3011053703u, "BuyItem", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							BuyItem(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in BuyItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1626480840 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_AddSellOrder "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_AddSellOrder", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1626480840u, "RPC_AddSellOrder", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_AddSellOrder(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_AddSellOrder");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 169239598 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Broadcast "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Broadcast", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(169239598u, "RPC_Broadcast", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_Broadcast(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_Broadcast");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3680901137u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_DeleteSellOrder "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_DeleteSellOrder", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3680901137u, "RPC_DeleteSellOrder", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_DeleteSellOrder(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_DeleteSellOrder");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2555993359u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenAdmin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenAdmin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2555993359u, "RPC_OpenAdmin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RPC_OpenAdmin(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in RPC_OpenAdmin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 36164441 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenShop "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenShop", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(36164441u, "RPC_OpenShop", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							RPC_OpenShop(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in RPC_OpenShop");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2947824655u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenShopNoLOS "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenShopNoLOS", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2947824655u, "RPC_OpenShopNoLOS", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							RPC_OpenShopNoLOS(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in RPC_OpenShopNoLOS");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3346513099u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RotateVM "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RotateVM", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3346513099u, "RPC_RotateVM", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							RPC_RotateVM(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogException(ex8);
						player.Kick("RPC Error in RPC_RotateVM");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1012779214 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_UpdateShopName "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_UpdateShopName", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1012779214u, "RPC_UpdateShopName", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg9 = rPCMessage;
							RPC_UpdateShopName(msg9);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogException(ex9);
						player.Kick("RPC Error in RPC_UpdateShopName");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1147600716 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_RequestLongTermData "));
				}
				TimeWarning val2 = TimeWarning.New("SV_RequestLongTermData", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1147600716u, "SV_RequestLongTermData", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1147600716u, "SV_RequestLongTermData", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg10 = rPCMessage;
							SV_RequestLongTermData(msg10);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogException(ex10);
						player.Kick("RPC Error in SV_RequestLongTermData");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3957849636u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_RequestPurchaseData "));
				}
				TimeWarning val2 = TimeWarning.New("SV_RequestPurchaseData", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3957849636u, "SV_RequestPurchaseData", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3957849636u, "SV_RequestPurchaseData", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg11 = rPCMessage;
							SV_RequestPurchaseData(msg11);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogException(ex11);
						player.Kick("RPC Error in SV_RequestPurchaseData");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3559014831u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - TransactionStart "));
				}
				TimeWarning val2 = TimeWarning.New("TransactionStart", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3559014831u, "TransactionStart", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							TransactionStart(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex12)
					{
						Debug.LogException(ex12);
						player.Kick("RPC Error in TransactionStart");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}

	public float GetSpoilMultiplier(Item arg)
	{
		if (IsPowered())
		{
			return PoweredFoodSpoilageRateMultiplier;
		}
		return 1f;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk && info.msg.vendingMachineStats != null)
		{
			purchaseHistory = GetListFromProto(info.msg.vendingMachineStats.purchaseHistory);
			for (int i = 0; i < info.msg.vendingMachineStats.customers.Count; i++)
			{
				uniqueCustomers.Add(info.msg.vendingMachineStats.customers[i], info.msg.vendingMachineStats.customersVisits[i]);
			}
		}
		if (info.msg.vendingMachine != null)
		{
			if (!IsLocalized)
			{
				shopName = info.msg.vendingMachine.shopName;
			}
			if (info.msg.vendingMachine.sellOrderContainer != null)
			{
				sellOrders = info.msg.vendingMachine.sellOrderContainer;
				sellOrders.ShouldPool = false;
			}
			if (info.fromDisk && base.isServer)
			{
				nameLastEditedBy = info.msg.vendingMachine.nameLastEditedBy;
				RefreshSellOrderStockLevel();
			}
		}
	}

	public static int GetTotalReceivedMerchandiseForOrder(SellOrder order)
	{
		return GetTotalReceivedMerchandiseForOrder(order.itemToSellAmount, order.receivedQuantityMultiplier);
	}

	public static int GetTotalReceivedMerchandiseForOrder(int merchAmountPerOrder, float multiplier)
	{
		float num = ((multiplier != 0f) ? multiplier : 1f);
		return Mathf.Max(Mathf.RoundToInt((float)merchAmountPerOrder * num), 1);
	}

	public static int GetTotalPriceForOrder(SellOrder order)
	{
		return GetTotalPriceForOrder(order.currencyAmountPerItem, order.priceMultiplier);
	}

	public static int GetTotalPriceForOrder(int currencyAmountPerItem, float multiplier)
	{
		float num = ((multiplier != 0f) ? multiplier : 1f);
		return Mathf.Max(Mathf.RoundToInt((float)currencyAmountPerItem * num), 1);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	public override void Save(SaveInfo info)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Expected O, but got Unknown
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Expected O, but got Unknown
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Expected O, but got Unknown
		base.Save(info);
		info.msg.vendingMachine = new VendingMachine();
		info.msg.vendingMachine.ShouldPool = false;
		info.msg.vendingMachine.shopName = shopName;
		if (info.forDisk)
		{
			info.msg.vendingMachine.nameLastEditedBy = nameLastEditedBy;
			if (ShouldRecordStats)
			{
				info.msg.vendingMachineStats = Pool.Get<VendingMachineStats>();
				info.msg.vendingMachineStats.purchaseHistory = GetEntriesProto(purchaseHistory);
				info.msg.vendingMachineStats.customers = uniqueCustomers.Keys.ToList();
				info.msg.vendingMachineStats.customersVisits = uniqueCustomers.Values.ToList();
			}
		}
		if (this is NPCVendingMachine)
		{
			info.msg.vendingMachine.translationToken = GetTranslationToken();
		}
		if (sellOrders == null)
		{
			return;
		}
		info.msg.vendingMachine.sellOrderContainer = new SellOrderContainer();
		info.msg.vendingMachine.sellOrderContainer.ShouldPool = false;
		info.msg.vendingMachine.sellOrderContainer.sellOrders = new List<SellOrder>();
		foreach (SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (CanSellOrBuyItem(sellOrder.itemToSellID, sellOrder.currencyID))
			{
				SellOrder val = new SellOrder();
				val.ShouldPool = false;
				sellOrder.CopyTo(val);
				info.msg.vendingMachine.sellOrderContainer.sellOrders.Add(val);
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (base.isServer)
		{
			InstallDefaultSellOrders();
			SetFlag(Flags.Reserved2, b: false);
			base.inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
			RefreshSellOrderStockLevel();
			ItemContainer itemContainer = base.inventory;
			itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
			UpdateMapMarker();
			fullUpdateCached = FullUpdate;
		}
	}

	public override void DestroyShared()
	{
		if (Object.op_Implicit((Object)(object)myMarker))
		{
			myMarker.Kill();
			myMarker = null;
		}
		base.DestroyShared();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return true;
	}

	public void FullUpdate()
	{
		RefreshSellOrderStockLevel();
		UpdateMapMarker();
		SendNetworkUpdate();
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		((FacepunchBehaviour)this).CancelInvoke(fullUpdateCached);
		((FacepunchBehaviour)this).Invoke(fullUpdateCached, 0.2f);
	}

	public void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)
	{
		int num = 0;
		foreach (SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (!((Object)(object)itemDef == (Object)null) && itemDef.itemid != sellOrder.itemToSellID)
			{
				continue;
			}
			List<Item> list = Pool.Get<List<Item>>();
			GetItemsToSell(sellOrder, list);
			int num2 = sellOrder.itemToSellAmount;
			if ((Object)(object)ItemManager.FindItemDefinition(sellOrder.itemToSellID) == (Object)(object)NPCVendingMachine.ScrapItem && sellOrder.receivedQuantityMultiplier != 1f)
			{
				num2 = GetTotalPriceForOrder(num2, sellOrder.receivedQuantityMultiplier);
			}
			int inStock;
			if (list.Count < 0)
			{
				inStock = 0;
			}
			else
			{
				List<Item> source = list;
				Func<Item, int> selector = (Item x) => x.amount;
				Interface.CallHook("OnRefreshVendingStock", (object)this, (object)itemDef);
				inStock = source.Sum(selector) / num2;
			}
			sellOrder.inStock = inStock;
			float itemCondition = 0f;
			float itemConditionMax = 0f;
			int instanceData = 0;
			List<int> list2 = Pool.Get<List<int>>();
			int totalAttachmentSlots = 0;
			int ammoType = 0;
			int ammoCount = 0;
			if (list.Count > 0)
			{
				if (list[0].hasCondition)
				{
					itemCondition = list[0].condition;
					itemConditionMax = list[0].maxCondition;
				}
				if ((Object)(object)list[0].info != (Object)null && (list[0].info.amountType == ItemDefinition.AmountType.Genetics || list[0].info.amountType == ItemDefinition.AmountType.NucleusGrades) && list[0].instanceData != null)
				{
					instanceData = list[0].instanceData.dataInt;
					sellOrder.inStock = list[0].amount;
				}
				if (list[0].contents != null && list[0].contents.capacity > 0 && list[0].contents.HasFlag(ItemContainer.Flag.ShowSlotsOnIcon))
				{
					foreach (Item item in list[0].contents.itemList)
					{
						list2.Add(item.info.itemid);
					}
					totalAttachmentSlots = list[0].contents.capacity;
				}
				if (list[0].GetHeldEntity() is BaseProjectile { primaryMagazine: not null } baseProjectile)
				{
					ammoCount = baseProjectile.primaryMagazine.contents;
					if ((Object)(object)baseProjectile.primaryMagazine.ammoType != (Object)null)
					{
						ammoType = baseProjectile.primaryMagazine.ammoType.itemid;
					}
				}
			}
			sellOrder.ammoType = ammoType;
			sellOrder.ammoCount = ammoCount;
			sellOrder.itemCondition = itemCondition;
			sellOrder.itemConditionMax = itemConditionMax;
			sellOrder.instanceData = instanceData;
			if (sellOrder.attachmentsList != null)
			{
				Pool.FreeUnmanaged<int>(ref sellOrder.attachmentsList);
			}
			sellOrder.attachmentsList = list2;
			sellOrder.totalAttachmentSlots = totalAttachmentSlots;
			sellOrder.priceMultiplier = GetDiscountForSlot(num, sellOrder);
			sellOrder.receivedQuantityMultiplier = GetReceivedQuantityMultiplier(num, sellOrder);
			num++;
			Pool.Free<Item>(ref list, false);
		}
	}

	protected virtual float GetDiscountForSlot(int sellOrderSlot, SellOrder forOrder)
	{
		return 1f;
	}

	protected virtual float GetReceivedQuantityMultiplier(int sellOrderSlot, SellOrder forOrder)
	{
		return 1f;
	}

	public bool OutOfStock()
	{
		foreach (SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (sellOrder.inStock > 0)
			{
				return true;
			}
		}
		return false;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Reserved2, b: false);
		RefreshSellOrderStockLevel();
		UpdateMapMarker();
	}

	public void UpdateEmptyFlag()
	{
		SetFlag(Flags.Reserved1, base.inventory.itemList.Count == 0);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.PlayerStoppedLooting(player);
		UpdateEmptyFlag();
		if ((Object)(object)vend_Player != (Object)null && (Object)(object)vend_Player == (Object)(object)player)
		{
			ClearPendingOrder();
		}
	}

	public virtual void InstallDefaultSellOrders()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		sellOrders = new SellOrderContainer();
		sellOrders.ShouldPool = false;
		sellOrders.sellOrders = new List<SellOrder>();
	}

	public virtual bool HasVendingSounds()
	{
		return true;
	}

	public virtual float GetBuyDuration()
	{
		return 2.5f;
	}

	public void SetPendingOrder(BasePlayer buyer, int sellOrderId, int numberOfTransactions)
	{
		ClearPendingOrder();
		vend_Player = buyer;
		vend_sellOrderID = sellOrderId;
		vend_numberOfTransactions = numberOfTransactions;
		SetFlag(Flags.Reserved2, b: true);
		if (HasVendingSounds())
		{
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_StartVendingSounds"), sellOrderId);
		}
	}

	public void ClearPendingOrder()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)CompletePendingOrder);
		vend_Player = null;
		vend_sellOrderID = -1;
		vend_numberOfTransactions = -1;
		SetFlag(Flags.Reserved2, b: false);
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_CancelVendingSounds"));
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void BuyItem(RPCMessage rpc)
	{
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		if (!OccupiedCheck(rpc.player))
		{
			return;
		}
		int num = rpc.read.Int32();
		int num2 = rpc.read.Int32();
		if (IsVending())
		{
			rpc.player.ShowToast(GameTip.Styles.Red_Normal, WaitForVendingMessage, false);
		}
		else
		{
			if (Interface.CallHook("OnBuyVendingItem", (object)this, (object)rpc.player, (object)num, (object)num2) != null)
			{
				return;
			}
			int num3 = 0;
			for (int i = 0; i < sellOrders.sellOrders.Count; i++)
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellOrders.sellOrders[i].itemToSellID);
				ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(sellOrders.sellOrders[i].currencyID);
				if (itemDefinition.IsAllowed(CurrentEraRestriction) && itemDefinition2.IsAllowed(CurrentEraRestriction))
				{
					if (num3 == num)
					{
						num = i;
						break;
					}
					num3++;
				}
			}
			SetPendingOrder(rpc.player, num, num2);
			((FacepunchBehaviour)this).Invoke((Action)CompletePendingOrder, GetBuyDuration());
		}
	}

	public virtual void CompletePendingOrder()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		DoTransaction(vend_Player, vend_sellOrderID, vend_numberOfTransactions);
		ClearPendingOrder();
		Decay.RadialDecayTouch(((Component)this).transform.position, 40f, 2097408);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void TransactionStart(RPCMessage rpc)
	{
	}

	private void GetItemsToSell(SellOrder sellOrder, List<Item> items)
	{
		if (sellOrder.itemToSellIsBP)
		{
			foreach (Item item in base.inventory.itemList)
			{
				if (item.info.itemid == blueprintBaseDef.itemid && item.blueprintTarget == sellOrder.itemToSellID)
				{
					items.Add(item);
				}
			}
			return;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if (item2.info.itemid == sellOrder.itemToSellID)
			{
				items.Add(item2);
			}
		}
	}

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action<BasePlayer, Item> onCurrencyRemoved = null, Action<BasePlayer, Item> onItemPurchased = null, MarketTerminal droneMarketTerminal = null)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_039e: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		if (sellOrderId < 0 || sellOrderId >= sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (targetContainer == null && Vector3.Distance(((Component)buyer).transform.position, ((Component)this).transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", (object)this, (object)buyer, (object)sellOrderId, (object)numberOfTransactions, (object)targetContainer);
		if (obj is bool)
		{
			return (bool)obj;
		}
		SellOrder val = sellOrders.sellOrders[sellOrderId];
		List<Item> list = Pool.Get<List<Item>>();
		GetItemsToSell(val, list);
		if (list == null || list.Count == 0)
		{
			Pool.FreeUnmanaged<Item>(ref list);
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, list[0].hasCondition ? 1 : 1000000);
		int num = val.itemToSellAmount * numberOfTransactions;
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(val.itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(val.currencyID);
		if (!itemDefinition.IsAllowed(CurrentEraRestriction) || !itemDefinition2.IsAllowed(CurrentEraRestriction))
		{
			return false;
		}
		if ((Object)(object)itemDefinition == (Object)(object)NPCVendingMachine.ScrapItem && val.receivedQuantityMultiplier != 1f)
		{
			num = GetTotalReceivedMerchandiseForOrder(val.itemToSellAmount, val.receivedQuantityMultiplier) * numberOfTransactions;
		}
		int num2 = list.Sum((Item x) => x.amount);
		if (num > num2)
		{
			Pool.FreeUnmanaged<Item>(ref list);
			return false;
		}
		int num3 = 0;
		PooledList<Item> val2 = Pool.Get<PooledList<Item>>();
		try
		{
			PooledList<Item> val3 = Pool.Get<PooledList<Item>>();
			try
			{
				buyer.inventory.FindItemsByItemID((List<Item>)(object)val3, val.currencyIsBP ? blueprintBaseDef.itemid : val.currencyID);
				for (int i = 0; i < ((List<Item>)(object)val3).Count; i++)
				{
					Item item = ((List<Item>)(object)val3)[i];
					if ((!val.currencyIsBP || item.blueprintTarget == val.currencyID) && (!item.hasCondition || (item.conditionNormalized >= 0.5f && item.maxConditionNormalized > 0.5f)) && item.GetItemVolume() <= maxCurrencyVolume)
					{
						((List<Item>)(object)val2).Add(item);
						num3 += item.amount;
					}
				}
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
			if (((List<Item>)(object)val2).Count == 0)
			{
				Pool.FreeUnmanaged<Item>(ref list);
				return false;
			}
			int num4 = GetTotalPriceForOrder(val) * numberOfTransactions;
			if (num3 < num4)
			{
				Pool.FreeUnmanaged<Item>(ref list);
				return false;
			}
			transactionActive = true;
			int num5 = 0;
			for (int j = 0; j < ((List<Item>)(object)val2).Count; j++)
			{
				Item item2 = ((List<Item>)(object)val2)[j];
				int num6 = Mathf.Min(num4 - num5, item2.amount);
				Item item3 = ((item2.amount > num6) ? item2.SplitItem(num6) : item2);
				TakeCurrencyItem(item3);
				onCurrencyRemoved?.Invoke(buyer, item3);
				num5 += num6;
				if (num5 >= num4)
				{
					break;
				}
			}
			int num7 = 0;
			foreach (Item item5 in list)
			{
				int num8 = num - num7;
				Item item4 = ((item5.amount > num8) ? item5.SplitItem(num8) : item5);
				if (item4 == null)
				{
					Debug.LogError((object)"Vending machine error, contact developers!");
				}
				else
				{
					num7 += item4.amount;
					object obj2 = Interface.CallHook("CanPurchaseItem", (object)buyer, (object)item4, (object)onItemPurchased, (object)this, (object)targetContainer);
					if (obj2 != null)
					{
						if (!(obj2 is bool))
						{
							return false;
						}
						return (bool)obj2;
					}
					RecordSaleAnalytics(item4, sellOrderId, val.currencyAmountPerItem);
					if (targetContainer == null)
					{
						GiveSoldItem(item4, buyer);
					}
					else if (!item4.MoveToContainer(targetContainer))
					{
						item4.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
					}
					if (ShouldRecordStats)
					{
						RegisterCustomer(buyer.userID);
					}
					onItemPurchased?.Invoke(buyer, item4);
				}
				if (num7 >= num)
				{
					break;
				}
			}
			Analytics.Azure.OnBuyFromVendingMachine(buyer, this, val.itemToSellID, num, val.itemToSellIsBP, val.currencyID, num5, val.currencyIsBP, numberOfTransactions, val.priceMultiplier, droneMarketTerminal);
			if (ShouldRecordStats)
			{
				AddPurchaseHistory(val.itemToSellID, num, val.currencyID, num5, val.itemToSellIsBP, val.currencyIsBP);
			}
			Pool.FreeUnmanaged<Item>(ref list);
			UpdateEmptyFlag();
			transactionActive = false;
			return true;
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	protected virtual void RecordSaleAnalytics(Item itemSold, int orderId, int currencyUsed)
	{
	}

	public virtual void TakeCurrencyItem(Item takenCurrencyItem)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnTakeCurrencyItem", (object)this, (object)takenCurrencyItem) == null && !takenCurrencyItem.MoveToContainer(base.inventory))
		{
			takenCurrencyItem.Drop(base.inventory.dropPosition, Vector3.zero);
		}
	}

	public virtual void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnGiveSoldItem", (object)this, (object)soldItem, (object)buyer) == null)
		{
			while (soldItem.amount > soldItem.MaxStackable())
			{
				Item item = soldItem.SplitItem(soldItem.MaxStackable());
				buyer.GiveItem(item, GiveItemReason.PickedUp);
			}
			buyer.GiveItem(soldItem, GiveItemReason.PickedUp);
		}
	}

	public void SendSellOrders(BasePlayer player = null)
	{
		if (Object.op_Implicit((Object)(object)player))
		{
			ClientRPC(RpcTarget.Player("CLIENT_ReceiveSellOrders", player), sellOrders);
		}
		else
		{
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_ReceiveSellOrders"), sellOrders);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Broadcast(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool b = msg.read.Bit();
		if (CanPlayerAdmin(player))
		{
			SetFlag(Flags.Reserved4, b);
			Interface.CallHook("OnToggleVendingBroadcast", (object)this, (object)player);
			UpdateMapMarker();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_UpdateShopName(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		string text = msg.read.String(32, false);
		if (CanPlayerAdmin(player) && Interface.CallHook("OnVendingShopRename", (object)this, (object)text, (object)player) == null)
		{
			shopName = text;
			nameLastEditedBy = player.userID.Get();
			UpdateMapMarker();
		}
	}

	public void UpdateMapMarkerPosition()
	{
		if (!((Object)(object)myMarker == (Object)null))
		{
			myMarker.TryUpdatePosition();
		}
	}

	public void UpdateMapMarker(bool updatePosition = false)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (!mapMarkerPrefab.isValid)
		{
			return;
		}
		if (IsBroadcasting())
		{
			bool flag = false;
			if ((Object)(object)myMarker == (Object)null)
			{
				myMarker = GameManager.server.CreateEntity(mapMarkerPrefab.resourcePath, ((Component)this).transform.position, Quaternion.identity) as VendingMachineMapMarker;
				flag = true;
			}
			myMarker.SetFlag(Flags.Busy, OutOfStock());
			myMarker.SetVendingMachine(this, shopName);
			if (flag)
			{
				myMarker.Spawn();
			}
			else
			{
				myMarker.SendNetworkUpdate();
			}
		}
		else if (Object.op_Implicit((Object)(object)myMarker))
		{
			myMarker.Kill();
			myMarker = null;
		}
	}

	public void OpenShop(BasePlayer ply)
	{
		SendSellOrders(ply);
		PlayerOpenLoot(ply, customerPanel);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_OpenShopNoLOS(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player))
		{
			OpenShop(msg.player);
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player) && Interface.CallHook("OnVendingShopOpen", (object)this, (object)msg.player) == null)
		{
			OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", (object)this, (object)msg.player);
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenAdmin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			OpenShop(player);
			ClientRPC(RpcTarget.Player("CLIENT_OpenAdminMenu", player));
			Interface.CallHook("OnOpenVendingAdmin", (object)this, (object)player);
		}
	}

	public void OnIndustrialItemTransferBegins()
	{
		industrialItemIncoming = true;
	}

	public void OnIndustrialItemTransferEnds()
	{
		industrialItemIncoming = false;
	}

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanVendingAcceptItem", (object)this, (object)item, (object)targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BasePlayer basePlayer = item.GetRootContainer()?.GetOwnerPlayer();
		if (transactionActive || industrialItemIncoming)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (base.inventory.itemList.Contains(item))
		{
			return true;
		}
		if ((Object)(object)basePlayer == (Object)null)
		{
			return item.GetEntityOwner() is ContainerCorpse;
		}
		return CanPlayerAdmin(basePlayer);
	}

	public bool CanMoveFrom(BasePlayer player, Item item)
	{
		return CanPlayerAdmin(player);
	}

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		object obj = Interface.CallHook("CanUseVending", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (panelName == customerPanel)
		{
			return true;
		}
		if (base.CanOpenLootPanel(player, panelName))
		{
			return CanPlayerAdmin(player);
		}
		return false;
	}

	public override Vector3 GetDropPosition()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(localDropPosition);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_DeleteSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			int num = msg.read.Int32();
			Interface.CallHook("OnDeleteVendingOffer", (object)this, (object)num);
			if (num >= 0 && num < sellOrders.sellOrders.Count)
			{
				SellOrder val = sellOrders.sellOrders[num];
				Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, val.itemToSellID, val.itemToSellAmount, val.itemToSellIsBP, val.currencyID, val.currencyAmountPerItem, val.currencyIsBP, added: false);
				sellOrders.sellOrders.RemoveAt(num);
			}
			RefreshSellOrderStockLevel();
			UpdateMapMarker();
			SendSellOrders(player);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_RotateVM(RPCMessage msg)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnRotateVendingMachine", (object)this, (object)msg.player) == null && CanRotate())
		{
			UpdateEmptyFlag();
			if (msg.player.CanBuild() && IsInventoryEmpty())
			{
				((Component)this).transform.rotation = Quaternion.LookRotation(-((Component)this).transform.forward, ((Component)this).transform.up);
				SendNetworkUpdate();
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_AddSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			if (sellOrders.sellOrders.Count >= 7)
			{
				player.ShowToast(GameTip.Styles.Error, TooManySellOrders, true);
				return;
			}
			int num = msg.read.Int32();
			int num2 = msg.read.Int32();
			int num3 = msg.read.Int32();
			int num4 = msg.read.Int32();
			byte b = msg.read.UInt8();
			AddSellOrder(num, num2, num3, num4, b);
			Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, num, num2, b == 2 || b == 3, num3, num4, b == 1 || b == 3, added: true);
		}
	}

	public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Expected O, but got Unknown
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);
		if (!((Object)(object)itemDefinition == (Object)null) && !((Object)(object)itemDefinition2 == (Object)null))
		{
			currencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);
			itemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);
			SellOrder val = new SellOrder();
			val.ShouldPool = false;
			val.itemToSellID = itemToSellID;
			val.itemToSellAmount = itemToSellAmount;
			val.currencyID = currencyToUseID;
			val.currencyAmountPerItem = currencyAmount;
			val.currencyIsBP = bpState == 3 || bpState == 2;
			val.itemToSellIsBP = bpState == 3 || bpState == 1;
			Interface.CallHook("OnAddVendingOffer", (object)this, (object)val);
			sellOrders.sellOrders.Add(val);
			RefreshSellOrderStockLevel(itemDefinition);
			UpdateMapMarker();
			SendNetworkUpdate();
		}
	}

	public void RefreshAndSendNetworkUpdate()
	{
		RefreshSellOrderStockLevel();
		SendNetworkUpdate();
	}

	public void UpdateOrCreateSalesSheet()
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("note");
		PooledList<Item> val = Pool.Get<PooledList<Item>>();
		try
		{
			base.inventory.FindItemsByItemID((List<Item>)(object)val, itemDefinition.itemid);
			Item item = null;
			foreach (Item item4 in (List<Item>)(object)val)
			{
				if (item4.text.Length == 0)
				{
					item = item4;
					break;
				}
			}
			if (item == null)
			{
				ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition("paper");
				Item item2 = base.inventory.FindItemByItemID(itemDefinition2.itemid);
				if (item2 != null)
				{
					item = ItemManager.CreateByItemID(itemDefinition.itemid, 1, 0uL);
					if (!item.MoveToContainer(base.inventory))
					{
						item.Drop(GetDropPosition(), GetDropVelocity());
					}
					item2.UseItem();
				}
			}
			if (item == null)
			{
				return;
			}
			foreach (SellOrder sellOrder in sellOrders.sellOrders)
			{
				ItemDefinition itemDefinition3 = ItemManager.FindItemDefinition(sellOrder.itemToSellID);
				Item item3 = item;
				item3.text = item3.text + itemDefinition3.displayName.translated + "\n";
			}
			item.MarkDirty();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ClearContent()
	{
		if (!(this is NPCVendingMachine))
		{
			shopName = "A Shop";
			nameLastEditedBy = 0uL;
			SendNetworkUpdate();
			UpdateMapMarker();
		}
	}

	protected virtual bool CanShop(BasePlayer bp)
	{
		return true;
	}

	protected virtual bool CanRotate()
	{
		if (!HasAttachedStorageMonitor())
		{
			return !HasAttachedStorageAdaptor();
		}
		return false;
	}

	public bool IsBroadcasting()
	{
		return HasFlag(Flags.Reserved4);
	}

	public bool IsInventoryEmpty()
	{
		return HasFlag(Flags.Reserved1);
	}

	public bool IsVending()
	{
		return HasFlag(Flags.Reserved2);
	}

	public bool PlayerBehind(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(forward, ((Vector3)(ref val)).normalized) <= -0.7f;
	}

	public bool PlayerInfront(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(forward, ((Vector3)(ref val)).normalized) >= 0.7f;
	}

	public virtual bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerBehind(player))
		{
			return OccupiedCheck(player);
		}
		return false;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public virtual string GetTranslationToken()
	{
		return "";
	}

	public bool CanSellOrBuyItem(int itemToSellID, int currencyID)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		if (ItemManager.FindItemDefinition(currencyID).IsAllowed(CurrentEraRestriction))
		{
			return itemDefinition.IsAllowed(CurrentEraRestriction);
		}
		return false;
	}

	[ServerVar(Help = "Wipe the backend stats data on all vending machines. Slow operation.")]
	public static void ClearAllVendingHistory()
	{
		VendingMachine[] array = Object.FindObjectsByType<VendingMachine>((FindObjectsSortMode)0);
		foreach (VendingMachine vendingMachine in array)
		{
			if (!vendingMachine.isClient)
			{
				vendingMachine.ClearPurchaseHistory();
			}
		}
	}

	[ServerVar(Help = "Wipe the backend customer stats data on all vending machines. Slow operation.")]
	public static void ClearAllVendingCustomerHistory()
	{
		VendingMachine[] array = Object.FindObjectsByType<VendingMachine>((FindObjectsSortMode)0);
		foreach (VendingMachine vendingMachine in array)
		{
			if (!vendingMachine.isClient)
			{
				vendingMachine.ClearCustomerHistory();
			}
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SV_RequestLongTermData(RPCMessage msg)
	{
		int seconds = 86400;
		VendingMachineLongTermStats val = Pool.Get<VendingMachineLongTermStats>();
		val.numberOfPurchases = purchaseHistory.Count;
		val.bestSalesHour = GetPeakSaleHourTimestamp(seconds);
		val.uniqueCustomers = GetUniqueCustomers();
		val.repeatCustomers = GetRepeatCustomers();
		val.bestCustomer = GetBestCustomer();
		ClientRPC(RpcTarget.NetworkGroup("CL_ReceiveLongTermData"), val);
		val.Dispose();
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SV_RequestPurchaseData(RPCMessage msg)
	{
		HistoryCategory historyCategory = (HistoryCategory)msg.read.Int32();
		int minutes = msg.read.Int32();
		VendingMachinePurchaseHistoryMessage proto = GetProto(historyCategory, minutes);
		ClientRPC(RpcTarget.NetworkGroup("CL_ReceivePurchaseData"), (int)historyCategory, proto);
		proto.Dispose();
	}

	public void AddPurchaseHistory(int itemId, int amount, int priceId, int price, bool itemIsBp, bool priceIsBp)
	{
		if (purchaseHistory.Count > max_history)
		{
			purchaseHistory.RemoveAt(0);
		}
		purchaseHistory.Add(new PurchaseDetails
		{
			itemId = itemId,
			amount = amount,
			priceId = priceId,
			price = price,
			timestamp = Epoch.Current,
			itemIsBp = itemIsBp,
			priceIsBp = priceIsBp
		});
	}

	public void RegisterCustomer(ulong userId)
	{
		if (uniqueCustomers.ContainsKey(userId))
		{
			uniqueCustomers[userId]++;
		}
		else
		{
			uniqueCustomers.Add(userId, 1);
		}
	}

	public void RemovePurchaseHistory(int index)
	{
		purchaseHistory.RemoveAt(index);
	}

	public void ClearPurchaseHistory()
	{
		purchaseHistory.Clear();
	}

	public void ClearCustomerHistory()
	{
		uniqueCustomers.Clear();
	}

	private VendingMachinePurchaseHistoryMessage GetProto(HistoryCategory category, int minutes)
	{
		if (minutes == 0)
		{
			minutes = 999999;
		}
		VendingMachinePurchaseHistoryMessage val = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		switch (category)
		{
		case HistoryCategory.History:
			val.transactions = GetEntriesProto(GetRecentPurchases(minutes * 60));
			break;
		case HistoryCategory.BestSold:
			val.smallTransactions = GetEntriesProtoSmall(GetBestSoldItems(minutes * 60));
			break;
		case HistoryCategory.MostRevenue:
			val.smallTransactions = GetEntriesProtoSmall(GetMostRevenueGeneratingItems(minutes * 60));
			break;
		}
		return val;
	}

	private List<VendingMachinePurchaseHistoryEntryMessage> GetEntriesProto(List<PurchaseDetails> details)
	{
		List<VendingMachinePurchaseHistoryEntryMessage> list = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
		foreach (PurchaseDetails detail in details)
		{
			list.Add(GetEntryProto(detail));
		}
		return list;
	}

	private List<PurchaseDetails> GetListFromProto(List<VendingMachinePurchaseHistoryEntryMessage> details)
	{
		List<PurchaseDetails> list = new List<PurchaseDetails>();
		foreach (VendingMachinePurchaseHistoryEntryMessage detail in details)
		{
			list.Add(new PurchaseDetails
			{
				itemId = detail.itemID,
				amount = detail.amount,
				priceId = detail.priceID,
				price = detail.price,
				timestamp = detail.dateTime,
				itemIsBp = detail.itemIsBp,
				priceIsBp = detail.priceIsBp
			});
		}
		return list;
	}

	private List<VendingMachinePurchaseHistoryEntrySmallMessage> GetEntriesProtoSmall(List<PurchaseDetails> details)
	{
		List<VendingMachinePurchaseHistoryEntrySmallMessage> list = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
		foreach (PurchaseDetails detail in details)
		{
			list.Add(GetEntryProtoSmall(detail));
		}
		return list;
	}

	private VendingMachinePurchaseHistoryEntryMessage GetEntryProto(PurchaseDetails details)
	{
		VendingMachinePurchaseHistoryEntryMessage obj = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		obj.itemID = details.itemId;
		obj.amount = details.amount;
		obj.priceID = details.priceId;
		obj.price = details.price;
		obj.dateTime = details.timestamp;
		obj.priceIsBp = details.priceIsBp;
		obj.itemIsBp = details.itemIsBp;
		return obj;
	}

	private VendingMachinePurchaseHistoryEntrySmallMessage GetEntryProtoSmall(PurchaseDetails details)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage obj = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		obj.itemID = details.itemId;
		obj.amount = details.amount;
		obj.priceID = details.priceId;
		obj.price = details.price;
		obj.priceIsBp = details.priceIsBp;
		obj.itemIsBp = details.itemIsBp;
		return obj;
	}

	public List<PurchaseDetails> GetRecentPurchases(int seconds)
	{
		int currentTime = Epoch.Current;
		return (from p in purchaseHistory
			where currentTime - p.timestamp <= seconds
			orderby p.timestamp descending
			select p).Take(max_returned).ToList();
	}

	public List<PurchaseDetails> GetBestSoldItems(int seconds)
	{
		int currentTime = Epoch.Current;
		return (from p in (from p in purchaseHistory
				where currentTime - p.timestamp <= seconds
				orderby p.timestamp descending
				select p).Take(max_processed)
			group p by new { p.itemId, p.itemIsBp, p.priceIsBp } into @group
			select new PurchaseDetails
			{
				itemId = @group.Key.itemId,
				amount = @group.Sum((PurchaseDetails p) => p.amount),
				priceId = 0,
				price = 0,
				timestamp = 0,
				itemIsBp = @group.Key.itemIsBp,
				priceIsBp = @group.Key.priceIsBp
			} into p
			orderby p.amount descending
			select p).Take(max_returned).ToList();
	}

	public List<PurchaseDetails> GetMostRevenueGeneratingItems(int seconds)
	{
		int currentTime = Epoch.Current;
		return (from p in (from p in purchaseHistory
				where currentTime - p.timestamp <= seconds
				orderby p.timestamp descending
				select p).Take(max_processed)
			group p by new { p.itemId, p.priceId, p.itemIsBp, p.priceIsBp } into @group
			select new PurchaseDetails
			{
				itemId = @group.Key.itemId,
				amount = @group.Sum((PurchaseDetails p) => p.amount),
				priceId = @group.Key.priceId,
				price = @group.Sum((PurchaseDetails p) => p.price),
				timestamp = 0,
				itemIsBp = @group.Key.itemIsBp,
				priceIsBp = @group.Key.priceIsBp
			} into p
			orderby p.price descending
			select p).Take(max_returned).ToList();
	}

	public long GetPeakSaleHourTimestamp(int seconds)
	{
		int currentTime = Epoch.Current;
		return (from p in (from p in purchaseHistory
				where currentTime - p.timestamp <= seconds
				orderby p.timestamp descending
				select p).Take(max_processed)
			group p by p.timestamp into @group
			select new
			{
				Timestamp = @group.Key,
				TotalSales = @group.Sum((PurchaseDetails p) => p.amount)
			} into s
			orderby s.TotalSales descending
			select s).FirstOrDefault()?.Timestamp ?? (-1);
	}

	public int GetUniqueCustomers()
	{
		return uniqueCustomers.Count;
	}

	public int GetRepeatCustomers()
	{
		return uniqueCustomers.Count((KeyValuePair<ulong, int> c) => c.Value > 1);
	}

	public int GetBestCustomer()
	{
		if (uniqueCustomers.Count == 0)
		{
			return 0;
		}
		return uniqueCustomers.Values.Max();
	}
}


public static class VendingMachineFlags
{
	public const Flags EmptyInv = Flags.Reserved1;

	public const Flags IsVending = Flags.Reserved2;

	public const Flags Broadcasting = Flags.Reserved4;

	public const Flags OutOfStock = Flags.Reserved5;

	public const Flags NoDirectAccess = Flags.Reserved6;
}


private enum HistoryCategory
{
	History,
	BestSold,
	MostRevenue
}


using System;

[Serializable]
public class PurchaseDetails
{
	public int itemId;

	public int amount;

	public int priceId;

	public int price;

	public int timestamp;

	public bool itemIsBp;

	public bool priceIsBp;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Spatial;
using UnityEngine;
using UnityEngine.Assertions;

public class VineMountable : BaseMountable
{
	public struct VinePoint
	{
		public EntityRef<VineSwingingTree> TreeEntity;

		public int PointIndex;

		public VineLaunchPoint Get(bool isServer)
		{
			VineSwingingTree vineSwingingTree = TreeEntity.Get(isServer);
			if ((Object)(object)vineSwingingTree != (Object)null)
			{
				return vineSwingingTree.LaunchPoints[PointIndex];
			}
			return null;
		}

		public void Set(VineLaunchPoint launchPoint)
		{
			TreeEntity.Set(launchPoint.ParentTree);
			PointIndex = launchPoint.Index();
		}

		public VineDestination Save()
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			VineDestination obj = Pool.Get<VineDestination>();
			obj.index = PointIndex;
			obj.targetTree = TreeEntity.uid;
			return obj;
		}

		public void Load(VineDestination destination)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			PointIndex = destination.index;
			TreeEntity.uid = destination.targetTree;
		}
	}

	public float moveSpeed;

	[Header("Rotation Settings")]
	public float rotationSpeed = 0.5f;

	public float descendSpeed = 5f;

	public Vector3 WorldSpaceAnchorPoint;

	private List<VinePoint> destinations = new List<VinePoint>();

	private VinePoint origin;

	public VinePoint currentLocation;

	public const Flags Away = Flags.Reserved1;

	public const Flags Descending = Flags.Reserved2;

	public const Flags Finished = Flags.Reserved3;

	public ViewModel VineViewModel;

	public float DismountViewmodelHoldTime = 0.2f;

	public GameObjectRef VineWorldModel;

	public Transform[] VineDirectionArrows;

	public CapsuleCollider ThisCollider;

	[ServerVar]
	public static bool allowChaining = true;

	private static readonly int DescendHash = Animator.StringToHash("descend");

	private static readonly int VineDescendingHash = Animator.StringToHash("vineDescending");

	private VineLaunchPoint activeOriginPoint;

	private VineLaunchPoint activeDestinationPoint;

	private float currentTime;

	private Vector3 lastPosition;

	private bool isDescending;

	private VineMountable chainTarget;

	private Vector3 lastValidLocation = Vector3.zero;

	private TimeSince lastValidLocationTime;

	private Action processMovementAction;

	private Action syncVineAtEndAction;

	public int DestinationCount => destinations.Count;

	public static Grid<VineMountable> pointGrid { get; private set; } = new Grid<VineMountable>(32, 8096f);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VineMountable.OnRpcMessage", 0);
		try
		{
			if (rpc == 2800581258u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_Descend "));
				}
				TimeWarning val2 = TimeWarning.New("SV_Descend", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2800581258u, "SV_Descend", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_Descend(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_Descend");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2867502127u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_Swing "));
				}
				TimeWarning val2 = TimeWarning.New("SV_Swing", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2867502127u, "SV_Swing", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SV_Swing(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SV_Swing");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static void NotifyVinesLaunchSiteRemoved(VineLaunchPoint point)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		PooledList<VineMountable> val = Pool.Get<PooledList<VineMountable>>();
		try
		{
			Vector3 position = ((Component)point).transform.position;
			pointGrid.Query<VineMountable>(position.x, position.z, 100f, (List<VineMountable>)(object)val);
			foreach (VineMountable item in (List<VineMountable>)(object)val)
			{
				if ((Object)(object)item.origin.Get(isServer: true) == (Object)(object)point)
				{
					item.Kill();
					continue;
				}
				for (int i = 0; i < item.destinations.Count; i++)
				{
					if ((Object)(object)item.destinations[i].Get(isServer: true) == (Object)(object)point)
					{
						item.destinations.RemoveAt(i);
						if (item.HasFlag(Flags.Reserved1) && item.destinations.Count > 0)
						{
							item.Swing(null, shouldMount: false);
						}
						i--;
					}
				}
				if (item.destinations.Count == 0)
				{
					item.Kill();
				}
				else
				{
					item.SendNetworkUpdate();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		pointGrid.Add(this, ((Component)this).transform.position.x, ((Component)this).transform.position.z);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		VineLaunchPoint vineLaunchPoint = origin.Get(isServer: true);
		if ((Object)(object)vineLaunchPoint != (Object)null)
		{
			vineLaunchPoint.OnVineKilled();
		}
		pointGrid.Remove(this);
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerServerInput(inputState, player);
		chainTarget = null;
		if (!allowChaining || isDescending || !(currentTime > 0.5f) || !((Object)(object)activeDestinationPoint != (Object)null) || !inputState.IsDown(BUTTON.USE))
		{
			return;
		}
		PooledList<VineMountable> val = Pool.Get<PooledList<VineMountable>>();
		try
		{
			Vector3 position = ((Component)activeDestinationPoint).transform.position;
			pointGrid.Query<VineMountable>(position.x, position.z, 5f, (List<VineMountable>)(object)val);
			foreach (VineMountable item in (List<VineMountable>)(object)val)
			{
				if (item.isServer && (Object)(object)item != (Object)(object)this && item.Distance(position) < 5f && (Object)(object)item.GetTargetDestination(((Component)this).transform.position, ((Component)this).transform.forward, out var foundAngle) != (Object)null && foundAngle < 90f)
				{
					chainTarget = item;
					break;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool AttackedByPlayer(BasePlayer bp)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (!Server.allowVineSwinging)
		{
			return false;
		}
		float num = 2f;
		if ((Object)(object)bp != (Object)null)
		{
			if (bp.Distance((BaseEntity)this) < 2f)
			{
				return false;
			}
			if (HasFlag(Flags.Reserved1))
			{
				VineLaunchPoint vineLaunchPoint = origin.Get(base.isServer);
				if ((Object)(object)vineLaunchPoint != (Object)null && bp.Distance(((Component)vineLaunchPoint).transform.position) < num)
				{
					Swing(null, shouldMount: false);
					return true;
				}
			}
			else
			{
				foreach (VinePoint destination in destinations)
				{
					VineLaunchPoint vineLaunchPoint2 = destination.Get(isServer: true);
					if ((Object)(object)vineLaunchPoint2 != (Object)null && bp.Distance(((Component)vineLaunchPoint2).transform.position) < num)
					{
						Swing(null, shouldMount: false, vineLaunchPoint2);
						return true;
					}
				}
			}
		}
		return false;
	}

	private void ProcessMovement()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0310: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_039e: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03db: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		lastPosition = ((Component)this).transform.position;
		VineLaunchPoint vineLaunchPoint = activeDestinationPoint;
		VineLaunchPoint vineLaunchPoint2 = activeOriginPoint;
		if (HasFlag(Flags.Reserved3))
		{
			SetFlag(Flags.Reserved3, b: false);
		}
		currentTime = Mathf.MoveTowards(currentTime, 1f, moveSpeed * Time.deltaTime);
		float time = Mathf.SmoothStep(0f, 1f, currentTime);
		if (isDescending && (Object)(object)vineLaunchPoint2 != (Object)null)
		{
			if (GamePhysics.Trace(new Ray(((Component)this).transform.position, -Vector3.up), 0.2f, out var hitInfo, 50f, 1218519297, (QueryTriggerInteraction)0, this) && ((RaycastHit)(ref hitInfo)).distance < 1.5f && !(hitInfo.GetEntity() is VineMountable))
			{
				if (Vector3.Distance(((Component)this).transform.position, ((Component)vineLaunchPoint2).transform.position) < 2f)
				{
					((Component)this).transform.position = ((Component)vineLaunchPoint2).transform.position;
				}
				isDescending = false;
				SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
				SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
				OnArrived(null);
				if (!HasFlag(Flags.Reserved3))
				{
					SetFlag(Flags.Reserved3, b: true);
				}
				SendNetworkUpdate();
				((Component)this).transform.position = ((Component)vineLaunchPoint2).transform.position;
			}
			else
			{
				((Component)this).transform.Translate(-Vector3.up * descendSpeed * Time.deltaTime);
			}
			return;
		}
		if ((Object)(object)vineLaunchPoint == (Object)null || (Object)(object)vineLaunchPoint2 == (Object)null)
		{
			DismountAllPlayers();
			VineLaunchPoint vineLaunchPoint3 = origin.Get(isServer: true);
			if ((Object)(object)vineLaunchPoint3 != (Object)null)
			{
				OnArrived(vineLaunchPoint3);
			}
			return;
		}
		if (TimeSince.op_Implicit(lastValidLocationTime) > 0.1f)
		{
			lastValidLocation = ((Component)this).transform.position;
			lastValidLocationTime = TimeSince.op_Implicit(0f);
		}
		Vector3 swingPointAtTime = vineLaunchPoint2.GetSwingPointAtTime(time, vineLaunchPoint);
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = swingPointAtTime - position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		PooledList<RaycastHit> val2 = Pool.Get<PooledList<RaycastHit>>();
		try
		{
			float num = ThisCollider.height * 0.5f;
			Vector3 position2 = Vector3Ex.WithY(swingPointAtTime, swingPointAtTime.y - num);
			Vector3 position3 = Vector3Ex.WithY(swingPointAtTime, swingPointAtTime.y + num);
			GamePhysics.CapsuleSweep(position2, position3, ThisCollider.radius, normalized, Vector3.Distance(((Component)this).transform.position, swingPointAtTime) * 2f, (List<RaycastHit>)(object)val2, 2097152, (QueryTriggerInteraction)1);
			if (((List<RaycastHit>)(object)val2).Count > 0)
			{
				if (Vector3.Distance(lastValidLocation, ((Component)vineLaunchPoint2).transform.position) < 2f)
				{
					lastValidLocation = ((Component)vineLaunchPoint2).transform.position;
				}
				((Component)this).transform.position = lastValidLocation;
				DismountAllPlayers();
				return;
			}
			((Component)this).transform.position = swingPointAtTime;
			Vector3 val3 = swingPointAtTime - lastPosition;
			val = ((Vector3)(ref val3)).normalized;
			Quaternion val4 = ((!(((Vector3)(ref val)).sqrMagnitude > Mathf.Epsilon)) ? ((Component)this).transform.rotation : Quaternion.LookRotation(((Vector3)(ref val3)).normalized, Vector3.up));
			float num2 = Mathf.Abs((((Component)this).transform.position.y - lastPosition.y) / Time.deltaTime);
			float num3 = Mathf.Clamp01(Mathf.InverseLerp(0f, 6f, num2));
			Quaternion rotation = ((Component)this).transform.rotation;
			Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
			float num4 = Mathf.Clamp(((Quaternion)(ref val4)).eulerAngles.y, 0f - num3, num3);
			Quaternion val5 = Quaternion.Euler(eulerAngles.x, num4, eulerAngles.z);
			Quaternion rotation2 = Quaternion.Slerp(((Component)this).transform.rotation, val5 * val4, Time.deltaTime * rotationSpeed);
			((Component)this).transform.rotation = rotation2;
			if (currentTime >= 1f)
			{
				((Component)this).transform.position = vineLaunchPoint2.GetSwingPointAtTime(1f, vineLaunchPoint);
				OnArrived(vineLaunchPoint);
				if (!HasFlag(Flags.Reserved3))
				{
					SetFlag(Flags.Reserved3, b: true);
				}
				SendNetworkUpdate();
			}
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	public void Initialise(VineLaunchPoint originPoint, List<VineLaunchPoint> destinationPoints, Vector3 anchor)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		origin.Set(originPoint);
		currentLocation.Set(originPoint);
		destinations.Clear();
		foreach (VineLaunchPoint destinationPoint in destinationPoints)
		{
			VinePoint item = default(VinePoint);
			item.Set(destinationPoint);
			destinations.Add(item);
		}
		WorldSpaceAnchorPoint = anchor;
		Vector3 val = ((Component)destinationPoints[0]).transform.position - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		((Component)this).transform.rotation = Quaternion.LookRotation(normalized, Vector3.up);
		((Component)this).transform.localEulerAngles = Vector3Ex.WithX(((Component)this).transform.localEulerAngles, 0f);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.vineMountable = Pool.Get<VineMountable>();
		info.msg.vineMountable.anchorPoint = WorldSpaceAnchorPoint;
		info.msg.vineMountable.originPoint = origin.Save();
		info.msg.vineMountable.currentLocation = currentLocation.Save();
		info.msg.vineMountable.destinations = Pool.Get<List<VineDestination>>();
		foreach (VinePoint destination in destinations)
		{
			info.msg.vineMountable.destinations.Add(destination.Save());
		}
	}

	public override float MaxVelocity()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (activeOriginPoint.IsUnityNull() || activeDestinationPoint.IsUnityNull())
		{
			return 1f;
		}
		float num = Vector3.Distance(((Component)activeOriginPoint).transform.position, ((Component)activeDestinationPoint).transform.position);
		float num2 = ((moveSpeed > 0f) ? (1f / moveSpeed) : 1f);
		return Mathf.Clamp(num / num2, 1f, 50f);
	}

	private float GetMaxVineDistance(Vector3 origin)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		foreach (VinePoint destination in destinations)
		{
			VineLaunchPoint vineLaunchPoint = destination.Get(base.isServer);
			if ((Object)(object)vineLaunchPoint != (Object)null)
			{
				num = Mathf.Max(Vector3.Distance(((Component)vineLaunchPoint).transform.position, origin), num);
			}
		}
		if (num == 0f)
		{
			Debug.Log((object)(" there are " + destinations.Count + " destinations"));
			foreach (VinePoint destination2 in destinations)
			{
				VineLaunchPoint vineLaunchPoint2 = destination2.Get(isServer: false);
				if ((Object)(object)vineLaunchPoint2 != (Object)null)
				{
					float num2 = Vector3.Distance(((Component)vineLaunchPoint2).transform.position, origin);
					Vector3 val = ((Component)vineLaunchPoint2).transform.position;
					string? text = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
					val = origin;
					Debug.LogWarning((object)("Detected broken distance between " + text + " and origin " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString()));
					val = ((Component)this).transform.position;
					Debug.LogWarning((object)("home " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString()));
					Debug.LogWarning((object)("dist is  " + num2));
				}
			}
			return 5f;
		}
		return num;
	}

	public override void PostServerLoad()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.PostServerLoad();
		VineLaunchPoint vineLaunchPoint = origin.Get(base.isServer);
		if ((Object)(object)vineLaunchPoint != (Object)null)
		{
			((Component)this).transform.position = ((Component)vineLaunchPoint).transform.position;
			SetFlag(Flags.Reserved1, b: false);
		}
	}

	private void Descend(BasePlayer forPlayer)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)forPlayer == (Object)null) && !forPlayer.isMounted)
		{
			isDescending = true;
			activeOriginPoint = origin.Get(isServer: true);
			((Component)this).transform.forward = Vector3Ex.WithY(forPlayer.eyes.BodyForward(), 0f);
			currentTime = 0f;
			MountPlayer(forPlayer);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Reserved2, b: true);
		}
	}

	private void Swing(BasePlayer forPlayer, bool shouldMount, VineLaunchPoint overridePoint = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = (((Object)(object)forPlayer != (Object)null) ? forPlayer.eyes.BodyForward() : Vector3.forward);
		Vector3 playerPos = (((Object)(object)forPlayer != (Object)null) ? ((Component)forPlayer).transform.position : ((Component)this).transform.position);
		VineLaunchPoint vineLaunchPoint = null;
		vineLaunchPoint = (HasFlag(Flags.Reserved1) ? origin.Get(base.isServer) : ((!((Object)(object)overridePoint != (Object)null)) ? GetTargetDestination(playerPos, forward, out var _) : overridePoint));
		if ((Object)(object)vineLaunchPoint == (Object)null)
		{
			Debug.Log((object)"Could not find valid vine launch destination, should not happen");
			return;
		}
		Vector3 val = ((Component)vineLaunchPoint).transform.position - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		((Component)this).transform.rotation = Quaternion.LookRotation(normalized, Vector3.up);
		activeOriginPoint = currentLocation.Get(base.isServer);
		activeDestinationPoint = vineLaunchPoint;
		if ((Object)(object)forPlayer != (Object)null)
		{
			lastPosition = ((Component)forPlayer).transform.position;
			if (shouldMount)
			{
				MountPlayer(forPlayer);
			}
		}
		lastValidLocation = ((Component)this).transform.position;
		lastValidLocationTime = TimeSince.op_Implicit(0f);
		currentTime = 0f;
		SetFlag(Flags.Reserved1, !HasFlag(Flags.Reserved1));
		currentLocation.Set(vineLaunchPoint);
		SetFlag(Flags.On, b: true);
		SetFlag(Flags.Reserved2, b: false);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void SV_Swing(RPCMessage msg)
	{
		if (!IsMounted() && Server.allowVineSwinging)
		{
			BasePlayer player = msg.player;
			bool flag = msg.read.Bool();
			if (!flag || !((Object)(object)player != (Object)null) || !player.isMounted)
			{
				Swing(player, flag);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void SV_Descend(RPCMessage msg)
	{
		if (!IsMounted() && Server.allowVineSwinging)
		{
			BasePlayer player = msg.player;
			Descend(player);
		}
	}

	private void OnArrived(VineLaunchPoint point)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.forward = -((Component)this).transform.forward;
		((Component)this).transform.localEulerAngles = Vector3Ex.WithX(((Component)this).transform.localEulerAngles, 0f);
		SetFlag(Flags.On, b: false);
		if ((Object)(object)point != (Object)null && point.FindVacantArrivalPoint(this, out var worldPos))
		{
			((Component)this).transform.position = worldPos;
		}
		BasePlayer mounted = GetMounted();
		DismountAllPlayers();
		if ((Object)(object)chainTarget != (Object)null)
		{
			chainTarget.Swing(mounted, shouldMount: true);
		}
	}

	public void Highlight(BasePlayer forPlayer)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)origin.Get(base.isServer)).transform.position;
		foreach (VinePoint destination in destinations)
		{
			Vector3 position2 = ((Component)destination.Get(base.isServer)).transform.position;
			forPlayer.SendConsoleCommand("ddraw.arrow", "60", Color.red, position, position2, 25, 0, 0);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.vineMountable == null)
		{
			return;
		}
		WorldSpaceAnchorPoint = info.msg.vineMountable.anchorPoint;
		origin.Load(info.msg.vineMountable.originPoint);
		currentLocation.Load(info.msg.vineMountable.currentLocation);
		destinations.Clear();
		foreach (VineDestination destination in info.msg.vineMountable.destinations)
		{
			VinePoint item = default(VinePoint);
			item.Load(destination);
			destinations.Add(item);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!base.isServer)
		{
			return;
		}
		if (processMovementAction == null)
		{
			processMovementAction = ProcessMovement;
		}
		bool flag = IsOn();
		bool flag2 = ((FacepunchBehaviour)this).IsInvoking(processMovementAction);
		if (flag != flag2)
		{
			if (flag)
			{
				((FacepunchBehaviour)this).InvokeRepeating(processMovementAction, 0f, 0f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke(processMovementAction);
			}
		}
	}

	private VineLaunchPoint GetTargetDestination(Vector3 playerPos, Vector3 forward, out float foundAngle)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		VineLaunchPoint result = null;
		forward.y = 0f;
		foreach (VinePoint destination in destinations)
		{
			VineLaunchPoint vineLaunchPoint = destination.Get(base.isServer);
			if ((Object)(object)vineLaunchPoint != (Object)null)
			{
				Vector3 val = forward;
				Vector3 val2 = ((Component)vineLaunchPoint).transform.position - playerPos;
				float num2 = Vector3.Angle(val, Vector3Ex.WithY(((Vector3)(ref val2)).normalized, 0f));
				if (num2 < num)
				{
					result = vineLaunchPoint;
					num = num2;
				}
			}
		}
		foundAngle = num;
		return result;
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public struct VinePoint
{
	public EntityRef<VineSwingingTree> TreeEntity;

	public int PointIndex;

	public VineLaunchPoint Get(bool isServer)
	{
		VineSwingingTree vineSwingingTree = TreeEntity.Get(isServer);
		if ((Object)(object)vineSwingingTree != (Object)null)
		{
			return vineSwingingTree.LaunchPoints[PointIndex];
		}
		return null;
	}

	public void Set(VineLaunchPoint launchPoint)
	{
		TreeEntity.Set(launchPoint.ParentTree);
		PointIndex = launchPoint.Index();
	}

	public VineDestination Save()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		VineDestination obj = Pool.Get<VineDestination>();
		obj.index = PointIndex;
		obj.targetTree = TreeEntity.uid;
		return obj;
	}

	public void Load(VineDestination destination)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		PointIndex = destination.index;
		TreeEntity.uid = destination.targetTree;
	}
}


using System;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class WallpaperPlanner : Planner
{
	private ulong wallSkinID;

	private ulong flooringSkinID;

	private ulong ceilingSkinID;

	private WallpaperSettings.Category currentMode = WallpaperSettings.Category.Wall;

	private static WallpaperSettings _settings;

	public GameObjectRef SkinSelectPanel;

	public GameObject[] thirdPersonModels;

	public static WallpaperSettings Settings
	{
		get
		{
			if (_settings == null)
			{
				_settings = FileSystem.Load<WallpaperSettings>("Assets/Prefabs/Wallpaper/Wallpaper Settings.asset", true);
			}
			return _settings;
		}
	}

	public ItemAmount placementPrice => Settings.PlacementPrice;

	public override bool isTypeDeployable => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WallpaperPlanner.OnRpcMessage", 0);
		try
		{
			if (rpc == 4026651916u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_ChangeWallpaperToolSkin "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_ChangeWallpaperToolSkin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4026651916u, "SERVER_ChangeWallpaperToolSkin", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(4026651916u, "SERVER_ChangeWallpaperToolSkin", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(4026651916u, "SERVER_ChangeWallpaperToolSkin", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_ChangeWallpaperToolSkin(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_ChangeWallpaperToolSkin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 236604960 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_SwitchMode "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_SwitchMode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(236604960u, "SERVER_SwitchMode", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(236604960u, "SERVER_SwitchMode", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_SwitchMode(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_SwitchMode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override Deployable GetDeployable(NetworkableId entityId)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (((NetworkableId)(ref entityId)).IsValid)
		{
			BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityId) as BaseEntity;
			return Settings.GetDeployable(baseEntity as BuildingBlock);
		}
		return null;
	}

	public ulong GetSkinIDForCategory(WallpaperSettings.Category category)
	{
		return category switch
		{
			WallpaperSettings.Category.Wall => wallSkinID, 
			WallpaperSettings.Category.Floor => flooringSkinID, 
			WallpaperSettings.Category.Ceiling => ceilingSkinID, 
			_ => 0uL, 
		};
	}

	public override BaseEntity DoBuild(Construction.Target target, Construction component)
	{
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return null;
		}
		if (target.entity is BuildingBlock buildingBlock)
		{
			int side = ((!target.socket.socketName.EndsWith("1")) ? 1 : 0);
			if (!buildingBlock.CanSeeWallpaperSocket(GetOwnerPlayer(), side))
			{
				return null;
			}
			bool flag = buildingBlock.HasWallpaper(side);
			if (flag && buildingBlock.GetWallpaperSkin(side) == skinID)
			{
				float y = component.rotationAmount.y;
				int num = Mathf.RoundToInt(target.rotation.y / y) * (int)y % 360;
				int num2 = Mathf.RoundToInt(buildingBlock.GetWallpaperRotation(side) / y) * (int)y % 360;
				if (num == num2 || (num + 180) % 360 == num2)
				{
					return null;
				}
			}
			if (!flag)
			{
				PayForPlacement(ownerPlayer, component);
			}
			WallpaperSettings.Category category = Settings.GetCategory(buildingBlock, side);
			ulong skinIDForCategory = GetSkinIDForCategory(category);
			buildingBlock.SetWallpaper(skinIDForCategory, side, target.rotation.y);
			if (component.deployable.placeEffect.isValid)
			{
				Effect.server.Run(component.deployable.placeEffect.resourcePath, ((Component)buildingBlock).transform.TransformPoint(target.socket.worldPosition), ((Component)buildingBlock).transform.up);
			}
			Analytics.Azure.OnWallpaperPlaced(ownerPlayer, buildingBlock, skinID, side, reskin: false);
		}
		return null;
	}

	public override void PayForPlacement(BasePlayer player, Construction component)
	{
		if (Interface.CallHook("OnPayForPlacement", (object)player, (object)this, (object)component) == null && (!player.IsInCreativeMode || !Creative.freeBuild))
		{
			player.inventory.Take(null, placementPrice.itemid, (int)placementPrice.amount);
			player.Command("note.inv", placementPrice.itemid, (int)placementPrice.amount * -1);
		}
	}

	public override bool CanAffordToPlace(Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return false;
		}
		if (ownerPlayer.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		if ((float)ownerPlayer.inventory.GetAmount(placementPrice.itemid) < placementPrice.amount)
		{
			return false;
		}
		return true;
	}

	protected override void GetConstructionCost(ItemAmountList list, Construction component)
	{
		list.amount.Clear();
		list.itemID.Clear();
		list.itemID.Add(placementPrice.itemid);
		list.amount.Add((int)placementPrice.amount);
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	private void SERVER_ChangeWallpaperToolSkin(RPCMessage msg)
	{
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null || (Object)(object)player != (Object)(object)GetOwnerPlayer() || num2 < 0 || num2 > 3)
		{
			return;
		}
		bool unlockAllSkins = player.UnlockAllSkins;
		if (num == 0 || unlockAllSkins || player.blueprints.CheckSkinOwnership(num, player.userID))
		{
			ulong num3 = ItemDefinition.FindSkin(WallpaperSettings.GetItemDefForCategory((WallpaperSettings.Category)num2).itemid, num);
			switch ((WallpaperSettings.Category)num2)
			{
			case WallpaperSettings.Category.Wall:
				wallSkinID = num3;
				break;
			case WallpaperSettings.Category.Floor:
				flooringSkinID = num3;
				break;
			case WallpaperSettings.Category.Ceiling:
				ceilingSkinID = num3;
				break;
			}
			skinID = num3;
			SendNetworkUpdate();
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_ChangeSkin"), skinID, (int)currentMode);
		}
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(10uL)]
	public void SERVER_SwitchMode(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null || (Object)(object)player != (Object)(object)GetOwnerPlayer())
		{
			return;
		}
		int num = msg.read.Int32();
		if (currentMode != (WallpaperSettings.Category)num && num >= 0 && num <= 3)
		{
			currentMode = (WallpaperSettings.Category)num;
			switch (currentMode)
			{
			case WallpaperSettings.Category.Wall:
				skinID = wallSkinID;
				break;
			case WallpaperSettings.Category.Floor:
				skinID = flooringSkinID;
				break;
			case WallpaperSettings.Category.Ceiling:
				skinID = ceilingSkinID;
				break;
			}
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_SwitchMode"), skinID, (int)currentMode);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.wallpaperTool == null)
		{
			info.msg.wallpaperTool = Pool.Get<WallpaperTool>();
			info.msg.wallpaperTool.wallSkinID = wallSkinID;
			info.msg.wallpaperTool.flooringSkinID = flooringSkinID;
			info.msg.wallpaperTool.ceilingSkinID = ceilingSkinID;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.wallpaperTool != null)
		{
			wallSkinID = info.msg.wallpaperTool.wallSkinID;
			flooringSkinID = info.msg.wallpaperTool.flooringSkinID;
			ceilingSkinID = info.msg.wallpaperTool.ceilingSkinID;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust.UI;
using UnityEngine;
using UnityEngine.Assertions;

public class WantedPoster : DecayEntity, ISignage, IUGCBrowserEntity, ILOD, IServerFileReceiver
{
	public uint imageCrc;

	public ulong playerId;

	public string playerName;

	public MeshRenderer PhotoImage;

	public RustText WantedName;

	public GameObjectRef AssignDialog;

	public const Flags HasTarget = Flags.Reserved1;

	public uiPlayerPreview.EffectMode EffectMode = uiPlayerPreview.EffectMode.Polaroid;

	public uint[] GetContentCRCs
	{
		get
		{
			if (imageCrc == 0)
			{
				return null;
			}
			return new uint[1] { imageCrc };
		}
	}

	public UGCType ContentType => UGCType.ImageJpg;

	public List<ulong> EditingHistory { get; } = new List<ulong>();

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public Vector2i TextureSize => new Vector2i(1024, 1024);

	public int TextureCount => 1;

	public NetworkableId NetworkID => net.ID;

	public FileStorage.Type FileType => FileStorage.Type.jpg;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WantedPoster.OnRpcMessage", 0);
		try
		{
			if (rpc == 2419123501u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearPlayer "));
				}
				TimeWarning val2 = TimeWarning.New("ClearPlayer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2419123501u, "ClearPlayer", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2419123501u, "ClearPlayer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ClearPlayer(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ClearPlayer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 657465493 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdatePoster "));
				}
				TimeWarning val2 = TimeWarning.New("UpdatePoster", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(657465493u, "UpdatePoster", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(657465493u, "UpdatePoster", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							UpdatePoster(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in UpdatePoster");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	private void UpdatePoster(RPCMessage msg)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null || !CanUpdateSign(msg.player))
		{
			return;
		}
		ulong num = msg.read.UInt64();
		string text = msg.read.String(256, false);
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		playerId = num;
		playerName = text;
		SetFlag(Flags.Reserved1, b: true);
		if (array == null)
		{
			if (imageCrc != 0)
			{
				FileStorage.server.RemoveExact(imageCrc, FileType, net.ID, 0u);
			}
			imageCrc = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidJPG(array, 1024, 1024))
			{
				return;
			}
			if (imageCrc != 0)
			{
				FileStorage.server.RemoveExact(imageCrc, FileType, net.ID, 0u);
			}
			imageCrc = FileStorage.server.Store(array, FileType, net.ID);
		}
		SendNetworkUpdate();
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	private void ClearPlayer(RPCMessage msg)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)msg.player == (Object)null) && CanUpdateSign(msg.player))
		{
			playerId = 0uL;
			playerName = string.Empty;
			SetFlag(Flags.Reserved1, b: false);
			if (imageCrc != 0)
			{
				FileStorage.server.RemoveExact(imageCrc, FileType, net.ID, 0u);
				imageCrc = 0u;
			}
			SendNetworkUpdate();
		}
	}

	public void SetTextureCRCs(uint[] crcs)
	{
		imageCrc = crcs[0];
		SendNetworkUpdate();
	}

	public void ClearContent()
	{
		imageCrc = 0u;
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.wantedPoster = Pool.Get<WantedPoster>();
		info.msg.wantedPoster.imageCrc = imageCrc;
		info.msg.wantedPoster.playerId = playerId;
		info.msg.wantedPoster.playerName = playerName;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.wantedPoster != null)
		{
			imageCrc = info.msg.wantedPoster.imageCrc;
			playerName = info.msg.wantedPoster.playerName;
			playerId = info.msg.wantedPoster.playerId;
		}
	}

	public bool CanUpdateSign(BasePlayer player)
	{
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

	public uint[] GetTextureCRCs()
	{
		return new uint[1] { imageCrc };
	}
}


using System;
using Network;
using UnityEngine;

public class WaterInflatable : BaseMountable, IPoolVehicle, INotifyTrigger
{
	private enum PaddleDirection
	{
		Forward,
		Left,
		Right,
		Back
	}

	public Transform centerOfMass;

	public float forwardPushForce = 5f;

	public float rearPushForce = 5f;

	public float rotationForce = 5f;

	public float maxSpeed = 3f;

	public float maxPaddleFrequency = 0.5f;

	public SoundDefinition paddleSfx;

	public SoundDefinition smallPlayerMovementSound;

	public SoundDefinition largePlayerMovementSound;

	public BlendedSoundLoops waterLoops;

	public float waterSoundSpeedDivisor = 1f;

	public float additiveDownhillVelocity;

	public GameObjectRef handSplashForwardEffect;

	public GameObjectRef handSplashBackEffect;

	public GameObjectRef footSplashEffect;

	public float animationLerpSpeed = 1f;

	public Transform smoothedEyePosition;

	public float smoothedEyeSpeed = 1f;

	public Buoyancy buoyancy;

	public bool driftTowardsIsland;

	public GameObjectRef mountEffect;

	[Range(0f, 1f)]
	public float handSplashOffset = 1f;

	public float velocitySplashMultiplier = 4f;

	public Vector3 modifyEyeOffset = Vector3.zero;

	[Range(0f, 1f)]
	public float inheritVelocityMultiplier;

	private TimeSince lastPaddle;

	public ParticleSystem[] movingParticleSystems;

	public float movingParticlesThreshold = 0.0005f;

	public Transform headSpaceCheckPosition;

	public float headSpaceCheckRadius = 0.4f;

	private TimeSince landFacingCheck;

	private bool isFacingLand;

	private float landPushAcceleration;

	private TimeSince inPoolCheck;

	private bool isInPool;

	private Vector3 lastPos = Vector3.zero;

	private Vector3 lastClipCheckPosition;

	private bool forceClippingCheck;

	private bool prevSleeping;

	public override bool IsSummerDlcVehicle => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WaterInflatable.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.centerOfMass = centerOfMass.localPosition;
		prevSleeping = false;
		((FacepunchBehaviour)this).InvokeRandomized((Action)LowPriorityCheck, 0f, 5f, 2.5f);
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		base.OnDeployed(parent, deployedBy, fromItem);
		if ((Object)(object)deployedBy != (Object)null)
		{
			Vector3 estimatedVelocity = deployedBy.estimatedVelocity;
			float num = Vector3.Dot(((Component)this).transform.forward, ((Vector3)(ref estimatedVelocity)).normalized);
			Vector3 val = Vector3.Lerp(Vector3.zero, estimatedVelocity, Mathf.Clamp(num, 0f, 1f));
			val *= inheritVelocityMultiplier;
			rigidBody.AddForce(val, (ForceMode)2);
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterInflatable.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			bool flag = rigidBody.IsSleeping();
			if (prevSleeping && !flag && (Object)(object)buoyancy != (Object)null)
			{
				buoyancy.Wake();
			}
			prevSleeping = flag;
			Vector3 velocity = rigidBody.velocity;
			if (((Vector3)(ref velocity)).magnitude > maxSpeed)
			{
				rigidBody.velocity = Vector3.ClampMagnitude(rigidBody.velocity, maxSpeed);
			}
			if (!AnyMounted() || !((Object)(object)headSpaceCheckPosition != (Object)null))
			{
				return;
			}
			Vector3 position = ((Component)this).transform.position;
			if (!forceClippingCheck && !(Vector3.Distance(position, lastClipCheckPosition) > headSpaceCheckRadius * 0.5f))
			{
				return;
			}
			forceClippingCheck = false;
			if (GamePhysics.CheckSphere(headSpaceCheckPosition.position, headSpaceCheckRadius, 1218511105, (QueryTriggerInteraction)1))
			{
				if (!GetDismountPosition(GetMounted(), out var _))
				{
					((Component)this).transform.position = lastClipCheckPosition;
				}
				DismountAllPlayers();
			}
			lastClipCheckPosition = position;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void LowPriorityCheck()
	{
		buoyancy.LowPriorityCheck(AnyMounted());
	}

	public override void OnPlayerMounted()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.OnPlayerMounted();
		lastPos = ((Component)this).transform.position;
		forceClippingCheck = true;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerServerInput(inputState, player);
		if (Vector3.Dot(((Component)this).transform.up, Vector3.up) < 0.1f)
		{
			DismountAllPlayers();
		}
		else
		{
			if (TimeSince.op_Implicit(lastPaddle) < maxPaddleFrequency || ((Object)(object)buoyancy != (Object)null && IsOutOfWaterServer()))
			{
				return;
			}
			if ((Object)(object)player.GetHeldEntity() == (Object)null)
			{
				if (inputState.IsDown(BUTTON.FORWARD))
				{
					Vector3 velocity = rigidBody.velocity;
					if (((Vector3)(ref velocity)).magnitude < maxSpeed)
					{
						rigidBody.AddForce(((Component)this).transform.forward * forwardPushForce, (ForceMode)1);
					}
					rigidBody.angularVelocity = Vector3.Lerp(rigidBody.angularVelocity, ((Component)this).transform.forward, 0.5f);
					lastPaddle = TimeSince.op_Implicit(0f);
					ClientRPC(RpcTarget.NetworkGroup("OnPaddled"), 0);
				}
				if (inputState.IsDown(BUTTON.BACKWARD))
				{
					rigidBody.AddForce(-((Component)this).transform.forward * rearPushForce, (ForceMode)1);
					rigidBody.angularVelocity = Vector3.Lerp(rigidBody.angularVelocity, -((Component)this).transform.forward, 0.5f);
					lastPaddle = TimeSince.op_Implicit(0f);
					ClientRPC(RpcTarget.NetworkGroup("OnPaddled"), 3);
				}
				if (inputState.IsDown(BUTTON.LEFT))
				{
					PaddleTurn(PaddleDirection.Left);
				}
				if (inputState.IsDown(BUTTON.RIGHT))
				{
					PaddleTurn(PaddleDirection.Right);
				}
			}
			if (TimeSince.op_Implicit(inPoolCheck) > 2f)
			{
				isInPool = IsInWaterVolume(((Component)this).transform.position, out var natural) && !natural;
				inPoolCheck = TimeSince.op_Implicit(0f);
			}
			if (additiveDownhillVelocity > 0f && !isInPool)
			{
				Vector3 val = ((Component)this).transform.TransformPoint(Vector3.forward);
				Vector3 position = ((Component)this).transform.position;
				if (val.y + 0.05f < position.y)
				{
					float num = additiveDownhillVelocity * (position.y - val.y);
					rigidBody.AddForce(num * Time.fixedDeltaTime * ((Component)this).transform.forward, (ForceMode)5);
				}
				Vector3 velocity2 = rigidBody.velocity;
				rigidBody.velocity = Vector3.Lerp(velocity2, ((Component)this).transform.forward * ((Vector3)(ref velocity2)).magnitude, 0.4f);
			}
			if (driftTowardsIsland && TimeSince.op_Implicit(landFacingCheck) > 2f && !isInPool)
			{
				isFacingLand = false;
				landFacingCheck = TimeSince.op_Implicit(0f);
				Vector3 position2 = ((Component)this).transform.position;
				if (!WaterResource.IsFreshWater(position2))
				{
					int num2 = 5;
					Vector3 forward = ((Component)this).transform.forward;
					forward.y = 0f;
					for (int i = 1; i <= num2; i++)
					{
						int mask = 128;
						if (!TerrainMeta.TopologyMap.GetTopology(position2 + (float)i * 15f * forward, mask))
						{
							isFacingLand = true;
							break;
						}
					}
				}
			}
			if (driftTowardsIsland && isFacingLand && !isInPool)
			{
				landPushAcceleration = Mathf.Clamp(landPushAcceleration + Time.deltaTime, 0f, 3f);
				rigidBody.AddForce(((Component)this).transform.forward * (Time.deltaTime * landPushAcceleration), (ForceMode)2);
			}
			else
			{
				landPushAcceleration = 0f;
			}
			lastPos = ((Component)this).transform.position;
		}
	}

	private void PaddleTurn(PaddleDirection direction)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (direction != 0 && direction != PaddleDirection.Back)
		{
			rigidBody.AddRelativeTorque(rotationForce * ((direction == PaddleDirection.Left) ? (-Vector3.up) : Vector3.up), (ForceMode)1);
			lastPaddle = TimeSince.op_Implicit(0f);
			ClientRPC(RpcTarget.NetworkGroup("OnPaddled"), (int)direction);
		}
	}

	public override float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		info = default(WaterLevel.WaterInfo);
		return 0f;
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		if (hitEntity is BaseVehicle baseVehicle && (baseVehicle.HasDriver() || baseVehicle.IsMoving() || baseVehicle.HasFlag(Flags.On)))
		{
			Kill(DestroyMode.Gib);
		}
	}

	private bool IsOutOfWaterServer()
	{
		return buoyancy.timeOutOfWater > 0.2f;
	}

	public void OnPoolDestroyed()
	{
		Kill(DestroyMode.Gib);
	}

	public void WakeUp()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody != (Object)null)
		{
			rigidBody.WakeUp();
			rigidBody.AddForce(Vector3.up * 0.1f, (ForceMode)1);
		}
		if ((Object)(object)buoyancy != (Object)null)
		{
			buoyancy.Wake();
		}
	}

	public void OnObjects(TriggerNotify trigger)
	{
		if (base.isClient)
		{
			return;
		}
		foreach (BaseEntity entityContent in trigger.entityContents)
		{
			if (entityContent is BaseVehicle baseVehicle && (baseVehicle.HasDriver() || baseVehicle.IsMoving() || baseVehicle.HasFlag(Flags.On)))
			{
				Kill(DestroyMode.Gib);
				break;
			}
		}
	}

	public void OnEmpty()
	{
	}
}


private enum PaddleDirection
{
	Forward,
	Left,
	Right,
	Back
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class WaterWell : LiquidContainer
{
	public Animator animator;

	private const Flags Pumping = Flags.Reserved2;

	private const Flags WaterFlow = Flags.Reserved3;

	public float caloriesPerPump = 5f;

	public float pressurePerPump = 0.2f;

	public float pressureForProduction = 1f;

	public float currentPressure;

	public int waterPerPump = 50;

	public GameObject waterLevelObj;

	public float waterLevelObjFullOffset;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WaterWell.OnRpcMessage", 0);
		try
		{
			if (rpc == 2538739344u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Pump "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Pump", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2538739344u, "RPC_Pump", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Pump(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Pump");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Reserved2, b: false);
		SetFlag(Flags.Reserved3, b: false);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_Pump(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !player.IsDead() && !player.IsSleeping() && !(player.metabolism.calories.value < caloriesPerPump) && !HasFlag(Flags.Reserved2))
		{
			SetFlag(Flags.Reserved2, b: true);
			player.metabolism.calories.value -= caloriesPerPump;
			player.metabolism.SendChangesToClient();
			currentPressure = Mathf.Clamp01(currentPressure + pressurePerPump);
			((FacepunchBehaviour)this).Invoke((Action)StopPump, 1.8f);
			if (currentPressure >= 0f)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Produce);
				((FacepunchBehaviour)this).Invoke((Action)Produce, 1f);
			}
			SendNetworkUpdateImmediate();
		}
	}

	public void StopPump()
	{
		SetFlag(Flags.Reserved2, b: false);
		SendNetworkUpdateImmediate();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		SendNetworkUpdate();
	}

	public void Produce()
	{
		base.inventory.AddItem(defaultLiquid, waterPerPump, 0uL);
		SetFlag(Flags.Reserved3, b: true);
		ScheduleTapOff();
		SendNetworkUpdateImmediate();
	}

	public void ScheduleTapOff()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)TapOff);
		((FacepunchBehaviour)this).Invoke((Action)TapOff, 1f);
	}

	private void TapOff()
	{
		SetFlag(Flags.Reserved3, b: false);
	}

	public void ReducePressure()
	{
		float num = Random.Range(0.1f, 0.2f);
		currentPressure = Mathf.Clamp01(currentPressure - num);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.waterwell = Pool.Get<WaterWell>();
		info.msg.waterwell.pressure = currentPressure;
		info.msg.waterwell.waterLevel = GetWaterAmount();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.waterwell != null)
		{
			currentPressure = info.msg.waterwell.pressure;
		}
	}

	public float GetWaterAmount()
	{
		if (base.isServer)
		{
			Item slot = base.inventory.GetSlot(0);
			if (slot == null)
			{
				return 0f;
			}
			return slot.amount;
		}
		return 0f;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class WeaponRack : StorageContainer
{
	[Serializable]
	public enum RackType
	{
		Board,
		Stand
	}

	public enum SpecialRackType
	{
		None,
		WesternDLC
	}

	[Header("Text")]
	public Phrase textLoadAmmos;

	public RackType Type;

	public float GridCellSize = 0.15f;

	public bool SetGridCellSizeFromCollision = true;

	public int Capacity = 30;

	public bool UseColliders;

	public int GridCellCountX = 10;

	public int GridCellCountY = 10;

	public BoxCollider Collision;

	public Transform Anchor;

	public Transform SmallPegPrefab;

	public Transform LargePegPrefab;

	[Header("Lights")]
	public GameObjectRef LightPrefab;

	public Transform[] LightPoints;

	public WeaponRackSlot[] gridSlots;

	private WeaponRackSlot[] gridCellSlotReferences;

	public int ForceItemRotation = -1;

	public bool CreatePegs = true;

	[Header("Custom Rack")]
	public SpecialRackType CustomRackType;

	public Transform CustomCenter;

	private static HashSet<int> usedSlots = new HashSet<int>();

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WeaponRack.OnRpcMessage", 0);
		try
		{
			if (rpc == 1682065633 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - LoadWeaponAmmo "));
				}
				TimeWarning val2 = TimeWarning.New("LoadWeaponAmmo", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						LoadWeaponAmmo(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in LoadWeaponAmmo");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 879556270 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqMountBackSlot "));
				}
				TimeWarning val2 = TimeWarning.New("ReqMountBackSlot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(879556270u, "ReqMountBackSlot", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(879556270u, "ReqMountBackSlot", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ReqMountBackSlot(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ReqMountBackSlot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2640584497u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqMountWeapon "));
				}
				TimeWarning val2 = TimeWarning.New("ReqMountWeapon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2640584497u, "ReqMountWeapon", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2640584497u, "ReqMountWeapon", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							ReqMountWeapon(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in ReqMountWeapon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2753286621u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqSwapWeapon "));
				}
				TimeWarning val2 = TimeWarning.New("ReqSwapWeapon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2753286621u, "ReqSwapWeapon", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2753286621u, "ReqSwapWeapon", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							ReqSwapWeapon(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in ReqSwapWeapon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3761066327u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqTakeAll "));
				}
				TimeWarning val2 = TimeWarning.New("ReqTakeAll", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3761066327u, "ReqTakeAll", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3761066327u, "ReqTakeAll", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							ReqTakeAll(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in ReqTakeAll");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1987971716 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqTakeWeapon "));
				}
				TimeWarning val2 = TimeWarning.New("ReqTakeWeapon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1987971716u, "ReqTakeWeapon", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1987971716u, "ReqTakeWeapon", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							ReqTakeWeapon(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in ReqTakeWeapon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3314206579u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqUnloadWeapon "));
				}
				TimeWarning val2 = TimeWarning.New("ReqUnloadWeapon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3314206579u, "ReqUnloadWeapon", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3314206579u, "ReqUnloadWeapon", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							ReqUnloadWeapon(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in ReqUnloadWeapon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		if (SetGridCellSizeFromCollision)
		{
			GridCellSize = Collision.size.x / (float)GridCellCountX;
		}
		gridSlots = new WeaponRackSlot[Capacity];
		for (int i = 0; i < gridSlots.Length; i++)
		{
			gridSlots[i] = new WeaponRackSlot();
		}
		ClearGridCellContentsRefs();
	}

	private void ClearGridCellContentsRefs()
	{
		if (gridCellSlotReferences == null)
		{
			gridCellSlotReferences = new WeaponRackSlot[GridCellCountX * GridCellCountY];
			return;
		}
		for (int i = 0; i < gridCellSlotReferences.Length; i++)
		{
			gridCellSlotReferences[i] = null;
		}
	}

	private void SetupSlot(WeaponRackSlot slot)
	{
		if (slot != null && !((Object)(object)slot.ItemDef == (Object)null))
		{
			SetGridCellContents(slot, clear: false);
		}
	}

	private void ClearSlot(WeaponRackSlot slot)
	{
		if (slot != null && slot.Used)
		{
			SetGridCellContents(slot, clear: true);
		}
	}

	public void SetGridCellContents(WeaponRackSlot slot, bool clear)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (slot == null)
		{
			return;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(slot.ItemDef);
		if ((Object)(object)forItemDef == (Object)null)
		{
			return;
		}
		Vector2Int xYForIndex = GetXYForIndex(slot.GridSlotIndex);
		Vector2Int weaponSize = GetWeaponSize(forItemDef, slot.Rotation);
		Vector2Int weaponStart = GetWeaponStart(xYForIndex, weaponSize, clamp: false);
		if (((Vector2Int)(ref weaponStart)).x < 0 || ((Vector2Int)(ref weaponStart)).y < 0 || ((Vector2Int)(ref weaponStart)).x + ((Vector2Int)(ref weaponSize)).x > GridCellCountX || ((Vector2Int)(ref weaponStart)).y + ((Vector2Int)(ref weaponSize)).y > GridCellCountY)
		{
			return;
		}
		for (int i = ((Vector2Int)(ref weaponStart)).y; i < ((Vector2Int)(ref weaponStart)).y + ((Vector2Int)(ref weaponSize)).y; i++)
		{
			for (int j = ((Vector2Int)(ref weaponStart)).x; j < ((Vector2Int)(ref weaponStart)).x + ((Vector2Int)(ref weaponSize)).x; j++)
			{
				gridCellSlotReferences[GetGridCellIndex(j, i)] = (clear ? null : slot);
			}
		}
		slot.SetUsed(!clear);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		usedSlots.Clear();
		ClearGridCellContentsRefs();
		if (info.msg.weaponRack == null)
		{
			return;
		}
		foreach (WeaponRackItem item in info.msg.weaponRack.items)
		{
			usedSlots.Add(item.inventorySlot);
			gridSlots[item.inventorySlot].InitFromProto(item);
		}
		for (int i = 0; i < Capacity; i++)
		{
			if (usedSlots.Contains(i))
			{
				SetupSlot(gridSlots[i]);
			}
			else
			{
				ClearSlot(gridSlots[i]);
			}
		}
	}

	public WeaponRackSlot GetWeaponAtIndex(int gridIndex)
	{
		if (gridIndex < 0)
		{
			return null;
		}
		if (gridIndex >= gridCellSlotReferences.Length)
		{
			return null;
		}
		return gridCellSlotReferences[gridIndex];
	}

	public Vector2Int GetXYForIndex(int index)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2Int(index % GridCellCountX, index / GridCellCountX);
	}

	private Vector2Int GetWeaponSize(WorldModelRackMountConfig config, int rotation)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		int num = ((Type == RackType.Board) ? config.XSize : config.ZSize);
		int num2 = ((Type == RackType.Board) ? config.YSize : config.XSize);
		if (rotation != 0 && Type == RackType.Board)
		{
			return new Vector2Int(num2, num);
		}
		return new Vector2Int(num, num2);
	}

	private Vector2Int GetWeaponStart(Vector2Int targetXY, Vector2Int size, bool clamp)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (Type == RackType.Board)
		{
			((Vector2Int)(ref targetXY)).x = ((Vector2Int)(ref targetXY)).x - ((Vector2Int)(ref size)).x / 2;
			((Vector2Int)(ref targetXY)).y = ((Vector2Int)(ref targetXY)).y - ((Vector2Int)(ref size)).y / 2;
		}
		if (clamp)
		{
			((Vector2Int)(ref targetXY)).x = Mathf.Max(((Vector2Int)(ref targetXY)).x, 0);
			((Vector2Int)(ref targetXY)).y = Mathf.Max(((Vector2Int)(ref targetXY)).y, 0);
		}
		return targetXY;
	}

	public bool CanAcceptWeaponType(WorldModelRackMountConfig weaponConfig)
	{
		if ((Object)(object)weaponConfig == (Object)null)
		{
			return false;
		}
		if (weaponConfig.ExcludedRackTypes.Contains(Type))
		{
			return false;
		}
		if (CustomRackType != 0 && weaponConfig.FindCustomRackPosition(CustomRackType) == null)
		{
			return false;
		}
		return true;
	}

	public int GetBestPlacementCellIndex(Vector2Int targetXY, WorldModelRackMountConfig config, int rotation, WeaponRackSlot ignoreSlot)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (Type == RackType.Stand)
		{
			((Vector2Int)(ref targetXY)).y = 0;
		}
		int gridCellIndex = GetGridCellIndex(((Vector2Int)(ref targetXY)).x, ((Vector2Int)(ref targetXY)).y);
		if (GridCellsFree(config, gridCellIndex, rotation, ignoreSlot))
		{
			return gridCellIndex;
		}
		float num = float.MaxValue;
		int result = -1;
		Vector2Int weaponSize = GetWeaponSize(config, rotation);
		Vector2Int weaponStart = GetWeaponStart(targetXY, weaponSize, clamp: true);
		Vector2Int val = default(Vector2Int);
		for (int i = ((Vector2Int)(ref weaponStart)).y; i < ((Vector2Int)(ref weaponStart)).y + ((Vector2Int)(ref weaponSize)).y + 1; i++)
		{
			if (Type == RackType.Stand && i != 0)
			{
				continue;
			}
			for (int j = ((Vector2Int)(ref weaponStart)).x; j < ((Vector2Int)(ref weaponStart)).x + ((Vector2Int)(ref weaponSize)).x + 1; j++)
			{
				gridCellIndex = GetGridCellIndex(j, i);
				if (GridCellsFree(config, gridCellIndex, rotation, ignoreSlot))
				{
					((Vector2Int)(ref val)).x = j;
					((Vector2Int)(ref val)).y = i;
					float num2 = Vector2Int.Distance(targetXY, val);
					if (!(num2 >= num))
					{
						result = gridCellIndex;
						num = num2;
					}
				}
			}
		}
		return result;
	}

	public int GetGridIndexAtPosition(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		float num = Collision.size.x - (pos.x + Collision.size.x / 2f);
		float num2 = pos.y + Collision.size.y / 2f;
		int num3 = (int)(num / GridCellSize);
		return (int)(num2 / GridCellSize) * GridCellCountX + num3;
	}

	private bool GridCellsFree(WorldModelRackMountConfig config, int gridIndex, int rotation, WeaponRackSlot ignoreGridSlot)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (gridIndex == -1)
		{
			return false;
		}
		Vector2Int xYForIndex = GetXYForIndex(gridIndex);
		Vector2Int weaponSize = GetWeaponSize(config, rotation);
		Vector2Int weaponStart = GetWeaponStart(xYForIndex, weaponSize, clamp: false);
		if (((Vector2Int)(ref weaponStart)).x < 0 || ((Vector2Int)(ref weaponStart)).y < 0)
		{
			return false;
		}
		for (int i = ((Vector2Int)(ref weaponStart)).y; i < ((Vector2Int)(ref weaponStart)).y + ((Vector2Int)(ref weaponSize)).y; i++)
		{
			for (int j = ((Vector2Int)(ref weaponStart)).x; j < ((Vector2Int)(ref weaponStart)).x + ((Vector2Int)(ref weaponSize)).x; j++)
			{
				int gridCellIndex = GetGridCellIndex(j, i);
				if (gridCellIndex == -1 || !GridCellFree(gridCellIndex, ignoreGridSlot))
				{
					return false;
				}
			}
		}
		return true;
	}

	private int GetGridCellIndex(int x, int y)
	{
		if (x < 0 || x >= GridCellCountX || y < 0 || y >= GridCellCountY)
		{
			return -1;
		}
		return y * GridCellCountX + x;
	}

	private bool GridCellFree(int index, WeaponRackSlot ignoreSlot)
	{
		if (gridCellSlotReferences[index] != null)
		{
			if (ignoreSlot != null)
			{
				return gridCellSlotReferences[index] == ignoreSlot;
			}
			return false;
		}
		return true;
	}

	private static bool ItemIsRackMountable(Item item)
	{
		return (Object)(object)WorldModelRackMountConfig.GetForItemDef(item.info) != (Object)null;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(InventoryItemFilter));
		SpawnLightSubEntities();
	}

	private void SpawnLightSubEntities()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoadingSave || LightPrefab == null || LightPoints == null)
		{
			return;
		}
		Transform[] lightPoints = LightPoints;
		foreach (Transform val in lightPoints)
		{
			SimpleLight simpleLight = GameManager.server.CreateEntity(LightPrefab.resourcePath, val.position, val.rotation) as SimpleLight;
			if (Object.op_Implicit((Object)(object)simpleLight))
			{
				simpleLight.enableSaving = true;
				simpleLight.SetParent(this, worldPositionStays: true);
				simpleLight.Spawn();
			}
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		bool flag = false;
		if (!added)
		{
			WeaponRackSlot[] array = gridSlots;
			foreach (WeaponRackSlot weaponRackSlot in array)
			{
				if (weaponRackSlot != null && weaponRackSlot.Used)
				{
					ItemDefinition itemDef = weaponRackSlot.ItemDef;
					if ((Object)(object)itemDef == (Object)null || !itemDef.IsAllowed((EraRestriction)0))
					{
						ClearSlot(weaponRackSlot);
						flag = true;
					}
				}
			}
		}
		if (flag)
		{
			SendNetworkUpdateImmediate();
		}
	}

	private bool InventoryItemFilter(Item item, int targetSlot)
	{
		if (item == null)
		{
			return false;
		}
		return ItemIsRackMountable(item);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.weaponRack = Pool.Get<WeaponRack>();
		info.msg.weaponRack.items = Pool.Get<List<WeaponRackItem>>();
		WeaponRackSlot[] array = gridSlots;
		foreach (WeaponRackSlot weaponRackSlot in array)
		{
			if (weaponRackSlot.Used)
			{
				Item slot = base.inventory.GetSlot(weaponRackSlot.InventoryIndex);
				WeaponRackItem proto = Pool.Get<WeaponRackItem>();
				info.msg.weaponRack.items.Add(weaponRackSlot.SaveToProto(slot, proto));
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(2f)]
	private void ReqSwapWeapon(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (num != -1)
		{
			int rotation = msg.read.Int32();
			Item item = msg.player.GetHeldEntity()?.GetItem();
			if (item != null)
			{
				SwapPlayerWeapon(msg.player, num, item.position, rotation);
			}
		}
	}

	private void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Item item = player.GetHeldEntity()?.GetItem();
		if (item == null)
		{
			return;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if ((Object)(object)forItemDef == (Object)null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridCellIndex);
		if (weaponAtIndex != null)
		{
			int mountSlotIndex = gridCellIndex;
			if (CustomRackType != 0)
			{
				gridCellIndex = 0;
			}
			int bestPlacementCellIndex = GetBestPlacementCellIndex(GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);
			if (bestPlacementCellIndex != -1 && Interface.CallHook("OnRackedWeaponSwap", (object)item, (object)weaponAtIndex, (object)player, (object)this) == null)
			{
				item.RemoveFromContainer();
				GivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, tryHold: false);
				MountWeapon(item, player, bestPlacementCellIndex, rotation, sendUpdate: false);
				ItemManager.DoRemoves();
				SendNetworkUpdateImmediate();
				Interface.CallHook("OnRackedWeaponSwapped", (object)item, (object)weaponAtIndex, (object)player, (object)this);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(2f)]
	private void ReqTakeWeapon(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (num != -1)
		{
			GivePlayerWeapon(msg.player, num);
		}
	}

	private void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)
	{
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null)
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponTake", (object)slot, (object)player, (object)this) != null)
		{
			return;
		}
		ClearSlot(weaponAtIndex);
		bool flag = false;
		bool flag2 = true;
		if (slot.IsBackpack())
		{
			flag2 = false;
			if ((Object)(object)((Component)slot.info).GetComponent<ItemModBackpack>() != (Object)null && player.inventory.GetAnyBackpack() == null)
			{
				flag = slot.MoveToContainer(player.inventory.containerWear);
			}
		}
		if (!flag)
		{
			flag = slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex);
		}
		if (flag)
		{
			if (flag2 && ((tryHold && (Object)(object)player.GetHeldEntity() == (Object)null) || playerBeltIndex != -1))
			{
				ClientRPC(RpcTarget.Player("SetActiveBeltSlot", player), slot.position, slot.uid);
			}
			ClientRPC(RpcTarget.Player("PlayGrabSound", player), slot.info.itemid);
		}
		else if (!slot.MoveToContainer(player.inventory.containerMain))
		{
			slot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponTaken", (object)slot, (object)player, (object)this);
	}

	[RPC_Server.MaxDistance(2f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ReqTakeAll(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (num != -1)
		{
			GivePlayerAllWeapons(msg.player, num);
		}
	}

	private void GivePlayerAllWeapons(BasePlayer player, int mountSlotIndex)
	{
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex != null)
		{
			GivePlayerWeapon(player, weaponAtIndex.GridSlotIndex);
		}
		for (int num = gridSlots.Length - 1; num >= 0; num--)
		{
			WeaponRackSlot weaponRackSlot = gridSlots[num];
			if (weaponRackSlot.Used)
			{
				GivePlayerWeapon(player, weaponRackSlot.GridSlotIndex, -1, tryHold: false);
			}
		}
		ItemManager.DoRemoves();
		SendNetworkUpdateImmediate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(2f)]
	private void ReqUnloadWeapon(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (num != -1)
		{
			UnloadWeapon(msg.player, num);
		}
	}

	private void UnloadWeapon(BasePlayer player, int mountSlotIndex)
	{
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponUnload", (object)slot, (object)player, (object)this) != null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
			if (!((Object)(object)component == (Object)null))
			{
				ItemDefinition ammoType = component.primaryMagazine.ammoType;
				component.UnloadAmmo(slot, player);
				SetSlotAmmoDetails(weaponAtIndex, slot);
				SendNetworkUpdateImmediate();
				ClientRPC(RpcTarget.Player("PlayAmmoSound", player), ammoType.itemid, 1);
				Interface.CallHook("OnRackedWeaponUnloaded", (object)slot, (object)player, (object)this);
			}
		}
	}

	[RPC_Server.MaxDistance(2f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ReqMountWeapon(RPCMessage msg)
	{
		if (base.inventory.itemList.Count != base.inventory.capacity)
		{
			int num = msg.read.Int32();
			if (num != -1)
			{
				int rotation = msg.read.Int32();
				MountWeapon(msg.player, num, rotation);
			}
		}
	}

	private void MountWeapon(BasePlayer player, int gridCellIndex, int rotation)
	{
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		HeldEntity heldEntity = player.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			Item item = heldEntity.GetItem();
			if (item != null)
			{
				MountWeapon(item, player, gridCellIndex, rotation);
			}
		}
	}

	[RPC_Server.MaxDistance(2f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ReqMountBackSlot(RPCMessage msg)
	{
		if (base.inventory.itemList.Count != base.inventory.capacity)
		{
			int num = msg.read.Int32();
			if (num != -1)
			{
				int rotation = msg.read.Int32();
				MountBackSlot(msg.player, num, rotation);
			}
		}
	}

	private void MountBackSlot(BasePlayer player, int gridCellIndex, int rotation)
	{
		if (!((Object)(object)player == (Object)null))
		{
			Item anyBackpack = player.inventory.GetAnyBackpack();
			if (anyBackpack != null && (!((Object)(object)((Component)anyBackpack.info).GetComponent<ItemModBackpack>() != (Object)null) || anyBackpack.contents == null || anyBackpack.contents.itemList == null || anyBackpack.contents.itemList.Count <= 0))
			{
				MountWeapon(anyBackpack, player, gridCellIndex, rotation);
			}
		}
	}

	private void SetSlotItem(WeaponRackSlot slot, Item item, int gridCellIndex, int rotation)
	{
		slot.SetItem(item, base.inventory.GetSlot(item.position)?.info, gridCellIndex, rotation);
	}

	private void SetSlotAmmoDetails(WeaponRackSlot slot, Item item)
	{
		slot?.SetAmmoDetails(item);
	}

	private bool MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate = true)
	{
		if (item == null)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnRackedWeaponMount", (object)item, (object)player, (object)this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		int itemid = item.info.itemid;
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if ((Object)(object)forItemDef == (Object)null)
		{
			Debug.LogWarning((object)"no rackmount config");
			return false;
		}
		if (!CanAcceptWeaponType(forItemDef))
		{
			return false;
		}
		if (!GridCellsFree(forItemDef, gridCellIndex, rotation, null))
		{
			return false;
		}
		if (item.MoveToContainer(base.inventory, -1, allowStack: false) && item.position >= 0 && item.position < gridSlots.Length)
		{
			WeaponRackSlot slot = gridSlots[item.position];
			SetSlotItem(slot, item, gridCellIndex, rotation);
			SetupSlot(slot);
			if ((Object)(object)player != (Object)null)
			{
				ClientRPC(RpcTarget.Player("PlayMountSound", player), itemid);
			}
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponMounted", (object)item, (object)player, (object)this);
		return true;
	}

	private void PlayMountSound(int itemID)
	{
		ClientRPC(RpcTarget.NetworkGroup("PlayMountSound"), itemID);
	}

	[RPC_Server]
	private void LoadWeaponAmmo(RPCMessage msg)
	{
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!Object.op_Implicit((Object)(object)player))
		{
			return;
		}
		int gridIndex = msg.read.Int32();
		int num = msg.read.Int32();
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if ((Object)(object)heldEntity == (Object)null)
		{
			return;
		}
		BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
		if ((Object)(object)component == (Object)null)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if ((Object)(object)itemDefinition == (Object)null || Interface.CallHook("OnRackedWeaponLoad", (object)slot, (object)itemDefinition, (object)player, (object)this) != null)
		{
			return;
		}
		if ((Object)(object)itemDefinition == (Object)(object)SnowballGun.SnowballInventoryItem)
		{
			itemDefinition = SnowballGun.SnowballAmmoItem;
			if (!((Object)(object)itemDefinition != (Object)null))
			{
				return;
			}
			num = itemDefinition.itemid;
		}
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return;
		}
		ItemModProjectile component2 = ((Component)itemDefinition).GetComponent<ItemModProjectile>();
		if (!((Object)(object)component2 == (Object)null) && component2.IsAmmo(component.primaryMagazine.definition.ammoTypes))
		{
			if (num != component.primaryMagazine.ammoType.itemid && component.primaryMagazine.contents > 0)
			{
				player.GiveItem(ItemManager.CreateByItemID(component.primaryMagazine.ammoType.itemid, component.primaryMagazine.contents, 0uL));
				component.SetAmmoCount(0);
			}
			component.primaryMagazine.ammoType = itemDefinition;
			component.TryReloadMagazine(player.inventory);
			SetSlotAmmoDetails(weaponAtIndex, slot);
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.Player("PlayAmmoSound", player), itemDefinition.itemid, 0);
			Interface.CallHook("OnRackedWeaponLoaded", (object)slot, (object)itemDefinition, (object)player, (object)this);
		}
	}
}


using System;

[Serializable]
public enum RackType
{
	Board,
	Stand
}


public enum SpecialRackType
{
	None,
	WesternDLC
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class WheelSwitch : IOEntity
{
	public Transform wheelObj;

	public float rotateSpeed = 90f;

	public Flags BeingRotated = Flags.Reserved1;

	public Flags RotatingLeft = Flags.Reserved2;

	public Flags RotatingRight = Flags.Reserved3;

	public float rotateProgress;

	public Animator animator;

	public float kineticEnergyPerSec = 1f;

	private BasePlayer rotatorPlayer;

	private float progressTickRate = 0.1f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WheelSwitch.OnRpcMessage", 0);
		try
		{
			if (rpc == 2223603322u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BeginRotate "));
				}
				TimeWarning val2 = TimeWarning.New("BeginRotate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2223603322u, "BeginRotate", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							BeginRotate(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in BeginRotate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 434251040 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - CancelRotate "));
				}
				TimeWarning val2 = TimeWarning.New("CancelRotate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(434251040u, "CancelRotate", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							CancelRotate(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in CancelRotate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetIOState()
	{
		CancelPlayerRotation();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void BeginRotate(RPCMessage msg)
	{
		if (!IsBeingRotated())
		{
			SetFlag(BeingRotated, b: true);
			rotatorPlayer = msg.player;
			((FacepunchBehaviour)this).InvokeRepeating((Action)RotateProgress, 0f, progressTickRate);
		}
	}

	public void CancelPlayerRotation()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)RotateProgress);
		SetFlag(BeingRotated, b: false);
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOSlot.connectedTo.Get().IOInput(this, ioType, 0f, iOSlot.connectedToSlot);
			}
		}
		rotatorPlayer = null;
	}

	public void RotateProgress()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)rotatorPlayer) || rotatorPlayer.IsDead() || rotatorPlayer.IsSleeping() || Vector3Ex.Distance2D(((Component)rotatorPlayer).transform.position, ((Component)this).transform.position) > 2f)
		{
			CancelPlayerRotation();
			return;
		}
		float num = kineticEnergyPerSec * progressTickRate;
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				num = iOSlot.connectedTo.Get().IOInput(this, ioType, num, iOSlot.connectedToSlot);
			}
		}
		if (num == 0f)
		{
			SetRotateProgress(rotateProgress + 0.1f);
		}
		SendNetworkUpdate();
	}

	public void SetRotateProgress(float newValue)
	{
		float num = rotateProgress;
		rotateProgress = newValue;
		SetFlag(Flags.Reserved4, num != newValue);
		SendNetworkUpdate();
		((FacepunchBehaviour)this).CancelInvoke((Action)StoppedRotatingCheck);
		((FacepunchBehaviour)this).Invoke((Action)StoppedRotatingCheck, 0.25f);
	}

	public void StoppedRotatingCheck()
	{
		SetFlag(Flags.Reserved4, b: false);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void CancelRotate(RPCMessage msg)
	{
		CancelPlayerRotation();
	}

	public void Powered()
	{
		float inputAmount = kineticEnergyPerSec * progressTickRate;
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				inputAmount = iOSlot.connectedTo.Get().IOInput(this, ioType, inputAmount, iOSlot.connectedToSlot);
			}
		}
		SetRotateProgress(rotateProgress + 0.1f);
	}

	public override float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot = 0)
	{
		if (inputAmount < 0f)
		{
			SetRotateProgress(rotateProgress + inputAmount);
			SendNetworkUpdate();
		}
		if (inputType == IOType.Electric && slot == 1)
		{
			if (inputAmount == 0f)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Powered);
			}
			else
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)Powered, 0f, progressTickRate);
			}
		}
		return Mathf.Clamp(inputAmount - 1f, 0f, inputAmount);
	}

	public bool IsBeingRotated()
	{
		return HasFlag(BeingRotated);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.sphereEntity != null)
		{
			rotateProgress = info.msg.sphereEntity.radius;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.sphereEntity = Pool.Get<SphereEntity>();
		info.msg.sphereEntity.radius = rotateProgress;
	}
}


using System;
using System.Linq;
using ConVar;
using Network;
using Rust;
using UnityEngine;

public class WildlifeHazard : BaseCombatEntity, IReceivePlayerTickListener
{
	public const Flags Flag_IsCorpse = Flags.Reserved8;

	[ServerVar]
	public static float ClientTickRate = 0.1f;

	[ServerVar]
	public static float ReactionTimeMultiplier = 1f;

	[ServerVar]
	public static float ChanceToRepositionMultiplier = 1f;

	[ServerVar]
	public static float RepositionRadiusMultiplier = 1f;

	[ServerVar]
	public static float RepositionTimerMultiplier = 1f;

	[ServerVar]
	public static int RepositionAttempts = 5;

	[Header("Wildlife Hazard")]
	public BUTTON ReactionSaveButton;

	public float SavingReactionTime = 2f;

	public float Damage = 20f;

	public float HazardInterval = 10f;

	public DamageType DamageType = DamageType.Bite;

	public float ChanceToReposition = 0.5f;

	public float RepositionDelay = 1.25f;

	public float RepositionTimer = 2f;

	public float RepositionRadiusMin = 2f;

	public float RepositionRadiusMax = 4f;

	public Transform ClientArtRoot;

	public TriggerQTE QTETrigger;

	public TriggerBase ClientTrigger;

	public float LookSpeed = 10f;

	public float MinTurnDegrees = 45f;

	public float MinFastTurnDistance = 2f;

	public float MaxWaterDepth = 0.1f;

	public float SlitherDuration = 1f;

	public float SlitherSpeed = 2f;

	public GameObjectRef CorpsePrefab;

	public GameObjectRef BitFX;

	[Header("Wildlife Hazad Visuals")]
	public Animator Animator;

	public GameObjectRef PrefabRepositionEffect;

	public GameObjectRef PrefabReappearEffect;

	[Header("Wildlife Hazard Audio")]
	public SoundDefinition HazardTriggeredSound;

	public bool PlayAlertSounds = true;

	public SoundDefinition AlertIntervalSound;

	public SoundDefinition AttackSound;

	public float AlertSoundMinInterval = 3f;

	public float AlertSoundMaxInterval = 5f;

	public SoundDefinition RepositionDisappearSound;

	public SoundDefinition RepositionReappearSound;

	[Header("Wildlife Hazard Corpse")]
	public ResourceDispenser DeadResourceDispenser;

	public ProtectionProperties DeadProtectionProperties;

	[Tooltip("If enabled, only triggers for one player at a time")]
	public bool SingularInteraction = true;

	public float AttackRange = 1.5f;

	public float AlertToIdleCooldown = 5f;

	protected const int placementMask = 8388608;

	protected const int blockMask = 1075904769;

	protected Vector3 repositionLookAtPos;

	protected Vector3 repositionTo;

	protected int failedRepositionAttempts;

	public override bool IsNpc => true;

	public bool IsCorpse => HasFlag(Flags.Reserved8);

	public BasePlayer SingularInteractionPlayer { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WildlifeHazard.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Reserved8, b: false);
		((Behaviour)DeadResourceDispenser).enabled = false;
		failedRepositionAttempts = 0;
	}

	public virtual void TriggeredByPlayer(BasePlayer player)
	{
		if (ShouldStartHazard(player))
		{
			StartHazard(player);
		}
	}

	protected virtual bool ShouldStartHazard(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (IsCorpse)
		{
			return false;
		}
		if (!IsAlive())
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)StartReposition))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)ReAttackCheck))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)FailHazardDelayed))
		{
			return false;
		}
		if (SingularInteraction && (Object)(object)SingularInteractionPlayer != (Object)null)
		{
			return false;
		}
		if (!CanSeeTarget(((Component)player).transform))
		{
			return false;
		}
		return true;
	}

	private void StartHazard(BasePlayer player)
	{
		OnHazardStarted(player);
	}

	protected virtual void OnHazardStarted(BasePlayer player)
	{
		player.AddReceiveTickListener(this);
		if (SingularInteraction)
		{
			SingularInteractionPlayer = player;
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
		((FacepunchBehaviour)this).CancelInvoke((Action)FailHazardDelayed);
		float reactionTime = GetReactionTime(player);
		((FacepunchBehaviour)this).Invoke((Action)FailHazardDelayed, reactionTime);
		ClientRPC(RpcTarget.Player("Client_StartHazard", player), reactionTime);
	}

	protected void FailHazardDelayed()
	{
		EndHazard(SingularInteractionPlayer, success: false);
	}

	protected void EndHazard(BasePlayer player, bool success)
	{
		if (success)
		{
			OnHazardCompleted(player);
		}
		else
		{
			OnHazardFailed(player);
		}
		OnHazardEnded(player);
	}

	protected virtual void OnHazardCompleted(BasePlayer player)
	{
	}

	protected virtual void OnHazardFailed(BasePlayer player)
	{
	}

	protected virtual void OnHazardEnded(BasePlayer player)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.Player("Client_EndHazard", player));
		((FacepunchBehaviour)this).CancelInvoke((Action)FailHazardDelayed);
		((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
		if ((Object)(object)player != (Object)null)
		{
			player.RemoveReceiveTickListener(this);
		}
		SingularInteractionPlayer = null;
		if (ShouldReposition())
		{
			if (FindSuitableReposition(out var pos))
			{
				failedRepositionAttempts = 0;
				repositionTo = pos;
				repositionLookAtPos = (((Object)(object)player != (Object)null) ? ((Component)player).transform.position : (((Component)this).transform.position + Vector3.forward));
				((FacepunchBehaviour)this).Invoke((Action)StartReposition, RepositionDelay);
			}
			else
			{
				failedRepositionAttempts++;
				if (failedRepositionAttempts <= 3)
				{
					((FacepunchBehaviour)this).Invoke((Action)ReAttackCheck, HazardInterval);
				}
				else
				{
					Kill();
				}
			}
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)ReAttackCheck, HazardInterval);
		}
	}

	private bool ShouldReposition()
	{
		if (IsCorpse)
		{
			return false;
		}
		float num = ChanceToReposition * ChanceToRepositionMultiplier;
		if (num <= 0f)
		{
			return false;
		}
		if (Random.Range(0f, 1f) > num)
		{
			return false;
		}
		return true;
	}

	public virtual void StartReposition()
	{
	}

	private bool FindSuitableReposition(out Vector3 pos)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		bool flag = true;
		int num = 0;
		Vector3 val = default(Vector3);
		while (flag)
		{
			float num2 = Random.Range(RepositionRadiusMin, RepositionRadiusMax) * RepositionRadiusMultiplier;
			float num3 = Random.value * (MathF.PI * 2f);
			((Vector3)(ref val))..ctor(Mathf.Cos(num3), 0f, Mathf.Sin(num3));
			pos = ((Component)this).transform.position + val * num2;
			bool flag2 = ValidatePosition(ref pos);
			if (flag2)
			{
				return true;
			}
			flag = !flag2 && ++num < RepositionAttempts;
		}
		pos = ((Component)this).transform.position;
		return false;
	}

	private bool ValidatePosition(ref Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(pos + Vector3.up * 3f, Vector3.down, ref val, 6f, 8388608))
		{
			if (WaterLevel.GetOverallWaterDepth(((RaycastHit)(ref val)).point, waves: true, volumes: false) > MaxWaterDepth)
			{
				return false;
			}
			if (!GamePhysics.LineOfSight(((RaycastHit)(ref val)).point, ((RaycastHit)(ref val)).point + Vector3.up * 4f, 1075904769))
			{
				return false;
			}
			if (!GamePhysics.LineOfSight(((Component)this).transform.position + Vector3.up * 0.25f, ((RaycastHit)(ref val)).point + Vector3.up * 0.25f, 1075904769))
			{
				return false;
			}
			pos = ((RaycastHit)(ref val)).point;
			return true;
		}
		return false;
	}

	private void ReAttackCheck()
	{
		if (IsCorpse || QTETrigger.contents == null || QTETrigger.contents.Count == 0)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
			return;
		}
		GameObject val = QTETrigger.contents.Single();
		if (!((Object)(object)val == (Object)null))
		{
			BaseEntity baseEntity = val.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null))
			{
				TriggeredByPlayer(baseEntity as BasePlayer);
			}
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if (base.isServer)
		{
			if (IsCorpse)
			{
				OnCorpseAttacked(info);
			}
			else
			{
				OnAliveAttacked(info);
			}
		}
	}

	private void OnCorpseAttacked(HitInfo info)
	{
		ResetCorpseRemovalTime();
		if (!(info.Weapon is BaseMelee baseMelee) || baseMelee.GetGatherInfoFromIndex(ResourceDispenser.GatherType.Flesh).gatherDamage != 0f)
		{
			DeadResourceDispenser.DoGather(info);
			if (!info.DidGather)
			{
				base.OnAttacked(info);
			}
		}
	}

	private void OnAliveAttacked(HitInfo info)
	{
		base.OnAttacked(info);
	}

	public override void OnKilled()
	{
		base.OnKilled();
		if ((Object)(object)SingularInteractionPlayer != (Object)null)
		{
			SingularInteractionPlayer.RemoveReceiveTickListener(this);
		}
		CancelHazardInvokes();
	}

	public override void OnDied(HitInfo info)
	{
		if (base.isServer)
		{
			ClientRPC(RpcTarget.NetworkGroup("CL_Died"));
			((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
			((FacepunchBehaviour)this).CancelInvoke((Action)FailHazardDelayed);
			if ((Object)(object)SingularInteractionPlayer != (Object)null)
			{
				SingularInteractionPlayer.RemoveReceiveTickListener(this);
			}
			if (IsCorpse)
			{
				Kill();
			}
			else
			{
				TurnIntoCorpse();
			}
		}
	}

	public void TurnIntoCorpse()
	{
		SetFlag(Flags.Reserved8, b: true);
		SetHealth(MaxHealth());
		lifestate = LifeState.Alive;
		((Behaviour)DeadResourceDispenser).enabled = true;
		baseProtection = DeadProtectionProperties;
		sendsHitNotification = false;
		ResetCorpseRemovalTime();
	}

	private void CancelHazardInvokes()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)FailHazardDelayed);
		((FacepunchBehaviour)this).CancelInvoke((Action)StartReposition);
		((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
	}

	public void ResetCorpseRemovalTime()
	{
		ResetCorpseRemovalTime(ConVar.Server.corpsedespawn);
	}

	public void ResetCorpseRemovalTime(float dur)
	{
		TimeWarning val = TimeWarning.New("ResetRemovalTime", 0);
		try
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)RemoveCorpse))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)RemoveCorpse);
			}
			((FacepunchBehaviour)this).Invoke((Action)RemoveCorpse, dur);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void RemoveCorpse()
	{
		Kill();
	}

	bool IReceivePlayerTickListener.ShouldRemoveOnPlayerDeath()
	{
		return true;
	}

	void IReceivePlayerTickListener.OnReceivePlayerTick(BasePlayer player, PlayerTick msg)
	{
		if (!((Object)(object)player == (Object)null) && !((Object)(object)player != (Object)(object)SingularInteractionPlayer) && player.serverInput.WasJustPressed(ReactionSaveButton))
		{
			EndHazard(player, success: true);
		}
	}

	public virtual float GetReactionTime(BasePlayer player)
	{
		float num = (((Object)(object)player == (Object)null || player.net == null || player.net.connection == null) ? 0f : ((float)Net.sv.GetAveragePing(player.net.connection) / 1000f));
		return SavingReactionTime * ReactionTimeMultiplier + num;
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		if (base.isServer)
		{
			ClientRPC(RpcTarget.NetworkGroup("CL_Hurt"));
		}
	}

	protected bool CanSeeTarget(Transform targetTransform)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)targetTransform == (Object)null)
		{
			return false;
		}
		if (!GamePhysics.LineOfSight(((Component)this).transform.position + Vector3.up * 0.25f, targetTransform.position + Vector3.up * 0.25f, 1075904769))
		{
			return false;
		}
		return true;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class WireTool : HeldEntity
{
	public enum WireColour
	{
		Gray,
		Red,
		Green,
		Blue,
		Yellow,
		Pink,
		Purple,
		Orange,
		White,
		LightBlue,
		Invisible,
		Count
	}

	public struct PendingPlug
	{
		public IOEntity ent;

		public bool isInput;

		public int index;
	}

	private const int maxLineNodes = 16;

	private const float industrialWallOffset = 0.04f;

	public IOEntity.IOType wireType;

	public WireColour DefaultColor;

	public float radialMenuHoldTime = 0.25f;

	public float disconnectDelay = 0.15f;

	public float clearDelay = 0.65f;

	private bool justCleared;

	public GameObjectRef plugEffect;

	public SoundDefinition clearStartSoundDef;

	public SoundDefinition clearSoundDef;

	public PendingPlug pendingPlug;

	private const float IndustrialThickness = 0.01f;

	private bool CanChangeColours
	{
		get
		{
			IOEntity.IOType iOType = wireType;
			return iOType == IOEntity.IOType.Electric || iOType == IOEntity.IOType.Fluidic || iOType == IOEntity.IOType.Industrial;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WireTool.OnRpcMessage", 0);
		try
		{
			if (rpc == 2571821359u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_MakeConnection "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_MakeConnection", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2571821359u, "RPC_MakeConnection", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2571821359u, "RPC_MakeConnection", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(2571821359u, "RPC_MakeConnection", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_MakeConnection(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_MakeConnection");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 986119119 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestChangeColor "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestChangeColor", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(986119119u, "RPC_RequestChangeColor", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(986119119u, "RPC_RequestChangeColor", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(986119119u, "RPC_RequestChangeColor", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_RequestChangeColor(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_RequestChangeColor");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1514179840 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestClear "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestClear", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1514179840u, "RPC_RequestClear", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1514179840u, "RPC_RequestClear", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(1514179840u, "RPC_RequestClear", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_RequestClear(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_RequestClear");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public float GetMaxWireLength(BasePlayer forPlayer)
	{
		if ((Object)(object)forPlayer == (Object)null || !forPlayer.IsInCreativeMode || !Creative.unlimitedIo)
		{
			return 30f;
		}
		return 200f;
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.FromOwner(false)]
	public void RPC_MakeConnection(RPCMessage rpc)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = rpc.player;
		if (!CanPlayerUseWires(player))
		{
			return;
		}
		WireConnectionMessage val = rpc.read.Proto<WireConnectionMessage>((WireConnectionMessage)null);
		List<Vector3> linePoints = val.linePoints;
		int inputIndex = val.inputIndex;
		int outputIndex = val.outputIndex;
		IOEntity iOEntity = new EntityRef<IOEntity>(val.inputID).Get(serverside: true);
		IOEntity iOEntity2 = new EntityRef<IOEntity>(val.outputID).Get(serverside: true);
		if ((Object)(object)iOEntity == (Object)null || (Object)(object)iOEntity2 == (Object)null || !ValidateLine(linePoints, iOEntity, iOEntity2, player, outputIndex) || inputIndex >= iOEntity.inputs.Length || outputIndex >= iOEntity2.outputs.Length || (Object)(object)iOEntity.inputs[inputIndex].connectedTo.Get() != (Object)null || (Object)(object)iOEntity2.outputs[outputIndex].connectedTo.Get() != (Object)null || (iOEntity.inputs[inputIndex].rootConnectionsOnly && !iOEntity2.IsRootEntity()) || !CanModifyEntity(player, iOEntity) || !CanModifyEntity(player, iOEntity2))
		{
			return;
		}
		List<float> slackLevels = val.slackLevels;
		IOEntity.LineAnchor[] array = new IOEntity.LineAnchor[val.lineAnchors.Count];
		for (int i = 0; i < val.lineAnchors.Count; i++)
		{
			WireLineAnchorInfo val2 = val.lineAnchors[i];
			array[i].entityRef = new EntityRef<Door>(val2.parentID);
			array[i].boneName = val2.boneName;
			array[i].index = (int)val2.index;
			array[i].position = val2.position;
		}
		WireColour wireColour = IntToColour(val.wireColor);
		if (Interface.CallHook("OnWireConnect", (object)player, (object)iOEntity, (object)inputIndex, (object)iOEntity2, (object)outputIndex, (object)val.linePoints, (object)slackLevels) == null)
		{
			if (wireColour == WireColour.Invisible && !player.IsInCreativeMode)
			{
				wireColour = DefaultColor;
			}
			iOEntity2.ConnectTo(iOEntity, outputIndex, inputIndex, linePoints, slackLevels, array, wireColour);
			if (wireType == IOEntity.IOType.Industrial)
			{
				iOEntity.NotifyIndustrialNetworkChanged();
				iOEntity2.NotifyIndustrialNetworkChanged();
			}
		}
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	public void RPC_RequestClear(RPCMessage msg)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_0405: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0411: Unknown result type (might be due to invalid IL or missing references)
		//IL_041c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!CanPlayerUseWires(player))
		{
			return;
		}
		NetworkableId uid = msg.read.EntityID();
		int num = msg.read.Int32();
		bool flag = msg.read.Bit();
		bool flag2 = msg.read.Bit();
		IOEntity iOEntity = BaseNetworkable.serverEntities.Find(uid) as IOEntity;
		if ((Object)(object)iOEntity == (Object)null)
		{
			return;
		}
		WireReconnectMessage val = Pool.Get<WireReconnectMessage>();
		if (flag2)
		{
			IOEntity.IOSlot iOSlot = (flag ? iOEntity.inputs : iOEntity.outputs)[num];
			IOEntity iOEntity2 = iOSlot.connectedTo.Get();
			if ((Object)(object)iOEntity2 == (Object)null)
			{
				return;
			}
			IOEntity.IOSlot iOSlot2 = (flag ? iOEntity2.outputs : iOEntity2.inputs)[iOSlot.connectedToSlot];
			val.isInput = !flag;
			val.slotIndex = iOSlot.connectedToSlot;
			val.entityId = iOSlot.connectedTo.Get().net.ID;
			val.wireColor = (int)iOSlot.wireColour;
			val.linePoints = Pool.Get<List<Vector3>>();
			val.slackLevels = Pool.Get<List<float>>();
			val.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			IOEntity iOEntity3 = iOEntity;
			Vector3[] array = iOSlot.linePoints;
			IOEntity.IOSlot iOSlot3 = iOSlot;
			if (array == null || array.Length == 0)
			{
				iOEntity3 = iOEntity2;
				array = iOSlot2.linePoints;
				iOSlot3 = iOSlot2;
			}
			if (array == null)
			{
				array = Array.Empty<Vector3>();
			}
			bool flag3 = (Object)(object)iOEntity3 != (Object)(object)iOEntity;
			if ((Object)(object)iOEntity == (Object)(object)iOEntity3 && flag)
			{
				flag3 = true;
			}
			val.linePoints.AddRange(array);
			float[] slackLevels = iOSlot.slackLevels;
			if (slackLevels == null || slackLevels.Length == 0)
			{
				slackLevels = iOSlot2.slackLevels;
			}
			float[] array2 = slackLevels;
			foreach (float item in array2)
			{
				val.slackLevels.Add(item);
			}
			IOEntity.LineAnchor[] lineAnchors = iOSlot.lineAnchors;
			if (lineAnchors == null || lineAnchors.Length == 0)
			{
				lineAnchors = iOSlot2.lineAnchors;
			}
			if (lineAnchors != null)
			{
				IOEntity.LineAnchor[] array3 = lineAnchors;
				for (int i = 0; i < array3.Length; i++)
				{
					IOEntity.LineAnchor lineAnchor = array3[i];
					EntityRef<Door> entityRef = lineAnchor.entityRef;
					if (entityRef.Get(serverside: true).IsValid())
					{
						val.lineAnchors.Add(lineAnchor.ToInfo());
					}
				}
			}
			val.slackLevels.RemoveAt(val.slackLevels.Count - 1);
			if (flag3)
			{
				val.linePoints.Reverse();
				val.slackLevels.Reverse();
				int num2 = val.linePoints.Count - 1;
				foreach (WireLineAnchorInfo lineAnchor2 in val.lineAnchors)
				{
					lineAnchor2.index = num2 - lineAnchor2.index;
				}
			}
			if (val.lineAnchors.Count >= 0)
			{
				List<WireLineAnchorInfo> list = Pool.Get<List<WireLineAnchorInfo>>();
				foreach (WireLineAnchorInfo lineAnchor3 in val.lineAnchors)
				{
					if (lineAnchor3.index == 0L || lineAnchor3.index == val.linePoints.Count - 1)
					{
						list.Add(lineAnchor3);
					}
				}
				foreach (WireLineAnchorInfo item2 in list)
				{
					val.lineAnchors.Remove(item2);
				}
				Pool.Free<WireLineAnchorInfo>(ref list, false);
			}
			if (val.linePoints.Count >= 0)
			{
				val.linePoints.RemoveAt(0);
				val.linePoints.RemoveAt(val.linePoints.Count - 1);
			}
			if (val.slackLevels.Count >= 0)
			{
				val.slackLevels.RemoveAt(val.slackLevels.Count - 1);
			}
			for (int j = 0; j < val.linePoints.Count; j++)
			{
				Vector3 val2 = Quaternion.Euler(iOSlot3.originRotation) * val.linePoints[j];
				Vector3 value = iOSlot3.originPosition + val2;
				val.linePoints[j] = value;
			}
		}
		if (AttemptClearSlot(iOEntity, player, num, flag) && flag2)
		{
			ClientRPC(RpcTarget.Player("RPC_OnWireDisconnected", player), val);
		}
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsActiveItem]
	public void RPC_RequestChangeColor(RPCMessage msg)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (!CanPlayerUseWires(msg.player))
		{
			return;
		}
		NetworkableId uid = msg.read.EntityID();
		IOEntity iOEntity = BaseNetworkable.serverEntities.Find(uid) as IOEntity;
		if ((Object)(object)iOEntity == (Object)null)
		{
			return;
		}
		int index = msg.read.Int32();
		bool flag = msg.read.Bit();
		WireColour wireColour = IntToColour(msg.read.Int32());
		IOEntity.IOSlot iOSlot = (flag ? iOEntity.inputs.ElementAtOrDefault(index) : iOEntity.outputs.ElementAtOrDefault(index));
		if (iOSlot != null)
		{
			IOEntity iOEntity2 = iOSlot.connectedTo.Get();
			if (!((Object)(object)iOEntity2 == (Object)null))
			{
				IOEntity.IOSlot obj = (flag ? iOEntity2.outputs : iOEntity2.inputs)[iOSlot.connectedToSlot];
				iOSlot.wireColour = wireColour;
				iOEntity.SendNetworkUpdate();
				obj.wireColour = wireColour;
				iOEntity2.SendNetworkUpdate();
			}
		}
	}

	public static bool AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput)
	{
		IOEntity iOEntity = (((Object)(object)clearEnt != (Object)null) ? ((Component)clearEnt).GetComponent<IOEntity>() : null);
		IOEntity iOEntity2 = (IOEntity)(object)(isInput ? iOEntity.inputs[clearIndex] : iOEntity.outputs[clearIndex]);
		if ((Object)(object)((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get() == (Object)null)
		{
			return false;
		}
		iOEntity2 = ((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get();
		object obj = Interface.CallHook("OnWireClear", (object)ply, (object)iOEntity, (object)clearIndex, (object)iOEntity2, (object)isInput);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)iOEntity == (Object)null)
		{
			return false;
		}
		if ((Object)(object)ply != (Object)null && !CanModifyEntity(ply, iOEntity))
		{
			return false;
		}
		return iOEntity.Disconnect(clearIndex, isInput);
	}

	public WireColour IntToColour(int i)
	{
		i %= 11;
		return (WireColour)i;
	}

	public bool ValidateLine(List<Vector3> lineList, IOEntity inputEntity, IOEntity outputEntity, BasePlayer byPlayer, int outputIndex)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)byPlayer != (Object)null && byPlayer.IsInCreativeMode && Creative.unlimitedIo)
		{
			return true;
		}
		if (lineList.Count < 2 || lineList.Count > 18)
		{
			return false;
		}
		if ((Object)(object)inputEntity == (Object)null || (Object)(object)outputEntity == (Object)null)
		{
			return false;
		}
		Vector3 val = lineList[0];
		float num = 0f;
		int count = lineList.Count;
		float maxWireLength = GetMaxWireLength(byPlayer);
		for (int i = 1; i < count; i++)
		{
			Vector3 val2 = lineList[i];
			num += Vector3.Distance(val, val2);
			if (num > maxWireLength)
			{
				return false;
			}
			val = val2;
		}
		Vector3 val3 = lineList[count - 1];
		Bounds val4 = outputEntity.bounds;
		((Bounds)(ref val4)).Expand(0.5f);
		if (!((Bounds)(ref val4)).Contains(val3))
		{
			return false;
		}
		Vector3 val5 = ((Component)outputEntity).transform.TransformPoint(lineList[0]);
		val3 = ((Component)inputEntity).transform.InverseTransformPoint(val5);
		Bounds val6 = inputEntity.bounds;
		((Bounds)(ref val6)).Expand(0.5f);
		if (!((Bounds)(ref val6)).Contains(val3))
		{
			return false;
		}
		if ((Object)(object)byPlayer == (Object)null)
		{
			return false;
		}
		Vector3 position = ((Component)outputEntity).transform.TransformPoint(lineList[lineList.Count - 1]);
		if (byPlayer.Distance(position) > 5f && byPlayer.Distance(val5) > 5f)
		{
			return false;
		}
		if (outputIndex >= 0 && outputIndex < outputEntity.outputs.Length && outputEntity.outputs[outputIndex].type == IOEntity.IOType.Industrial && !VerifyLineOfSight(lineList, ((Component)outputEntity).transform.localToWorldMatrix))
		{
			return false;
		}
		return true;
	}

	public bool VerifyLineOfSight(List<Vector3> positions, Matrix4x4 localToWorldSpace)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 worldSpaceA = ((Matrix4x4)(ref localToWorldSpace)).MultiplyPoint3x4(positions[0]);
		for (int i = 1; i < positions.Count; i++)
		{
			Vector3 val = ((Matrix4x4)(ref localToWorldSpace)).MultiplyPoint3x4(positions[i]);
			if (!VerifyLineOfSight(worldSpaceA, val))
			{
				return false;
			}
			worldSpaceA = val;
		}
		return true;
	}

	public bool VerifyLineOfSight(Vector3 worldSpaceA, Vector3 worldSpaceB)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		float maxDistance = Vector3.Distance(worldSpaceA, worldSpaceB);
		Vector3 val = worldSpaceA - worldSpaceB;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(new Ray(worldSpaceB, normalized), 0.01f, list, maxDistance, 2162944, (QueryTriggerInteraction)0);
		bool result = true;
		foreach (RaycastHit item in list)
		{
			BaseEntity entity = item.GetEntity();
			if ((Object)(object)entity != (Object)null && item.IsOnLayer((Layer)8))
			{
				if (entity is VendingMachine)
				{
					result = false;
					break;
				}
			}
			else if (!((Object)(object)entity != (Object)null) || !(entity is Door))
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return result;
	}

	public bool HasPendingPlug()
	{
		if ((Object)(object)pendingPlug.ent != (Object)null)
		{
			return pendingPlug.index != -1;
		}
		return false;
	}

	public bool PendingPlugIsInput()
	{
		if ((Object)(object)pendingPlug.ent != (Object)null && pendingPlug.index != -1)
		{
			return pendingPlug.isInput;
		}
		return false;
	}

	public bool PendingPlugIsType(IOEntity.IOType type)
	{
		if ((Object)(object)pendingPlug.ent == (Object)null || pendingPlug.index == -1)
		{
			return false;
		}
		IOEntity.IOSlot[] array = (pendingPlug.isInput ? pendingPlug.ent.inputs : pendingPlug.ent.outputs);
		if (pendingPlug.index < 0 || pendingPlug.index >= array.Length)
		{
			return false;
		}
		return array[pendingPlug.index].type == type;
	}

	public bool PendingPlugIsOutput()
	{
		if ((Object)(object)pendingPlug.ent != (Object)null && pendingPlug.index != -1)
		{
			return !pendingPlug.isInput;
		}
		return false;
	}

	public bool PendingPlugIsRoot()
	{
		if ((Object)(object)pendingPlug.ent != (Object)null)
		{
			return pendingPlug.ent.IsRootEntity();
		}
		return false;
	}

	private void ResetPendingPlug()
	{
		pendingPlug.ent = null;
		pendingPlug.index = -1;
	}

	public static bool CanPlayerUseWires(BasePlayer player, bool cached = false, float cacheDuration = 1f)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanUseWires", (object)player, (object)cached, (object)cacheDuration);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)player != (Object)null && player.IsInCreativeMode && Creative.unlimitedIo)
		{
			return true;
		}
		if (!player.CanBuild(cached, cacheDuration))
		{
			return false;
		}
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(player.eyes.position, 0.1f, list, 536870912, (QueryTriggerInteraction)2);
		bool result = true;
		foreach (Collider item in list)
		{
			if (!((Component)item).gameObject.CompareTag("IgnoreWireCheck"))
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private static bool CanModifyEntity(BasePlayer player, IOEntity ent)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (ent.AllowWireConnections())
		{
			if (!player.CanBuild(((Component)ent).transform.position, ((Component)ent).transform.rotation, ent.bounds))
			{
				if (player.IsInCreativeMode)
				{
					return Creative.unlimitedIo;
				}
				return false;
			}
			return true;
		}
		return false;
	}
}


public enum WireColour
{
	Gray,
	Red,
	Green,
	Blue,
	Yellow,
	Pink,
	Purple,
	Orange,
	White,
	LightBlue,
	Invisible,
	Count
}


public struct PendingPlug
{
	public IOEntity ent;

	public bool isInput;

	public int index;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Workbench : StorageContainer
{
	public const int blueprintSlot = 0;

	public const int experimentSlot = 1;

	public bool Static;

	public int Workbenchlevel;

	public LootSpawn experimentalItems;

	public GameObjectRef experimentStartEffect;

	public GameObjectRef experimentSuccessEffect;

	public ItemDefinition experimentResource;

	public TechTreeData[] techTrees;

	public static ItemDefinition blueprintBaseDef;

	private ItemDefinition pendingBlueprint;

	private bool creatingBlueprint;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Workbench.OnRpcMessage", 0);
		try
		{
			if (rpc == 2308794761u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_BeginExperiment "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_BeginExperiment", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2308794761u, "RPC_BeginExperiment", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_BeginExperiment(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_BeginExperiment");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4127240744u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TechTreeUnlock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TechTreeUnlock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4127240744u, "RPC_TechTreeUnlock", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_TechTreeUnlock(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_TechTreeUnlock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public IEnumerable<TechTreeData> GetTechTrees()
	{
		TechTreeData[] array = techTrees;
		foreach (TechTreeData techTreeData in array)
		{
			if (techTreeData.IsAllowedInEra(Server.Era) && techTreeData.IsAllowedInGameMode(base.isServer))
			{
				yield return techTreeData;
			}
		}
	}

	public TechTreeData GetTechTreeForLevel(int level)
	{
		foreach (TechTreeData techTree in GetTechTrees())
		{
			if (techTree.techTreeLevel == level)
			{
				return techTree;
			}
		}
		return null;
	}

	public int GetScrapForExperiment()
	{
		if (Workbenchlevel == 1)
		{
			return 75;
		}
		if (Workbenchlevel == 2)
		{
			return 300;
		}
		if (Workbenchlevel == 3)
		{
			return 1000;
		}
		Debug.LogWarning((object)"GetScrapForExperiment fucked up big time.");
		return 0;
	}

	public bool IsWorking()
	{
		return HasFlag(Flags.On);
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (children.Count != 0)
		{
			lastPickupError = Phrase.op_Implicit(string.Format(PickupErrors.ItemHasAttachment.translated, pickup.itemTarget.displayName.translated));
			return false;
		}
		return base.CanCompletePickup(player);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_TechTreeUnlock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int id = msg.read.Int32();
		int level = msg.read.Int32();
		TechTreeData techTreeForLevel = GetTechTreeForLevel(level);
		if ((Object)(object)techTreeForLevel == (Object)null)
		{
			return;
		}
		TechTreeData.NodeInstance byID = techTreeForLevel.GetByID(id);
		if (byID == null)
		{
			Debug.Log((object)("Node for unlock not found :" + id));
		}
		else
		{
			if (!techTreeForLevel.PlayerCanUnlock(player, byID))
			{
				return;
			}
			if (byID.IsGroup())
			{
				foreach (int output in byID.outputs)
				{
					TechTreeData.NodeInstance byID2 = techTreeForLevel.GetByID(output);
					if (byID2 != null && (Object)(object)byID2.itemDef != (Object)null)
					{
						player.blueprints.Unlock(byID2.itemDef);
						Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, "techtree", 0, this);
					}
				}
				Debug.Log((object)("Player unlocked group :" + byID.groupName));
			}
			else if ((Object)(object)byID.itemDef != (Object)null && Interface.CallHook("OnTechTreeNodeUnlock", (object)this, (object)byID, (object)player) == null)
			{
				int tax;
				int num = ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out tax);
				int itemid = ItemManager.FindItemDefinition("scrap").itemid;
				if (player.inventory.GetAmount(itemid) >= num + tax)
				{
					player.inventory.Take(null, itemid, num + tax);
					player.blueprints.Unlock(byID.itemDef);
					Interface.CallHook("OnTechTreeNodeUnlocked", (object)this, (object)byID, (object)player);
					Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, "techtree", num + tax, this);
				}
			}
		}
	}

	public static ItemDefinition GetBlueprintTemplate()
	{
		if ((Object)(object)blueprintBaseDef == (Object)null)
		{
			blueprintBaseDef = ItemManager.FindItemDefinition("blueprintbase");
		}
		return blueprintBaseDef;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null || IsWorking())
		{
			return;
		}
		PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;
		int num = Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if (Object.op_Implicit((Object)(object)itemDef.Blueprint) && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if ((Object)(object)pendingBlueprint == (Object)null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("OnExperimentStart", (object)this, (object)player) != null)
			{
				return;
			}
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			base.inventory.SetLocked(isLocked: true);
			((FacepunchBehaviour)this).CancelInvoke((Action)ExperimentComplete);
			((FacepunchBehaviour)this).Invoke((Action)ExperimentComplete, 5f);
			SendNetworkUpdate();
			Interface.CallHook("OnExperimentStarted", (object)this, (object)player);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		((FacepunchBehaviour)this).CancelInvoke((Action)ExperimentComplete);
	}

	public int GetAvailableExperimentResources()
	{
		Item experimentResourceItem = GetExperimentResourceItem();
		if (experimentResourceItem == null || (Object)(object)experimentResourceItem.info != (Object)(object)experimentResource)
		{
			return 0;
		}
		return experimentResourceItem.amount;
	}

	public Item GetExperimentResourceItem()
	{
		return base.inventory.GetSlot(1);
	}

	public void ExperimentComplete()
	{
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		Item experimentResourceItem = GetExperimentResourceItem();
		int scrapForExperiment = GetScrapForExperiment();
		if ((Object)(object)pendingBlueprint == (Object)null)
		{
			Debug.LogWarning((object)"Pending blueprint was null!");
		}
		if (Interface.CallHook("OnExperimentEnd", (object)this) != null)
		{
			return;
		}
		if (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && (Object)(object)pendingBlueprint != (Object)null)
		{
			experimentResourceItem.UseItem(scrapForExperiment);
			Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
			item.blueprintTarget = pendingBlueprint.itemid;
			creatingBlueprint = true;
			if (!item.MoveToContainer(base.inventory, 0))
			{
				item.Drop(GetDropPosition(), GetDropVelocity());
			}
			creatingBlueprint = false;
			if (experimentSuccessEffect.isValid)
			{
				Effect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		SetFlag(Flags.On, b: false);
		pendingBlueprint = null;
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdate();
		Interface.CallHook("OnExperimentEnded", (object)this);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.On, b: false);
		if (base.inventory != null)
		{
			base.inventory.SetLocked(isLocked: false);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.canAcceptItem = ItemFilter;
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if ((targetSlot == 1 && (Object)(object)item.info == (Object)(object)experimentResource) || (targetSlot == 0 && creatingBlueprint))
		{
			return true;
		}
		return false;
	}

	public static int ScrapForResearch(ItemDefinition info, int workbenchLevel, out int tax)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Invalid comparison between Unknown and I4
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Invalid comparison between Unknown and I4
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Invalid comparison between Unknown and I4
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Invalid comparison between Unknown and I4
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		if ((int)info.rarity == 1)
		{
			num = 20;
		}
		if ((int)info.rarity == 2)
		{
			num = 75;
		}
		if ((int)info.rarity == 3)
		{
			num = 125;
		}
		if ((int)info.rarity == 4 || (int)info.rarity == 0)
		{
			num = 500;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null)
		{
			BaseGameMode.ResearchCostResult scrapCostForResearch = activeGameMode.GetScrapCostForResearch(info, ResearchTable.ResearchType.TechTree);
			if (scrapCostForResearch.Scale.HasValue)
			{
				num = Mathf.RoundToInt((float)num * scrapCostForResearch.Scale.Value);
			}
			else if (scrapCostForResearch.Amount.HasValue)
			{
				num = scrapCostForResearch.Amount.Value;
			}
		}
		float taxRateForWorkbenchUnlock = Server.GetTaxRateForWorkbenchUnlock(workbenchLevel);
		tax = 0;
		if (taxRateForWorkbenchUnlock > 0f)
		{
			tax = Mathf.CeilToInt((float)num * (taxRateForWorkbenchUnlock / 100f));
		}
		return num;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}
}


using System;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class WorldItem : BaseEntity, PlayerInventory.ICanMoveFrom
{
	public static readonly Phrase OpenLootTitle = new Phrase("open_loot", "Open");

	public static readonly Phrase PickUpTitle = new Phrase("pick_up", "Pick Up");

	public static readonly Phrase HoldToPickupPhrase = new Phrase("hold_use_to_pickup", "Hold [USE] to pickup");

	[Header("WorldItem")]
	public bool allowPickup = true;

	[NonSerialized]
	public Item item;

	private float pickupStartTime;

	private bool _isInvokingSendItemUpdate;

	protected float eatSeconds = 10f;

	protected float caloriesPerSecond = 1f;

	public override TraitFlag Traits
	{
		get
		{
			if (item != null)
			{
				return item.Traits;
			}
			return base.Traits;
		}
	}

	protected virtual bool CanBePickedUp => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WorldItem.OnRpcMessage", 0);
		try
		{
			if (rpc == 2778075470u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Pickup "));
				}
				TimeWarning val2 = TimeWarning.New("Pickup", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2778075470u, "Pickup", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Pickup(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Pickup");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2145528377 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - PickupTimer "));
				}
				TimeWarning val2 = TimeWarning.New("PickupTimer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2145528377u, "PickupTimer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							PickupTimer(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in PickupTimer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 331989034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(331989034u, "RPC_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override Item GetItem()
	{
		return item;
	}

	public void InitializeItem(Item in_item)
	{
		if (item != null)
		{
			RemoveItem();
		}
		item = in_item;
		if (item != null)
		{
			item.OnDirty += OnItemDirty;
			((Object)this).name = item.info.shortname + " (world)";
			item.SetWorldEntity(this);
			OnItemDirty(item);
			if (base.isServer)
			{
				SingletonComponent<NpcFoodManager>.Instance.Add(this);
			}
		}
	}

	public void RemoveItem()
	{
		if (item != null)
		{
			if (base.isServer)
			{
				SingletonComponent<NpcFoodManager>.Instance.Remove(this);
			}
			item.OnDirty -= OnItemDirty;
			item = null;
		}
	}

	public void DestroyItem()
	{
		if (item != null)
		{
			if (base.isServer)
			{
				SingletonComponent<NpcFoodManager>.Instance.Remove(this);
			}
			item.OnDirty -= OnItemDirty;
			item.Remove();
			item = null;
		}
	}

	protected virtual void OnItemDirty(Item in_item)
	{
		Assert.IsTrue(item == in_item, "WorldItem:OnItemDirty - dirty item isn't ours!");
		if (item != null)
		{
			((Component)this).BroadcastMessage("OnItemChanged", (object)item, (SendMessageOptions)1);
		}
		DoItemNetworking();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.worldItem != null && info.msg.worldItem.item != null)
		{
			Item item = ItemManager.Load(info.msg.worldItem.item, this.item, base.isServer);
			if (item != null)
			{
				InitializeItem(item);
			}
		}
	}

	public override string ToString()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (_name == null)
		{
			if (base.isServer)
			{
				_name = string.Format("{1}[{0}] {2}", (object)(NetworkableId)(((??)net?.ID) ?? default(NetworkableId)), base.ShortPrefabName, this.IsUnityNull() ? "NULL" : ((Object)this).name);
			}
			else
			{
				_name = base.ShortPrefabName;
			}
		}
		return _name;
	}

	public bool CanMoveFrom(BasePlayer player, Item item)
	{
		if ((Object)(object)((item != null) ? ((Component)item.info).GetComponent<ItemModBackpack>() : null) == (Object)null)
		{
			return true;
		}
		return item.parentItem?.parent == player.inventory.containerWear;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (item != null)
		{
			((Component)this).BroadcastMessage("OnItemChanged", (object)item, (SendMessageOptions)1);
		}
	}

	private void DoItemNetworking()
	{
		if (!_isInvokingSendItemUpdate)
		{
			_isInvokingSendItemUpdate = true;
			((FacepunchBehaviour)this).Invoke((Action)SendItemUpdate, 0.1f);
		}
	}

	private void SendItemUpdate()
	{
		_isInvokingSendItemUpdate = false;
		if (item == null)
		{
			return;
		}
		UpdateItem val = Pool.Get<UpdateItem>();
		try
		{
			val.item = item.Save(bIncludeContainer: false, bIncludeOwners: false);
			ClientRPC(RpcTarget.NetworkGroup("UpdateItem"), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && this.item != null && allowPickup && Interface.CallHook("OnItemPickup", (object)this.item, (object)msg.player, (object)this) == null && CanOpenInSafeZone(msg.player))
		{
			ItemModContainer component = ((Component)this.item.info).GetComponent<ItemModContainer>();
			if (!((Object)(object)component != (Object)null) || !component.canLootInWorld || !(component.pickupInWorldDelay > 0f) || !(Mathf.Abs(pickupStartTime + component.pickupInWorldDelay - Time.realtimeSinceStartup) > ConVar.AntiHack.rpc_timer_forgiveness))
			{
				ClientRPC(RpcTarget.NetworkGroup("PickupSound"));
				Item item = this.item;
				Analytics.Azure.OnItemPickup(msg.player, this);
				RemoveItem();
				TryApplyOwnershipOnPickup(msg.player, item);
				msg.player.GiveItem(item, GiveItemReason.PickedUp);
				msg.player.SignalBroadcast(Signal.Gesture, "pickup_item");
			}
		}
	}

	public virtual void TryApplyOwnershipOnPickup(BasePlayer player, Item item)
	{
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void PickupTimer(RPCMessage msg)
	{
		if (msg.player.CanInteract() && item != null && allowPickup && CanOpenInSafeZone(msg.player))
		{
			pickupStartTime = Time.realtimeSinceStartup;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (item != null)
		{
			bool forDisk = info.forDisk;
			info.msg.worldItem = Pool.Get<WorldItem>();
			info.msg.worldItem.item = item.Save(forDisk, bIncludeOwners: false);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		DestroyItem();
	}

	public override void SwitchParent(BaseEntity ent)
	{
		SetParent(ent, parentBone);
	}

	public override void Eat(BaseNpc baseNpc, float timeSpent)
	{
		if (!(eatSeconds <= 0f))
		{
			eatSeconds -= timeSpent;
			baseNpc.AddCalories(caloriesPerSecond * timeSpent);
			if (eatSeconds < 0f)
			{
				DestroyItem();
				Kill();
			}
		}
	}

	private bool CanOpenInSafeZone(BasePlayer looter)
	{
		if (item == null || !item.info.blockStealingInSafeZone)
		{
			return true;
		}
		if (!(this is DroppedItem droppedItem))
		{
			return true;
		}
		if (looter.InSafeZone() && droppedItem.DroppedBy != (ulong)looter.userID && droppedItem.DroppedBy != 0L)
		{
			return false;
		}
		return true;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (item == null || item.contents == null)
		{
			return;
		}
		ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
		if (!((Object)(object)component == (Object)null) && component.canLootInWorld)
		{
			BasePlayer player = rpc.player;
			if (Object.op_Implicit((Object)(object)player) && player.CanInteract() && CanOpenInSafeZone(player) && Interface.CallHook("CanLootEntity", (object)player, (object)this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(item.contents);
				player.inventory.loot.SendImmediate();
				player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), "generic_resizable");
				SendNetworkUpdate();
			}
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;

public class XMasRefill : BaseEntity
{
	public GameObjectRef[] giftPrefabs;

	public List<BasePlayer> goodKids;

	public List<Stocking> stockings;

	public AudioSource bells;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("XMasRefill.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public float GiftRadius()
	{
		return XMas.spawnRange;
	}

	public int GiftsPerPlayer()
	{
		return XMas.giftsPerPlayer;
	}

	public int GiftSpawnAttempts()
	{
		return XMas.giftsPerPlayer * XMas.spawnAttempts;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!XMas.enabled)
		{
			((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 0.1f);
			return;
		}
		goodKids = ((BasePlayer.activePlayerList != null) ? new List<BasePlayer>((IEnumerable<BasePlayer>)BasePlayer.activePlayerList) : new List<BasePlayer>());
		stockings = ((Stocking.stockings != null) ? new List<Stocking>((IEnumerable<Stocking>)Stocking.stockings.Values) : new List<Stocking>());
		((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 60f);
		if (Interface.CallHook("OnXmasLootDistribute", (object)this) == null)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)DistributeLoot, 3f, 0.02f);
			((FacepunchBehaviour)this).Invoke((Action)SendBells, 0.5f);
		}
	}

	public void SendBells()
	{
		ClientRPC(RpcTarget.NetworkGroup("PlayBells"));
	}

	public void RemoveMe()
	{
		if (goodKids.Count == 0 && stockings.Count == 0)
		{
			Kill();
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 60f);
		}
	}

	public void DistributeLoot()
	{
		if (goodKids.Count > 0)
		{
			BasePlayer basePlayer = null;
			foreach (BasePlayer goodKid in goodKids)
			{
				if (!goodKid.IsSleeping() && !goodKid.IsWounded() && goodKid.IsAlive())
				{
					basePlayer = goodKid;
					break;
				}
			}
			if (Object.op_Implicit((Object)(object)basePlayer))
			{
				DistributeGiftsForPlayer(basePlayer);
				goodKids.Remove(basePlayer);
			}
		}
		if (stockings.Count > 0)
		{
			Stocking stocking = stockings[0];
			if ((Object)(object)stocking != (Object)null)
			{
				stocking.SpawnLoot();
			}
			stockings.RemoveAt(0);
		}
	}

	protected bool DropToGround(ref Vector3 pos)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		int num = 1235288065;
		int num2 = 8454144;
		if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) && (TerrainMeta.TopologyMap.GetTopology(pos) & 0x14080) != 0)
		{
			return false;
		}
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) && Object.op_Implicit((Object)(object)TerrainMeta.Collision) && !TerrainMeta.Collision.GetIgnore(pos))
		{
			float height = TerrainMeta.HeightMap.GetHeight(pos);
			pos.y = Mathf.Max(pos.y, height);
		}
		if (!TransformUtil.GetGroundInfo(pos, out var hitOut, 80f, LayerMask.op_Implicit(num)))
		{
			return false;
		}
		if (((1 << ((Component)((RaycastHit)(ref hitOut)).transform).gameObject.layer) & num2) == 0)
		{
			return false;
		}
		pos = ((RaycastHit)(ref hitOut)).point;
		return true;
	}

	public bool DistributeGiftsForPlayer(BasePlayer player)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnXmasGiftsDistribute", (object)this, (object)player) != null)
		{
			return false;
		}
		int num = GiftsPerPlayer();
		int num2 = GiftSpawnAttempts();
		for (int i = 0; i < num2; i++)
		{
			if (num <= 0)
			{
				break;
			}
			Vector2 val = Random.insideUnitCircle * GiftRadius();
			Vector3 pos = ((Component)player).transform.position + new Vector3(val.x, 10f, val.y);
			Quaternion rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
			if (DropToGround(ref pos))
			{
				string resourcePath = giftPrefabs[Random.Range(0, giftPrefabs.Length)].resourcePath;
				BaseEntity baseEntity = GameManager.server.CreateEntity(resourcePath, pos, rot);
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					baseEntity.Spawn();
					num--;
				}
			}
		}
		return true;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ZiplineLaunchPoint : BaseEntity
{
	public Transform LineDeparturePoint;

	public LineRenderer ZiplineRenderer;

	public Collider MountCollider;

	public BoxCollider[] BuildingBlocks;

	public BoxCollider[] PointBuildingBlocks;

	public SpawnableBoundsBlocker[] SpawnableBoundsBlockers;

	public GameObjectRef MountableRef;

	public float LineSlackAmount = 2f;

	public bool RegenLine;

	public List<Vector3> ziplineTargets = new List<Vector3>();

	private List<Vector3> linePoints;

	public GameObjectRef ArrivalPointRef;

	private const float MaxZiplineLength = 185f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ZiplineLaunchPoint.OnRpcMessage", 0);
		try
		{
			if (rpc == 2256922575u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - MountPlayer "));
				}
				TimeWarning val2 = TimeWarning.New("MountPlayer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2256922575u, "MountPlayer", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2256922575u, "MountPlayer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							MountPlayer(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in MountPlayer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		ziplineTargets.Clear();
		linePoints = null;
	}

	public override void PostMapEntitySpawn()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		base.PostMapEntitySpawn();
		FindZiplineTarget(ref ziplineTargets);
		CalculateZiplinePoints(ziplineTargets, ref linePoints);
		if (ziplineTargets.Count == 0)
		{
			Kill();
			return;
		}
		Vector3 val = linePoints[0];
		List<Vector3> list = linePoints;
		if (Vector3.Distance(val, list[list.Count - 1]) > 100f && ArrivalPointRef != null && ArrivalPointRef.isValid)
		{
			GameManager obj = base.gameManager;
			string resourcePath = ArrivalPointRef.resourcePath;
			List<Vector3> list2 = linePoints;
			ZiplineArrivalPoint obj2 = obj.CreateEntity(resourcePath, list2[list2.Count - 1]) as ZiplineArrivalPoint;
			obj2.SetPositions(linePoints);
			obj2.Spawn();
		}
		UpdateBuildingBlocks();
		SendNetworkUpdate();
	}

	public void FindZiplineTarget(ref List<Vector3> foundPositions)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		foundPositions.Clear();
		Vector3 position = LineDeparturePoint.position;
		List<ZiplineTarget> list = Pool.Get<List<ZiplineTarget>>();
		GamePhysics.OverlapSphere<ZiplineTarget>(position + ((Component)this).transform.forward * 185f, 185f, list, 1084293377, (QueryTriggerInteraction)1);
		ZiplineTarget ziplineTarget = null;
		float num = float.MinValue;
		float num2 = 3f;
		foreach (ZiplineTarget item in list)
		{
			if (item.IsChainPoint)
			{
				continue;
			}
			Vector3 position2 = ((Component)item).transform.position;
			Vector3 val = Vector3Ex.WithY(position2, position.y) - position;
			float num3 = Vector3.Dot(((Vector3)(ref val)).normalized, ((Component)this).transform.forward);
			val = position - Vector3Ex.WithY(position2, position.y);
			float num4 = Vector3.Dot(((Vector3)(ref val)).normalized, ((Component)item).transform.forward);
			float num5 = Vector3.Distance(position, position2) + (position2.y - position.y);
			float num6 = num5 * num3 * num4;
			if (!(num3 > 0.2f) || !item.IsValidPosition(position) || !(position.y + num2 > position2.y) || !(num5 > 10f) || !(num6 > num))
			{
				continue;
			}
			if (CheckLineOfSight(position, position2))
			{
				num = num6;
				ziplineTarget = item;
				foundPositions.Clear();
				foundPositions.Add(((Component)ziplineTarget).transform.position);
				continue;
			}
			foreach (ZiplineTarget item2 in list)
			{
				if (!item2.IsChainPoint || !item2.IsValidChainPoint(position, position2))
				{
					continue;
				}
				Vector3 position3 = ((Component)item2).transform.position;
				val = Vector3Ex.WithY(position3, position.y) - position;
				num3 = Vector3.Dot(((Vector3)(ref val)).normalized, ((Component)this).transform.forward);
				val = position - Vector3Ex.WithY(position3, position.y);
				num4 = Vector3.Dot(((Vector3)(ref val)).normalized, ((Component)item2).transform.forward);
				num6 = num5 * num3 * num4;
				bool flag = CheckLineOfSight(position, ((Component)item2).transform.position);
				bool flag2 = CheckLineOfSight(((Component)item2).transform.position, position2);
				if (flag && flag2)
				{
					num = num6;
					ziplineTarget = item;
					foundPositions.Clear();
					foundPositions.Add(((Component)item2).transform.position);
					foundPositions.Add(((Component)ziplineTarget).transform.position);
				}
				else
				{
					if (!flag)
					{
						continue;
					}
					foreach (ZiplineTarget item3 in list)
					{
						if (!((Object)(object)item3 == (Object)(object)item2) && item3.IsValidChainPoint(item2.Target.position, item.Target.position))
						{
							bool num7 = CheckLineOfSight(((Component)item2).transform.position, ((Component)item3).transform.position);
							bool flag3 = CheckLineOfSight(((Component)item3).transform.position, ((Component)item).transform.position);
							if (num7 && flag3)
							{
								num = num6;
								ziplineTarget = item;
								foundPositions.Clear();
								foundPositions.Add(((Component)item2).transform.position);
								foundPositions.Add(((Component)item3).transform.position);
								foundPositions.Add(((Component)ziplineTarget).transform.position);
							}
						}
					}
				}
			}
		}
	}

	public bool CheckLineOfSight(Vector3 from, Vector3 to)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = CalculateLineMidPoint(from, to) - Vector3.up * 0.75f;
		if (GamePhysics.LineOfSightRadius(from, to, 1084293377, 0.5f, 2f) && GamePhysics.LineOfSightRadius(from, val, 1084293377, 0.5f, 2f))
		{
			return GamePhysics.LineOfSightRadius(val, to, 1084293377, 0.5f, 2f);
		}
		return false;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	public void MountPlayer(RPCMessage msg)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		if (IsBusy() || (Object)(object)msg.player == (Object)null || !msg.player.CanInteract() || msg.player.Distance(LineDeparturePoint.position) > 3f || !IsPlayerFacingValidDirection(msg.player) || ziplineTargets.Count == 0)
		{
			return;
		}
		Vector3 position = LineDeparturePoint.position;
		Vector3 val = Vector3Ex.WithY(ziplineTargets[0], position.y) - position;
		Quaternion lineStartRot = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
		val = position - Vector3Ex.WithY(((Component)msg.player).transform.position, position.y);
		Quaternion rot = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
		ZiplineMountable ziplineMountable = base.gameManager.CreateEntity(MountableRef.resourcePath, ((Component)msg.player).transform.position + Vector3.up * 2.1f, rot) as ZiplineMountable;
		if ((Object)(object)ziplineMountable != (Object)null)
		{
			CalculateZiplinePoints(ziplineTargets, ref linePoints);
			ziplineMountable.SetDestination(linePoints, position, lineStartRot);
			ziplineMountable.Spawn();
			ziplineMountable.MountPlayer(msg.player);
			if ((Object)(object)msg.player.GetMounted() != (Object)(object)ziplineMountable)
			{
				ziplineMountable.Kill();
			}
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearBusy, 2f);
		}
	}

	public void ClearBusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.zipline == null)
		{
			info.msg.zipline = Pool.Get<Zipline>();
		}
		info.msg.zipline.destinationPoints = Pool.Get<List<VectorData>>();
		foreach (Vector3 ziplineTarget in ziplineTargets)
		{
			info.msg.zipline.destinationPoints.Add(new VectorData(ziplineTarget.x, ziplineTarget.y, ziplineTarget.z));
		}
	}

	[ServerVar(ServerAdmin = true)]
	public static void report(Arg arg)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		int num2 = 0;
		int num3 = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (current is ZiplineLaunchPoint ziplineLaunchPoint)
				{
					float lineLength = ziplineLaunchPoint.GetLineLength();
					num2++;
					num += lineLength;
				}
				else if (current is ZiplineArrivalPoint)
				{
					num3++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"{num2} ziplines, total distance: {num:F2}, avg length: {num / (float)num2:F2}, arrival points: {num3}");
	}

	[ServerVar(ServerAdmin = true)]
	public static void highlight(Arg arg)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is ZiplineLaunchPoint ziplineLaunchPoint)
				{
					BasePlayer basePlayer = arg.Player();
					object[] obj = new object[7]
					{
						"60",
						Color.red,
						((Component)ziplineLaunchPoint).transform.position,
						null,
						null,
						null,
						null
					};
					List<Vector3> list = ziplineLaunchPoint.ziplineTargets;
					obj[3] = list[list.Count - 1];
					obj[4] = 25;
					obj[5] = 0;
					obj[6] = 0;
					basePlayer.SendConsoleCommand("ddraw.arrow", obj);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.zipline == null)
		{
			return;
		}
		ziplineTargets.Clear();
		foreach (VectorData destinationPoint in info.msg.zipline.destinationPoints)
		{
			ziplineTargets.Add(VectorData.op_Implicit(destinationPoint));
		}
	}

	public void CalculateZiplinePoints(List<Vector3> targets, ref List<Vector3> points)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (points == null && targets.Count != 0)
		{
			Vector3[] array = (Vector3[])(object)new Vector3[targets.Count + 1];
			array[0] = LineDeparturePoint.position;
			for (int i = 0; i < targets.Count; i++)
			{
				array[i + 1] = targets[i];
			}
			float[] array2 = new float[array.Length];
			for (int j = 0; j < array2.Length; j++)
			{
				array2[j] = LineSlackAmount;
			}
			points = new List<Vector3>();
			Bezier.ApplyLineSlack(array, array2, ref points, 25);
		}
	}

	public Vector3 CalculateLineMidPoint(Vector3 start, Vector3 endPoint)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result = Vector3.Lerp(start, endPoint, 0.5f);
		result.y -= LineSlackAmount;
		return result;
	}

	public void UpdateBuildingBlocks()
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		BoxCollider[] buildingBlocks = BuildingBlocks;
		for (int i = 0; i < buildingBlocks.Length; i++)
		{
			((Component)buildingBlocks[i]).gameObject.SetActive(false);
		}
		buildingBlocks = PointBuildingBlocks;
		for (int i = 0; i < buildingBlocks.Length; i++)
		{
			((Component)buildingBlocks[i]).gameObject.SetActive(false);
		}
		SpawnableBoundsBlocker[] spawnableBoundsBlockers = SpawnableBoundsBlockers;
		for (int i = 0; i < spawnableBoundsBlockers.Length; i++)
		{
			((Component)spawnableBoundsBlockers[i]).gameObject.SetActive(false);
		}
		int num = 0;
		if (ziplineTargets.Count <= 0)
		{
			return;
		}
		Vector3 val = Vector3.zero;
		int startIndex2 = 0;
		for (int j = 0; j < linePoints.Count; j++)
		{
			if (j == 0 || (base.isClient && j == 1))
			{
				continue;
			}
			Vector3 val2 = linePoints[j];
			Vector3 val3 = val2 - Vector3Ex.WithY(linePoints[j - 1], val2.y);
			Vector3 normalized = ((Vector3)(ref val3)).normalized;
			if (val != Vector3.zero && Vector3.Dot(normalized, val) < 0.98f)
			{
				if (num < BuildingBlocks.Length)
				{
					SetUpBuildingBlock(BuildingBlocks[num], PointBuildingBlocks[num], SpawnableBoundsBlockers[num++], startIndex2, j - 1);
				}
				startIndex2 = j - 1;
			}
			val = normalized;
		}
		if (num < BuildingBlocks.Length)
		{
			SetUpBuildingBlock(BuildingBlocks[num], PointBuildingBlocks[num], SpawnableBoundsBlockers[num], startIndex2, linePoints.Count - 1);
		}
		void SetUpBuildingBlock(BoxCollider longCollider, BoxCollider pointCollider, SpawnableBoundsBlocker spawnBlocker, int startIndex, int endIndex)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val4 = linePoints[startIndex];
			Vector3 val5 = linePoints[endIndex];
			Vector3 val6 = Vector3.zero;
			Vector3 center = val4 - val5;
			Quaternion rotation = Quaternion.LookRotation(((Vector3)(ref center)).normalized, Vector3.up);
			Vector3 position = Vector3.Lerp(val4, val5, 0.5f);
			((Component)longCollider).transform.position = position;
			((Component)longCollider).transform.rotation = rotation;
			for (int k = startIndex; k < endIndex; k++)
			{
				Vector3 val7 = ((Component)longCollider).transform.InverseTransformPoint(linePoints[k]);
				if (val7.y < val6.y)
				{
					val6 = val7;
				}
			}
			float num2 = Mathf.Abs(val6.y) + 2f;
			float num3 = Vector3.Distance(val4, val5);
			center = (longCollider.size = (spawnBlocker.BoxCollider.size = new Vector3(0.5f, num2, num3) + Vector3.one));
			BoxCollider boxCollider = spawnBlocker.BoxCollider;
			((Vector3)(ref center))..ctor(0f, 0f - num2 * 0.5f, 0f);
			boxCollider.center = center;
			longCollider.center = center;
			((Component)longCollider).gameObject.SetActive(true);
			((Component)pointCollider).transform.position = linePoints[endIndex];
			((Component)pointCollider).gameObject.SetActive(true);
			((Component)spawnBlocker).gameObject.SetActive(true);
			if (base.isServer)
			{
				spawnBlocker.ClearTrees();
			}
		}
	}

	public bool IsPlayerFacingValidDirection(BasePlayer ply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Dot(ply.eyes.HeadForward(), ((Component)this).transform.forward) > 0.2f;
	}

	public float GetLineLength()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints == null)
		{
			return 0f;
		}
		float num = 0f;
		for (int i = 0; i < linePoints.Count - 1; i++)
		{
			num += Vector3.Distance(linePoints[i], linePoints[i + 1]);
		}
		return num;
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class LegacyShelter : DecayEntity
{
	public static readonly int FpShelterDefault = 1;

	[ReplicatedVar]
	public static int max_shelters = 1;

	private static Dictionary<ulong, List<LegacyShelter>> sheltersPerPlayer = new Dictionary<ulong, List<LegacyShelter>>();

	public static Phrase shelterLimitPhrase = new Phrase("shelter_limit_update", "You are now at {0}/{1} shelters");

	public static Phrase shelterLimitReachedPhrase = new Phrase("shelter_limit_reached", "You have reached your shelter limit!");

	[Header("Shelter References")]
	public GameObjectRef smallPrivilegePrefab;

	public GameObjectRef includedDoorPrefab;

	public GameObjectRef includedLockPrefab;

	public EntityRef<EntityPrivilege> entityPrivilege;

	private EntityRef<LegacyShelterDoor> childDoorInstance;

	private EntityRef<BaseLock> lockEntityInstance;

	private Decay decayReference;

	private float lastShelterDecayTick;

	public float lastInteractedWithDoor;

	private ulong shelterOwnerID;

	public static Dictionary<ulong, List<LegacyShelter>> SheltersPerPlayer => sheltersPerPlayer;

	public static Planner.CanBuildResult? CanBuildShelter(BasePlayer player, Construction construction)
	{
		GameObject obj = GameManager.server.FindPrefab(construction.prefabID);
		if (((obj != null) ? obj.GetComponent<BaseEntity>() : null) is LegacyShelter)
		{
			int num = 1;
			Planner.CanBuildResult value2;
			if (sheltersPerPlayer.TryGetValue(player.userID, out var value))
			{
				num = value.Count + 1;
				if (value.Count >= max_shelters)
				{
					value2 = default(Planner.CanBuildResult);
					value2.Result = false;
					value2.Phrase = shelterLimitReachedPhrase;
					return value2;
				}
			}
			value2 = default(Planner.CanBuildResult);
			value2.Result = true;
			value2.Phrase = shelterLimitPhrase;
			value2.Arguments = new string[2]
			{
				num.ToString(),
				max_shelters.ToString()
			};
			return value2;
		}
		return null;
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (sheltersPerPlayer.TryGetValue(shelterOwnerID, out var _))
		{
			sheltersPerPlayer[shelterOwnerID].Remove(this);
			BasePlayer basePlayer = BasePlayer.FindByID(shelterOwnerID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.SendRespawnOptions();
			}
		}
	}

	public static int GetShelterCount(ulong userId)
	{
		if (userId == 0L)
		{
			return 0;
		}
		if (!sheltersPerPlayer.TryGetValue(userId, out var value))
		{
			return 0;
		}
		return value.Count;
	}

	private void AddToShelterList(ulong id)
	{
		if (!sheltersPerPlayer.ContainsKey(id))
		{
			sheltersPerPlayer.Add(id, new List<LegacyShelter>());
		}
		if (!IsShelterInList(sheltersPerPlayer[id], out var _))
		{
			sheltersPerPlayer[id].Add(this);
		}
	}

	private bool IsShelterInList(List<LegacyShelter> shelters, out LegacyShelter thisShelter)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		thisShelter = null;
		if (shelters.Count == 0)
		{
			return false;
		}
		if ((Object)(object)thisShelter == (Object)null)
		{
			return false;
		}
		foreach (LegacyShelter shelter in shelters)
		{
			if (shelter.net.ID == net.ID)
			{
				result = true;
				thisShelter = shelter;
				break;
			}
		}
		return result;
	}

	public override EntityPrivilege GetEntityBuildingPrivilege()
	{
		return GetEntityPrivilege();
	}

	public EntityPrivilege GetEntityPrivilege()
	{
		EntityPrivilege entityPrivilege = this.entityPrivilege.Get(base.isServer);
		if (entityPrivilege.IsValid())
		{
			return entityPrivilege;
		}
		return null;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && child.prefabID == includedDoorPrefab.GetEntity().prefabID && !Application.isLoadingSave)
		{
			Setup(child);
		}
		if (child.prefabID == smallPrivilegePrefab.GetEntity().prefabID)
		{
			EntityPrivilege entity = (EntityPrivilege)child;
			entityPrivilege.Set(entity);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.legacyShelter == null || !base.isServer)
		{
			return;
		}
		shelterOwnerID = info.msg.legacyShelter.ownerId;
		childDoorInstance = new EntityRef<LegacyShelterDoor>(info.msg.legacyShelter.doorID);
		lastInteractedWithDoor = info.msg.legacyShelter.timeSinceInteracted;
		AddToShelterList(shelterOwnerID);
		if (max_shelters == FpShelterDefault)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(shelterOwnerID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.SendRespawnOptions();
			}
		}
	}

	public override void DecayTick()
	{
		base.DecayTick();
		float num = Time.time - lastShelterDecayTick;
		lastShelterDecayTick = Time.time;
		float num2 = num * ConVar.Decay.scale;
		lastInteractedWithDoor += num2;
		UpdateDoorHp();
	}

	public void HasInteracted()
	{
		lastInteractedWithDoor = 0f;
	}

	public void SetupDecay()
	{
		decayReference = PrefabAttribute.server.Find<Decay>(prefabID);
	}

	public override float GetEntityDecayDuration()
	{
		if (lastInteractedWithDoor < 64800f)
		{
			return float.MaxValue;
		}
		if (decayReference == null)
		{
			SetupDecay();
		}
		if (decayReference != null)
		{
			return decayReference.GetDecayDuration(this);
		}
		return float.MaxValue;
	}

	public LegacyShelterDoor GetChildDoor()
	{
		LegacyShelterDoor legacyShelterDoor = childDoorInstance.Get(base.isServer);
		if (legacyShelterDoor.IsValid())
		{
			return legacyShelterDoor;
		}
		return null;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.legacyShelter = Pool.Get<LegacyShelter>();
		info.msg.legacyShelter.doorID = childDoorInstance.uid;
		info.msg.legacyShelter.timeSinceInteracted = lastInteractedWithDoor;
		info.msg.legacyShelter.ownerId = shelterOwnerID;
	}

	public override void OnPlaced(BasePlayer player)
	{
		if (sheltersPerPlayer.TryGetValue(player.userID, out var value) && value.Count >= max_shelters)
		{
			value[0].Kill(DestroyMode.Gib);
		}
		shelterOwnerID = player.userID;
		AddToShelterList(shelterOwnerID);
		player.SendRespawnOptions();
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		LegacyShelterDoor childDoor = GetChildDoor();
		if ((Object)(object)childDoor != (Object)null)
		{
			childDoor.ProtectedHurt(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		LegacyShelterDoor childDoor = GetChildDoor();
		if ((Object)(object)childDoor != (Object)null && !childDoor.IsDead())
		{
			childDoor.Die();
		}
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateDoorHp();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateDoorHp();
	}

	public void ProtectedHurt(HitInfo info)
	{
		info.HitEntity = this;
		base.Hurt(info);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		LegacyShelterDoor childDoor = GetChildDoor();
		if (Object.op_Implicit((Object)(object)childDoor))
		{
			childDoor.SetupDoor(this);
			childDoor.SetMaxHealth(MaxHealth());
			UpdateDoorHp();
		}
		SetupDecay();
	}

	private void Setup(BaseEntity child)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		LegacyShelterDoor legacyShelterDoor = (LegacyShelterDoor)child;
		childDoorInstance.Set(legacyShelterDoor);
		BasePlayer basePlayer = BasePlayer.FindByID(shelterOwnerID);
		((Component)this).GetComponentInChildren<EntityPrivilege>().AddPlayer(basePlayer);
		legacyShelterDoor.SetupDoor(this);
		legacyShelterDoor.SetMaxHealth(MaxHealth());
		UpdateDoorHp();
		BaseEntity baseEntity = GameManager.server.CreateEntity(includedLockPrefab.resourcePath);
		baseEntity.SetParent(legacyShelterDoor, legacyShelterDoor.GetSlotAnchorName(Slot.Lock));
		baseEntity.OwnerID = shelterOwnerID;
		baseEntity.OnDeployed(legacyShelterDoor, basePlayer, null);
		baseEntity.Spawn();
		BaseLock baseLock = (BaseLock)baseEntity;
		if ((Object)(object)baseLock != (Object)null)
		{
			baseLock.CanRemove = false;
		}
		legacyShelterDoor.SetSlot(Slot.Lock, baseEntity);
	}

	private void UpdateDoorHp()
	{
		LegacyShelterDoor childDoor = GetChildDoor();
		if ((Object)(object)childDoor != (Object)null)
		{
			childDoor.SetHealth(base.health);
		}
	}
}


using Rust;
using UnityEngine;

public class LegacyShelterDoor : Door
{
	public GameObjectRef includedLockPrefab;

	private LegacyShelter shelter;

	public void SetupDoor(LegacyShelter shelter)
	{
		this.shelter = shelter;
	}

	public override void DecayTick()
	{
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (Application.isLoadingSave && child.prefabID == includedLockPrefab.GetEntity().prefabID && child.IsValid())
		{
			BaseLock baseLock = (BaseLock)child;
			if ((Object)(object)baseLock != (Object)null)
			{
				baseLock.CanRemove = false;
			}
		}
	}

	protected override void OnPlayerOpenedDoor(BasePlayer p)
	{
		base.OnPlayerOpenedDoor(p);
		if ((Object)(object)shelter != (Object)null)
		{
			shelter.HasInteracted();
		}
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateShelterHp();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateShelterHp();
	}

	public override void Hurt(HitInfo info)
	{
		if (HasParent() && (Object)(object)shelter != (Object)null)
		{
			shelter.ProtectedHurt(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)shelter != (Object)null && !shelter.IsDead())
		{
			shelter.Die();
		}
	}

	public void ProtectedHurt(HitInfo info)
	{
		info.HitEntity = this;
		base.Hurt(info);
	}

	private void UpdateShelterHp()
	{
		if (HasParent() && (Object)(object)shelter != (Object)null)
		{
			shelter.SetHealth(base.health);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ZiplineArrivalPoint : BaseEntity
{
	public LineRenderer Line;

	private Vector3[] linePositions;

	public override void Save(SaveInfo info)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.ZiplineArrival == null)
		{
			info.msg.ZiplineArrival = Pool.Get<ZiplineArrivalPoint>();
		}
		info.msg.ZiplineArrival.linePoints = Pool.Get<List<VectorData>>();
		Vector3[] array = linePositions;
		foreach (Vector3 val in array)
		{
			info.msg.ZiplineArrival.linePoints.Add(VectorData.op_Implicit(val));
		}
	}

	public void SetPositions(List<Vector3> points)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		linePositions = (Vector3[])(object)new Vector3[points.Count];
		for (int i = 0; i < points.Count; i++)
		{
			linePositions[i] = points[i];
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.ZiplineArrival != null && linePositions == null)
		{
			linePositions = (Vector3[])(object)new Vector3[info.msg.ZiplineArrival.linePoints.Count];
			for (int i = 0; i < info.msg.ZiplineArrival.linePoints.Count; i++)
			{
				linePositions[i] = VectorData.op_Implicit(info.msg.ZiplineArrival.linePoints[i]);
			}
		}
	}

	public override void ResetState()
	{
		base.ResetState();
		linePositions = null;
	}
}


using UnityEngine;

public class ZiplineAudio : MonoBehaviour
{
	public ZiplineMountable zipline;

	public SoundDefinition movementLoopDef;

	public SoundDefinition frictionLoopDef;

	public SoundDefinition sparksLoopDef;

	public AnimationCurve movementGainCurve;

	public AnimationCurve movementPitchCurve;

	public AnimationCurve frictionGainCurve;

	public AnimationCurve sparksGainCurve;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ZiplineMountable : BaseMountable
{
	public float MoveSpeed = 4f;

	public float ForwardAdditive = 5f;

	public CapsuleCollider ZipCollider;

	public Transform ZiplineGrabRoot;

	public Transform LeftHandIkPoint;

	public Transform RightHandIkPoint;

	public float SpeedUpTime = 0.6f;

	public bool EditorHoldInPlace;

	private List<Vector3> linePoints;

	public const Flags PushForward = Flags.Reserved1;

	public AnimationCurve MountPositionCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve MountRotationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public float MountEaseInTime = 0.5f;

	public const Flags ShowHandle = Flags.Reserved2;

	public float additiveValue;

	public float currentTravelDistance;

	public TimeSince mountTime;

	private bool hasEnded;

	public List<Collider> ignoreColliders = new List<Collider>();

	private Vector3 lastSafePosition;

	public Vector3 startPosition = Vector3.zero;

	public Vector3 endPosition = Vector3.zero;

	public Quaternion startRotation = Quaternion.identity;

	public Quaternion endRotation = Quaternion.identity;

	public float elapsedMoveTime;

	public bool isAnimatingIn;

	public Vector3 ProcessBezierMovement(float distanceToTravel)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints == null)
		{
			return Vector3.zero;
		}
		float num = 0f;
		for (int i = 0; i < linePoints.Count - 1; i++)
		{
			float num2 = Vector3.Distance(linePoints[i], linePoints[i + 1]);
			if (num + num2 > distanceToTravel)
			{
				float num3 = Mathf.Clamp((distanceToTravel - num) / num2, 0f, 1f);
				return Vector3.Lerp(linePoints[i], linePoints[i + 1], num3);
			}
			num += num2;
		}
		return linePoints[linePoints.Count - 1];
	}

	public Vector3 GetLineEndPoint(bool applyDismountOffset = false)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (applyDismountOffset && linePoints != null)
		{
			List<Vector3> list = linePoints;
			Vector3 val = list[list.Count - 2];
			List<Vector3> list2 = linePoints;
			Vector3 val2 = val - list2[list2.Count - 1];
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			List<Vector3> list3 = linePoints;
			return list3[list3.Count - 1] + normalized * 1.5f;
		}
		List<Vector3> list4 = linePoints;
		return list4?[list4.Count - 1] ?? Vector3.zero;
	}

	public Vector3 GetNextLinePoint(Transform forTransform)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = forTransform.position;
		Vector3 forward = forTransform.forward;
		for (int i = 1; i < linePoints.Count - 1; i++)
		{
			Vector3 val = linePoints[i + 1] - position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			val = linePoints[i - 1] - position;
			Vector3 normalized2 = ((Vector3)(ref val)).normalized;
			float num = Vector3.Dot(forward, normalized);
			float num2 = Vector3.Dot(forward, normalized2);
			if (num > 0f && num2 < 0f)
			{
				return linePoints[i + 1];
			}
		}
		return GetLineEndPoint();
	}

	public override void ResetState()
	{
		base.ResetState();
		additiveValue = 0f;
		currentTravelDistance = 0f;
		hasEnded = false;
		linePoints = null;
	}

	public override float MaxVelocity()
	{
		return MoveSpeed + ForwardAdditive;
	}

	public void SetDestination(List<Vector3> targetLinePoints, Vector3 lineStartPos, Quaternion lineStartRot)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		linePoints = targetLinePoints;
		currentTravelDistance = 0f;
		mountTime = TimeSince.op_Implicit(0f);
		GamePhysics.OverlapSphere(((Component)this).transform.position, 6f, ignoreColliders, 1084293377, (QueryTriggerInteraction)1);
		startPosition = ((Component)this).transform.position;
		startRotation = ((Component)this).transform.rotation;
		lastSafePosition = startPosition;
		endPosition = lineStartPos;
		endRotation = lineStartRot;
		elapsedMoveTime = 0f;
		isAnimatingIn = true;
		((FacepunchBehaviour)this).InvokeRepeating((Action)MovePlayerToPosition, 0f, 0f);
	}

	private void Update()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints == null || base.isClient || isAnimatingIn || hasEnded)
		{
			return;
		}
		float num = (MoveSpeed + additiveValue * ForwardAdditive) * Mathf.Clamp(TimeSince.op_Implicit(mountTime) / SpeedUpTime, 0f, 1f) * Time.smoothDeltaTime;
		currentTravelDistance += num;
		Vector3 val = ProcessBezierMovement(currentTravelDistance);
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		Vector3 position = Vector3Ex.WithY(val, val.y - ZipCollider.height * 0.6f);
		Vector3 position2 = val;
		GamePhysics.CapsuleSweep(position, position2, 0.5f, ((Component)this).transform.forward, num, list, 1084293377, (QueryTriggerInteraction)1);
		foreach (RaycastHit item in list)
		{
			RaycastHit current = item;
			if (!((Object)(object)((RaycastHit)(ref current)).collider == (Object)(object)ZipCollider) && !ignoreColliders.Contains(((RaycastHit)(ref current)).collider) && !((Object)(object)((Component)((RaycastHit)(ref current)).collider).GetComponentInParent<PowerlineNode>() != (Object)null) && !((Object)(object)((Component)((RaycastHit)(ref current)).collider).GetComponent<TreeEntity>() != (Object)null) && !((Object)(object)((Component)((RaycastHit)(ref current)).collider).GetComponentInParent<TreeEntity>() != (Object)null))
			{
				ZiplineMountable componentInParent = ((Component)((RaycastHit)(ref current)).collider).GetComponentInParent<ZiplineMountable>();
				if ((Object)(object)componentInParent != (Object)null)
				{
					componentInParent.EndZipline();
				}
				if (!GetDismountPosition(GetMounted(), out var _, silent: true))
				{
					((Component)this).transform.position = lastSafePosition;
				}
				EndZipline();
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				return;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		if (Vector3.Distance(val, GetLineEndPoint()) < 0.1f)
		{
			((Component)this).transform.position = GetLineEndPoint(applyDismountOffset: true);
			hasEnded = true;
			return;
		}
		if (Vector3.Distance(lastSafePosition, ((Component)this).transform.position) > 0.5f && GetDismountPosition(GetMounted(), out var _, silent: true))
		{
			lastSafePosition = ((Component)this).transform.position;
		}
		Vector3 val2 = val - Vector3Ex.WithY(((Component)this).transform.position, val.y);
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		((Component)this).transform.position = Vector3.Lerp(((Component)this).transform.position, val, Time.deltaTime * 12f);
		((Component)this).transform.forward = normalized;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerServerInput(inputState, player);
		if (linePoints == null)
		{
			return;
		}
		if (hasEnded)
		{
			if (!GetDismountPosition(GetMounted(), out var _, silent: true))
			{
				((Component)this).transform.position = lastSafePosition;
			}
			EndZipline();
		}
		else
		{
			Vector3 position = ((Component)this).transform.position;
			float num = ((GetNextLinePoint(((Component)this).transform).y < position.y + 0.1f && inputState.IsDown(BUTTON.FORWARD)) ? 1f : 0f);
			additiveValue = Mathf.MoveTowards(additiveValue, num, (float)Server.tickrate * ((num > 0f) ? 4f : 2f));
			SetFlag(Flags.Reserved1, additiveValue > 0.5f);
		}
	}

	public void EndZipline()
	{
		DismountAllPlayers();
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public override bool ValidDismountPosition(BasePlayer player, Vector3 disPos)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		((Collider)ZipCollider).enabled = false;
		bool result = base.ValidDismountPosition(player, disPos);
		((Collider)ZipCollider).enabled = true;
		return result;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (linePoints == null)
		{
			return;
		}
		if (info.msg.ziplineMountable == null)
		{
			info.msg.ziplineMountable = Pool.Get<ZiplineMountable>();
		}
		info.msg.ziplineMountable.linePoints = Pool.Get<List<VectorData>>();
		foreach (Vector3 linePoint in linePoints)
		{
			info.msg.ziplineMountable.linePoints.Add(VectorData.op_Implicit(linePoint));
		}
	}

	public void MovePlayerToPosition()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		elapsedMoveTime += Time.deltaTime;
		float num = Mathf.Clamp(elapsedMoveTime / MountEaseInTime, 0f, 1f);
		Vector3 localPosition = Vector3.Lerp(startPosition, endPosition, MountPositionCurve.Evaluate(num));
		Quaternion localRotation = Quaternion.Lerp(startRotation, endRotation, MountRotationCurve.Evaluate(num));
		((Component)this).transform.localPosition = localPosition;
		((Component)this).transform.localRotation = localRotation;
		if (num >= 1f)
		{
			isAnimatingIn = false;
			SetFlag(Flags.Reserved2, b: true);
			mountTime = TimeSince.op_Implicit(0f);
			((FacepunchBehaviour)this).CancelInvoke((Action)MovePlayerToPosition);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && old.HasFlag(Flags.Busy) && !next.HasFlag(Flags.Busy) && !base.IsDestroyed)
		{
			Kill();
		}
	}
}


using UnityEngine;

public class ZiplineTarget : MonoBehaviour
{
	public Transform Target;

	public bool IsChainPoint;

	public float MonumentConnectionDotMin = 0.2f;

	public float MonumentConnectionDotMax = 1f;

	public bool IsValidPosition(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = position - Vector3Ex.WithY(Target.position, position.y);
		float num = Vector3.Dot(((Vector3)(ref val)).normalized, Target.forward);
		if (num >= MonumentConnectionDotMin)
		{
			return num <= MonumentConnectionDotMax;
		}
		return false;
	}

	public bool IsValidChainPoint(Vector3 from, Vector3 to)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = from - Vector3Ex.WithY(Target.position, from.y);
		float num = Vector3.Dot(((Vector3)(ref val)).normalized, Target.forward);
		val = to - Vector3Ex.WithY(Target.position, from.y);
		float num2 = Vector3.Dot(((Vector3)(ref val)).normalized, Target.forward);
		if ((num > 0f && num2 > 0f) || (num < 0f && num2 < 0f))
		{
			return false;
		}
		num2 = Mathf.Abs(num2);
		if (num2 >= MonumentConnectionDotMin)
		{
			return num2 <= MonumentConnectionDotMax;
		}
		return false;
	}
}


public class TriggerVineClimbTip : TriggerBase, IClientComponent
{
}


public class Vine : FacepunchBehaviour
{
	[ClientVar]
	public static bool DRAW_DEBUG;

	[ClientVar]
	public static bool PREVENT_VINE_DRAW;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Spatial;
using UnityEngine;

public class VineLaunchPoint : MonoBehaviour
{
	[Header("References")]
	public GameObjectRef VineMountablePrefab;

	public float MaximumDestinationRange;

	public float MinimumDestinationRange;

	[Header("Arc Settings")]
	public float maxDistanceHeight = -10f;

	public float minDistanceHeight = -4f;

	public int resolution = 30;

	public bool drawArc = true;

	public float angle;

	public float VineSpawnOffset = 0.1f;

	public bool useLevelDirection = true;

	public Transform[] VineArrivalPoints;

	public VineSwingingTree ParentTree;

	private static Grid<VineLaunchPoint> pointGrid = new Grid<VineLaunchPoint>(32, 8096f);

	private bool hasDied;

	private VineMountable spawnedVine
	{
		get
		{
			return ParentTree.GetSpawnedVine(this);
		}
		set
		{
			ParentTree.SetSpawnedVine(this, value);
		}
	}

	public int Index()
	{
		if ((Object)(object)ParentTree != (Object)null)
		{
			for (int i = 0; i < ParentTree.LaunchPoints.Length; i++)
			{
				if ((Object)(object)ParentTree.LaunchPoints[i] == (Object)(object)this)
				{
					return i;
				}
			}
		}
		return -1;
	}

	public Vector3 GetSwingPointAtTime(float time, VineLaunchPoint forPoint)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return GetSwingPointAtTime(time, ((Component)forPoint).transform.position);
	}

	public Vector3 GetSwingPointAtTime(float time, Vector3 forPoint)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = forPoint;
		Vector3 val2 = val - position;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		position += normalized * VineSpawnOffset;
		val += normalized * (0f - VineSpawnOffset);
		float num = Mathx.RemapValClamped(Vector3.Distance(position, val), MinimumDestinationRange, MaximumDestinationRange, 0f, 1f);
		Vector3 point = VineUtils.SampleParabola(position, val, Mathf.Lerp(minDistanceHeight, maxDistanceHeight, num), time, useLevelDirection);
		Vector3 pivot = (position + val) / 2f;
		val2 = position - val;
		return VineUtils.RotateAroundWorldAxis(point, pivot, ((Vector3)(ref val2)).normalized, angle);
	}

	public void ServerInit()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		pointGrid.Add(this, position.x, position.z);
		hasDied = false;
	}

	public void DoServerDestroy()
	{
		if (!hasDied)
		{
			hasDied = true;
			pointGrid.Remove(this);
			VineMountable.NotifyVinesLaunchSiteRemoved(this);
		}
	}

	public void SpawnVineIfPossible(VineSwingingTree fromTree)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		hasDied = false;
		VineMountable vineMountable = spawnedVine;
		PooledList<VineLaunchPoint> val = Pool.Get<PooledList<VineLaunchPoint>>();
		try
		{
			if ((Object)(object)vineMountable != (Object)null)
			{
				if (GetReceivePoints((List<VineLaunchPoint>)(object)val))
				{
					vineMountable.Initialise(this, (List<VineLaunchPoint>)(object)val, vineMountable.WorldSpaceAnchorPoint);
					vineMountable.SendNetworkUpdate();
				}
				return;
			}
			((List<VineLaunchPoint>)(object)val).Clear();
			GetReceivePoints((List<VineLaunchPoint>)(object)val);
			if (((List<VineLaunchPoint>)(object)val).Count <= 0)
			{
				return;
			}
			Vector3 val2 = ((Component)this).transform.TransformPoint(Vector3.forward * VineSpawnOffset);
			PooledList<VineMountable> val3 = Pool.Get<PooledList<VineMountable>>();
			try
			{
				GamePhysics.OverlapSphere<VineMountable>(val2, 5f, (List<VineMountable>)(object)val3, 134217728, (QueryTriggerInteraction)2);
				foreach (VineMountable item in (List<VineMountable>)(object)val3)
				{
					if (!item.HasFlag(BaseEntity.Flags.Reserved1))
					{
						return;
					}
				}
				VineMountable vineMountable2 = GameManager.server.CreateEntity(VineMountablePrefab.resourcePath, val2, Quaternion.identity) as VineMountable;
				if (FindVacantArrivalPoint(vineMountable2, out var worldPos))
				{
					((Component)vineMountable2).transform.position = worldPos;
				}
				spawnedVine = vineMountable2;
				Vector3 vineSpawnPos = fromTree.GetVineSpawnPos((List<VineLaunchPoint>)(object)val);
				vineMountable2.Initialise(this, (List<VineLaunchPoint>)(object)val, vineSpawnPos);
				vineMountable2.Spawn();
				vineMountable2.SendNetworkUpdate();
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnVineKilled()
	{
		spawnedVine = null;
	}

	private bool GetReceivePoints(List<VineLaunchPoint> points)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Vector3 forward = ((Component)this).transform.forward;
		bool result = false;
		PooledList<VineLaunchPoint> val = Pool.Get<PooledList<VineLaunchPoint>>();
		try
		{
			if (!Application.isPlaying)
			{
				((List<VineLaunchPoint>)(object)val).AddRange((IEnumerable<VineLaunchPoint>)Object.FindObjectsByType<VineLaunchPoint>((FindObjectsInactive)0, (FindObjectsSortMode)0));
			}
			else
			{
				pointGrid.Query<VineLaunchPoint>(position.x, position.z, MaximumDestinationRange, (List<VineLaunchPoint>)(object)val);
			}
			foreach (VineLaunchPoint item in (List<VineLaunchPoint>)(object)val)
			{
				if ((Object)(object)item == (Object)(object)this || points.Contains(item))
				{
					continue;
				}
				Vector3 position2 = ((Component)item).transform.position;
				float num = Vector3.Distance(position, Vector3Ex.WithY(position2, position.y));
				if (num > MaximumDestinationRange || num < MinimumDestinationRange)
				{
					continue;
				}
				Vector3 val2 = Vector3Ex.WithY(position2, position.y) - position;
				if (!(Vector3.Angle(forward, ((Vector3)(ref val2)).normalized) > 45f) && !(Vector3.Angle(forward, -((Component)item).transform.forward) > 90f))
				{
					if (!GamePhysics.LineOfSightRadius(position, position2, 1084293377, 0.25f, ParentTree))
					{
						return false;
					}
					Vector3 swingPointAtTime = GetSwingPointAtTime(0.5f, position2);
					if (!GamePhysics.LineOfSightRadius(position, swingPointAtTime, 1084293377, 0.25f, ParentTree))
					{
						return false;
					}
					if (!GamePhysics.LineOfSightRadius(position2, swingPointAtTime, 1084293377, 0.25f, ParentTree))
					{
						return false;
					}
					points.Add(item);
					result = true;
				}
			}
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool FindVacantArrivalPoint(VineMountable forMountable, out Vector3 worldPos)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		if (!forMountable.HasFlag(BaseEntity.Flags.Reserved1))
		{
			worldPos = ((Component)this).transform.TransformPoint(Vector3.forward * VineSpawnOffset);
			return true;
		}
		worldPos = Vector3.zero;
		PooledList<VineMountable> val = Pool.Get<PooledList<VineMountable>>();
		try
		{
			Vis.Entities(((Component)this).transform.position, 2f, (List<VineMountable>)(object)val, 134217728, (QueryTriggerInteraction)2);
			float num = float.MaxValue;
			Transform val2 = null;
			Transform[] vineArrivalPoints = VineArrivalPoints;
			foreach (Transform val3 in vineArrivalPoints)
			{
				Vector3 position = val3.position;
				bool flag = true;
				foreach (VineMountable item in (List<VineMountable>)(object)val)
				{
					if (!item.isClient && !((Object)(object)item == (Object)(object)forMountable) && Vector3.Distance(position, Vector3Ex.WithY(((Component)item).transform.position, position.y)) < 0.1f)
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					float num2 = Vector3.Distance(Vector3Ex.WithY(((Component)forMountable).transform.position, position.y), position);
					if (num2 < num)
					{
						num = num2;
						val2 = val3;
					}
				}
			}
			bool num3 = (Object)(object)val2 != (Object)null;
			if (num3)
			{
				worldPos = val2.position;
			}
			return num3;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public class VineLOD : RendererLOD
{
	public FakePhysicsRope.RenderMode[] renderModesPerLOD;

	public int MaxLodForShadows;
}


using UnityEngine;

public class VineRenderer : FakePhysicsRope
{
	[Header("Swing Settings")]
	public float swingDamp = 5f;

	public float swingStiffness = 20f;
}


using UnityEngine;

public static class VineUtils
{
	public static Vector3 SampleParabola(Vector3 start, Vector3 end, float height, float t, bool useLevelDirection = false)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		float num = t * 2f - 1f;
		if (Mathf.Abs(start.y - end.y) < 0.1f)
		{
			Vector3 val = end - start;
			Vector3 result = start + t * val;
			result.y += ((0f - num) * num + 1f) * height;
			return result;
		}
		Vector3 val2 = end - start;
		Vector3 val3 = end - new Vector3(start.x, end.y, start.z);
		Vector3 val4 = Vector3.Cross(val2, val3);
		Vector3 val5 = ((!useLevelDirection) ? Vector3.Cross(val4, val2) : Vector3.Cross(val4, val3));
		if (end.y > start.y)
		{
			val5 = -val5;
		}
		return start + t * val2 + ((0f - num) * num + 1f) * height * ((Vector3)(ref val5)).normalized;
	}

	public static float FindT(Vector3 start, Vector3 end, float height, Vector3 targetPosition, bool useLevelDirection = false)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.5f;
		float num2 = 0.01f;
		for (num = 0f; num <= 1f; num += num2)
		{
			if (Vector3.Distance(SampleParabola(start, end, height, num, useLevelDirection), targetPosition) < 0.01f)
			{
				return num;
			}
		}
		return -1f;
	}

	public static Vector3 RotateAroundWorldAxis(Vector3 point, Vector3 pivot, Vector3 axis, float angle)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.AngleAxis(angle, axis);
		Vector3 val2 = point - pivot;
		Vector3 val3 = val * val2;
		return pivot + val3;
	}
}


using UnityEngine;

public class VineViewmodel : BaseViewModel
{
	public Transform VineConnectionPoint;
}


using UnityEngine;
using UnityEngine.UI;

public class ShopFrontLootPanel : LootPanel
{
	public Text playerLabelA;

	public Text playerLabelB;

	public GameObject confirmButton;

	public GameObject confirmHelp;

	public GameObject denyButton;

	public GameObject denyHelp;

	public GameObject waitingText;

	public GameObject exchangeInProgressImage;

	public Phrase acceptedPhrase;

	public Phrase noOnePhrase;
}


using UnityEngine;

public class BurstClothCollider : MonoBehaviour, IClientComponent
{
	public float Height;

	public float Radius;

	public void GetParams(out Vector3 pointA, out Vector3 pointB, out Vector3 up, out float halfHeight)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		halfHeight = Height / 2f;
		up = ((Component)this).transform.rotation * Vector3.up;
		pointA = position + up * halfHeight;
		pointB = position - up * halfHeight;
	}
}


using System.Collections.Generic;
using Facepunch.BurstCloth;
using Unity.Mathematics;
using UnityEngine;

public class BurstClothHitBoxCollision : BurstCloth, IClientComponent, IPrefabPreProcess
{
	[Header("Rust Wearable BurstCloth")]
	public bool UseLocalGravity = true;

	public float GravityStrength = 0.8f;

	public float DefaultLength = 1f;

	public float MountedLengthMultiplier;

	public float DuckedLengthMultiplier = 0.5f;

	public float CorpseLengthMultiplier = 0.2f;

	public Transform UpAxis;

	[Header("Collision")]
	public Transform ColliderRoot;

	[Tooltip("Keywords in bone names which should be ignored for collision")]
	public string[] IgnoreKeywords;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	private static void BreakCapsuleIntoSpheres(Transform transform, Vector3 pointA, Vector3 pointB, Vector3 up, float halfHeight, float radius, List<SphereParams> sphereColliders)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pointA - up * radius;
		Vector3 val2 = pointB + up * radius;
		sphereColliders.Add(new SphereParams
		{
			Transform = transform,
			Point = transform.InverseTransformPoint(val),
			Radius = radius
		});
		sphereColliders.Add(new SphereParams
		{
			Transform = transform,
			Point = transform.InverseTransformPoint(val2),
			Radius = radius
		});
		Vector3 val3 = val - up * radius;
		int num = Mathf.CeilToInt(math.max((2f * halfHeight - 4f * radius) / radius, 1f));
		for (int i = 0; i < num; i++)
		{
			sphereColliders.Add(new SphereParams
			{
				Transform = transform,
				Point = transform.InverseTransformPoint(val3 - up * ((float)i * radius)),
				Radius = radius
			});
		}
	}

	protected override void GatherColliders(List<SphereParams> sphereColliders)
	{
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}
}


using EZhex1991.EZSoftBone;
using UnityEngine;

public class GhostSheetSystemSpaceUpdater : MonoBehaviour, IClientComponent
{
	private EZSoftBone[] ezSoftBones;

	private BasePlayer player;

	public void Awake()
	{
		ezSoftBones = ((Component)this).GetComponents<EZSoftBone>();
		player = ((Component)this).gameObject.ToBaseEntity() as BasePlayer;
	}

	public void Update()
	{
		if (ezSoftBones == null || ezSoftBones.Length == 0 || (Object)(object)player == (Object)null)
		{
			return;
		}
		BaseMountable mounted = player.GetMounted();
		if ((Object)(object)mounted != (Object)null)
		{
			SetSimulateSpace(((Component)mounted).transform, collisionEnabled: false);
			return;
		}
		BaseEntity parentEntity = player.GetParentEntity();
		if ((Object)(object)parentEntity != (Object)null)
		{
			SetSimulateSpace(((Component)parentEntity).transform, collisionEnabled: true);
		}
		else
		{
			SetSimulateSpace(null, collisionEnabled: true);
		}
	}

	private void SetSimulateSpace(Transform transform, bool collisionEnabled)
	{
		for (int i = 0; i < ezSoftBones.Length; i++)
		{
			EZSoftBone obj = ezSoftBones[i];
			obj.simulateSpace = transform;
			obj.collisionEnabled = collisionEnabled;
		}
	}
}


using UnityEngine;

public class PartyHatMaterialRandomiser : MonoBehaviour, IItemSetup
{
	public Material[] MaterialOptions;

	public Renderer[] TargetRenderers;

	public void OnItemSetup(Item item)
	{
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class NVGCamera : FacepunchBehaviour, IClothingChanged
{
	public static NVGCamera instance;

	public PostProcessVolume postProcessVolume;

	public GameObject lights;
}


using UnityStandardAssets.ImageEffects;

public class NVGColorCorrection : ColorCorrectionCurves
{
}


using System;
using UnityEngine;
using UnityStandardAssets.ImageEffects;

[ExecuteInEditMode]
[AddComponentMenu("Image Effects/NVG Effect")]
public class NVGEffect : PostEffectsBase, IImageEffect
{
	[Serializable]
	public struct ColorCorrectionParams
	{
		public float saturation;

		public AnimationCurve redChannel;

		public AnimationCurve greenChannel;

		public AnimationCurve blueChannel;
	}

	[Serializable]
	public struct NoiseAndGrainParams
	{
		public float intensityMultiplier;

		public float generalIntensity;

		public float blackIntensity;

		public float whiteIntensity;

		public float midGrey;

		public bool monochrome;

		public Vector3 intensities;

		public Vector3 tiling;

		public float monochromeTiling;

		public FilterMode filterMode;
	}

	public ColorCorrectionParams ColorCorrection1 = new ColorCorrectionParams
	{
		saturation = 1f,
		redChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		}),
		greenChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		}),
		blueChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		})
	};

	public ColorCorrectionParams ColorCorrection2 = new ColorCorrectionParams
	{
		saturation = 1f,
		redChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		}),
		greenChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		}),
		blueChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		})
	};

	public NoiseAndGrainParams NoiseAndGrain = new NoiseAndGrainParams
	{
		intensityMultiplier = 1.5f,
		generalIntensity = 1f,
		blackIntensity = 1f,
		whiteIntensity = 1f,
		midGrey = 0.182f,
		monochrome = true,
		intensities = new Vector3(1f, 1f, 1f),
		tiling = new Vector3(60f, 70f, 80f),
		monochromeTiling = 55f,
		filterMode = (FilterMode)0
	};

	private Texture2D rgbChannelTex1;

	private Texture2D rgbChannelTex2;

	private bool updateTexturesOnStartup = true;

	public Texture2D NoiseTexture;

	private static float NOISE_TILE_AMOUNT = 64f;

	public Shader Shader;

	private Material material;

	private void Awake()
	{
		updateTexturesOnStartup = true;
	}

	private void OnDestroy()
	{
		if ((Object)(object)rgbChannelTex1 != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)rgbChannelTex1);
			rgbChannelTex1 = null;
		}
		if ((Object)(object)rgbChannelTex2 != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)rgbChannelTex2);
			rgbChannelTex2 = null;
		}
		if ((Object)(object)material != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)material);
			material = null;
		}
	}

	private void UpdateColorCorrectionTexture(ColorCorrectionParams param, ref Texture2D tex)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		if (param.redChannel != null && param.greenChannel != null && param.blueChannel != null)
		{
			for (float num = 0f; num <= 1f; num += 0.003921569f)
			{
				float num2 = Mathf.Clamp(param.redChannel.Evaluate(num), 0f, 1f);
				float num3 = Mathf.Clamp(param.greenChannel.Evaluate(num), 0f, 1f);
				float num4 = Mathf.Clamp(param.blueChannel.Evaluate(num), 0f, 1f);
				tex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num2, num2, num2));
				tex.SetPixel((int)Mathf.Floor(num * 255f), 1, new Color(num3, num3, num3));
				tex.SetPixel((int)Mathf.Floor(num * 255f), 2, new Color(num4, num4, num4));
			}
			tex.Apply();
		}
	}

	public void UpdateTextures()
	{
		((PostEffectsBase)this).CheckResources();
		UpdateColorCorrectionTexture(ColorCorrection1, ref rgbChannelTex1);
		UpdateColorCorrectionTexture(ColorCorrection2, ref rgbChannelTex2);
	}

	public override bool CheckResources()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Expected O, but got Unknown
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Expected O, but got Unknown
		((PostEffectsBase)this).CheckSupport(false);
		material = ((PostEffectsBase)this).CheckShaderAndCreateMaterial(Shader, material);
		if ((Object)(object)rgbChannelTex1 == (Object)null || (Object)(object)rgbChannelTex2 == (Object)null)
		{
			rgbChannelTex1 = new Texture2D(256, 4, (TextureFormat)5, false, true)
			{
				hideFlags = (HideFlags)52,
				wrapMode = (TextureWrapMode)1
			};
			rgbChannelTex2 = new Texture2D(256, 4, (TextureFormat)5, false, true)
			{
				hideFlags = (HideFlags)52,
				wrapMode = (TextureWrapMode)1
			};
		}
		if (!base.isSupported)
		{
			((PostEffectsBase)this).ReportAutoDisable();
		}
		return base.isSupported;
	}

	public bool IsActive()
	{
		if (((Behaviour)this).enabled && ((PostEffectsBase)this).CheckResources())
		{
			return (Object)(object)NoiseTexture != (Object)null;
		}
		return false;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		if (!((PostEffectsBase)this).CheckResources())
		{
			Graphics.Blit((Texture)(object)source, destination);
			if ((Object)(object)NoiseTexture == (Object)null)
			{
				Debug.LogWarning((object)"[NVGEffect] Noise & Grain effect failing as noise texture is not assigned. please assign.", (Object)(object)((Component)this).transform);
			}
			return;
		}
		if (updateTexturesOnStartup)
		{
			UpdateTextures();
			updateTexturesOnStartup = false;
		}
		material.SetTexture("_MainTex", (Texture)(object)source);
		material.SetTexture("_RgbTex1", (Texture)(object)rgbChannelTex1);
		material.SetFloat("_Saturation1", ColorCorrection1.saturation);
		material.SetTexture("_RgbTex2", (Texture)(object)rgbChannelTex2);
		material.SetFloat("_Saturation2", ColorCorrection2.saturation);
		material.SetTexture("_NoiseTex", (Texture)(object)NoiseTexture);
		material.SetVector("_NoisePerChannel", Vector4.op_Implicit(NoiseAndGrain.monochrome ? Vector3.one : NoiseAndGrain.intensities));
		material.SetVector("_NoiseTilingPerChannel", Vector4.op_Implicit(NoiseAndGrain.monochrome ? (Vector3.one * NoiseAndGrain.monochromeTiling) : NoiseAndGrain.tiling));
		material.SetVector("_MidGrey", Vector4.op_Implicit(new Vector3(NoiseAndGrain.midGrey, 1f / (1f - NoiseAndGrain.midGrey), -1f / NoiseAndGrain.midGrey)));
		material.SetVector("_NoiseAmount", Vector4.op_Implicit(new Vector3(NoiseAndGrain.generalIntensity, NoiseAndGrain.blackIntensity, NoiseAndGrain.whiteIntensity) * NoiseAndGrain.intensityMultiplier));
		if (Object.op_Implicit((Object)(object)NoiseTexture))
		{
			((Texture)NoiseTexture).wrapMode = (TextureWrapMode)0;
			((Texture)NoiseTexture).filterMode = NoiseAndGrain.filterMode;
		}
		RenderTexture.active = destination;
		float num = (float)((Texture)NoiseTexture).width * 1f;
		float num2 = 1f * (float)((Texture)source).width / NOISE_TILE_AMOUNT;
		GL.PushMatrix();
		GL.LoadOrtho();
		float num3 = 1f * (float)((Texture)source).width / (1f * (float)((Texture)source).height);
		float num4 = 1f / num2;
		float num5 = num4 * num3;
		float num6 = num / ((float)((Texture)NoiseTexture).width * 1f);
		material.SetPass(0);
		GL.Begin(7);
		for (float num7 = 0f; num7 < 1f; num7 += num4)
		{
			for (float num8 = 0f; num8 < 1f; num8 += num5)
			{
				float num9 = Random.Range(0f, 1f);
				float num10 = Random.Range(0f, 1f);
				num9 = Mathf.Floor(num9 * num) / num;
				num10 = Mathf.Floor(num10 * num) / num;
				float num11 = 1f / num;
				GL.MultiTexCoord2(0, num9, num10);
				GL.MultiTexCoord2(1, 0f, 0f);
				GL.Vertex3(num7, num8, 0.1f);
				GL.MultiTexCoord2(0, num9 + num6 * num11, num10);
				GL.MultiTexCoord2(1, 1f, 0f);
				GL.Vertex3(num7 + num4, num8, 0.1f);
				GL.MultiTexCoord2(0, num9 + num6 * num11, num10 + num6 * num11);
				GL.MultiTexCoord2(1, 1f, 1f);
				GL.Vertex3(num7 + num4, num8 + num5, 0.1f);
				GL.MultiTexCoord2(0, num9, num10 + num6 * num11);
				GL.MultiTexCoord2(1, 0f, 1f);
				GL.Vertex3(num7, num8 + num5, 0.1f);
			}
		}
		GL.End();
		GL.PopMatrix();
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ColorCorrectionParams
{
	public float saturation;

	public AnimationCurve redChannel;

	public AnimationCurve greenChannel;

	public AnimationCurve blueChannel;
}


using System;
using UnityEngine;

[Serializable]
public struct NoiseAndGrainParams
{
	public float intensityMultiplier;

	public float generalIntensity;

	public float blackIntensity;

	public float whiteIntensity;

	public float midGrey;

	public bool monochrome;

	public Vector3 intensities;

	public Vector3 tiling;

	public float monochromeTiling;

	public FilterMode filterMode;
}


public class NVGToggle : ItemEventFlag
{
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class Beehive : StorageContainer, IHeatSourceListener, ISplashable
{
	[Header("Beehive Settings")]
	public ItemDefinition HoneyCombDefinition;

	public ItemDefinition BeeNucleusDefinition;

	public float growthRate = 0.05f;

	public float beeStingTime = 2f;

	[Header("References")]
	public TriggerHurtEx hurtTrigger;

	public GameObjectRef masterSwarm;

	public const Flags HasNucleus = Flags.Reserved12;

	public const Flags HasBees = Flags.Reserved13;

	public const Flags AngryBees = Flags.Reserved14;

	[ServerVar(Help = "How long before a Beehive will update")]
	public static float updateHiveInterval = 120f;

	[ServerVar(Help = "How long before the Beehive will perform temperature and inside checks")]
	public static float updateHiveStatsInterval = 120f;

	[ServerVar(Help = "How much the Nucleus's XP should be increased per honeycomb generated")]
	public static int xpIncreasePerHoneycomb = 2;

	private static Vector3[] outsideLookupDirs;

	private bool hasNucleus;

	private float createNewCombAccumulator;

	private float honeyCombProductionMultiplier = 2f;

	private TimeSince timeSinceAngryBees;

	private TimeCachedValue<float> temperatureExposure;

	private TimeCachedValue<float> humidityExposure;

	private TimeCachedValue<bool> outsideCheck;

	private float serverHumidity;

	private float serverTemperature;

	private bool serverOutside;

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (HasFlag(Flags.Reserved13) || HasFlag(Flags.Reserved12))
		{
			lastPickupError = Phrase.op_Implicit(string.Format(PickupErrors.ItemMustBeEmpty.translated, pickup.itemTarget.displayName.translated));
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public bool IsOutsideAccurate()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return SocketMod_Inside.IsOutside(((Component)this).transform.position + Vector3.up * 0.2f, Quaternion.identity, outsideLookupDirs);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer && info.fromDisk && info.msg.beehive != null)
		{
			createNewCombAccumulator = info.msg.beehive.currentProgress;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.beehive = Pool.Get<Beehive>();
		info.msg.beehive.currentProgress = createNewCombAccumulator;
		if (!info.forDisk)
		{
			info.msg.beehive.temperature = serverTemperature;
			info.msg.beehive.inside = serverOutside;
			info.msg.beehive.humidity = serverHumidity;
		}
	}

	public override void OnItemRemovedFromStack(Item item, int amount)
	{
		base.OnItemRemovedFromStack(item, amount);
		OnItemAddedOrRemoved(item, added: false);
	}

	public override void OnItemAddedToStack(Item item, int amount)
	{
		base.OnItemAddedToStack(item, amount);
		OnItemAddedOrRemoved(item, added: true);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		base.OnItemAddedOrRemoved(item, added);
		CheckNucleus();
		float num = base.inventory.GetAmount(HoneyCombDefinition.itemid, onlyUsableAmounts: false);
		SetFlag(Flags.Reserved13, num > 0f && hasNucleus);
		if (!added && (Object)(object)item.info == (Object)(object)HoneyCombDefinition)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(base.LastLootedBy);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsAlive() && !basePlayer.IsNpc && basePlayer.isServer)
			{
				timeSinceAngryBees = TimeSince.op_Implicit(0f);
				SetFlag(Flags.Reserved14, b: true);
			}
		}
		if (base.inventory.IsFull(checkForPartialStacks: true))
		{
			StopHive();
		}
	}

	private void OnPhysicsNeighbourChanged()
	{
		TimeWarning val = TimeWarning.New("Beehive.OnPhysicsNeighbourChanged", 0);
		try
		{
			CalculateQualifiers(force: true);
			SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		if (!base.isClient)
		{
			CheckNucleus();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		CalculateQualifiers(force: true);
		CheckNucleus();
		((FacepunchBehaviour)this).InvokeRepeating((Action)HiveUpdateTick, 0f, 1f);
	}

	public void OnHeatSourceChanged()
	{
		CalculateQualifiers(force: true);
		SendNetworkUpdate();
	}

	private void HiveUpdateTick()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(timeSinceAngryBees) > beeStingTime)
		{
			SetFlag(Flags.Reserved14, b: false);
		}
	}

	private void GenerateHoneyComb()
	{
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		float num = base.inventory.GetAmount(HoneyCombDefinition.itemid, onlyUsableAmounts: false);
		SetFlag(Flags.Reserved13, num > 0f && hasNucleus);
		createNewCombAccumulator += growthRate * honeyCombProductionMultiplier;
		if (!(createNewCombAccumulator >= 1f))
		{
			return;
		}
		createNewCombAccumulator = 0f;
		if (hasNucleus)
		{
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				int dataInt = slot.instanceData.dataInt;
				if (NucleusGrading.XpToGrade(dataInt) != NucleusGrading.NucleusGrade.Grade1)
				{
					dataInt += xpIncreasePerHoneycomb;
					SetNucleusData(slot, dataInt);
				}
			}
		}
		Item item = ItemManager.Create(HoneyCombDefinition, 1, 0uL);
		if (!item.MoveToContainer(base.inventory))
		{
			StopHive();
			item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
		}
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (targetSlot == 0)
		{
			return item.info.shortname.Equals(allowedItem.shortname);
		}
		if (targetSlot > 0)
		{
			return item.info.shortname.Equals(allowedItem2.shortname);
		}
		return base.ItemFilter(item, targetSlot);
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		return (Object)(object)splashType == (Object)(object)WaterTypes.RadioactiveWaterItemDef;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		if ((Object)(object)splashType == (Object)(object)WaterTypes.RadioactiveWaterItemDef)
		{
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				hasNucleus = (Object)(object)((Component)slot.info).GetComponent<ItemModBeehiveNucleus>() != (Object)null;
				if (hasNucleus)
				{
					base.inventory.Remove(slot);
					slot.Remove();
				}
			}
			return amount;
		}
		return amount;
	}

	private void SetNucleusData(Item targetItem, int xp)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		if (targetItem != null)
		{
			targetItem.instanceData = new InstanceData
			{
				ShouldPool = false,
				dataInt = xp
			};
		}
	}

	private void CheckNucleus()
	{
		if (base.inventory == null)
		{
			return;
		}
		Item slot = base.inventory.GetSlot(0);
		if (slot != null)
		{
			hasNucleus = (Object)(object)((Component)slot.info).GetComponent<ItemModBeehiveNucleus>() != (Object)null;
			if (slot == null || slot.instanceData == null || (slot.instanceData.dataInt == 0 && slot.instanceData.dataFloat == 0f))
			{
				SetNucleusData(slot, 0);
			}
			createNewCombAccumulator = 0f;
		}
		else
		{
			hasNucleus = false;
		}
		SetFlag(Flags.Reserved12, hasNucleus);
		if (hasNucleus)
		{
			StartHive();
		}
		else
		{
			StopHive();
		}
	}

	private void StartHive()
	{
		if (!((FacepunchBehaviour)this).IsInvoking((Action)UpdateGrowthRate))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateGrowthRate, 0f, updateHiveInterval);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)GenerateHoneyComb))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)GenerateHoneyComb, updateHiveInterval, updateHiveInterval);
		}
		SetFlag(Flags.On, b: true);
		CalculateQualifiers(force: true);
		SendNetworkUpdate();
	}

	private void StopHive()
	{
		if (((FacepunchBehaviour)this).IsInvoking((Action)UpdateGrowthRate))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateGrowthRate);
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)GenerateHoneyComb))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)GenerateHoneyComb);
		}
		SetFlag(Flags.On, b: false);
		SendNetworkUpdate();
	}

	public float CalculateRain()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			SingletonComponent<NpcFireManager>.Instance.GetFiresAround(((Component)this).transform.position, 2f, (List<BaseEntity>)(object)val);
			if (((List<BaseEntity>)(object)val).Count > 0)
			{
				return 0f;
			}
			if (!IsOutside())
			{
				return 0f;
			}
			return Climate.GetRain(((Component)this).transform.position);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public float CalculateTemperature()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		float temperature = Climate.GetTemperature(((Component)this).transform.position);
		float num = GrowableEntity.CalculateArtificialTemperature(((Component)this).transform);
		bool flag = num >= 10f;
		bool flag2 = temperature < 10f;
		bool flag3 = temperature < 16f && !flag2;
		if (flag)
		{
			if (flag3)
			{
				return 20f;
			}
			if (flag2)
			{
				return 16f;
			}
		}
		return temperature + num;
	}

	private void CalculateQualifiers(bool force = false)
	{
		TimeWarning val = TimeWarning.New("Beehive.CalculateQualifiers", 0);
		try
		{
			if (temperatureExposure == null)
			{
				temperatureExposure = new TimeCachedValue<float>
				{
					refreshCooldown = updateHiveStatsInterval,
					refreshRandomRange = 5f,
					updateValue = CalculateTemperature
				};
			}
			if (outsideCheck == null)
			{
				outsideCheck = new TimeCachedValue<bool>
				{
					refreshCooldown = updateHiveStatsInterval,
					refreshRandomRange = 5f,
					updateValue = IsOutsideAccurate
				};
			}
			if (humidityExposure == null)
			{
				humidityExposure = new TimeCachedValue<float>
				{
					refreshCooldown = updateHiveStatsInterval,
					refreshRandomRange = 5f,
					updateValue = CalculateRain
				};
			}
			serverHumidity = humidityExposure.Get(force);
			serverTemperature = temperatureExposure.Get(force);
			serverOutside = outsideCheck.Get(force);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void UpdateGrowthRate()
	{
		TimeWarning val = TimeWarning.New("Beehive.UpdateGrowthRate", 0);
		try
		{
			CalculateQualifiers();
			float num = serverTemperature;
			float num2 = ((num < 28f) ? ((num < 10f) ? 0.010000001f : ((!(num < 16f)) ? 0.1f : 0.05f)) : ((!(num < 40f)) ? 0.010000001f : 0.05f));
			growthRate = num2;
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				switch (NucleusGrading.XpToGrade(slot.instanceData.dataInt))
				{
				case NucleusGrading.NucleusGrade.Grade2:
					growthRate *= 2f;
					break;
				case NucleusGrading.NucleusGrade.Grade1:
					growthRate *= 3f;
					break;
				}
			}
			if (serverHumidity >= 0.5f)
			{
				growthRate *= 0.5f;
			}
			if (!serverOutside)
			{
				growthRate = 0f;
			}
			SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void DropItems(BaseEntity initiator = null)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		int index = -1;
		for (int i = 0; i < base.inventory.itemList.Count; i++)
		{
			if ((Object)(object)base.inventory.itemList[i].info == (Object)(object)BeeNucleusDefinition)
			{
				flag = true;
				index = i;
			}
		}
		if (flag && base.inventory.Remove(base.inventory.itemList[index]))
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(masterSwarm.resourcePath, ((Component)this).transform.position + Vector3.up * 1.5f, Quaternion.identity);
			if (creatorEntity is BasePlayer basePlayer)
			{
				baseEntity.creatorEntity = basePlayer;
				baseEntity.OwnerID = basePlayer.userID;
			}
			baseEntity.Spawn();
		}
		base.DropItems(initiator);
	}

	static Beehive()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = new Vector3[5];
		Vector3 val = new Vector3(0f, 1f, 0f);
		array[0] = ((Vector3)(ref val)).normalized;
		val = new Vector3(1f, 0f, 0f);
		array[1] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, 1f);
		array[2] = ((Vector3)(ref val)).normalized;
		val = new Vector3(-1f, 0f, 0f);
		array[3] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, -1f);
		array[4] = ((Vector3)(ref val)).normalized;
		outsideLookupDirs = (Vector3[])(object)array;
	}
}


using UnityEngine;

public class BeehiveLootPanel : LootPanel
{
	[Header("Info Bars")]
	public InfoBar Indoors;

	public InfoBar Humidity;

	public InfoBar Temperature;

	public InfoBar Overall;

	[Header("Grids")]
	public LootGrid LootGrid_Input;

	public LootGrid LootGrid_Output;

	[Header("Status")]
	public StatusPanel status;

	public static readonly Phrase YesIndoors = new Phrase("beehive.indoors.yes", "YES");

	public static readonly Phrase NoIndoors = new Phrase("beehive.indoors.no", "NO");
}


using UnityEngine;

public class IdentifierConfig : IOConfig<IRemoteControllable>
{
	[HideInInspector]
	public string id;
}


using System;

[Flags]
public enum RemoteControllableControls
{
	None = 0,
	Movement = 1,
	Mouse = 2,
	SprintAndDuck = 4,
	Fire = 8,
	Reload = 0x10,
	Crosshair = 0x20
}


using UnityEngine;

public interface IRemoteControllable
{
	bool RequiresMouse { get; }

	float MaxRange { get; }

	RemoteControllableControls RequiredControls { get; }

	CameraViewerId? ControllingViewerId { get; }

	bool CanPing { get; }

	Transform GetEyes();

	float GetFovScale();

	BaseEntity GetEnt();

	string GetIdentifier();

	float Health();

	float MaxHealth();

	void UpdateIdentifier(string newID, bool clientSend = false);

	void RCSetup();

	void RCShutdown();

	bool CanControl(ulong playerID);

	void UserInput(InputState inputState, CameraViewerId viewerID);

	bool InitializeControl(CameraViewerId viewerID);

	void StopControl(CameraViewerId viewerID);
}


using System;

public struct CameraViewerId : IEquatable<CameraViewerId>
{
	public readonly ulong SteamId;

	public readonly long ConnectionId;

	public CameraViewerId(ulong steamId, long connectionId)
	{
		SteamId = steamId;
		ConnectionId = connectionId;
	}

	public bool Equals(CameraViewerId other)
	{
		if (SteamId == other.SteamId)
		{
			return ConnectionId == other.ConnectionId;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is CameraViewerId other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		ulong steamId = SteamId;
		int num = steamId.GetHashCode() * 397;
		long connectionId = ConnectionId;
		return num ^ connectionId.GetHashCode();
	}

	public static bool operator ==(CameraViewerId left, CameraViewerId right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(CameraViewerId left, CameraViewerId right)
	{
		return !left.Equals(right);
	}
}


public class ClanTable : BaseCombatEntity
{
}


using System;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class Composter : StorageContainer
{
	[Header("Composter")]
	public ItemDefinition FertilizerDef;

	[Tooltip("If enabled, entire item stacks will be composted each tick, instead of a single item of a stack.")]
	public bool CompostEntireStack;

	public float fertilizerProductionProgress;

	protected float UpdateInterval => Server.composterUpdateInterval;

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(InventoryItemFilter));
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateComposting, UpdateInterval, UpdateInterval, UpdateInterval * 0.1f);
	}

	public bool InventoryItemFilter(Item item, int targetSlot)
	{
		if (item == null)
		{
			return false;
		}
		if ((Object)(object)((Component)item.info).GetComponent<ItemModCompostable>() != (Object)null || ItemIsFertilizer(item))
		{
			return true;
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.composter = Pool.Get<Composter>();
		info.msg.composter.fertilizerProductionProgress = fertilizerProductionProgress;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.composter != null)
		{
			fertilizerProductionProgress = info.msg.composter.fertilizerProductionProgress;
		}
	}

	public bool ItemIsFertilizer(Item item)
	{
		return item.info.shortname == "fertilizer";
	}

	public void UpdateComposting()
	{
		if (Interface.CallHook("OnComposterUpdate", (object)this) != null)
		{
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				CompostItem(slot);
			}
		}
	}

	public void CompostItem(Item item)
	{
		if (!ItemIsFertilizer(item))
		{
			ItemModCompostable component = ((Component)item.info).GetComponent<ItemModCompostable>();
			if (!((Object)(object)component == (Object)null))
			{
				int num = ((!CompostEntireStack) ? 1 : item.amount);
				item.UseItem(num);
				fertilizerProductionProgress += (float)num * component.TotalFertilizerProduced;
				ProduceFertilizer(Mathf.FloorToInt(fertilizerProductionProgress));
			}
		}
	}

	public void ProduceFertilizer(int amount)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (amount > 0)
		{
			Item item = ItemManager.Create(FertilizerDef, amount, 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
			fertilizerProductionProgress -= amount;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ComputerMenu : UIDialog
{
	public RectTransform bookmarkContainer;

	public GameObject bookmarkPrefab;

	public List<RCBookmarkEntry> activeEntries = new List<RCBookmarkEntry>();
}


using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class RCBookmarkEntry : MonoBehaviour
{
	private ComputerMenu owner;

	public RectTransform connectButton;

	public RectTransform disconnectButton;

	public RawImage onlineIndicator;

	public RawImage offlineIndicator;

	public GameObject selectedindicator;

	public Image backgroundImage;

	public Color selectedColor;

	public Color activeColor;

	public Color inactiveColor;

	public Text nameLabel;

	public EventTrigger eventTrigger;

	public string identifier { get; private set; }

	public bool isSelected { get; private set; }

	public bool isControlling { get; private set; }
}


public interface IRemoteControllableClientCallbacks : IRemoteControllable
{
}


using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UI;

public class RCMenu : ComputerMenu
{
	public Image backgroundOpaque;

	public InputField newBookmarkEntryField;

	public NeedsCursor needsCursor;

	public float hiddenOffset = -256f;

	public RectTransform devicesPanel;

	private Vector3 initialDevicesPosition;

	public static bool isControllingCamera;

	public CanvasGroup overExposure;

	public CanvasGroup interference;

	public float interferenceFadeDuration = 0.2f;

	public float rangeInterferenceScale = 10000f;

	public Text timeText;

	public Text watchedDurationText;

	public Text deviceNameText;

	public Text noSignalText;

	public Text healthText;

	public GameObject healthBarParent;

	public RectTransform healthBarBackground;

	public RectTransform healthBarFill;

	public SoundDefinition bookmarkPressedSoundDef;

	public GameObject[] hideIfStatic;

	public GameObject readOnlyIndicator;

	[FormerlySerializedAs("crosshair")]
	public GameObject aimCrosshair;

	public GameObject generalCrosshair;

	public float fogOverrideDensity = 0.1f;

	public float autoTurretFogDistance = 30f;

	public float autoTurretDotBaseScale = 2f;

	public float autoTurretDotGrowScale = 4f;

	public PingManager PingManager;

	public ScrollRectSettable scrollRect;

	public Phrase Phrase_NoSignal = new Phrase("no_signal", "No Signal");

	public Phrase Phrase_CameraDisabled = new Phrase("weak_signal", "Weak Signal");
}


using Rust;
using UnityEngine;

public class CookingWorkbench : MixingTable
{
	public GameObjectRef SubOvenPrefab;

	public Transform SubOvenPosition;

	[Tooltip("The recipes that will set the OvenCooking flag (to play the oven effects)")]
	public ItemDefinition[] ovenCookingFlagItems;

	public const Flags OvenCooking = Flags.Reserved9;

	public const Flags MixingTea = Flags.Reserved10;

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!base.isServer || next.HasFlag(Flags.On) == old.HasFlag(Flags.On))
		{
			return;
		}
		string text = (((Object)(object)currentRecipe != (Object)null) ? currentRecipe.ProducedItem.shortname : currentProductionItem?.shortname);
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		bool flag = GetChildBbq().IsOn();
		ItemDefinition[] array = ovenCookingFlagItems;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].shortname == text)
			{
				SetFlag(Flags.Reserved9, next.HasFlag(Flags.On) || flag);
				return;
			}
		}
		SetFlag(Flags.Reserved10, next.HasFlag(Flags.On));
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		SpawnOven();
	}

	private void SpawnOven()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)GetChildBbq() != (Object)null) && SubOvenPrefab.isValid)
		{
			BaseEntity baseEntity = base.gameManager.CreateEntity(SubOvenPrefab.resourcePath, SubOvenPosition.position, SubOvenPosition.rotation);
			baseEntity.SetParent(this, worldPositionStays: true);
			((Component)baseEntity).transform.localPosition = SubOvenPosition.localPosition;
			((Component)baseEntity).transform.localRotation = SubOvenPosition.localRotation;
			baseEntity.Spawn();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SpawnOven();
		}
	}

	private CookingWorkbenchBbq GetChildBbq()
	{
		foreach (BaseEntity child in children)
		{
			if (child is CookingWorkbenchBbq result)
			{
				return result;
			}
		}
		return null;
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		CookingWorkbenchBbq childBbq = GetChildBbq();
		if ((Object)(object)childBbq != (Object)null && childBbq.inventory != null && !childBbq.inventory.IsEmpty())
		{
			lastPickupError = Phrase.op_Implicit(string.Format(PickupErrors.ItemInventoryMustBeEmpty.translated, pickup.itemTarget.displayName.translated));
			return false;
		}
		return base.CanCompletePickup(player);
	}

	internal override void DoServerDestroy()
	{
		CookingWorkbenchBbq childBbq = GetChildBbq();
		if ((Object)(object)childBbq != (Object)null)
		{
			childBbq.DropItems();
			childBbq.Kill();
		}
		base.DoServerDestroy();
	}
}


using UnityEngine;

public class CookingWorkbenchBbq : BaseOven
{
	private CookingWorkbench ParentBench
	{
		get
		{
			if (!parentEntity.IsValid(base.isServer))
			{
				return null;
			}
			return parentEntity.Get(base.isServer) as CookingWorkbench;
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if ((Object)(object)ParentBench != (Object)null && base.isServer)
		{
			ParentBench.Hurt(info);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && next.HasFlag(Flags.On) != old.HasFlag(Flags.On))
		{
			CookingWorkbench parentBench = ParentBench;
			if ((Object)(object)parentBench != (Object)null)
			{
				bool b = (parentBench.IsOn() ? parentBench.IsOn() : next.HasFlag(Flags.On));
				parentBench.SetFlag(Flags.Reserved9, b);
			}
		}
	}

	public override void AdminKill()
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			baseEntity.AdminKill();
		}
	}
}


