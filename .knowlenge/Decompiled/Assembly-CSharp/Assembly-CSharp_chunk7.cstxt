using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using FIMSpace.FProceduralAnimation;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class RidableHorse : BaseVehicle, IInventoryProvider, IDetector, HitchTrough.IHitchable, TriggerHurtNotChild.IHurtTriggerUser, IAnimalRagdollCollisionReceiver, ITowing
{
	public enum GaitType : byte
	{
		Walk,
		Trot,
		Canter,
		Gallop
	}

	[Serializable]
	public struct Gait
	{
		public GaitType gaitType;

		public float minSpeed;

		public float maxSpeed;

		public float accelerationForce;

		public float brakingForce;

		public float turnSpeed;

		public float staminaReplenishRatio;

		public bool equipmentScalesMaxSpeed;

		public bool breedScalesMaxSpeed;
	}

	[Serializable]
	public struct PurchaseOption
	{
		public ItemDefinition tokenItem;

		public Phrase title;

		public Phrase description;

		public Sprite icon;

		public int order;
	}

	public enum HorseAvoidanceState
	{
		Normal,
		AvoidingObstacle
	}

	[Header("Breed")]
	public HorseBreed[] breeds;

	public SkinnedMeshRenderer[] bodyRenderers;

	public SkinnedMeshRenderer[] hairRenderers;

	private int currentBreedIndex = -1;

	public HorseBreed currentBreed;

	public FakePhysicsRope leadingRope;

	public FakePhysicsRope leadingRope2;

	[Header("Container")]
	public ItemDefinition onlyAllowedItem;

	public ItemContainer.ContentsType allowedContents = ItemContainer.ContentsType.Generic;

	[Space]
	public int maxStackSize;

	public int numStorageSlots;

	public int equipmentSlots = 4;

	public string lootPanelName = "animal";

	public string storagePanelName = "animal-storage";

	public bool needsBuildingPrivilegeToUse;

	public bool isLootable = true;

	public ItemContainer storageInventory;

	public ItemContainer equipmentInventory;

	public ProtectionProperties riderProtection;

	public ProtectionProperties baseHorseProtection;

	public float equipmentSpeedMod;

	[Header("Horse")]
	[SerializeField]
	private Animator animator;

	[SerializeField]
	private Transform centreOfMassTransform;

	[SerializeField]
	private RidableHorseAudio horseAudio;

	[SerializeField]
	private RidableHorseAnimation horseAnimation;

	[SerializeField]
	private LegsAnimator serverLegsAnimator;

	[SerializeField]
	private ScaleBySpeed scaleBySpeedWater;

	public WheelCollider wheelCollider;

	public GameObjectRef corpsePrefab;

	[Space]
	public Collider playerServerCollider;

	public Collider playerServerColliderRear;

	public CapsuleCollider clippingMountCheckCollider;

	public Gait[] gaits;

	public GaitType currentGait;

	public float gaitProgressionInterval = 1f;

	public float gravity = 10f;

	public float waterGravity = 1f;

	public float groundAlignmentSpeed = 50f;

	public float roadSpeedBonus = 1f;

	[Space]
	public float reverseSpeedFactor = 0.5f;

	public float reverseAccelerationForce = 4000f;

	[Space]
	public float rotationResponsiveness = 1f;

	[Tooltip("The factor applied to rotationResponsiveness, based on the current speed ratio (0 = stopped, 1 = full speed)")]
	public AnimationCurve rotationResponsivenessCurve;

	public Transform[] groundSampleOffsets;

	public Vector2 minMaxSlopeAngle = new Vector2(10f, 60f);

	public AnimationCurve slopeAngleSpeedFactor;

	[SerializeField]
	[Header("Collision Damage")]
	[Space]
	private GameObjectRef collisionEffect;

	[Tooltip("Ignore low magnitude so e.g. Players running into stationary vehicles doesn't trigger damage or FX")]
	[SerializeField]
	private float minCollisionDamageForce = 20000f;

	[Tooltip("Cap max magnitude so unusual events can't cause mega damage")]
	[SerializeField]
	private float maxCollisionDamageForce = 2500000f;

	[Tooltip("Adjust this away from 1.0 if collision damage to this vehicle seems too high or low")]
	[SerializeField]
	private float collisionDamageMultiplier = 1f;

	[SerializeField]
	private float playerDamageThreshold = 40f;

	[SerializeField]
	private float playerRagdollThreshold = 75f;

	[SerializeField]
	private float maxAirTimeBeforeRagdoll = 1.5f;

	[Header("Towing")]
	public TriggerTowing towingTrigger;

	public Transform towingPoint;

	public TowingVisuals towingVisuals;

	private NetworkableId towingEntityId;

	public GameObjectRef towingAttachEffect;

	public GameObjectRef towingDetachEffect;

	[SerializeField]
	private float towingAccelerationBoost = 2f;

	[SerializeField]
	private float towingMaxSpeedBoost = 1f;

	[SerializeField]
	private GaitType maxTowingGait = GaitType.Trot;

	[Header("Stamina")]
	public float currentStamina = 10f;

	public float currentMaxStamina = 10f;

	public float maxStamina = 20f;

	public float staminaCoreLossRatio = 0.1f;

	public float staminaCoreSpeedBonus = 3f;

	public float calorieToStaminaRatio = 0.1f;

	public float hydrationToStaminaRatio = 0.5f;

	public float maxStaminaCoreFromWater = 0.5f;

	[Header("Purchase")]
	public List<PurchaseOption> PurchaseOptions;

	[Header("Saddle")]
	public Phrase SwapToSingleTitle;

	public Phrase SwapToSingleDescription;

	public Sprite SwapToSingleIcon;

	public Phrase SwapToDoubleTitle;

	public Phrase SwapToDoubleDescription;

	public Sprite SwapToDoubleIcon;

	[HideInInspector]
	[SerializeField]
	protected bool[] hasItemTokenCache;

	[Space]
	public SoundPlayer standSound;

	public SoundPlayer slidingSound;

	private TimeSince timeSinceSlidingSoundPlayed;

	public ParticleSystemContainer skidDust;

	public GameObjectRef ragdollPrefab;

	[SerializeField]
	[Header("Pulling")]
	private List<ModifierDefintion> pullingPlayerModifiers;

	[Header("Avoidance")]
	public float avoidanceSphereRadius = 0.5f;

	public Vector2 avoidanceDetectionDistance = new Vector2(3f, 8f);

	public LayerMask avoidanceObstacleMask;

	[Header("Sliding")]
	public float groundAngleSlideThresholdForced = 50f;

	public float groundAngleSlideThreshold = 37f;

	public float groundAngleToRecoverFromSlide = 24f;

	public float normalVariationSlideThreshold = 2.5f;

	[HideInInspector]
	public float normalVariation;

	public const Flags Flag_ForSale = Flags.Reserved2;

	public const Flags Flag_Hitched = Flags.Reserved3;

	public const Flags Flag_HideHair = Flags.Reserved4;

	public const Flags Flag_WoodArmor = Flags.Reserved5;

	public const Flags Flag_RoadsignArmor = Flags.Reserved6;

	public const Flags Flag_Lead = Flags.Reserved16;

	public const Flags Flag_HasSingleSaddle = Flags.Reserved9;

	public const Flags Flag_HasDoubleSaddle = Flags.Reserved10;

	public const Flags Flag_IsRagdolling = Flags.Reserved12;

	public const Flags Flag_IsSwimming = Flags.Reserved13;

	public const Flags Flag_IsSliding = Flags.Reserved18;

	public const Flags Flag_IsInWater = Flags.Reserved19;

	private static readonly Phrase TowAngleErrorPhrase = new Phrase("horse_tow_error", "Straighten up to tow");

	private NetworkableId playerLeadingId;

	[ServerVar(Saved = true, ClientAdmin = true)]
	public static bool debug = false;

	[ServerVar(Saved = true, ClientAdmin = true)]
	public static bool autoAvoidance = true;

	[ServerVar(Saved = true, ClientAdmin = true, Default = "1")]
	public static bool throttledGroundAngleUpdate = true;

	[ServerVar(Saved = true, ClientAdmin = true, Default = "0.05")]
	public static float groundAngleUpdateRate = 0.05f;

	[ServerVar(Help = "How long before a horse dies unattended")]
	public static float decayMinutes = 180f;

	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 2f;

	public Transform rootBone;

	public Transform[] allBones;

	private static Vector3[] bonesInitialLocalPos;

	[Header("Dung")]
	public TriggerBase foodTrigger;

	public ItemDefinition dungItem;

	public Transform dungSpawnPoint;

	public float caloriesToDigestPerHour = 100f;

	public float dungProducedPerCalorie = 0.1f;

	[NonSerialized]
	public HorseModifiers modifiers;

	[Help("Scale all rideable animal dung production rates by this value. 0 will disable dung production.")]
	[ServerVar]
	public static float dungTimeScale = 1f;

	private float nextEatTime;

	private float lastEatTime = float.NegativeInfinity;

	private float pendingDungCalories;

	private float dungProduction;

	public HitchTrough currentHitch;

	private VehicleTerrainHandler terrainHandler;

	private readonly Dictionary<BaseEntity, float> damageSinceLastTick = new Dictionary<BaseEntity, float>();

	private float nextCollisionDamageTime;

	private float steerInput;

	private float steerInputDownTime;

	private float throttleInput;

	private bool forwardInputDown;

	private bool backwardInputDown;

	private bool duckInputDown;

	private float doubleTapTime = 0.25f;

	private float lastDuckTapTime = -1f;

	private bool duckDoubleTapped;

	private float sprintInputHoldTime;

	private bool sprintInputJustPressed;

	private Vector3 targetUp = Vector3.up;

	private Vector3 averagedUp = Vector3.up;

	private float groundAngle;

	protected bool onIdealTerrain;

	protected bool onWaterTopology;

	private float nextTerrainCheckTime;

	private float nextAutoAvoidanceCheckTime;

	private float nextGroundNormalCheckTime;

	private TimeSince timeSinceWaterCheck;

	private TimeSince timeSinceDrowningDamage;

	private bool wasSleeping;

	private float lastMovingTime;

	private const float SLEEP_DELAY = 5f;

	private const float SLEEP_SPEED = 0.5f;

	private WaterLevel.WaterInfo lastWaterInfo;

	private float currentWaterFactor;

	private float airTime;

	private float slidingTime;

	private float lastCrashDamage;

	private Vector3 lastPullerPosition;

	private float lastYVelocity;

	public float kmDistance;

	public float tempDistanceTravelled;

	private float lastRoughTerrainTime;

	private bool wasGrounded;

	private bool isSubmerged;

	[SerializeField]
	[HideInInspector]
	private float baseDrag;

	[SerializeField]
	[HideInInspector]
	private float baseAngularDrag;

	private HorseAvoidanceState currentAvoidanceState;

	private int avoidanceSteeringInput;

	private Vector3 avoidanceScanDirection;

	private float nextStandTime;

	private IHorseInputProvider inputProvider;

	private TowingAttachment<RidableHorse> towingAttachment;

	private ITowing towableEntity;

	private float lastRiddenTime;

	private float nextDecayTime;

	public bool HasSingleSaddle => HasFlag(Flags.Reserved9);

	public bool HasDoubleSaddle => HasFlag(Flags.Reserved10);

	public bool HasSaddle
	{
		get
		{
			if (!HasSingleSaddle)
			{
				return HasDoubleSaddle;
			}
			return true;
		}
	}

	public bool IsForSale => HasFlag(Flags.Reserved2);

	public bool IsTowing => HasFlag(Flags.Reserved14);

	public bool IsLeading => HasFlag(Flags.Reserved16);

	public bool IsSwimming => HasFlag(Flags.Reserved13);

	public bool IsSliding => HasFlag(Flags.Reserved18);

	public BasePlayer leadingPlayer { get; private set; }

	public override bool IsNpc => true;

	public bool isGrounded { get; private set; }

	public bool isStanding { get; private set; }

	public bool isSkidding { get; private set; }

	private VehicleTerrainHandler.Surface OnSurface
	{
		get
		{
			if (terrainHandler == null)
			{
				return VehicleTerrainHandler.Surface.Default;
			}
			return terrainHandler.OnSurface;
		}
	}

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public BaseEntity TowEntity => this;

	public Transform TowAnchor => towingPoint;

	public Rigidbody TowBody => rigidBody;

	public bool IsTowingAllowed => !IsTowing;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RidableHorse.OnRpcMessage", 0);
		try
		{
			if (rpc == 2663053610u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_Claim "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_Claim", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2663053610u, "SERVER_Claim", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_Claim(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_Claim");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 299778156 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_Lead "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_Lead", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(299778156u, "SERVER_Lead", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(299778156u, "SERVER_Lead", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_Lead(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_Lead");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3442949235u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3442949235u, "SERVER_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							SERVER_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SERVER_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3395302925u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestDetach "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestDetach", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3395302925u, "SERVER_RequestDetach", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3395302925u, "SERVER_RequestDetach", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3395302925u, "SERVER_RequestDetach", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							SERVER_RequestDetach(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in SERVER_RequestDetach");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 294213070 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestSaddleSwap "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestSaddleSwap", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(294213070u, "SERVER_RequestSaddleSwap", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							SERVER_RequestSaddleSwap(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in SERVER_RequestSaddleSwap");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3979037781u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestTow "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestTow", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3979037781u, "SERVER_RequestTow", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3979037781u, "SERVER_RequestTow", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3979037781u, "SERVER_RequestTow", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							SERVER_RequestTow(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in SERVER_RequestTow");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void ApplyBreed(int index)
	{
		if (currentBreedIndex != index)
		{
			if (index >= breeds.Length || index < 0)
			{
				Debug.LogError((object)("ApplyBreed issue! index is " + index + " breed length is : " + breeds.Length));
				return;
			}
			ApplyBreedInternal(breeds[index]);
			currentBreed = breeds[index];
			currentBreedIndex = index;
		}
	}

	protected void ApplyBreedInternal(HorseBreed breed)
	{
		if (base.isServer)
		{
			SetMaxHealth(StartHealth() * breed.maxHealth);
			base.health = MaxHealth();
		}
	}

	public HorseBreed GetBreed()
	{
		if (currentBreedIndex == -1 || currentBreedIndex >= breeds.Length)
		{
			return null;
		}
		return breeds[currentBreedIndex];
	}

	public void SetBreed(int index)
	{
		ApplyBreed(index);
		SendNetworkUpdate();
	}

	private bool ItemIsSaddle(Item item)
	{
		if (item == null)
		{
			return false;
		}
		ItemModAnimalEquipment component = ((Component)item.info).GetComponent<ItemModAnimalEquipment>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		ItemModAnimalEquipment.SlotType slot = component.slot;
		return slot == ItemModAnimalEquipment.SlotType.Saddle || slot == ItemModAnimalEquipment.SlotType.SaddleDouble;
	}

	private bool CanOpenStorage(BasePlayer player)
	{
		if (!AnyMounted() || PlayerIsMounted(player))
		{
			return true;
		}
		return false;
	}

	public int GetStorageSlotCount()
	{
		return numStorageSlots;
	}

	public void InitContainers()
	{
		if (storageInventory == null)
		{
			CreateStorageInventory(giveUID: true);
		}
		if (equipmentInventory == null)
		{
			CreateEquipmentInventory(giveUID: true);
		}
	}

	private void CreateInventories(bool giveUID)
	{
		CreateStorageInventory(giveUID);
		CreateEquipmentInventory(giveUID);
	}

	private void CreateStorageInventory(bool giveUID)
	{
		Debug.Assert(storageInventory == null, "Double init of inventory!");
		storageInventory = CreateInventory(giveUID, 48);
		storageInventory.canAcceptItem = StorageItemFilter;
	}

	private void CreateEquipmentInventory(bool giveUID)
	{
		Debug.Assert(equipmentInventory == null, "Double init of inventory!");
		equipmentInventory = CreateInventory(giveUID, equipmentSlots);
		equipmentInventory.canAcceptItem = EquipmentItemFilter;
	}

	private ItemContainer CreateInventory(bool giveUID, int slots)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.entityOwner = this;
		itemContainer.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
		itemContainer.SetOnlyAllowedItem(onlyAllowedItem);
		itemContainer.maxStackSize = maxStackSize;
		itemContainer.ServerInitialize(null, slots);
		if (giveUID)
		{
			itemContainer.GiveUID();
		}
		itemContainer.onItemAddedRemoved = OnItemAddedOrRemoved;
		itemContainer.onDirty += OnInventoryDirty;
		return itemContainer;
	}

	public bool StorageItemFilter(Item item, int targetSlot)
	{
		return true;
	}

	public bool EquipmentItemFilter(Item item, int targetSlot)
	{
		if (IsForSale && ItemIsSaddle(item))
		{
			return false;
		}
		ItemModAnimalEquipment component = ((Component)item.info).GetComponent<ItemModAnimalEquipment>();
		if (!Object.op_Implicit((Object)(object)component))
		{
			return false;
		}
		if (ItemIsSaddle(item) && HasSaddle)
		{
			return false;
		}
		if (component.slot == ItemModAnimalEquipment.SlotType.Basic)
		{
			return true;
		}
		for (int i = 0; i < equipmentInventory.capacity; i++)
		{
			Item slot = equipmentInventory.GetSlot(i);
			if (slot != null)
			{
				ItemModAnimalEquipment component2 = ((Component)slot.info).GetComponent<ItemModAnimalEquipment>();
				if (!((Object)(object)component2 == (Object)null) && component2.slot == component.slot)
				{
					int slot2 = (int)component2.slot;
					string text = slot2.ToString();
					slot2 = (int)component.slot;
					Debug.Log((object)("Rejecting because slot same, found : " + text + " new : " + slot2));
					return false;
				}
			}
		}
		return true;
	}

	private void OnInventoryDirty()
	{
		EquipmentUpdate();
	}

	private void OnItemAddedOrRemoved(Item arg1, bool arg2)
	{
	}

	private void ReleaseInventories()
	{
		Pool.Free<ItemContainer>(ref equipmentInventory);
		Pool.Free<ItemContainer>(ref storageInventory);
	}

	public void EquipmentUpdate()
	{
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.Reserved4, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved5, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);
		riderProtection.Clear();
		baseProtection.Clear();
		equipmentSpeedMod = 0f;
		numStorageSlots = 0;
		for (int i = 0; i < equipmentInventory.capacity; i++)
		{
			Item slot = equipmentInventory.GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			ItemModAnimalEquipment component = ((Component)slot.info).GetComponent<ItemModAnimalEquipment>();
			if ((Object)(object)component != (Object)null)
			{
				SetFlag(component.WearableFlag, b: true, recursive: false, networkupdate: false);
				if (component.hideHair)
				{
					SetFlag(Flags.Reserved4, b: true);
				}
				if (Object.op_Implicit((Object)(object)component.riderProtection))
				{
					riderProtection.Add(component.riderProtection, 1f);
				}
				if (Object.op_Implicit((Object)(object)component.animalProtection))
				{
					baseProtection.Add(component.animalProtection, 1f);
				}
				equipmentSpeedMod += component.speedModifier;
				numStorageSlots += component.additionalInventorySlots;
			}
		}
		for (int j = 0; j < storageInventory.capacity; j++)
		{
			if (j >= numStorageSlots)
			{
				Item slot2 = storageInventory.GetSlot(j);
				if (slot2 != null)
				{
					slot2.RemoveFromContainer();
					slot2.Drop(((Component)this).transform.position + Vector3.up + Random.insideUnitSphere * 0.25f, Vector3.zero);
				}
			}
		}
		storageInventory.capacity = numStorageSlots;
		SendNetworkUpdate();
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void SERVER_OpenLoot(RPCMessage rpc)
	{
		if (storageInventory == null)
		{
			return;
		}
		BasePlayer player = rpc.player;
		string text = rpc.read.String(256, false);
		if (!((Object)(object)player == (Object)null) && player.CanInteract() && CanOpenStorage(player) && (!needsBuildingPrivilegeToUse || player.CanBuild()) && Interface.CallHook("CanLootEntity", (object)player, (object)this) == null && player.inventory.loot.StartLootingEntity(this))
		{
			ItemContainer container = equipmentInventory;
			string arg = lootPanelName;
			if (text == "storage")
			{
				arg = storagePanelName;
				container = storageInventory;
			}
			player.inventory.loot.AddContainer(container);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), arg);
			SendNetworkUpdate();
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SERVER_RequestSaddleSwap(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !IsForSale && HasSaddle && !AnyMounted())
		{
			int tokenItemID = msg.read.Int32();
			Item purchaseToken = GetPurchaseToken(player, tokenItemID);
			if (purchaseToken != null && ItemIsSaddle(purchaseToken))
			{
				ItemDefinition template = (HasSingleSaddle ? PurchaseOptions[0].tokenItem : PurchaseOptions[1].tokenItem);
				OnClaimedWithToken(purchaseToken);
				purchaseToken.UseItem();
				Item item = ItemManager.Create(template, 1, 0uL);
				player.GiveItem(item);
				SendNetworkUpdateImmediate();
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_Claim(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && IsForSale)
		{
			int tokenItemID = msg.read.Int32();
			Item purchaseToken = GetPurchaseToken(player, tokenItemID);
			if (purchaseToken != null && Interface.CallHook("OnRidableAnimalClaim", (object)this, (object)player, (object)purchaseToken) == null && ItemIsSaddle(purchaseToken))
			{
				SetFlag(Flags.Reserved2, b: false);
				OnClaimedWithToken(purchaseToken);
				purchaseToken.UseItem();
				Analytics.Azure.OnVehiclePurchased(msg.player, this);
				AttemptMount(player, doMountChecks: false);
				Interface.CallHook("OnRidableAnimalClaimed", (object)this, (object)player);
			}
		}
	}

	public void OnClaimedWithToken(Item tokenItem)
	{
		int saddleItemSeatCount = GetSaddleItemSeatCount(tokenItem);
		SetSeatCount(saddleItemSeatCount);
	}

	public int GetSaddleItemSeatCount(Item item)
	{
		if (!ItemIsSaddle(item))
		{
			return 0;
		}
		ItemModAnimalEquipment component = ((Component)item.info).GetComponent<ItemModAnimalEquipment>();
		if ((Object)(object)component != (Object)null)
		{
			if (component.slot == ItemModAnimalEquipment.SlotType.Saddle)
			{
				return 1;
			}
			if (component.slot == ItemModAnimalEquipment.SlotType.SaddleDouble)
			{
				return 2;
			}
		}
		return 0;
	}

	public void GetAllInventories(List<ItemContainer> list)
	{
		list.Add(storageInventory);
		list.Add(equipmentInventory);
	}

	public Item GetPurchaseToken(BasePlayer player, int tokenItemID)
	{
		return player.inventory.FindItemByItemID(tokenItemID);
	}

	public bool PlayerHasToken(BasePlayer player, int tokenItemID)
	{
		return GetPurchaseToken(player, tokenItemID) != null;
	}

	public void SaveContainer(SaveInfo info, Horse msgHorse)
	{
		if (info.forDisk)
		{
			if (storageInventory != null)
			{
				msgHorse.storageContainer = storageInventory.Save();
			}
			if (equipmentInventory != null)
			{
				msgHorse.equipmentContainer = equipmentInventory.Save();
			}
		}
	}

	public void LoadContainer(LoadInfo info)
	{
		if (info.fromDisk && info.msg.horse != null)
		{
			if (equipmentInventory != null && info.msg.horse.equipmentContainer != null)
			{
				equipmentInventory.Load(info.msg.horse.equipmentContainer);
				equipmentInventory.capacity = equipmentSlots;
			}
			else
			{
				Debug.LogWarning((object)("Horse didn't have saved equipment inventory: " + ((object)this).ToString()));
			}
			if (storageInventory != null && info.msg.horse.storageContainer != null)
			{
				storageInventory.Load(info.msg.horse.storageContainer);
				storageInventory.capacity = numStorageSlots;
			}
			else
			{
				Debug.LogWarning((object)("Horse didn't have savevd storage inventorry: " + ((object)this).ToString()));
			}
		}
	}

	public override void PreInitShared()
	{
		base.PreInitShared();
		modifiers = ((Component)this).GetComponent<HorseModifiers>();
	}

	public bool HasSeatAvailable()
	{
		if (HasSaddle)
		{
			return !HasFlag(Flags.Reserved11);
		}
		return false;
	}

	public bool IsPlayerTooHeavy(BasePlayer player)
	{
		return player.Weight >= 10f;
	}

	public static float UnitsToKPH(float unitsPerSecond)
	{
		return unitsPerSecond * 60f * 60f / 1000f;
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		hasItemTokenCache = new bool[PurchaseOptions.Count];
		if (serverside || bundling)
		{
			baseDrag = rigidBody.drag;
			baseAngularDrag = rigidBody.angularDrag;
		}
		bonesInitialLocalPos = (Vector3[])(object)new Vector3[allBones.Length];
		for (int i = 0; i < allBones.Length; i++)
		{
			bonesInitialLocalPos[i] = allBones[i].localPosition;
		}
	}

	public void ResetBonesPositions()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < allBones.Length; i++)
		{
			allBones[i].localPosition = bonesInitialLocalPos[i];
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next && base.isServer)
		{
			ServerFlagsChanged(old, next);
		}
	}

	public override bool AnyMounted()
	{
		return base.AnyMounted();
	}

	private bool CanPlayerSeeSaddlePoint(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (!GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position, 0.25f, 2162688, (QueryTriggerInteraction)0))
		{
			return !GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position + Vector3.up * 0.5f, 0.25f, 2162688, (QueryTriggerInteraction)0);
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.horse = Pool.Get<Horse>();
		SaveContainer(info, info.msg.horse);
		info.msg.horse.stamina = currentStamina;
		info.msg.horse.maxStamina = currentMaxStamina;
		info.msg.horse.towEntityId = towingEntityId;
		info.msg.horse.breedIndex = currentBreedIndex;
		info.msg.horse.numStorageSlots = numStorageSlots;
		if (!info.forDisk)
		{
			info.msg.horse.gait = (int)currentGait;
			info.msg.horse.equipmentSpeedMod = equipmentSpeedMod;
			info.msg.horse.playerLeadingId = playerLeadingId;
		}
		info.msg.horse.modifiers = null;
		if ((Object)(object)modifiers != (Object)null)
		{
			info.msg.horse.modifiers = modifiers.Save(info.forDisk);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.horse != null)
		{
			LoadContainer(info);
			currentStamina = info.msg.horse.stamina;
			currentMaxStamina = info.msg.horse.maxStamina;
			if (info.fromDisk)
			{
				towingEntityId = info.msg.horse.towEntityId;
				ValidateTowableEntity();
				TowAttach();
			}
			if (info.msg.horse.modifiers != null && (Object)(object)modifiers != (Object)null)
			{
				modifiers.Load(info.msg.horse.modifiers, info.fromDisk);
			}
			ApplyBreed(info.msg.horse.breedIndex);
		}
	}

	public bool ShouldTrigger()
	{
		if (IsStopped() && isGrounded && !IsSwimming)
		{
			return !HasFlag(Flags.Reserved19);
		}
		return false;
	}

	public void OnObjects()
	{
	}

	public void OnObjectAdded(GameObject obj, Collider col)
	{
		if (ShouldTrigger() && !base.isClient)
		{
			BaseEntity baseEntity = obj.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !baseEntity.isClient && baseEntity is DroppedItem { item: not null } droppedItem && droppedItem.item.info.category == ItemCategory.Food)
			{
				OnFoodDetected(droppedItem);
			}
		}
	}

	public void OnEmpty()
	{
	}

	private void OnFoodDetected(DroppedItem droppedItem)
	{
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			EatDroppedFood(droppedItem);
		}, Random.Range(1f, 2f));
	}

	private void EatDroppedFood(DroppedItem droppedItem)
	{
		if ((Object)(object)droppedItem == (Object)null || !foodTrigger.HasAnyEntityContents || (GetMaxStaminaFraction() >= 1f && base.healthFraction >= 1f))
		{
			return;
		}
		if (Time.time < nextEatTime)
		{
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				OnFoodDetected(droppedItem);
			}, nextEatTime - Time.time);
		}
		else
		{
			if (!foodTrigger.entityContents.Contains(droppedItem))
			{
				return;
			}
			ItemModConsumable component = ((Component)droppedItem.item.info).GetComponent<ItemModConsumable>();
			if ((Object)(object)component == (Object)null)
			{
				return;
			}
			droppedItem.item.UseItem();
			if (droppedItem.item.amount <= 0)
			{
				droppedItem.Kill();
			}
			else
			{
				((FacepunchBehaviour)this).Invoke((Action)delegate
				{
					EatDroppedFood(droppedItem);
				}, nextEatTime - Time.time);
			}
			nextEatTime = Time.time + Random.Range(2f, 3f) + Mathf.InverseLerp(0.5f, 1f, GetMaxStaminaFraction()) * 4f;
			ReplenishFromFood(component);
		}
	}

	public void ReplenishFromFood(ItemModConsumable consumable)
	{
		if (!((Object)(object)consumable == (Object)null))
		{
			HorseModifiers.AddToHorse(this, consumable.modifiers);
			lastEatTime = Time.time;
			float ifType = consumable.GetIfType(MetabolismAttribute.Type.Calories);
			float ifType2 = consumable.GetIfType(MetabolismAttribute.Type.Hydration);
			float num = consumable.GetIfType(MetabolismAttribute.Type.Health) + consumable.GetIfType(MetabolismAttribute.Type.HealthOverTime);
			ApplyDungCalories(ifType);
			ReplenishStaminaCore(ifType, ifType2);
			Heal(num * 4f);
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_HorseEat"));
		}
	}

	private void UpdateDung(float deltaTime)
	{
		if (pendingDungCalories < 0.01f || (Object)(object)dungItem == (Object)null)
		{
			return;
		}
		deltaTime *= dungTimeScale;
		float num = (((Object)(object)modifiers != (Object)null) ? modifiers.GetValue(Modifier.ModifierType.HorseDungProductionBoost, 1f) : 1f);
		deltaTime *= num;
		if (!(deltaTime < 0.01f))
		{
			float num2 = Mathf.Min(pendingDungCalories * deltaTime, caloriesToDigestPerHour / 3600f * deltaTime) * dungProducedPerCalorie;
			dungProduction += num2;
			pendingDungCalories -= num2;
			if (dungProduction >= 1f)
			{
				DoDung();
			}
		}
	}

	public void ApplyDungCalories(float calories)
	{
		pendingDungCalories += calories;
	}

	private void DoDung()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		dungProduction -= 1f;
		if (Interface.CallHook("OnAnimalDungProduce", (object)this) == null)
		{
			Quaternion rotation = Quaternion.Euler(Random.Range(-180f, 180f), Random.Range(-180f, 180f), Random.Range(-180f, 180f));
			Vector3 vVelocity = default(Vector3);
			((Vector3)(ref vVelocity))..ctor(Random.Range(-0.5f, 0.5f), Random.Range(-1f, -3f), Random.Range(-0.5f, 0.5f));
			Item item = ItemManager.Create(dungItem, 1, 0uL);
			item.SetItemOwnership(currentBreed.breedName.english, ItemOwnershipPhrases.Pooped);
			item.Drop(dungSpawnPoint.position + Random.insideUnitSphere * 0.1f, vVelocity, rotation);
			Interface.CallHook("OnAnimalDungProduced", (object)this, (object)item);
		}
	}

	public bool IsHitched()
	{
		return (Object)(object)currentHitch != (Object)null;
	}

	public void TryToHitch()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		List<HitchTrough> list = Pool.Get<List<HitchTrough>>();
		Vis.Entities(((Component)this).transform.position, 2.5f, list, 256, (QueryTriggerInteraction)1);
		foreach (HitchTrough item in list)
		{
			if (!item.isClient && !(Vector3.Dot(Vector3Ex.Direction2D(((Component)item).transform.position, ((Component)this).transform.position), ((Component)this).transform.forward) < 0.4f) && item.HasSpace() && item.IsValidHitchPosition(((Component)this).transform.position) && item.AttemptToHitch(this))
			{
				break;
			}
		}
		Pool.FreeUnmanaged<HitchTrough>(ref list);
	}

	public void SetHitch(HitchTrough hitch, HitchTrough.HitchSpot spot)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		currentHitch = hitch;
		SetFlag(Flags.Reserved3, (Object)(object)currentHitch != (Object)null);
		if ((Object)(object)hitch != (Object)null)
		{
			((Component)this).transform.SetPositionAndRotation(spot.tr.position, spot.tr.rotation);
			DismountAllPlayers();
		}
	}

	private void EatFromHitch()
	{
		if (!IsHitched())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)EatFromHitch);
		}
		else
		{
			if (Time.time < nextEatTime || (GetMaxStaminaFraction() >= 1f && base.healthFraction >= 1f))
			{
				return;
			}
			Item foodItem = currentHitch.GetFoodItem();
			if (foodItem != null && foodItem.amount > 0)
			{
				ItemModConsumable component = ((Component)foodItem.info).GetComponent<ItemModConsumable>();
				if (Object.op_Implicit((Object)(object)component))
				{
					float time = component.GetIfType(MetabolismAttribute.Type.Calories) * currentHitch.caloriesToDecaySeconds;
					AddDecayDelay(time);
					ReplenishFromFood(component);
					foodItem.UseItem();
					nextEatTime = Time.time + Random.Range(2f, 3f) + Mathf.InverseLerp(0.5f, 1f, GetMaxStaminaFraction()) * 4f;
				}
			}
		}
	}

	public void TryLeaveHitch()
	{
		if ((Object)(object)currentHitch != (Object)null)
		{
			currentHitch.UnHitch(this);
		}
	}

	public bool IsReversing()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		if (base.isServer)
		{
			val = rigidBody.velocity;
		}
		return Vector3.Dot(val, ((Component)this).transform.forward) < -0.1f;
	}

	private float GetCurrentSpeed()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			Vector3 velocity = rigidBody.velocity;
			return ((Vector3)(ref velocity)).magnitude;
		}
		return 0f;
	}

	public float GetCurrentGaitSpeedFraction()
	{
		return Mathf.Clamp01(GetCurrentSpeed() / GetCurrentMaxSpeed());
	}

	public float GetSpeedFraction()
	{
		return Mathf.Clamp01(GetCurrentSpeed() / GetTopSpeed());
	}

	private float GetTurnSpeed()
	{
		float turnSpeed = GetCurrentGait().turnSpeed;
		if (IsSwimming)
		{
			return turnSpeed * 0.8f;
		}
		if (IsReversing())
		{
			return turnSpeed * 0.7f;
		}
		return turnSpeed;
	}

	private float GetCurrentAcceleration()
	{
		float num = GetCurrentGait().accelerationForce;
		if (IsTowing)
		{
			num *= towingAccelerationBoost;
		}
		return num;
	}

	private float GetCurrentMaxSpeed()
	{
		Gait gait = GetCurrentGait();
		float num = gait.maxSpeed;
		if (onIdealTerrain && gait.gaitType == GaitType.Gallop)
		{
			num += roadSpeedBonus;
		}
		if (gait.equipmentScalesMaxSpeed)
		{
			num += equipmentSpeedMod;
			float num2 = (((Object)(object)modifiers != (Object)null) ? modifiers.GetValue(Modifier.ModifierType.HorseGallopSpeed) : 0f);
			num += num2;
		}
		if (gait.breedScalesMaxSpeed)
		{
			num *= currentBreed.maxSpeed;
		}
		if (IsTowing)
		{
			num *= towingMaxSpeedBoost;
		}
		return num;
	}

	public float GetTopSpeed()
	{
		float num = (gaits[gaits.Length - 1].maxSpeed + equipmentSpeedMod) * currentBreed.maxSpeed;
		float num2 = (((Object)(object)modifiers != (Object)null) ? modifiers.GetValue(Modifier.ModifierType.HorseGallopSpeed) : 0f);
		return num + num2;
	}

	private Gait GetCurrentGait()
	{
		return gaits[(uint)currentGait];
	}

	private bool IsStopped()
	{
		if (!IsSliding)
		{
			return GetSpeedFraction() < 0.05f;
		}
		return false;
	}

	public float GetMaxStaminaFraction()
	{
		return Mathf.InverseLerp(0f, maxStamina, currentMaxStamina);
	}

	public float GetStaminaFraction()
	{
		return Mathf.InverseLerp(0f, maxStamina, currentStamina);
	}

	public bool IsDrowning()
	{
		if (IsSwimming)
		{
			return GetStaminaFraction() < 0.02f;
		}
		return false;
	}

	public bool CanLead(BasePlayer player)
	{
		if (!AnyMounted() && NearMountPoint(player) && DirectlyMountable() && !HasFlag(Flags.Reserved12) && !player.isMounted && !IsLeading && !IsTowing)
		{
			return !IsForSale;
		}
		return false;
	}

	public bool CanStopLead(BasePlayer player)
	{
		if (IsLeading && (Object)(object)leadingPlayer == (Object)(object)player)
		{
			return NearMountPoint(player);
		}
		return false;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (!IsDriver(player))
		{
			return;
		}
		if (inputProvider != null)
		{
			throttleInput = inputProvider.GetMoveInput();
			steerInput = inputProvider.GetSteerInput();
		}
		float num = steerInput;
		if (num == 1f || num == -1f)
		{
			if (steerInputDownTime == 0f)
			{
				steerInputDownTime = Time.time;
			}
		}
		else
		{
			steerInputDownTime = 0f;
		}
		forwardInputDown = throttleInput == 1f;
		backwardInputDown = throttleInput == -1f;
		sprintInputJustPressed = inputState.WasJustPressed(BUTTON.SPRINT);
		bool flag = inputState.IsDown(BUTTON.SPRINT);
		if (sprintInputJustPressed)
		{
			IncrementGait(flag);
		}
		if (inputState.WasJustReleased(BUTTON.SPRINT) && currentGait == GaitType.Gallop)
		{
			RetrogradeGait();
		}
		if (flag)
		{
			if (sprintInputHoldTime == 0f)
			{
				sprintInputHoldTime = Time.time;
			}
			if (Time.time - sprintInputHoldTime >= gaitProgressionInterval && (int)currentGait < 3)
			{
				sprintInputHoldTime = Time.time;
				IncrementGait(sprintHeld: true);
			}
		}
		else
		{
			sprintInputHoldTime = 0f;
		}
		duckInputDown = inputState.IsDown(BUTTON.DUCK);
		if (inputState.WasJustReleased(BUTTON.DUCK))
		{
			float time = Time.time;
			if (time - lastDuckTapTime <= doubleTapTime)
			{
				duckDoubleTapped = true;
			}
			else
			{
				duckDoubleTapped = false;
			}
			lastDuckTapTime = time;
		}
		else if (duckDoubleTapped)
		{
			duckDoubleTapped = false;
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		if (HasFlag(Flags.Reserved12))
		{
			return;
		}
		base.VehicleFixedUpdate();
		TimeWarning val = TimeWarning.New("RidableHorse.VehicleFixedUpdate", 0);
		try
		{
			if ((Object)(object)modifiers != (Object)null)
			{
				modifiers.ServerUpdate(this);
			}
			float fixedDeltaTime = Time.fixedDeltaTime;
			UpdateStamina(fixedDeltaTime);
			UpdateDung(fixedDeltaTime);
			if (IsDrowning() && TimeSince.op_Implicit(timeSinceDrowningDamage) > 2f)
			{
				timeSinceDrowningDamage = TimeSince.op_Implicit(0f);
				Hurt(75f, DamageType.Drowned, null, useProtection: false);
			}
			if (Time.time >= nextCollisionDamageTime)
			{
				nextCollisionDamageTime = Time.time + 0.33f;
				foreach (KeyValuePair<BaseEntity, float> item in damageSinceLastTick)
				{
					DoCollisionDamage(item.Key, item.Value);
				}
				damageSinceLastTick.Clear();
			}
			bool flag = AnyMounted();
			if ((!IsLeading && !HasDoubleSaddle && !flag) || (HasDoubleSaddle && !HasDriver()))
			{
				throttleInput = 0f;
				steerInput = 0f;
			}
			if (IsLeading)
			{
				if ((Object)(object)leadingPlayer == (Object)null || leadingPlayer.IsDead() || leadingPlayer.IsSleeping() || leadingPlayer.IsDestroyed)
				{
					SetLeading(null);
				}
				else
				{
					throttleInput = inputProvider.GetMoveInput();
					steerInput = inputProvider.GetSteerInput();
				}
			}
			if ((flag || IsLeading) && rigidBody.IsSleeping())
			{
				((Collider)wheelCollider).enabled = true;
				rigidBody.WakeUp();
			}
			if (rigidBody.IsSleeping())
			{
				wasSleeping = true;
				((Behaviour)serverLegsAnimator).enabled = false;
				((Collider)wheelCollider).enabled = false;
				return;
			}
			((Collider)wheelCollider).enabled = true;
			((Behaviour)serverLegsAnimator).enabled = true;
			serverLegsAnimator.HipsHeightStepSpeed = Mathf.Lerp(0.7f, 0.05f, Mathf.InverseLerp(0f, 10f, normalVariation));
			if (IsTowing)
			{
				towingAttachment.FixedUpdate();
			}
			if (!wasSleeping && !(GetCurrentSpeed() > 0.5f))
			{
				Vector3 angularVelocity = rigidBody.angularVelocity;
				if (!(Mathf.Abs(((Vector3)(ref angularVelocity)).magnitude) > 0.5f))
				{
					goto IL_0296;
				}
			}
			lastMovingTime = Time.time;
			goto IL_0296;
			IL_0296:
			float num = GetCurrentSpeed() * Time.fixedDeltaTime;
			if (!flag && !IsLeading && !IsTowing && Time.time > lastMovingTime + 5f)
			{
				airTime = 0f;
				wheelCollider.motorTorque = 0f;
				((Behaviour)serverLegsAnimator).enabled = false;
				((Collider)wheelCollider).enabled = false;
				rigidBody.Sleep();
			}
			else
			{
				if (autoAvoidance)
				{
					AutoAvoidObstacles();
				}
				MovementsUpdate();
			}
			wasSleeping = false;
			tempDistanceTravelled += num;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override float MaxVelocity()
	{
		return GetTopSpeed() * 1.3f;
	}

	private void MovementsUpdate()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ad9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0adf: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b09: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b1c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b21: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b29: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b52: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b57: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b35: Unknown result type (might be due to invalid IL or missing references)
		//IL_0403: Unknown result type (might be due to invalid IL or missing references)
		//IL_0405: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b94: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b9f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b6f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b74: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b78: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b7e: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0be5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bf3: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0423: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0438: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c4f: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c23: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c28: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0868: Unknown result type (might be due to invalid IL or missing references)
		//IL_086d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0816: Unknown result type (might be due to invalid IL or missing references)
		//IL_075b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0760: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08df: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0900: Unknown result type (might be due to invalid IL or missing references)
		//IL_0905: Unknown result type (might be due to invalid IL or missing references)
		//IL_0784: Unknown result type (might be due to invalid IL or missing references)
		//IL_0789: Unknown result type (might be due to invalid IL or missing references)
		//IL_0776: Unknown result type (might be due to invalid IL or missing references)
		//IL_0925: Unknown result type (might be due to invalid IL or missing references)
		//IL_092a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0937: Unknown result type (might be due to invalid IL or missing references)
		//IL_093d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0942: Unknown result type (might be due to invalid IL or missing references)
		//IL_0947: Unknown result type (might be due to invalid IL or missing references)
		//IL_0955: Unknown result type (might be due to invalid IL or missing references)
		//IL_095a: Unknown result type (might be due to invalid IL or missing references)
		//IL_095f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0967: Unknown result type (might be due to invalid IL or missing references)
		//IL_096c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0971: Unknown result type (might be due to invalid IL or missing references)
		//IL_0975: Unknown result type (might be due to invalid IL or missing references)
		//IL_097c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0981: Unknown result type (might be due to invalid IL or missing references)
		//IL_0983: Unknown result type (might be due to invalid IL or missing references)
		//IL_0600: Unknown result type (might be due to invalid IL or missing references)
		//IL_0602: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0635: Unknown result type (might be due to invalid IL or missing references)
		//IL_0637: Unknown result type (might be due to invalid IL or missing references)
		//IL_0648: Unknown result type (might be due to invalid IL or missing references)
		//IL_064d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0655: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_09de: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_09ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_09f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_09fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0716: Unknown result type (might be due to invalid IL or missing references)
		//IL_071a: Unknown result type (might be due to invalid IL or missing references)
		//IL_071f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0721: Unknown result type (might be due to invalid IL or missing references)
		//IL_0726: Unknown result type (might be due to invalid IL or missing references)
		//IL_072a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0737: Unknown result type (might be due to invalid IL or missing references)
		//IL_073c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0744: Unknown result type (might be due to invalid IL or missing references)
		//IL_069d: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0701: Unknown result type (might be due to invalid IL or missing references)
		//IL_0709: Unknown result type (might be due to invalid IL or missing references)
		if (currentGait == GaitType.Canter && !CanCanter())
		{
			RetrogradeGait();
		}
		else if (currentGait == GaitType.Gallop && !CanGallop())
		{
			RetrogradeGait();
		}
		CheckSpeedForRetrograde();
		UpdateOnTerrain();
		bool isSwimming = IsSwimming;
		if (onWaterTopology)
		{
			if (TimeSince.op_Implicit(timeSinceWaterCheck) > (isSwimming ? 0.05f : 0.25f))
			{
				OBB val = WorldSpaceBounds();
				Bounds val2 = ((OBB)(ref val)).ToBounds();
				lastWaterInfo = WaterLevel.GetWaterInfo(val2, waves: true, volumes: true, this);
				currentWaterFactor = (lastWaterInfo.isValid ? Mathf.InverseLerp(((Bounds)(ref val2)).min.y, ((Bounds)(ref val2)).max.y, lastWaterInfo.surfaceLevel) : 0f);
				isSubmerged = currentWaterFactor > 0.65f;
				bool flag = (currentWaterFactor > 0.5f && !isGrounded) || isSubmerged;
				if (isSwimming != flag)
				{
					SetFlag(Flags.Reserved13, flag);
				}
				bool flag2 = currentWaterFactor > 0.32f;
				if (HasFlag(Flags.Reserved19) != flag2)
				{
					SetFlag(Flags.Reserved19, flag2);
				}
				rigidBody.drag = Mathf.Max(baseDrag, currentWaterFactor * 3f);
				rigidBody.angularDrag = Mathf.Max(baseAngularDrag, currentWaterFactor * 2f);
				timeSinceWaterCheck = TimeSince.op_Implicit(0f);
			}
		}
		else
		{
			if (HasFlag(Flags.Reserved19))
			{
				SetFlag(Flags.Reserved19, b: false);
			}
			currentWaterFactor = 0f;
		}
		wasGrounded = isGrounded;
		if (throttledGroundAngleUpdate)
		{
			if (Time.time > nextGroundNormalCheckTime)
			{
				UpdateGroundNormal();
				nextGroundNormalCheckTime = Time.time + Random.Range(groundAngleUpdateRate, groundAngleUpdateRate + 0.1f);
			}
		}
		else
		{
			UpdateGroundNormal();
		}
		bool flag3;
		Vector3 force;
		if (isGrounded || isSwimming)
		{
			if (!wasGrounded)
			{
				OnLanded(Mathf.Abs(lastYVelocity));
			}
			airTime = 0f;
			flag3 = IsStopped();
			force = rigidBody.velocity;
			if (((Vector3)(ref force)).magnitude > 0.5f && !isSwimming)
			{
				Vector3 val3 = -((Component)this).transform.up;
				force = rigidBody.velocity;
				Vector3 val4 = val3 * ((Vector3)(ref force)).magnitude * 20f;
				rigidBody.AddForce(val4, (ForceMode)0);
			}
			AlignWithNormal(averagedUp);
			Vector3 forward = ((Component)this).transform.forward;
			Vector3 velocity = rigidBody.velocity;
			if (ShouldSlide())
			{
				SetWheelStiffness(0.1f, 0f);
				SetFlag(Flags.Reserved18, b: true);
			}
			float currentSpeed = GetCurrentSpeed();
			if (IsSliding)
			{
				if ((groundAngle < groundAngleToRecoverFromSlide && currentSpeed < 7f) || (currentSpeed < 1f && slidingTime > Time.fixedDeltaTime * 10f))
				{
					SetWheelStiffness(1f, 1f);
					SetFlag(Flags.Reserved18, b: false);
					slidingTime = 0f;
				}
				slidingTime += Time.fixedDeltaTime;
				float num = Vector3.Dot(rigidBody.velocity, -((Component)this).transform.forward);
				if (slidingTime > Time.fixedDeltaTime * 5f && num > 7f)
				{
					if (groundAngle > groundAngleToRecoverFromSlide + 5f)
					{
						force = default(Vector3);
						RagdollAllRiders(force);
					}
					RagdollHorse();
				}
			}
			Vector3 val5 = Vector3.Project(velocity, forward);
			Vector3 val6 = velocity - val5;
			if (((Vector3)(ref val6)).magnitude > 1f)
			{
				Vector3 val7 = -val6 * (isSkidding ? 1f : 3f);
				rigidBody.AddForce(val7 * rigidBody.mass, (ForceMode)0);
			}
			float num2 = Mathf.Clamp01(currentSpeed / GetTopSpeed());
			if (num2 > 0.9f && duckInputDown && !isSkidding && currentWaterFactor < 0.1f && groundAngle < 10f)
			{
				isSkidding = true;
				SetWheelStiffness(0.1f, 0.3f);
				ClientRPC(RpcTarget.NetworkGroup("CLIENT_Skid"));
			}
			if (isSkidding)
			{
				SetWheelStiffness(0f, 0f);
				Brake(1.25f);
				if (num2 <= 0.01f || Vector3.Dot(forward, ((Vector3)(ref velocity)).normalized) < 0.2f)
				{
					isSkidding = false;
				}
			}
			else if (!IsSliding)
			{
				SetWheelStiffness(1f, 1f);
			}
			if (Mathf.Abs(steerInput) > 0f && num2 < 0.3f && !IsReversing() && !backwardInputDown && !forwardInputDown && !isSkidding && !duckInputDown && Time.time - steerInputDownTime > 1f)
			{
				throttleInput = 1f;
			}
			if (!isStanding && !IsSliding && !isSkidding)
			{
				if (duckInputDown && !flag3)
				{
					float multiplier = (((int)currentGait <= 1) ? 0.15f : 1f);
					Brake(multiplier);
				}
				if (throttleInput != 0f && !duckInputDown)
				{
					wheelCollider.motorTorque = 1E-05f * Mathf.Sign(throttleInput);
					if (throttleInput < 0f)
					{
						if (Vector3.Dot(velocity, forward) < -0.1f || flag3)
						{
							float num3 = GetCurrentMaxSpeed() * reverseSpeedFactor;
							float num4 = Mathf.Max(num3 - currentSpeed, 0f);
							Vector3 val8 = -forward * (reverseAccelerationForce * (num4 / num3));
							rigidBody.AddForce(val8, (ForceMode)0);
						}
						else
						{
							Brake();
						}
					}
					else if (throttleInput > 0f)
					{
						float currentMaxSpeed = GetCurrentMaxSpeed();
						float currentAcceleration = GetCurrentAcceleration();
						if (((Vector3)(ref velocity)).magnitude < currentMaxSpeed)
						{
							Vector3 val9 = forward * currentAcceleration;
							if (currentGait != 0 || IsTowing)
							{
								float num5 = slopeAngleSpeedFactor.Evaluate(Mathf.InverseLerp(minMaxSlopeAngle.x, minMaxSlopeAngle.y, groundAngle));
								if (IsTowing)
								{
									num5 += 1f;
								}
								val9 *= num5;
							}
							rigidBody.AddForce(val9, (ForceMode)0);
						}
						else
						{
							Vector3 val10 = forward * currentMaxSpeed - velocity;
							Vector3 val11 = ((Vector3)(ref val10)).normalized * (currentAcceleration * 0.2f);
							rigidBody.AddForce(val11, (ForceMode)0);
						}
					}
				}
				else
				{
					float num6 = 0.1f;
					force = rigidBody.velocity;
					if (((Vector3)(ref force)).sqrMagnitude < num6 * num6)
					{
						rigidBody.velocity = Vector3.zero;
					}
					else
					{
						Vector3 val12 = -((Vector3)(ref velocity)).normalized * (rigidBody.mass * (AnyMounted() ? 1.1f : 3f));
						rigidBody.AddForce(val12, (ForceMode)0);
					}
				}
			}
			if (!isStanding && !IsSliding)
			{
				float num7 = GetTurnSpeed();
				if (duckInputDown && (int)currentGait < 2)
				{
					num7 *= 1.5f;
				}
				float num8 = ((steerInput + (float)avoidanceSteeringInput) * num7 * (MathF.PI / 180f) - rigidBody.angularVelocity.y) * rotationResponsiveness * rotationResponsivenessCurve.Evaluate(num2);
				rigidBody.AddRelativeTorque(0f, num8, 0f, (ForceMode)5);
			}
			if (Mathf.Abs(throttleInput) <= 0f)
			{
				force = rigidBody.velocity;
				if (((Vector3)(ref force)).magnitude < 2.5f && groundAngle < minMaxSlopeAngle.y && !isSwimming && !IsSliding)
				{
					goto IL_08ac;
				}
			}
			if (IsLeading && currentSpeed > 6f)
			{
				goto IL_08ac;
			}
			wheelCollider.brakeTorque = 0f;
			goto IL_08c4;
		}
		airTime += Time.fixedDeltaTime;
		if (airTime > maxAirTimeBeforeRagdoll)
		{
			force = default(Vector3);
			RagdollAllRiders(force);
			RagdollHorse();
		}
		float num9 = ((currentWaterFactor != 0f) ? waterGravity : gravity);
		Vector3 val13 = Vector3.down * (rigidBody.mass * num9);
		rigidBody.AddForce(val13, (ForceMode)0);
		goto IL_0b31;
		IL_0b31:
		if (isSwimming)
		{
			AlignWithNormal(Vector3.up);
			ApplyBuoyancy();
		}
		float num10 = 10000f;
		force = rigidBody.velocity;
		if (((Vector3)(ref force)).magnitude > num10)
		{
			Rigidbody obj = rigidBody;
			force = rigidBody.velocity;
			obj.velocity = ((Vector3)(ref force)).normalized * num10;
		}
		float num11 = -1.3f;
		float num12 = Vector3.Dot(rigidBody.velocity, ((Component)this).transform.forward);
		if (num12 <= num11)
		{
			float num13 = num11 - num12;
			float num14 = Mathf.Lerp(1f, 0.2f, Mathf.InverseLerp(10f, 40f, groundAngle));
			rigidBody.AddForce(((Component)this).transform.forward * num13 * num14, (ForceMode)5);
		}
		if (Mathf.Abs(steerInput) == 0f && !rigidBody.isKinematic)
		{
			force = rigidBody.angularVelocity;
			if (((Vector3)(ref force)).magnitude < 0.2f)
			{
				rigidBody.angularVelocity = Vector3.zero;
			}
		}
		lastYVelocity = rigidBody.velocity.y;
		return;
		IL_08c4:
		if (IsLeading)
		{
			Vector3 val14 = ((Component)this).transform.TransformPoint(Vector3.up * 1.8f + Vector3.forward);
			float num15 = Vector3.Distance(((Component)leadingPlayer).transform.position, val14);
			if (num15 > 3.5f)
			{
				Vector3 position = ((Component)leadingPlayer).transform.position;
				Vector3 val15 = ((Component)leadingPlayer).transform.position - lastPullerPosition;
				lastPullerPosition = ((Component)leadingPlayer).transform.position;
				force = position - ((Component)this).transform.position;
				Vector3 normalized = ((Vector3)(ref force)).normalized;
				Vector3 normalized2 = ((Vector3)(ref val15)).normalized;
				if (Vector3.Dot(normalized, normalized2) > 0.5f)
				{
					float value = Mathf.Lerp(0f, -0.9f, Mathf.Clamp01(Mathf.InverseLerp(3.5f, 7f, num15)));
					leadingPlayer.modifiers.SetValue(Modifier.ModifierSource.Interaction, Modifier.ModifierType.MoveSpeed, value);
					if (num15 > 5f)
					{
						force = position - val14;
						Vector3 normalized3 = ((Vector3)(ref force)).normalized;
						rigidBody.AddForceAtPosition(normalized3 * 5000f, val14, (ForceMode)0);
					}
				}
				else
				{
					leadingPlayer.modifiers.SetValue(Modifier.ModifierSource.Interaction, Modifier.ModifierType.MoveSpeed, 0f);
				}
			}
			else
			{
				leadingPlayer.modifiers.SetValue(Modifier.ModifierSource.Interaction, Modifier.ModifierType.MoveSpeed, 0f);
			}
			if (num15 > 7f)
			{
				leadingPlayer.modifiers.RemoveFromSource(Modifier.ModifierSource.Interaction);
				SetLeading(null);
			}
		}
		if (flag3 && duckDoubleTapped && CanStand())
		{
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_Stand"));
			nextStandTime = Time.time + 4f;
			isStanding = true;
		}
		if (isStanding && nextStandTime < Time.time)
		{
			isStanding = false;
		}
		goto IL_0b31;
		IL_08ac:
		ApplyHandBrake();
		goto IL_08c4;
	}

	private void Brake(float multiplier = 1f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero - rigidBody.velocity;
		Vector3 val2 = ((Vector3)(ref val)).normalized * GetCurrentGait().brakingForce * multiplier;
		rigidBody.AddForce(val2, (ForceMode)0);
	}

	private bool ShouldSlide()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if ((IsSliding || !(groundAngle > groundAngleSlideThreshold) || !(normalVariation < normalVariationSlideThreshold)) && !(groundAngle > groundAngleSlideThresholdForced))
		{
			return Vector3.Dot(rigidBody.velocity, -((Component)this).transform.forward) > 4f;
		}
		return true;
	}

	private void ApplyBuoyancy()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		float num = lastWaterInfo.surfaceLevel - (IsDrowning() ? (centreOfMassTransform.position.y + 3f) : (centreOfMassTransform.position.y - 0.5f));
		num = Mathf.Clamp(num, 0f, 5f);
		if (num > 0f)
		{
			float num2 = Mathf.Sin(Time.time * 2f) * 0.3f;
			float num3 = 1f + num2;
			Vector3 val = Vector3.up * (10f * num * num3);
			rigidBody.AddForce(val, (ForceMode)5);
			Vector3 val2 = Vector3.ProjectOnPlane(rigidBody.velocity, Vector3.up);
			Vector3 val3 = Vector3.Project(rigidBody.velocity, Vector3.up);
			val3 *= 1f - Time.fixedDeltaTime * 6f;
			rigidBody.velocity = val2 + val3;
		}
	}

	private void CheckSpeedForRetrograde()
	{
		float currentSpeed = GetCurrentSpeed();
		Gait gait = GetCurrentGait();
		if ((int)currentGait > 0 && currentSpeed < gait.minSpeed)
		{
			RetrogradeGait();
		}
		if (IsSwimming && currentGait != 0)
		{
			RetrogradeGait();
		}
	}

	public void IncrementGait(bool sprintHeld)
	{
		if (!IsTowing || currentGait != maxTowingGait)
		{
			GaitType gaitType = currentGait + 1;
			if ((gaitType != GaitType.Gallop || (sprintHeld && CanStartGalloping())) && (gaitType != GaitType.Trot || !IsSwimming) && (int)currentGait < 3)
			{
				currentGait++;
			}
		}
	}

	private bool CanGallop()
	{
		if (GetStaminaFraction() > 0f)
		{
			return Time.time - lastRoughTerrainTime > 2.5f;
		}
		return false;
	}

	private bool CanCanter()
	{
		return Time.time - lastRoughTerrainTime > 1.5f;
	}

	private bool CanStartGalloping()
	{
		return GetStaminaFraction() > 0.04f;
	}

	public void RetrogradeGait()
	{
		if ((int)currentGait > 0)
		{
			currentGait--;
		}
	}

	private void ApplyHandBrake()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.ProjectOnPlane(Vector3.down, averagedUp);
		rigidBody.AddForce(-val * rigidBody.mass * 10f, (ForceMode)0);
		wheelCollider.brakeTorque = 10000f;
		wheelCollider.motorTorque = 0f;
	}

	private void AlignWithNormal(Vector3 normal, bool force = false)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normalized = ((Vector3)(ref normal)).normalized;
		Vector3 val = Vector3.ProjectOnPlane(((Component)this).transform.forward, normalized);
		Vector3 val2 = ((Vector3)(ref val)).normalized;
		if (val2 == Vector3.zero)
		{
			val2 = ((Component)this).transform.forward;
		}
		Quaternion val3 = Quaternion.LookRotation(val2, Vector3.up);
		Quaternion val4 = (force ? val3 : Quaternion.Slerp(rigidBody.rotation, val3, 5f * Time.fixedDeltaTime));
		rigidBody.MoveRotation(val4);
	}

	public void UpdateGroundNormal()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("RidableHorse.UpdateGroundNormal", 0);
		try
		{
			int num = 0;
			bool flag = false;
			List<Vector3> list = Pool.Get<List<Vector3>>();
			Vector3 val2 = Vector3.zero;
			Vector3 val3 = averagedUp;
			for (int i = 0; i < groundSampleOffsets.Length; i++)
			{
				Vector3 val4 = groundSampleOffsets[i].position + Vector3.up;
				if (GamePhysics.Trace(new Ray(val4, Vector3.down), 0f, out var hitInfo, 1.2f, 1503731969, (QueryTriggerInteraction)1, this))
				{
					Vector3 normal = ((RaycastHit)(ref hitInfo)).normal;
					num++;
					if (i == groundSampleOffsets.Length - 1)
					{
						flag = true;
					}
					val3 += normal;
					list.Add(normal);
					val2 += normal;
				}
				else
				{
					val3 += Vector3.up;
					list.Add(Vector3.up);
					val2 += Vector3.up;
				}
			}
			isGrounded = num >= 2;
			if (!IsSwimming && !flag && throttleInput == 0f)
			{
				throttleInput = 1f;
			}
			Vector3 val5 = val2 / (float)list.Count;
			Vector3 normalized = ((Vector3)(ref val5)).normalized;
			float num2 = 0f;
			for (int j = 0; j < list.Count; j++)
			{
				float num3 = Vector3.Angle(list[j], normalized);
				num2 += num3;
			}
			normalVariation = num2 / (float)list.Count;
			if (normalVariation > 25f && !onIdealTerrain)
			{
				lastRoughTerrainTime = Time.time;
			}
			val3 += Vector3.up;
			val3 /= (float)(groundSampleOffsets.Length + 1);
			((Vector3)(ref val3)).Normalize();
			if (normalVariation < 10f || Vector3.Dot(targetUp, val3) < 0.99f)
			{
				targetUp = val3;
			}
			averagedUp = Vector3.Lerp(averagedUp, targetUp, Time.fixedDeltaTime * groundAlignmentSpeed);
			groundAngle = Vector3.Angle(normalized, Vector3.up);
			Pool.FreeUnmanaged<Vector3>(ref list);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SetWheelStiffness(float forward, float sideways)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		WheelFrictionCurve forwardFriction = wheelCollider.forwardFriction;
		WheelFrictionCurve sidewaysFriction = wheelCollider.sidewaysFriction;
		((WheelFrictionCurve)(ref forwardFriction)).stiffness = forward;
		((WheelFrictionCurve)(ref sidewaysFriction)).stiffness = sideways;
		wheelCollider.forwardFriction = forwardFriction;
		wheelCollider.sidewaysFriction = sidewaysFriction;
	}

	private void AutoAvoidObstacles()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		if (currentAvoidanceState == HorseAvoidanceState.Normal && GetSpeedFraction() < 0.1f)
		{
			avoidanceSteeringInput = 0;
			return;
		}
		float num = Mathf.Lerp(avoidanceDetectionDistance.x, avoidanceDetectionDistance.y, GetSpeedFraction());
		Vector3 val = rigidBody.velocity;
		Vector3 val2;
		if (!(((Vector3)(ref val)).sqrMagnitude > 0.01f))
		{
			val2 = ((Component)this).transform.forward;
		}
		else
		{
			val = rigidBody.velocity;
			val2 = ((Vector3)(ref val)).normalized;
		}
		Vector3 val3 = ((Component)this).transform.right * steerInput * 0.4f;
		val = val2 + val3 * 0.4f;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = Vector3.Lerp(avoidanceScanDirection, normalized, Time.deltaTime * 5f);
		avoidanceScanDirection = ((Vector3)(ref val)).normalized;
		if (currentAvoidanceState == HorseAvoidanceState.Normal && Time.time < nextAutoAvoidanceCheckTime)
		{
			return;
		}
		nextAutoAvoidanceCheckTime = Time.time + Random.Range(0.1f, 0.2f);
		switch (currentAvoidanceState)
		{
		case HorseAvoidanceState.Normal:
		{
			if (DetectObstacleAhead(num, avoidanceScanDirection, out var _))
			{
				currentAvoidanceState = HorseAvoidanceState.AvoidingObstacle;
			}
			avoidanceSteeringInput = 0;
			break;
		}
		case HorseAvoidanceState.AvoidingObstacle:
		{
			int num2 = DetermineAvoidanceDirection(num);
			avoidanceSteeringInput = num2;
			if (!DetectObstacleAhead(num, ((Component)this).transform.forward, out var _))
			{
				if (steerInput != 0f && steerInput != (float)avoidanceSteeringInput)
				{
					currentAvoidanceState = HorseAvoidanceState.Normal;
					avoidanceSteeringInput = 0;
				}
				else
				{
					currentAvoidanceState = HorseAvoidanceState.Normal;
					avoidanceSteeringInput = 0;
				}
			}
			break;
		}
		}
	}

	private bool DetectObstacleAhead(float distance, Vector3 direction, out BaseEntity avoidedEnt)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		avoidedEnt = null;
		RaycastHit val = default(RaycastHit);
		if (Physics.SphereCast(((Component)this).transform.position + ((Component)this).transform.forward + Vector3.up * 1f, avoidanceSphereRadius, direction, ref val, distance, LayerMask.op_Implicit(avoidanceObstacleMask)))
		{
			BaseEntity baseEntity = ((RaycastHit)(ref val)).collider.ToBaseEntity();
			if (baseEntity is TreeEntity)
			{
				avoidedEnt = baseEntity;
				return true;
			}
			if (baseEntity is ResourceEntity)
			{
				Physics.IgnoreCollision((Collider)(object)wheelCollider, ((RaycastHit)(ref val)).collider);
			}
		}
		return false;
	}

	private int DetermineAvoidanceDirection(float detectDistance)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.forward + ((Component)this).transform.right * 0.5f;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = ((Component)this).transform.forward - ((Component)this).transform.right * 0.5f;
		Vector3 normalized2 = ((Vector3)(ref val)).normalized;
		float num = CheckSideClearance(normalized, detectDistance);
		float num2 = CheckSideClearance(normalized2, detectDistance);
		if (!(num > num2))
		{
			return -1;
		}
		return 1;
	}

	private float CheckSideClearance(Vector3 direction, float distance)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.SphereCast(((Component)this).transform.position + Vector3.up * 1f, avoidanceSphereRadius, direction, ref val, distance, LayerMask.op_Implicit(avoidanceObstacleMask)))
		{
			if (((RaycastHit)(ref val)).collider.ToBaseEntity() is TreeEntity)
			{
				return ((RaycastHit)(ref val)).distance;
			}
			return distance;
		}
		return distance;
	}

	public void OnRagdollCollisionEnter(Collision collision)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		OnLanded(Mathf.Abs(collision.relativeVelocity.y));
	}

	protected void OnCollisionEnter(Collision collision)
	{
		if (base.isServer)
		{
			ProcessCollision(collision, rigidBody);
		}
	}

	protected void ProcessCollision(Collision collision, Rigidbody ourRigidbody)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && collision != null && !((Object)(object)collision.gameObject == (Object)null) && !((Object)(object)collision.gameObject == (Object)null))
		{
			Vector3 relativeVelocity = collision.relativeVelocity;
			float num = ((Vector3)(ref relativeVelocity)).magnitude * rigidBody.mass;
			float num2 = Vector3.Dot(-((ContactPoint)(ref collision.contacts[0])).normal, ((Component)this).transform.forward);
			float num3 = Mathf.Lerp(0.2f, 1f, Mathf.Clamp01(num2));
			num *= num3;
			if (QueueCollisionDamage(this, num) > 0f)
			{
				TryShowCollisionFX(collision);
			}
		}
	}

	private float QueueCollisionDamage(BaseEntity hitEntity, float forceMagnitude)
	{
		float num = Mathf.InverseLerp(minCollisionDamageForce, maxCollisionDamageForce, forceMagnitude);
		if (num > 0f)
		{
			float num2 = Mathf.Lerp(1f, 200f, num) * collisionDamageMultiplier;
			if (damageSinceLastTick.TryGetValue(hitEntity, out var value))
			{
				if (value < num2)
				{
					damageSinceLastTick[hitEntity] = num2;
				}
			}
			else
			{
				damageSinceLastTick[hitEntity] = num2;
			}
		}
		return num;
	}

	protected virtual void DoCollisionDamage(BaseEntity hitEntity, float damage)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		lastCrashDamage = damage;
		if (damage > playerDamageThreshold)
		{
			float damage2 = (damage - playerDamageThreshold) / 4f;
			DamageAllRiders(damage2);
		}
		if (damage > playerRagdollThreshold)
		{
			Vector3 mountRagdollVelocity = GetMountRagdollVelocity(GetDriver());
			RagdollAllRiders(mountRagdollVelocity);
		}
		Hurt(damage, DamageType.Collision, this, useProtection: false);
		if (damage > playerRagdollThreshold && !IsDead() && !HasFlag(Flags.Reserved12))
		{
			RagdollHorse();
		}
	}

	private void OnLanded(float impactSpeed)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		float num = DamageFromFalling(impactSpeed, checkAirtime: true);
		if (num != 0f)
		{
			Hurt(num, DamageType.Fall, this, useProtection: false);
			TryShowCollisionFX(((Component)this).transform.position);
			if (num > playerDamageThreshold)
			{
				float damage = (num - playerDamageThreshold) / 4f;
				DamageAllRiders(damage);
			}
			if (num > 100f)
			{
				RagdollAllRiders();
			}
		}
	}

	private float DamageFromFalling(float impactSpeed, bool checkAirtime)
	{
		float result = 0f;
		if (impactSpeed > 5f && (!checkAirtime || airTime > 0.4f))
		{
			result = (impactSpeed - 5f) * 10f;
		}
		return result;
	}

	private void DamageAllRiders(float damage)
	{
		BasePlayer driver = GetDriver();
		if ((Object)(object)driver != (Object)null && !driver.IsDead())
		{
			driver.Hurt(damage, DamageType.Collision, this, useProtection: false);
		}
		BasePlayer passenger = GetPassenger();
		if ((Object)(object)passenger != (Object)null && !passenger.IsDead())
		{
			passenger.Hurt(damage, DamageType.Collision, this, useProtection: false);
		}
	}

	private void RagdollAllRiders(Vector3 force = default(Vector3))
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer driver = GetDriver();
		if ((Object)(object)driver != (Object)null && !driver.IsDead())
		{
			driver.Ragdoll(force);
		}
		BasePlayer passenger = GetPassenger();
		if ((Object)(object)passenger != (Object)null && !passenger.IsDead())
		{
			passenger.Ragdoll(force);
		}
	}

	public override GameObjectRef GetCollisionFX()
	{
		return collisionEffect;
	}

	public override Vector3 GetMountRagdollVelocity(BasePlayer player)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Clamp(lastCrashDamage, 0f, 75f);
		return ((Component)this).transform.forward * num * 0.25f;
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return Mathf.Abs(GetSpeed()) * 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
	}

	[ServerVar]
	public static void Ragdoll(Arg arg)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		List<RidableHorse> list = Pool.Get<List<RidableHorse>>();
		Vis.Entities(basePlayer.eyes.position, basePlayer.eyes.position + basePlayer.eyes.HeadForward() * 5f, 0f, list, -1, (QueryTriggerInteraction)2);
		foreach (RidableHorse item in list)
		{
			item.RagdollHorse();
		}
		Pool.FreeUnmanaged<RidableHorse>(ref list);
	}

	public void RagdollHorse()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (!Physics.allowhorsetempragdoll)
		{
			DismountAllPlayers();
		}
		else if (!HasFlag(Flags.Reserved12))
		{
			DismountAllPlayers();
			CreateRagdoll(((Component)this).transform.position, ((Component)this).transform.rotation);
			SetFlag(Flags.Reserved12, b: true);
			SendNetworkUpdateImmediate();
		}
	}

	private void CreateRagdoll(Vector3 position, Quaternion rotation)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		BaseAnimalRagdoll baseAnimalRagdoll = GameManager.server.CreateEntity(ragdollPrefab.resourcePath) as BaseAnimalRagdoll;
		if (baseAnimalRagdoll != null)
		{
			((Component)baseAnimalRagdoll).transform.SetPositionAndRotation(position, rotation);
		}
		Ragdoll ragdoll = ((baseAnimalRagdoll != null) ? ((Component)baseAnimalRagdoll).GetComponent<Ragdoll>() : null);
		if ((Object)(object)ragdoll != (Object)null)
		{
			ragdoll.simOnServer = true;
		}
		baseAnimalRagdoll?.InitFromEnt(this);
		baseAnimalRagdoll?.Spawn();
		GameObjectExtensions.SetIgnoreCollisions(((Component)this).gameObject, ((Component)baseAnimalRagdoll).gameObject, true);
	}

	private void OnRagdollStartServer()
	{
		TowDetach();
		SetLeading(null);
		rigidBody.isKinematic = true;
		((Collider)wheelCollider).enabled = false;
		SetWorldColliders(enabled: false);
		((Behaviour)serverLegsAnimator).enabled = false;
	}

	private void OnRagdollEndServer()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		rigidBody.isKinematic = false;
		((Collider)wheelCollider).enabled = true;
		currentGait = GaitType.Walk;
		UpdateGroundNormal();
		averagedUp = targetUp;
		AlignWithNormal(targetUp, force: true);
		isGrounded = true;
		airTime = 0f;
		lastMovingTime = Time.time;
		SetWorldColliders(enabled: true);
		ResetBonesPositions();
		((Behaviour)serverLegsAnimator).enabled = true;
		damageSinceLastTick.Clear();
		rigidBody.WakeUp();
	}

	private void SetWorldColliders(bool enabled)
	{
		List<Collider> list = Pool.Get<List<Collider>>();
		((Component)this).GetComponentsInChildren<Collider>(list);
		foreach (Collider item in list)
		{
			if (item.IsOnLayer((Layer)15))
			{
				item.enabled = enabled;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
	}

	private void UpdateOnTerrain()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		if (Time.time < nextTerrainCheckTime)
		{
			return;
		}
		nextTerrainCheckTime = Time.time + Random.Range(0.5f, 1f);
		onIdealTerrain = false;
		onWaterTopology = false;
		if ((Object)(object)TerrainMeta.TopologyMap != (Object)null)
		{
			int topology = TerrainMeta.TopologyMap.GetTopology(((Component)this).transform.position);
			if ((topology & 0x80800) != 0)
			{
				onIdealTerrain = true;
			}
			if ((topology & 0x14080) != 0)
			{
				onWaterTopology = true;
			}
		}
	}

	public void UpdateStamina(float delta)
	{
		if (currentGait == GaitType.Gallop)
		{
			UseStamina(delta);
		}
		else if (IsSwimming)
		{
			UseStamina(delta * 0.5f);
		}
		else if (currentStamina != currentMaxStamina)
		{
			ReplenishStamina(GetStaminaReplenishRatio() * delta);
		}
	}

	public void UseStamina(float amount)
	{
		if (onIdealTerrain)
		{
			amount *= 0.5f;
		}
		currentStamina -= amount;
		if (currentStamina <= 0f)
		{
			currentStamina = 0f;
		}
	}

	private float GetStaminaReplenishRatio()
	{
		return GetCurrentGait().staminaReplenishRatio;
	}

	public void ReplenishStamina(float amount)
	{
		float num = 1f + Mathf.InverseLerp(maxStamina * 0.5f, maxStamina, currentMaxStamina);
		amount *= num;
		amount = Mathf.Min(currentMaxStamina - currentStamina, amount);
		float num2 = Mathf.Min(currentMaxStamina - staminaCoreLossRatio * amount, amount * staminaCoreLossRatio);
		currentMaxStamina = Mathf.Clamp(currentMaxStamina - num2, 0f, maxStamina);
		currentStamina = Mathf.Clamp(currentStamina + num2 / staminaCoreLossRatio, 0f, currentMaxStamina);
		if (currentStamina == currentMaxStamina)
		{
			OnStaminaReplenished();
		}
	}

	private void OnStaminaReplenished()
	{
		UpdateClients(force: true);
	}

	public void ReplenishStaminaCore(float calories, float hydration)
	{
		float num = calories * calorieToStaminaRatio;
		float num2 = hydration * hydrationToStaminaRatio;
		num2 = Mathf.Min(maxStaminaCoreFromWater - currentMaxStamina, num2);
		if (num2 < 0f)
		{
			num2 = 0f;
		}
		float num3 = num + num2;
		currentMaxStamina = Mathf.Clamp(currentMaxStamina + num3, 0f, maxStamina);
		currentStamina = Mathf.Clamp(currentStamina + num3, 0f, currentMaxStamina);
	}

	public void SetLeading(BasePlayer target)
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.Reserved16, (Object)(object)target != (Object)null);
		if (!((Object)(object)target == (Object)(object)leadingPlayer))
		{
			if ((Object)(object)target != (Object)null)
			{
				playerLeadingId = target.net.ID;
				inputProvider = new AIHorseInputProvider(this, ((Component)target).transform, 3f);
				PlayerModifiers.AddToPlayer(target, pullingPlayerModifiers);
			}
			else
			{
				leadingPlayer.modifiers.RemoveFromSource(Modifier.ModifierSource.Interaction);
				playerLeadingId = default(NetworkableId);
			}
			leadingPlayer = target;
			SendNetworkUpdateImmediate();
			LeadingChanged();
			if ((Object)(object)leadingPlayer == (Object)null)
			{
				ClientRPC(RpcTarget.NetworkGroup("CLIENT_StopLeading"));
			}
			else
			{
				ClientRPC(RpcTarget.NetworkGroup("CLIENT_StartLeading"));
			}
		}
	}

	public void LeadingChanged()
	{
		if (!IsLeading)
		{
			TryToHitch();
		}
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_Lead(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		bool flag = msg.read.Bool();
		if (flag)
		{
			if (!CanLead(player))
			{
				return;
			}
		}
		else if (!CanStopLead(player))
		{
			return;
		}
		if (Interface.CallHook("OnHorseLead", (object)this, (object)player) == null)
		{
			SetLeading(flag ? player : null);
		}
	}

	public bool CanStand()
	{
		if (nextStandTime > Time.time)
		{
			return false;
		}
		if ((Object)(object)mountPoints[0].mountable == (Object)null)
		{
			return false;
		}
		return IsStandCollisionClear();
	}

	public virtual bool IsStandCollisionClear()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(((Component)mountPoints[0].mountable.eyePositionOverride).transform.position - ((Component)this).transform.forward * 1f, 2f, list, 2162689, (QueryTriggerInteraction)2);
		bool num = list.Count > 0;
		Pool.FreeUnmanaged<Collider>(ref list);
		return !num;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		InitContainers();
		SetBreed(Random.Range(0, breeds.Length));
		SetFlag(Flags.Reserved16, b: false);
		baseHorseProtection = baseProtection;
		riderProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
		baseProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
		baseProtection.Add(baseHorseProtection, 1f);
		rigidBody.centerOfMass = centreOfMassTransform.localPosition;
		terrainHandler = new VehicleTerrainHandler(this);
		towingTrigger.OnEntityEnterTrigger = HandleTowTrigger;
		towingTrigger.OnEntityLeaveTrigger = HandleTowTriggerLeave;
		towingAttachment = new TowingAttachment<RidableHorse>(this);
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.333f, 0.1f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)HorseDecay, Random.Range(30f, 60f), 60f, 6f);
		SpawnWildSaddle();
		EquipmentUpdate();
		if ((Object)(object)modifiers != (Object)null)
		{
			modifiers.ServerInit(this);
		}
	}

	public override void PreServerLoad()
	{
		base.PreServerLoad();
		CreateInventories(giveUID: false);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		ReleaseInventories();
	}

	private void ServerFlagsChanged(Flags old, Flags next)
	{
		if ((old & Flags.Reserved3) != 0 && (next & Flags.Reserved3) != 0)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)EatFromHitch, Random.Range(1f, 2f), 2f);
		}
		if ((next & Flags.Reserved13) != 0 && (next & Flags.Reserved14) != 0)
		{
			TowDetach();
		}
		bool flag = (old & Flags.Reserved12) != 0;
		bool flag2 = (next & Flags.Reserved12) != 0;
		if (!flag && flag2)
		{
			OnRagdollStartServer();
		}
		else if (flag && !flag2)
		{
			OnRagdollEndServer();
		}
	}

	private void SpawnWildSaddle()
	{
		SetSeatCount(1);
	}

	public void SetForSale()
	{
		SetFlag(Flags.Reserved2, b: true);
		SetSeatCount(0);
	}

	protected override int GetClipCheckMask()
	{
		return base.GetClipCheckMask() & -1073741825;
	}

	private bool IsHorseClipping()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 localToWorldMatrix = ((Component)clippingMountCheckCollider).transform.localToWorldMatrix;
		Vector3 val = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(clippingMountCheckCollider.center);
		Vector3 val2 = Vector3.zero;
		((Vector3)(ref val2))[clippingMountCheckCollider.direction] = 1f;
		val2 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyVector(val2);
		float num = clippingMountCheckCollider.radius * 0.9f;
		float num2 = 0.5f * clippingMountCheckCollider.height * 0.9f - num;
		Vector3 point = val + val2 * num2;
		Vector3 point2 = val - val2 * num2;
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapCapsule(point, point2, num, list, 1235583233, (QueryTriggerInteraction)1);
		for (int i = 0; i < list.Count; i++)
		{
			BaseEntity baseEntity = list[i].ToBaseEntity();
			if ((Object)(object)baseEntity != (Object)null && (baseEntity.isClient != base.isClient || (Object)(object)baseEntity == (Object)(object)this))
			{
				ListEx.RemoveUnordered<Collider>(list, i);
				i--;
			}
		}
		bool result = list.Count > 0;
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (IsForSale || !MountEligable(player) || HasFlag(Flags.Reserved12) || IsPlayerTooHeavy(player) || !CanPlayerSeeSaddlePoint(player) || IsHorseClipping())
		{
			return;
		}
		BaseMountable baseMountable = null;
		if (HasSingleSaddle && !player.IsRestrained)
		{
			baseMountable = mountPoints[0].mountable;
		}
		else
		{
			if (!HasDoubleSaddle)
			{
				return;
			}
			baseMountable = ((HasDriver() || player.IsRestrained) ? mountPoints[2].mountable : mountPoints[1].mountable);
		}
		if ((Object)(object)baseMountable != (Object)null)
		{
			baseMountable.AttemptMount(player, doMountChecks);
		}
	}

	public override void PlayerMounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerMounted(player, seat);
		UpdateClients();
		TryLeaveHitch();
		if (IsLeading)
		{
			SetLeading(null);
		}
		if (IsDriver(player))
		{
			((Component)playerServerCollider).gameObject.SetActive(true);
			inputProvider = new PlayerHorseInputProvider(player);
		}
		if (IsPassenger(player))
		{
			((Component)playerServerColliderRear).gameObject.SetActive(true);
		}
		((FacepunchBehaviour)this).InvokeRepeating((Action)SaveTraveledDistance, 10f, 10f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)PostPlayerLateUpdate, 0f, 0f);
	}

	public override void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerDismounted(player, seat);
		UpdateClients(force: true);
		if (NumMounted() == 0)
		{
			TryToHitch();
		}
		if ((Object)(object)GetDriver() == (Object)null)
		{
			((Component)playerServerCollider).gameObject.SetActive(false);
			inputProvider = null;
		}
		if ((Object)(object)GetPassenger() == (Object)null)
		{
			((Component)playerServerColliderRear).gameObject.SetActive(false);
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)SaveTraveledDistance);
		((FacepunchBehaviour)this).CancelInvoke((Action)PostPlayerLateUpdate);
		lastRiddenTime = Time.time;
	}

	private void PostPlayerLateUpdate()
	{
		if (!AnyMounted())
		{
			return;
		}
		foreach (MountPointInfo allMountPoint in base.allMountPoints)
		{
			if (!((Object)(object)allMountPoint.mountable == (Object)null) && !((Object)(object)allMountPoint.mountable.GetMounted() == (Object)null))
			{
				allMountPoint.mountable.MountedPlayerSync();
			}
		}
	}

	private void SetSeatCount(int count)
	{
		SetFlag(Flags.Reserved9, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved10, b: false, recursive: false, networkupdate: false);
		switch (count)
		{
		case 1:
			SetFlag(Flags.Reserved9, b: true, recursive: false, networkupdate: false);
			break;
		case 2:
			SetFlag(Flags.Reserved10, b: true, recursive: false, networkupdate: false);
			break;
		}
		UpdateMountFlags();
	}

	public override bool IsPlayerSeatSwapValid(BasePlayer player, int fromIndex, int toIndex, bool ignoreRestraint)
	{
		if (!base.IsPlayerSeatSwapValid(player, fromIndex, toIndex, ignoreRestraint))
		{
			return false;
		}
		if (!HasSaddle)
		{
			return false;
		}
		if (HasSingleSaddle)
		{
			return false;
		}
		if (HasDoubleSaddle && toIndex == 0)
		{
			return false;
		}
		return true;
	}

	public override int MaxMounted()
	{
		return GetSeatCapacity();
	}

	public int GetSeatCapacity()
	{
		if (HasDoubleSaddle)
		{
			return 2;
		}
		if (HasSingleSaddle)
		{
			return 1;
		}
		return 0;
	}

	public override int NumSwappableSeats()
	{
		return mountPoints.Count;
	}

	public override void OnDied(HitInfo hitInfo)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		BaseCorpse baseCorpse = DropCorpse(corpsePrefab.resourcePath);
		if (Object.op_Implicit((Object)(object)baseCorpse))
		{
			SetupCorpse(baseCorpse);
			baseCorpse.Spawn();
			baseCorpse.TakeChildren(this);
		}
		SaveTraveledDistance();
		TryLeaveHitch();
		TowDetach();
		RagdollAllRiders();
		((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0.5f);
		base.OnDied(hitInfo);
	}

	public override void AdminKill()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		SaveTraveledDistance();
		TryLeaveHitch();
		TowDetach();
		RagdollAllRiders();
		((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0.5f);
		base.AdminKill();
	}

	public virtual void SetupCorpse(BaseCorpse corpse)
	{
		corpse.flags = flags;
		LootableCorpse component = ((Component)corpse).GetComponent<LootableCorpse>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.TakeFrom(this, storageInventory);
		}
		HorseCorpse component2 = ((Component)corpse).GetComponent<HorseCorpse>();
		if (Object.op_Implicit((Object)(object)component2))
		{
			component2.breedIndex = currentBreedIndex;
		}
	}

	private void UpdateClients()
	{
		UpdateClients(force: true);
	}

	private void UpdateClients(bool force = false)
	{
		if (force || AnyMounted() || IsLeading)
		{
			byte num = (byte)((duckInputDown ? (-1f) : throttleInput) + 1f);
			byte b = (byte)(steerInput + 1f);
			byte b2 = (byte)(avoidanceSteeringInput + 1);
			byte arg = (byte)(num | (b << 2) | (b2 << 4));
			byte arg2 = (byte)Mathf.Clamp(normalVariation / 100f * 255f, 0f, 255f);
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_HorseUpdate"), currentStamina, currentMaxStamina, (byte)currentGait, arg, arg2);
		}
	}

	public override void OnMountedPlayerWeightChanged(BasePlayer player)
	{
		base.OnMountedPlayerWeightChanged(player);
		if (IsPlayerTooHeavy(player))
		{
			player.EnsureDismounted();
		}
	}

	private void SaveTraveledDistance()
	{
		BasePlayer driver = GetDriver();
		if ((Object)(object)driver == (Object)null)
		{
			tempDistanceTravelled = 0f;
			return;
		}
		kmDistance += tempDistanceTravelled / 1000f;
		if (kmDistance >= 1f)
		{
			driver.stats.Add("horse_distance_ridden_km", 1, (Stats)5);
			kmDistance -= 1f;
		}
		driver.stats.Add("horse_distance_ridden", Mathf.FloorToInt(tempDistanceTravelled));
		driver.stats.Save();
		tempDistanceTravelled = 0f;
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		riderProtection.Scale(info.damageTypes);
	}

	public void OnTowAttach()
	{
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			ComponentExtensions.SetActive<TriggerTowing>(towingTrigger, false);
		}, 0f);
	}

	public void OnTowDetach()
	{
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			ComponentExtensions.SetActive<TriggerTowing>(towingTrigger, true);
		}, 1f);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	public void SERVER_RequestTow(RPCMessage msg)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (towableEntity != null && !IsTowing && !HasFlag(Flags.Reserved12))
		{
			TowAttach(msg.player);
			Effect.server.Run(towingAttachEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	public void SERVER_RequestDetach(RPCMessage msg)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (IsTowing)
		{
			BasePlayer player = msg.player;
			if (!((Object)(object)player == (Object)null) && (!AnyMounted() || !((Object)(object)player.GetMounted().VehicleParent() != (Object)(object)this)))
			{
				TowDetach();
				Effect.server.Run(towingDetachEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

	private void TowAttach(BasePlayer requester = null)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		if (towableEntity == null || !towableEntity.IsTowingAllowed)
		{
			return;
		}
		if (Vector3.Dot(TowAnchor.forward, ((Component)towableEntity.TowAnchor).transform.forward) <= 0.5f)
		{
			if ((Object)(object)requester != (Object)null)
			{
				requester.ShowToast(GameTip.Styles.Error, TowAngleErrorPhrase, false);
			}
			return;
		}
		towingEntityId = towableEntity.TowEntity.net.ID;
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_SetTowId"), towableEntity.TowEntity.net.ID);
		towingAttachment.AttachTo(towableEntity);
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			ComponentExtensions.SetActive<TriggerTowing>(towingTrigger, false);
		}, 0f);
	}

	private void TowDetach()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (IsTowing)
		{
			towingEntityId = default(NetworkableId);
			((BaseEntity)this).ClientRPC(RpcTarget.NetworkGroup("CLIENT_SetTowId"), default(NetworkableId));
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_CanTow"), arg1: false);
			towableEntity = null;
			towingAttachment.Detach();
		}
	}

	private void ValidateTowableEntity()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (towableEntity != null)
		{
			towingEntityId = towableEntity.TowEntity.net.ID;
		}
		else
		{
			towableEntity = BaseNetworkable.serverEntities.Find(towingEntityId) as ITowing;
		}
	}

	private void HandleTowTrigger(BaseNetworkable networkable)
	{
		if (networkable is ITowing { IsTowing: false } towing)
		{
			towableEntity = towing;
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_CanTow"), arg1: true);
		}
		else
		{
			towableEntity = null;
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_CanTow"), arg1: false);
		}
	}

	private void HandleTowTriggerLeave(BaseNetworkable networkable)
	{
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_CanTow"), arg1: false);
		towableEntity = null;
	}

	public void OnJointBreak(float breakForce)
	{
		TowDetach();
	}

	private void HorseDecay()
	{
		if (base.healthFraction != 0f && !base.IsDestroyed && !(Time.time < lastRiddenTime + 600f) && !(Time.time < lastEatTime + 600f) && !IsForSale && !(Time.time < nextDecayTime))
		{
			float num = 1f / decayMinutes;
			float num2 = ((!IsOutside()) ? 1f : 0.5f);
			Hurt(MaxHealth() * num * num2, DamageType.Decay, this, useProtection: false);
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (!IsForSale)
		{
			base.Hurt(info);
		}
	}

	private void AddDecayDelay(float time)
	{
		if (nextDecayTime < Time.time)
		{
			nextDecayTime = Time.time + 5f;
		}
		nextDecayTime += time;
	}

	[ServerVar]
	public static void SetHorseBreed(Arg arg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		int @int = arg.GetInt(0, 0);
		List<RidableHorse> list = Pool.Get<List<RidableHorse>>();
		Vis.Entities(basePlayer.eyes.position, basePlayer.eyes.position + basePlayer.eyes.HeadForward() * 5f, 0f, list, -1, (QueryTriggerInteraction)2);
		foreach (RidableHorse item in list)
		{
			item.SetBreed(@int);
		}
		Pool.FreeUnmanaged<RidableHorse>(ref list);
	}

	[ServerVar]
	public static void SetForSale(Arg arg)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		List<RidableHorse> list = Pool.Get<List<RidableHorse>>();
		Vis.Entities(basePlayer.eyes.position, basePlayer.eyes.position + basePlayer.eyes.HeadForward() * 5f, 0f, list, -1, (QueryTriggerInteraction)2);
		foreach (RidableHorse item in list)
		{
			item.SetForSale();
		}
		Pool.FreeUnmanaged<RidableHorse>(ref list);
	}

	public override bool AdminFixUp(int tier)
	{
		if (IsDead())
		{
			return false;
		}
		ReplenishStamina(1000f);
		ReplenishStaminaCore(10000f, 10000f);
		return base.AdminFixUp(tier);
	}
}


public enum GaitType : byte
{
	Walk,
	Trot,
	Canter,
	Gallop
}


using System;

[Serializable]
public struct Gait
{
	public GaitType gaitType;

	public float minSpeed;

	public float maxSpeed;

	public float accelerationForce;

	public float brakingForce;

	public float turnSpeed;

	public float staminaReplenishRatio;

	public bool equipmentScalesMaxSpeed;

	public bool breedScalesMaxSpeed;
}


using System;
using UnityEngine;

[Serializable]
public struct PurchaseOption
{
	public ItemDefinition tokenItem;

	public Phrase title;

	public Phrase description;

	public Sprite icon;

	public int order;
}


public enum HorseAvoidanceState
{
	Normal,
	AvoidingObstacle
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class RustigeEgg : BaseCombatEntity
{
	public const Flags Flag_Spin = Flags.Reserved1;

	public Transform eggRotationTransform;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RustigeEgg.OnRpcMessage", 0);
		try
		{
			if (rpc == 4254195175u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Open "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Open", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4254195175u, "RPC_Open", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Open(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Open");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1455840454 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Spin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Spin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1455840454u, "RPC_Spin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_Spin(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Spin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsSpinning()
	{
		return HasFlag(Flags.Reserved1);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Spin(RPCMessage msg)
	{
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Open(RPCMessage msg)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null)
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag != IsOpen())
		{
			if (flag)
			{
				ClientRPC(RpcTarget.NetworkGroup("FaceEggPosition"), msg.player.eyes.position);
				((FacepunchBehaviour)this).Invoke((Action)CloseEgg, 60f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)CloseEgg);
			}
			SetFlag(Flags.Open, flag, recursive: false, networkupdate: false);
			if (IsSpinning() && flag)
			{
				SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
			}
			SendNetworkUpdateImmediate();
		}
	}

	public void CloseEgg()
	{
		SetFlag(Flags.Open, b: false);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SamSite : ContainerIOEntity
{
	public interface ISamSiteTarget
	{
		static List<ISamSiteTarget> serverList;

		SamTargetType SAMTargetType { get; }

		bool isClient { get; }

		bool IsValidSAMTarget(bool staticRespawn);

		Vector3 CenterPoint();

		Vector3 GetWorldVelocity();

		bool IsVisible(Vector3 position, float maxDistance = float.PositiveInfinity);

		static ISamSiteTarget()
		{
			serverList = new List<ISamSiteTarget>();
		}
	}

	public class SamTargetType
	{
		public readonly float scanRadius;

		public readonly float speedMultiplier;

		public readonly float timeBetweenBursts;

		public SamTargetType(float scanRadius, float speedMultiplier, float timeBetweenBursts)
		{
			this.scanRadius = scanRadius;
			this.speedMultiplier = speedMultiplier;
			this.timeBetweenBursts = timeBetweenBursts;
		}
	}

	public Animator pitchAnimator;

	public GameObject yaw;

	public GameObject pitch;

	public GameObject gear;

	public Transform eyePoint;

	public float gearEpislonDegrees = 20f;

	public float turnSpeed = 1f;

	public float clientLerpSpeed = 1f;

	public Vector3 currentAimDir = Vector3.forward;

	public Vector3 targetAimDir = Vector3.forward;

	public float vehicleScanRadius = 350f;

	public float missileScanRadius = 500f;

	public GameObjectRef projectileTest;

	public GameObjectRef muzzleFlashTest;

	public bool staticRespawn;

	public ItemDefinition ammoType;

	public Transform[] tubes;

	[ServerVar(Help = "how long until static sam sites auto repair")]
	public static float staticrepairseconds = 1200f;

	public SoundDefinition yawMovementLoopDef;

	public float yawGainLerp = 8f;

	public float yawGainMovementSpeedMult = 0.1f;

	public SoundDefinition pitchMovementLoopDef;

	public float pitchGainLerp = 10f;

	public float pitchGainMovementSpeedMult = 0.5f;

	public int lowAmmoThreshold = 5;

	public Flags Flag_TargetMode = Flags.Reserved9;

	public Flags Flag_ManuallySetMode = Flags.Reserved10;

	public static SamTargetType targetTypeUnknown;

	public static SamTargetType targetTypeVehicle;

	public static SamTargetType targetTypeMissile;

	public ISamSiteTarget currentTarget;

	public SamTargetType mostRecentTargetType;

	public Item ammoItem;

	public float lockOnTime;

	public float lastTargetVisibleTime;

	public int lastAmmoCount;

	public int currentTubeIndex;

	public int firedCount;

	public float nextBurstTime;

	private int input1Amount;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SamSite.OnRpcMessage", 0);
		try
		{
			if (rpc == 3160662357u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ToggleDefenderMode "));
				}
				TimeWarning val2 = TimeWarning.New("ToggleDefenderMode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3160662357u, "ToggleDefenderMode", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3160662357u, "ToggleDefenderMode", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ToggleDefenderMode(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ToggleDefenderMode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool IsPowered()
	{
		if (!staticRespawn)
		{
			return HasFlag(Flags.Reserved8);
		}
		return true;
	}

	public override int ConsumptionAmount()
	{
		return 25;
	}

	public bool IsInDefenderMode()
	{
		return HasFlag(Flag_TargetMode);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}

	public void SetTarget(ISamSiteTarget target)
	{
		bool num = currentTarget != target;
		currentTarget = target;
		if (!target.IsUnityNull())
		{
			mostRecentTargetType = target.SAMTargetType;
		}
		if (num)
		{
			MarkIODirty();
		}
	}

	public void MarkIODirty()
	{
		if (!staticRespawn)
		{
			lastPassthroughEnergy = -1;
			MarkDirtyForceUpdateOutputs();
		}
	}

	public void ClearTarget()
	{
		SetTarget(null);
	}

	public override void ServerInit()
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		targetTypeUnknown = new SamTargetType(vehicleScanRadius, 1f, 5f);
		targetTypeVehicle = new SamTargetType(vehicleScanRadius, 1f, 5f);
		targetTypeMissile = new SamTargetType(missileScanRadius, 2.25f, 3.5f);
		mostRecentTargetType = targetTypeUnknown;
		ClearTarget();
		((FacepunchBehaviour)this).InvokeRandomized((Action)TargetScan, 1f, 3f, 0.2f);
		currentAimDir = ((Component)this).transform.forward;
		if (base.inventory != null && !staticRespawn)
		{
			base.inventory.onItemAddedRemoved = OnItemAddedRemoved;
		}
	}

	public void OnItemAddedRemoved(Item arg1, bool arg2)
	{
		EnsureReloaded();
		if (IsPowered())
		{
			MarkIODirty();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.samSite = Pool.Get<SAMSite>();
		info.msg.samSite.aimDir = GetAimDir();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (staticRespawn && HasFlag(Flags.Reserved1))
		{
			((FacepunchBehaviour)this).Invoke((Action)SelfHeal, staticrepairseconds);
		}
	}

	public void SelfHeal()
	{
		lifestate = LifeState.Alive;
		base.health = startHealth;
		SetFlag(Flags.Reserved1, b: false);
	}

	public override void Die(HitInfo info = null)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (staticRespawn)
		{
			ClearTarget();
			Quaternion val = Quaternion.LookRotation(currentAimDir, Vector3.up);
			val = Quaternion.Euler(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f);
			currentAimDir = val * Vector3.forward;
			((FacepunchBehaviour)this).Invoke((Action)SelfHeal, staticrepairseconds);
			lifestate = LifeState.Dead;
			base.health = 0f;
			SetFlag(Flags.Reserved1, b: true);
		}
		else
		{
			base.Die(info);
		}
	}

	public void FixedUpdate()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = currentAimDir;
		if (!currentTarget.IsUnityNull() && IsPowered())
		{
			float num = projectileTest.Get().GetComponent<ServerProjectile>().speed * currentTarget.SAMTargetType.speedMultiplier;
			Vector3 val2 = currentTarget.CenterPoint();
			float num2 = Vector3.Distance(val2, ((Component)eyePoint).transform.position);
			float num3 = num2 / num;
			Vector3 val3 = val2 + currentTarget.GetWorldVelocity() * num3;
			num3 = Vector3.Distance(val3, ((Component)eyePoint).transform.position) / num;
			val3 = val2 + currentTarget.GetWorldVelocity() * num3;
			Vector3 val4 = currentTarget.GetWorldVelocity();
			if (((Vector3)(ref val4)).magnitude > 0.1f)
			{
				float num4 = Mathf.Sin(Time.time * 3f) * (1f + num3 * 0.5f);
				Vector3 val5 = val3;
				val4 = currentTarget.GetWorldVelocity();
				val3 = val5 + ((Vector3)(ref val4)).normalized * num4;
			}
			val4 = val3 - ((Component)eyePoint).transform.position;
			currentAimDir = ((Vector3)(ref val4)).normalized;
			if (num2 > currentTarget.SAMTargetType.scanRadius)
			{
				ClearTarget();
			}
		}
		Quaternion val6 = Quaternion.LookRotation(currentAimDir, ((Component)this).transform.up);
		Vector3 eulerAngles = ((Quaternion)(ref val6)).eulerAngles;
		eulerAngles = BaseMountable.ConvertVector(eulerAngles);
		float num5 = Mathf.InverseLerp(0f, 90f, 0f - eulerAngles.x);
		float num6 = Mathf.Lerp(15f, -75f, num5);
		Quaternion localRotation = Quaternion.Euler(0f, eulerAngles.y, 0f);
		yaw.transform.localRotation = localRotation;
		Quaternion localRotation2 = pitch.transform.localRotation;
		float x = ((Quaternion)(ref localRotation2)).eulerAngles.x;
		localRotation2 = pitch.transform.localRotation;
		Quaternion localRotation3 = Quaternion.Euler(x, ((Quaternion)(ref localRotation2)).eulerAngles.y, num6);
		pitch.transform.localRotation = localRotation3;
		if (currentAimDir != val)
		{
			SendNetworkUpdate();
		}
	}

	public Vector3 GetAimDir()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return currentAimDir;
	}

	public bool HasValidTarget()
	{
		return !currentTarget.IsUnityNull();
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (HasAmmo())
		{
			pickupErrorToFormat = (format: PickupErrors.ItemInventoryMustBeEmpty, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	private void AddTargetSet(List<ISamSiteTarget> allTargets, float scanRadius)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		foreach (ISamSiteTarget server in ISamSiteTarget.serverList)
		{
			if (!(server is MLRSRocket) && Vector3.Distance(server.CenterPoint(), ((Component)eyePoint).transform.position) < scanRadius)
			{
				allTargets.Add(server);
			}
		}
	}

	private void AddMLRSRockets(List<ISamSiteTarget> allTargets, float scanRadius)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (MLRSRocket.serverList.Count == 0)
		{
			return;
		}
		foreach (MLRSRocket server in MLRSRocket.serverList)
		{
			if (Vector3.Distance(((Component)server).transform.position, ((Component)this).transform.position) < scanRadius)
			{
				allTargets.Add(server);
			}
		}
	}

	public void TargetScan()
	{
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		if (!IsPowered())
		{
			lastTargetVisibleTime = 0f;
			return;
		}
		if (Time.time > lastTargetVisibleTime + 3f)
		{
			ClearTarget();
		}
		if (!staticRespawn)
		{
			int num = ((ammoItem != null && ammoItem.parent == base.inventory) ? ammoItem.amount : 0);
			bool flag = lastAmmoCount < lowAmmoThreshold;
			bool flag2 = num < lowAmmoThreshold;
			if (num != lastAmmoCount && flag != flag2)
			{
				MarkIODirty();
			}
			lastAmmoCount = num;
		}
		if (HasValidTarget() || IsDead())
		{
			return;
		}
		List<ISamSiteTarget> list = Pool.Get<List<ISamSiteTarget>>();
		if (Interface.CallHook("OnSamSiteTargetScan", (object)this, (object)list) == null)
		{
			if (!IsInDefenderMode())
			{
				AddTargetSet(list, targetTypeVehicle.scanRadius);
			}
			AddMLRSRockets(list, targetTypeMissile.scanRadius);
		}
		ISamSiteTarget samSiteTarget = null;
		foreach (ISamSiteTarget item in list)
		{
			if (!item.isClient && !(item.CenterPoint().y < ((Component)eyePoint).transform.position.y) && item.IsVisible(((Component)eyePoint).transform.position, item.SAMTargetType.scanRadius * 2f) && item.IsValidSAMTarget(staticRespawn) && Interface.CallHook("OnSamSiteTarget", (object)this, (object)item) == null)
			{
				samSiteTarget = item;
				break;
			}
		}
		if (!samSiteTarget.IsUnityNull() && currentTarget != samSiteTarget)
		{
			lockOnTime = Time.time + 0.5f;
		}
		SetTarget(samSiteTarget);
		if (!currentTarget.IsUnityNull())
		{
			lastTargetVisibleTime = Time.time;
		}
		Pool.FreeUnmanaged<ISamSiteTarget>(ref list);
		if (currentTarget.IsUnityNull())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)WeaponTick);
		}
		else
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)WeaponTick, 0f, 0.5f, 0.2f);
		}
	}

	public virtual bool HasAmmo()
	{
		if (!staticRespawn)
		{
			if (ammoItem != null && ammoItem.amount > 0)
			{
				return ammoItem.parent == base.inventory;
			}
			return false;
		}
		return true;
	}

	public void Reload()
	{
		if (staticRespawn)
		{
			return;
		}
		for (int i = 0; i < base.inventory.itemList.Count; i++)
		{
			Item item = base.inventory.itemList[i];
			if (item != null && item.info.itemid == ammoType.itemid && item.amount > 0)
			{
				ammoItem = item;
				return;
			}
		}
		ammoItem = null;
	}

	public void EnsureReloaded()
	{
		if (!HasAmmo())
		{
			Reload();
		}
	}

	public bool IsReloading()
	{
		return ((FacepunchBehaviour)this).IsInvoking((Action)Reload);
	}

	public void WeaponTick()
	{
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		if (IsDead() || Time.time < lockOnTime || Time.time < nextBurstTime)
		{
			return;
		}
		if (!IsPowered())
		{
			firedCount = 0;
			return;
		}
		if (firedCount >= 6)
		{
			float timeBetweenBursts = mostRecentTargetType.timeBetweenBursts;
			nextBurstTime = Time.time + timeBetweenBursts;
			firedCount = 0;
			return;
		}
		EnsureReloaded();
		if (Interface.CallHook("CanSamSiteShoot", (object)this) == null && HasAmmo())
		{
			bool num = ammoItem != null && ammoItem.amount == lowAmmoThreshold;
			if (!staticRespawn && ammoItem != null)
			{
				ammoItem.UseItem();
			}
			firedCount++;
			float speedMultiplier = 1f;
			if (!currentTarget.IsUnityNull())
			{
				speedMultiplier = currentTarget.SAMTargetType.speedMultiplier;
			}
			FireProjectile(tubes[currentTubeIndex].position, currentAimDir, speedMultiplier);
			Effect.server.Run(muzzleFlashTest.resourcePath, this, StringPool.Get("Tube " + (currentTubeIndex + 1)), Vector3.zero, Vector3.up);
			currentTubeIndex++;
			if (currentTubeIndex >= tubes.Length)
			{
				currentTubeIndex = 0;
			}
			if (num)
			{
				MarkIODirty();
			}
		}
	}

	public void FireProjectile(Vector3 origin, Vector3 direction, float speedMultiplier)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(projectileTest.resourcePath, origin, Quaternion.LookRotation(direction, Vector3.up));
		if (!((Object)(object)baseEntity == (Object)null))
		{
			baseEntity.creatorEntity = this;
			ServerProjectile component = ((Component)baseEntity).GetComponent<ServerProjectile>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.InitializeVelocity(GetInheritedProjectileVelocity(direction) + direction * component.speed * speedMultiplier);
			}
			baseEntity.Spawn();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int result = Mathf.Min(1, GetCurrentEnergy());
		switch (outputSlot)
		{
		case 0:
			if (currentTarget.IsUnityNull())
			{
				return 0;
			}
			return result;
		case 1:
			if (ammoItem == null || ammoItem.amount >= lowAmmoThreshold || ammoItem.parent != base.inventory)
			{
				return 0;
			}
			return result;
		case 2:
			if (HasAmmo())
			{
				return 0;
			}
			return result;
		default:
			return GetCurrentEnergy();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	private void ToggleDefenderMode(RPCMessage msg)
	{
		if (staticRespawn)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && player.CanBuild())
		{
			bool flag = msg.read.Bit();
			if (flag != IsInDefenderMode() && Interface.CallHook("OnSamSiteModeToggle", (object)this, (object)player, (object)flag) == null)
			{
				SetFlag(Flag_ManuallySetMode, flag);
				SetFlag(Flag_TargetMode, flag);
			}
		}
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		switch (inputSlot)
		{
		case 0:
			base.UpdateFromInput(inputAmount, inputSlot);
			break;
		case 1:
			if (input1Amount != inputAmount)
			{
				bool flag = HasFlag(Flag_ManuallySetMode);
				SetFlag(Flag_TargetMode, (inputAmount == 0) ? flag : (!flag));
			}
			input1Amount = inputAmount;
			break;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public interface ISamSiteTarget
{
	static List<ISamSiteTarget> serverList;

	SamTargetType SAMTargetType { get; }

	bool isClient { get; }

	bool IsValidSAMTarget(bool staticRespawn);

	Vector3 CenterPoint();

	Vector3 GetWorldVelocity();

	bool IsVisible(Vector3 position, float maxDistance = float.PositiveInfinity);

	static ISamSiteTarget()
	{
		serverList = new List<ISamSiteTarget>();
	}
}


public class SamTargetType
{
	public readonly float scanRadius;

	public readonly float speedMultiplier;

	public readonly float timeBetweenBursts;

	public SamTargetType(float scanRadius, float speedMultiplier, float timeBetweenBursts)
	{
		this.scanRadius = scanRadius;
		this.speedMultiplier = speedMultiplier;
		this.timeBetweenBursts = timeBetweenBursts;
	}
}


using System;
using Network;
using UnityEngine;

public class SantaSleigh : BaseEntity
{
	public GameObjectRef prefabDrop;

	public SpawnFilter filter;

	public Transform dropOrigin;

	[ServerVar]
	public static float altitudeAboveTerrain = 50f;

	[ServerVar]
	public static float desiredAltitude = 60f;

	public Light bigLight;

	public SoundPlayer hohoho;

	public float hohohospacing = 4f;

	public float hohoho_additional_spacing = 2f;

	public Vector3 swimScale;

	public Vector3 swimSpeed;

	public float appliedSwimScale = 1f;

	public float appliedSwimRotation = 20f;

	private Vector3 startPos;

	private Vector3 endPos;

	private float secondsToTake;

	private float secondsTaken;

	private bool dropped;

	public Vector3 dropPosition = Vector3.zero;

	private float swimRandom;

	private const string path = "assets/prefabs/misc/xmas/sleigh/santasleigh.prefab";

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SantaSleigh.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public void InitDropPosition(Vector3 newDropPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		dropPosition = newDropPosition;
		dropPosition.y = 0f;
	}

	public override void ServerInit()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (dropPosition == Vector3.zero)
		{
			dropPosition = RandomDropPosition();
		}
		UpdateDropPosition(dropPosition);
		((FacepunchBehaviour)this).Invoke((Action)SendHoHoHo, 0f);
	}

	public void SendHoHoHo()
	{
		((FacepunchBehaviour)this).Invoke((Action)SendHoHoHo, hohohospacing + Random.Range(0f, hohoho_additional_spacing));
		ClientRPC(RpcTarget.NetworkGroup("ClientPlayHoHoHo"));
	}

	public Vector3 RandomDropPosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		float num = 100f;
		float x = TerrainMeta.Size.x;
		do
		{
			zero = Vector3Ex.Range(0f - x / 3f, x / 3f);
		}
		while (filter.GetFactor(zero) == 0f && (num -= 1f) > 0f);
		zero.y = 0f;
		return zero;
	}

	public void UpdateDropPosition(Vector3 newDropPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float y = altitudeAboveTerrain;
		startPos = Vector3Ex.Range(-1f, 1f);
		startPos.y = 0f;
		((Vector3)(ref startPos)).Normalize();
		startPos *= x * 1.25f;
		startPos.y = y;
		endPos = startPos * -1f;
		endPos.y = startPos.y;
		startPos += newDropPosition;
		endPos += newDropPosition;
		secondsToTake = Vector3.Distance(startPos, endPos) / 25f;
		secondsToTake *= Random.Range(0.95f, 1.05f);
		((Component)this).transform.SetPositionAndRotation(startPos, Quaternion.LookRotation(endPos - startPos));
		dropPosition = newDropPosition;
	}

	private void FixedUpdate()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		Quaternion rotation = ((Component)this).transform.rotation;
		secondsTaken += Time.deltaTime;
		float num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
		if (!dropped && num >= 0.5f)
		{
			dropped = true;
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, ((Component)dropOrigin).transform.position);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.globalBroadcast = true;
				baseEntity.Spawn();
			}
		}
		position = Vector3.Lerp(startPos, endPos, num);
		Vector3 val = endPos - startPos;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = Vector3.zero;
		if (swimScale != Vector3.zero)
		{
			if (swimRandom == 0f)
			{
				swimRandom = Random.Range(0f, 20f);
			}
			float num2 = Time.time + swimRandom;
			((Vector3)(ref val2))..ctor(Mathf.Sin(num2 * swimSpeed.x) * swimScale.x, Mathf.Cos(num2 * swimSpeed.y) * swimScale.y, Mathf.Sin(num2 * swimSpeed.z) * swimScale.z);
			val2 = ((Component)this).transform.InverseTransformDirection(val2);
			position += val2 * appliedSwimScale;
		}
		rotation = Quaternion.LookRotation(normalized) * Quaternion.Euler(Mathf.Cos(Time.time * swimSpeed.y) * appliedSwimRotation, 0f, Mathf.Sin(Time.time * swimSpeed.x) * appliedSwimRotation);
		Vector3 val3 = position;
		float height = TerrainMeta.HeightMap.GetHeight(val3 + ((Component)this).transform.forward * 30f);
		float height2 = TerrainMeta.HeightMap.GetHeight(val3);
		float num3 = Mathf.Max(height, height2);
		float num4 = Mathf.Max(desiredAltitude, num3 + altitudeAboveTerrain);
		val3.y = Mathf.Lerp(((Component)this).transform.position.y, num4, Time.fixedDeltaTime * 0.5f);
		position = val3;
		((Component)this).transform.hasChanged = true;
		if (num >= 1f)
		{
			Kill();
		}
		((Component)this).transform.SetPositionAndRotation(position, rotation);
	}

	[ServerVar]
	public static void drop(Arg arg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Debug.Log((object)"Santa Inbound");
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/misc/xmas/sleigh/santasleigh.prefab");
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).GetComponent<SantaSleigh>().InitDropPosition(((Component)basePlayer).transform.position + new Vector3(0f, 10f, 0f));
				baseEntity.Spawn();
			}
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using VLB;

public class SearchLight : IOEntity
{
	public static class SearchLightFlags
	{
		public const Flags PlayerUsing = Flags.Reserved5;
	}

	public GameObject pitchObject;

	public GameObject yawObject;

	public GameObject eyePoint;

	public SoundPlayer turnLoop;

	public bool needsBuildingPrivilegeToUse = true;

	[SerializeField]
	private GameObject lightParent;

	[SerializeField]
	private Light[] lights;

	[SerializeField]
	private float[] initialLightIntensity;

	[SerializeField]
	private VolumetricLightBeam vlb;

	[SerializeField]
	private GameObject flare;

	[SerializeField]
	private SoundPlayer humLoopSound;

	[SerializeField]
	private SoundPlayer turnOffSound;

	[SerializeField]
	private SoundPlayer turnOnSound;

	[SerializeField]
	private AnimationCurve lightLerpCurve;

	public Vector3 aimDir = Vector3.zero;

	public BasePlayer mountedPlayer;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SearchLight.OnRpcMessage", 0);
		try
		{
			if (rpc == 3611615802u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_UseLight "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_UseLight", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3611615802u, "RPC_UseLight", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_UseLight(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_UseLight");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		aimDir = Vector3.zero;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && !old.HasFlag(Flags.Reserved8) && next.HasFlag(Flags.Reserved8) && IsFlickering())
		{
			Hurt(25f);
		}
	}

	public override int ConsumptionAmount()
	{
		return 10;
	}

	public void Update()
	{
		if (base.isServer && IsMounted())
		{
			MountedUpdate();
		}
	}

	public void PlayerEnter(BasePlayer player)
	{
		if (!IsMounted() || !((Object)(object)player != (Object)(object)mountedPlayer))
		{
			PlayerExit();
			if ((Object)(object)player != (Object)null)
			{
				mountedPlayer = player;
				SetFlag(Flags.Reserved5, b: true);
			}
		}
	}

	public void PlayerExit()
	{
		if (Object.op_Implicit((Object)(object)mountedPlayer))
		{
			mountedPlayer = null;
		}
		SetFlag(Flags.Reserved5, b: false);
	}

	public void MountedUpdate()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)mountedPlayer == (Object)null || mountedPlayer.IsSleeping() || !mountedPlayer.IsAlive() || mountedPlayer.IsWounded() || Vector3.Distance(((Component)mountedPlayer).transform.position, ((Component)this).transform.position) > 2f)
		{
			PlayerExit();
			return;
		}
		Vector3 targetAimpoint = eyePoint.transform.position + mountedPlayer.eyes.BodyForward() * 100f;
		SetTargetAimpoint(targetAimpoint);
		SendNetworkUpdate();
	}

	public void SetTargetAimpoint(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = worldPos - eyePoint.transform.position;
		aimDir = ((Vector3)(ref val)).normalized;
	}

	public bool IsMounted()
	{
		return (Object)(object)mountedPlayer != (Object)null;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_UseLight(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool flag = msg.read.Bit();
		if ((!flag || !IsMounted()) && (!needsBuildingPrivilegeToUse || msg.player.CanBuild()))
		{
			if (flag)
			{
				PlayerEnter(player);
			}
			else
			{
				PlayerExit();
			}
		}
	}

	public override void OnDied(HitInfo info)
	{
		SetFlag(Flags.On, b: false);
		base.OnDied(info);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.autoturret = Pool.Get<AutoTurret>();
		info.msg.autoturret.aimDir = aimDir;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.autoturret != null)
		{
			aimDir = info.msg.autoturret.aimDir;
		}
	}
}


public static class SearchLightFlags
{
	public const Flags PlayerUsing = Flags.Reserved5;
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class SeismicSensor : IOEntity
{
	public static int MinRange = 1;

	public static int MaxRange = 30;

	public int range = 30;

	public GameObjectRef sensorPanelPrefab;

	private int vibrationLevel;

	private const int holdTime = 3;

	private static readonly BaseEntity[] resultBuffer = new BaseEntity[128];

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SeismicSensor.OnRpcMessage", 0);
		try
		{
			if (rpc == 128851379 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SetRange "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SetRange", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(128851379u, "RPC_SetRange", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(128851379u, "RPC_SetRange", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_SetRange(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_SetRange");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void SetVibrationLevel(int value)
	{
		float num = value;
		if (num <= 0f)
		{
			SetOff();
			return;
		}
		if (num > (float)vibrationLevel)
		{
			vibrationLevel = Mathf.RoundToInt(num);
			SetFlag(Flags.On, b: true);
			MarkDirty();
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)SetOff))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SetOff);
		}
		((FacepunchBehaviour)this).Invoke((Action)SetOff, 3f);
	}

	private void SetOff()
	{
		if (vibrationLevel != 0)
		{
			vibrationLevel = 0;
			SetFlag(Flags.On, b: false);
			MarkDirty();
		}
	}

	public void SetRange(int value)
	{
		value = Mathf.Clamp(value, MinRange, MaxRange);
		range = value;
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void RPC_SetRange(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && player.CanBuild())
		{
			int num = msg.read.Int32();
			SetRange(num);
		}
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		if (inputAmount == 0)
		{
			ResetIOState();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsPowered())
		{
			return 0;
		}
		return vibrationLevel;
	}

	public override void ResetIOState()
	{
		vibrationLevel = 0;
		SetFlag(Flags.On, b: false);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity.genericInt1 = range;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			range = info.msg.ioEntity.genericInt1;
		}
	}

	public static void Notify(Vector3 position, int value)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (value == 0)
		{
			return;
		}
		int inSphereFast = Query.Server.GetInSphereFast(position, MaxRange, resultBuffer, FilterOutSensors);
		for (int i = 0; i < inSphereFast; i++)
		{
			SeismicSensor seismicSensor = resultBuffer[i] as SeismicSensor;
			Vector3 position2 = ((Component)seismicSensor).transform.position;
			Vector3 val = position - position2;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			float num = (float)seismicSensor.range + 0.5f;
			if (sqrMagnitude < num * num)
			{
				seismicSensor.SetVibrationLevel(value);
			}
		}
	}

	private static bool FilterOutSensors(BaseEntity entity)
	{
		SeismicSensor seismicSensor = entity as SeismicSensor;
		if ((Object)(object)seismicSensor != (Object)null && seismicSensor.IsValidEntityReference())
		{
			return seismicSensor.HasFlag(Flags.Reserved8);
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class Shield : HeldEntity
{
	public const Flags Blocking = Flags.Reserved6;

	public float DeployDelay = 1f;

	public ProtectionProperties Protection;

	[Range(0f, 1f)]
	public float DamageMitigationFactor;

	public Collider ShieldCollider;

	public float MaxBlockTime = 4f;

	public float MinBlockTime = 1f;

	public GameObjectRef MeleeLocalPlayerImpactFxPrefab;

	public GameObjectRef RangedLocalPlayerImpactFxPrefab;

	[ReplicatedVar]
	public static bool InfiniteShieldBlock = false;

	private Action shieldBlockTick;

	private bool serverWantsBlock;

	private static Vector3 MaximumLocalPosition = new Vector3(0.39f, 1.62f, 0.41f);

	private static Vector3 MinimumLocalPosition = new Vector3(-0.66f, 0.66f, -0.44f);

	private static Vector3 MaximumLocalRotation = new Vector3(360f, 360f, 360f);

	private static Vector3 MinimumLocalRotation = new Vector3(2.5f, 2.14f, 0.04f);

	private TimeSince serverSideShieldBlockStarted;

	private float serverSideBlockPower;

	private TimeSince lastLocalPlayerUpdateTick;

	private HeldEntity tickingHeldEntity;

	public override bool IsShield => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Shield.OnRpcMessage", 0);
		try
		{
			if (rpc == 2238556937u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerToggleBlock "));
				}
				TimeWarning val2 = TimeWarning.New("ServerToggleBlock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2238556937u, "ServerToggleBlock", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2238556937u, "ServerToggleBlock", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerToggleBlock(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerToggleBlock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsBlocking()
	{
		return HasFlag(Flags.Reserved6);
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer)
		{
			ServerSideAttack(info);
		}
	}

	public bool RaycastAgainstColliders(Ray r, float maxDistance)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if ((Object)(object)ShieldCollider != (Object)null)
		{
			return ShieldCollider.Raycast(r, ref val, maxDistance);
		}
		return false;
	}

	public bool SphereCastAgainstColliders(Vector3 center, float radius)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Distance(ClosestPoint(center), center) <= radius;
	}

	public string GetHitMaterialString()
	{
		return ShieldCollider.sharedMaterial.GetName();
	}

	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	private void ServerToggleBlock(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		serverWantsBlock = flag;
		if (shieldBlockTick == null)
		{
			shieldBlockTick = ShieldBlockTick;
		}
		if (!((FacepunchBehaviour)this).IsInvoking(shieldBlockTick))
		{
			((FacepunchBehaviour)this).InvokeRepeating(shieldBlockTick, 0f, 0f);
		}
	}

	private void ServerSideAttack(HitInfo info)
	{
		Item item = GetItem();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (item != null)
		{
			Protection.Scale(info.damageTypes);
			info.HitBone = 0u;
			float num = info.damageTypes.Total();
			info.damageTypes.ScaleAll(Mathf.Clamp01(1f - DamageMitigationFactor));
			float amount = num - info.damageTypes.Total();
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				ownerPlayer.OnAttacked(info);
			}
			item.LoseCondition(amount);
		}
		bool arg = (Object)(object)info.Weapon != (Object)null && info.Weapon is BaseMelee;
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			ClientRPC(RpcTarget.NetworkGroup("ClientShieldHit", ownerPlayer), arg, ((Object)(object)info.InitiatorPlayer != (Object)null) ? info.InitiatorPlayer.userID.Get() : 0);
		}
	}

	private void DestroyShield()
	{
		List<BaseEntity> list = Pool.GetList<BaseEntity>();
		foreach (BaseEntity child in children)
		{
			list.Add(child);
		}
		foreach (BaseEntity item in list)
		{
			item.SetParent(null, worldPositionStays: true);
		}
		Pool.FreeList<BaseEntity>(ref list);
	}

	public override float BoundsPadding()
	{
		if ((Object)(object)GetOwnerPlayer() != (Object)null && GetOwnerPlayer().IsBot)
		{
			return 3f;
		}
		return 0.75f;
	}

	public override void SetHeld(bool bHeld)
	{
		base.SetHeld(bHeld);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			ownerPlayer.modelState.blocking = false;
		}
	}

	private void ShieldBlockTick()
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (IsDisabled() || (Object)(object)ownerPlayer == (Object)null)
		{
			return;
		}
		HeldEntity heldEntity = ownerPlayer.GetHeldEntity();
		if ((Object)(object)heldEntity != (Object)(object)tickingHeldEntity)
		{
			tickingHeldEntity = heldEntity;
			serverSideBlockPower = 0f;
		}
		if (serverWantsBlock)
		{
			if (!IsBlocking() && serverSideBlockPower < MaxBlockTime - MinBlockTime)
			{
				serverSideShieldBlockStarted = TimeSince.op_Implicit(0f);
				SetFlag(Flags.Reserved6, b: true);
			}
		}
		else if (IsBlocking() && TimeSince.op_Implicit(serverSideShieldBlockStarted) > MinBlockTime)
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		ownerPlayer.modelState.blocking = IsBlocking();
		serverSideBlockPower = Mathf.MoveTowards(serverSideBlockPower, IsBlocking() ? MaxBlockTime : 0f, Time.deltaTime);
		if (TimeSince.op_Implicit(lastLocalPlayerUpdateTick) > 0.5f)
		{
			ClientRPC(RpcTarget.Player("ClientUpdateShieldPowerTime", ownerPlayer), serverSideBlockPower / MaxBlockTime);
			lastLocalPlayerUpdateTick = TimeSince.op_Implicit(0f);
		}
		if (HasFlag(Flags.Reserved6) && serverSideBlockPower >= MaxBlockTime && !InfiniteShieldBlock)
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		if (!IsBlocking() && serverSideBlockPower <= 0f)
		{
			((FacepunchBehaviour)this).CancelInvoke(shieldBlockTick);
		}
	}

	public override void ServerTick(BasePlayer byPlayer)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerTick(byPlayer);
		if (!IsDisabled() && byPlayer.modelState != null)
		{
			Vector3 val = byPlayer.modelState.localShieldPos;
			if (Vector3Ex.IsNaNOrInfinity(val))
			{
				val = Vector3.Lerp(MinimumLocalPosition, MaximumLocalPosition, 0.5f);
			}
			Vector3 val2 = byPlayer.modelState.localShieldRot;
			if (Vector3Ex.IsNaNOrInfinity(val2))
			{
				val2 = Vector3.Lerp(MinimumLocalRotation, MaximumLocalRotation, 0.5f);
			}
			val.x = Mathf.Clamp(val.x, MinimumLocalPosition.x, MaximumLocalPosition.x);
			val.y = Mathf.Clamp(val.y, MinimumLocalPosition.y, MaximumLocalPosition.y);
			val.z = Mathf.Clamp(val.z, MinimumLocalPosition.z, MaximumLocalPosition.z);
			val2.x = Mathf.Clamp(val2.x, MinimumLocalRotation.x, MaximumLocalRotation.x);
			val2.y = Mathf.Clamp(val2.y, MinimumLocalRotation.y, MaximumLocalRotation.y);
			val2.z = Mathf.Clamp(val2.z, MinimumLocalRotation.z, MaximumLocalRotation.z);
			((Component)this).transform.SetLocalPositionAndRotation(val, Quaternion.Euler(val2));
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!base.isServer)
		{
			return;
		}
		if (old.HasFlag(Flags.Broken) != next.HasFlag(Flags.Broken))
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if (!((Object)(object)ownerPlayer != (Object)null))
			{
				return;
			}
			HeldEntity heldEntity = ownerPlayer.GetHeldEntity();
			if ((Object)(object)heldEntity != (Object)null)
			{
				heldEntity.UpdateShieldState(bHeld: true);
			}
			if (next.HasFlag(Flags.Broken))
			{
				DestroyShield();
				if ((Object)(object)heldEntity != (Object)null)
				{
					heldEntity.UpdateShieldState(bHeld: false);
				}
			}
		}
		else if (old.HasFlag(Flags.Reserved4) && !next.HasFlag(Flags.Reserved4))
		{
			SetFlag(Flags.Reserved6, b: false);
			serverWantsBlock = false;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class ShopFront : StorageContainer
{
	public static class ShopFrontFlags
	{
		public const Flags VendorAccepted = Flags.Reserved1;

		public const Flags CustomerAccepted = Flags.Reserved2;

		public const Flags Exchanging = Flags.Reserved3;
	}

	public float maxUseAngle = 27f;

	public BasePlayer vendorPlayer;

	public BasePlayer customerPlayer;

	public GameObjectRef transactionCompleteEffect;

	[NonSerialized]
	public ItemContainer customerInventory;

	private bool swappingItems;

	private float AngleDotProduct => 1f - maxUseAngle / 90f;

	public ItemContainer vendorInventory => base.inventory;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ShopFront.OnRpcMessage", 0);
		try
		{
			if (rpc == 1159607245 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AcceptClicked "));
				}
				TimeWarning val2 = TimeWarning.New("AcceptClicked", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1159607245u, "AcceptClicked", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							AcceptClicked(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AcceptClicked");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3168107540u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - CancelClicked "));
				}
				TimeWarning val2 = TimeWarning.New("CancelClicked", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3168107540u, "CancelClicked", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							CancelClicked(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in CancelClicked");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool TradeLocked()
	{
		return false;
	}

	public bool IsTradingPlayer(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null)
		{
			if (!IsPlayerCustomer(player))
			{
				return IsPlayerVendor(player);
			}
			return true;
		}
		return false;
	}

	public bool IsPlayerCustomer(BasePlayer player)
	{
		return (Object)(object)player == (Object)(object)customerPlayer;
	}

	public bool IsPlayerVendor(BasePlayer player)
	{
		return (Object)(object)player == (Object)(object)vendorPlayer;
	}

	public bool PlayerInVendorPos(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 right = ((Component)this).transform.right;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(right, ((Vector3)(ref val)).normalized) <= 0f - AngleDotProduct;
	}

	public bool PlayerInCustomerPos(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 right = ((Component)this).transform.right;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(right, ((Vector3)(ref val)).normalized) >= AngleDotProduct;
	}

	public bool LootEligable(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (PlayerInVendorPos(player) && (Object)(object)vendorPlayer == (Object)null)
		{
			return true;
		}
		if (PlayerInCustomerPos(player) && (Object)(object)customerPlayer == (Object)null)
		{
			return true;
		}
		return false;
	}

	public void ResetTrade()
	{
		SetFlag(Flags.Reserved1, b: false);
		SetFlag(Flags.Reserved2, b: false);
		SetFlag(Flags.Reserved3, b: false);
		vendorInventory.SetLocked(isLocked: false);
		customerInventory.SetLocked(isLocked: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)CompleteTrade);
	}

	public void CompleteTrade()
	{
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)vendorPlayer != (Object)null && (Object)(object)customerPlayer != (Object)null && HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
		{
			if (Interface.CallHook("OnShopCompleteTrade", (object)this) != null)
			{
				return;
			}
			try
			{
				swappingItems = true;
				for (int num = vendorInventory.capacity - 1; num >= 0; num--)
				{
					Item slot = vendorInventory.GetSlot(num);
					Item slot2 = customerInventory.GetSlot(num);
					if (Object.op_Implicit((Object)(object)customerPlayer) && slot != null)
					{
						customerPlayer.GiveItem(slot);
					}
					if (Object.op_Implicit((Object)(object)vendorPlayer) && slot2 != null)
					{
						vendorPlayer.GiveItem(slot2);
					}
				}
			}
			finally
			{
				swappingItems = false;
			}
			Effect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);
		}
		ResetTrade();
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AcceptClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && !((Object)(object)vendorPlayer == (Object)null) && !((Object)(object)customerPlayer == (Object)null) && Interface.CallHook("OnShopAcceptClick", (object)this, (object)msg.player) == null)
		{
			if (IsPlayerVendor(msg.player))
			{
				SetFlag(Flags.Reserved1, b: true);
				vendorInventory.SetLocked(isLocked: true);
			}
			else if (IsPlayerCustomer(msg.player))
			{
				SetFlag(Flags.Reserved2, b: true);
				customerInventory.SetLocked(isLocked: true);
			}
			if (HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
			{
				SetFlag(Flags.Reserved3, b: true);
				((FacepunchBehaviour)this).Invoke((Action)CompleteTrade, 2f);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void CancelClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && Interface.CallHook("OnShopCancelClick", (object)this, (object)msg.player) == null)
		{
			Object.op_Implicit((Object)(object)vendorPlayer);
			Object.op_Implicit((Object)(object)customerPlayer);
			ResetTrade();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = vendorInventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptVendorItem));
		if (customerInventory == null)
		{
			customerInventory = Pool.Get<ItemContainer>();
			customerInventory.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
			customerInventory.SetOnlyAllowedItem(allowedItem);
			customerInventory.entityOwner = this;
			customerInventory.maxStackSize = maxStackSize;
			customerInventory.ServerInitialize(null, inventorySlots);
			customerInventory.GiveUID();
			customerInventory.onDirty += OnInventoryDirty;
			customerInventory.onItemAddedRemoved = OnItemAddedOrRemoved;
			ItemContainer itemContainer2 = customerInventory;
			itemContainer2.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer2.canAcceptItem, new Func<Item, int, bool>(CanAcceptCustomerItem));
			OnInventoryFirstCreated(customerInventory);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Pool.Free<ItemContainer>(ref customerInventory);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		ResetTrade();
	}

	private bool CanAcceptVendorItem(Item item, int targetSlot)
	{
		if (swappingItems || ((Object)(object)vendorPlayer != (Object)null && (Object)(object)item.GetOwnerPlayer() == (Object)(object)vendorPlayer) || vendorInventory.itemList.Contains(item))
		{
			return true;
		}
		return false;
	}

	private bool CanAcceptCustomerItem(Item item, int targetSlot)
	{
		if (swappingItems || ((Object)(object)customerPlayer != (Object)null && (Object)(object)item.GetOwnerPlayer() == (Object)(object)customerPlayer) || customerInventory.itemList.Contains(item))
		{
			return true;
		}
		return false;
	}

	public override bool CanMoveFrom(BasePlayer player, Item item)
	{
		if (TradeLocked())
		{
			return false;
		}
		if (IsTradingPlayer(player))
		{
			if (IsPlayerCustomer(player) && customerInventory.itemList.Contains(item) && !customerInventory.IsLocked())
			{
				return true;
			}
			if (IsPlayerVendor(player) && vendorInventory.itemList.Contains(item) && !vendorInventory.IsLocked())
			{
				return true;
			}
		}
		return false;
	}

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		if (base.CanOpenLootPanel(player, panelName))
		{
			return LootEligable(player);
		}
		return false;
	}

	public void ReturnPlayerItems(BasePlayer player)
	{
		if (!IsTradingPlayer(player))
		{
			return;
		}
		ItemContainer itemContainer = null;
		if (IsPlayerVendor(player))
		{
			itemContainer = vendorInventory;
		}
		else if (IsPlayerCustomer(player))
		{
			itemContainer = customerInventory;
		}
		if (itemContainer != null)
		{
			for (int num = itemContainer.itemList.Count - 1; num >= 0; num--)
			{
				Item item = itemContainer.itemList[num];
				player.GiveItem(item);
			}
		}
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		if (IsTradingPlayer(player))
		{
			ReturnPlayerItems(player);
			if ((Object)(object)player == (Object)(object)vendorPlayer)
			{
				vendorPlayer = null;
			}
			if ((Object)(object)player == (Object)(object)customerPlayer)
			{
				customerPlayer = null;
			}
			UpdatePlayers();
			ResetTrade();
			base.PlayerStoppedLooting(player);
		}
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		bool flag = base.PlayerOpenLoot(player, panelToOpen);
		if (flag)
		{
			player.inventory.loot.AddContainer(customerInventory);
			player.inventory.loot.SendImmediate();
		}
		if (PlayerInVendorPos(player) && (Object)(object)vendorPlayer == (Object)null)
		{
			vendorPlayer = player;
		}
		else
		{
			if (!PlayerInCustomerPos(player) || !((Object)(object)customerPlayer == (Object)null))
			{
				return false;
			}
			customerPlayer = player;
		}
		ResetTrade();
		UpdatePlayers();
		return flag;
	}

	public void UpdatePlayers()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_ReceivePlayers"), (NetworkableId)(((Object)(object)vendorPlayer == (Object)null) ? default(NetworkableId) : vendorPlayer.net.ID), (NetworkableId)(((Object)(object)customerPlayer == (Object)null) ? default(NetworkableId) : customerPlayer.net.ID));
	}

	public override void GetAllInventories(List<ItemContainer> list)
	{
		base.GetAllInventories(list);
		list.Add(customerInventory);
	}
}


public static class ShopFrontFlags
{
	public const Flags VendorAccepted = Flags.Reserved1;

	public const Flags CustomerAccepted = Flags.Reserved2;

	public const Flags Exchanging = Flags.Reserved3;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class SiegeTower : BaseSiegeWeapon
{
	[Header("Siege Tower")]
	[SerializeField]
	private SiegeTowerDoor drawBridgePrefab;

	[SerializeField]
	private SiegeTowerDoor drawBridge2Prefab;

	[SerializeField]
	private SiegeTowerDoor drawBridge3Prefab;

	private EntityRef<SiegeTowerDoor> drawBridgeRef;

	private EntityRef<SiegeTowerDoor> drawBridge2Ref;

	private EntityRef<SiegeTowerDoor> drawBridge3Ref;

	private const Flags Flag_IsTipping = Flags.Reserved18;

	private const Flags Flag_IsTipped = Flags.Reserved16;

	[Header("Raise Command")]
	public float torqueForce = 10f;

	public float uprightAngle = 10f;

	private bool shouldRaise;

	private float raiseTimer;

	public override float DriveWheelVelocity { get; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SiegeTower.OnRpcMessage", 0);
		try
		{
			if (rpc == 886085783 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_RequestRaise "));
				}
				TimeWarning val2 = TimeWarning.New("SV_RequestRaise", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(886085783u, "SV_RequestRaise", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_RequestRaise(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_RequestRaise");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.siegeTower != null && base.isServer)
		{
			drawBridgeRef.uid = info.msg.siegeTower.drawBridgeID;
			drawBridge2Ref.uid = info.msg.siegeTower.drawBridge2ID;
			drawBridge3Ref.uid = info.msg.siegeTower.drawBridge3ID;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.siegeTower = Pool.Get<SiegeTower>();
		info.msg.siegeTower.drawBridgeID = drawBridgeRef.uid;
		info.msg.siegeTower.drawBridge2ID = drawBridge2Ref.uid;
		info.msg.siegeTower.drawBridge3ID = drawBridge3Ref.uid;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && !Application.isLoadingSave)
		{
			if (child.prefabID == drawBridgePrefab.GetEntity().prefabID)
			{
				SiegeTowerDoor siegeTowerDoor = (SiegeTowerDoor)child;
				drawBridgeRef.Set(siegeTowerDoor);
				SetupDoor(siegeTowerDoor);
			}
			if (child.prefabID == drawBridge2Prefab.GetEntity().prefabID)
			{
				SiegeTowerDoor siegeTowerDoor2 = (SiegeTowerDoor)child;
				drawBridge2Ref.Set(siegeTowerDoor2);
				SetupDoor(siegeTowerDoor2);
			}
			if (child.prefabID == drawBridge3Prefab.GetEntity().prefabID)
			{
				SiegeTowerDoor siegeTowerDoor3 = (SiegeTowerDoor)child;
				drawBridge3Ref.Set(siegeTowerDoor3);
				SetupDoor(siegeTowerDoor3);
			}
			UpdateDoorHp();
		}
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		if (HasFlag(Flags.Reserved16))
		{
			return false;
		}
		if (base.isServer)
		{
			BaseEntity baseEntity = pusher.parentEntity.Get(serverside: true);
			if (baseEntity.IsValid())
			{
				BaseEntity baseEntity2 = baseEntity.parentEntity.Get(serverside: true);
				if (baseEntity2.IsValid() && (Object)(object)baseEntity2 == (Object)(object)this)
				{
					return false;
				}
			}
			if (!IsYValid(pusher))
			{
				return false;
			}
		}
		return true;
	}

	private bool IsYValid(BasePlayer pusher)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return !(Mathf.Abs(((Component)this).transform.position.y - ((Component)pusher).transform.position.y) > 2f);
	}

	protected override void CreateEngineController()
	{
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override bool ForceDeployableSetParent()
	{
		return true;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		DisablePhysics();
		((FacepunchBehaviour)this).Invoke((Action)base.EnablePhysics, 1f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)CheckIfTipped, 0f, 2f);
	}

	public void GetDoors(List<SiegeTowerDoor> doors)
	{
		SiegeTowerDoor siegeTowerDoor = drawBridgeRef.Get(base.isServer);
		if (siegeTowerDoor.IsValid())
		{
			doors.Add(siegeTowerDoor);
		}
		siegeTowerDoor = drawBridge2Ref.Get(base.isServer);
		if (siegeTowerDoor.IsValid())
		{
			doors.Add(siegeTowerDoor);
		}
		siegeTowerDoor = drawBridge3Ref.Get(base.isServer);
		if (siegeTowerDoor.IsValid())
		{
			doors.Add(siegeTowerDoor);
		}
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		List<SiegeTowerDoor> list = Pool.Get<List<SiegeTowerDoor>>();
		GetDoors(list);
		foreach (SiegeTowerDoor item in list)
		{
			if ((Object)(object)item != (Object)null)
			{
				item.ProtectedHurt(info);
			}
		}
		Pool.FreeUnmanaged<SiegeTowerDoor>(ref list);
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		List<SiegeTowerDoor> list = Pool.Get<List<SiegeTowerDoor>>();
		GetDoors(list);
		foreach (SiegeTowerDoor item in list)
		{
			if (!item.IsDead())
			{
				item.Die();
			}
		}
		Pool.FreeUnmanaged<SiegeTowerDoor>(ref list);
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateDoorHp();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateDoorHp();
	}

	private void UpdateDoorHp()
	{
		List<SiegeTowerDoor> list = Pool.Get<List<SiegeTowerDoor>>();
		GetDoors(list);
		foreach (SiegeTowerDoor item in list)
		{
			item.SetMaxHealth(MaxHealth());
			item.SetHealth(base.health);
		}
		Pool.FreeUnmanaged<SiegeTowerDoor>(ref list);
	}

	public void ProtectedHurt(HitInfo info)
	{
		info.HitEntity = this;
		base.Hurt(info);
	}

	public void ProtectedSetHealth(float health)
	{
		SetHealth(health);
		UpdateDoorHp();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		List<SiegeTowerDoor> list = Pool.Get<List<SiegeTowerDoor>>();
		GetDoors(list);
		foreach (SiegeTowerDoor item in list)
		{
			SetupDoor(item);
		}
		Pool.FreeUnmanaged<SiegeTowerDoor>(ref list);
		UpdateDoorHp();
	}

	private void SetupDoor(SiegeTowerDoor door)
	{
		door.SetupDoor(this);
		door.SetMaxHealth(MaxHealth());
		door.SetHealth(MaxHealth());
		door.OwnerID = base.OwnerID;
		door.startHealth = MaxHealth();
	}

	private void CheckIfTipped()
	{
		bool flag = IsFlipping();
		if (HasFlag(Flags.Reserved18) != flag)
		{
			SetFlag(Flags.Reserved18, flag);
		}
		bool flag2 = IsFlipped();
		if (HasFlag(Flags.Reserved16) != flag2)
		{
			SetFlag(Flags.Reserved16, flag2);
		}
	}

	public override bool CheckTowingAllowed()
	{
		if (!base.CheckTowingAllowed())
		{
			return false;
		}
		if (HasFlag(Flags.Reserved18) || HasFlag(Flags.Reserved16))
		{
			return false;
		}
		return true;
	}

	private void FixedUpdate()
	{
		if (!base.isClient && !rigidBody.isKinematic)
		{
			UprightIfRaise();
		}
	}

	private void UprightIfRaise()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (shouldRaise)
		{
			if (Mathf.Abs(((Component)this).transform.up.y) > uprightAngle || raiseTimer > 5f)
			{
				rigidBody.angularDrag = 0.95f;
			}
			else if (Mathf.Abs(((Component)this).transform.up.y) > 1f || raiseTimer > 15f)
			{
				shouldRaise = false;
				rigidBody.angularDrag = 0.05f;
			}
			Vector3 angularVelocity = rigidBody.angularVelocity;
			Vector3 val = Quaternion.AngleAxis(((Vector3)(ref angularVelocity)).magnitude * 57.29578f * 100f / 350f, rigidBody.angularVelocity) * ((Component)this).transform.up;
			Vector3 up = Vector3.up;
			Vector3 val2 = Vector3.Cross(val, up);
			float num = Vector3.Dot(((Vector3)(ref val)).normalized, up);
			num = Mathf.Clamp01((num + 1f) / 2f);
			Vector3 val3 = val2 * (1f - num) * 350f * 350f;
			rigidBody.AddTorque(val3);
			raiseTimer += Time.fixedDeltaTime;
		}
	}

	private void AlignRotationToZero()
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null || !HasFlag(Flags.Reserved16))
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)AlignRotationToZero))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)AlignRotationToZero);
			}
			if ((Object)(object)rigidBody != (Object)null && !HasFlag(Flags.Reserved16))
			{
				rigidBody.angularVelocity = Vector3.zero;
			}
		}
	}

	public override void OnEngineStartFailed()
	{
	}

	public override bool MeetsEngineRequirements()
	{
		return false;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void SV_RequestRaise(RPCMessage msg)
	{
		if (HasFlag(Flags.Reserved16) && !((FacepunchBehaviour)this).IsInvoking((Action)AlignRotationToZero))
		{
			if (rigidBody.IsSleeping())
			{
				rigidBody.WakeUp();
			}
			raiseTimer = 0f;
			shouldRaise = true;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Signage : IOEntity, ILOD, ISignage, IUGCBrowserEntity
{
	public ItemDefinition RequiredHeldEntity;

	private List<ulong> editHistory = new List<ulong>();

	private const float TextureRequestTimeout = 15f;

	public GameObjectRef changeTextDialog;

	public MeshPaintableSource[] paintableSources;

	[NonSerialized]
	public uint[] textureIDs;

	public NetworkableId NetworkID => net.ID;

	public FileStorage.Type FileType => FileStorage.Type.png;

	public UGCType ContentType => UGCType.ImagePng;

	public List<ulong> EditingHistory => editHistory;

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public uint[] GetContentCRCs => GetTextureCRCs();

	public override bool ShouldTransferAssociatedFiles => true;

	public Vector2i TextureSize
	{
		get
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			if (paintableSources == null || paintableSources.Length == 0)
			{
				return Vector2i.zero;
			}
			MeshPaintableSource meshPaintableSource = paintableSources[0];
			return new Vector2i(meshPaintableSource.texWidth, meshPaintableSource.texHeight);
		}
	}

	public int TextureCount
	{
		get
		{
			MeshPaintableSource[] array = paintableSources;
			if (array == null)
			{
				return 0;
			}
			return array.Length;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Signage.OnRpcMessage", 0);
		try
		{
			if (rpc == 1455609404 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - LockSign "));
				}
				TimeWarning val2 = TimeWarning.New("LockSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1455609404u, "LockSign", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							LockSign(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in LockSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4149904254u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UnLockSign "));
				}
				TimeWarning val2 = TimeWarning.New("UnLockSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4149904254u, "UnLockSign", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							UnLockSign(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in UnLockSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1255380462 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdateSign "));
				}
				TimeWarning val2 = TimeWarning.New("UpdateSign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1255380462u, "UpdateSign", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1255380462u, "UpdateSign", this, player, 5f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							UpdateSign(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in UpdateSign");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		if (!HeldEntityCheck(player))
		{
			return false;
		}
		return true;
	}

	public bool CanUnlockSign(BasePlayer player)
	{
		if (!IsLocked())
		{
			return false;
		}
		if (!HeldEntityCheck(player))
		{
			return false;
		}
		return CanUpdateSign(player);
	}

	public bool CanLockSign(BasePlayer player)
	{
		if (IsLocked())
		{
			return false;
		}
		if (!HeldEntityCheck(player))
		{
			return false;
		}
		return CanUpdateSign(player);
	}

	public override void Load(LoadInfo info)
	{
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		EnsureInitialized();
		bool flag = false;
		if (info.msg.sign != null)
		{
			uint num = textureIDs[0];
			if (info.msg.sign.imageIds != null && info.msg.sign.imageIds.Count > 0)
			{
				int num2 = Mathf.Min(info.msg.sign.imageIds.Count, textureIDs.Length);
				for (int i = 0; i < num2; i++)
				{
					uint num3 = info.msg.sign.imageIds[i];
					bool flag2 = num3 != textureIDs[i];
					flag = flag || flag2;
					textureIDs[i] = num3;
				}
			}
			else
			{
				flag = num != info.msg.sign.imageid;
				textureIDs[0] = info.msg.sign.imageid;
			}
		}
		if (!base.isServer)
		{
			return;
		}
		bool flag3 = false;
		for (int j = 0; j < paintableSources.Length; j++)
		{
			uint num4 = textureIDs[j];
			if (num4 != 0)
			{
				byte[] array = FileStorage.server.Get(num4, FileStorage.Type.png, net.ID, (uint)j);
				if (array == null)
				{
					Log($"Frame {j} (id={num4}) doesn't exist, clearing");
					textureIDs[j] = 0u;
				}
				flag3 = flag3 || array != null;
			}
		}
		if (!flag3)
		{
			SetFlag(Flags.Locked, b: false);
		}
		if (info.msg.sign == null)
		{
			return;
		}
		if (info.msg.sign.editHistory != null)
		{
			if (editHistory == null)
			{
				editHistory = Pool.Get<List<ulong>>();
			}
			editHistory.Clear();
			{
				foreach (ulong item in info.msg.sign.editHistory)
				{
					editHistory.Add(item);
				}
				return;
			}
		}
		if (editHistory != null)
		{
			Pool.FreeUnmanaged<ulong>(ref editHistory);
		}
	}

	private bool HeldEntityCheck(BasePlayer player)
	{
		if ((Object)(object)RequiredHeldEntity != (Object)null && (!Object.op_Implicit((Object)(object)player.GetHeldEntity()) || (Object)(object)player.GetHeldEntity().GetItem().info != (Object)(object)RequiredHeldEntity))
		{
			return false;
		}
		return true;
	}

	public uint[] GetTextureCRCs()
	{
		return textureIDs;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", (object)this, (object)msg.player);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void UnLockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUnlockSign(msg.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		EnsureInitialized();
		List<uint> list = Pool.Get<List<uint>>();
		uint[] array = textureIDs;
		foreach (uint item in array)
		{
			list.Add(item);
		}
		info.msg.sign = Pool.Get<Sign>();
		info.msg.sign.imageid = 0u;
		info.msg.sign.imageIds = list;
		if (editHistory == null || editHistory.Count <= 0 || !info.forDisk)
		{
			return;
		}
		info.msg.sign.editHistory = Pool.Get<List<ulong>>();
		foreach (ulong item2 in editHistory)
		{
			info.msg.sign.editHistory.Add(item2);
		}
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (net != null)
		{
			FileStorage.server.RemoveAllByEntity(net.ID);
		}
		if (textureIDs != null)
		{
			Array.Clear(textureIDs, 0, textureIDs.Length);
		}
		base.OnDied(info);
	}

	public override void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
	{
		base.OnPickedUpPreItemMove(createdItem, player);
		bool flag = false;
		uint[] array = textureIDs;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] != 0)
			{
				flag = true;
				break;
			}
		}
		ItemModSign itemModSign = default(ItemModSign);
		if (flag && ((Component)createdItem.info).TryGetComponent<ItemModSign>(ref itemModSign))
		{
			itemModSign.OnSignPickedUp(this, this, createdItem);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		ItemModSign itemModSign = default(ItemModSign);
		if (((Component)fromItem.info).TryGetComponent<ItemModSign>(ref itemModSign))
		{
			SignContent associatedEntity = ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(fromItem);
			if ((Object)(object)associatedEntity != (Object)null)
			{
				associatedEntity.CopyInfoToSign(this, this);
			}
		}
	}

	public override bool ShouldNetworkOwnerInfo()
	{
		return true;
	}

	public void SetTextureCRCs(uint[] crcs)
	{
		textureIDs = new uint[crcs.Length];
		crcs.CopyTo(textureIDs, 0);
		SendNetworkUpdate();
	}

	public void LogEdit(BasePlayer byPlayer)
	{
		if (!editHistory.Contains(byPlayer.userID))
		{
			editHistory.Insert(0, byPlayer.userID);
			int num = 0;
			while (editHistory.Count > 5 && num < 10)
			{
				editHistory.RemoveAt(5);
				num++;
			}
		}
	}

	public void ClearContent()
	{
		SetTextureCRCs(Array.Empty<uint>());
	}

	public override string Admin_Who()
	{
		if (editHistory == null || editHistory.Count == 0)
		{
			return base.Admin_Who();
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine(base.Admin_Who());
		for (int i = 0; i < editHistory.Count; i++)
		{
			stringBuilder.AppendLine($"Edit {i}: {editHistory[i]}");
		}
		return stringBuilder.ToString();
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override string Categorize()
	{
		return "sign";
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (clientside && paintableSources != null && paintableSources.Length > 1)
		{
			MeshPaintableSource meshPaintableSource = paintableSources[0];
			for (int i = 1; i < paintableSources.Length; i++)
			{
				MeshPaintableSource obj = paintableSources[i];
				obj.texWidth = meshPaintableSource.texWidth;
				obj.texHeight = meshPaintableSource.texHeight;
			}
		}
	}

	[RPC_Server.MaxDistance(5f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	public void UpdateSign(RPCMessage msg)
	{
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null || !CanUpdateSign(msg.player))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num < 0 || num >= paintableSources.Length)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		if (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)
		{
			Debug.LogWarning((object)$"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring");
			return;
		}
		EnsureInitialized();
		if (array == null)
		{
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				return;
			}
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);
		}
		LogEdit(msg.player);
		SendNetworkUpdate();
		Interface.CallHook("OnSignUpdated", (object)this, (object)msg.player, (object)num);
	}

	public void EnsureInitialized()
	{
		int num = Mathf.Max(paintableSources.Length, 1);
		if (textureIDs == null || textureIDs.Length != num)
		{
			Array.Resize(ref textureIDs, num);
		}
	}

	[Conditional("SIGN_DEBUG")]
	private static void SignDebugLog(string str)
	{
		Debug.Log((object)str);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class SimpleBuildingBlock : StabilityEntity, ISimpleUpgradable, ISprayCallback
{
	public List<ItemDefinition> UpgradeItems;

	public Menu.Option UpgradeMenu;

	private GameObject currentModel;

	private SimpleBuildingBlockModelVariant[] variants;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SimpleBuildingBlock.OnRpcMessage", 0);
		try
		{
			if (rpc == 2824056853u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoSimpleUpgrade "));
				}
				TimeWarning val2 = TimeWarning.New("DoSimpleUpgrade", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2824056853u, "DoSimpleUpgrade", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2824056853u, "DoSimpleUpgrade", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoSimpleUpgrade(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoSimpleUpgrade");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		variants = PrefabAttribute.server.FindAll<SimpleBuildingBlockModelVariant>(prefabID);
	}

	public List<ItemDefinition> GetUpgradeItems()
	{
		return UpgradeItems;
	}

	public bool CanUpgrade(BasePlayer player, ItemDefinition upgradeItem)
	{
		return SimpleUpgrade.CanUpgrade(this, upgradeItem, player);
	}

	public void DoUpgrade(BasePlayer player, ItemDefinition upgradeItem)
	{
		SimpleUpgrade.DoUpgrade(this, player, upgradeItem);
	}

	public Menu.Option GetUpgradeMenuOption()
	{
		return UpgradeMenu;
	}

	public bool UpgradingEnabled()
	{
		if (UpgradeItems != null)
		{
			return UpgradeItems.Count > 0;
		}
		return false;
	}

	public bool CostIsItem()
	{
		return true;
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void DoSimpleUpgrade(RPCMessage msg)
	{
		if (base.SecondsSinceAttacked < 30f)
		{
			msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantUpgradeRecentlyDamaged, false, (30f - base.SecondsSinceAttacked).ToString("N0"));
			return;
		}
		int num = msg.read.Int32();
		if (num >= 0 && num < UpgradeItems.Count)
		{
			ItemDefinition upgradeItem = UpgradeItems[num];
			if (CanUpgrade(msg.player, upgradeItem))
			{
				DoUpgrade(msg.player, upgradeItem);
			}
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		PopulateVariants();
	}

	private void PopulateVariants()
	{
		if (base.isServer && variants.Any())
		{
			ulong value = net.ID.Value;
			SeedRandom.Wanghash(ref value);
			SeedRandom.Wanghash(ref value);
			SeedRandom.Wanghash(ref value);
			int num = (int)(value % (ulong)variants.Length);
			SetFlag(variants[num].Flag, b: true);
		}
	}

	public void OnReskinned(BasePlayer byPlayer)
	{
		PopulateVariants();
	}

	public void SetVariant(int index)
	{
		int num = index % variants.Length;
		SimpleBuildingBlockModelVariant[] array = variants;
		foreach (SimpleBuildingBlockModelVariant simpleBuildingBlockModelVariant in array)
		{
			SetFlag(simpleBuildingBlockModelVariant.Flag, b: false, recursive: false, networkupdate: false);
		}
		SetFlag(variants[num].Flag, b: true);
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if (!base.isServer)
		{
			return;
		}
		SimpleBuildingBlockModelVariant[] array = variants;
		foreach (SimpleBuildingBlockModelVariant simpleBuildingBlockModelVariant in array)
		{
			if (HasFlag(simpleBuildingBlockModelVariant.Flag))
			{
				SetFlag(simpleBuildingBlockModelVariant.Flag, b: false);
			}
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (variants != null)
		{
			RefreshVariant();
		}
	}

	private void RefreshVariant()
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		if (variants == null)
		{
			return;
		}
		base.gameManager.Retire(currentModel);
		SimpleBuildingBlockModelVariant[] array = variants;
		foreach (SimpleBuildingBlockModelVariant simpleBuildingBlockModelVariant in array)
		{
			if (HasFlag(simpleBuildingBlockModelVariant.Flag))
			{
				GameObject val = base.gameManager.CreatePrefab(simpleBuildingBlockModelVariant.prefab.resourcePath, ((Component)this).transform);
				if (Object.op_Implicit((Object)(object)val))
				{
					val.transform.localPosition = simpleBuildingBlockModelVariant.localPosition;
					val.transform.localRotation = simpleBuildingBlockModelVariant.localRotation;
				}
				currentModel = val;
			}
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		base.gameManager.Retire(currentModel);
		currentModel = null;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Development.Attributes;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

[ResetStaticFields]
public class SleepingBag : DecayEntity
{
	public enum BagAssignMode
	{
		Allowed = 0,
		TeamAndFriendlyContacts = 1,
		None = 2,
		LAST = 2
	}

	public enum BagResultType
	{
		Ok,
		TooManyBags,
		BagBlocked,
		TargetIsPlayingTutorial
	}

	public struct CanAssignBedResult
	{
		public BagResultType Result;

		public int Count;

		public int Max;
	}

	public enum SleepingBagResetReason
	{
		Respawned,
		Placed,
		Death
	}

	[ReplicatedVar]
	public static bool UseTeamLabels = true;

	[NonSerialized]
	public ulong deployerUserID;

	public GameObject renameDialog;

	public GameObject assignDialog;

	public float secondsBetweenReuses = 300f;

	public bool perPlayerRespawnCooldown;

	private Dictionary<ulong, float> playerCooldowns = new Dictionary<ulong, float>();

	public string niceName = "Unnamed Bag";

	public Vector3 spawnOffset = Vector3.zero;

	public RespawnType RespawnType = (RespawnType)1;

	public bool isStatic;

	public bool canBePublic;

	public bool canReassignToFriends = true;

	public const Flags IsPublicFlag = Flags.Reserved3;

	public const Flags DestroyAfterUseFlag = Flags.Reserved14;

	public static Phrase bagLimitPhrase = new Phrase("bag_limit_update", "You are now at {0}/{1} bags");

	public static Phrase bagLimitReachedPhrase = new Phrase("bag_limit_reached", "You have reached your bag limit!");

	public static Phrase teammateBagPhrase = new Phrase("teammate_bag", "{0}'s bag");

	public Phrase assignOtherBagPhrase = new Phrase("assigned_other_bag_limit", "You have assigned {0} a bag, they are now at {0}/{1} bags");

	public Phrase assignedBagPhrase = new Phrase("assigned_bag_limit", "You have been assigned a bag, you are now at {0}/{1} bags");

	public Phrase cannotAssignBedNoPlayerPhrase = new Phrase("cannot_assign_bag_limit_noplayer", "You cannot assign a bag to this player, they have reached their bag limit!");

	public Phrase cannotAssignBedPhrase = new Phrase("cannot_assign_bag_limit", "You cannot assign {0} a bag, they have reached their bag limit!");

	public Phrase cannotMakeBedPhrase = new Phrase("cannot_make_bed_limit", "You cannot take ownership of the bed, you are at your bag limit");

	public Phrase bedAssigningBlocked = new Phrase("bag_assign_blocked", "That player has blocked bag assignment");

	public static Phrase tutorialPhrase = new Phrase("bag_assign_tutorial", "Cannot assign bags to players mid-tutorial");

	public float unlockTime;

	public static List<SleepingBag> sleepingBags = new List<SleepingBag>();

	private bool notifyPlayerOnServerInit;

	private static Dictionary<ulong, List<SleepingBag>> bagsPerPlayer = new Dictionary<ulong, List<SleepingBag>>();

	public virtual float unlockSeconds
	{
		get
		{
			if (unlockTime < Time.realtimeSinceStartup)
			{
				return 0f;
			}
			return unlockTime - Time.realtimeSinceStartup;
		}
	}

	public bool IsTutorialBag
	{
		get
		{
			if (net != null && net.group != null)
			{
				return net.group.restricted;
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SleepingBag.OnRpcMessage", 0);
		try
		{
			if (rpc == 3057055788u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AssignToFriend "));
				}
				TimeWarning val2 = TimeWarning.New("AssignToFriend", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3057055788u, "AssignToFriend", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							AssignToFriend(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AssignToFriend");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1335950295 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Rename "));
				}
				TimeWarning val2 = TimeWarning.New("Rename", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1335950295u, "Rename", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Rename(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Rename");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 42669546 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_MakeBed "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_MakeBed", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(42669546u, "RPC_MakeBed", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_MakeBed(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_MakeBed");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 393812086 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_MakePublic "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_MakePublic", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(393812086u, "RPC_MakePublic", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RPC_MakePublic(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_MakePublic");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsPublic()
	{
		return HasFlag(Flags.Reserved3);
	}

	private float EvaluatedSecondsBetweenReuses()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Expected I4, but got Unknown
		float num = 0f;
		RespawnType respawnType = RespawnType;
		switch (respawnType - 1)
		{
		case 0:
		case 2:
			num = ConVar.Server.respawnTimeAdditionBag;
			break;
		case 1:
		case 3:
			num = ConVar.Server.respawnTimeAdditionBed;
			break;
		}
		return secondsBetweenReuses + num;
	}

	public virtual float GetUnlockSeconds(ulong playerID)
	{
		if (playerCooldowns.TryGetValue(playerID, out var value) && value > unlockTime)
		{
			return Mathf.Max(0f, value - Time.realtimeSinceStartup);
		}
		return unlockSeconds;
	}

	public virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers)
	{
		object obj = Interface.CallHook("OnSleepingBagValidCheck", (object)this, (object)playerID, (object)ignoreTimers);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (deployerUserID == playerID)
		{
			if (!ignoreTimers)
			{
				return unlockTime < Time.realtimeSinceStartup;
			}
			return true;
		}
		return false;
	}

	public static CanAssignBedResult? CanAssignBed(BasePlayer player, SleepingBag newBag, ulong targetPlayer, int countOffset = 1, int maxOffset = 0, SleepingBag ignore = null)
	{
		int num = ConVar.Server.max_sleeping_bags + maxOffset;
		if (player.IsInTutorial)
		{
			return null;
		}
		if (num < 0)
		{
			return null;
		}
		int num2 = countOffset;
		BasePlayer basePlayer = BasePlayer.FindByID(targetPlayer);
		BagAssignMode bagAssignMode = (BagAssignMode)Mathf.Clamp(((Object)(object)basePlayer != (Object)null) ? basePlayer.GetInfoInt("client.bagassignmode", 0) : 0, 0, 2);
		int max = num;
		CanAssignBedResult value;
		if ((Object)(object)player != (Object)(object)basePlayer)
		{
			switch (bagAssignMode)
			{
			case BagAssignMode.Allowed:
			{
				BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
				if ((Object)(object)activeGameMode != (Object)null && (activeGameMode.fogOfWar || !activeGameMode.ingameMap))
				{
					num--;
				}
				break;
			}
			case BagAssignMode.None:
				value = default(CanAssignBedResult);
				value.Result = BagResultType.BagBlocked;
				return value;
			case BagAssignMode.TeamAndFriendlyContacts:
			{
				if (!((Object)(object)basePlayer != (Object)null))
				{
					break;
				}
				bool flag = false;
				if (basePlayer.Team != null && basePlayer.Team.members.Contains(player.userID))
				{
					flag = true;
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo relations = RelationshipManager.ServerInstance.GetRelationships(targetPlayer).GetRelations(player.userID);
					if (relations != null && relations.type == RelationshipManager.RelationshipType.Friend)
					{
						flag = true;
					}
					if (!flag && (Object)(object)ClanManager.ServerInstance != (Object)null && basePlayer.clanId != 0L && basePlayer.clanId == player.clanId)
					{
						flag = true;
					}
				}
				if (!flag)
				{
					value = default(CanAssignBedResult);
					value.Result = BagResultType.BagBlocked;
					return value;
				}
				break;
			}
			}
			if ((Object)(object)basePlayer != (Object)(object)player && (Object)(object)basePlayer != (Object)null && basePlayer.IsInTutorial)
			{
				value = default(CanAssignBedResult);
				value.Result = BagResultType.TargetIsPlayingTutorial;
				return value;
			}
		}
		foreach (SleepingBag sleepingBag in sleepingBags)
		{
			if ((Object)(object)sleepingBag != (Object)(object)ignore && sleepingBag.deployerUserID == targetPlayer)
			{
				num2++;
				if (num2 > num)
				{
					value = default(CanAssignBedResult);
					value.Count = num2;
					value.Max = max;
					value.Result = BagResultType.TooManyBags;
					return value;
				}
			}
		}
		value = default(CanAssignBedResult);
		value.Count = num2;
		value.Max = max;
		value.Result = BagResultType.Ok;
		return value;
	}

	public static Planner.CanBuildResult? CanBuildBed(BasePlayer player, Construction construction)
	{
		GameObject obj = GameManager.server.FindPrefab(construction.prefabID);
		if (((obj != null) ? obj.GetComponent<BaseEntity>() : null) is SleepingBag)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(player, null, player.userID);
			if (canAssignBedResult.HasValue)
			{
				Planner.CanBuildResult value;
				if (canAssignBedResult.Value.Result == BagResultType.Ok)
				{
					value = default(Planner.CanBuildResult);
					value.Result = true;
					value.Phrase = bagLimitPhrase;
					value.Arguments = new string[2]
					{
						canAssignBedResult.Value.Count.ToString(),
						canAssignBedResult.Value.Max.ToString()
					};
					return value;
				}
				value = default(Planner.CanBuildResult);
				value.Result = false;
				value.Phrase = bagLimitReachedPhrase;
				return value;
			}
		}
		return null;
	}

	public static PooledList<SleepingBag> FindForPlayer(ulong playerID, bool ignoreTimers = true)
	{
		PooledList<SleepingBag> val = Pool.Get<PooledList<SleepingBag>>();
		if (bagsPerPlayer.TryGetValue(playerID, out var value))
		{
			if (!ignoreTimers)
			{
				foreach (SleepingBag item in value)
				{
					if (item.ValidForPlayer(playerID, ignoreTimers))
					{
						((List<SleepingBag>)(object)val).Add(item);
					}
				}
			}
			else
			{
				foreach (SleepingBag item2 in value)
				{
					((List<SleepingBag>)(object)val).Add(item2);
				}
			}
		}
		if (!ignoreTimers)
		{
			foreach (StaticRespawnArea staticRespawnArea in StaticRespawnArea.staticRespawnAreas)
			{
				if (staticRespawnArea.ValidForPlayer(playerID, ignoreTimers))
				{
					((List<SleepingBag>)(object)val).Add((SleepingBag)staticRespawnArea);
				}
			}
		}
		else
		{
			foreach (StaticRespawnArea staticRespawnArea2 in StaticRespawnArea.staticRespawnAreas)
			{
				((List<SleepingBag>)(object)val).Add((SleepingBag)staticRespawnArea2);
			}
		}
		return val;
	}

	public static void FindForPlayer(ulong playerID, bool ignoreTimers, List<SleepingBag> result)
	{
		foreach (SleepingBag sleepingBag in sleepingBags)
		{
			if (sleepingBag.ValidForPlayer(playerID, ignoreTimers))
			{
				result.Add(sleepingBag);
			}
		}
	}

	public static void UpdateMyBags(ulong id)
	{
		if (!bagsPerPlayer.TryGetValue(id, out var value))
		{
			return;
		}
		foreach (SleepingBag item in value)
		{
			if (!((Object)(object)item == (Object)null))
			{
				item.SendNetworkUpdate();
			}
		}
	}

	public static void UpdateTeamsBags(List<ulong> ids)
	{
		foreach (ulong id in ids)
		{
			UpdateMyBags(id);
		}
	}

	public static bool SpawnPlayer(BasePlayer player, NetworkableId sleepingBag)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Invalid comparison between Unknown and I4
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		PooledList<SleepingBag> val = FindForPlayer(player.userID);
		try
		{
			SleepingBag sleepingBag2 = null;
			foreach (SleepingBag item in (List<SleepingBag>)(object)val)
			{
				if (item.ValidForPlayer(player.userID, ignoreTimers: false) && item.net.ID == sleepingBag && item.unlockTime < Time.realtimeSinceStartup)
				{
					sleepingBag2 = item;
					break;
				}
			}
			if ((Object)(object)sleepingBag2 == (Object)null)
			{
				return false;
			}
			object obj = Interface.CallHook("OnPlayerRespawn", (object)player, (object)sleepingBag2);
			if (obj is SleepingBag)
			{
				sleepingBag2 = (SleepingBag)obj;
			}
			if (sleepingBag2 is StaticRespawnArea staticRespawnArea && !staticRespawnArea.IsAuthed(player.userID))
			{
				return false;
			}
			if ((int)sleepingBag2.GetRespawnState(player.userID) != 1)
			{
				return false;
			}
			sleepingBag2.GetSpawnPos(out var pos, out var rot);
			player.RespawnAt(pos, rot, sleepingBag2);
			sleepingBag2.PostPlayerSpawn(player);
			foreach (SleepingBag item2 in (List<SleepingBag>)(object)val)
			{
				SetBagTimer(item2, pos, SleepingBagResetReason.Respawned, player);
			}
			if (sleepingBag2.HasFlag(Flags.Reserved14))
			{
				sleepingBag2.Kill();
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void AddBagForPlayer(SleepingBag bag, ulong user, bool networkUpdate = true)
	{
		if (user == 0L)
		{
			return;
		}
		if (!bagsPerPlayer.TryGetValue(user, out var value))
		{
			value = new List<SleepingBag>();
			bagsPerPlayer[user] = value;
		}
		if (!value.Contains(bag))
		{
			value.Add(bag);
			if (networkUpdate)
			{
				RelationshipManager.FindByID(user)?.SendNetworkUpdate();
			}
		}
	}

	public static void RemoveBagForPlayer(SleepingBag bag, ulong user)
	{
		if (user != 0L && bagsPerPlayer.TryGetValue(user, out var value))
		{
			if (value.Remove(bag))
			{
				RelationshipManager.FindByID(user)?.SendNetworkUpdate();
			}
			if (value.Count == 0)
			{
				bagsPerPlayer.Remove(user);
			}
		}
	}

	public static void OnBagChangedOwnership(SleepingBag bag, ulong oldUser)
	{
		if (bag.deployerUserID != oldUser)
		{
			RemoveBagForPlayer(bag, oldUser);
			AddBagForPlayer(bag, bag.deployerUserID);
		}
	}

	public static void ClearTutorialBagsForPlayer(ulong userId)
	{
		if (userId == 0L || !bagsPerPlayer.TryGetValue(userId, out var _))
		{
			return;
		}
		List<SleepingBag> list = Pool.Get<List<SleepingBag>>();
		foreach (SleepingBag item in bagsPerPlayer[userId])
		{
			if (item.net != null && item.net.group != null && item.net.group.restricted)
			{
				list.Add(item);
			}
		}
		foreach (SleepingBag item2 in list)
		{
			item2.deployerUserID = 0uL;
			RemoveBagForPlayer(item2, userId);
		}
		Pool.FreeUnmanaged<SleepingBag>(ref list);
	}

	public static int GetSleepingBagCount(ulong userId)
	{
		if (userId == 0L)
		{
			return 0;
		}
		if (!bagsPerPlayer.TryGetValue(userId, out var value))
		{
			return 0;
		}
		return value.Count;
	}

	public static bool TrySpawnPlayer(BasePlayer player, NetworkableId sleepingBag, out string errorMessage)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (!player.IsDead())
		{
			errorMessage = "Couldn't spawn - player is not dead!";
			return false;
		}
		if (player.CanRespawn())
		{
			if (SpawnPlayer(player, sleepingBag))
			{
				player.MarkRespawn();
				errorMessage = null;
				return true;
			}
			errorMessage = "Couldn't spawn in sleeping bag!";
			return false;
		}
		errorMessage = "You can't respawn again so quickly, wait a while";
		return false;
	}

	public virtual void SetUnlockTime(float newTime)
	{
		unlockTime = newTime;
	}

	public void SetUnlockTimeForPlayer(ulong player, float time)
	{
		playerCooldowns.TryGetValue(player, out var value);
		playerCooldowns[player] = Mathf.Max(value, time);
	}

	public void ResetUnlockTimeForPlayer(ulong player)
	{
		playerCooldowns.Remove(player);
	}

	public static bool DestroyBag(ulong userID, NetworkableId sleepingBag)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		PooledList<SleepingBag> val = FindForPlayer(userID);
		try
		{
			SleepingBag sleepingBag2 = null;
			foreach (SleepingBag item in (List<SleepingBag>)(object)val)
			{
				if (item.net.ID == sleepingBag)
				{
					sleepingBag2 = item;
					break;
				}
			}
			if ((Object)(object)sleepingBag2 == (Object)null)
			{
				return false;
			}
			if (Interface.CallHook("OnSleepingBagDestroy", (object)sleepingBag2, (object)userID) != null)
			{
				return false;
			}
			RemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);
			sleepingBag2.deployerUserID = 0uL;
			if (sleepingBag2.HasFlag(Flags.Reserved14))
			{
				sleepingBag2.Kill();
			}
			else
			{
				sleepingBag2.SendNetworkUpdate();
			}
			BasePlayer basePlayer = BasePlayer.FindByID(userID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.SendRespawnOptions();
				Interface.CallHook("OnSleepingBagDestroyed", (object)sleepingBag2, (object)userID);
				Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void ResetTimersForPlayer(BasePlayer player)
	{
		PooledList<SleepingBag> val = FindForPlayer(player.userID);
		try
		{
			foreach (SleepingBag item in (List<SleepingBag>)(object)val)
			{
				item.unlockTime = 0f;
				item.ResetUnlockTimeForPlayer(player.userID);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void GetSpawnPos(out Vector3 pos, out Quaternion rot)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		pos = ((Component)this).transform.position + spawnOffset;
		Quaternion rotation = ((Component)this).transform.rotation;
		rot = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
	}

	public void SetPublic(bool isPublic)
	{
		SetFlag(Flags.Reserved3, isPublic);
	}

	public void SetDeployedBy(BasePlayer player)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)player == (Object)null) && !base.isClient)
		{
			deployerUserID = player.userID;
			SetBagTimer(this, ((Component)this).transform.position, SleepingBagResetReason.Placed, player);
			SendNetworkUpdate();
			notifyPlayerOnServerInit = true;
		}
	}

	public static void OnPlayerDeath(BasePlayer player)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		PooledList<SleepingBag> val = FindForPlayer(player.userID);
		try
		{
			foreach (SleepingBag item in (List<SleepingBag>)(object)val)
			{
				SetBagTimer(item, ((Component)player).transform.position, SleepingBagResetReason.Death, player);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void SetBagTimer(SleepingBag bag, Vector3 position, SleepingBagResetReason reason, BasePlayer forPlayer)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		float? num = null;
		if ((Object)(object)activeGameMode != (Object)null)
		{
			num = activeGameMode.EvaluateSleepingBagReset(bag, position, reason);
		}
		if (num.HasValue)
		{
			bag.SetUnlockTime(Time.realtimeSinceStartup + num.Value);
			return;
		}
		if (reason == SleepingBagResetReason.Respawned && Vector3.Distance(position, ((Component)bag).transform.position) <= ConVar.Server.respawnresetrange)
		{
			if (bag.perPlayerRespawnCooldown)
			{
				bag.SetUnlockTimeForPlayer(forPlayer.userID, Time.realtimeSinceStartup + bag.EvaluatedSecondsBetweenReuses());
			}
			else
			{
				bag.SetUnlockTime(Time.realtimeSinceStartup + bag.EvaluatedSecondsBetweenReuses());
			}
			bag.SendNetworkUpdate();
		}
		if (reason != SleepingBagResetReason.Placed)
		{
			return;
		}
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		SleepingBag[] array = sleepingBags.Where((SleepingBag x) => x.deployerUserID != 0L && x.deployerUserID == bag.deployerUserID && x.unlockTime > Time.realtimeSinceStartup).ToArray();
		foreach (SleepingBag sleepingBag in array)
		{
			if (bag.unlockTime > realtimeSinceStartup && Vector3.Distance(((Component)sleepingBag).transform.position, position) <= ConVar.Server.respawnresetrange)
			{
				realtimeSinceStartup = bag.unlockTime;
			}
		}
		float num2 = Mathf.Max(realtimeSinceStartup, Time.realtimeSinceStartup + bag.EvaluatedSecondsBetweenReuses());
		if ((Object)(object)forPlayer != (Object)null && forPlayer.IsInTutorial)
		{
			num2 = 0f;
		}
		bag.SetUnlockTime(num2);
		bag.SendNetworkUpdate();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!sleepingBags.Contains(this))
		{
			sleepingBags.Add(this);
			if (deployerUserID != 0L)
			{
				AddBagForPlayer(this, deployerUserID, !Application.isLoadingSave);
			}
		}
		if (notifyPlayerOnServerInit)
		{
			notifyPlayerOnServerInit = false;
			NotifyPlayer(deployerUserID);
		}
	}

	public override void OnPlaced(BasePlayer player)
	{
		SetDeployedBy(player);
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		((FacepunchBehaviour)this).Invoke((Action)DelayedPlayerNotify, 0.1f);
	}

	private void DelayedPlayerNotify()
	{
		NotifyPlayer(deployerUserID);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		AddBagForPlayer(this, deployerUserID, !Application.isLoadingSave);
	}

	private void NotifyPlayer(ulong id)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(id);
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsConnected)
		{
			basePlayer.SendRespawnOptions();
		}
	}

	public override void DoServerDestroy()
	{
		base.DoServerDestroy();
		sleepingBags.RemoveAll((SleepingBag x) => (Object)(object)x == (Object)(object)this);
		RemoveBagForPlayer(this, deployerUserID);
		NotifyPlayer(deployerUserID);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		TimeWarning val = TimeWarning.New("SleepingBag.Save", 0);
		try
		{
			info.msg.sleepingBag = Pool.Get<SleepingBag>();
			info.msg.sleepingBag.name = niceName;
			if (info.forDisk)
			{
				info.msg.sleepingBag.deployerID = deployerUserID;
			}
			else
			{
				info.msg.sleepingBag.clientAssigned = deployerUserID == info.forConnection.userid;
				info.msg.sleepingBag.isAssigned = deployerUserID != 0;
			}
			if (!UseTeamLabels)
			{
				return;
			}
			if ((Object)(object)RelationshipManager.ServerInstance != (Object)null && info.forConnection != null)
			{
				try
				{
					RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(deployerUserID);
					BasePlayer basePlayer = BasePlayer.FindAwakeOrSleepingByID(deployerUserID);
					if (playerTeam != null || ((Object)(object)basePlayer != (Object)null && info.forConnection == basePlayer.Connection))
					{
						if (info.forConnection.userid != 0L && (Object)(object)basePlayer != (Object)null)
						{
							string displayName = basePlayer.displayName;
							if (deployerUserID == info.forConnection.userid)
							{
								info.msg.sleepingBag.teamMemberName = displayName;
							}
							else
							{
								List<ulong> members = playerTeam.members;
								if (members.Count > 0 && members.Contains(info.forConnection.userid))
								{
									info.msg.sleepingBag.teamMemberName = displayName;
								}
								else
								{
									info.msg.sleepingBag.teamMemberName = "";
								}
							}
						}
					}
					else
					{
						info.msg.sleepingBag.teamMemberName = "";
					}
					return;
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					return;
				}
			}
			info.msg.sleepingBag.teamMemberName = "";
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override bool CanUseNetworkCache(Connection connection)
	{
		return false;
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return true;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Rename(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		string text = msg.read.String(256, false);
		if (Interface.CallHook("CanRenameBed", (object)msg.player, (object)this, (object)text) == null)
		{
			text = WordFilter.Filter(text);
			if (string.IsNullOrEmpty(text))
			{
				text = "Unnamed Sleeping Bag";
			}
			if (text.Length > 24)
			{
				text = text.Substring(0, 22) + "..";
			}
			niceName = text;
			SendNetworkUpdate();
			NotifyPlayer(deployerUserID);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void AssignToFriend(RPCMessage msg)
	{
		if (!msg.player.CanInteract() || deployerUserID != (ulong)msg.player.userID || !canReassignToFriends)
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num == 0L || Interface.CallHook("CanAssignBed", (object)msg.player, (object)this, (object)num) != null)
		{
			return;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, num);
			if (canAssignBedResult.HasValue)
			{
				BasePlayer basePlayer = RelationshipManager.FindByID(num);
				if (canAssignBedResult.Value.Result == BagResultType.TooManyBags)
				{
					if ((Object)(object)basePlayer == (Object)null)
					{
						msg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedNoPlayerPhrase, false);
					}
					else
					{
						string playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);
						msg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedPhrase, false, playerNameStreamSafe);
					}
				}
				else if (canAssignBedResult.Value.Result == BagResultType.BagBlocked)
				{
					msg.player.ShowToast(GameTip.Styles.Error, bedAssigningBlocked, false);
				}
				else if (canAssignBedResult.Value.Result == BagResultType.TargetIsPlayingTutorial)
				{
					msg.player.ShowToast(GameTip.Styles.Error, tutorialPhrase, false);
				}
				else
				{
					basePlayer?.ShowToast(GameTip.Styles.Blue_Long, assignedBagPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, (GetSleepingBagCount(msg.player.userID) - 1).ToString(), canAssignBedResult.Value.Max.ToString());
					SendNetworkUpdate();
				}
				if (canAssignBedResult.Value.Result != 0)
				{
					return;
				}
			}
		}
		ulong num2 = deployerUserID;
		deployerUserID = num;
		OnBagChangedOwnership(this, num2);
		NotifyPlayer(num2);
		NotifyPlayer(deployerUserID);
		Analytics.Azure.OnSleepingBagAssigned(msg.player, this, num);
		SendNetworkUpdate();
	}

	[ServerVar]
	public static void AssignToPlayer(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		NetworkableId entityID = arg.GetEntityID(0);
		SleepingBag obj = BaseNetworkable.serverEntities.Find(entityID) as SleepingBag;
		ulong num = obj.deployerUserID;
		obj.deployerUserID = basePlayer.userID.Get();
		OnBagChangedOwnership(obj, num);
		obj.NotifyPlayer(num);
		obj.NotifyPlayer(obj.deployerUserID);
		obj.SendNetworkUpdate();
	}

	[ServerVar]
	public static void ClearFromPlayer(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityID = arg.GetEntityID(0);
		SleepingBag obj = BaseNetworkable.serverEntities.Find(entityID) as SleepingBag;
		ulong num = obj.deployerUserID;
		obj.deployerUserID = 0uL;
		RemoveBagForPlayer(obj, num);
		obj.NotifyPlayer(num);
		obj.SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public virtual void RPC_MakePublic(RPCMessage msg)
	{
		if (!canBePublic || !msg.player.CanInteract() || (deployerUserID != (ulong)msg.player.userID && !msg.player.CanBuild()))
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag == IsPublic() || Interface.CallHook("CanSetBedPublic", (object)msg.player, (object)this) != null)
		{
			return;
		}
		SetPublic(flag);
		if (!IsPublic())
		{
			if (ConVar.Server.max_sleeping_bags > 0)
			{
				CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);
				if (canAssignBedResult.HasValue)
				{
					if (canAssignBedResult.Value.Result == BagResultType.Ok)
					{
						msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					}
					else
					{
						msg.player.ShowToast(GameTip.Styles.Blue_Long, cannotMakeBedPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					}
					if (canAssignBedResult.Value.Result != 0)
					{
						return;
					}
				}
			}
			ulong num = deployerUserID;
			deployerUserID = msg.player.userID;
			OnBagChangedOwnership(this, num);
			NotifyPlayer(num);
			NotifyPlayer(deployerUserID);
			Analytics.Azure.OnSleepingBagAssigned(msg.player, this, deployerUserID = msg.player.userID);
		}
		else
		{
			Analytics.Azure.OnSleepingBagAssigned(msg.player, this, 0uL);
		}
		SendNetworkUpdate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_MakeBed(RPCMessage msg)
	{
		if (!canBePublic || !IsPublic() || !msg.player.CanInteract())
		{
			return;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);
			if (canAssignBedResult.HasValue)
			{
				if (canAssignBedResult.Value.Result != 0)
				{
					msg.player.ShowToast(GameTip.Styles.Red_Normal, cannotMakeBedPhrase, false);
				}
				else
				{
					msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
				}
				if (canAssignBedResult.Value.Result != 0)
				{
					return;
				}
			}
		}
		ulong num = deployerUserID;
		deployerUserID = msg.player.userID;
		OnBagChangedOwnership(this, num);
		NotifyPlayer(num);
		NotifyPlayer(deployerUserID);
		Interface.CallHook("OnBedMade", (object)this, (object)msg.player);
		SendNetworkUpdate();
	}

	protected virtual void PostPlayerSpawn(BasePlayer p)
	{
		p.SendRespawnOptions();
	}

	public virtual RespawnState GetRespawnState(ulong userID)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (!WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: false))
		{
			if (!TriggerNoRespawnZone.InAnyNoRespawnZone(((Component)this).transform.position))
			{
				return (RespawnState)1;
			}
			return (RespawnState)4;
		}
		return (RespawnState)3;
	}

	public virtual bool IsMobile()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Invalid comparison between Unknown and I4
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity is BaseVehicle)
		{
			return true;
		}
		return (int)RespawnType == 4;
	}

	public override string Admin_Who()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine(base.Admin_Who());
		stringBuilder.AppendLine($"Assigned bag ID: {deployerUserID}");
		stringBuilder.AppendLine("Assigned player name: " + Admin.GetPlayerName(deployerUserID));
		stringBuilder.AppendLine("Bag Name:" + niceName);
		return stringBuilder.ToString();
	}

	public override void OnDeployableCorpseSpawned(BaseEntity corpse)
	{
		base.OnDeployableCorpseSpawned(corpse);
		if (corpse is SleepingBag sleepingBag)
		{
			sleepingBag.deployerUserID = deployerUserID;
			sleepingBag.niceName = niceName;
			sleepingBag.SetFlag(Flags.Reserved14, b: true);
			AddBagForPlayer(sleepingBag, deployerUserID);
		}
	}

	public override bool ShouldDropDeployableCorpse(HitInfo info)
	{
		if (!base.ShouldDropDeployableCorpse(info))
		{
			return false;
		}
		if (HasFlag(Flags.Reserved14))
		{
			return false;
		}
		return true;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.sleepingBag != null)
		{
			niceName = info.msg.sleepingBag.name;
			if (base.isServer)
			{
				deployerUserID = info.msg.sleepingBag.deployerID;
			}
		}
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (base.ShouldDisplayPickupOption(player) && player.IsBuildingAuthed())
		{
			return true;
		}
		if (base.ShouldDisplayPickupOption(player))
		{
			return (ulong)player.userID == deployerUserID;
		}
		return false;
	}
}


public enum BagAssignMode
{
	Allowed = 0,
	TeamAndFriendlyContacts = 1,
	None = 2,
	LAST = 2
}


public enum BagResultType
{
	Ok,
	TooManyBags,
	BagBlocked,
	TargetIsPlayingTutorial
}


public struct CanAssignBedResult
{
	public BagResultType Result;

	public int Count;

	public int Max;
}


public enum SleepingBagResetReason
{
	Respawned,
	Placed,
	Death
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SleepingBagCamper : SleepingBag
{
	public EntityRef<BaseVehicleSeat> AssociatedSeat;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SleepingBagCamper.OnRpcMessage", 0);
		try
		{
			if (rpc == 2177887503u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerClearBed "));
				}
				TimeWarning val2 = TimeWarning.New("ServerClearBed", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2177887503u, "ServerClearBed", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ServerClearBed(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ServerClearBed");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Reserved3, b: true);
	}

	protected override void PostPlayerSpawn(BasePlayer p)
	{
		base.PostPlayerSpawn(p);
		BaseVehicleSeat baseVehicleSeat = AssociatedSeat.Get(base.isServer);
		if ((Object)(object)baseVehicleSeat != (Object)null)
		{
			if (p.IsConnected)
			{
				p.EndSleeping();
			}
			baseVehicleSeat.MountPlayer(p);
		}
	}

	public void SetSeat(BaseVehicleSeat seat, bool sendNetworkUpdate = false)
	{
		AssociatedSeat.Set(seat);
		if (sendNetworkUpdate)
		{
			SendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.sleepingBagCamper = Pool.Get<SleepingBagCamper>();
			info.msg.sleepingBagCamper.seatID = AssociatedSeat.uid;
		}
	}

	public override RespawnState GetRespawnState(ulong userID)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Invalid comparison between Unknown and I4
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		RespawnState respawnState = base.GetRespawnState(userID);
		if ((int)respawnState != 1)
		{
			return respawnState;
		}
		if (AssociatedSeat.IsValid(base.isServer))
		{
			BasePlayer mounted = AssociatedSeat.Get(base.isServer).GetMounted();
			if ((Object)(object)mounted != (Object)null && (ulong)mounted.userID != userID)
			{
				return (RespawnState)2;
			}
		}
		return (RespawnState)1;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void ServerClearBed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && AssociatedSeat.IsValid(base.isServer) && !((Object)(object)AssociatedSeat.Get(base.isServer).GetMounted() != (Object)(object)player))
		{
			ulong userID = deployerUserID;
			SleepingBag.RemoveBagForPlayer(this, deployerUserID);
			deployerUserID = 0uL;
			SendNetworkUpdate();
			BasePlayer basePlayer = BasePlayer.FindByID(userID);
			if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsDestroyed)
			{
				basePlayer.SendRespawnOptions();
			}
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class SlotMachine : BaseMountable
{
	public enum SlotFaces
	{
		Scrap,
		Rope,
		Apple,
		LowGrade,
		Wood,
		Bandage,
		Charcoal,
		Gunpowder,
		Rust,
		Meat,
		Hammer,
		Sulfur,
		TechScrap,
		Frags,
		Cloth,
		LuckySeven
	}

	[ServerVar]
	public static int ForcePayoutIndex = -1;

	[Header("Slot Machine")]
	public Transform Reel1;

	public Transform Reel2;

	public Transform Reel3;

	public Transform Arm;

	public AnimationCurve Curve;

	public int Reel1Spins = 16;

	public int Reel2Spins = 48;

	public int Reel3Spins = 80;

	public int MaxReelSpins = 96;

	public float SpinDuration = 2f;

	private int SpinResult1;

	private int SpinResult2;

	private int SpinResult3;

	private int SpinResultPrevious1;

	private int SpinResultPrevious2;

	private int SpinResultPrevious3;

	private float SpinTime;

	public GameObjectRef StoragePrefab;

	public EntityRef StorageInstance;

	public SoundDefinition SpinSound;

	public SlotMachinePayoutDisplay PayoutDisplay;

	public SlotMachinePayoutSettings PayoutSettings;

	public Transform HandIkTarget;

	private const Flags HasScrapForSpin = Flags.Reserved1;

	private const Flags IsSpinningFlag = Flags.Reserved2;

	public Material PayoutIconMaterial;

	public bool UseTimeOfDayAdjustedSprite = true;

	public MeshRenderer[] PulseRenderers;

	public float PulseSpeed = 5f;

	[ColorUsage(true, true)]
	public Color PulseFrom;

	[ColorUsage(true, true)]
	public Color PulseTo;

	private BasePlayer CurrentSpinPlayer;

	private bool IsSpinning => HasFlag(Flags.Reserved2);

	public int CurrentMultiplier { get; private set; } = 1;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SlotMachine.OnRpcMessage", 0);
		try
		{
			if (rpc == 1251063754 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Deposit "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Deposit", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1251063754u, "RPC_Deposit", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_Deposit(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Deposit");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1455840454 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Spin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Spin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1455840454u, "RPC_Spin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							RPC_Spin(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Spin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3942337446u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestMultiplierChange "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestMultiplierChange", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3942337446u, "Server_RequestMultiplierChange", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3942337446u, "Server_RequestMultiplierChange", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_RequestMultiplierChange(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in Server_RequestMultiplierChange");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Save(SaveInfo info)
	{
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.slotMachine = Pool.Get<SlotMachine>();
		info.msg.slotMachine.oldResult1 = SpinResultPrevious1;
		info.msg.slotMachine.oldResult2 = SpinResultPrevious2;
		info.msg.slotMachine.oldResult3 = SpinResultPrevious3;
		info.msg.slotMachine.newResult1 = SpinResult1;
		info.msg.slotMachine.newResult2 = SpinResult2;
		info.msg.slotMachine.newResult3 = SpinResult3;
		info.msg.slotMachine.isSpinning = IsSpinning;
		info.msg.slotMachine.spinTime = SpinTime;
		info.msg.slotMachine.storageID = StorageInstance.uid;
		info.msg.slotMachine.multiplier = CurrentMultiplier;
	}

	public override void Load(LoadInfo info)
	{
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.slotMachine != null)
		{
			SpinResultPrevious1 = info.msg.slotMachine.oldResult1;
			SpinResultPrevious2 = info.msg.slotMachine.oldResult2;
			SpinResultPrevious3 = info.msg.slotMachine.oldResult3;
			SpinResult1 = info.msg.slotMachine.newResult1;
			SpinResult2 = info.msg.slotMachine.newResult2;
			SpinResult3 = info.msg.slotMachine.newResult3;
			CurrentMultiplier = info.msg.slotMachine.multiplier;
			if (base.isServer)
			{
				SpinTime = info.msg.slotMachine.spinTime;
			}
			StorageInstance.uid = info.msg.slotMachine.storageID;
			if (info.fromDisk && base.isServer)
			{
				SetFlag(Flags.Reserved2, b: false);
			}
		}
	}

	public override float GetComfort()
	{
		return 1f;
	}

	public override void Spawn()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(StoragePrefab.resourcePath);
			baseEntity.Spawn();
			baseEntity.SetParent(this);
			StorageInstance.Set(baseEntity);
		}
	}

	internal override void DoServerDestroy()
	{
		SlotMachineStorage slotMachineStorage = StorageInstance.Get(base.isServer) as SlotMachineStorage;
		if (slotMachineStorage.IsValid())
		{
			slotMachineStorage.DropItems();
		}
		base.DoServerDestroy();
	}

	private int GetBettingAmount()
	{
		SlotMachineStorage component = ((Component)StorageInstance.Get(base.isServer)).GetComponent<SlotMachineStorage>();
		if ((Object)(object)component == (Object)null)
		{
			return 0;
		}
		return component.inventory.GetSlot(0)?.amount ?? 0;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Spin(RPCMessage rpc)
	{
		if (IsSpinning || (Object)(object)rpc.player != (Object)(object)GetMounted())
		{
			return;
		}
		SlotMachineStorage component = ((Component)StorageInstance.Get(base.isServer)).GetComponent<SlotMachineStorage>();
		int num = (int)PayoutSettings.SpinCost.amount * CurrentMultiplier;
		if (GetBettingAmount() < num || (Object)(object)rpc.player == (Object)null)
		{
			return;
		}
		(CurrentSpinPlayer = rpc.player).inventory.loot.Clear();
		Item slot = component.inventory.GetSlot(0);
		int amount = 0;
		if (slot != null)
		{
			if (slot.amount > num)
			{
				slot.MarkDirty();
				slot.amount -= num;
				amount = slot.amount;
			}
			else
			{
				slot.amount -= num;
				slot.RemoveFromContainer();
			}
		}
		component.UpdateAmount(amount);
		SetFlag(Flags.Reserved2, b: true);
		SpinResultPrevious1 = SpinResult1;
		SpinResultPrevious2 = SpinResult2;
		SpinResultPrevious3 = SpinResult3;
		CalculateSpinResults();
		SpinTime = Time.time;
		ClientRPC(RpcTarget.NetworkGroup("RPC_OnSpin"), (sbyte)SpinResult1, (sbyte)SpinResult2, (sbyte)SpinResult3);
		((FacepunchBehaviour)this).Invoke((Action)CheckPayout, SpinDuration);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Deposit(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null) && !HasFlag(Flags.Reserved2) && StorageInstance.IsValid(base.isServer))
		{
			((Component)StorageInstance.Get(base.isServer)).GetComponent<StorageContainer>().PlayerOpenLoot(player, "", doPositionChecks: false);
		}
	}

	private void CheckPayout()
	{
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if ((Object)(object)PayoutSettings != (Object)null)
		{
			if (CalculatePayout(out var info, out var bonus))
			{
				int num = ((int)info.Item.amount + bonus) * CurrentMultiplier;
				BaseEntity baseEntity = StorageInstance.Get(serverside: true);
				if ((Object)(object)baseEntity != (Object)null && baseEntity is SlotMachineStorage slotMachineStorage)
				{
					Item slot = slotMachineStorage.inventory.GetSlot(1);
					if (slot != null)
					{
						slot.amount += num;
						slot.MarkDirty();
					}
					else
					{
						ItemManager.Create(info.Item.itemDef, num, 0uL).MoveToContainer(slotMachineStorage.inventory, 1);
					}
				}
				if (CurrentSpinPlayer.IsValid() && (Object)(object)CurrentSpinPlayer == (Object)(object)GetMounted())
				{
					CurrentSpinPlayer.ChatMessage($"You received {num}x {info.Item.itemDef.displayName.english} for slots payout!");
				}
				Analytics.Azure.OnGamblingResult(CurrentSpinPlayer, this, (int)PayoutSettings.SpinCost.amount * CurrentMultiplier, num, null);
				if (info.OverrideWinEffect != null && info.OverrideWinEffect.isValid)
				{
					Effect.server.Run(info.OverrideWinEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
				else if (PayoutSettings.DefaultWinEffect != null && PayoutSettings.DefaultWinEffect.isValid)
				{
					Effect.server.Run(PayoutSettings.DefaultWinEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
				if (info.OverrideWinEffect != null && info.OverrideWinEffect.isValid)
				{
					flag = true;
				}
			}
			else
			{
				Analytics.Azure.OnGamblingResult(CurrentSpinPlayer, this, (int)PayoutSettings.SpinCost.amount * CurrentMultiplier, 0, null);
			}
		}
		else
		{
			Debug.LogError((object)$"Failed to process spin results: PayoutSettings != null {(Object)(object)PayoutSettings != (Object)null} CurrentSpinPlayer.IsValid {CurrentSpinPlayer.IsValid()} CurrentSpinPlayer == mounted {(Object)(object)CurrentSpinPlayer == (Object)(object)GetMounted()}");
		}
		if (!flag)
		{
			SetFlag(Flags.Reserved2, b: false);
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedSpinningReset, 4f);
		}
		CurrentSpinPlayer = null;
	}

	private void DelayedSpinningReset()
	{
		SetFlag(Flags.Reserved2, b: false);
	}

	private void CalculateSpinResults()
	{
		if (ForcePayoutIndex != -1)
		{
			SpinResult1 = PayoutSettings.Payouts[ForcePayoutIndex].Result1;
			SpinResult2 = PayoutSettings.Payouts[ForcePayoutIndex].Result2;
			SpinResult3 = PayoutSettings.Payouts[ForcePayoutIndex].Result3;
		}
		else
		{
			SpinResult1 = RandomSpinResult();
			SpinResult2 = RandomSpinResult();
			SpinResult3 = RandomSpinResult();
		}
	}

	private int RandomSpinResult()
	{
		int num = new Random(Random.Range(0, 1000)).Next(0, PayoutSettings.TotalStops);
		int num2 = 0;
		int num3 = 0;
		int[] virtualFaces = PayoutSettings.VirtualFaces;
		foreach (int num4 in virtualFaces)
		{
			if (num < num4 + num2)
			{
				return num3;
			}
			num2 += num4;
			num3++;
		}
		return 15;
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		BaseEntity baseEntity = StorageInstance.Get(serverside: true);
		if ((Object)(object)baseEntity != (Object)null && baseEntity is SlotMachineStorage slotMachineStorage)
		{
			slotMachineStorage.inventory.GetSlot(1)?.MoveToContainer(player.inventory.containerMain);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	private void Server_RequestMultiplierChange(RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)GetMounted()) && !HasFlag(Flags.Reserved2))
		{
			CurrentMultiplier = Mathf.Clamp(msg.read.Int32(), 1, 5);
			OnBettingScrapUpdated(GetBettingAmount());
			SendNetworkUpdate();
		}
	}

	public void OnBettingScrapUpdated(int amount)
	{
		SetFlag(Flags.Reserved1, (float)amount >= PayoutSettings.SpinCost.amount * (float)CurrentMultiplier);
	}

	private bool CalculatePayout(out SlotMachinePayoutSettings.PayoutInfo info, out int bonus)
	{
		info = default(SlotMachinePayoutSettings.PayoutInfo);
		bonus = 0;
		SlotMachinePayoutSettings.IndividualPayouts[] facePayouts = PayoutSettings.FacePayouts;
		for (int i = 0; i < facePayouts.Length; i++)
		{
			SlotMachinePayoutSettings.IndividualPayouts individualPayouts = facePayouts[i];
			if (individualPayouts.Result == SpinResult1)
			{
				bonus += (int)individualPayouts.Item.amount;
			}
			if (individualPayouts.Result == SpinResult2)
			{
				bonus += (int)individualPayouts.Item.amount;
			}
			if (individualPayouts.Result == SpinResult3)
			{
				bonus += (int)individualPayouts.Item.amount;
			}
			if (bonus > 0)
			{
				info.Item = new ItemAmount(individualPayouts.Item.itemDef);
			}
		}
		SlotMachinePayoutSettings.PayoutInfo[] payouts = PayoutSettings.Payouts;
		for (int i = 0; i < payouts.Length; i++)
		{
			SlotMachinePayoutSettings.PayoutInfo payoutInfo = payouts[i];
			if (payoutInfo.Result1 == SpinResult1 && payoutInfo.Result2 == SpinResult2 && payoutInfo.Result3 == SpinResult3)
			{
				info = payoutInfo;
				return true;
			}
		}
		return bonus > 0;
	}
}


public enum SlotFaces
{
	Scrap,
	Rope,
	Apple,
	LowGrade,
	Wood,
	Bandage,
	Charcoal,
	Gunpowder,
	Rust,
	Meat,
	Hammer,
	Sulfur,
	TechScrap,
	Frags,
	Cloth,
	LuckySeven
}


using System;
using Network;
using UnityEngine;

public class SlotMachineStorage : StorageContainer
{
	public int Amount;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SlotMachineStorage.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsPlayerValid(BasePlayer player)
	{
		if (!player.isMounted || (Object)(object)player.GetMounted() != (Object)(object)GetParentEntity())
		{
			return false;
		}
		return true;
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (!IsPlayerValid(player))
		{
			return false;
		}
		return base.PlayerOpenLoot(player, panelToOpen);
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		UpdateAmount(base.inventory.GetSlot(0)?.amount ?? 0);
	}

	public void UpdateAmount(int amount)
	{
		if (Amount != amount)
		{
			Amount = amount;
			(GetParentEntity() as SlotMachine).OnBettingScrapUpdated(amount);
			ClientRPC(RpcTarget.NetworkGroup("RPC_UpdateAmount"), Amount);
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!IsPlayerValid(player))
		{
			return false;
		}
		return base.CanBeLooted(player);
	}
}


using System;
using CompanionServer;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SmartAlarm : AppIOEntity, ISubscribable
{
	public const Flags Flag_HasCustomMessage = Flags.Reserved6;

	public static readonly Phrase DefaultNotificationTitle = new Phrase("app.alarm.title", "Alarm");

	public static readonly Phrase DefaultNotificationBody = new Phrase("app.alarm.body", "Your base is under attack!");

	[Header("Smart Alarm")]
	public GameObjectRef SetupNotificationDialog;

	public Animator Animator;

	public readonly NotificationList _subscriptions = new NotificationList();

	public string _notificationTitle = "";

	public string _notificationBody = "";

	public float _lastSentTime;

	public override AppEntityType Type => (AppEntityType)2;

	public override bool Value { get; set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SmartAlarm.OnRpcMessage", 0);
		try
		{
			if (rpc == 3292290572u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetNotificationTextImpl "));
				}
				TimeWarning val2 = TimeWarning.New("SetNotificationTextImpl", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3292290572u, "SetNotificationTextImpl", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3292290572u, "SetNotificationTextImpl", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage notificationTextImpl = rPCMessage;
							SetNotificationTextImpl(notificationTextImpl);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetNotificationTextImpl");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4207149767u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StartSetupNotification "));
				}
				TimeWarning val2 = TimeWarning.New("StartSetupNotification", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4207149767u, "StartSetupNotification", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4207149767u, "StartSetupNotification", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							StartSetupNotification(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in StartSetupNotification");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool AddSubscription(ulong steamId)
	{
		return _subscriptions.AddSubscription(steamId);
	}

	public bool RemoveSubscription(ulong steamId)
	{
		return _subscriptions.RemoveSubscription(steamId);
	}

	public bool HasSubscription(ulong steamId)
	{
		return _subscriptions.HasSubscription(steamId);
	}

	public override void InitShared()
	{
		base.InitShared();
		_notificationTitle = DefaultNotificationTitle.translated;
		_notificationBody = DefaultNotificationBody.translated;
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		Value = inputAmount > 0;
		if (Value == IsOn())
		{
			return;
		}
		SetFlag(Flags.On, Value);
		BroadcastValueChange();
		float num = Mathf.Max(App.alarmcooldown, 15f);
		if (Value && Time.realtimeSinceStartup - _lastSentTime >= num)
		{
			BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
			if ((Object)(object)buildingPrivilege != (Object)null)
			{
				_subscriptions.IntersectWith(buildingPrivilege.authorizedPlayers);
			}
			_subscriptions.SendNotification(NotificationChannel.SmartAlarm, _notificationTitle, _notificationBody, "alarm");
			_lastSentTime = Time.realtimeSinceStartup;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.smartAlarm = Pool.Get<SmartAlarm>();
			info.msg.smartAlarm.notificationTitle = _notificationTitle;
			info.msg.smartAlarm.notificationBody = _notificationBody;
			info.msg.smartAlarm.subscriptions = _subscriptions.ToList();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk && info.msg.smartAlarm != null)
		{
			_notificationTitle = info.msg.smartAlarm.notificationTitle;
			_notificationBody = info.msg.smartAlarm.notificationBody;
			_subscriptions.LoadFrom(info.msg.smartAlarm.subscriptions);
		}
	}

	protected override void OnPairedWithPlayer(BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null) && !HasSubscription(player.userID) && !AddSubscription(player.userID))
		{
			player.ClientRPC(RpcTarget.Player("HandleCompanionPairingResult", player), 7);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	private void StartSetupNotification(RPCMessage rpc)
	{
		if (rpc.player.CanInteract())
		{
			BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
			if (!((Object)(object)buildingPrivilege != (Object)null) || buildingPrivilege.CanAdministrate(rpc.player))
			{
				ClientRPC(RpcTarget.Player("SetupNotification", rpc.player), _notificationTitle, _notificationBody);
			}
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void SetNotificationTextImpl(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
		if (!((Object)(object)buildingPrivilege != (Object)null) || buildingPrivilege.CanAdministrate(rpc.player))
		{
			string text = rpc.read.String(128, false);
			string text2 = rpc.read.String(512, false);
			if (!string.IsNullOrWhiteSpace(text))
			{
				_notificationTitle = text;
			}
			if (!string.IsNullOrWhiteSpace(text2))
			{
				_notificationBody = text2;
			}
			SetFlag(Flags.Reserved6, b: true);
		}
	}
}


using System;
using ConVar;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SmartSwitch : AppIOEntity
{
	[Header("Smart Switch")]
	public Animator ReceiverAnimator;

	public override AppEntityType Type => (AppEntityType)1;

	public override bool Value
	{
		get
		{
			return IsOn();
		}
		set
		{
			SetSwitch(value);
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SmartSwitch.OnRpcMessage", 0);
		try
		{
			if (rpc == 2810053005u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ToggleSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("ToggleSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2810053005u, "ToggleSwitch", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2810053005u, "ToggleSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ToggleSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ToggleSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool WantsPower(int inputIndex)
	{
		if (inputIndex == 0)
		{
			return IsOn();
		}
		return false;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Busy, b: false);
	}

	public override void ResetIOState()
	{
		SetFlag(Flags.On, b: false);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsOn())
		{
			return 0;
		}
		return GetCurrentEnergy();
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		if (inputSlot != 0)
		{
			return currentEnergy;
		}
		return base.CalculateCurrentEnergy(inputAmount, inputSlot);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 1 && inputAmount > 0)
		{
			SetSwitch(wantsOn: true);
		}
		if (inputSlot == 2 && inputAmount > 0)
		{
			SetSwitch(wantsOn: false);
		}
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public void SetSwitch(bool wantsOn)
	{
		if (wantsOn != IsOn())
		{
			SetFlag(Flags.On, wantsOn);
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).Invoke((Action)Unbusy, 0.5f);
			SendNetworkUpdateImmediate();
			MarkDirty();
			BroadcastValueChange();
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.IsVisible(3f)]
	public void ToggleSwitch(RPCMessage msg)
	{
		if (PlayerCanToggle(msg.player))
		{
			SetSwitch(!IsOn());
		}
	}

	public void Unbusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	private static bool PlayerCanToggle(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null)
		{
			return player.CanBuild();
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Network;
using UnityEngine;

public class SnakeHazard : WildlifeHazard
{
	public static Phrase SnakeHazardFailedTipPhrase = new Phrase("toast.snake_hazard_failed", "Jump immediately when a Snake hisses to avoid its attack.");

	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 5f;

	public List<ModifierDefintion> FailModifierEffects;

	private BasePlayer playerToAttack;

	private float slitherRate = 0.05f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SnakeHazard.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	protected override void OnHazardFailed(BasePlayer player)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		base.OnHazardFailed(player);
		if (!((Object)(object)player == (Object)null))
		{
			ClientRPC(RpcTarget.Player("CL_SnakeHazardFailed", player));
			if (GamePhysics.LineOfSight(((Component)this).transform.position + Vector3.up * 0.25f, ((Component)player).transform.position + Vector3.up * 0.25f, 1075904769))
			{
				playerToAttack = player;
				((FacepunchBehaviour)this).Invoke((Action)ApplyAttackToPlayer, 0.3f);
				ClientRPC(RpcTarget.NetworkGroup("CL_Attack"));
			}
		}
	}

	private void ApplyAttackToPlayer()
	{
		if ((Object)(object)playerToAttack == (Object)null)
		{
			return;
		}
		if (!playerToAttack.OnAttacked(Damage, DamageType, this, ignoreShield: false))
		{
			playerToAttack = null;
			return;
		}
		if (FailModifierEffects != null && (Object)(object)playerToAttack.modifiers != (Object)null)
		{
			playerToAttack.modifiers.Add(FailModifierEffects);
		}
		playerToAttack = null;
	}

	public override void StartReposition()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		base.StartReposition();
		if (!base.IsCorpse)
		{
			if (base.isServer)
			{
				ClientRPC(RpcTarget.NetworkGroup("CL_RepositionDisappear"), repositionTo);
			}
			((FacepunchBehaviour)this).InvokeRepeating((Action)SlitherTick, 0.2f, slitherRate);
			((FacepunchBehaviour)this).Invoke((Action)StartDelayedTeleport, SlitherDuration + 0.2f);
		}
	}

	private void SlitherTick()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.MoveTowards(((Component)this).transform.position, repositionTo, SlitherSpeed * slitherRate);
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(val + Vector3.up * 1f, Vector3.down, ref val2, 5f, 8388608))
		{
			val = ((RaycastHit)(ref val2)).point;
		}
		((Component)this).transform.position = val;
		try
		{
			syncPosition = true;
			NetworkPositionTick();
		}
		finally
		{
			syncPosition = false;
		}
	}

	private void StartDelayedTeleport()
	{
		if (!base.IsCorpse)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SlitherTick);
			SetFlag(Flags.Disabled, b: true);
			((FacepunchBehaviour)this).Invoke((Action)EndDelayedTeleport, 2f);
		}
	}

	private void EndDelayedTeleport()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.Disabled, b: false);
		ServerPosition = repositionTo;
		SendNetworkUpdate_Position();
		if (base.isServer)
		{
			if (PrefabRepositionEffect != null && PrefabRepositionEffect.isValid)
			{
				Effect.server.Run(PrefabReappearEffect.resourcePath, ServerPosition, Vector3.up);
			}
			ClientRPC(RpcTarget.NetworkGroup("CL_RepositionReappear"), repositionLookAtPos);
		}
	}

	protected override bool ShouldStartHazard(BasePlayer player)
	{
		if (!base.ShouldStartHazard(player))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)SlitherTick))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)StartDelayedTeleport))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)EndDelayedTeleport))
		{
			return false;
		}
		return true;
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		CancelSnakeInvokes();
	}

	public override void OnKilled()
	{
		base.OnKilled();
		CancelSnakeInvokes();
	}

	private void CancelSnakeInvokes()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)SlitherTick);
		((FacepunchBehaviour)this).CancelInvoke((Action)StartDelayedTeleport);
		((FacepunchBehaviour)this).CancelInvoke((Action)EndDelayedTeleport);
		((FacepunchBehaviour)this).CancelInvoke((Action)ApplyAttackToPlayer);
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Snowmobile : GroundVehicle, VehicleChassisVisuals<Snowmobile>.IClientWheelUser, IPrefabPreProcess, CarPhysics<Snowmobile>.ICar, TriggerHurtNotChild.IHurtTriggerUser
{
	[Header("Snowmobile")]
	[SerializeField]
	private Transform centreOfMassTransform;

	[SerializeField]
	private GameObjectRef itemStoragePrefab;

	[SerializeField]
	private VisualCarWheel wheelSkiFL;

	[SerializeField]
	private VisualCarWheel wheelSkiFR;

	[SerializeField]
	private VisualCarWheel wheelTreadFL;

	[SerializeField]
	private VisualCarWheel wheelTreadFR;

	[SerializeField]
	private VisualCarWheel wheelTreadRL;

	[SerializeField]
	private VisualCarWheel wheelTreadRR;

	[SerializeField]
	public CarSettings carSettings;

	[SerializeField]
	public int engineKW = 59;

	[SerializeField]
	public float idleFuelPerSec = 0.03f;

	[SerializeField]
	public float maxFuelPerSec = 0.15f;

	[SerializeField]
	public float airControlStability = 10f;

	[SerializeField]
	public float airControlPower = 40f;

	[SerializeField]
	public float badTerrainDrag = 1f;

	[SerializeField]
	public ProtectionProperties riderProtection;

	[SerializeField]
	public float hurtTriggerMinSpeed = 1f;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerFront;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerRear;

	[Header("Snowmobile Visuals")]
	public float minGroundFXSpeed;

	[SerializeField]
	private SnowmobileChassisVisuals chassisVisuals;

	[SerializeField]
	private VehicleLight[] lights;

	[SerializeField]
	private Transform steeringLeftIK;

	[SerializeField]
	private Transform steeringRightIK;

	[SerializeField]
	private Transform leftFootIK;

	[SerializeField]
	private Transform rightFootIK;

	[SerializeField]
	private Transform starterKey;

	[SerializeField]
	private Vector3 engineOffKeyRot;

	[SerializeField]
	private Vector3 engineOnKeyRot;

	[ServerVar(Help = "How long before a snowmobile loses all its health while outside")]
	public static float outsideDecayMinutes = 1440f;

	[ServerVar(Help = "Allow mounting as a passenger when there's no driver")]
	public static bool allowPassengerOnly = false;

	[ServerVar(Help = "If true, snowmobile goes fast on all terrain types")]
	public static bool allTerrain = false;

	private float _throttle;

	private float _brake;

	private float _mass = -1f;

	public const Flags Flag_Slowmode = Flags.Reserved8;

	private EntityRef<StorageContainer> itemStorageInstance;

	private float cachedFuelFraction;

	private const float FORCE_MULTIPLIER = 10f;

	private float _steer;

	public CarPhysics<Snowmobile> carPhysics;

	public VehicleTerrainHandler serverTerrainHandler;

	private CarWheel[] wheels;

	public TimeSince timeSinceLastUsed;

	private const float DECAY_TICK_TIME = 60f;

	public float prevTerrainModDrag;

	public TimeSince timeSinceTerrainModCheck;

	public float ThrottleInput
	{
		get
		{
			if (!engineController.IsOn)
			{
				return 0f;
			}
			return _throttle;
		}
		protected set
		{
			_throttle = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public float BrakeInput
	{
		get
		{
			return _brake;
		}
		protected set
		{
			_brake = Mathf.Clamp(value, 0f, 1f);
		}
	}

	public bool IsBraking => BrakeInput > 0f;

	public float SteerAngle
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.SteerAngle;
			}
			return 0f;
		}
	}

	public override float DriveWheelVelocity
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.DriveWheelVelocity;
			}
			return 0f;
		}
	}

	public float DriveWheelSlip
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.DriveWheelSlip;
			}
			return 0f;
		}
	}

	public float MaxSteerAngle => carSettings.maxSteerAngle;

	public bool InSlowMode
	{
		get
		{
			return HasFlag(Flags.Reserved8);
		}
		private set
		{
			if (InSlowMode != value)
			{
				SetFlag(Flags.Reserved8, value);
			}
		}
	}

	private float Mass
	{
		get
		{
			if (base.isServer)
			{
				return rigidBody.mass;
			}
			return _mass;
		}
	}

	public float SteerInput
	{
		get
		{
			return _steer;
		}
		protected set
		{
			_steer = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public VehicleTerrainHandler.Surface OnSurface
	{
		get
		{
			if (serverTerrainHandler == null)
			{
				return VehicleTerrainHandler.Surface.Default;
			}
			return serverTerrainHandler.OnSurface;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Snowmobile.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 924237371 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenItemStorage "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenItemStorage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(924237371u, "RPC_OpenItemStorage", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_OpenItemStorage(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_OpenItemStorage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.snowmobile != null)
		{
			itemStorageInstance.uid = info.msg.snowmobile.storageID;
			engineController.FuelSystem.SetInstanceID(info.msg.snowmobile.fuelStorageID);
			cachedFuelFraction = info.msg.snowmobile.fuelFraction;
		}
	}

	public float GetMaxDriveForce()
	{
		return (float)engineKW * 10f * GetPerformanceFraction();
	}

	public override float GetMaxForwardSpeed()
	{
		return GetMaxDriveForce() / Mass * 15f;
	}

	public override float GetThrottleInput()
	{
		return ThrottleInput;
	}

	public override float GetBrakeInput()
	{
		return BrakeInput;
	}

	public bool GetSteerSpeedMod(float speed)
	{
		return false;
	}

	public virtual float GetSteerMaxMult(float speed)
	{
		return 1f;
	}

	public float GetPerformanceFraction()
	{
		float num = Mathf.InverseLerp(0.25f, 0.5f, base.healthFraction);
		return Mathf.Lerp(0.5f, 1f, num);
	}

	public float GetFuelFraction()
	{
		if (base.isServer)
		{
			return engineController.FuelSystem.GetFuelFraction();
		}
		return cachedFuelFraction;
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		if (!PlayerIsMounted(player))
		{
			return !IsOn();
		}
		return true;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && GameInfo.HasAchievements && !old.HasFlag(Flags.On) && next.HasFlag(Flags.On))
		{
			BasePlayer driver = GetDriver();
			if ((Object)(object)driver != (Object)null && (Object)(object)driver.FindTrigger<TriggerSnowmobileAchievement>() != (Object)null)
			{
				driver.GiveAchievement("DRIVE_SNOWMOBILE");
			}
		}
	}

	private bool CanPlayerSeeMountPoint(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (!GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position, 0.25f, 2162688, (QueryTriggerInteraction)0))
		{
			return !GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position + Vector3.up * 0.5f, 0.25f, 2162688, (QueryTriggerInteraction)0);
		}
		return false;
	}

	public float GetSteerInput()
	{
		return SteerInput;
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		rigidBody.centerOfMass = centreOfMassTransform.localPosition;
		rigidBody.inertiaTensor = new Vector3(450f, 200f, 200f);
		carPhysics = new CarPhysics<Snowmobile>(this, ((Component)this).transform, rigidBody, carSettings);
		serverTerrainHandler = new VehicleTerrainHandler(this);
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.15f, 0.02f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)SnowmobileDecay, Random.Range(30f, 60f), 60f, 6f);
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Snowmobile.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			float speed = GetSpeed();
			carPhysics.FixedUpdate(Time.fixedDeltaTime, speed);
			serverTerrainHandler.FixedUpdate();
			if (IsOn())
			{
				float fuelPerSecond = Mathf.Lerp(idleFuelPerSec, maxFuelPerSec, Mathf.Abs(ThrottleInput));
				engineController.TickFuel(fuelPerSecond);
			}
			engineController.CheckEngineState();
			RaycastHit val2 = default(RaycastHit);
			if (!carPhysics.IsGrounded() && Physics.Raycast(((Component)this).transform.position, Vector3.down, ref val2, 10f, 1218511105, (QueryTriggerInteraction)1))
			{
				Vector3 normal = ((RaycastHit)(ref val2)).normal;
				Vector3 right = ((Component)this).transform.right;
				right.y = 0f;
				normal = Vector3.ProjectOnPlane(normal, right);
				float num = Vector3.Angle(normal, Vector3.up);
				Vector3 angularVelocity = rigidBody.angularVelocity;
				float num2 = ((Vector3)(ref angularVelocity)).magnitude * 57.29578f * airControlStability / airControlPower;
				if (num <= 45f)
				{
					Vector3 val3 = Vector3.Cross(Quaternion.AngleAxis(num2, rigidBody.angularVelocity) * ((Component)this).transform.up, normal) * airControlPower * airControlPower;
					rigidBody.AddTorque(val3);
				}
			}
			((Component)hurtTriggerFront).gameObject.SetActive(speed > hurtTriggerMinSpeed);
			((Component)hurtTriggerRear).gameObject.SetActive(speed < 0f - hurtTriggerMinSpeed);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!IsDriver(player))
		{
			return;
		}
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		if (inputState.IsDown(BUTTON.FIRE_THIRD))
		{
			SteerInput += inputState.MouseDelta().x * 0.1f;
		}
		else
		{
			SteerInput = 0f;
			if (inputState.IsDown(BUTTON.LEFT))
			{
				SteerInput = -1f;
			}
			else if (inputState.IsDown(BUTTON.RIGHT))
			{
				SteerInput = 1f;
			}
		}
		float num = 0f;
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			num = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			num = -1f;
		}
		ThrottleInput = 0f;
		BrakeInput = 0f;
		if (GetSpeed() > 3f && num < -0.1f)
		{
			ThrottleInput = 0f;
			BrakeInput = 0f - num;
		}
		else
		{
			ThrottleInput = num;
			BrakeInput = 0f;
		}
		if (engineController.IsOff && ((inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD)) || (inputState.IsDown(BUTTON.BACKWARD) && !inputState.WasDown(BUTTON.BACKWARD))))
		{
			engineController.TryStartEngine(player);
		}
	}

	public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
	{
		float maxDriveForce = GetMaxDriveForce();
		float num = Mathf.Lerp(0.3f, 0.75f, GetPerformanceFraction());
		float num2 = MathEx.BiasedLerp(1f - absSpeed / topSpeed, num);
		return maxDriveForce * num2;
	}

	public override float GetModifiedDrag()
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		float num = base.GetModifiedDrag();
		if (!allTerrain)
		{
			VehicleTerrainHandler.Surface onSurface = serverTerrainHandler.OnSurface;
			if (serverTerrainHandler.IsGrounded && onSurface != VehicleTerrainHandler.Surface.Frictionless && onSurface != VehicleTerrainHandler.Surface.Sand && onSurface != VehicleTerrainHandler.Surface.Snow && onSurface != VehicleTerrainHandler.Surface.Ice)
			{
				float num2 = Mathf.Max(num, badTerrainDrag);
				num = (prevTerrainModDrag = ((!(num2 <= prevTerrainModDrag)) ? Mathf.MoveTowards(prevTerrainModDrag, num2, 0.33f * TimeSince.op_Implicit(timeSinceTerrainModCheck)) : prevTerrainModDrag));
			}
			else
			{
				prevTerrainModDrag = 0f;
			}
		}
		timeSinceTerrainModCheck = TimeSince.op_Implicit(0f);
		InSlowMode = num >= badTerrainDrag;
		return num;
	}

	public override float MaxVelocity()
	{
		return Mathf.Max(GetMaxForwardSpeed() * 1.3f, 30f);
	}

	public CarWheel[] GetWheels()
	{
		if (wheels == null)
		{
			wheels = new CarWheel[6] { wheelSkiFL, wheelSkiFR, wheelTreadFL, wheelTreadFR, wheelTreadRL, wheelTreadRR };
		}
		return wheels;
	}

	public float GetWheelsMidPos()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		return (((Component)wheelSkiFL.wheelCollider).transform.localPosition.z - ((Component)wheelTreadRL.wheelCollider).transform.localPosition.z) * 0.5f;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.snowmobile = Pool.Get<Snowmobile>();
		info.msg.snowmobile.steerInput = SteerInput;
		info.msg.snowmobile.driveWheelVel = DriveWheelVelocity;
		info.msg.snowmobile.throttleInput = ThrottleInput;
		info.msg.snowmobile.brakeInput = BrakeInput;
		info.msg.snowmobile.storageID = itemStorageInstance.uid;
		info.msg.snowmobile.fuelStorageID = GetFuelSystem().GetInstanceID();
		info.msg.snowmobile.fuelFraction = GetFuelFraction();
	}

	public override int StartingFuelUnits()
	{
		return 0;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned && child.prefabID == itemStoragePrefab.GetEntity().prefabID)
		{
			itemStorageInstance.Set((StorageContainer)child);
		}
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot)
		{
			StorageContainer storageContainer = itemStorageInstance.Get(base.isServer);
			if ((Object)(object)storageContainer != (Object)null && storageContainer.IsValid())
			{
				storageContainer.DropItems();
			}
		}
		base.DoServerDestroy();
	}

	public override bool MeetsEngineRequirements()
	{
		return HasDriver();
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (allowPassengerOnly)
		{
			base.AttemptMount(player, doMountChecks);
		}
		else if (MountEligable(player) && CanPlayerSeeMountPoint(player))
		{
			BaseMountable baseMountable = ((HasDriver() || player.IsRestrained) ? GetIdealMountPointFor(player) : mountPoints[0].mountable);
			if ((Object)(object)baseMountable != (Object)null)
			{
				baseMountable.AttemptMount(player, doMountChecks);
			}
			if (PlayerIsMounted(player))
			{
				PlayerMounted(player, baseMountable);
			}
		}
	}

	public void SnowmobileDecay()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		if (!IsDead() && !(TimeSince.op_Implicit(timeSinceLastUsed) < 2700f))
		{
			float num = (IsOutside() ? outsideDecayMinutes : float.PositiveInfinity);
			if (!float.IsPositiveInfinity(num))
			{
				float num2 = 1f / num;
				Hurt(MaxHealth() * num2, DamageType.Decay, this, useProtection: false);
			}
		}
	}

	public StorageContainer GetItemContainer()
	{
		BaseEntity baseEntity = itemStorageInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as StorageContainer;
		}
		return null;
	}

	private void UpdateClients()
	{
		if (HasDriver())
		{
			byte num = (byte)((ThrottleInput + 1f) * 7f);
			byte b = (byte)(BrakeInput * 15f);
			byte arg = (byte)(num + (b << 4));
			ClientRPC(RpcTarget.NetworkGroup("SnowmobileUpdate"), SteerInput, arg, DriveWheelVelocity, GetFuelFraction());
		}
	}

	public override void OnEngineStartFailed()
	{
		ClientRPC(RpcTarget.NetworkGroup("EngineStartFailed"));
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		riderProtection.Scale(info.damageTypes);
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player) && IsDriver(player))
		{
			GetFuelSystem().LootFuel(player);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_OpenItemStorage(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player))
		{
			StorageContainer itemContainer = GetItemContainer();
			if ((Object)(object)itemContainer != (Object)null)
			{
				itemContainer.PlayerOpenLoot(player);
			}
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SpinnerWheel : Signage
{
	public Transform wheel;

	public float velocity;

	public Quaternion targetRotation = Quaternion.identity;

	[Header("Sound")]
	public SoundDefinition spinLoopSoundDef;

	public SoundDefinition spinStartSoundDef;

	public SoundDefinition spinAccentSoundDef;

	public SoundDefinition spinStopSoundDef;

	public float minTimeBetweenSpinAccentSounds = 0.3f;

	public float spinAccentAngleDelta = 180f;

	private Sound spinSound;

	private SoundModulation.Modulator spinSoundGain;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SpinnerWheel.OnRpcMessage", 0);
		try
		{
			if (rpc == 3019675107u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_AnyoneSpin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_AnyoneSpin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3019675107u, "RPC_AnyoneSpin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_AnyoneSpin(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_AnyoneSpin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1455840454 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Spin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Spin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1455840454u, "RPC_Spin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							RPC_Spin(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Spin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual bool AllowPlayerSpins()
	{
		return true;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.spinnerWheel = Pool.Get<SpinnerWheel>();
		SpinnerWheel spinnerWheel = info.msg.spinnerWheel;
		Quaternion localRotation = wheel.localRotation;
		spinnerWheel.spin = ((Quaternion)(ref localRotation)).eulerAngles;
	}

	public override void Load(LoadInfo info)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.spinnerWheel != null)
		{
			Quaternion localRotation = Quaternion.Euler(info.msg.spinnerWheel.spin);
			if (base.isServer && info.fromDisk)
			{
				localRotation = Quaternion.identity;
			}
			if (base.isServer)
			{
				((Component)wheel).transform.localRotation = localRotation;
			}
		}
	}

	public virtual float GetMaxSpinSpeed()
	{
		return 720f;
	}

	public virtual void Update_Server()
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (velocity > 0f)
		{
			float num = Mathf.Clamp(GetMaxSpinSpeed() * velocity, 0f, GetMaxSpinSpeed());
			velocity -= Time.deltaTime * Mathf.Clamp(velocity / 2f, 0.1f, 1f);
			if (velocity < 0f)
			{
				velocity = 0f;
				ToggleChildEntityColliders(state: true);
			}
			wheel.Rotate(Vector3.up, num * Time.deltaTime, (Space)1);
			SendNetworkUpdate();
		}
	}

	public void Update_Client()
	{
	}

	public void Update()
	{
		if (base.isClient)
		{
			Update_Client();
		}
		if (base.isServer)
		{
			Update_Server();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Spin(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && AllowPlayerSpins() && (AnyoneSpin() || rpc.player.CanBuild()) && Interface.CallHook("OnSpinWheel", (object)rpc.player, (object)this) == null && !(velocity > 15f))
		{
			velocity += Random.Range(4f, 7f);
			ToggleChildEntityColliders(state: false);
		}
	}

	private void ToggleChildEntityColliders(bool state)
	{
		foreach (BaseEntity child in children)
		{
			if (child is DroppedItem droppedItem && (Object)(object)droppedItem.childCollider != (Object)null)
			{
				droppedItem.childCollider.enabled = state;
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_AnyoneSpin(RPCMessage rpc)
	{
		if (rpc.player.CanInteract())
		{
			SetFlag(Flags.Reserved3, rpc.read.Bit());
		}
	}

	public bool AnyoneSpin()
	{
		return HasFlag(Flags.Reserved3);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class SpinUpWeapon : BaseProjectile, ITurretNotify
{
	public float timeBetweenSpinToggle = 1f;

	public float spinUpTime = 1f;

	public GameObjectRef bulletEffect;

	public float projectileThicknessOverride = 0.5f;

	public bool showSpinProgress = true;

	public float spinningMoveSpeedScale = 0.7f;

	public float conditionLossPerSecondSpinning = 1f;

	public ItemModWearable BackpackWearable;

	public const Flags FullySpunFlag = Flags.Reserved10;

	public const Flags SpinningFlag = Flags.Reserved11;

	public const Flags ShootingFlag = Flags.Reserved12;

	private const float bulletSpeed = 375f;

	private float lastSpinToggleTime = float.NegativeInfinity;

	public override ItemModWearable WearableWhileEquipped
	{
		get
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null && ownerPlayer.inventory.HasBackpackItem())
			{
				return null;
			}
			return BackpackWearable;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SpinUpWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 2014484270 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetSpinButton "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetSpinButton", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2014484270u, "Server_SetSpinButton", this, player, 8uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(2014484270u, "Server_SetSpinButton", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_SetSpinButton(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_SetSpinButton");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override float GetOverrideProjectileThickness(Projectile projectile)
	{
		return projectileThicknessOverride;
	}

	public bool IsSpinning()
	{
		return HasFlag(Flags.Reserved11);
	}

	public bool IsFullySpun()
	{
		return HasFlag(Flags.Reserved10);
	}

	public override void ServerReload()
	{
		SetFlag(Flags.Reserved12, b: false);
		base.ServerReload();
	}

	public override void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
		if (!ServerIsReloading())
		{
			SetFlag(Flags.Reserved12, b: true);
			((FacepunchBehaviour)this).Invoke((Action)StopMainTrigger, repeatDelay * 1.1f);
		}
		base.ServerUse(damageModifier, speedModifier, originOverride, useBulletThickness);
	}

	public override void SetGenericVisible(bool visible)
	{
		base.SetGenericVisible(visible);
		SetFlag(Flags.Reserved11, visible);
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null && ownerPlayer.IsNpc)
		{
			SetFlag(Flags.Reserved11, !IsDisabled());
		}
		else
		{
			SetFlag(Flags.Reserved11, b: false);
			SetFlag(Flags.Reserved10, b: false);
			lastSpinToggleTime = float.NegativeInfinity;
		}
		if (IsDisabled())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateConditionLoss);
			((FacepunchBehaviour)this).CancelInvoke((Action)SetFullySpun);
		}
		else
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateConditionLoss, 0f, 1f);
		}
	}

	public void UpdateConditionLoss()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!((Object)(object)ownerPlayer == (Object)null) && !ownerPlayer.IsNpc && IsSpinning())
		{
			GetOwnerItem()?.LoseCondition(conditionLossPerSecondSpinning);
		}
	}

	public void FireFakeBulletServer(float aimconeToUse)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		bool flag = (Object)(object)ownerPlayer != (Object)null;
		Vector3 val = (flag ? ownerPlayer.eyes.BodyForward() : MuzzlePoint.forward);
		Vector3 val2 = (flag ? ownerPlayer.eyes.position : MuzzlePoint.position);
		Vector3 inputVec = val;
		inputVec = AimConeUtil.GetModifiedAimConeDirection(aimconeToUse, inputVec);
		List<Connection> list = Pool.Get<List<Connection>>();
		foreach (Connection subscriber in net.group.subscribers)
		{
			BasePlayer basePlayer = subscriber.player as BasePlayer;
			if (!((Object)(object)basePlayer == (Object)null) && !ShouldNetworkTo(basePlayer))
			{
				list.Add(subscriber);
			}
		}
		if (list.Count > 0)
		{
			CreateProjectileEffectClientside(bulletEffect.resourcePath, val2 + inputVec * 2f, inputVec * 375f, 0, flag ? ownerPlayer.net.connection : null, IsSilenced(), forceClientsideEffects: true, list);
		}
		Pool.FreeUnmanaged<Connection>(ref list);
	}

	public void StopMainTrigger()
	{
		SetFlag(Flags.Reserved12, b: false);
	}

	public override void DidAttackServerside()
	{
		base.DidAttackServerside();
		SetFlag(Flags.Reserved12, b: true);
		((FacepunchBehaviour)this).Invoke((Action)StopMainTrigger, repeatDelay * 1.1f);
		if (ServerOcclusion.OcclusionEnabled)
		{
			DoFakeBullets();
		}
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(8uL)]
	[RPC_Server]
	private void Server_SetSpinButton(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (!(Time.realtimeSinceStartup < lastSpinToggleTime + 1f))
		{
			SetFlag(Flags.Reserved11, flag);
			((FacepunchBehaviour)this).CancelInvoke((Action)SetFullySpun);
			if (flag)
			{
				((FacepunchBehaviour)this).Invoke((Action)SetFullySpun, spinUpTime);
			}
			else
			{
				SetFlag(Flags.Reserved10, b: false);
			}
			lastSpinToggleTime = Time.realtimeSinceStartup;
		}
	}

	public void SetFullySpun()
	{
		SetFlag(Flags.Reserved10, b: true);
	}

	public void WarmupTick(bool wantsShoot)
	{
		if (wantsShoot)
		{
			SetFlag(Flags.Reserved11, b: true);
			if (!((FacepunchBehaviour)this).IsInvoking((Action)SetFullySpun))
			{
				((FacepunchBehaviour)this).Invoke((Action)SetFullySpun, spinUpTime);
			}
			lastSpinToggleTime = Time.realtimeSinceStartup;
		}
		else if (Time.realtimeSinceStartup > lastSpinToggleTime + 10f)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SetFullySpun);
			SetFlag(Flags.Reserved11, b: false);
			SetFlag(Flags.Reserved10, b: false);
		}
	}

	public bool CanShoot()
	{
		return IsFullySpun();
	}

	public void OnAddedRemovedToTurret(bool added)
	{
		SetFlag(Flags.Reserved11, b: false);
		SetFlag(Flags.Reserved10, b: false);
		if (added)
		{
			lastSpinToggleTime = float.NegativeInfinity;
			return;
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)UpdateConditionLoss);
		((FacepunchBehaviour)this).CancelInvoke((Action)SetFullySpun);
	}

	private void DoFakeBullets()
	{
		float num = repeatDelay / 4f;
		if (!((FacepunchBehaviour)this).IsInvoking((Action)FakeBullet1))
		{
			((FacepunchBehaviour)this).Invoke((Action)FakeBullet1, num);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)FakeBullet2))
		{
			((FacepunchBehaviour)this).Invoke((Action)FakeBullet2, num * 2f);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)FakeBullet3))
		{
			((FacepunchBehaviour)this).Invoke((Action)FakeBullet3, num * 3f);
		}
	}

	private void FakeBullet()
	{
		if (base.isServer)
		{
			FireFakeBulletServer(aimCone * 3f);
		}
	}

	private void FakeBullet1()
	{
		FakeBullet();
	}

	private void FakeBullet2()
	{
		FakeBullet();
	}

	private void FakeBullet3()
	{
		FakeBullet();
	}

	private void CancelFakeBullets()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)FakeBullet1);
		((FacepunchBehaviour)this).CancelInvoke((Action)FakeBullet2);
		((FacepunchBehaviour)this).CancelInvoke((Action)FakeBullet3);
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class SpookySpeaker : IOEntity
{
	public SoundPlayer soundPlayer;

	public float soundSpacing = 12f;

	public float soundSpacingRand = 5f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SpookySpeaker.OnRpcMessage", 0);
		try
		{
			if (rpc == 2523893445u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetWantsOn "));
				}
				TimeWarning val2 = TimeWarning.New("SetWantsOn", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2523893445u, "SetWantsOn", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage wantsOn = rPCMessage;
							SetWantsOn(wantsOn);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SetWantsOn");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		UpdateInvokes();
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		if (inputSlot == 1)
		{
			SetTargetState(state: false);
		}
		if (inputSlot == 0)
		{
			SetTargetState(state: true);
		}
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	private void SetTargetState(bool state)
	{
		SetFlag(Flags.On, state);
		UpdateInvokes();
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SetWantsOn(RPCMessage msg)
	{
		bool targetState = msg.read.Bit();
		SetTargetState(targetState);
	}

	public void UpdateInvokes()
	{
		if (IsOn())
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)SendPlaySound, soundSpacing, soundSpacing, soundSpacingRand);
			((FacepunchBehaviour)this).Invoke((Action)DelayedOff, 7200f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SendPlaySound);
			((FacepunchBehaviour)this).CancelInvoke((Action)DelayedOff);
		}
	}

	public void SendPlaySound()
	{
		ClientRPC(RpcTarget.NetworkGroup("PlaySpookySound"));
	}

	public void DelayedOff()
	{
		SetFlag(Flags.On, b: false);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

public class SprayCan : HeldEntity
{
	private enum SprayFailReason
	{
		None,
		MountedBlocked,
		IOConnection,
		LineOfSight,
		SkinNotOwned,
		InvalidItem
	}

	private struct ContainerSet
	{
		public int ContainerIndex;

		public uint PrefabId;
	}

	public struct IOPreserveInfo
	{
		public IOEntity connectedTo;

		public int connectedToSlot;

		public Vector3[] linePoints;

		public float[] slackLevels;

		public IOEntity.LineAnchor[] lineAnchors;

		public Vector3 worldSpaceLineEndRotation;

		public Vector3 originPosition;

		public Vector3 originRotation;

		public WireTool.WireColour wireColour;
	}

	private struct CodeLockPreserveInfo
	{
		public string code;

		public string guestCode;

		public bool isLocked;

		public List<ulong> whitelistPlayers;

		public List<ulong> guestPlayers;
	}

	private struct OtherEntityPreserveInfo
	{
		public IOPreserveInfo info;

		public IOEntity connectedEntity;

		public int index;

		public bool isOutput;
	}

	public struct ChildPreserveInfo
	{
		public BaseEntity TargetEntity;

		public uint TargetBone;

		public Vector3 LocalPosition;

		public Quaternion LocalRotation;
	}

	public const float MaxFreeSprayDistanceFromStart = 10f;

	public const float MaxFreeSprayStartingDistance = 3f;

	private SprayCanSpray_Freehand paintingLine;

	public const Flags IsFreeSpraying = Flags.Reserved1;

	public SoundDefinition SpraySound;

	public GameObjectRef SkinSelectPanel;

	public float SprayCooldown = 2f;

	public float ConditionLossPerSpray = 10f;

	public float ConditionLossPerReskin = 10f;

	public GameObjectRef LinePrefab;

	public Color[] SprayColours = (Color[])(object)new Color[0];

	public float[] SprayWidths = new float[3] { 0.1f, 0.2f, 0.3f };

	public ParticleSystem worldSpaceSprayFx;

	public GameObjectRef ReskinEffect;

	public ItemDefinition SprayDecalItem;

	public GameObjectRef SprayDecalEntityRef;

	public SteamInventoryItem FreeSprayUnlockItem;

	public MinMaxGradient DecalSprayGradient;

	public SoundDefinition SprayLoopDef;

	public static Phrase FreeSprayNamePhrase = new Phrase("freespray_radial", "Free Spray");

	public static Phrase FreeSprayDescPhrase = new Phrase("freespray_radial_desc", "Spray shapes freely with various colors");

	public static Phrase BuildingSkinColourPhrase = new Phrase("buildingskin_colour", "Set colour");

	public static Phrase BuildingSkinColourDescPhrase = new Phrase("buildingskin_colour_desc", "Set the block to the highlighted colour");

	public static readonly Phrase DoorMustBeClosed = new Phrase("error_doormustbeclosed", "Door must be closed");

	public static readonly Phrase NeedDoorAccess = new Phrase("error_needdooraccess", "Need door access");

	public static readonly Phrase CannotReskinThatDoor = new Phrase("error_cannotreskindoor", "Cannot reskin that door");

	public static readonly Phrase RecentlyDamaged = new Phrase("error_reskin_recentlydamaged", "Cannot reskin an object that was recently damaged");

	public static readonly Phrase ExplosivesActive = new Phrase("error_explosivesactive", "Cannot reskin an object with explosives attached");

	public static readonly Phrase PlayerInAir = new Phrase("error_playerinair", "You must be on the ground");

	public static readonly Phrase BlockedByPlayer = new Phrase("error_blockedbyplayer_reskin", "Blocked by intersecting player");

	public static readonly Phrase BlockedBySomething = new Phrase("error_blockedbysomething", "Blocked by something");

	public static readonly Phrase PlayerIsMounted = new Phrase("error_playerismounted", "Player {0} is mounted");

	[FormerlySerializedAs("ShippingCOntainerColourLookup")]
	public ConstructionSkin_ColourLookup ShippingContainerColourLookup;

	public const string ENEMY_BASE_STAT = "sprayed_enemy_base";

	private Phrase lastSprayError;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SprayCan.OnRpcMessage", 0);
		try
		{
			if (rpc == 3490735573u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BeginFreehandSpray "));
				}
				TimeWarning val2 = TimeWarning.New("BeginFreehandSpray", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3490735573u, "BeginFreehandSpray", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							BeginFreehandSpray(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in BeginFreehandSpray");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 151738090 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ChangeItemSkin "));
				}
				TimeWarning val2 = TimeWarning.New("ChangeItemSkin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(151738090u, "ChangeItemSkin", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(151738090u, "ChangeItemSkin", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ChangeItemSkin(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ChangeItemSkin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 688080035 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ChangeWallpaper "));
				}
				TimeWarning val2 = TimeWarning.New("ChangeWallpaper", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(688080035u, "ChangeWallpaper", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(688080035u, "ChangeWallpaper", this, player))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(688080035u, "ChangeWallpaper", this, player, 5f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							ChangeWallpaper(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in ChangeWallpaper");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 396000799 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - CreateSpray "));
				}
				TimeWarning val2 = TimeWarning.New("CreateSpray", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(396000799u, "CreateSpray", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							CreateSpray(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in CreateSpray");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 14517645 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetBlockColourId "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetBlockColourId", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(14517645u, "Server_SetBlockColourId", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(14517645u, "Server_SetBlockColourId", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							Server_SetBlockColourId(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in Server_SetBlockColourId");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void BeginFreehandSpray(RPCMessage msg)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		if (!IsBusy() && CanSprayFreehand(msg.player))
		{
			Vector3 val = msg.read.Vector3();
			Vector3 atNormal = msg.read.Vector3();
			int num = msg.read.Int32();
			int num2 = msg.read.Int32();
			if (num >= 0 && num < SprayColours.Length && num2 >= 0 && num2 < SprayWidths.Length && !(Vector3.Distance(val, ((Component)GetOwnerPlayer()).transform.position) > 3f))
			{
				SprayCanSpray_Freehand sprayCanSpray_Freehand = GameManager.server.CreateEntity(LinePrefab.resourcePath, val, Quaternion.identity) as SprayCanSpray_Freehand;
				sprayCanSpray_Freehand.AddInitialPoint(atNormal);
				sprayCanSpray_Freehand.SetColour(SprayColours[num]);
				sprayCanSpray_Freehand.SetWidth(SprayWidths[num2]);
				sprayCanSpray_Freehand.EnableChanges(msg.player);
				sprayCanSpray_Freehand.Spawn();
				paintingLine = sprayCanSpray_Freehand;
				ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), num);
				SetFlag(Flags.Busy, b: true);
				SetFlag(Flags.Reserved1, b: true);
				CheckAchievementPosition(val);
			}
		}
	}

	public void ClearPaintingLine(bool allowNewSprayImmediately)
	{
		paintingLine = null;
		if (!base.UsingInfiniteAmmoCheat)
		{
			LoseCondition(ConditionLossPerSpray);
		}
		if (allowNewSprayImmediately)
		{
			ClearBusy();
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)ClearBusy, 0.1f);
		}
	}

	public bool CanSprayFreehand(BasePlayer player)
	{
		if (player.UnlockAllSkins)
		{
			return true;
		}
		if ((Object)(object)FreeSprayUnlockItem != (Object)null)
		{
			if (!player.blueprints.steamInventory.HasItem(FreeSprayUnlockItem.id))
			{
				return FreeSprayUnlockItem.HasUnlocked(player.userID);
			}
			return true;
		}
		return false;
	}

	private bool IsSprayBlockedByTrigger(Vector3 pos)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return true;
		}
		TriggerNoSpray triggerNoSpray = ownerPlayer.FindTrigger<TriggerNoSpray>();
		if ((Object)(object)triggerNoSpray == (Object)null)
		{
			return false;
		}
		return !triggerNoSpray.IsPositionValid(pos);
	}

	private bool ValidateEntityAndSkin(BasePlayer player, BaseNetworkable targetEnt, int targetSkin)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		if (IsBusy())
		{
			return false;
		}
		if ((Object)(object)player == (Object)null || !player.CanBuild())
		{
			return false;
		}
		if (!player.IsOnGround())
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInAir, false);
			return false;
		}
		bool unlockAllSkins = player.UnlockAllSkins;
		if (targetSkin != 0 && !unlockAllSkins && !player.blueprints.CheckSkinOwnership(targetSkin, player.userID))
		{
			SprayFailResponse(SprayFailReason.SkinNotOwned);
			return false;
		}
		if ((Object)(object)targetEnt != (Object)null && targetEnt is BaseEntity baseEntity)
		{
			OBB val = baseEntity.WorldSpaceBounds();
			Vector3 position = ((OBB)(ref val)).ClosestPoint(player.eyes.position);
			if (!player.IsVisible(position, 3f))
			{
				SprayFailResponse(SprayFailReason.LineOfSight);
				return false;
			}
			if (targetEnt is Door door)
			{
				if (!door.GetPlayerLockPermission(player))
				{
					player.ShowToast(GameTip.Styles.Error, NeedDoorAccess, false);
					return false;
				}
				if (door.IsOpen())
				{
					player.ShowToast(GameTip.Styles.Error, DoorMustBeClosed, false);
					return false;
				}
				if ((Object)(object)door.GetParentEntity() != (Object)null && door.GetParentEntity() is HotAirBalloonArmor)
				{
					player.ShowToast(GameTip.Styles.Error, CannotReskinThatDoor, false);
					return false;
				}
			}
			if (targetEnt is BaseCombatEntity { SecondsSinceAttacked: <30f } baseCombatEntity)
			{
				player.ShowToast(GameTip.Styles.Error, RecentlyDamaged, false, (30f - baseCombatEntity.SecondsSinceAttacked).ToString("N0"));
				return false;
			}
			foreach (BaseEntity child in targetEnt.children)
			{
				if (child is TimedExplosive)
				{
					player.ShowToast(GameTip.Styles.Error, ExplosivesActive, false);
					return false;
				}
			}
			if (targetEnt is SimpleBuildingBlock || targetEnt is Gate)
			{
				PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					Vis.Entities(baseEntity.WorldSpaceBounds(), (List<BaseEntity>)(object)val2, -2145386240, (QueryTriggerInteraction)2);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
					{
						if (!((Object)(object)item == (Object)null) && !item.isClient && !((Object)(object)item == (Object)(object)baseEntity) && !(item is BuildingBlock) && !(item is SimpleBuildingBlock) && !(item is Door) && !(item is BaseOven) && !(item is Barricade))
						{
							player.ShowBlockedByEntityToast(item, BlockedBySomething);
							return false;
						}
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
		}
		if ((Object)(object)targetEnt != (Object)null && targetEnt is BaseLock baseLock)
		{
			return baseLock.GetPlayerLockPermission(player);
		}
		return true;
	}

	private bool ValidateWallpaperReskin(BasePlayer player, BuildingBlock block, int side, int targetSkin)
	{
		if ((Object)(object)player == (Object)null || !player.CanBuild())
		{
			return false;
		}
		if (!player.IsOnGround())
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInAir, false);
			return false;
		}
		bool unlockAllSkins = player.UnlockAllSkins;
		if (targetSkin != 0 && !unlockAllSkins && !player.blueprints.CheckSkinOwnership(targetSkin, player.userID))
		{
			SprayFailResponse(SprayFailReason.SkinNotOwned);
			return false;
		}
		if (!block.HasWallpaper(side))
		{
			return false;
		}
		if (!block.CanSeeWallpaperSocket(player, side))
		{
			return false;
		}
		return true;
	}

	private void SprayFailResponse(SprayFailReason reason)
	{
		ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 0, (int)reason);
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(2uL)]
	private void ChangeItemSkin(RPCMessage msg)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b39: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0413: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_0426: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_066a: Unknown result type (might be due to invalid IL or missing references)
		//IL_066c: Unknown result type (might be due to invalid IL or missing references)
		//IL_065f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0686: Unknown result type (might be due to invalid IL or missing references)
		//IL_068b: Unknown result type (might be due to invalid IL or missing references)
		//IL_068d: Unknown result type (might be due to invalid IL or missing references)
		//IL_067b: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a87: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a9f: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId uid = msg.read.EntityID();
		int targetSkin = msg.read.Int32();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		if (!ValidateEntityAndSkin(msg.player, baseNetworkable, targetSkin))
		{
			return;
		}
		if ((Object)(object)baseNetworkable != (Object)null)
		{
			BaseEntity baseEntity2 = baseNetworkable as BaseEntity;
			if (baseEntity2 != null)
			{
				if (!GetItemDefinitionForEntity(baseEntity2, out var def, useRedirect: false))
				{
					FailResponse(SprayFailReason.InvalidItem);
					return;
				}
				ItemDefinition itemDefinition = null;
				ulong num = ItemDefinition.FindSkin(((Object)(object)def.isRedirectOf != (Object)null) ? def.isRedirectOf.itemid : def.itemid, targetSkin);
				ItemSkinDirectory.Skin skin = (((Object)(object)def.isRedirectOf != (Object)null) ? def.isRedirectOf : def).skins.FirstOrDefault((ItemSkinDirectory.Skin x) => x.id == targetSkin);
				if (Interface.CallHook("OnEntityReskin", (object)baseEntity2, (object)skin, (object)msg.player) != null)
				{
					return;
				}
				if ((Object)(object)skin.invItem != (Object)null && skin.invItem is ItemSkin itemSkin)
				{
					if ((Object)(object)itemSkin.Redirect != (Object)null)
					{
						itemDefinition = itemSkin.Redirect;
					}
					else if (Object.op_Implicit((Object)(object)def) && (Object)(object)def.isRedirectOf != (Object)null)
					{
						itemDefinition = def.isRedirectOf;
					}
				}
				else if ((Object)(object)def.isRedirectOf != (Object)null || (Object.op_Implicit((Object)(object)def) && (Object)(object)def.isRedirectOf != (Object)null))
				{
					itemDefinition = def.isRedirectOf;
				}
				if ((Object)(object)itemDefinition == (Object)null)
				{
					baseEntity2.skinID = num;
					baseEntity2.SendNetworkUpdate();
					Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);
				}
				else
				{
					if (!CanEntityBeRespawned(baseEntity2, out var reason2, out var culpritPlayer))
					{
						if (reason2 == SprayFailReason.MountedBlocked)
						{
							lastSprayError = Phrase.op_Implicit(string.Format(PlayerIsMounted.translated, NameHelper.GetPlayerNameStreamSafe(msg.player, culpritPlayer)));
							msg.player.ShowToast(GameTip.Styles.Error, lastSprayError, false);
						}
						FailResponse(reason2);
						return;
					}
					if (!GetEntityPrefabPath(itemDefinition, out var resourcePath))
					{
						Debug.LogWarning((object)("Cannot find resource path of redirect entity to spawn! " + ((Object)((Component)itemDefinition).gameObject).name));
						FailResponse(SprayFailReason.InvalidItem);
						return;
					}
					if (SimpleUpgrade.IsUpgradeBlocked(baseEntity2, itemDefinition, msg.player))
					{
						msg.player.ShowToast(GameTip.Styles.Error, BlockedByPlayer, false);
						return;
					}
					CodeLockPreserveInfo codeLockPreserveInfo = default(CodeLockPreserveInfo);
					if (baseEntity2 is CodeLock codeLock)
					{
						codeLockPreserveInfo.code = codeLock.code;
						codeLockPreserveInfo.guestCode = codeLock.guestCode;
						codeLockPreserveInfo.isLocked = codeLock.IsLocked();
						codeLockPreserveInfo.whitelistPlayers = Pool.Get<List<ulong>>();
						codeLockPreserveInfo.guestPlayers = Pool.Get<List<ulong>>();
						codeLockPreserveInfo.whitelistPlayers.AddRange(codeLock.whitelistPlayers);
						codeLockPreserveInfo.guestPlayers.AddRange(codeLock.guestPlayers);
					}
					Vector3 localPosition = ((Component)baseEntity2).transform.localPosition;
					Quaternion localRotation = ((Component)baseEntity2).transform.localRotation;
					BaseEntity baseEntity3 = baseEntity2.GetParentEntity();
					float health = baseEntity2.Health();
					EntityRef[] slots = baseEntity2.GetSlots();
					ulong ownerID = baseEntity2.OwnerID;
					float lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);
					int soilSaturation = ((baseEntity2 is PlanterBox planterBox) ? planterBox.soilSaturation : 0);
					bool flag = baseEntity2 is DecayEntity decayEntity && decayEntity.HasFlag(Flags.Reserved2);
					HashSet<PlayerNameID> hashSet = null;
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge)
					{
						hashSet = new HashSet<PlayerNameID>(buildingPrivlidge.authorizedPlayers);
					}
					bool flag2 = baseEntity2 is Door || baseEntity2 is BuildingPrivlidge || baseEntity2 is BoxStorage || baseEntity2 is PlanterBox;
					Dictionary<ContainerSet, List<Item>> dictionary2 = new Dictionary<ContainerSet, List<Item>>();
					SaveEntityStorage(baseEntity2, dictionary2, 0);
					List<ChildPreserveInfo> list = Pool.Get<List<ChildPreserveInfo>>();
					if (flag2)
					{
						foreach (BaseEntity child in baseEntity2.children)
						{
							list.Add(new ChildPreserveInfo
							{
								TargetEntity = child,
								TargetBone = child.parentBone,
								LocalPosition = ((Component)child).transform.localPosition,
								LocalRotation = ((Component)child).transform.localRotation
							});
						}
						foreach (ChildPreserveInfo item in list)
						{
							item.TargetEntity.SetParent(null, worldPositionStays: true);
						}
					}
					else
					{
						for (int i = 0; i < baseEntity2.children.Count; i++)
						{
							SaveEntityStorage(baseEntity2.children[i], dictionary2, -1);
						}
					}
					IOPreserveInfo[] array = null;
					IOPreserveInfo[] array2 = null;
					List<OtherEntityPreserveInfo> list2 = new List<OtherEntityPreserveInfo>();
					if (baseEntity2 is IOEntity iOEntity)
					{
						array = new IOPreserveInfo[iOEntity.outputs.Length];
						for (int j = 0; j < iOEntity.outputs.Length; j++)
						{
							IOEntity.IOSlot iOSlot = iOEntity.outputs[j];
							IOEntity iOEntity2 = iOSlot.connectedTo.Get();
							if ((Object)(object)iOEntity2 != (Object)null)
							{
								iOSlot.Preserve(ref array[j]);
								IOPreserveInfo target = default(IOPreserveInfo);
								iOEntity2.inputs[iOSlot.connectedToSlot].Preserve(ref target);
								list2.Add(new OtherEntityPreserveInfo
								{
									info = target,
									connectedEntity = iOEntity2,
									index = iOSlot.connectedToSlot,
									isOutput = false
								});
							}
						}
						array2 = new IOPreserveInfo[iOEntity.inputs.Length];
						for (int k = 0; k < iOEntity.inputs.Length; k++)
						{
							IOEntity.IOSlot iOSlot2 = iOEntity.inputs[k];
							IOEntity iOEntity3 = iOSlot2.connectedTo.Get();
							if ((Object)(object)iOEntity3 != (Object)null)
							{
								iOSlot2.Preserve(ref array2[k]);
								IOPreserveInfo target2 = default(IOPreserveInfo);
								iOEntity3.outputs[iOSlot2.connectedToSlot].Preserve(ref target2);
								list2.Add(new OtherEntityPreserveInfo
								{
									info = target2,
									connectedEntity = iOEntity3,
									index = iOSlot2.connectedToSlot,
									isOutput = true
								});
							}
						}
					}
					baseEntity2.Kill();
					baseEntity2 = GameManager.server.CreateEntity(resourcePath, ((Object)(object)baseEntity3 != (Object)null) ? ((Component)baseEntity3).transform.TransformPoint(localPosition) : localPosition, ((Object)(object)baseEntity3 != (Object)null) ? (((Component)baseEntity3).transform.rotation * localRotation) : localRotation);
					baseEntity2.SetParent(baseEntity3);
					((Component)baseEntity2).transform.localPosition = localPosition;
					((Component)baseEntity2).transform.localRotation = localRotation;
					baseEntity2.OwnerID = ownerID;
					if (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) && (Object)(object)def2.isRedirectOf != (Object)null)
					{
						baseEntity2.skinID = 0uL;
					}
					else
					{
						baseEntity2.skinID = num;
					}
					if (baseEntity2 is DecayEntity decayEntity2)
					{
						decayEntity2.AttachToBuilding(null);
					}
					if (baseEntity2 is PlanterBox planterBox2)
					{
						planterBox2.soilSaturation = soilSaturation;
					}
					baseEntity2.Spawn();
					if (baseEntity2 is IOEntity iOEntity4)
					{
						if (array != null)
						{
							for (int l = 0; l < iOEntity4.outputs.Length; l++)
							{
								iOEntity4.outputs[l].Restore(array[l]);
							}
						}
						if (array2 != null)
						{
							for (int m = 0; m < iOEntity4.inputs.Length; m++)
							{
								if ((Object)(object)array2[m].connectedTo != (Object)null)
								{
									iOEntity4.inputs[m].Restore(array2[m]);
								}
							}
						}
						PooledList<IOEntity> val = Pool.Get<PooledList<IOEntity>>();
						try
						{
							foreach (OtherEntityPreserveInfo item2 in list2)
							{
								IOPreserveInfo info = item2.info;
								info.connectedTo = iOEntity4;
								if ((Object)(object)item2.connectedEntity != (Object)null)
								{
									if (item2.isOutput)
									{
										item2.connectedEntity.outputs[item2.index].Restore(info);
										((List<IOEntity>)(object)val).Add(item2.connectedEntity);
									}
									else
									{
										item2.connectedEntity.inputs[item2.index].Restore(info);
										((List<IOEntity>)(object)val).Add(item2.connectedEntity);
									}
								}
							}
							foreach (IOEntity item3 in (List<IOEntity>)(object)val)
							{
								item3.SendNetworkUpdate();
							}
						}
						finally
						{
							((IDisposable)val)?.Dispose();
						}
					}
					if (baseEntity2 is BaseCombatEntity baseCombatEntity2)
					{
						baseCombatEntity2.SetHealth(health);
						baseCombatEntity2.lastAttackedTime = lastAttackedTime;
					}
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge2 && hashSet != null)
					{
						buildingPrivlidge2.authorizedPlayers = hashSet;
					}
					if (baseEntity2 is CodeLock codeLock2)
					{
						baseEntity3.SetSlot(Slot.Lock, codeLock2);
						codeLock2.SetParent(baseEntity3, baseEntity3.GetSlotAnchorName(Slot.Lock));
						codeLock2.code = codeLockPreserveInfo.code;
						codeLock2.guestCode = codeLockPreserveInfo.guestCode;
						codeLock2.SetFlag(Flags.Locked, codeLockPreserveInfo.isLocked);
						codeLock2.whitelistPlayers.AddRange(codeLockPreserveInfo.whitelistPlayers);
						codeLock2.guestPlayers.AddRange(codeLockPreserveInfo.guestPlayers);
						Pool.FreeUnmanaged<ulong>(ref codeLockPreserveInfo.whitelistPlayers);
						Pool.FreeUnmanaged<ulong>(ref codeLockPreserveInfo.guestPlayers);
					}
					if (dictionary2.Count > 0)
					{
						RestoreEntityStorage(baseEntity2, 0, dictionary2);
						if (!flag2)
						{
							for (int n = 0; n < baseEntity2.children.Count; n++)
							{
								RestoreEntityStorage(baseEntity2.children[n], -1, dictionary2);
							}
						}
						foreach (KeyValuePair<ContainerSet, List<Item>> item4 in dictionary2)
						{
							foreach (Item item5 in item4.Value)
							{
								Debug.Log((object)$"Deleting {item5} as it has no new container");
								item5.Remove();
							}
						}
						Analytics.Azure.OnEntitySkinChanged(msg.player, baseNetworkable, targetSkin);
					}
					if (flag2)
					{
						foreach (ChildPreserveInfo item6 in list)
						{
							item6.TargetEntity.SetParent(baseEntity2, item6.TargetBone, worldPositionStays: true);
							((Component)item6.TargetEntity).transform.localPosition = item6.LocalPosition;
							((Component)item6.TargetEntity).transform.localRotation = item6.LocalRotation;
							item6.TargetEntity.SendNetworkUpdate();
						}
						baseEntity2.SetSlots(slots);
					}
					Pool.FreeUnmanaged<ChildPreserveInfo>(ref list);
					if (baseEntity2 is ISprayCallback sprayCallback)
					{
						sprayCallback.OnReskinned(msg.player);
					}
					if (baseEntity2 is DecayEntity decayEntity3 && !flag)
					{
						decayEntity3.StopBeingDemolishable();
					}
				}
				Interface.CallHook("OnEntityReskinned", (object)baseEntity2, (object)skin, (object)msg.player);
				ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 1, baseEntity2.net.ID);
			}
		}
		if (!base.UsingInfiniteAmmoCheat)
		{
			LoseCondition(ConditionLossPerReskin);
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ClearBusy, SprayCooldown);
		void FailResponse(SprayFailReason reason)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 0, (int)reason);
		}
		static void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary<ContainerSet, List<Item>> copy)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity2)
			{
				ContainerSet containerSet2 = default(ContainerSet);
				containerSet2.ContainerIndex = index;
				containerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key2 = containerSet2;
				if (copy.ContainsKey(key2))
				{
					foreach (Item item7 in copy[key2])
					{
						item7.MoveToContainer(itemContainerEntity2.inventory);
					}
					copy.Remove(key2);
				}
			}
		}
		static void SaveEntityStorage(BaseEntity baseEntity, Dictionary<ContainerSet, List<Item>> dictionary, int index)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity)
			{
				ContainerSet containerSet = default(ContainerSet);
				containerSet.ContainerIndex = index;
				containerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key = containerSet;
				if (!dictionary.ContainsKey(key))
				{
					dictionary.Add(key, new List<Item>());
					foreach (Item item8 in itemContainerEntity.inventory.itemList)
					{
						dictionary[key].Add(item8);
					}
					{
						foreach (Item item9 in dictionary[key])
						{
							item9.RemoveFromContainer();
						}
						return;
					}
				}
				Debug.Log((object)"Multiple containers with the same prefab id being added during vehicle reskin");
			}
		}
	}

	[RPC_Server.MaxDistance(5f)]
	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(2uL)]
	private void ChangeWallpaper(RPCMessage msg)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId uid = msg.read.EntityID();
		int targetSkin = msg.read.Int32();
		int side = ((!msg.read.Bool()) ? 1 : 0);
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		if (!(baseNetworkable is BuildingBlock buildingBlock) || !buildingBlock.HasWallpaper(side))
		{
			SprayFailResponse(SprayFailReason.InvalidItem);
		}
		else if (ValidateWallpaperReskin(msg.player, baseNetworkable as BuildingBlock, side, targetSkin))
		{
			ulong id = ItemDefinition.FindSkin(WallpaperSettings.GetItemDefForCategory(WallpaperPlanner.Settings.GetCategory(buildingBlock, side)).itemid, targetSkin);
			buildingBlock.SetWallpaper(id, side);
			Analytics.Azure.OnWallpaperPlaced(msg.player, buildingBlock, id, side, reskin: true);
			ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 1, buildingBlock.net.ID);
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearBusy, SprayCooldown);
		}
	}

	private bool GetEntityPrefabPath(ItemDefinition def, out string resourcePath)
	{
		resourcePath = string.Empty;
		ItemModDeployable itemModDeployable = default(ItemModDeployable);
		if (((Component)def).TryGetComponent<ItemModDeployable>(ref itemModDeployable))
		{
			resourcePath = itemModDeployable.entityPrefab.resourcePath;
			return true;
		}
		ItemModEntity itemModEntity = default(ItemModEntity);
		if (((Component)def).TryGetComponent<ItemModEntity>(ref itemModEntity))
		{
			resourcePath = itemModEntity.entityPrefab.resourcePath;
			return true;
		}
		ItemModEntityReference itemModEntityReference = default(ItemModEntityReference);
		if (((Component)def).TryGetComponent<ItemModEntityReference>(ref itemModEntityReference))
		{
			resourcePath = itemModEntityReference.entityPrefab.resourcePath;
			return true;
		}
		return false;
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void CreateSpray(RPCMessage msg)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		if (IsBusy())
		{
			return;
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ClearBusy, SprayCooldown);
		Vector3 val = msg.read.Vector3();
		Vector3 val2 = msg.read.Vector3();
		Vector3 val3 = msg.read.Vector3();
		int num = msg.read.Int32();
		if (Vector3.Distance(val, ((Component)this).transform.position) > 4.5f)
		{
			return;
		}
		Plane val4 = default(Plane);
		((Plane)(ref val4))..ctor(val2, val);
		Vector3 val5 = ((Plane)(ref val4)).ClosestPointOnPlane(val3) - val;
		Quaternion val6 = Quaternion.LookRotation(((Vector3)(ref val5)).normalized, val2);
		val6 *= Quaternion.Euler(0f, 0f, 90f);
		bool flag = false;
		if (msg.player.IsDeveloper)
		{
			flag = true;
		}
		if (num != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(num, msg.player.userID))
		{
			Debug.Log((object)$"SprayCan.ChangeItemSkin player does not have item :{num}:");
		}
		else if (Interface.CallHook("OnSprayCreate", (object)this, (object)val, (object)val6) == null)
		{
			ulong num2 = ItemDefinition.FindSkin(SprayDecalItem.itemid, num);
			BaseEntity baseEntity = GameManager.server.CreateEntity(SprayDecalEntityRef.resourcePath, val, val6);
			baseEntity.skinID = num2;
			baseEntity.OnDeployed(null, GetOwnerPlayer(), GetItem());
			baseEntity.Spawn();
			CheckAchievementPosition(val);
			if (!base.UsingInfiniteAmmoCheat)
			{
				LoseCondition(ConditionLossPerSpray);
			}
		}
	}

	private void CheckAchievementPosition(Vector3 pos)
	{
	}

	private void LoseCondition(float amount)
	{
		GetOwnerItem()?.LoseCondition(amount);
	}

	public void ClearBusy()
	{
		SetFlag(Flags.Busy, b: false);
		SetFlag(Flags.Reserved1, b: false);
	}

	public override void OnHeldChanged()
	{
		if (IsDisabled())
		{
			ClearBusy();
			if ((Object)(object)paintingLine != (Object)null)
			{
				paintingLine.Kill();
			}
			paintingLine = null;
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Server_SetBlockColourId(RPCMessage msg)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId uid = msg.read.EntityID();
		uint num = msg.read.UInt32();
		BasePlayer player = msg.player;
		SetFlag(Flags.Busy, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ClearBusy, 0.1f);
		if (!((Object)(object)player == (Object)null) && player.CanBuild())
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			BuildingBlock buildingBlock = BaseNetworkable.serverEntities.Find(uid) as BuildingBlock;
			if ((Object)(object)buildingBlock != (Object)null && !(player.Distance((BaseEntity)buildingBlock) > 4f))
			{
				uint customColour = buildingBlock.customColour;
				buildingBlock.SetCustomColour(num);
				Analytics.Azure.OnBuildingBlockColorChanged(ownerPlayer, buildingBlock, customColour, num);
			}
		}
	}

	private bool CanEntityBeRespawned(BaseEntity targetEntity, out SprayFailReason reason, out BasePlayer culpritPlayer)
	{
		if (targetEntity is BaseMountable baseMountable && baseMountable.AnyMounted())
		{
			reason = SprayFailReason.MountedBlocked;
			culpritPlayer = baseMountable.GetMounted();
			return false;
		}
		if (targetEntity.isServer && targetEntity is BaseVehicle baseVehicle && (baseVehicle.HasDriver() || baseVehicle.AnyMounted()))
		{
			reason = SprayFailReason.MountedBlocked;
			culpritPlayer = baseVehicle.GetMounted();
			return false;
		}
		reason = SprayFailReason.None;
		culpritPlayer = null;
		return true;
	}

	public static bool GetItemDefinitionForEntity(BaseEntity be, out ItemDefinition def, bool useRedirect = true)
	{
		def = null;
		if (be is BaseCombatEntity baseCombatEntity)
		{
			if (baseCombatEntity.pickup.enabled && (Object)(object)baseCombatEntity.pickup.itemTarget != (Object)null)
			{
				def = baseCombatEntity.pickup.itemTarget;
			}
			else if (baseCombatEntity.repair.enabled && (Object)(object)baseCombatEntity.repair.itemTarget != (Object)null)
			{
				def = baseCombatEntity.repair.itemTarget;
			}
		}
		if (be is CodeLock codeLock)
		{
			def = codeLock.itemType;
		}
		if (useRedirect && (Object)(object)def != (Object)null && (Object)(object)def.isRedirectOf != (Object)null)
		{
			def = def.isRedirectOf;
		}
		return (Object)(object)def != (Object)null;
	}
}


private enum SprayFailReason
{
	None,
	MountedBlocked,
	IOConnection,
	LineOfSight,
	SkinNotOwned,
	InvalidItem
}


private struct ContainerSet
{
	public int ContainerIndex;

	public uint PrefabId;
}


using UnityEngine;

public struct IOPreserveInfo
{
	public IOEntity connectedTo;

	public int connectedToSlot;

	public Vector3[] linePoints;

	public float[] slackLevels;

	public IOEntity.LineAnchor[] lineAnchors;

	public Vector3 worldSpaceLineEndRotation;

	public Vector3 originPosition;

	public Vector3 originRotation;

	public WireTool.WireColour wireColour;
}


using System.Collections.Generic;

private struct CodeLockPreserveInfo
{
	public string code;

	public string guestCode;

	public bool isLocked;

	public List<ulong> whitelistPlayers;

	public List<ulong> guestPlayers;
}


private struct OtherEntityPreserveInfo
{
	public IOPreserveInfo info;

	public IOEntity connectedEntity;

	public int index;

	public bool isOutput;
}


using UnityEngine;

public struct ChildPreserveInfo
{
	public BaseEntity TargetEntity;

	public uint TargetBone;

	public Vector3 LocalPosition;

	public Quaternion LocalRotation;
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class SprayCanSpray : DecayEntity, ISplashable
{
	private DateTime sprayTimestamp;

	[NonSerialized]
	public ulong sprayedByPlayer;

	public static ListHashSet<SprayCanSpray> AllSprays = new ListHashSet<SprayCanSpray>();

	[NonSerialized]
	public int splashThreshold;

	public override bool BypassInsideDecayMultiplier => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SprayCanSpray.OnRpcMessage", 0);
		try
		{
			if (rpc == 2774110739u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestWaterClear "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestWaterClear", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_RequestWaterClear(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_RequestWaterClear");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.spray == null)
		{
			info.msg.spray = Pool.Get<Spray>();
		}
		info.msg.spray.sprayedBy = sprayedByPlayer;
		info.msg.spray.timestamp = sprayTimestamp.ToBinary();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.spray != null)
		{
			sprayedByPlayer = info.msg.spray.sprayedBy;
			sprayTimestamp = DateTime.FromBinary(info.msg.spray.timestamp);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		sprayTimestamp = DateTime.Now;
		sprayedByPlayer = deployedBy.userID;
		if (Global.MaxSpraysPerPlayer > 0 && sprayedByPlayer != 0L)
		{
			int num = -1;
			DateTime now = DateTime.Now;
			int num2 = 0;
			for (int i = 0; i < AllSprays.Count; i++)
			{
				if (AllSprays[i].sprayedByPlayer == sprayedByPlayer)
				{
					num2++;
					if (num == -1 || AllSprays[i].sprayTimestamp < now)
					{
						num = i;
						now = AllSprays[i].sprayTimestamp;
					}
				}
			}
			if (num2 >= Global.MaxSpraysPerPlayer && num != -1)
			{
				AllSprays[num].Kill();
			}
		}
		if ((Object)(object)deployedBy == (Object)null || !deployedBy.IsBuildingAuthed())
		{
			((FacepunchBehaviour)this).Invoke((Action)ApplyOutOfAuthConditionPenalty, 1f);
		}
	}

	public void ApplyOutOfAuthConditionPenalty()
	{
		if (!IsFullySpawned())
		{
			((FacepunchBehaviour)this).Invoke((Action)ApplyOutOfAuthConditionPenalty, 1f);
			return;
		}
		float amount = MaxHealth() * (1f - Global.SprayOutOfAuthMultiplier);
		Hurt(amount, DamageType.Decay);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)RainCheck, 60f, 180f, 30f);
		if (!AllSprays.Contains(this))
		{
			AllSprays.Add(this);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (AllSprays.Contains(this))
		{
			AllSprays.Remove(this);
		}
	}

	public void RainCheck()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		if (Climate.GetRain(((Component)this).transform.position) > 0f && IsOutside())
		{
			Kill();
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		return amount > splashThreshold;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		if (!base.IsDestroyed)
		{
			Kill();
		}
		return 1;
	}

	[RPC_Server]
	private void Server_RequestWaterClear(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && Menu_WaterClear_ShowIf(player) && Interface.CallHook("OnSprayRemove", (object)this, (object)player) == null)
		{
			Kill();
		}
	}

	public bool Menu_WaterClear_ShowIf(BasePlayer player)
	{
		if ((Object)(object)player.GetHeldEntity() != (Object)null && player.GetHeldEntity() is BaseLiquidVessel baseLiquidVessel)
		{
			return baseLiquidVessel.AmountHeld() > 0;
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class SprayCanSpray_Freehand : SprayCanSpray
{
	public AlignedLineDrawer LineDrawer;

	public List<AlignedLineDrawer.LinePoint> LinePoints = new List<AlignedLineDrawer.LinePoint>();

	public Color colour = Color.white;

	public float width;

	public EntityRef<BasePlayer> editingPlayer;

	public GroundWatch groundWatch;

	public MeshCollider meshCollider;

	public const int MaxLinePointLength = 60;

	public const float SimplifyTolerance = 0.008f;

	private bool AcceptingChanges => editingPlayer.IsValid(serverside: true);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SprayCanSpray_Freehand.OnRpcMessage", 0);
		try
		{
			if (rpc == 2020094435 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_AddPointMidSpray "));
				}
				TimeWarning val2 = TimeWarning.New("Server_AddPointMidSpray", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_AddPointMidSpray(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_AddPointMidSpray");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 117883393 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_FinishEditing "));
				}
				TimeWarning val2 = TimeWarning.New("Server_FinishEditing", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						Server_FinishEditing(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in Server_FinishEditing");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool ShouldNetworkOwnerInfo()
	{
		return true;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (LinePoints == null || LinePoints.Count == 0)
		{
			Kill();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.sprayLine == null)
		{
			info.msg.sprayLine = Pool.Get<SprayLine>();
		}
		if (info.msg.sprayLine.linePoints == null)
		{
			info.msg.sprayLine.linePoints = Pool.Get<List<LinePoint>>();
		}
		bool flag = AcceptingChanges && info.forDisk;
		if (LinePoints != null && !flag)
		{
			CopyPoints(LinePoints, info.msg.sprayLine.linePoints);
		}
		info.msg.sprayLine.width = width;
		info.msg.sprayLine.colour = new Vector3(colour.r, colour.g, colour.b);
		if (!info.forDisk)
		{
			info.msg.sprayLine.editingPlayer = editingPlayer.uid;
		}
	}

	public void SetColour(Color newColour)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		colour = newColour;
	}

	public void SetWidth(float lineWidth)
	{
		width = lineWidth;
	}

	[RPC_Server]
	private void Server_AddPointMidSpray(RPCMessage msg)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (AcceptingChanges && !((Object)(object)editingPlayer.Get(serverside: true) != (Object)(object)msg.player) && LinePoints.Count + 1 <= 60)
		{
			Vector3 val = msg.read.Vector3();
			Vector3 worldNormal = msg.read.Vector3();
			if (!(Vector3.Distance(val, LinePoints[0].LocalPosition) >= 10f))
			{
				LinePoints.Add(new AlignedLineDrawer.LinePoint
				{
					LocalPosition = val,
					WorldNormal = worldNormal
				});
				UpdateGroundWatch();
				SendNetworkUpdate();
			}
		}
	}

	public void EnableChanges(BasePlayer byPlayer)
	{
		base.OwnerID = byPlayer.userID;
		editingPlayer.Set(byPlayer);
		((FacepunchBehaviour)this).Invoke((Action)TimeoutEditing, 30f);
	}

	public void TimeoutEditing()
	{
		if (editingPlayer.IsSet)
		{
			editingPlayer.Set(null);
			SendNetworkUpdate();
			Kill();
		}
	}

	[RPC_Server]
	private void Server_FinishEditing(RPCMessage msg)
	{
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = editingPlayer.Get(serverside: true);
		if ((Object)(object)msg.player != (Object)(object)basePlayer)
		{
			return;
		}
		bool allowNewSprayImmediately = msg.read.Int32() == 1;
		if ((Object)(object)basePlayer != (Object)null && (Object)(object)basePlayer.GetHeldEntity() != (Object)null && basePlayer.GetHeldEntity() is SprayCan sprayCan)
		{
			sprayCan.ClearPaintingLine(allowNewSprayImmediately);
		}
		editingPlayer.Set(null);
		SprayList val = msg.read.Proto<SprayList>((SprayList)null);
		try
		{
			int count = val.linePoints.Count;
			if (count > 70)
			{
				Kill();
				return;
			}
			if (LinePoints.Count <= 1)
			{
				Kill();
				return;
			}
			((FacepunchBehaviour)this).CancelInvoke((Action)TimeoutEditing);
			LinePoints.Clear();
			for (int i = 0; i < count; i++)
			{
				if (((Vector3)(ref val.linePoints[i].localPosition)).sqrMagnitude < 100f)
				{
					LinePoints.Add(new AlignedLineDrawer.LinePoint
					{
						LocalPosition = val.linePoints[i].localPosition,
						WorldNormal = val.linePoints[i].worldNormal
					});
				}
			}
			OnDeployed(null, basePlayer, null);
			UpdateGroundWatch();
			SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void AddInitialPoint(Vector3 atNormal)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		LinePoints = new List<AlignedLineDrawer.LinePoint>
		{
			new AlignedLineDrawer.LinePoint
			{
				LocalPosition = Vector3.zero,
				WorldNormal = atNormal
			}
		};
	}

	private void UpdateGroundWatch()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && LinePoints.Count > 1)
		{
			Vector3 groundPosition = Vector3.Lerp(LinePoints[0].LocalPosition, LinePoints[LinePoints.Count - 1].LocalPosition, 0.5f);
			if ((Object)(object)groundWatch != (Object)null)
			{
				groundWatch.groundPosition = groundPosition;
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.sprayLine != null)
		{
			if (info.msg.sprayLine.linePoints != null)
			{
				LinePoints.Clear();
				CopyPoints(info.msg.sprayLine.linePoints, LinePoints);
			}
			colour = new Color(info.msg.sprayLine.colour.x, info.msg.sprayLine.colour.y, info.msg.sprayLine.colour.z);
			width = info.msg.sprayLine.width;
			editingPlayer.uid = info.msg.sprayLine.editingPlayer;
			UpdateGroundWatch();
		}
	}

	public void CopyPoints(List<AlignedLineDrawer.LinePoint> from, List<LinePoint> to)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		to.Clear();
		foreach (AlignedLineDrawer.LinePoint item in from)
		{
			LinePoint val = Pool.Get<LinePoint>();
			val.localPosition = item.LocalPosition;
			val.worldNormal = item.WorldNormal;
			to.Add(val);
		}
	}

	public void CopyPoints(List<AlignedLineDrawer.LinePoint> from, List<Vector3> to)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		to.Clear();
		foreach (AlignedLineDrawer.LinePoint item in from)
		{
			to.Add(item.LocalPosition);
			to.Add(item.WorldNormal);
		}
	}

	public void CopyPoints(List<LinePoint> from, List<AlignedLineDrawer.LinePoint> to)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		to.Clear();
		foreach (LinePoint item in from)
		{
			to.Add(new AlignedLineDrawer.LinePoint
			{
				LocalPosition = item.localPosition,
				WorldNormal = item.worldNormal
			});
		}
	}

	public static void CopyPoints(List<AlignedLineDrawer.LinePoint> from, List<AlignedLineDrawer.LinePoint> to)
	{
		to.Clear();
		foreach (AlignedLineDrawer.LinePoint item in from)
		{
			to.Add(item);
		}
	}

	public override void ResetState()
	{
		base.ResetState();
		editingPlayer.Set(null);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;

public class StagedResourceEntity : ResourceEntity
{
	[Serializable]
	public class ResourceStage
	{
		public float health;

		public GameObject instance;
	}

	public List<ResourceStage> stages = new List<ResourceStage>();

	protected int stage;

	public GameObjectRef changeStageEffect;

	public MeshLOD ResourceMeshLod;

	public MeshCollider ResourceMeshCollider;

	public GameObject gibSourceTest;

	private StagedResourceEntityInfo cachedInfo;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StagedResourceEntity.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.resource != null)
		{
			int num = info.msg.resource.stage;
			if (info.fromDisk && base.isServer)
			{
				health = startHealth;
				num = 0;
			}
			if (num != stage)
			{
				stage = num;
				UpdateStage();
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.resource == null)
		{
			info.msg.resource = Pool.Get<BaseResource>();
		}
		info.msg.resource.health = Health();
		info.msg.resource.stage = stage;
	}

	protected override void OnHealthChanged()
	{
		((FacepunchBehaviour)this).Invoke((Action)UpdateNetworkStage, 0.1f);
	}

	public virtual void UpdateNetworkStage()
	{
		if (FindBestStage() != stage)
		{
			stage = FindBestStage();
			SendNetworkUpdate();
			UpdateStage();
		}
	}

	private int FindBestStage()
	{
		float num = Mathf.InverseLerp(0f, MaxHealth(), Health());
		StagedResourceEntityInfo.ResourceStage[] array = GetInfo().Stages;
		for (int i = 0; i < array.Length; i++)
		{
			if (num >= array[i].Health)
			{
				return i;
			}
		}
		return array.Length - 1;
	}

	private StagedResourceEntityInfo GetInfo()
	{
		if (cachedInfo != null)
		{
			return cachedInfo;
		}
		if (base.isServer)
		{
			cachedInfo = PrefabAttribute.server.Find<StagedResourceEntityInfo>(prefabID);
		}
		return cachedInfo;
	}

	private void UpdateStage()
	{
		if (GetInfo().Stages.Length != 0)
		{
			ResourceMeshCollider.sharedMesh = cachedInfo.GetCollisionMesh(stage);
			GroundWatch.PhysicsChanged(((Component)this).gameObject);
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class ResourceStage
{
	public float health;

	public GameObject instance;
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

[Factory("stash")]
public class StashContainer : StorageContainer
{
	public static class StashContainerFlags
	{
		public const Flags Hidden = Flags.Reserved5;
	}

	public Transform visuals;

	public float burriedOffset;

	public float raisedOffset;

	public GameObjectRef buryEffect;

	public float uncoverRange = 3f;

	public float uncoverTime = 2f;

	[ServerVar(Name = "reveal_tick_rate")]
	public static float PlayerDetectionTickRate = 0.5f;

	private float lastToggleTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StashContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 4130263076u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_HideStash "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_HideStash", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4130263076u, "RPC_HideStash", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_HideStash(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_HideStash");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool PlayerInRange(BasePlayer ply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3.Distance(((Component)this).transform.position, ((Component)ply).transform.position) <= uncoverRange)
		{
			Vector3 val = ((Component)this).transform.position - ply.eyes.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			if (Vector3.Dot(ply.eyes.BodyForward(), normalized) > 0.95f)
			{
				return true;
			}
		}
		return false;
	}

	public override void InitShared()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		((Component)visuals).transform.localPosition = Vector3Ex.WithY(((Component)visuals).transform.localPosition, raisedOffset);
	}

	public void DoOccludedCheck()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (Physics.SphereCast(new Ray(((Component)this).transform.position + Vector3.up * 5f, Vector3.down), 0.25f, 5f, 2097152) && Interface.CallHook("OnStashOcclude", (object)this) == null)
		{
			DropItems();
			Kill();
		}
	}

	public void OnPhysicsNeighbourChanged()
	{
		if (!((FacepunchBehaviour)this).IsInvoking((Action)DoOccludedCheck))
		{
			((FacepunchBehaviour)this).Invoke((Action)DoOccludedCheck, Random.Range(5f, 10f));
		}
	}

	private void RemoveFromNetworkRange()
	{
		base.limitNetworking = true;
	}

	private void ReturnToNetworkRange()
	{
		if (base.limitNetworking)
		{
			base.limitNetworking = false;
			SendNetworkUpdateImmediate();
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)RemoveFromNetworkRange);
	}

	public void SetHidden(bool isHidden)
	{
		if (!(Time.realtimeSinceStartup - lastToggleTime < 3f) && isHidden != HasFlag(Flags.Reserved5))
		{
			if (isHidden)
			{
				((FacepunchBehaviour)this).Invoke((Action)RemoveFromNetworkRange, 3f);
			}
			else
			{
				ReturnToNetworkRange();
			}
			lastToggleTime = Time.realtimeSinceStartup;
			((FacepunchBehaviour)this).Invoke((Action)Decay, 259200f);
			if (base.isServer)
			{
				SetFlag(Flags.Reserved5, isHidden);
			}
		}
	}

	public void DisableNetworking()
	{
		base.limitNetworking = true;
		SetFlag(Flags.Disabled, b: true);
	}

	public void Decay()
	{
		Kill();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetHidden(isHidden: false);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (IsHidden())
		{
			RemoveFromNetworkRange();
		}
	}

	public void ToggleHidden()
	{
		SetHidden(!IsHidden());
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_HideStash(RPCMessage rpc)
	{
		if (Interface.CallHook("CanHideStash", (object)rpc.player, (object)this) == null)
		{
			Analytics.Azure.OnStashHidden(rpc.player, this);
			SetHidden(isHidden: true);
			Interface.CallHook("OnStashHidden", (object)this, (object)rpc.player);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool num = (old & Flags.Reserved5) == Flags.Reserved5;
		bool flag = (next & Flags.Reserved5) == Flags.Reserved5;
		if (num != flag)
		{
			float num2 = (flag ? burriedOffset : raisedOffset);
			LeanTween.cancel(((Component)visuals).gameObject);
			LeanTween.moveLocalY(((Component)visuals).gameObject, num2, 1f);
		}
	}

	public bool IsHidden()
	{
		return HasFlag(Flags.Reserved5);
	}
}


public static class StashContainerFlags
{
	public const Flags Hidden = Flags.Reserved5;
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class StaticInstrument : BaseMountable
{
	public AnimatorOverrideController AnimatorOverride;

	public bool ShowDeployAnimation;

	public InstrumentKeyController KeyController;

	public bool ShouldSuppressHandsAnimationLayer;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StaticInstrument.OnRpcMessage", 0);
		try
		{
			if (rpc == 1625188589 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_PlayNote "));
				}
				TimeWarning val2 = TimeWarning.New("Server_PlayNote", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						Server_PlayNote(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in Server_PlayNote");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 705843933 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_StopNote "));
				}
				TimeWarning val2 = TimeWarning.New("Server_StopNote", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						Server_StopNote(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in Server_StopNote");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server]
	private void Server_PlayNote(RPCMessage msg)
	{
		int arg = msg.read.Int32();
		int arg2 = msg.read.Int32();
		int arg3 = msg.read.Int32();
		float num = msg.read.Float();
		if (!FloatEx.IsNaNOrInfinity(num))
		{
			KeyController.ProcessServerPlayedNote(GetMounted());
			ClientRPC(RpcTarget.NetworkGroup("Client_PlayNote"), arg, arg2, arg3, num);
		}
	}

	[RPC_Server]
	private void Server_StopNote(RPCMessage msg)
	{
		int arg = msg.read.Int32();
		int arg2 = msg.read.Int32();
		int arg3 = msg.read.Int32();
		ClientRPC(RpcTarget.NetworkGroup("Client_StopNote"), arg, arg2, arg3);
	}

	public override bool IsInstrument()
	{
		return true;
	}
}


using System;
using System.Linq;
using System.Threading.Tasks;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class SteamInventory : EntityComponent<BasePlayer>
{
	public IPlayerItem[] Items;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SteamInventory.OnRpcMessage", 0);
		try
		{
			if (rpc == 643458331 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdateSteamInventory "));
				}
				TimeWarning val2 = TimeWarning.New("UpdateSteamInventory", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!BaseEntity.RPC_Server.FromOwner.Test(643458331u, "UpdateSteamInventory", GetBaseEntity(), player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							BaseEntity.RPCMessage rPCMessage = default(BaseEntity.RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							BaseEntity.RPCMessage msg2 = rPCMessage;
							UpdateSteamInventory(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in UpdateSteamInventory");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool HasItem(int itemid)
	{
		if (base.baseEntity.UnlockAllSkins)
		{
			return true;
		}
		if (Items == null)
		{
			return false;
		}
		IPlayerItem[] items = Items;
		for (int i = 0; i < items.Length; i++)
		{
			if (items[i].DefinitionId == itemid)
			{
				return true;
			}
		}
		return false;
	}

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.FromOwner(false)]
	private async Task UpdateSteamInventory(BaseEntity.RPCMessage msg)
	{
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		if (array == null)
		{
			Debug.LogWarning((object)"UpdateSteamInventory: Data is null");
			return;
		}
		IPlayerInventory val = await PlatformService.Instance.DeserializeInventory(array);
		if (val == null)
		{
			Debug.LogWarning((object)"UpdateSteamInventory: result is null");
		}
		else if ((Object)(object)base.baseEntity == (Object)null)
		{
			Debug.LogWarning((object)"UpdateSteamInventory: player is null");
		}
		else if (!val.BelongsTo((ulong)base.baseEntity.userID))
		{
			Debug.LogWarning((object)$"UpdateSteamPlayer: inventory belongs to someone else (userID={base.baseEntity.userID.Get()})");
		}
		else if (Object.op_Implicit((Object)(object)((Component)this).gameObject))
		{
			Items = val.Items.ToArray();
			Interface.CallHook("OnSteamInventoryUpdated", (object)this);
			((IDisposable)val).Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class StorageContainer : DecayEntity, IItemContainerEntity, IIdealSlotEntity, ILootableEntity, IInventoryProvider, LootPanel.IHasLootPanel, IContainerSounds, PlayerInventory.ICanMoveFrom
{
	[Header("Storage Container")]
	public static readonly Phrase LockedMessage = new Phrase("storage.locked", "Can't loot right now");

	public static readonly Phrase InUseMessage = new Phrase("storage.in_use", "Already in use");

	public int inventorySlots = 6;

	public bool dropsLoot = true;

	public float dropLootDestroyPercent;

	public bool dropFloats;

	public bool isLootable = true;

	public bool isLockable = true;

	public bool isMonitorable;

	public string panelName = "generic";

	public Phrase panelTitle = new Phrase("loot", "Loot");

	public ItemContainer.ContentsType allowedContents;

	public ItemDefinition allowedItem;

	public ItemDefinition allowedItem2;

	public ItemDefinition[] allowedItems;

	public ItemDefinition[] blockedItems;

	public int maxStackSize;

	public bool needsBuildingPrivilegeToUse;

	public bool requireAuthIfNotLocked;

	[ServerVar]
	public static bool canRequireAuthIfNoLock = false;

	public bool mustBeMountedToUse;

	public SoundDefinition openSound;

	public SoundDefinition closeSound;

	[Header("Item Dropping")]
	public Vector3 dropPosition;

	public Vector3 dropVelocity = Vector3.forward;

	public ItemCategory onlyAcceptCategory = ItemCategory.All;

	public bool onlyOneUser;

	[ServerVar]
	public static bool dropCorpseOnDeath;

	[ServerVar]
	public static float corpseItemsSavedPercent = 0.5f;

	public ItemContainer _inventory;

	public Phrase LootPanelTitle => panelTitle;

	public ItemContainer inventory => _inventory;

	public Transform Transform => ((Component)this).transform;

	public bool DropsLoot => dropsLoot;

	public bool DropFloats => dropFloats;

	public float DestroyLootPercent
	{
		get
		{
			if (!ShouldDropDeployableCorpse(lastAttacker, lastDamage))
			{
				return dropLootDestroyPercent;
			}
			return 0f;
		}
	}

	public ulong LastLootedBy { get; set; }

	public BasePlayer LastLootedByPlayer { get; set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StorageContainer.OnRpcMessage", 0);
		try
		{
			if (rpc == 331989034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(331989034u, "RPC_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.yellow;
		Gizmos.DrawCube(dropPosition, Vector3.one * 0.1f);
		Gizmos.color = Color.white;
		Gizmos.DrawRay(dropPosition, dropVelocity);
	}

	public bool MoveAllInventoryItems(ItemContainer from)
	{
		return MoveAllInventoryItems(from, _inventory);
	}

	public static bool MoveAllInventoryItems(ItemContainer source, ItemContainer dest)
	{
		bool flag = true;
		for (int i = 0; i < Mathf.Min(source.capacity, dest.capacity); i++)
		{
			Item slot = source.GetSlot(i);
			if (slot != null)
			{
				bool flag2 = slot.MoveToContainer(dest);
				if (flag && !flag2)
				{
					flag = false;
				}
			}
		}
		return flag;
	}

	public virtual void ReceiveInventoryFromItem(Item item)
	{
		if (item.contents != null)
		{
			MoveAllInventoryItems(item.contents, _inventory);
		}
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		bool num = (Object)(object)GetSlot(Slot.Lock) != (Object)null;
		pickupErrorToFormat.arg0 = pickup.itemTarget.displayName;
		if (num)
		{
			pickupErrorToFormat.format = PickupErrors.ItemHasLock;
			return false;
		}
		if (pickup.requireEmptyInv && _inventory != null && !inventory.IsEmpty())
		{
			pickupErrorToFormat.format = PickupErrors.ItemInventoryMustBeEmpty;
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public override void OnPickedUp(Item createdItem, BasePlayer player)
	{
		base.OnPickedUp(createdItem, player);
		if (createdItem != null && createdItem.contents != null)
		{
			MoveAllInventoryItems(_inventory, createdItem.contents);
			return;
		}
		for (int i = 0; i < _inventory.capacity; i++)
		{
			Item slot = _inventory.GetSlot(i);
			if (slot != null)
			{
				slot.RemoveFromContainer();
				player.GiveItem(slot, GiveItemReason.PickedUp);
			}
		}
	}

	public override void ServerInit()
	{
		if (_inventory == null)
		{
			CreateInventory(giveUID: true);
			OnInventoryFirstCreated(_inventory);
		}
		else
		{
			_inventory.SetBlacklist(blockedItems);
		}
		base.ServerInit();
	}

	public virtual void OnInventoryFirstCreated(ItemContainer container)
	{
	}

	public virtual void OnItemAddedOrRemoved(Item item, bool added)
	{
	}

	public virtual void OnItemAddedToStack(Item item, int amount)
	{
	}

	public virtual void OnItemRemovedFromStack(Item item, int amount)
	{
	}

	public virtual void OnItemPositionChanged(Item item, int from, int to)
	{
	}

	public virtual bool ItemFilter(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("OnItemFilter", (object)item, (object)this, (object)targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (onlyAcceptCategory == ItemCategory.All)
		{
			return true;
		}
		return item.info.category == onlyAcceptCategory;
	}

	public void CreateInventory(bool giveUID)
	{
		Debug.Assert(_inventory == null, "Double init of inventory!");
		_inventory = Pool.Get<ItemContainer>();
		_inventory.entityOwner = this;
		_inventory.allowedContents = ((allowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : allowedContents);
		_inventory.SetOnlyAllowedItems(allowedItems, allowedItem, allowedItem2);
		_inventory.SetBlacklist(blockedItems);
		_inventory.maxStackSize = maxStackSize;
		_inventory.ServerInitialize(null, inventorySlots);
		if (giveUID)
		{
			_inventory.GiveUID();
		}
		_inventory.onDirty += OnInventoryDirty;
		_inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
		_inventory.onItemAddedToStack = OnItemAddedToStack;
		_inventory.onItemRemovedFromStack = OnItemRemovedFromStack;
		_inventory.onItemPositionChanged = OnItemPositionChanged;
		_inventory.canAcceptItem = ItemFilter;
	}

	public override void PreServerLoad()
	{
		base.PreServerLoad();
		CreateInventory(giveUID: false);
	}

	protected virtual void OnInventoryDirty()
	{
		InvalidateNetworkCache();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (_inventory != null && !((ItemContainerId)(ref _inventory.uid)).IsValid)
		{
			_inventory.GiveUID();
		}
		SetFlag(Flags.Open, b: false);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (_inventory != null)
		{
			Pool.Free<ItemContainer>(ref _inventory);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (isLootable)
		{
			BasePlayer player = rpc.player;
			if (Object.op_Implicit((Object)(object)player) && player.CanInteract())
			{
				PlayerOpenLoot(player);
			}
		}
	}

	public virtual string GetPanelName()
	{
		return panelName;
	}

	public virtual bool CanMoveFrom(BasePlayer player, Item item)
	{
		return !_inventory.IsLocked();
	}

	public virtual bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		if (!CanBeLooted(player))
		{
			return false;
		}
		BaseLock @lock = GetLock();
		if ((Object)(object)@lock != (Object)null && !@lock.OnTryToOpen(player))
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
			return false;
		}
		return true;
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if ((needsBuildingPrivilegeToUse || ShouldRequireAuthIfNoCodelock(this, requireAuthIfNotLocked)) && !player.CanBuild())
		{
			return false;
		}
		if (mustBeMountedToUse && !player.isMounted)
		{
			return false;
		}
		return base.CanBeLooted(player);
	}

	public virtual void AddContainers(PlayerLoot loot)
	{
		loot.AddContainer(_inventory);
	}

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", (object)player, (object)this) != null)
		{
			return false;
		}
		if (IsLocked() || IsTransferring())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, LockedMessage, false);
			return false;
		}
		if (onlyOneUser && IsOpen())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, InUseMessage, false);
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = panelName;
		}
		if (!CanOpenLootPanel(player, panelToOpen))
		{
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			AddContainers(player.inventory.loot);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), panelToOpen);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", (object)player, (object)this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			if (_inventory != null)
			{
				info.msg.storageBox = Pool.Get<StorageBox>();
				info.msg.storageBox.contents = _inventory.Save();
			}
			else
			{
				Debug.LogWarning((object)("Storage container without inventory: " + ((object)this).ToString()));
			}
		}
	}

	public override void OnDied(HitInfo info)
	{
		DropItems(info?.Initiator);
		base.OnDied(info);
	}

	public override void OnDeployableCorpseSpawned(BaseEntity corpse)
	{
		base.OnDeployableCorpseSpawned(corpse);
		if (corpse is ContainerCorpse containerCorpse)
		{
			containerCorpse.TakeFrom(new ItemContainer[1] { inventory }, corpseItemsSavedPercent);
		}
	}

	public virtual void DropItems(BaseEntity initiator = null)
	{
		DropItems(this, initiator);
	}

	public static void DropItems(IItemContainerEntity containerEntity, BaseEntity initiator = null)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		ItemContainer itemContainer = containerEntity.inventory;
		if (itemContainer == null || itemContainer.itemList == null || itemContainer.itemList.Count == 0 || !containerEntity.DropsLoot)
		{
			return;
		}
		if (containerEntity.ShouldDropItemsIndividually() || (itemContainer.itemList.Count == 1 && !containerEntity.DropFloats))
		{
			if ((Object)(object)initiator != (Object)null)
			{
				containerEntity.DropBonusItems(initiator, itemContainer);
			}
			DropUtil.DropItems(itemContainer, containerEntity.GetDropPosition());
		}
		else
		{
			string prefab = (containerEntity.DropFloats ? "assets/prefabs/misc/item drop/item_drop_buoyant.prefab" : "assets/prefabs/misc/item drop/item_drop.prefab");
			_ = (Object)(object)itemContainer.Drop(prefab, containerEntity.GetDropPosition(), containerEntity.Transform.rotation, containerEntity.DestroyLootPercent) != (Object)null;
		}
	}

	public virtual void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
	}

	public override Vector3 GetDropPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		return ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint(dropPosition);
	}

	public override Vector3 GetDropVelocity()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 inheritedDropVelocity = GetInheritedDropVelocity();
		Matrix4x4 localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		return inheritedDropVelocity + ((Matrix4x4)(ref localToWorldMatrix)).MultiplyVector(dropPosition);
	}

	public virtual bool ShouldDropItemsIndividually()
	{
		return false;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.storageBox != null)
		{
			if (_inventory != null)
			{
				_inventory.Load(info.msg.storageBox.contents);
				_inventory.capacity = inventorySlots;
			}
			else
			{
				Debug.LogWarning((object)("Storage container without inventory: " + ((object)this).ToString()));
			}
		}
	}

	public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		return -1;
	}

	public virtual ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return default(ItemContainerId);
	}

	public virtual void GetAllInventories(List<ItemContainer> list)
	{
		list.Add(inventory);
	}

	public static bool ShouldRequireAuthIfNoCodelock(BaseEntity container, bool containerRequiresAuth)
	{
		if (canRequireAuthIfNoLock && containerRequiresAuth)
		{
			return (Object)(object)container.GetLock() == (Object)null;
		}
		return false;
	}

	public override bool HasSlot(Slot slot)
	{
		if (isLockable && slot == Slot.Lock)
		{
			return true;
		}
		if (isMonitorable && slot == Slot.StorageMonitor)
		{
			return true;
		}
		return base.HasSlot(slot);
	}

	public bool OccupiedCheck(BasePlayer player = null)
	{
		if ((Object)(object)player != (Object)null && (Object)(object)player.inventory.loot.entitySource == (Object)(object)this)
		{
			return true;
		}
		if (onlyOneUser)
		{
			return !IsOpen();
		}
		return true;
	}

	protected bool HasAttachedStorageAdaptor()
	{
		if (children == null)
		{
			return false;
		}
		foreach (BaseEntity child in children)
		{
			if (child is IndustrialStorageAdaptor)
			{
				return true;
			}
		}
		return false;
	}

	protected bool HasAttachedStorageMonitor()
	{
		if (children == null)
		{
			return false;
		}
		foreach (BaseEntity child in children)
		{
			if (child is StorageMonitor)
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class StringLights : IOEntity
{
	public struct PointEntry
	{
		public Vector3 point;

		public Vector3 normal;

		public float slack;
	}

	[Serializable]
	public struct BulbSettings
	{
		public GameObjectRef BulbPrefab;

		public float Weight;
	}

	[SerializeField]
	private float lengthPerAmount = 0.5f;

	[SerializeField]
	private float maxPlaceDistance = 5f;

	[SerializeField]
	private ItemDefinition itemToConsume;

	[SerializeField]
	[Header("Line Generation Settings")]
	protected BulbSettings[] bulbSettings;

	[SerializeField]
	private GameObjectRef pointLightPrefab;

	[SerializeField]
	private Transform lightsParent;

	[SerializeField]
	private Transform wireOrigin;

	[SerializeField]
	protected float bulbSpacing = 0.25f;

	[SerializeField]
	protected float wireThickness = 0.02f;

	[SerializeField]
	protected float maxDeviation = 0.25f;

	[SerializeField]
	protected float deviationFactor = 1f;

	[SerializeField]
	[Space]
	protected LineRenderer lineRenderer;

	[SerializeField]
	protected RendererLOD rendererLod;

	protected readonly List<PointEntry> points = new List<PointEntry>();

	protected readonly List<StringLightsBulb> bulbs = new List<StringLightsBulb>();

	protected readonly List<Light> pointLights = new List<Light>();

	private readonly Dictionary<int, GameObject> prefabLookup = new Dictionary<int, GameObject>();

	public bool useBatching;

	protected List<StringLightsBulb> lastBatchedMeshes = new List<StringLightsBulb>();

	private int lengthUsed;

	private const Flags Flag_Used = Flags.Reserved5;

	private const int PLACEMENT_LAYER = 1084293121;

	private BasePlayer usingPlayer;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("StringLights.OnRpcMessage", 0);
		try
		{
			if (rpc == 4045900594u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_AddPoint "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_AddPoint", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4045900594u, "SERVER_AddPoint", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_AddPoint(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_AddPoint");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3733663691u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RemovePoint "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RemovePoint", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3733663691u, "SERVER_RemovePoint", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_RemovePoint(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_RemovePoint");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2400039444u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_StartDeploying "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_StartDeploying", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2400039444u, "SERVER_StartDeploying", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2400039444u, "SERVER_StartDeploying", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							SERVER_StartDeploying(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SERVER_StartDeploying");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2702400742u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_StopDeploying "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_StopDeploying", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2702400742u, "SERVER_StopDeploying", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2702400742u, "SERVER_StopDeploying", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							SERVER_StopDeploying(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in SERVER_StopDeploying");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsUsed()
	{
		return HasFlag(Flags.Reserved5);
	}

	public void ClearPoints()
	{
		points.Clear();
	}

	public void AddPoint(Vector3 newPoint, Vector3 newNormal, float slackLevel, bool addFirstPoint = true)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (addFirstPoint && base.isServer && points.Count == 0)
		{
			PointEntry item = default(PointEntry);
			item.point = wireOrigin.position;
			item.normal = newNormal;
			item.slack = slackLevel;
			points.Add(item);
		}
		PointEntry item2 = default(PointEntry);
		item2.point = newPoint;
		item2.normal = newNormal;
		item2.slack = slackLevel;
		points.Add(item2);
	}

	public void RemoveLastPoint()
	{
		points.RemoveAt(points.Count - 1);
		if (points.Count == 1)
		{
			points.Clear();
		}
	}

	public override int ConsumptionAmount()
	{
		return 5;
	}

	protected override int GetPickupCount()
	{
		return Mathf.Max(lengthUsed, 1);
	}

	public void AddLengthUsed(int addLength)
	{
		lengthUsed += addLength;
	}

	public static bool CanPlayerUse(BasePlayer player)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (player.CanBuild())
		{
			return !GamePhysics.CheckSphere(player.eyes.position, 0.1f, 536870912, (QueryTriggerInteraction)2);
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.lightString = Pool.Get<LightString>();
		info.msg.lightString.points = Pool.GetList<StringPoint>();
		info.msg.lightString.lengthUsed = lengthUsed;
		foreach (PointEntry point in points)
		{
			StringPoint val = Pool.Get<StringPoint>();
			val.point = point.point;
			val.normal = point.normal;
			val.slack = point.slack;
			info.msg.lightString.points.Add(val);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.lightString == null)
		{
			return;
		}
		ClearPoints();
		foreach (StringPoint point in info.msg.lightString.points)
		{
			AddPoint(point.point, point.normal, point.slack, addFirstPoint: false);
		}
		lengthUsed = info.msg.lightString.lengthUsed;
	}

	protected Item GetOwnerItem()
	{
		BasePlayer basePlayer = null;
		if (base.isServer)
		{
			basePlayer = usingPlayer;
		}
		if ((Object)(object)basePlayer == (Object)null || (Object)(object)basePlayer.inventory == (Object)null)
		{
			return null;
		}
		return basePlayer.inventory.FindItemByItemID(itemToConsume.itemid);
	}

	public override Item GetItem()
	{
		return GetOwnerItem();
	}

	private bool CheckValidPlacement(Vector3 position, float radius, int layerMask)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		bool result = true;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, radius, list, layerMask, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (item is AnimatedBuildingBlock)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		if (base.isServer)
		{
			lengthUsed = 1;
			PlayerStartsDeploying(deployedBy);
		}
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void SERVER_StartDeploying(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsUsed() && player.CanBuild())
		{
			PlayerStartsDeploying(player);
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.MaxDistance(3f)]
	public void SERVER_StopDeploying(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player.CanBuild())
		{
			PlayerStopsDeploying(player);
		}
	}

	public void PlayerStartsDeploying(BasePlayer player)
	{
		if (!IsUsed() && !((Object)(object)player == (Object)null))
		{
			usingPlayer = player;
			SetFlag(Flags.Reserved5, b: true);
			if (((FacepunchBehaviour)this).IsInvoking((Action)ServerWireDeployingTick))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ServerWireDeployingTick);
			}
			((FacepunchBehaviour)this).InvokeRepeating((Action)ServerWireDeployingTick, 0f, 0f);
			ClientRPC(RpcTarget.Player("CLIENT_StartDeploying", player));
		}
	}

	public void PlayerStopsDeploying(BasePlayer player)
	{
		usingPlayer = null;
		SetFlag(Flags.Reserved5, b: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ServerWireDeployingTick);
		ClientRPC(RpcTarget.Player("CLIENT_StopDeploying", player));
	}

	public void ServerWireDeployingTick()
	{
		if (!usingPlayer.IsValid() || !usingPlayer.IsConnected)
		{
			PlayerStopsDeploying(usingPlayer);
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public void SERVER_AddPoint(RPCMessage msg)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = msg.read.Vector3();
		Vector3 val2 = msg.read.Vector3();
		float num = msg.read.Float();
		BasePlayer player = msg.player;
		if (Vector3Ex.IsNaNOrInfinity(val) || Vector3Ex.IsNaNOrInfinity(val2) || FloatEx.IsNaNOrInfinity(num))
		{
			return;
		}
		Item item = GetItem();
		if (item != null && item.amount >= 1 && CanPlayerUse(player) && !(Vector3.Distance(val, player.eyes.position) > maxPlaceDistance) && CheckValidPlacement(val, 0.1f, 1084293121) && Interface.CallHook("OnPoweredLightsPointAdd", (object)this, (object)player, (object)val, (object)val2) == null)
		{
			int num2 = 1;
			float num3 = 0f;
			Vector3 val3 = ((points.Count > 0) ? points[points.Count - 1].point : wireOrigin.position);
			num3 = Vector3.Distance(val, val3);
			num3 = Mathf.Max(num3, lengthPerAmount);
			float num4 = (float)item.amount * lengthPerAmount;
			if (player.IsInCreativeMode && Creative.unlimitedIo)
			{
				num4 = 200f;
			}
			if (num3 > num4)
			{
				num3 = num4;
				val = val3 + Vector3Ex.Direction(val, val3) * num3;
			}
			num3 = Mathf.Min(num4, num3);
			num2 = Mathf.CeilToInt(num3 / lengthPerAmount);
			if (player.IsInCreativeMode && Creative.unlimitedIo)
			{
				num2 = 0;
			}
			AddPoint(val, val2, num);
			UseItemAmount(num2);
			AddLengthUsed(num2);
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public void SERVER_RemovePoint(RPCMessage msg)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (CanPlayerUse(player) && points.Count != 0)
		{
			Vector3 point = points[points.Count - 1].point;
			Vector3 val = ((Component)this).transform.position;
			if (points.Count > 1)
			{
				val = points[points.Count - 2].point;
			}
			int num = Mathf.CeilToInt(Vector3.Distance(point, val) / lengthPerAmount);
			RemoveLastPoint();
			if (!player.IsInCreativeMode || !Creative.unlimitedIo)
			{
				GiveItemAmount(player, num);
				AddLengthUsed(-num);
			}
			SendNetworkUpdate();
		}
	}

	private void GiveItemAmount(BasePlayer player, int amount)
	{
		if (amount > 0)
		{
			Item ownerItem = GetOwnerItem();
			if (ownerItem == null)
			{
				ownerItem = ItemManager.Create(itemToConsume, amount, 0uL);
				player.GiveItem(ownerItem, GiveItemReason.PickedUp);
			}
			else
			{
				ownerItem.amount += amount;
				ownerItem.MarkDirty();
				ownerItem.ReduceItemOwnership(amount);
			}
		}
	}

	protected void UseItemAmount(int amount)
	{
		if (amount <= 0)
		{
			return;
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			ownerItem.amount -= amount;
			ownerItem.MarkDirty();
			ownerItem.ReduceItemOwnership(amount);
			if (ownerItem.amount <= 0)
			{
				ownerItem.Remove();
			}
		}
	}
}


using UnityEngine;

public struct PointEntry
{
	public Vector3 point;

	public Vector3 normal;

	public float slack;
}


using System;

[Serializable]
public struct BulbSettings
{
	public GameObjectRef BulbPrefab;

	public float Weight;
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class SurveyCrater : BaseCombatEntity
{
	private ResourceDispenser resourceDispenser;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("SurveyCrater.OnRpcMessage", 0);
		try
		{
			if (rpc == 3491246334u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AnalysisComplete "));
				}
				TimeWarning val2 = TimeWarning.New("AnalysisComplete", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						AnalysisComplete(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in AnalysisComplete");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 1800f);
	}

	public override void OnAttacked(HitInfo info)
	{
		_ = base.isServer;
		base.OnAttacked(info);
	}

	public void RemoveMe()
	{
		Kill();
	}

	[RPC_Server]
	public void AnalysisComplete(RPCMessage msg)
	{
		Interface.CallHook("OnAnalysisComplete", (object)this, (object)msg.player);
	}

	public override float BoundsPadding()
	{
		return 2f;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Telephone : ContainerIOEntity, ICassettePlayer
{
	public enum CallState
	{
		Idle,
		Dialing,
		Ringing,
		InProcess
	}

	public enum DialFailReason
	{
		TimedOut,
		Engaged,
		WrongNumber,
		CallSelf,
		RemoteHangUp,
		NetworkBusy,
		TimeOutDuringCall,
		SelfHangUp
	}

	public const int MaxPhoneNameLength = 30;

	public const int MaxSavedNumbers = 10;

	public Transform PhoneHotspot;

	public Transform AnsweringMachineHotspot;

	public Transform[] HandsetRoots;

	public ItemDefinition[] ValidCassettes;

	public Transform ParentedHandsetTransform;

	public LineRenderer CableLineRenderer;

	public Transform CableStartPoint;

	public Transform CableEndPoint;

	public float LineDroopAmount = 0.25f;

	public PhoneController Controller;

	public Cassette cachedCassette { get; private set; }

	public BaseEntity ToBaseEntity => this;

	public uint AnsweringMessageId
	{
		get
		{
			if (!((Object)(object)cachedCassette != (Object)null))
			{
				return 0u;
			}
			return cachedCassette.AudioId;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Telephone.OnRpcMessage", 0);
		try
		{
			if (rpc == 1529322558 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AnswerPhone "));
				}
				TimeWarning val2 = TimeWarning.New("AnswerPhone", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1529322558u, "AnswerPhone", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							AnswerPhone(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AnswerPhone");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2754362156u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearCurrentUser "));
				}
				TimeWarning val2 = TimeWarning.New("ClearCurrentUser", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2754362156u, "ClearCurrentUser", this, player, 9f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ClearCurrentUser(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ClearCurrentUser");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1095090232 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - InitiateCall "));
				}
				TimeWarning val2 = TimeWarning.New("InitiateCall", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1095090232u, "InitiateCall", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							InitiateCall(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in InitiateCall");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2606442785u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_AddSavedNumber "));
				}
				TimeWarning val2 = TimeWarning.New("Server_AddSavedNumber", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2606442785u, "Server_AddSavedNumber", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2606442785u, "Server_AddSavedNumber", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							Server_AddSavedNumber(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in Server_AddSavedNumber");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1402406333 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RemoveSavedNumber "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RemoveSavedNumber", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1402406333u, "Server_RemoveSavedNumber", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1402406333u, "Server_RemoveSavedNumber", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							Server_RemoveSavedNumber(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in Server_RemoveSavedNumber");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 942544266 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestPhoneDirectory "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestPhoneDirectory", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(942544266u, "Server_RequestPhoneDirectory", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(942544266u, "Server_RequestPhoneDirectory", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							Server_RequestPhoneDirectory(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in Server_RequestPhoneDirectory");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1240133378 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerDeleteVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerDeleteVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1240133378u, "ServerDeleteVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1240133378u, "ServerDeleteVoicemail", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							ServerDeleteVoicemail(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in ServerDeleteVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1221129498 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerHangUp "));
				}
				TimeWarning val2 = TimeWarning.New("ServerHangUp", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg9 = rPCMessage;
						ServerHangUp(msg9);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex8)
				{
					Debug.LogException(ex8);
					player.Kick("RPC Error in ServerHangUp");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 239260010 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerPlayVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerPlayVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(239260010u, "ServerPlayVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(239260010u, "ServerPlayVoicemail", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg10 = rPCMessage;
							ServerPlayVoicemail(msg10);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogException(ex9);
						player.Kick("RPC Error in ServerPlayVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 189198880 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerSendVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerSendVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(189198880u, "ServerSendVoicemail", this, player, 5uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg11 = rPCMessage;
							ServerSendVoicemail(msg11);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogException(ex10);
						player.Kick("RPC Error in ServerSendVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2760189029u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerStopVoicemail "));
				}
				TimeWarning val2 = TimeWarning.New("ServerStopVoicemail", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2760189029u, "ServerStopVoicemail", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2760189029u, "ServerStopVoicemail", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg12 = rPCMessage;
							ServerStopVoicemail(msg12);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogException(ex11);
						player.Kick("RPC Error in ServerStopVoicemail");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3900772076u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SetCurrentUser "));
				}
				TimeWarning val2 = TimeWarning.New("SetCurrentUser", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3900772076u, "SetCurrentUser", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage currentUser = rPCMessage;
							SetCurrentUser(currentUser);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex12)
					{
						Debug.LogException(ex12);
						player.Kick("RPC Error in SetCurrentUser");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2760249627u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdatePhoneName "));
				}
				TimeWarning val2 = TimeWarning.New("UpdatePhoneName", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2760249627u, "UpdatePhoneName", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2760249627u, "UpdatePhoneName", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg13 = rPCMessage;
							UpdatePhoneName(msg13);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex13)
					{
						Debug.LogException(ex13);
						player.Kick("RPC Error in UpdatePhoneName");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg?.telephone == null)
		{
			return;
		}
		Controller.PhoneNumber = info.msg.telephone.phoneNumber;
		Controller.PhoneName = info.msg.telephone.phoneName;
		Controller.lastDialedNumber = info.msg.telephone.lastNumber;
		Controller.savedVoicemail = Pool.Get<List<VoicemailEntry>>();
		foreach (VoicemailEntry item in info.msg.telephone.voicemail)
		{
			Controller.savedVoicemail.Add(item);
			item.ShouldPool = false;
		}
		if (!info.fromDisk)
		{
			Controller.currentPlayerRef.uid = info.msg.telephone.usingPlayer;
		}
		PhoneDirectory savedNumbers = Controller.savedNumbers;
		if (savedNumbers != null)
		{
			savedNumbers.ResetToPool();
		}
		Controller.savedNumbers = info.msg.telephone.savedNumbers;
		if (Controller.savedNumbers != null)
		{
			Controller.savedNumbers.ShouldPool = false;
		}
		if (info.fromDisk)
		{
			SetFlag(Flags.Busy, b: false);
		}
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if ((Object)(object)Controller.currentPlayer != (Object)null)
		{
			pickupErrorToFormat = (format: PickupErrors.ItemIsBeingUsed, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer)
		{
			if (Controller.RequirePower && next.HasFlag(Flags.Busy) && !next.HasFlag(Flags.Reserved8))
			{
				Controller.ServerHangUp();
			}
			if (old.HasFlag(Flags.Busy) != next.HasFlag(Flags.Busy))
			{
				if (next.HasFlag(Flags.Busy))
				{
					if (!((FacepunchBehaviour)this).IsInvoking((Action)Controller.WatchForDisconnects))
					{
						((FacepunchBehaviour)this).InvokeRepeating((Action)Controller.WatchForDisconnects, 0f, 0.1f);
					}
				}
				else
				{
					((FacepunchBehaviour)this).CancelInvoke((Action)Controller.WatchForDisconnects);
				}
			}
		}
		Controller.OnFlagsChanged(old, next);
	}

	public override void Save(SaveInfo info)
	{
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.telephone == null)
		{
			info.msg.telephone = Pool.Get<Telephone>();
		}
		info.msg.telephone.phoneNumber = Controller.PhoneNumber;
		info.msg.telephone.phoneName = Controller.PhoneName;
		info.msg.telephone.lastNumber = Controller.lastDialedNumber;
		info.msg.telephone.savedNumbers = Controller.savedNumbers;
		if (Controller.savedVoicemail != null)
		{
			info.msg.telephone.voicemail = Pool.Get<List<VoicemailEntry>>();
			foreach (VoicemailEntry item in Controller.savedVoicemail)
			{
				info.msg.telephone.voicemail.Add(item);
			}
		}
		if (!info.forDisk)
		{
			info.msg.telephone.usingPlayer = Controller.currentPlayerRef.uid;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Controller.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Controller.PostServerLoad();
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Controller.DoServerDestroy();
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(9f)]
	public void ClearCurrentUser(RPCMessage msg)
	{
		Controller.ClearCurrentUser(msg);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void SetCurrentUser(RPCMessage msg)
	{
		Controller.SetCurrentUser(msg);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void InitiateCall(RPCMessage msg)
	{
		Controller.InitiateCall(msg);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void AnswerPhone(RPCMessage msg)
	{
		Controller.AnswerPhone(msg);
	}

	[RPC_Server]
	private void ServerHangUp(RPCMessage msg)
	{
		Controller.ServerHangUp(msg);
	}

	public void OnCassetteInserted(Cassette c)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		cachedCassette = c;
		ClientRPC(RpcTarget.NetworkGroup("ClientOnCassetteChanged"), c.net.ID);
	}

	public void OnCassetteRemoved(Cassette c)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		cachedCassette = null;
		Controller.DeleteAllVoicemail();
		((BaseEntity)this).ClientRPC(RpcTarget.NetworkGroup("ClientOnCassetteChanged"), default(NetworkableId));
	}

	private bool CanAcceptItem(Item item, int targetSlot)
	{
		ItemDefinition[] validCassettes = ValidCassettes;
		for (int i = 0; i < validCassettes.Length; i++)
		{
			if ((Object)(object)validCassettes[i] == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void UpdatePhoneName(RPCMessage msg)
	{
		Controller.UpdatePhoneName(msg);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Server_RequestPhoneDirectory(RPCMessage msg)
	{
		Controller.Server_RequestPhoneDirectory(msg);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Server_AddSavedNumber(RPCMessage msg)
	{
		Controller.Server_AddSavedNumber(msg);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Server_RemoveSavedNumber(RPCMessage msg)
	{
		Controller.Server_RemoveSavedNumber(msg);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	public void ServerSendVoicemail(RPCMessage msg)
	{
		Controller.ServerSendVoicemail(msg);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ServerPlayVoicemail(RPCMessage msg)
	{
		Controller.ServerPlayVoicemail(msg);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void ServerStopVoicemail(RPCMessage msg)
	{
		Controller.ServerStopVoicemail(msg);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ServerDeleteVoicemail(RPCMessage msg)
	{
		Controller.ServerDeleteVoicemail(msg);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (Controller.serverState == CallState.Ringing || Controller.serverState == CallState.InProcess)
		{
			return base.GetPassthroughAmount(outputSlot);
		}
		return 0;
	}
}


public enum CallState
{
	Idle,
	Dialing,
	Ringing,
	InProcess
}


public enum DialFailReason
{
	TimedOut,
	Engaged,
	WrongNumber,
	CallSelf,
	RemoteHangUp,
	NetworkBusy,
	TimeOutDuringCall,
	SelfHangUp
}


using System;
using Network;
using Rust.Demo;
using UnityEngine;

public class ThrownBoomerang : BaseEntity
{
	[Header("References")]
	public ItemDefinition boomerangItem;

	[Header("Settings")]
	public float timeToReturnOnArc = 3f;

	public float secondsUntilStartArc = 0.9f;

	public float lerpSpeed = 20f;

	private const float CATCH_DISTANCE = 1.5f;

	private const float HOMING_TO_PLAYER_DISTANCE = 6f;

	private Vector3 lastMoveDirection;

	private Vector3 gravityVelocity = Vector3.zero;

	private bool calculated;

	private float returnTimer;

	private float timeToReturn;

	private Vector3 startLocation;

	private Vector3 midLocation;

	private Vector3 endLocation;

	private Vector3 spawnLocation = Vector3.zero;

	private ThrownBoomerangServerProjectile projectile;

	private BasePlayer creatorPlayer;

	private Boomerang originEntityItem;

	[NonSerialized]
	public ItemOwnershipShare ItemOwnership;

	[NonSerialized]
	public float Condition;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ThrownBoomerang.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private void DoBoomerangMove()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		if (Reader.IsActive && Reader.Active.IsScrubbing)
		{
			return;
		}
		float deltaTime = Time.deltaTime;
		float num = 15f;
		Vector3 val;
		if (!calculated)
		{
			returnTimer = 0f;
			startLocation = ((Component)this).transform.position;
			endLocation = spawnLocation;
			endLocation += Vector3.up * 1.2f;
			val = endLocation - startLocation;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			Vector3 val2 = Vector3.Cross(Vector3.up, normalized);
			midLocation = (startLocation + endLocation) / 2f;
			midLocation += val2 * num;
			if (base.isServer)
			{
				projectile.ProjectileHandleMovement(state: false);
			}
			calculated = true;
		}
		BasePlayer basePlayer = null;
		if (base.isServer)
		{
			basePlayer = creatorPlayer;
		}
		if ((Object)(object)basePlayer != (Object)null && Vector3.Distance(((Component)basePlayer).transform.position, spawnLocation) <= 6f && IsValidPlayer(basePlayer))
		{
			endLocation = ((Component)basePlayer).transform.position;
			endLocation += Vector3.up * 1.5f;
			val = endLocation - startLocation;
			Vector3 normalized2 = ((Vector3)(ref val)).normalized;
			Vector3 val3 = Vector3.Cross(Vector3.up, normalized2);
			midLocation = (startLocation + endLocation) / 2f;
			midLocation += val3 * num;
		}
		float num2 = returnTimer / timeToReturnOnArc;
		Vector3 val4 = FakePhysicsRope.GetRationalBezierPoint(startLocation, midLocation, endLocation, Mathf.Clamp01(num2));
		if (num2 >= 1f)
		{
			gravityVelocity += Vector3.down * 9.81f * deltaTime;
			lastMoveDirection += gravityVelocity * deltaTime;
			val4 = ((Component)this).transform.position + lastMoveDirection;
		}
		else if (num2 > 0.95f)
		{
			val4 += Vector3.down * 0.03f;
		}
		Vector3 val5 = val4 - ((Component)this).transform.position;
		if (val5 != Vector3.zero && base.isServer)
		{
			projectile.SetVelocity(val5);
			((Component)this).transform.rotation = Quaternion.Slerp(((Component)this).transform.rotation, Quaternion.LookRotation(((Vector3)(ref val5)).normalized), deltaTime * 2f);
		}
		((Component)this).transform.position = Vector3.MoveTowards(((Component)this).transform.position, val4, deltaTime * lerpSpeed);
		if (num2 <= 1f)
		{
			lastMoveDirection = val5;
		}
		returnTimer += deltaTime;
	}

	private bool IsValidPlayer(BasePlayer ply)
	{
		if ((Object)(object)ply == (Object)null)
		{
			return false;
		}
		if (ply.IsDead())
		{
			return false;
		}
		if (ply.IsSleeping())
		{
			return false;
		}
		return true;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (base.isClient)
		{
			return;
		}
		spawnLocation = ((Component)this).transform.position;
		projectile = ((Component)this).GetComponent<ThrownBoomerangServerProjectile>();
		if (Object.op_Implicit((Object)(object)projectile))
		{
			projectile.InitializeVelocity(((Component)this).transform.forward * projectile.speed);
			projectile.ProjectileHandleMovement(state: true);
			projectile.SetStartPosition(spawnLocation);
			((FacepunchBehaviour)this).InvokeRepeating((Action)DoBoomerangMove, secondsUntilStartArc, 0f);
			if (!(creatorEntity is BasePlayer basePlayer))
			{
				return;
			}
			creatorPlayer = basePlayer;
			base.OwnerID = creatorPlayer.userID;
			creatorEntity = creatorPlayer;
			Item activeItem = creatorPlayer.GetActiveItem();
			if (activeItem != null)
			{
				if (activeItem.GetHeldEntity() is Boomerang boomerang)
				{
					originEntityItem = boomerang;
				}
				ItemOwnership = activeItem.TakeOwnershipShare();
			}
			((FacepunchBehaviour)this).Invoke((Action)LateRPC, 0.1f);
			((FacepunchBehaviour)this).InvokeRepeating((Action)CheckReturnToHand, secondsUntilStartArc, 0f);
		}
		else
		{
			KillThrownBoomerang();
		}
	}

	private void LateRPC()
	{
		Item activeItem = creatorPlayer.GetActiveItem();
		if (activeItem != null && activeItem.GetHeldEntity() is Boomerang)
		{
			ClientRPC(RpcTarget.Player("SetClientPlayer", creatorPlayer), activeItem.uid.Value);
		}
	}

	public void CreateWorldModel(HitInfo info, Vector3 attackDir)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Max(projectile.scanRange, projectile.radius);
		num /= 2f;
		Item item = ItemManager.Create(boomerangItem, 1, 0uL);
		BaseEntity baseEntity = null;
		bool flag = false;
		if ((Object)(object)info.HitEntity == (Object)null || !info.HitEntity.IsValid())
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld + -attackDir * num * 0.3f, Quaternion.LookRotation(-attackDir));
			flag = info.HitMaterial != Projectile.WaterMaterialID();
			if (!info.HitEntity.IsValid())
			{
				flag = false;
			}
		}
		else if (info.HitBone == 0)
		{
			Vector3 hitPositionLocal = info.HitPositionLocal;
			baseEntity = item.CreateWorldObject(hitPositionLocal, Quaternion.LookRotation(((Component)info.HitEntity).transform.InverseTransformDirection(((Vector3)(ref attackDir)).normalized)), info.HitEntity);
			flag = false;
		}
		else
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(((Component)info.HitEntity).transform.InverseTransformDirection(((Vector3)(ref attackDir)).normalized)));
			flag = false;
		}
		if (flag)
		{
			DroppedItem droppedItem = baseEntity as DroppedItem;
			if ((Object)(object)droppedItem != (Object)null)
			{
				droppedItem.StickIn();
			}
			else
			{
				((Component)baseEntity).GetComponent<Rigidbody>().isKinematic = true;
			}
		}
		else
		{
			((Component)baseEntity).GetComponent<Rigidbody>().AddTorque(((Vector3)(ref attackDir)).normalized * Random.Range(5f, 10f), (ForceMode)1);
		}
		item.condition = Condition;
		item.SetItemOwnership(ItemOwnership);
		baseEntity.OwnerID = base.OwnerID;
		baseEntity.creatorEntity = creatorEntity;
	}

	public void OnHit()
	{
		if ((Object)(object)originEntityItem != (Object)null)
		{
			Item item = originEntityItem.GetItem();
			if (item != null)
			{
				float num = item.maxCondition * 0.1f;
				Condition -= num;
				item.UseItem();
				item.SetParent(null);
			}
		}
	}

	private void KillThrownBoomerang()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)CheckReturnToHand);
		Kill();
	}

	public void CheckReturnToHand()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)creatorPlayer == (Object)null) && !creatorPlayer.IsDead() && !creatorPlayer.IsSleeping() && Vector3.Distance(((Component)creatorPlayer).transform.position, ((Component)this).transform.position) <= 1.5f)
		{
			Item activeItem = creatorPlayer.GetActiveItem();
			if (activeItem != null && activeItem.GetHeldEntity() is Boomerang { HasThrown: not false } boomerang && !((Object)(object)boomerang != (Object)(object)originEntityItem))
			{
				boomerang.SetHasThrown(thrown: false);
				KillThrownBoomerang();
			}
		}
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class ThrownWeapon : AttackEntity
{
	[Header("Throw Weapon")]
	public GameObjectRef prefabToThrow;

	public float maxThrowVelocity = 10f;

	public float tumbleVelocity;

	public Vector3 overrideAngle = Vector3.zero;

	public bool canStick = true;

	public bool canThrowUnderwater = true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ThrownWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 1513023343 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoDrop "));
				}
				TimeWarning val2 = TimeWarning.New("DoDrop", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1513023343u, "DoDrop", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoDrop(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoDrop");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1974840882 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoThrow "));
				}
				TimeWarning val2 = TimeWarning.New("DoThrow", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1974840882u, "DoThrow", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							DoThrow(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in DoThrow");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return player.GetInheritedThrowVelocity(direction);
	}

	public void ServerThrow(Vector3 targetPosition)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || !HasItemAmount() || HasAttackCooldown())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null || (!canThrowUnderwater && ownerPlayer.IsHeadUnderwater()))
		{
			return;
		}
		Vector3 position = ownerPlayer.eyes.position;
		Vector3 val = ownerPlayer.eyes.BodyForward();
		float num = 1f;
		SignalBroadcast(Signal.Throw, string.Empty);
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, position, Quaternion.LookRotation((overrideAngle == Vector3.zero) ? (-val) : overrideAngle));
		if ((Object)(object)baseEntity == (Object)null)
		{
			return;
		}
		baseEntity.SetCreatorEntity(ownerPlayer);
		Vector3 val2 = val + Quaternion.AngleAxis(10f, Vector3.right) * Vector3.up;
		float num2 = GetThrowVelocity(position, targetPosition, val2);
		if (float.IsNaN(num2))
		{
			val2 = val + Quaternion.AngleAxis(20f, Vector3.right) * Vector3.up;
			num2 = GetThrowVelocity(position, targetPosition, val2);
			if (float.IsNaN(num2))
			{
				num2 = 5f;
			}
		}
		baseEntity.SetVelocity(val2 * num2 * num);
		if (tumbleVelocity > 0f)
		{
			baseEntity.SetAngularVelocity(new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f)) * tumbleVelocity);
		}
		baseEntity.Spawn();
		StartAttackCooldown(repeatDelay);
		UseItemAmount(1);
		if ((Object)(object)(baseEntity as TimedExplosive) != (Object)null)
		{
			Analytics.Azure.OnExplosiveLaunched(ownerPlayer, baseEntity);
		}
	}

	private float GetThrowVelocity(Vector3 throwPos, Vector3 targetPos, Vector3 aimDir)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = targetPos - throwPos;
		Vector2 val2 = new Vector2(val.x, val.z);
		float magnitude = ((Vector2)(ref val2)).magnitude;
		float y = val.y;
		val2 = new Vector2(aimDir.x, aimDir.z);
		float magnitude2 = ((Vector2)(ref val2)).magnitude;
		float y2 = aimDir.y;
		float y3 = Physics.gravity.y;
		return Mathf.Sqrt(0.5f * y3 * magnitude * magnitude / (magnitude2 * (magnitude2 * y - y2 * magnitude)));
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoThrow(RPCMessage msg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		if (!HasItemAmount() || HasAttackCooldown())
		{
			return;
		}
		Vector3 val = msg.read.Vector3();
		Vector3 val2 = msg.read.Vector3();
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		float num = Mathf.Clamp01(msg.read.Float());
		if (Vector3Ex.IsNaNOrInfinity(normalized) || FloatEx.IsNaNOrInfinity(num))
		{
			return;
		}
		if (msg.player.isMounted || msg.player.HasParent())
		{
			val = msg.player.eyes.position;
		}
		else if (!ValidateEyePos(msg.player, val))
		{
			return;
		}
		if (!canThrowUnderwater && msg.player.IsHeadUnderwater())
		{
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, val, Quaternion.LookRotation((overrideAngle == Vector3.zero) ? (-normalized) : overrideAngle));
		if (!((Object)(object)baseEntity == (Object)null))
		{
			Item ownerItem = GetOwnerItem();
			if (ownerItem != null && ownerItem.instanceData != null && ownerItem.HasFlag(Item.Flag.IsOn))
			{
				((Component)baseEntity).gameObject.SendMessage("SetFrequency", (object)GetOwnerItem().instanceData.dataInt, (SendMessageOptions)1);
			}
			baseEntity.SetCreatorEntity(msg.player);
			baseEntity.skinID = skinID;
			baseEntity.SetVelocity(GetInheritedVelocity(msg.player, normalized) + normalized * maxThrowVelocity * num + msg.player.estimatedVelocity * 0.5f);
			if (tumbleVelocity > 0f)
			{
				baseEntity.SetAngularVelocity(new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f)) * tumbleVelocity);
			}
			baseEntity.Spawn();
			if (baseEntity is TimedExplosive timedExplosive)
			{
				ItemOwnershipShare itemOwnership = ownerItem.TakeOwnershipShare();
				timedExplosive.ItemOwnership = itemOwnership;
				timedExplosive.SetCreator(msg.player);
			}
			SetUpThrownWeapon(baseEntity);
			StartAttackCooldown(repeatDelay);
			Interface.CallHook("OnExplosiveThrown", (object)msg.player, (object)baseEntity, (object)this);
			UseItemAmount(1, reduceItemOwnership: false);
		}
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void DoDrop(RPCMessage msg)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		if (!HasItemAmount() || HasAttackCooldown() || (!canThrowUnderwater && msg.player.IsHeadUnderwater()))
		{
			return;
		}
		Vector3 val = msg.read.Vector3();
		Vector3 val2 = msg.read.Vector3();
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		if (msg.player.isMounted || msg.player.HasParent())
		{
			val = msg.player.eyes.position;
		}
		else if (!ValidateEyePos(msg.player, val))
		{
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, val, Quaternion.LookRotation(Vector3.up));
		if ((Object)(object)baseEntity == (Object)null)
		{
			return;
		}
		RaycastHit hit = default(RaycastHit);
		if (canStick && Physics.SphereCast(new Ray(val, normalized), 0.05f, ref hit, 1.5f, 1237003025))
		{
			Vector3 point = ((RaycastHit)(ref hit)).point;
			Vector3 normal = ((RaycastHit)(ref hit)).normal;
			BaseEntity entity = hit.GetEntity();
			Collider collider = ((RaycastHit)(ref hit)).collider;
			if (Object.op_Implicit((Object)(object)entity) && entity is StabilityEntity && baseEntity is TimedExplosive)
			{
				entity = entity.ToServer<BaseEntity>();
				TimedExplosive timedExplosive = baseEntity as TimedExplosive;
				timedExplosive.onlyDamageParent = true;
				timedExplosive.DoStick(point, normal, entity, collider);
				Analytics.Azure.OnExplosiveLaunched(msg.player, timedExplosive);
			}
			else
			{
				baseEntity.SetVelocity(normalized);
			}
		}
		else
		{
			baseEntity.SetVelocity(normalized);
		}
		baseEntity.creatorEntity = msg.player;
		baseEntity.skinID = skinID;
		baseEntity.Spawn();
		SetUpThrownWeapon(baseEntity);
		StartAttackCooldown(repeatDelay);
		Interface.CallHook("OnExplosiveDropped", (object)msg.player, (object)baseEntity, (object)this);
		UseItemAmount(1);
	}

	protected virtual void SetUpThrownWeapon(BaseEntity ent)
	{
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class TimerSwitch : IOEntity
{
	public float timerLength = 10f;

	public Transform timerDrum;

	private float timePassed;

	private float input1Amount;

	private float serverStartTime = -1f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TimerSwitch.OnRpcMessage", 0);
		try
		{
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SVSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SVSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4167839872u, "SVSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SVSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SVSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public float GetPassedTime()
	{
		return timePassed;
	}

	public override void ResetIOState()
	{
		base.ResetIOState();
		SetFlag(Flags.On, b: false);
		if (((FacepunchBehaviour)this).IsInvoking((Action)AdvanceTime))
		{
			EndTimer();
		}
	}

	public override bool WantsPassthroughPower()
	{
		if (IsPowered())
		{
			return IsOn();
		}
		return false;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsPowered() || !IsOn())
		{
			return 0;
		}
		return base.GetPassthroughAmount(outputSlot);
	}

	public override bool WantsPower(int inputIndex)
	{
		return inputIndex == 0;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		switch (inputSlot)
		{
		case 0:
			base.UpdateFromInput(inputAmount, inputSlot);
			if (IsPowered())
			{
				if (timePassed != 0f && !((FacepunchBehaviour)this).IsInvoking((Action)AdvanceTime))
				{
					SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
					SwitchPressed();
				}
			}
			else if (((FacepunchBehaviour)this).IsInvoking((Action)AdvanceTime))
			{
				EndTimer();
				SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
				SendNetworkUpdate_Flags();
			}
			break;
		case 1:
			if (input1Amount != (float)inputAmount)
			{
				if (inputAmount > 0)
				{
					SwitchPressed();
				}
				input1Amount = inputAmount;
			}
			break;
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SVSwitch(RPCMessage msg)
	{
		SwitchPressed();
	}

	public void SwitchPressed()
	{
		if (!IsOn() && IsPowered())
		{
			StartTimer();
			SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
			MarkDirty();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (timePassed == 0f)
		{
			if (IsOn())
			{
				SetFlag(Flags.On, b: false);
			}
		}
		else
		{
			SwitchPressed();
		}
	}

	public void AdvanceTime()
	{
		if (timePassed < 0f)
		{
			timePassed = 0f;
		}
		timePassed = Time.realtimeSinceStartup - serverStartTime;
		if (timePassed >= timerLength)
		{
			EndTimer();
		}
	}

	public void StartTimer()
	{
		serverStartTime = Time.realtimeSinceStartup;
		timePassed = 0f;
		((FacepunchBehaviour)this).InvokeRepeating((Action)AdvanceTime, 0f, 0.1f);
	}

	public void EndTimer()
	{
		serverStartTime = 0f;
		timePassed = 0f;
		((FacepunchBehaviour)this).CancelInvoke((Action)AdvanceTime);
		SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
		MarkDirty();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.ioEntity.genericFloat1 = GetPassedTime();
		info.msg.ioEntity.genericFloat2 = timerLength;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			timePassed = info.msg.ioEntity.genericFloat1;
			timerLength = info.msg.ioEntity.genericFloat2;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class TinCanAlarm : DecayEntity, IDetector
{
	[Space]
	public LineRenderer lineRenderer;

	public Transform wireOrigin;

	public Transform wireOriginClient;

	public PlayerDetectionTrigger trigger;

	public Transform wireEndCollider;

	public GroundWatch groundWatch;

	public GroundWatch wireGroundWatch;

	public Animator animator;

	[Space]
	public SoundDefinition alarmSoundDef;

	public SoundDefinition armSoundDef;

	public Vector3 endPoint;

	private const Flags Flag_Used = Flags.Reserved5;

	public BaseEntity lastTriggerEntity;

	public float lastTriggerTime;

	private BasePlayer usingPlayer;

	[Space]
	public float maxWireLength = 10f;

	private const int WIRE_PLACEMENT_LAYER = 1084293377;

	public Transform WireOrigin
	{
		get
		{
			_ = base.isServer;
			return wireOrigin;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TinCanAlarm.OnRpcMessage", 0);
		try
		{
			if (rpc == 3384266798u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_SetEndPoint "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_SetEndPoint", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_SetEndPoint(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_SetEndPoint");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3516830045u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_StartArming "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_StartArming", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3516830045u, "SERVER_StartArming", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_StartArming(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_StartArming");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3508772935u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_StopArming "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_StopArming", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg4 = rPCMessage;
						SERVER_StopArming(msg4);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex3)
				{
					Debug.LogException(ex3);
					player.Kick("RPC Error in SERVER_StopArming");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsUsed()
	{
		return HasFlag(Flags.Reserved5);
	}

	private bool IsArmed()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return endPoint != Vector3.zero;
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (base.ShouldDisplayPickupOption(player))
		{
			return (Object)(object)player.GetBuildingPrivilege() != (Object)null;
		}
		return false;
	}

	public bool ShouldTrigger()
	{
		return IsArmed();
	}

	public void OnObjects()
	{
	}

	public void OnObjectAdded(GameObject obj, Collider col)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = obj.ToBaseEntity();
		if (!((Object)(object)baseEntity != (Object)null))
		{
			return;
		}
		if (baseEntity is BuildingBlock && IsGoingThroughWalls(endPoint))
		{
			CutWire();
			return;
		}
		if (baseEntity is BasePlayer { isMounted: not false } basePlayer)
		{
			baseEntity = basePlayer.GetMounted();
		}
		else
		{
			BaseEntity baseEntity2 = baseEntity.GetParentEntity();
			if ((Object)(object)baseEntity2 != (Object)null)
			{
				baseEntity = baseEntity2;
			}
		}
		if ((!(Time.realtimeSinceStartup - lastTriggerTime < 1f) || !((Object)(object)baseEntity == (Object)(object)lastTriggerEntity)) && (baseEntity is BasePlayer || baseEntity is Door || baseEntity is BaseNpc || baseEntity is BaseVehicle || baseEntity is Elevator || baseEntity is Lift))
		{
			lastTriggerTime = Time.realtimeSinceStartup;
			lastTriggerEntity = baseEntity;
			TriggerAlarm();
		}
	}

	public void OnEmpty()
	{
	}

	public void TriggerAlarm()
	{
		ClientRPC(RpcTarget.NetworkGroup("RPC_TriggerAlarm"));
	}

	public void ServerOnWireDeploying()
	{
		if (!usingPlayer.IsValid() || !usingPlayer.IsConnected)
		{
			PlayerStopsArming(usingPlayer);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void SERVER_StartArming(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsUsed() && player.CanBuild())
		{
			PlayerStartsArming(player);
		}
	}

	[RPC_Server]
	public void SERVER_StopArming(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player.CanBuild())
		{
			PlayerStopsArming(player);
		}
	}

	public void PlayerStartsArming(BasePlayer player)
	{
		if (!IsUsed() && !((Object)(object)player == (Object)null))
		{
			usingPlayer = player;
			SetFlag(Flags.Reserved5, b: true);
			if (((FacepunchBehaviour)this).IsInvoking((Action)ServerOnWireDeploying))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ServerOnWireDeploying);
			}
			((FacepunchBehaviour)this).InvokeRepeating((Action)ServerOnWireDeploying, 0f, 0f);
			ClientRPC(RpcTarget.Player("CLIENT_StartArming", player));
		}
	}

	public void PlayerStopsArming(BasePlayer player)
	{
		usingPlayer = null;
		SetFlag(Flags.Reserved5, b: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ServerOnWireDeploying);
		ClientRPC(RpcTarget.Player("CLIENT_StopArming", player));
	}

	public void CutWire()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TriggerAlarm();
		endPoint = Vector3.zero;
		SendNetworkUpdate();
	}

	private void UpdateWireTip()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			if (!IsArmed())
			{
				ComponentExtensions.SetActive<Transform>(wireEndCollider, false);
				return;
			}
			wireEndCollider.position = endPoint;
			ComponentExtensions.SetActive<Transform>(wireEndCollider, true);
		}
	}

	private void OnGroundMissing()
	{
		if (!base.IsDestroyed && !base.isClient)
		{
			if (!groundWatch.OnGround())
			{
				Kill(DestroyMode.Gib);
			}
			else if (!wireGroundWatch.OnGround())
			{
				CutWire();
			}
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		if (base.isServer)
		{
			PlayerStartsArming(deployedBy);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (info.hasDamage && !info.damageTypes.Has(DamageType.Heat))
		{
			TriggerAlarm();
		}
	}

	private void UpdateTrigger()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		if (!IsArmed())
		{
			ComponentExtensions.SetActive<PlayerDetectionTrigger>(trigger, false);
			return;
		}
		ComponentExtensions.SetActive<PlayerDetectionTrigger>(trigger, true);
		Vector3 position = wireOrigin.position;
		Vector3 val = endPoint;
		Vector3 position2 = (position + val) / 2f;
		Vector3 val2 = val - position;
		float magnitude = ((Vector3)(ref val2)).magnitude;
		((Component)trigger).transform.position = position2;
		Vector3 localScale = ((Component)trigger).transform.localScale;
		localScale.z = magnitude;
		((Component)trigger).transform.rotation = Quaternion.LookRotation(val2);
		((Component)trigger).transform.localScale = new Vector3(0.15f, 0.15f, localScale.z);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.tinCanAlarm = Pool.Get<TinCanAlarm>();
		info.msg.tinCanAlarm.endPoint = endPoint;
		UpdateTrigger();
		UpdateWireTip();
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.tinCanAlarm != null)
		{
			endPoint = info.msg.tinCanAlarm.endPoint;
			UpdateTrigger();
			if (info.fromDisk && !usingPlayer.IsValid())
			{
				PlayerStopsArming(usingPlayer);
			}
		}
	}

	[RPC_Server]
	public void RPC_SetEndPoint(RPCMessage msg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		Vector3 val = msg.read.Vector3();
		if (player.CanBuild() && player.IsVisibleAndCanSee(val) && !IsGoingThroughWalls(val) && IsInValidVolume(val) && IsOnValidEntities(val) && !(Vector3.Distance(wireOrigin.position, val) > maxWireLength))
		{
			endPoint = val;
			SendNetworkUpdate();
			PlayerStopsArming(player);
		}
	}

	private bool IsGoingThroughWalls(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		float maxDistance = Vector3.Distance(wireOrigin.position, position);
		Vector3 val = position - wireOrigin.position;
		RaycastHit hitInfo;
		bool flag = GamePhysics.Trace(new Ray(wireOrigin.position, val), 0f, out hitInfo, maxDistance, 1218519297, (QueryTriggerInteraction)1, this);
		if (!flag)
		{
			flag = GamePhysics.Trace(new Ray(position, -val), 0f, out var _, maxDistance, 1218519297, (QueryTriggerInteraction)1, this);
		}
		return flag;
	}

	private bool IsInValidVolume(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(position, 0.1f, list, 536870912, (QueryTriggerInteraction)2);
		bool result = true;
		foreach (Collider item in list)
		{
			if (((Component)item).gameObject.HasCustomTag(GameObjectTag.BlockPlacement))
			{
				result = false;
				break;
			}
			if (!((Object)(object)item.GetMonument() != (Object)null))
			{
				ColliderInfo component = ((Component)item).GetComponent<ColliderInfo>();
				if (!((Object)(object)component != (Object)null) || !component.HasFlag(ColliderInfo.Flags.Tunnels))
				{
					result = false;
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private bool IsOnValidEntities(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, 0.1f, list, 1084293377, (QueryTriggerInteraction)2);
		bool result = true;
		foreach (BaseEntity item in list)
		{
			if (item is AnimatedBuildingBlock || item is ElevatorLift || item is Elevator)
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return result;
	}
}


using System;
using Network;
using UnityEngine;

public class Toolgun : Hammer
{
	public GameObjectRef attackEffect;

	public GameObjectRef beamEffect;

	public GameObjectRef beamImpactEffect;

	public GameObjectRef errorEffect;

	public GameObjectRef beamEffectClassic;

	public GameObjectRef beamImpactEffectClassic;

	public Transform muzzlePoint;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Toolgun.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void DoAttackShared(HitInfo info)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			ClientRPC(RpcTarget.NetworkGroup("EffectSpawn"), info.HitPositionWorld, info.HitNormalWorld);
		}
		base.DoAttackShared(info);
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class TorchDeployableLightSource : StorageContainer, ISplashable, IIgniteable, IAlwaysOn
{
	public ItemDefinition[] AllowedTorches;

	public Transform TorchRoot;

	public const Flags HasTorch = Flags.Reserved1;

	public const Flags UseBuiltInFx = Flags.Reserved2;

	public const Flags AlwaysOn = Flags.Reserved3;

	public ItemDefinition[] BuiltInFxItems = new ItemDefinition[0];

	private EntityRef<TorchWeapon> spawnedTorch;

	private ItemDefinition spawnedTorchDef;

	private Item CurrentTorch => base.inventory.GetSlot(0);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TorchDeployableLightSource.OnRpcMessage", 0);
		try
		{
			if (rpc == 3305620958u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestTurnOnOff "));
				}
				TimeWarning val2 = TimeWarning.New("RequestTurnOnOff", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3305620958u, "RequestTurnOnOff", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RequestTurnOnOff(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RequestTurnOnOff");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		ItemDefinition[] allowedTorches = AllowedTorches;
		for (int i = 0; i < allowedTorches.Length; i++)
		{
			if ((Object)(object)allowedTorches[i] == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	private bool ShouldUseBuiltInFx(ItemDefinition def)
	{
		if ((Object)(object)def == (Object)null)
		{
			return false;
		}
		ItemDefinition[] builtInFxItems = BuiltInFxItems;
		for (int i = 0; i < builtInFxItems.Length; i++)
		{
			if ((Object)(object)builtInFxItems[i] == (Object)(object)def)
			{
				return true;
			}
		}
		return false;
	}

	private void UpdateTorch()
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		Item item = CurrentTorch;
		if (item != null && item.isBroken)
		{
			item = null;
		}
		ItemDefinition itemDefinition = item?.info;
		if ((Object)(object)itemDefinition != (Object)(object)spawnedTorchDef)
		{
			spawnedTorchDef = itemDefinition;
			SetFlag(Flags.Reserved2, ShouldUseBuiltInFx(itemDefinition), recursive: false, networkupdate: false);
			TorchWeapon torchWeapon = spawnedTorch.Get(serverside: true);
			if ((Object)(object)torchWeapon != (Object)null)
			{
				torchWeapon.Kill();
			}
			spawnedTorch.Set(null);
			if ((Object)(object)itemDefinition != (Object)null)
			{
				TorchWeapon component = ((Component)GameManager.server.CreateEntity(((Component)itemDefinition).GetComponent<ItemModEntity>().entityPrefab.resourcePath, TorchRoot.position, TorchRoot.rotation)).GetComponent<TorchWeapon>();
				component.SetParent(this, worldPositionStays: true);
				component.SetFlag(Flags.Reserved1, b: true);
				component.Spawn();
				spawnedTorch.Set(component);
			}
			else
			{
				SetFlag(Flags.On, b: false);
			}
		}
		SetFlag(Flags.Reserved1, (Object)(object)spawnedTorch.Get(serverside: true) != (Object)null);
		if (!HasFlag(Flags.Reserved1) && ((FacepunchBehaviour)this).IsInvoking((Action)TickTorchDurability))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TickTorchDurability);
		}
	}

	private void TickTorchDurability()
	{
		Item currentTorch = CurrentTorch;
		if (currentTorch != null && !IsAlwaysOn())
		{
			currentTorch.LoseCondition(1f / 12f);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		foreach (BaseEntity child in children)
		{
			if (child is TorchWeapon torchWeapon)
			{
				spawnedTorch.Set(torchWeapon);
				torchWeapon.SetFlag(Flags.On, IsOn());
				break;
			}
		}
		if (HasFlag(Flags.Reserved1) && IsOn())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)TickTorchDurability, 1f, 1f);
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		UpdateTorch();
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RequestTurnOnOff(RPCMessage msg)
	{
		bool wantsOn = msg.read.Bit();
		TryToggle(wantsOn);
	}

	private void TryToggle(bool wantsOn)
	{
		if (CurrentTorch == null)
		{
			return;
		}
		TorchWeapon torchWeapon = spawnedTorch.Get(serverside: true);
		if (!((Object)(object)torchWeapon == (Object)null))
		{
			torchWeapon.SetFlag(Flags.On, wantsOn);
			SetFlag(Flags.On, wantsOn);
			if (HasFlag(Flags.Reserved1) && wantsOn)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)TickTorchDurability, 1f, 1f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)TickTorchDurability);
			}
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if (HasFlag(Flags.Reserved1))
		{
			return IsOn();
		}
		return false;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		TryToggle(wantsOn: false);
		return 10;
	}

	public void Ignite(Vector3 fromPos)
	{
		TryToggle(wantsOn: true);
	}

	public bool CanIgnite()
	{
		if (HasFlag(Flags.Reserved1))
		{
			return !IsOn();
		}
		return false;
	}

	public virtual bool IsAlwaysOn()
	{
		if (HasFlag(Flags.Reserved3))
		{
			return Creative.alwaysOnEnabled;
		}
		return false;
	}

	public void SetAlwaysOn(bool flag)
	{
		SetFlag(Flags.Reserved3, flag);
		AlwaysOnToggled(flag);
	}

	public void AlwaysOnToggled(bool flag)
	{
		if (flag)
		{
			if (AllowedTorches == null || AllowedTorches.Length == 0 || base.inventory == null)
			{
				return;
			}
			if (!HasFlag(Flags.Reserved1))
			{
				ItemDefinition itemDefinition = AllowedTorches[0];
				if ((Object)(object)itemDefinition == (Object)null)
				{
					return;
				}
				ItemManager.Create(itemDefinition, 1, 0uL).MoveToContainer(base.inventory, 0, allowStack: false);
			}
		}
		TryToggle(flag);
	}
}


using System;
using ConVar;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class TorchWeapon : BaseMelee
{
	[NonSerialized]
	public const float FuelTickAmount = 1f / 12f;

	[Header("TorchWeapon")]
	public AnimatorOverrideController LitHoldAnimationOverride;

	public bool ExtinguishUnderwater = true;

	public bool UseTurnOnOffAnimations;

	public GameObjectRef litStrikeFX;

	public const Flags IsInHolder = Flags.Reserved1;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TorchWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 2235491565u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Extinguish "));
				}
				TimeWarning val2 = TimeWarning.New("Extinguish", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(2235491565u, "Extinguish", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Extinguish(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Extinguish");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3010584743u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Ignite "));
				}
				TimeWarning val2 = TimeWarning.New("Ignite", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(3010584743u, "Ignite", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Ignite(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Ignite");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void GetAttackStats(HitInfo info)
	{
		base.GetAttackStats(info);
		if (HasFlag(Flags.On))
		{
			info.damageTypes.Add(DamageType.Heat, 1f);
		}
	}

	public override float GetConditionLoss()
	{
		return base.GetConditionLoss() + (HasFlag(Flags.On) ? 6f : 0f);
	}

	public void SetIsOn(bool isOn)
	{
		if (isOn)
		{
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.OnFire, b: true);
			((FacepunchBehaviour)this).InvokeRepeating((Action)UseFuel, 1f, 1f);
		}
		else
		{
			SetFlag(Flags.On, b: false);
			SetFlag(Flags.OnFire, b: false);
			((FacepunchBehaviour)this).CancelInvoke((Action)UseFuel);
		}
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void Ignite(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			SetIsOn(isOn: true);
		}
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Extinguish(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			SetIsOn(isOn: false);
		}
	}

	public void UseFuel()
	{
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			ownerItem.LoseCondition(1f / 12f);
			SingletonComponent<NpcFireManager>.Instance.Move(this);
		}
	}

	public override void OnHeldChanged()
	{
		if (IsDisabled())
		{
			SetIsOn(isOn: false);
		}
	}

	public override string GetStrikeEffectPath(string materialName)
	{
		for (int i = 0; i < materialStrikeFX.Count; i++)
		{
			if (materialStrikeFX[i].materialName == materialName && materialStrikeFX[i].fx.isValid)
			{
				return materialStrikeFX[i].fx.resourcePath;
			}
		}
		if (HasFlag(Flags.On) && litStrikeFX.isValid)
		{
			return litStrikeFX.resourcePath;
		}
		return strikeFX.resourcePath;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

public class TrainCar : BaseVehicle, ITrainCollidable, IPrefabPreProcess, TriggerHurtNotChild.IHurtTriggerUser, TrainTrackSpline.ITrainTrackUser
{
	public enum TrainCarType
	{
		Wagon,
		Engine,
		Other
	}

	[SerializeField]
	[Header("Train Car")]
	public float corpseSeconds = 60f;

	[SerializeField]
	public TriggerTrainCollisions frontCollisionTrigger;

	[SerializeField]
	public TriggerTrainCollisions rearCollisionTrigger;

	[SerializeField]
	public float collisionDamageDivide = 100000f;

	[SerializeField]
	public float derailCollisionForce = 130000f;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerFront;

	[SerializeField]
	public TriggerHurtNotChild hurtTriggerRear;

	[SerializeField]
	private GameObject[] hurtOrRepelTriggersInternal;

	[SerializeField]
	public float hurtTriggerMinSpeed = 1f;

	[SerializeField]
	public Transform centreOfMassTransform;

	[SerializeField]
	public Transform frontBogiePivot;

	[SerializeField]
	public bool frontBogieCanRotate = true;

	[SerializeField]
	public Transform rearBogiePivot;

	[SerializeField]
	public bool rearBogieCanRotate = true;

	[SerializeField]
	private Transform[] wheelVisuals;

	[SerializeField]
	public float wheelRadius = 0.615f;

	[SerializeField]
	[FormerlySerializedAs("fxFinalExplosion")]
	public GameObjectRef fxDestroyed;

	[SerializeField]
	public TriggerParent platformParentTrigger;

	public GameObjectRef collisionEffect;

	public Transform frontCoupling;

	public Transform frontCouplingPivot;

	public Transform rearCoupling;

	public Transform rearCouplingPivot;

	[SerializeField]
	public SoundDefinition coupleSound;

	[SerializeField]
	private SoundDefinition uncoupleSound;

	[SerializeField]
	private TrainCarAudio trainCarAudio;

	[SerializeField]
	[FormerlySerializedAs("frontCoupleFx")]
	public ParticleSystem frontCouplingChangedFx;

	[FormerlySerializedAs("rearCoupleFx")]
	[SerializeField]
	public ParticleSystem rearCouplingChangedFx;

	[FormerlySerializedAs("fxCoupling")]
	[SerializeField]
	public ParticleSystem newCouplingFX;

	[SerializeField]
	private float decayTimeMultiplier = 1f;

	[SerializeField]
	[ReadOnly]
	public Vector3 frontBogieLocalOffset;

	[SerializeField]
	[ReadOnly]
	public Vector3 rearBogieLocalOffset;

	[SerializeField]
	private GameObjectRef itemStoragePrefab;

	private EntityRef<StorageContainer> itemStorageInstance;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population = 2.3f;

	[ServerVar(Help = "Ratio of wagons to train engines that spawn")]
	public static int wagons_per_engine = 2;

	[ServerVar(Help = "How long before a train car despawns")]
	public static float decayminutes = 30f;

	[ServerVar(Help = "Chance to miss per m/s of velocity for turrets shooting players on moving trains", Name = "trainturretinaccuratepervelocity")]
	public static float TrainTurretInaccuratePerVelocity = 0.1f;

	[ReadOnly]
	public float DistFrontWheelToFrontCoupling;

	[ReadOnly]
	public float DistFrontWheelToBackCoupling;

	public TrainCouplingController coupling;

	[NonSerialized]
	public TrainTrackSpline.TrackSelection localTrackSelection;

	public const Flags Flag_LinedUpToUnload = Flags.Reserved4;

	public static float TRAINCAR_MAX_SPEED = 25f;

	protected bool trainDebug;

	public CompleteTrain completeTrain;

	[NonSerialized]
	public float savedTrackSpeed;

	private bool frontAtEndOfLine;

	private bool rearAtEndOfLine;

	public float frontBogieYRot;

	public float rearBogieYRot;

	public Vector3 spawnOrigin;

	private bool coupledBackwards;

	public TrainTrackSpline _frontTrackSection;

	public float distFrontToBackWheel;

	public float initialSpawnTime;

	public float decayingFor;

	public float decayTickSpacing = 60f;

	public float lastDecayTick;

	public TriggerTrainCollisions FrontCollisionTrigger => frontCollisionTrigger;

	public TriggerTrainCollisions RearCollisionTrigger => rearCollisionTrigger;

	public virtual TrainCarType CarType => TrainCarType.Wagon;

	public bool LinedUpToUnload => HasFlag(Flags.Reserved4);

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	public Vector3 Position => ((Component)this).transform.position;

	public float FrontWheelSplineDist { get; set; }

	public bool FrontAtEndOfLine => frontAtEndOfLine;

	public bool RearAtEndOfLine => rearAtEndOfLine;

	public virtual bool networkUpdateOnCompleteTrainChange => false;

	public TrainTrackSpline FrontTrackSection
	{
		get
		{
			return _frontTrackSection;
		}
		set
		{
			if ((Object)(object)_frontTrackSection != (Object)(object)value)
			{
				if ((Object)(object)_frontTrackSection != (Object)null)
				{
					_frontTrackSection.DeregisterTrackUser(this);
				}
				_frontTrackSection = value;
				if ((Object)(object)_frontTrackSection != (Object)null)
				{
					_frontTrackSection.RegisterTrackUser(this);
				}
			}
		}
	}

	public TrainTrackSpline RearTrackSection { get; set; }

	public bool IsAtAStation
	{
		get
		{
			if ((Object)(object)FrontTrackSection != (Object)null)
			{
				return FrontTrackSection.isStation;
			}
			return false;
		}
	}

	public bool IsOnAboveGroundSpawnRail
	{
		get
		{
			if ((Object)(object)FrontTrackSection != (Object)null)
			{
				return FrontTrackSection.aboveGroundSpawn;
			}
			return false;
		}
	}

	public bool RecentlySpawned => Time.time < initialSpawnTime + 2f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TrainCar.OnRpcMessage", 0);
		try
		{
			if (rpc == 924237371 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenItemStorage "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenItemStorage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(924237371u, "RPC_OpenItemStorage", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_OpenItemStorage(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenItemStorage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3930273067u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_WantsUncouple "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_WantsUncouple", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						RPC_WantsUncouple(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in RPC_WantsUncouple");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		base.PreProcess(process, rootObj, name, serverside, clientside, bundling);
		if (!((Object)(object)frontBogiePivot == (Object)null) && !((Object)(object)rearBogiePivot == (Object)null))
		{
			frontBogieLocalOffset = ((Component)this).transform.InverseTransformPoint(frontBogiePivot.position);
			float num = ((!((Object)(object)frontCoupling != (Object)null)) ? (((Bounds)(ref bounds)).extents.z + ((Bounds)(ref bounds)).center.z) : ((Component)this).transform.InverseTransformPoint(frontCoupling.position).z);
			float num2 = ((!((Object)(object)rearCoupling != (Object)null)) ? (0f - ((Bounds)(ref bounds)).extents.z + ((Bounds)(ref bounds)).center.z) : ((Component)this).transform.InverseTransformPoint(rearCoupling.position).z);
			DistFrontWheelToFrontCoupling = num - frontBogieLocalOffset.z;
			DistFrontWheelToBackCoupling = 0f - num2 + frontBogieLocalOffset.z;
			rearBogieLocalOffset = ((Component)this).transform.InverseTransformPoint(rearBogiePivot.position);
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		coupling = new TrainCouplingController(this);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.baseTrain != null && base.isServer)
		{
			frontBogieYRot = info.msg.baseTrain.frontBogieYRot;
			rearBogieYRot = info.msg.baseTrain.rearBogieYRot;
			itemStorageInstance.uid = info.msg.baseTrain.itemStorageID;
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next && base.isServer)
		{
			ServerFlagsChanged(old, next);
		}
	}

	public bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger)
	{
		return false;
	}

	public override float InheritedVelocityScale()
	{
		return 0.5f;
	}

	public virtual void SetTrackSelection(TrainTrackSpline.TrackSelection trackSelection)
	{
		if (localTrackSelection != trackSelection)
		{
			localTrackSelection = trackSelection;
			if (base.isServer)
			{
				ClientRPC(RpcTarget.NetworkGroup("SetTrackSelection"), (sbyte)localTrackSelection);
			}
		}
	}

	public bool PlayerIsOnPlatform(BasePlayer player)
	{
		return (Object)(object)player.GetParentEntity() == (Object)(object)this;
	}

	public override void ServerInit()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		spawnOrigin = ((Component)this).transform.position;
		distFrontToBackWheel = Vector3.Distance(GetFrontWheelPos(), GetRearWheelPos());
		rigidBody.centerOfMass = centreOfMassTransform.localPosition;
		UpdateCompleteTrain();
		lastDecayTick = Time.time;
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.15f, 0.02f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayTick, Random.Range(20f, 40f), decayTickSpacing, decayTickSpacing * 0.1f);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (base.health <= 0f)
		{
			ActualDeath();
			return;
		}
		SetFlag(Flags.Reserved2, b: false);
		SetFlag(Flags.Reserved3, b: false);
	}

	public override void Spawn()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		initialSpawnTime = Time.time;
		if (TrainTrackSpline.TryFindTrackNear(GetFrontWheelPos(), 15f, out var splineResult, out var distResult))
		{
			FrontWheelSplineDist = distResult;
			Vector3 tangent;
			Vector3 positionAndTangent = splineResult.GetPositionAndTangent(FrontWheelSplineDist, ((Component)this).transform.forward, out tangent);
			SetTheRestFromFrontWheelData(ref splineResult, positionAndTangent, tangent, localTrackSelection, null, instantMove: true);
			FrontTrackSection = splineResult;
			if (!Application.isLoadingSave && !SpaceIsClear())
			{
				((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0f);
			}
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0f);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.baseTrain = Pool.Get<BaseTrain>();
		info.msg.baseTrain.time = GetNetworkTime();
		info.msg.baseTrain.frontBogieYRot = frontBogieYRot;
		info.msg.baseTrain.rearBogieYRot = rearBogieYRot;
		info.msg.baseTrain.itemStorageID = itemStorageInstance.uid;
		if (coupling.frontCoupling.TryGetCoupledToID(out var id))
		{
			info.msg.baseTrain.frontCouplingID = id;
			info.msg.baseTrain.frontCouplingToFront = coupling.frontCoupling.CoupledTo.isFrontCoupling;
		}
		if (coupling.rearCoupling.TryGetCoupledToID(out id))
		{
			info.msg.baseTrain.rearCouplingID = id;
			info.msg.baseTrain.rearCouplingToFront = coupling.rearCoupling.CoupledTo.isFrontCoupling;
		}
	}

	public virtual void ServerFlagsChanged(Flags old, Flags next)
	{
		if (isSpawned && (next.HasFlag(Flags.Reserved2) != old.HasFlag(Flags.Reserved2) || next.HasFlag(Flags.Reserved3) != old.HasFlag(Flags.Reserved3)))
		{
			UpdateCompleteTrain();
		}
	}

	public void UpdateCompleteTrain()
	{
		List<TrainCar> result = Pool.Get<List<TrainCar>>();
		coupling.GetAll(ref result);
		SetNewCompleteTrain(new CompleteTrain(result));
	}

	public void SetNewCompleteTrain(CompleteTrain ct)
	{
		if (completeTrain != ct)
		{
			RemoveFromCompleteTrain();
			completeTrain = ct;
			coupledBackwards = ct.GetIsCoupledBackwards(this);
			if (networkUpdateOnCompleteTrainChange)
			{
				SendNetworkUpdate();
			}
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (!RecentlySpawned)
		{
			base.Hurt(info);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_OpenItemStorage(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player))
		{
			StorageContainer itemContainer = GetItemContainer();
			if ((Object)(object)itemContainer != (Object)null)
			{
				itemContainer.PlayerOpenLoot(player);
			}
		}
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && itemStoragePrefab != null && itemStoragePrefab.isValid)
		{
			BaseEntity entity = itemStoragePrefab.GetEntity();
			if ((Object)(object)entity != (Object)null && child.prefabID == entity.prefabID)
			{
				itemStorageInstance.Set((StorageContainer)child);
			}
		}
	}

	public StorageContainer GetItemContainer()
	{
		BaseEntity baseEntity = itemStorageInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as StorageContainer;
		}
		return null;
	}

	public override void OnDied(HitInfo info)
	{
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		float num = info?.damageTypes.Get(DamageType.AntiVehicle) ?? 0f;
		float num2 = info?.damageTypes.Get(DamageType.Explosion) ?? 0f;
		float num3 = info?.damageTypes.Total() ?? 0f;
		if ((num + num2) / num3 > 0.5f || vehicle.cinematictrains || corpseSeconds == 0f)
		{
			if (HasDriver())
			{
				GetDriver().Hurt(float.MaxValue);
			}
			base.OnDied(info);
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)ActualDeath, corpseSeconds);
		}
		if (base.IsDestroyed && fxDestroyed.isValid)
		{
			Effect.server.Run(fxDestroyed.resourcePath, GetExplosionPos(), Vector3.up, null, broadcast: true);
		}
	}

	public virtual Vector3 GetExplosionPos()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetCentreOfTrainPos();
	}

	public void ActualDeath()
	{
		Kill(DestroyMode.Gib);
	}

	public override void DoRepair(BasePlayer player)
	{
		base.DoRepair(player);
		if (IsDead() && Health() > 0f)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ActualDeath);
			lifestate = LifeState.Alive;
		}
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return Mathf.Abs(GetTrackSpeed()) * 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
	}

	public override void DoServerDestroy()
	{
		if ((Object)(object)FrontTrackSection != (Object)null)
		{
			FrontTrackSection.DeregisterTrackUser(this);
		}
		coupling.Uncouple(front: true);
		coupling.Uncouple(front: false);
		RemoveFromCompleteTrain();
		if (vehicle.vehiclesdroploot)
		{
			StorageContainer storageContainer = itemStorageInstance.Get(base.isServer);
			if ((Object)(object)storageContainer != (Object)null && storageContainer.IsValid())
			{
				storageContainer.DropItems();
			}
		}
		base.DoServerDestroy();
	}

	public void RemoveFromCompleteTrain()
	{
		if (completeTrain != null)
		{
			if (completeTrain.ContainsOnly(this))
			{
				completeTrain.Dispose();
				completeTrain = null;
			}
			else
			{
				completeTrain.RemoveTrainCar(this);
			}
		}
	}

	public override bool MountEligable(BasePlayer player)
	{
		if (IsDead())
		{
			return false;
		}
		return base.MountEligable(player);
	}

	public override float MaxVelocity()
	{
		return TRAINCAR_MAX_SPEED;
	}

	public float GetTrackSpeed()
	{
		if (completeTrain == null)
		{
			return 0f;
		}
		return completeTrain.GetTrackSpeedFor(this);
	}

	public bool IsCoupledBackwards()
	{
		if (completeTrain == null)
		{
			return false;
		}
		return coupledBackwards;
	}

	public float GetPrevTrackSpeed()
	{
		if (completeTrain == null)
		{
			return 0f;
		}
		return completeTrain.GetPrevTrackSpeedFor(this);
	}

	public override Vector3 GetLocalVelocityServer()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.forward * GetTrackSpeed();
	}

	public bool AnyPlayersOnTrainCar()
	{
		if (AnyMounted())
		{
			return true;
		}
		if ((Object)(object)platformParentTrigger != (Object)null && platformParentTrigger.HasAnyEntityContents)
		{
			foreach (BaseEntity entityContent in platformParentTrigger.entityContents)
			{
				if ((Object)(object)entityContent.ToPlayer() != (Object)null)
				{
					return true;
				}
			}
		}
		return false;
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("TrainCar.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (completeTrain != null)
			{
				completeTrain.UpdateTick(Time.fixedDeltaTime);
				float trackSpeed = GetTrackSpeed();
				((Component)hurtTriggerFront).gameObject.SetActive(!coupling.IsFrontCoupled && trackSpeed > hurtTriggerMinSpeed);
				((Component)hurtTriggerRear).gameObject.SetActive(!coupling.IsRearCoupled && trackSpeed < 0f - hurtTriggerMinSpeed);
				GameObject[] array = hurtOrRepelTriggersInternal;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(Mathf.Abs(trackSpeed) > hurtTriggerMinSpeed);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void PostVehicleFixedUpdate()
	{
		base.PostVehicleFixedUpdate();
		if (completeTrain != null)
		{
			completeTrain.ResetUpdateTick();
		}
	}

	public Vector3 GetCentreOfTrainPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * ((Bounds)(ref bounds)).center;
	}

	public Vector3 GetFrontOfTrainPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * (((Bounds)(ref bounds)).center + Vector3.forward * ((Bounds)(ref bounds)).extents.z);
	}

	public Vector3 GetRearOfTrainPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * (((Bounds)(ref bounds)).center - Vector3.forward * ((Bounds)(ref bounds)).extents.z);
	}

	public void FrontTrainCarTick(TrainTrackSpline.TrackSelection trackSelection, float dt)
	{
		float distToMove = GetTrackSpeed() * dt;
		TrainTrackSpline preferredAltTrack = (((Object)(object)RearTrackSection != (Object)(object)FrontTrackSection) ? RearTrackSection : null);
		MoveFrontWheelsAlongTrackSpline(FrontTrackSection, FrontWheelSplineDist, distToMove, preferredAltTrack, trackSelection);
	}

	public void OtherTrainCarTick(TrainTrackSpline theirTrackSpline, float prevSplineDist, float distanceOffset)
	{
		MoveFrontWheelsAlongTrackSpline(theirTrackSpline, prevSplineDist, distanceOffset, FrontTrackSection, TrainTrackSpline.TrackSelection.Default);
	}

	public bool TryGetNextTrainCar(Vector3 forwardDir, out TrainCar result)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return TryGetTrainCar(next: true, forwardDir, out result);
	}

	public bool TryGetPrevTrainCar(Vector3 forwardDir, out TrainCar result)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return TryGetTrainCar(next: false, forwardDir, out result);
	}

	public bool TryGetTrainCar(bool next, Vector3 forwardDir, out TrainCar result)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		result = null;
		if (completeTrain == null)
		{
			return false;
		}
		return completeTrain.TryGetAdjacentTrainCar(this, next, forwardDir, out result);
	}

	public void MoveFrontWheelsAlongTrackSpline(TrainTrackSpline trackSpline, float prevSplineDist, float distToMove, TrainTrackSpline preferredAltTrack, TrainTrackSpline.TrackSelection trackSelection)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		TrainTrackSpline.MoveResult moveResult = trackSpline.MoveAlongSpline(tReq: new TrainTrackSpline.TrackRequest(trackSelection, preferredAltTrack, null), prevSplineDist: prevSplineDist, askerForward: ((Component)this).transform.forward, distMoved: distToMove);
		TrainTrackSpline frontTS = moveResult.spline;
		FrontWheelSplineDist = moveResult.distAlongSpline;
		frontAtEndOfLine = moveResult.atEndOfLine;
		Vector3 tangent;
		Vector3 positionAndTangent = frontTS.GetPositionAndTangent(FrontWheelSplineDist, ((Component)this).transform.forward, out tangent);
		SetTheRestFromFrontWheelData(ref frontTS, positionAndTangent, tangent, trackSelection, trackSpline, instantMove: false);
		FrontTrackSection = frontTS;
	}

	public Vector3 GetFrontWheelPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * frontBogieLocalOffset;
	}

	public Vector3 GetRearWheelPos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + ((Component)this).transform.rotation * rearBogieLocalOffset;
	}

	public void SetTheRestFromFrontWheelData(ref TrainTrackSpline frontTS, Vector3 targetFrontWheelPos, Vector3 targetFrontWheelTangent, TrainTrackSpline.TrackSelection trackSelection, TrainTrackSpline additionalAlt, bool instantMove)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		TrainTrackSpline.TrackRequest tReq = new TrainTrackSpline.TrackRequest(trackSelection, RearTrackSection, additionalAlt);
		TrainTrackSpline.MoveResult moveResult = frontTS.MoveAlongSpline(FrontWheelSplineDist, ((Component)this).transform.forward, 0f - distFrontToBackWheel, tReq);
		TrainTrackSpline spline = moveResult.spline;
		float distAlongSpline = moveResult.distAlongSpline;
		rearAtEndOfLine = moveResult.atEndOfLine;
		Vector3 tangent;
		Vector3 positionAndTangent = spline.GetPositionAndTangent(distAlongSpline, ((Component)this).transform.forward, out tangent);
		if (rearAtEndOfLine)
		{
			moveResult = spline.MoveAlongSpline(tReq: new TrainTrackSpline.TrackRequest(trackSelection, spline, additionalAlt), prevSplineDist: distAlongSpline, askerForward: ((Component)this).transform.forward, distMoved: distFrontToBackWheel);
			frontTS = moveResult.spline;
			FrontWheelSplineDist = moveResult.distAlongSpline;
			frontAtEndOfLine = moveResult.atEndOfLine;
			targetFrontWheelPos = frontTS.GetPositionAndTangent(FrontWheelSplineDist, ((Component)this).transform.forward, out targetFrontWheelTangent);
		}
		RearTrackSection = spline;
		Vector3 val = targetFrontWheelPos - positionAndTangent;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = targetFrontWheelPos - Quaternion.LookRotation(normalized) * frontBogieLocalOffset;
		if (instantMove)
		{
			((Component)this).transform.position = val2;
			if (((Vector3)(ref normalized)).magnitude == 0f)
			{
				((Component)this).transform.rotation = Quaternion.identity;
			}
			else
			{
				((Component)this).transform.rotation = Quaternion.LookRotation(normalized);
			}
		}
		else
		{
			((Component)this).transform.position = val2;
			if (((Vector3)(ref normalized)).magnitude == 0f)
			{
				((Component)this).transform.rotation = Quaternion.identity;
			}
			else
			{
				((Component)this).transform.rotation = Quaternion.LookRotation(normalized);
			}
		}
		frontBogieYRot = Vector3.SignedAngle(((Component)this).transform.forward, targetFrontWheelTangent, ((Component)this).transform.up);
		rearBogieYRot = Vector3.SignedAngle(((Component)this).transform.forward, tangent, ((Component)this).transform.up);
		if (Application.isEditor)
		{
			Debug.DrawLine(targetFrontWheelPos, positionAndTangent, Color.magenta, 0.2f);
			Debug.DrawLine(rigidBody.position, val2, Color.yellow, 0.2f);
			Debug.DrawRay(val2, Vector3.up, Color.yellow, 0.2f);
		}
	}

	public float GetForces()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		float num = ((Component)this).transform.localEulerAngles.x;
		if (num > 180f)
		{
			num -= 360f;
		}
		return 0f + num / 90f * (0f - Physics.gravity.y) * RealisticMass * 0.33f + GetThrottleForce();
	}

	protected virtual float GetThrottleForce()
	{
		return 0f;
	}

	public virtual bool HasThrottleInput()
	{
		return false;
	}

	public float ApplyCollisionDamage(float forceMagnitude)
	{
		float num = ((!(forceMagnitude > derailCollisionForce)) ? (Mathf.Pow(forceMagnitude, 1.3f) / collisionDamageDivide) : float.MaxValue);
		Hurt(num, DamageType.Collision, this, useProtection: false);
		return num;
	}

	public bool SpaceIsClear()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapOBB(WorldSpaceBounds(), list, 32768, (QueryTriggerInteraction)1);
		foreach (Collider item in list)
		{
			if (!ColliderIsPartOfTrain(item))
			{
				Pool.FreeUnmanaged<Collider>(ref list);
				return false;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return true;
	}

	public bool ColliderIsPartOfTrain(Collider collider)
	{
		BaseEntity baseEntity = collider.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return false;
		}
		if ((Object)(object)baseEntity == (Object)(object)this)
		{
			return true;
		}
		BaseEntity baseEntity2 = baseEntity.parentEntity.Get(base.isServer);
		if (baseEntity2.IsValid())
		{
			return (Object)(object)baseEntity2 == (Object)(object)this;
		}
		return false;
	}

	public void UpdateClients()
	{
		if (IsMoving())
		{
			ClientRPC(RpcTarget.NetworkGroup("BaseTrainUpdate"), GetNetworkTime(), frontBogieYRot, rearBogieYRot);
		}
	}

	public void DecayTick()
	{
		if (completeTrain == null)
		{
			return;
		}
		bool flag = HasDriver() || completeTrain.AnyPlayersOnTrain();
		if (flag)
		{
			decayingFor = 0f;
		}
		float num = GetDecayMinutes(flag) * 60f;
		float time = Time.time;
		float num2 = time - lastDecayTick;
		lastDecayTick = time;
		if (num != float.PositiveInfinity)
		{
			decayingFor += num2;
			if (decayingFor >= num && CanDieFromDecayNow())
			{
				ActualDeath();
			}
		}
	}

	public virtual float GetDecayMinutes(bool hasPassengers)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		bool flag = IsAtAStation && Vector3.Distance(spawnOrigin, ((Component)this).transform.position) < 50f;
		if (hasPassengers || AnyPlayersNearby(30f) || flag || IsOnAboveGroundSpawnRail)
		{
			return float.PositiveInfinity;
		}
		return decayminutes * decayTimeMultiplier;
	}

	public virtual bool CanDieFromDecayNow()
	{
		if (CarType != TrainCarType.Engine)
		{
			return !completeTrain.IncludesAnEngine();
		}
		return true;
	}

	public bool AnyPlayersNearby(float maxDist)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return BaseNetworkable.HasCloseConnections(((Component)this).transform.position, maxDist);
	}

	[RPC_Server]
	public void RPC_WantsUncouple(RPCMessage msg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !(Vector3.SqrMagnitude(((Component)this).transform.position - ((Component)player).transform.position) > 200f) && Interface.CallHook("OnTrainCarUncouple", (object)this, (object)msg.player) == null)
		{
			bool front = msg.read.Bit();
			coupling.Uncouple(front);
		}
	}
}


public enum TrainCarType
{
	Wagon,
	Engine,
	Other
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class TrainCarUnloadable : TrainCar
{
	public enum WagonType
	{
		Ore,
		Lootboxes,
		Fuel
	}

	[SerializeField]
	[Header("Train Car Unloadable")]
	private GameObjectRef storagePrefab;

	[SerializeField]
	private BoxCollider[] unloadingAreas;

	[SerializeField]
	private TrainCarFuelHatches fuelHatches;

	[SerializeField]
	private Transform orePlaneVisuals;

	[SerializeField]
	private Transform orePlaneColliderDetailed;

	[SerializeField]
	private Transform orePlaneColliderWorld;

	[Range(0f, 1f)]
	[SerializeField]
	public float vacuumStretchPercent = 0.5f;

	[SerializeField]
	private ParticleSystemContainer unloadingFXContainer;

	[SerializeField]
	private ParticleSystem unloadingFX;

	public WagonType wagonType;

	private int lootTypeIndex = -1;

	private List<EntityRef<LootContainer>> lootContainers = new List<EntityRef<LootContainer>>();

	private Vector3 _oreScale = Vector3.one;

	private float animPercent;

	private float prevAnimTime;

	[ServerVar(Help = "How long before an unloadable train car despawns afer being unloaded")]
	public static float decayminutesafterunload = 10f;

	private EntityRef<StorageContainer> storageInstance;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TrainCarUnloadable.OnRpcMessage", 0);
		try
		{
			if (rpc == 4254195175u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Open "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Open", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4254195175u, "RPC_Open", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Open(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Open");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old.HasFlag(Flags.Reserved4) != next.HasFlag(Flags.Reserved4) && (Object)(object)fuelHatches != (Object)null)
		{
			fuelHatches.LinedUpStateChanged(base.LinedUpToUnload);
		}
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		base.OnChildAdded(child);
		if (IsDead() || base.IsDestroyed)
		{
			return;
		}
		LootContainer lootContainer = default(LootContainer);
		if (((Component)child).TryGetComponent<LootContainer>(ref lootContainer))
		{
			if (base.isServer)
			{
				lootContainer.inventory.SetLocked(!IsEmpty());
			}
			lootContainers.Add(new EntityRef<LootContainer>(lootContainer.net.ID));
		}
		if (base.isServer && child.prefabID == storagePrefab.GetEntity().prefabID)
		{
			StorageContainer storageContainer = (StorageContainer)child;
			storageInstance.Set(storageContainer);
			if (!Application.isLoadingSave)
			{
				FillWithLoot(storageContainer);
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.baseTrain != null)
		{
			lootTypeIndex = info.msg.baseTrain.lootTypeIndex;
			if (base.isServer)
			{
				SetVisualOreLevel(info.msg.baseTrain.lootPercent);
			}
		}
	}

	public bool IsEmpty()
	{
		return GetOrePercent() == 0f;
	}

	public bool TryGetLootType(out TrainWagonLootData.LootOption lootOption)
	{
		return TrainWagonLootData.instance.TryGetLootFromIndex(lootTypeIndex, out lootOption);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		return !IsEmpty();
	}

	public int GetFilledLootAmount()
	{
		if (TryGetLootType(out var lootOption))
		{
			return lootOption.maxLootAmount;
		}
		Debug.LogWarning((object)(((object)this).GetType().Name + ": Called GetFilledLootAmount without a lootTypeIndex set."));
		return 0;
	}

	public void SetVisualOreLevel(float percent)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)orePlaneColliderDetailed == (Object)null))
		{
			_oreScale.y = Mathf.Clamp01(percent);
			orePlaneColliderDetailed.localScale = _oreScale;
			if (base.isClient)
			{
				orePlaneVisuals.localScale = _oreScale;
				((Component)orePlaneVisuals).gameObject.SetActive(percent > 0f);
			}
			if (base.isServer)
			{
				orePlaneColliderWorld.localScale = _oreScale;
			}
		}
	}

	private void AnimateUnload(float startPercent)
	{
		prevAnimTime = Time.time;
		animPercent = startPercent;
		if (base.isClient && (Object)(object)unloadingFXContainer != (Object)null)
		{
			unloadingFXContainer.Play();
		}
		((FacepunchBehaviour)this).InvokeRepeating((Action)UnloadAnimTick, 0f, 0f);
	}

	private void UnloadAnimTick()
	{
		animPercent -= (Time.time - prevAnimTime) / 40f;
		SetVisualOreLevel(animPercent);
		prevAnimTime = Time.time;
		if (animPercent <= 0f)
		{
			EndUnloadAnim();
		}
	}

	private void EndUnloadAnim()
	{
		if (base.isClient && (Object)(object)unloadingFXContainer != (Object)null)
		{
			unloadingFXContainer.Stop();
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)UnloadAnimTick);
	}

	public float GetOrePercent()
	{
		if (base.isServer)
		{
			return TrainWagonLootData.GetOrePercent(lootTypeIndex, GetStorageContainer());
		}
		return 0f;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseTrain.lootTypeIndex = lootTypeIndex;
		info.msg.baseTrain.lootPercent = GetOrePercent();
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot)
		{
			foreach (EntityRef<LootContainer> lootContainer2 in lootContainers)
			{
				LootContainer lootContainer = lootContainer2.Get(base.isServer);
				if ((Object)(object)lootContainer != (Object)null && lootContainer.inventory != null && !lootContainer.inventory.IsLocked())
				{
					lootContainer.DropItems();
				}
			}
		}
		base.DoServerDestroy();
	}

	public bool IsLinedUpToUnload(BoxCollider unloaderBounds)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		BoxCollider[] array = unloadingAreas;
		foreach (BoxCollider val in array)
		{
			Bounds val2 = ((Collider)unloaderBounds).bounds;
			if (((Bounds)(ref val2)).Intersects(((Collider)val).bounds))
			{
				return true;
			}
		}
		return false;
	}

	public void FillWithLoot(StorageContainer sc)
	{
		sc.inventory.Clear();
		ItemManager.DoRemoves();
		TrainWagonLootData.LootOption lootOption = TrainWagonLootData.instance.GetLootOption(wagonType, out lootTypeIndex);
		int amount = Random.Range(lootOption.minLootAmount, lootOption.maxLootAmount);
		ItemDefinition itemToCreate = ItemManager.FindItemDefinition(lootOption.lootItem.itemid);
		sc.inventory.AddItem(itemToCreate, amount, 0uL, ItemContainer.LimitStack.All);
		sc.inventory.SetLocked(isLocked: true);
		SetVisualOreLevel(GetOrePercent());
		SendNetworkUpdate();
	}

	public void EmptyOutLoot(StorageContainer sc)
	{
		sc.inventory.Clear();
		ItemManager.DoRemoves();
		SetVisualOreLevel(GetOrePercent());
		SendNetworkUpdate();
	}

	public void BeginUnloadAnimation()
	{
		float orePercent = GetOrePercent();
		AnimateUnload(orePercent);
		ClientRPC(RpcTarget.NetworkGroup("RPC_AnimateUnload"), orePercent);
	}

	public void EndEmptyProcess()
	{
		float orePercent = GetOrePercent();
		if (!(orePercent > 0f))
		{
			lootTypeIndex = -1;
			foreach (EntityRef<LootContainer> lootContainer2 in lootContainers)
			{
				LootContainer lootContainer = lootContainer2.Get(base.isServer);
				if ((Object)(object)lootContainer != (Object)null && lootContainer.inventory != null)
				{
					lootContainer.inventory.SetLocked(isLocked: false);
				}
			}
		}
		SetVisualOreLevel(orePercent);
		ClientRPC(RpcTarget.NetworkGroup("RPC_StopAnimateUnload"), orePercent);
		decayingFor = 0f;
	}

	public StorageContainer GetStorageContainer()
	{
		StorageContainer storageContainer = storageInstance.Get(base.isServer);
		if (storageContainer.IsValid())
		{
			return storageContainer;
		}
		return null;
	}

	protected override float GetDecayMinutes(bool hasPassengers)
	{
		if ((wagonType == WagonType.Ore || wagonType == WagonType.Fuel) && !hasPassengers && IsEmpty())
		{
			return decayminutesafterunload;
		}
		return base.GetDecayMinutes(hasPassengers);
	}

	protected override bool CanDieFromDecayNow()
	{
		if (IsEmpty())
		{
			return true;
		}
		return base.CanDieFromDecayNow();
	}

	public override bool AdminFixUp(int tier)
	{
		if (!base.AdminFixUp(tier))
		{
			return false;
		}
		StorageContainer storageContainer = GetStorageContainer();
		if (storageContainer.IsValid())
		{
			if (tier > 1)
			{
				FillWithLoot(storageContainer);
			}
			else
			{
				EmptyOutLoot(storageContainer);
			}
		}
		return true;
	}

	public float MinDistToUnloadingArea(Vector3 point)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		point.y = 0f;
		BoxCollider[] array = unloadingAreas;
		foreach (BoxCollider val in array)
		{
			Vector3 val2 = ((Component)val).transform.position + ((Component)val).transform.rotation * val.center;
			val2.y = 0f;
			float num2 = Vector3.Distance(point, val2);
			if (num2 < num)
			{
				num = num2;
			}
		}
		return num;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_Open(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			StorageContainer storageContainer = GetStorageContainer();
			if (storageContainer.IsValid())
			{
				storageContainer.PlayerOpenLoot(player);
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
			}
		}
	}

	public void SetLootPercentage(float value)
	{
		TrainWagonLootData.SetOrePercent(lootTypeIndex, GetStorageContainer(), value);
	}
}


public enum WagonType
{
	Ore,
	Lootboxes,
	Fuel
}


using System;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using Rust.UI;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

public class TrainEngine : TrainCar, IEngineControllerUser, IEntity
{
	private enum LeverStyle
	{
		WorkCart,
		Locomotive
	}

	public enum EngineSpeeds
	{
		Rev_Hi,
		Rev_Med,
		Rev_Lo,
		Zero,
		Fwd_Lo,
		Fwd_Med,
		Fwd_Hi
	}

	[Header("Train Engine")]
	[SerializeField]
	public Transform leftHandLever;

	[SerializeField]
	public Transform rightHandLever;

	[SerializeField]
	public Transform leftHandGrip;

	[SerializeField]
	public Transform rightHandGrip;

	[SerializeField]
	private LeverStyle leverStyle;

	[SerializeField]
	public Canvas monitorCanvas;

	[SerializeField]
	public RustText monitorText;

	[SerializeField]
	private LocomotiveExtraVisuals gauges;

	[SerializeField]
	public float engineForce = 50000f;

	[SerializeField]
	public float maxSpeed = 12f;

	[SerializeField]
	public float engineStartupTime = 1f;

	[SerializeField]
	public GameObjectRef fuelStoragePrefab;

	[SerializeField]
	public float idleFuelPerSec = 0.05f;

	[SerializeField]
	public float maxFuelPerSec = 0.15f;

	[SerializeField]
	public ProtectionProperties driverProtection;

	[SerializeField]
	public bool lootablesAreOnPlatform;

	[SerializeField]
	private bool mustMountFromPlatform = true;

	[SerializeField]
	private VehicleLight[] onLights;

	[SerializeField]
	public VehicleLight[] headlights;

	[SerializeField]
	private VehicleLight[] notMovingLights;

	[SerializeField]
	private VehicleLight[] movingForwardLights;

	[FormerlySerializedAs("movingBackwardsLights")]
	[SerializeField]
	private VehicleLight[] movingBackwardLights;

	[SerializeField]
	public ParticleSystemContainer fxEngineOn;

	[SerializeField]
	public ParticleSystemContainer fxLightDamage;

	[SerializeField]
	public ParticleSystemContainer fxMediumDamage;

	[SerializeField]
	public ParticleSystemContainer fxHeavyDamage;

	[SerializeField]
	public ParticleSystemContainer fxEngineTrouble;

	[SerializeField]
	public BoxCollider engineWorldCol;

	[SerializeField]
	public float engineDamageToSlow = 150f;

	[SerializeField]
	public float engineDamageTimeframe = 10f;

	[SerializeField]
	public float engineSlowedTime = 10f;

	[SerializeField]
	public float engineSlowedMaxVel = 4f;

	[SerializeField]
	private ParticleSystemContainer[] sparks;

	[FormerlySerializedAs("brakeSparkLights")]
	[SerializeField]
	private Light[] sparkLights;

	[SerializeField]
	private TrainEngineAudio trainAudio;

	public const Flags Flag_HazardAhead = Flags.Reserved6;

	public const Flags Flag_Horn = Flags.Reserved8;

	public const Flags Flag_AltColor = Flags.Reserved9;

	public const Flags Flag_EngineSlowed = Flags.Reserved10;

	public VehicleEngineController<TrainEngine> engineController;

	public const float HAZARD_CHECK_EVERY = 1f;

	public const float HAZARD_DIST_MAX = 325f;

	public const float HAZARD_DIST_MIN = 20f;

	public const float HAZARD_SPEED_MIN = 4.5f;

	public float buttonHoldTime;

	public static readonly EngineSpeeds MaxThrottle = EngineSpeeds.Fwd_Hi;

	public static readonly EngineSpeeds MinThrottle = EngineSpeeds.Rev_Hi;

	public EngineDamageOverTime engineDamage;

	public Vector3 engineLocalOffset;

	private int __sync_FuelAmountSync;

	private int __sync_NumConnectedCarsSync;

	private int __sync_LinedUpToUnloadSync;

	public bool LightsAreOn => HasFlag(Flags.Reserved5);

	public bool CloseToHazard => HasFlag(Flags.Reserved6);

	public bool EngineIsSlowed => HasFlag(Flags.Reserved10);

	public EngineSpeeds CurThrottleSetting { get; set; } = EngineSpeeds.Zero;

	public override TrainCarType CarType => TrainCarType.Engine;

	[Sync(Autosave = true)]
	private int FuelAmountSync
	{
		[CompilerGenerated]
		get
		{
			return __sync_FuelAmountSync;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_FuelAmountSync, value))
			{
				__sync_FuelAmountSync = value;
				byte nameID = __GetWeaverID("FuelAmountSync");
				QueueSyncVar(nameID);
			}
		}
	}

	[Sync(Autosave = true)]
	private int NumConnectedCarsSync
	{
		[CompilerGenerated]
		get
		{
			return __sync_NumConnectedCarsSync;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_NumConnectedCarsSync, value))
			{
				__sync_NumConnectedCarsSync = value;
				byte nameID = __GetWeaverID("NumConnectedCarsSync");
				QueueSyncVar(nameID);
			}
		}
	}

	[Sync(Autosave = true, Pack = false)]
	private int LinedUpToUnloadSync
	{
		[CompilerGenerated]
		get
		{
			return __sync_LinedUpToUnloadSync;
		}
		[CompilerGenerated]
		set
		{
			if (!IsSyncVarEqual(__sync_LinedUpToUnloadSync, value))
			{
				__sync_LinedUpToUnloadSync = value;
				byte nameID = __GetWeaverID("LinedUpToUnloadSync");
				SV_SyncVarSend(nameID);
			}
		}
	}

	public override bool networkUpdateOnCompleteTrainChange => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TrainEngine.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		EntityFuelSystem fuelSystem = new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
		engineController = new VehicleEngineController<TrainEngine>(this, fuelSystem, base.isServer, engineStartupTime);
		if (base.isServer)
		{
			bool b = SeedRandom.Range((uint)net.ID.Value, 0, 2) == 0;
			SetFlag(Flags.Reserved9, b);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.trainEngine != null)
		{
			engineController.FuelSystem.SetInstanceID(info.msg.trainEngine.fuelStorageID);
			SetThrottle((EngineSpeeds)info.msg.trainEngine.throttleSetting);
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		if (player.isMounted)
		{
			return false;
		}
		if (lootablesAreOnPlatform)
		{
			return PlayerIsOnPlatform(player);
		}
		Vector3 localVelocity = GetLocalVelocity();
		if (((Vector3)(ref localVelocity)).magnitude < 2f)
		{
			return true;
		}
		return PlayerIsOnPlatform(player);
	}

	public float GetEnginePowerMultiplier(float minPercent)
	{
		if (base.healthFraction > 0.4f)
		{
			return 1f;
		}
		return Mathf.Lerp(minPercent, 1f, base.healthFraction / 0.4f);
	}

	public float GetThrottleFraction()
	{
		return CurThrottleSetting switch
		{
			EngineSpeeds.Rev_Hi => -1f, 
			EngineSpeeds.Rev_Med => -0.5f, 
			EngineSpeeds.Rev_Lo => -0.2f, 
			EngineSpeeds.Zero => 0f, 
			EngineSpeeds.Fwd_Lo => 0.2f, 
			EngineSpeeds.Fwd_Med => 0.5f, 
			EngineSpeeds.Fwd_Hi => 1f, 
			_ => 0f, 
		};
	}

	public bool IsNearDesiredSpeed(float leeway)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Dot(((Component)this).transform.forward, GetLocalVelocity());
		float num2 = maxSpeed * GetThrottleFraction();
		if (num2 < 0f)
		{
			return num - leeway <= num2;
		}
		return num + leeway >= num2;
	}

	public override void SetTrackSelection(TrainTrackSpline.TrackSelection trackSelection)
	{
		base.SetTrackSelection(trackSelection);
	}

	public void SetThrottle(EngineSpeeds throttle)
	{
		if (CurThrottleSetting != throttle)
		{
			CurThrottleSetting = throttle;
			if (base.isServer)
			{
				ClientRPC(RpcTarget.NetworkGroup("SetThrottle"), (sbyte)throttle);
			}
		}
	}

	public bool CanMount(BasePlayer player)
	{
		if (mustMountFromPlatform)
		{
			return PlayerIsOnPlatform(player);
		}
		return true;
	}

	public override void ServerInit()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		engineDamage = new EngineDamageOverTime(engineDamageToSlow, engineDamageTimeframe, OnEngineTookHeavyDamage);
		engineLocalOffset = ((Component)this).transform.InverseTransformPoint(((Component)engineWorldCol).transform.position + ((Component)engineWorldCol).transform.rotation * engineWorldCol.center);
	}

	public override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned)
		{
			GetFuelSystem().CheckNewChild(child);
		}
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("TrainEngine.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			engineController.CheckEngineState();
			if (engineController.IsOn)
			{
				float fuelPerSecond = Mathf.Lerp(idleFuelPerSec, maxFuelPerSec, Mathf.Abs(GetThrottleFraction()));
				engineController.TickFuel(fuelPerSecond);
				FuelAmountSync = engineController.FuelSystem.GetFuelAmount();
				NumConnectedCarsSync = completeTrain.NumTrainCars;
				LinedUpToUnloadSync = completeTrain.LinedUpToUnload;
			}
			else if (LightsAreOn && !HasDriver())
			{
				SetFlag(Flags.Reserved5, b: false);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.trainEngine = Pool.Get<TrainEngine>();
		info.msg.trainEngine.throttleSetting = (int)CurThrottleSetting;
		info.msg.trainEngine.fuelStorageID = GetFuelSystem().GetInstanceID();
	}

	public override IFuelSystem GetFuelSystem()
	{
		return engineController.FuelSystem;
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			SetFlag(Flags.Reserved5, !LightsAreOn);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (!IsDriver(player))
		{
			return;
		}
		if (engineController.IsOff)
		{
			if ((inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD)) || (inputState.IsDown(BUTTON.BACKWARD) && !inputState.WasDown(BUTTON.BACKWARD)))
			{
				engineController.TryStartEngine(player);
			}
			SetFlag(Flags.Reserved8, b: false);
		}
		else
		{
			if (!ProcessThrottleInput(BUTTON.FORWARD, IncreaseThrottle))
			{
				ProcessThrottleInput(BUTTON.BACKWARD, DecreaseThrottle);
			}
			SetFlag(Flags.Reserved8, inputState.IsDown(BUTTON.FIRE_PRIMARY));
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			SetTrackSelection(TrainTrackSpline.TrackSelection.Left);
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			SetTrackSelection(TrainTrackSpline.TrackSelection.Right);
		}
		else
		{
			SetTrackSelection(TrainTrackSpline.TrackSelection.Default);
		}
		bool ProcessThrottleInput(BUTTON button, Action action)
		{
			if (inputState.IsDown(button))
			{
				if (!inputState.WasDown(button))
				{
					action();
					buttonHoldTime = 0f;
				}
				else
				{
					buttonHoldTime += Player.clientTickInterval;
					if (buttonHoldTime > 0.55f)
					{
						action();
						buttonHoldTime = 0.4f;
					}
				}
				return true;
			}
			return false;
		}
	}

	public override void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerDismounted(player, seat);
		SetFlag(Flags.Reserved8, b: false);
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		driverProtection.Scale(info.damageTypes);
	}

	public bool MeetsEngineRequirements()
	{
		if (!HasDriver() && CurThrottleSetting == EngineSpeeds.Zero)
		{
			return false;
		}
		if (!completeTrain.AnyPlayersOnTrain())
		{
			return vehicle.trainskeeprunning;
		}
		return true;
	}

	public void OnEngineStartFailed()
	{
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (CanMount(player))
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

	protected override float GetThrottleForce()
	{
		if (IsDead() || base.IsDestroyed)
		{
			return 0f;
		}
		float num = 0f;
		float num2 = (engineController.IsOn ? GetThrottleFraction() : 0f);
		float num3 = maxSpeed * num2;
		float curTopSpeed = GetCurTopSpeed();
		num3 = Mathf.Clamp(num3, 0f - curTopSpeed, curTopSpeed);
		float trackSpeed = GetTrackSpeed();
		if (num2 > 0f && trackSpeed < num3)
		{
			num += GetCurEngineForce();
		}
		else if (num2 < 0f && trackSpeed > num3)
		{
			num -= GetCurEngineForce();
		}
		return num;
	}

	public override bool HasThrottleInput()
	{
		if (engineController.IsOn)
		{
			return CurThrottleSetting != EngineSpeeds.Zero;
		}
		return false;
	}

	public override void Hurt(HitInfo info)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (engineDamage != null && Vector3.SqrMagnitude(engineLocalOffset - info.HitPositionLocal) < 2f)
		{
			engineDamage.TakeDamage(info.damageTypes.Total());
		}
		base.Hurt(info);
	}

	public void StopEngine()
	{
		engineController.StopEngine();
	}

	public override Vector3 GetExplosionPos()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)engineWorldCol).transform.position + engineWorldCol.center;
	}

	public void IncreaseThrottle()
	{
		if (CurThrottleSetting != MaxThrottle)
		{
			SetThrottle(CurThrottleSetting + 1);
		}
	}

	public void DecreaseThrottle()
	{
		if (CurThrottleSetting != MinThrottle)
		{
			SetThrottle(CurThrottleSetting - 1);
		}
	}

	public void SetZeroThrottle()
	{
		SetThrottle(EngineSpeeds.Zero);
	}

	public override void ServerFlagsChanged(Flags old, Flags next)
	{
		base.ServerFlagsChanged(old, next);
		if (next.HasFlag(Flags.On) && !old.HasFlag(Flags.On))
		{
			SetFlag(Flags.Reserved5, b: true);
			((FacepunchBehaviour)this).InvokeRandomized((Action)CheckForHazards, 0f, 1f, 0.1f);
		}
		else if (!next.HasFlag(Flags.On) && old.HasFlag(Flags.On))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckForHazards);
			SetFlag(Flags.Reserved6, b: false);
		}
	}

	public void CheckForHazards()
	{
		float trackSpeed = GetTrackSpeed();
		if (trackSpeed > 4.5f || trackSpeed < -4.5f)
		{
			float maxHazardDist = Mathf.Lerp(40f, 325f, Mathf.Abs(trackSpeed) * 0.05f);
			SetFlag(Flags.Reserved6, base.FrontTrackSection.HasValidHazardWithin(this, base.FrontWheelSplineDist, 20f, maxHazardDist, localTrackSelection, trackSpeed, base.RearTrackSection, null));
		}
		else
		{
			SetFlag(Flags.Reserved6, b: false);
		}
	}

	public void OnEngineTookHeavyDamage()
	{
		SetFlag(Flags.Reserved10, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ResetEngineToNormal, engineSlowedTime);
	}

	public void ResetEngineToNormal()
	{
		SetFlag(Flags.Reserved10, b: false);
	}

	public float GetCurTopSpeed()
	{
		float num = maxSpeed * GetEnginePowerMultiplier(0.5f);
		if (EngineIsSlowed)
		{
			num = Mathf.Clamp(num, 0f - engineSlowedMaxVel, engineSlowedMaxVel);
		}
		return num;
	}

	public float GetCurEngineForce()
	{
		return engineForce * GetEnginePowerMultiplier(0.75f);
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			GetFuelSystem().LootFuel(player);
		}
	}

	protected override bool WriteSyncVar(byte id, NetWrite writer)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId iD;
		switch (id)
		{
		case 0:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: FuelAmountSync for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_FuelAmountSync);
			return true;
		case 1:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: NumConnectedCarsSync for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_NumConnectedCarsSync);
			return true;
		case 2:
			if (Global.developer > 2)
			{
				iD = net.ID;
				Debug.Log((object)("SyncVar Writing: LinedUpToUnloadSync for " + ((object)(NetworkableId)(ref iD)/*cast due to .constrained prefix*/).ToString()));
			}
			SyncVarNetWrite(writer, __sync_LinedUpToUnloadSync);
			return true;
		default:
			return false;
		}
	}

	protected override bool OnSyncVar(byte id, NetRead reader, bool fromAutoSave = false)
	{
		return false;
	}

	private byte __GetWeaverID(string propertyName)
	{
		return propertyName switch
		{
			"FuelAmountSync" => 0, 
			"NumConnectedCarsSync" => 1, 
			"LinedUpToUnloadSync" => 2, 
			_ => 0, 
		};
	}

	protected override bool AutoSaveSyncVars(SaveInfo save)
	{
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		WriteSyncVar(0, val);
		WriteSyncVar(1, val);
		WriteSyncVar(2, val);
		var (src, num) = val.GetBuffer();
		if (_autosaveBuffer == null)
		{
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		if (_autosaveBuffer.Length < num)
		{
			BaseEntity._autosaveBufferPool.Return(_autosaveBuffer);
			_autosaveBuffer = BaseEntity._autosaveBufferPool.Rent(num);
		}
		Buffer.BlockCopy(src, 0, _autosaveBuffer, 0, num);
		save.msg.baseEntity.syncVars = _autosaveBuffer;
		Pool.Free<NetWrite>(ref val);
		return true;
	}

	protected override bool AutoLoadSyncVars(LoadInfo load)
	{
		if (load.msg.baseEntity != null && load.msg.baseEntity.syncVars != null)
		{
			NetRead val = Pool.Get<NetRead>();
			val.Init(load.msg.baseEntity.syncVars.AsSpan());
			OnSyncVar(0, val, fromAutoSave: true);
			OnSyncVar(1, val, fromAutoSave: true);
			OnSyncVar(2, val, fromAutoSave: true);
			Pool.Free<NetRead>(ref val);
		}
		return true;
	}

	protected override void ResetSyncVars()
	{
		__sync_FuelAmountSync = 0;
		__sync_NumConnectedCarsSync = 0;
		__sync_LinedUpToUnloadSync = 0;
	}

	protected override bool ShouldInvalidateCache(byte id)
	{
		return id switch
		{
			0 => true, 
			1 => true, 
			2 => true, 
			_ => true, 
		};
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


private enum LeverStyle
{
	WorkCart,
	Locomotive
}


public enum EngineSpeeds
{
	Rev_Hi,
	Rev_Med,
	Rev_Lo,
	Zero,
	Fwd_Lo,
	Fwd_Med,
	Fwd_Hi
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class TravellingVendor : BaseEntity, VehicleChassisVisuals<TravellingVendor>.IClientWheelUser, IPathListener
{
	private enum TravellingVendorState
	{
		Stopped,
		Travelling,
		Waiting,
		Aligning
	}

	public static class TravellingVendorFlags
	{
		public const Flags Braking = Flags.Reserved1;

		public const Flags IndicateLeft = Flags.Reserved2;

		public const Flags IndicateRight = Flags.Reserved4;

		public const Flags Lights = Flags.Reserved5;

		public const Flags Hazards = Flags.Reserved6;
	}

	[Flags]
	private enum WheelIsGroundedFlags
	{
		RearLeft = 1,
		RearRight = 2,
		FrontLeft = 4,
		FrontRight = 8
	}

	[Serializable]
	private struct VendorTargetInfo
	{
		public float lastSeenTime;

		public float lastBlockingTime;

		public float blockingAccumulator;

		public float ignoredUntil;

		public bool IsIgnored => ignoredUntil > Time.time;
	}

	[Header("Visuals")]
	public TravellingVendorVisuals visuals;

	[Header("Sounds")]
	public TravellingVendorSounds sounds;

	public SoundPlayer BuySound;

	[Header("References")]
	[SerializeField]
	private VisualCarWheel wheelFL;

	[SerializeField]
	private VisualCarWheel wheelFR;

	[SerializeField]
	private VisualCarWheel wheelRL;

	[SerializeField]
	private VisualCarWheel wheelRR;

	public float client_steering_left;

	public float client_steering_right;

	public Vector3 client_velocity = Vector3.zero;

	private WheelIsGroundedFlags client_wheel_flags;

	public TimeSince timeSinceLastUpdate;

	public VehicleLight headlight;

	public VehicleLight rearLights;

	public VehicleLight rearLeftIndicator;

	public VehicleLight rearRightIndicator;

	private static Collider[] spawncheckColliders = (Collider[])(object)new Collider[2];

	public const string PREFAB_PATH = "assets/prefabs/npc/travelling vendor/travellingvendor.prefab";

	[Header("General")]
	public bool DoAI = true;

	public float ObstacleCheckTime = 0.33f;

	public float MarkerUpdateTime = 0.05f;

	public float TimeBetweenPullovers = 120f;

	[Header("Engine Config")]
	public float motorForceConstant = 300f;

	public float brakeForceConstant = 500f;

	public float acceleration = 2f;

	[Header("Steer Config")]
	public float wheelbase = 3.3f;

	public float rearTrack = 1.6f;

	public float steeringSmoothing = 0.1f;

	public float downforceCoefficient = 10f;

	public float maxSteerAngle = 80f;

	[Header("Trade")]
	public GameObjectRef vendingMachineRef;

	public GameObjectRef vendingMachineFrontRef;

	[Header("Pullover")]
	public float maxPulloverAngleDifference = 15f;

	[Header("Other")]
	public static int obstacleMask = 196608;

	[Header("References")]
	public GameObjectRef mapMarkerEntityPrefab;

	public GameObjectRef preventBuildingPrefab;

	public GameObjectRef backfireEffect;

	public Transform backfirePosition;

	private TriggerVehiclePush pusher;

	private TriggerPlayerForce forcer;

	public NPCVendingMachine vendingMachine;

	[Header("Spline")]
	public float splineMovementSpeed = 2f;

	public Vector3 splineOffset;

	[ServerVar]
	public static bool should_spawn = true;

	[ServerVar]
	public static bool attempt_pullovers = true;

	[ServerVar]
	public static float alive_time_seconds = 1800f;

	[ServerVar]
	public static bool should_destroy_buildings = false;

	[ReplicatedVar(Saved = true)]
	public static float max_speed = 5f;

	private float smoothedSteering;

	private float brakes;

	private float throttle;

	private float targetThrottle = 3f;

	private bool handbrake = true;

	private float steeringAngle;

	private float currentMaxSpeed;

	private Rigidbody myRigidbody;

	private List<RaycastHit> obstacleHits;

	private List<RaycastHit> pulloverHits;

	private Vector3 destination;

	private bool instantLeave;

	private float waitTimeAccumulator;

	private float aliveTimer;

	private TimeSince timeSinceBackfire;

	private bool pullingOver;

	private Vector3 pulloverPosition = Vector3.zero;

	private float pullOverTimer;

	private Vector3 pulloverTangent = Vector3.zero;

	private bool overrideSteering;

	private BaseEntity preventBuildingInstance;

	private RaycastHit hit;

	private TravellingVendorState internalState;

	private WheelIsGroundedFlags wheelFlags;

	private SimpleSplineTranslator splineTranslator;

	private MapMarker mapMarkerInstance;

	private bool globaIndicatorLeft;

	private TimeSince timeSincePlayerDetected;

	private float slowdownStartSpeed;

	private List<Vector3> currentPath;

	private int currentPathIndex;

	private float atDestinationDistance = 8f;

	private bool followingSpine;

	private int splineId = -1;

	private WorldSpline spline;

	private ListDictionary<BasePlayer, VendorTargetInfo> playerRecords;

	private List<BasePlayer> localPlayers;

	private int searchRange = 10;

	private float allowedVendorBlockTime = 1f;

	public Vector3 Velocity => client_velocity;

	public float DriveWheelVelocity => ((Vector3)(ref client_velocity)).magnitude;

	public float SteerAngle => (client_steering_left + client_steering_right) / 2f;

	public float MaxSteerAngle => maxSteerAngle;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TravellingVendor.OnRpcMessage", 0);
		try
		{
			if (rpc == 831304742 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_OpenMenu "));
				}
				TimeWarning val2 = TimeWarning.New("SV_OpenMenu", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(831304742u, "SV_OpenMenu", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_OpenMenu(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_OpenMenu");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public float GetThrottleInput()
	{
		return 1f;
	}

	[ServerVar(Name = "spawn")]
	public static string svspawntravellingvendor(Arg args)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)SpawnTravellingVendor(((Component)args.Player()).transform.position) != (Object)null))
		{
			return "Failed to spawn Travelling Vendor. Is there a ring road present?";
		}
		return "Spawned Travelling Vendor.";
	}

	[ServerVar(Name = "startevent")]
	public static string svspawntravellingvendorevent(Arg args)
	{
		if (!((Object)(object)SpawnTravellingVendorForEvent() != (Object)null))
		{
			return "Failed to spawn Travelling Vendor.";
		}
		return "Spawned Travelling Vendor.";
	}

	public static TravellingVendor SpawnTravellingVendor(Vector3 position)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		RuntimePath runtimePath = new RuntimePath();
		PathList pathList = null;
		float num = float.PositiveInfinity;
		foreach (PathList mainRoad in TerrainMeta.Path.MainRoads)
		{
			_ = Vector3.zero;
			float num2 = float.PositiveInfinity;
			Vector3[] points = mainRoad.Path.Points;
			foreach (Vector3 val in points)
			{
				float num3 = Vector3.Distance(val, position);
				if (num3 < num2)
				{
					num2 = num3;
				}
			}
			if (num2 < num)
			{
				pathList = mainRoad;
				num = num2;
			}
		}
		if (pathList == null)
		{
			Debug.Log((object)"Couldn't find road to spawn on.");
			return null;
		}
		Vector3 startPoint = pathList.Path.GetStartPoint();
		pathList.Path.GetEndPoint();
		int num4 = pathList.Path.Points.Length - 1;
		IAIPathNode[] nodes = new RuntimePathNode[num4];
		runtimePath.Nodes = nodes;
		IAIPathNode iAIPathNode = null;
		int num5 = 0;
		int num6 = pathList.Path.MaxIndex - 1;
		for (int j = pathList.Path.MinIndex; j <= num6; j++)
		{
			IAIPathNode iAIPathNode2 = new RuntimePathNode(pathList.Path.Points[j] + Vector3.up * 1f);
			if (iAIPathNode != null)
			{
				iAIPathNode2.AddLink(iAIPathNode);
				iAIPathNode.AddLink(iAIPathNode2);
			}
			runtimePath.Nodes[num5] = iAIPathNode2;
			iAIPathNode = iAIPathNode2;
			num5++;
		}
		runtimePath.Nodes[0].AddLink(runtimePath.Nodes[runtimePath.Nodes.Length - 1]);
		runtimePath.Nodes[runtimePath.Nodes.Length - 1].AddLink(runtimePath.Nodes[0]);
		int num7 = Mathf.CeilToInt(pathList.Path.Length / 500f);
		num7 = Mathf.Clamp(num7, 1, 3);
		num7++;
		for (int k = 0; k < num7; k++)
		{
			int num8 = Random.Range(0, pathList.Path.Points.Length);
			RuntimeInterestNode interestNode = new RuntimeInterestNode(pathList.Path.Points[num8] + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode);
		}
		Vector3 val2 = runtimePath.Nodes[1].Position - startPoint;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/travelling vendor/travellingvendor.prefab", startPoint + Vector3.up * 2f, Quaternion.LookRotation(normalized));
		TravellingVendor travellingVendor = null;
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			travellingVendor = ((Component)baseEntity).GetComponent<TravellingVendor>();
			if (Object.op_Implicit((Object)(object)travellingVendor))
			{
				travellingVendor.Spawn();
				travellingVendor.InstallPath(runtimePath, 1);
			}
			else
			{
				baseEntity.Kill();
			}
		}
		return travellingVendor;
	}

	private static (bool Valid, int Index) GetSpawnPoint(Vector3[] points)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		int num = Random.Range(0, points.Length);
		for (int i = 0; i < 15; i++)
		{
			if (CheckSpawnPosition(points[num]))
			{
				return (Valid: true, Index: num);
			}
			num = Random.Range(0, points.Length);
		}
		Debug.Log((object)("Failed to spawn a travelling vendor after " + 15 + " attempts."));
		return (Valid: false, Index: 0);
	}

	public static TravellingVendor SpawnTravellingVendorForEvent()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		RuntimePath runtimePath = new RuntimePath();
		PathList pathList = null;
		if (TerrainMeta.Path.MainRoads.Count == 0)
		{
			Debug.Log((object)"Can't spawn Travelling Vendor: No roads available to spawn on.");
			return null;
		}
		foreach (PathList mainRoad in TerrainMeta.Path.MainRoads)
		{
			if (mainRoad.Path.GetStartPoint() == mainRoad.Path.GetEndPoint())
			{
				pathList = mainRoad;
				break;
			}
		}
		if (pathList == null)
		{
			Debug.Log((object)"Can't spawn Travelling Vendor: can't find Ring Road.");
			return null;
		}
		if (pathList.Path.Points.Length == 0)
		{
			Debug.Log((object)"Can't spawn Travelling Vendor: Road has no points.");
			return null;
		}
		int num = pathList.Path.Points.Length - 1;
		IAIPathNode[] nodes = new RuntimePathNode[num];
		runtimePath.Nodes = nodes;
		IAIPathNode iAIPathNode = null;
		int num2 = 0;
		int num3 = pathList.Path.MaxIndex - 1;
		for (int i = pathList.Path.MinIndex; i <= num3; i++)
		{
			IAIPathNode iAIPathNode2 = new RuntimePathNode(pathList.Path.Points[i] + Vector3.up * 1f);
			if (iAIPathNode != null)
			{
				iAIPathNode2.AddLink(iAIPathNode);
				iAIPathNode.AddLink(iAIPathNode2);
			}
			runtimePath.Nodes[num2] = iAIPathNode2;
			iAIPathNode = iAIPathNode2;
			num2++;
		}
		runtimePath.Nodes[0].AddLink(runtimePath.Nodes[runtimePath.Nodes.Length - 1]);
		runtimePath.Nodes[runtimePath.Nodes.Length - 1].AddLink(runtimePath.Nodes[0]);
		int num4 = Mathf.CeilToInt(pathList.Path.Length / 500f);
		num4 = Mathf.Clamp(num4, 1, 3);
		num4++;
		for (int j = 0; j < num4; j++)
		{
			int num5 = Random.Range(0, pathList.Path.Points.Length);
			RuntimeInterestNode interestNode = new RuntimeInterestNode(pathList.Path.Points[num5] + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode);
		}
		(bool, int) spawnPoint = GetSpawnPoint(pathList.Path.Points);
		if (spawnPoint.Item1)
		{
			int item = spawnPoint.Item2;
			Vector3 val = pathList.Path.Points[(item + 1) % pathList.Path.Points.Length] - pathList.Path.Points[item];
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/travelling vendor/travellingvendor.prefab", pathList.Path.Points[item] + Vector3.up * 2f, Quaternion.LookRotation(normalized));
			TravellingVendor travellingVendor = null;
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				travellingVendor = ((Component)baseEntity).GetComponent<TravellingVendor>();
				if (Object.op_Implicit((Object)(object)travellingVendor))
				{
					travellingVendor.Spawn();
					travellingVendor.InstallPath(runtimePath, (item + 1) % pathList.Path.Points.Length);
				}
				else
				{
					baseEntity.Kill();
				}
			}
			return travellingVendor;
		}
		return null;
	}

	private static bool CheckSpawnPosition(Vector3 testPosition)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (TerrainMeta.TopologyMap.GetTopology(testPosition, 1024))
		{
			return false;
		}
		Physics.OverlapSphereNonAlloc(testPosition, 0.3f, spawncheckColliders, obstacleMask | 0x8000000);
		bool flag = false;
		Collider[] array = spawncheckColliders;
		foreach (Collider val in array)
		{
			if (!((Object)(object)val == (Object)null) && !((Component)val).CompareTag("IgnoreCollider"))
			{
				flag = true;
				break;
			}
		}
		return !flag;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (child.prefabID == vendingMachineRef.GetEntity().prefabID && !Application.isLoadingSave)
		{
			vendingMachine = child as NPCVendingMachine;
			if (base.isServer && (Object)(object)vendingMachine != (Object)null)
			{
				vendingMachine.SetFlag(Flags.Reserved4, b: false);
				vendingMachine.UpdateMapMarker();
				vendingMachine.ChangeRefillTime(alive_time_seconds * 0.334f);
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SV_OpenMenu(RPCMessage msg)
	{
		if ((Object)(object)vendingMachine == (Object)null)
		{
			vendingMachine = ((Component)this).GetComponentInChildren<NPCVendingMachine>();
		}
		if (Interface.CallHook("OnVendingShopOpen", (object)vendingMachine, (object)msg.player) == null)
		{
			vendingMachine.OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", (object)vendingMachine, (object)msg.player);
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override bool IsDebugging()
	{
		return false;
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		BaseCombatEntity baseCombatEntity = info.Initiator as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity != (Object)null)
		{
			baseCombatEntity.MarkHostileFor();
		}
	}

	public void CreateMapMarker()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)mapMarkerInstance != (Object)null)
		{
			mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerEntityPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.Spawn();
		mapMarkerInstance = baseEntity as MapMarker;
	}

	public void CreatePreventBuilding()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)preventBuildingInstance != (Object)null)
		{
			preventBuildingInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(preventBuildingPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		preventBuildingInstance = baseEntity;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		UpdateWheelFlags();
		info.msg.travellingVendor = Pool.Get<TravellingVendor>();
		info.msg.travellingVendor.steeringAngle = wheelFL.wheelCollider.steerAngle;
		info.msg.travellingVendor.velocity = (IsFollowingSpline() ? (((Component)this).transform.forward * splineTranslator.Speed) : myRigidbody.velocity);
		info.msg.travellingVendor.wheelFlags = (int)wheelFlags;
	}

	public override void ServerInit()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (!base.isClient)
		{
			myRigidbody = ((Component)this).GetComponent<Rigidbody>();
			obstacleHits = Pool.Get<List<RaycastHit>>();
			pulloverHits = Pool.Get<List<RaycastHit>>();
			currentMaxSpeed = max_speed;
			timeSinceBackfire = TimeSince.op_Implicit(0f);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Reserved1, b: false);
			SetFlag(Flags.Reserved5, b: false);
			NightCheck();
			pusher = ((Component)this).GetComponentInChildren<TriggerVehiclePush>();
			forcer = ((Component)this).GetComponentInChildren<TriggerPlayerForce>();
			CreateMapMarker();
			CreatePreventBuilding();
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateObstacles, 0f, ObstacleCheckTime);
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateMarker, 0f, MarkerUpdateTime);
			((FacepunchBehaviour)this).InvokeRepeating((Action)BuildingCheck, 1f, 3f);
			((FacepunchBehaviour)this).InvokeRepeating((Action)NightCheck, 0f, 120f);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if ((Object)(object)preventBuildingInstance != (Object)null && preventBuildingInstance.IsValid())
		{
			preventBuildingInstance.Kill();
		}
		if ((Object)(object)mapMarkerInstance != (Object)null && mapMarkerInstance.IsValid())
		{
			mapMarkerInstance.Kill();
		}
		if (localPlayers != null)
		{
			Pool.FreeUnmanaged<BasePlayer>(ref localPlayers);
		}
		if (obstacleHits != null)
		{
			Pool.FreeUnmanaged<RaycastHit>(ref obstacleHits);
		}
		if (pulloverHits != null)
		{
			Pool.FreeUnmanaged<RaycastHit>(ref pulloverHits);
		}
		if (currentPath != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref currentPath);
		}
	}

	private void StartBackfire()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(backfireEffect.resourcePath, this, 0u, backfirePosition.localPosition, Vector3.zero);
	}

	private void StartHorn()
	{
		ClientRPC(RpcTarget.NetworkGroup("CL_PlayerDetected"));
	}

	private void FixedUpdate()
	{
		if (!base.isClient && DoAI && HasPath())
		{
			ProcessLifetime();
			ProcessHandbrake();
			if (!IsFollowingSpline())
			{
				DoSteering();
				ApplyDownforce();
			}
			ProcessState();
			FetchTargets();
			SendNetworkUpdate();
		}
	}

	private void ProcessHandbrake()
	{
		if (handbrake && !(aliveTimer <= 5f) && wheelFL.wheelCollider.isGrounded && wheelFR.wheelCollider.isGrounded)
		{
			handbrake = false;
			wheelFL.wheelCollider.brakeTorque = 0f;
			wheelFR.wheelCollider.brakeTorque = 0f;
			wheelRL.wheelCollider.brakeTorque = 0f;
			wheelRR.wheelCollider.brakeTorque = 0f;
		}
	}

	private void SetGlobalIndicator()
	{
		if (HasFlag(Flags.Reserved6))
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		if (globaIndicatorLeft)
		{
			SetFlag(Flags.Reserved2, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved4, b: true);
		}
	}

	private void TurnOffIndicators()
	{
		if (HasFlag(Flags.Reserved2) || HasFlag(Flags.Reserved4))
		{
			SetFlag(Flags.Reserved2, b: false);
			SetFlag(Flags.Reserved4, b: false);
		}
	}

	private void UpdateMarker()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)mapMarkerInstance == (Object)null))
		{
			((Component)mapMarkerInstance).transform.SetPositionAndRotation(((Component)this).transform.position, ((Component)this).transform.rotation);
			mapMarkerInstance.SendNetworkUpdate();
		}
	}

	private void NightCheck()
	{
		bool flag = (Object)(object)TOD_Sky.Instance != (Object)null && (TOD_Sky.Instance.Cycle.Hour > 19f || TOD_Sky.Instance.Cycle.Hour < 8f);
		if (HasFlag(Flags.Reserved5) != flag)
		{
			SetFlag(Flags.Reserved5, flag);
		}
	}

	private void ProcessLifetime()
	{
		aliveTimer += Time.deltaTime;
		if (!(aliveTimer >= alive_time_seconds))
		{
			return;
		}
		if (localPlayers.Count > 0)
		{
			aliveTimer += 120f;
			return;
		}
		if ((Object)(object)mapMarkerInstance != (Object)null)
		{
			mapMarkerInstance.Kill();
		}
		if ((Object)(object)preventBuildingInstance != (Object)null)
		{
			preventBuildingInstance.Kill();
		}
		TravellingVendorEvent.currentVendor = null;
		Kill();
	}

	private void ProcessState()
	{
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return;
		}
		if (internalState == TravellingVendorState.Stopped)
		{
			targetThrottle = 0f;
			if (HasPath())
			{
				internalState = TravellingVendorState.Travelling;
			}
		}
		if (internalState == TravellingVendorState.Travelling)
		{
			targetThrottle = 2f;
			if (instantLeave)
			{
				instantLeave = false;
			}
			if (overrideSteering)
			{
				overrideSteering = false;
			}
			if (!IsFollowingSpline())
			{
				if (!pullingOver)
				{
					AdvancePath();
					pullOverTimer += Time.deltaTime;
					if (pullOverTimer > TimeBetweenPullovers && attempt_pullovers)
					{
						pullingOver = true;
					}
				}
				else
				{
					HandlePullover();
				}
			}
			if (CheckForObstacle())
			{
				instantLeave = true;
				SetWaiting();
				return;
			}
			if (!IsFollowingSpline())
			{
				ApplyForceAtWheels();
			}
			else
			{
				TravelOnSpline();
			}
			if (IsValidPatrons())
			{
				if (pulloverPosition != Vector3.zero)
				{
					return;
				}
				SetWaiting();
			}
		}
		if (internalState == TravellingVendorState.Aligning)
		{
			targetThrottle = 0.2f;
			Vector3 val = currentPath[GetPathIndexAhead(3)] - currentPath[GetPathIndexAhead(2)];
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			float steerAngle = ((Vector3.Dot(((Component)this).transform.right, normalized) <= 0f) ? (0f - MaxSteerAngle) : MaxSteerAngle);
			if (Vector3.Angle(((Component)this).transform.forward, pulloverTangent) > 5f)
			{
				wheelFL.wheelCollider.steerAngle = steerAngle;
				wheelFR.wheelCollider.steerAngle = steerAngle;
				ApplyForceAtWheels();
			}
			else
			{
				overrideSteering = false;
				SetPulloverWaiting();
			}
		}
		if (internalState != TravellingVendorState.Waiting)
		{
			return;
		}
		targetThrottle = 0f;
		if (!IsFollowingSpline())
		{
			ApplyBrakesAtWheels();
		}
		else
		{
			SlowOnSpline();
		}
		if (CheckForObstacle())
		{
			return;
		}
		if (!IsValidPatrons() || instantLeave)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)SetTravelling))
			{
				float num = 0f;
				if (waitTimeAccumulator > 0f)
				{
					num = GetWaitAccumulator();
				}
				float num2 = 10f + num;
				((FacepunchBehaviour)this).Invoke((Action)SetTravelling, instantLeave ? 0f : num2);
				if (!instantLeave)
				{
					((FacepunchBehaviour)this).Invoke((Action)SetGlobalIndicator, num2 - 5f);
				}
			}
		}
		else if (((FacepunchBehaviour)this).IsInvoking((Action)SetTravelling))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SetTravelling);
		}
	}

	private void HandlePullover()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (pulloverPosition == Vector3.zero && !FindPullingOverSpot())
		{
			ResetPullover();
			pulloverPosition = Vector3.zero;
			currentMaxSpeed = 1f;
		}
		else
		{
			if (!AtDestination())
			{
				return;
			}
			if (Vector3.Angle(((Component)this).transform.forward, pulloverTangent) > 5f && pulloverPosition != Vector3.zero)
			{
				Vector3 position = pulloverPosition + pulloverTangent * 2f;
				if (!IsPositionClear(position, 2f))
				{
					SetPulloverWaiting();
					return;
				}
				overrideSteering = true;
				internalState = TravellingVendorState.Aligning;
				SetFlag(Flags.Reserved1, b: false);
			}
			else
			{
				SetPulloverWaiting();
			}
		}
	}

	private void SetPulloverWaiting()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		currentPathIndex = GetPathIndexAhead(4);
		SetDestination(currentPath[currentPathIndex]);
		SetWaiting();
		TurnOffIndicators();
		SetFlag(Flags.Reserved6, b: true);
		waitTimeAccumulator += 60f;
		ResetPullover();
	}

	private bool FindPullingOverSpot()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		pulloverHits.Clear();
		bool flag = Random.value > 0.5f;
		Vector3 val = currentPath[GetPathIndexAhead(3)] - currentPath[GetPathIndexAhead(2)];
		pulloverTangent = ((Vector3)(ref val)).normalized;
		Vector3 val2 = Vector3.Cross(((Component)this).transform.up, pulloverTangent);
		Vector3 val3 = Vector3.Cross(pulloverTangent, ((Component)this).transform.up);
		if (!TryFindClearPulloverPoint(flag, out var testedPosition))
		{
			flag = !flag;
			if (!TryFindClearPulloverPoint(flag, out testedPosition))
			{
				return false;
			}
		}
		globaIndicatorLeft = !flag;
		if (flag)
		{
			SetFlag(Flags.Reserved2, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved4, b: true);
		}
		if ((Object)(object)preventBuildingInstance != (Object)null)
		{
			preventBuildingInstance.SetParent(null);
			((Component)preventBuildingInstance).transform.position = pulloverPosition;
		}
		pulloverPosition = testedPosition;
		SetDestination(pulloverPosition, 2f);
		return true;
	}

	private Vector3 GetAdjustedPulloverPoint(bool onLeft)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		Vector3 side = (onLeft ? Vector3.Cross(pulloverTangent, ((Component)this).transform.up) : Vector3.Cross(((Component)this).transform.up, pulloverTangent));
		Vector3 pulloverPointFromSide = GetPulloverPointFromSide(side);
		float height = TerrainMeta.HeightMap.GetHeight(pulloverPointFromSide);
		pulloverPointFromSide.y = height + 1f;
		return pulloverPointFromSide;
	}

	private bool TryFindClearPulloverPoint(bool onLeft, out Vector3 testedPosition)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 adjustedPulloverPoint = GetAdjustedPulloverPoint(onLeft);
		Vector3 val = adjustedPulloverPoint - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		testedPosition = adjustedPulloverPoint;
		bool num = IsDirectionClear(normalized, adjustedPulloverPoint);
		bool flag = IsPositionClear(adjustedPulloverPoint);
		return num && flag;
	}

	private Vector3 GetPulloverPointFromSide(Vector3 side, bool inFront = true)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (inFront)
		{
			return currentPath[GetPathIndexAhead(2)] + side * 3.2f + pulloverTangent * 3f;
		}
		return currentPath[GetPathIndexAhead(-2)] + side * 3.2f + pulloverTangent * 3f;
	}

	private bool IsPositionClear(Vector3 position, float radiusCheck = 4.5f)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(position, radiusCheck, list, obstacleMask, (QueryTriggerInteraction)2);
		bool result = true;
		if (list == null)
		{
			return false;
		}
		if (list.Count > 0)
		{
			foreach (Collider item in list)
			{
				if (!((Object)(object)item == (Object)null) && !((Object)(object)((Component)item).gameObject == (Object)null) && !((Object)(object)((Component)item).transform == (Object)null) && !((Component)item).transform.IsChildOf(((Component)this).transform) && !((Object)(object)((Component)item).transform == (Object)(object)((Component)this).transform) && !((Component)item).CompareTag("IgnoreCollider"))
				{
					result = false;
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private bool IsDirectionClear(Vector3 direction, Vector3 point)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		UpdateObstacleList(pulloverHits, direction, 3.5f);
		foreach (RaycastHit pulloverHit in pulloverHits)
		{
			RaycastHit current = pulloverHit;
			if (!((Component)((RaycastHit)(ref current)).collider).CompareTag("IgnoreCollider") && !((Component)((RaycastHit)(ref current)).collider).CompareTag("Main Terrain") && !((Component)((RaycastHit)(ref current)).collider).transform.IsChildOf(((Component)this).transform) && !((Object)(object)((Component)((RaycastHit)(ref current)).collider).transform == (Object)(object)((Component)this).transform))
			{
				return false;
			}
		}
		float height = TerrainMeta.HeightMap.GetHeight(point);
		Vector3 testPos = point;
		testPos.y = height + 1f;
		if (Vector3Ex.DotDegrees(((Component)this).transform.up, GetTerrainNormal(testPos)) >= maxPulloverAngleDifference)
		{
			return false;
		}
		return true;
	}

	private Vector3 GetTerrainNormal(Vector3 testPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (TransformUtil.GetGroundInfo(testPos, out hit, 100f, LayerMask.op_Implicit(8388608)))
		{
			return ((RaycastHit)(ref hit)).normal;
		}
		return Vector3.zero;
	}

	private void SetWaiting()
	{
		internalState = TravellingVendorState.Waiting;
		((Behaviour)forcer).enabled = false;
		((Behaviour)pusher).enabled = false;
		SetFlag(Flags.Reserved1, b: true);
		targetThrottle = 0f;
		brakes = 1f;
	}

	private void SetTravelling()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)preventBuildingInstance != (Object)null && preventBuildingInstance.parentEntity.uid != net.ID)
		{
			preventBuildingInstance.SetParent(this);
			((Component)preventBuildingInstance).transform.localPosition = Vector3.zero;
		}
		((Behaviour)forcer).enabled = true;
		((Behaviour)pusher).enabled = true;
		if (TimeSince.op_Implicit(timeSinceBackfire) > 30f && Random.value < 0.6f)
		{
			timeSinceBackfire = TimeSince.op_Implicit(0f);
			((FacepunchBehaviour)this).Invoke((Action)StartBackfire, Random.Range(1f, 4f));
		}
		if (HasFlag(Flags.Reserved6))
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)TurnOffIndicators))
		{
			((FacepunchBehaviour)this).Invoke((Action)TurnOffIndicators, 3f, 0f);
		}
		SetFlag(Flags.Reserved1, b: false);
		internalState = TravellingVendorState.Travelling;
		brakes = 0f;
	}

	private void AdvancePath()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (currentPath != null)
		{
			if (PathComplete())
			{
				currentPathIndex = 0;
				flag = true;
			}
			else if (AtDestination())
			{
				currentPathIndex = GetPathIndexAhead(2);
				flag = true;
			}
			if (flag)
			{
				SetDestination(currentPath[currentPathIndex]);
			}
		}
	}

	private int GetPathIndexAhead(int ahead)
	{
		if (currentPath == null)
		{
			return 0;
		}
		return (currentPathIndex + ahead) % currentPath.Count;
	}

	private void ResetPullover()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		pullingOver = false;
		pullOverTimer = 0f;
		pulloverPosition = Vector3.zero;
		pulloverTangent = Vector3.zero;
	}

	private float GetWaitAccumulator()
	{
		float result = waitTimeAccumulator;
		waitTimeAccumulator = 0f;
		return result;
	}

	public void ScaleSidewaysFriction(float scale)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		float stiffness = 0.75f + 0.75f * scale;
		WheelFrictionCurve sidewaysFriction = wheelFL.wheelCollider.sidewaysFriction;
		((WheelFrictionCurve)(ref sidewaysFriction)).stiffness = stiffness;
		wheelFL.wheelCollider.sidewaysFriction = sidewaysFriction;
		wheelFR.wheelCollider.sidewaysFriction = sidewaysFriction;
		wheelRL.wheelCollider.sidewaysFriction = sidewaysFriction;
		wheelRR.wheelCollider.sidewaysFriction = sidewaysFriction;
	}

	private void ApplyDownforce()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		myRigidbody.AddForce(-((Component)this).transform.up * downforceCoefficient);
	}

	private void UpdateWheelFlags()
	{
		if (wheelFL.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.FrontLeft;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.FrontLeft;
		}
		if (wheelFR.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.FrontRight;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.FrontRight;
		}
		if (wheelRL.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.RearLeft;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.RearLeft;
		}
		if (wheelRR.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.RearRight;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.RearRight;
		}
	}

	private void BuildingCheck()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(WorldSpaceBounds(), list, 1075937536, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!(item is Barricade barricade))
			{
				if (!(item is LootContainer lootContainer))
				{
					if (!(item is ConstructableEntity constructableEntity))
					{
						if (!(item is TreeEntity treeEntity))
						{
							if (!(item is DecayEntity decayEntity))
							{
								if (item is TrainCar { isServer: not false } trainCar && trainCar.IsAlive())
								{
									trainCar.Kill(DestroyMode.Gib);
								}
							}
							else if (should_destroy_buildings && (Object)(object)decayEntity.parentEntity.Get(serverside: true) != (Object)(object)this && decayEntity.isServer && decayEntity.IsAlive())
							{
								decayEntity.Kill(DestroyMode.Gib);
							}
						}
						else if (treeEntity.isServer)
						{
							treeEntity.Kill();
						}
					}
					else if (constructableEntity.isServer && constructableEntity.IsAlive())
					{
						constructableEntity.Kill(DestroyMode.Gib);
					}
				}
				else if (lootContainer.isServer && lootContainer.IsAlive())
				{
					lootContainer.Kill(DestroyMode.Gib);
				}
			}
			else if (barricade.isServer && barricade.IsAlive())
			{
				barricade.Kill(DestroyMode.Gib);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private bool CheckForObstacle()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		if (obstacleHits == null)
		{
			return false;
		}
		if (obstacleHits.Count <= 0)
		{
			return false;
		}
		foreach (RaycastHit obstacleHit in obstacleHits)
		{
			RaycastHit current = obstacleHit;
			if ((Object)(object)((RaycastHit)(ref current)).collider == (Object)null)
			{
				continue;
			}
			if (((RaycastHit)(ref current)).collider.ToBaseEntity() is BradleyAPC)
			{
				obstacleHits.Clear();
				return true;
			}
			if (!(((RaycastHit)(ref current)).collider.ToBaseEntity() is BasePlayer basePlayer) || IsPlayerIgnored(basePlayer) || basePlayer.IsFlying || IsInvalidPlayer(basePlayer))
			{
				continue;
			}
			if (TimeSince.op_Implicit(timeSincePlayerDetected) > 10f)
			{
				((FacepunchBehaviour)this).Invoke((Action)StartHorn, (float)Random.Range(1, 4));
				timeSincePlayerDetected = TimeSince.op_Implicit(0f);
			}
			if (playerRecords.ContainsKey(basePlayer))
			{
				VendorTargetInfo vendorTargetInfo = playerRecords[basePlayer];
				if (vendorTargetInfo.lastBlockingTime > Time.time + 60f)
				{
					vendorTargetInfo.blockingAccumulator = 0f;
					vendorTargetInfo.lastBlockingTime = Time.time;
					playerRecords[basePlayer] = vendorTargetInfo;
					continue;
				}
				vendorTargetInfo.lastBlockingTime = Time.time;
				vendorTargetInfo.blockingAccumulator += Time.deltaTime;
				if (vendorTargetInfo.blockingAccumulator > allowedVendorBlockTime)
				{
					IgnorePlayer(basePlayer);
				}
				else
				{
					playerRecords[basePlayer] = vendorTargetInfo;
				}
			}
			else
			{
				playerRecords.Add(basePlayer, new VendorTargetInfo
				{
					blockingAccumulator = Time.deltaTime,
					ignoredUntil = 0f,
					lastBlockingTime = Time.time,
					lastSeenTime = Time.time
				});
			}
			obstacleHits.Clear();
			return true;
		}
		return false;
	}

	private void UpdateObstacles()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		UpdateObstacleList(obstacleHits, ((Component)this).transform.forward);
	}

	private void UpdateObstacleList(List<RaycastHit> hits, Vector3 forward, float checkRadius = 2.5f)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		hits.Clear();
		GamePhysics.TraceAll(new Ray(((Component)this).transform.position + ((Component)this).transform.forward * (((Bounds)(ref bounds)).extents.z / 0.6f - 1f), forward), checkRadius, hits, 15f, obstacleMask | 1 | 0x8000, (QueryTriggerInteraction)1, this);
	}

	private void DoSteering()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 velocity = myRigidbody.velocity;
		float magnitude = ((Vector3)(ref velocity)).magnitude;
		velocity = myRigidbody.velocity;
		float num = Mathf.InverseLerp(5f, 1.5f, magnitude * Mathf.Abs(Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward)));
		ScaleSidewaysFriction(1f - num);
		if (!overrideSteering)
		{
			Vector3 val = ((Component)this).transform.InverseTransformPoint(destination);
			steeringAngle = Mathf.Atan2(val.x, val.z);
			steeringAngle *= 57.29578f;
			float num2 = steeringSmoothing * Time.deltaTime;
			smoothedSteering = Mathf.Lerp(smoothedSteering, steeringAngle, num2);
			wheelFL.wheelCollider.steerAngle = smoothedSteering;
			wheelFR.wheelCollider.steerAngle = smoothedSteering;
		}
	}

	private void ApplyForceAtWheels()
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (handbrake)
		{
			wheelFL.wheelCollider.brakeTorque = 1000f;
			wheelFR.wheelCollider.brakeTorque = 1000f;
			wheelRL.wheelCollider.brakeTorque = 1000f;
			wheelRR.wheelCollider.brakeTorque = 1000f;
			return;
		}
		throttle = Mathf.MoveTowards(throttle, targetThrottle, acceleration * Time.deltaTime);
		float num = throttle * motorForceConstant * 5f;
		Vector3 velocity = myRigidbody.velocity;
		bool flag = ((Vector3)(ref velocity)).magnitude >= max_speed;
		wheelFL.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		wheelFR.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		wheelRL.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		wheelRR.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		if (wheelFL.wheelCollider.isGrounded)
		{
			wheelFL.wheelCollider.motorTorque = num / 4f;
		}
		if (wheelFR.wheelCollider.isGrounded)
		{
			wheelFR.wheelCollider.motorTorque = num / 4f;
		}
		if (wheelRL.wheelCollider.isGrounded)
		{
			wheelRL.wheelCollider.motorTorque = num / 4f;
		}
		if (wheelRR.wheelCollider.isGrounded)
		{
			wheelRR.wheelCollider.motorTorque = num / 4f;
		}
	}

	private void ApplyBrakesAtWheels()
	{
		brakes = Mathf.Clamp(brakes, 0f, 1f);
		wheelFL.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelFR.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelRL.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelRR.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelFR.wheelCollider.motorTorque = 0f;
		wheelFL.wheelCollider.motorTorque = 0f;
		wheelRL.wheelCollider.motorTorque = 0f;
		wheelRR.wheelCollider.motorTorque = 0f;
	}

	private float CalculateSteeringAngle(float radius)
	{
		return Mathf.Atan(wheelbase / radius);
	}

	private void HandleSplineMovement()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		splineTranslator.SetOffset(splineOffset);
		splineTranslator.Update(Time.deltaTime);
		splineTranslator.GetCurrentPositionAndTangent(out var position, out var tangent);
		((Component)this).transform.position = Vector3.Lerp(((Component)this).transform.position, position, Time.deltaTime * splineMovementSpeed * 10f);
		Vector3 val = splineTranslator.PeekNextPositionFollowingDirection();
		tangent = val - position;
		Vector3 normalized = ((Vector3)(ref tangent)).normalized;
		((Component)this).transform.forward = normalized;
		Vector3 val2 = ((Component)this).transform.InverseTransformPoint(val);
		steeringAngle = Mathf.Atan2(val2.x, val2.z);
		steeringAngle *= 57.29578f;
		wheelFL.wheelCollider.steerAngle = steeringAngle;
		wheelFR.wheelCollider.steerAngle = steeringAngle;
	}

	private void TravelOnSpline()
	{
		splineTranslator.SetSpeed(splineMovementSpeed);
		slowdownStartSpeed = splineMovementSpeed;
		HandleSplineMovement();
	}

	private void SlowOnSpline()
	{
		splineTranslator.SetSpeed(slowdownStartSpeed);
		HandleSplineMovement();
		slowdownStartSpeed = Mathf.MoveTowards(slowdownStartSpeed, 0f, Time.deltaTime * 2f);
	}

	private void StopSplineMovement()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		overrideSteering = false;
		myRigidbody.isKinematic = false;
		int num = FindClosestNode() + 2 % currentPath.Count;
		currentPathIndex = num;
		SetDestination(currentPath[currentPathIndex]);
	}

	public void OnSplinePathTrigger(int pathId, WorldSpline spline, int direction)
	{
		if (splineId == -1 && (Object)(object)this.spline != (Object)(object)spline)
		{
			if (splineTranslator == null)
			{
				splineTranslator = new SimpleSplineTranslator();
			}
			myRigidbody.isKinematic = true;
			splineTranslator.SetSpline(spline).SetSpeed(splineMovementSpeed).SetDirection(direction)
				.CalculateStartingDistance();
			splineId = pathId;
			this.spline = spline;
			if (!((FacepunchBehaviour)this).IsInvoking((Action)CheckForSplineStart))
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)CheckForSplineStart, 0f, 1f);
			}
		}
		else if (splineId != pathId)
		{
			StopSplineMovement();
			splineId = -1;
			followingSpine = false;
		}
	}

	public void OnBasePathTrigger(int pathId, BasePath path)
	{
	}

	private void CheckForSplineStart()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		float start = splineTranslator.GetStart();
		Vector3 positionAtDistance = splineTranslator.GetPositionAtDistance(start, out var _);
		positionAtDistance += splineOffset;
		Vector3 val = ((Component)spline).transform.TransformPoint(positionAtDistance);
		if (Vector3Ex.Distance2D(((Component)this).transform.position, val) < 1.5f)
		{
			overrideSteering = true;
			followingSpine = true;
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckForSplineStart);
		}
	}

	public void InstallPath(RuntimePath path, int initialDestination)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (currentPath == null)
		{
			currentPath = Pool.Get<List<Vector3>>();
		}
		currentPath.Clear();
		IAIPathNode[] nodes = path.Nodes;
		foreach (IAIPathNode iAIPathNode in nodes)
		{
			currentPath.Add(iAIPathNode.Position);
		}
		currentPathIndex = initialDestination;
		SetDestination(currentPath[currentPathIndex]);
	}

	private bool HasPath()
	{
		if (currentPath != null)
		{
			return currentPath.Count > 0;
		}
		return false;
	}

	private bool IsFollowingSpline()
	{
		return followingSpine;
	}

	private void ClearPath()
	{
		currentPath.Clear();
		currentPathIndex = -1;
	}

	private bool IndexValid(int index)
	{
		if (!HasPath())
		{
			return false;
		}
		if (index >= 0)
		{
			return index < currentPath.Count;
		}
		return false;
	}

	private Vector3 GetCurrentPathDestination()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return ((Component)this).transform.position;
		}
		return currentPath[currentPathIndex];
	}

	private bool PathComplete()
	{
		if (HasPath())
		{
			if (currentPathIndex == currentPath.Count - 1)
			{
				return AtDestination();
			}
			return false;
		}
		return true;
	}

	public void SetDestination(Vector3 dest, float destinationDistance = 8f)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		atDestinationDistance = destinationDistance;
		destination = dest;
	}

	public bool AtDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(((Component)this).transform.position, destination) <= atDestinationDistance;
	}

	private int FindClosestNode()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		int result = 0;
		for (int i = 0; i < currentPath.Count; i++)
		{
			Vector3 val = currentPath[i];
			float num2 = Vector3Ex.Distance2D(((Component)this).transform.position, val);
			if (num2 < num)
			{
				num = num2;
				result = i;
			}
		}
		return result;
	}

	private void FetchTargets()
	{
		if (playerRecords == null)
		{
			playerRecords = new ListDictionary<BasePlayer, VendorTargetInfo>();
		}
		if (localPlayers == null)
		{
			localPlayers = Pool.Get<List<BasePlayer>>();
		}
		List<BaseEntity> foundEntities = Pool.Get<List<BaseEntity>>();
		FetchCycle(foundEntities);
		Pool.FreeUnmanaged<BaseEntity>(ref foundEntities);
	}

	private void FetchCycle(List<BaseEntity> foundEntities)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Vis.Entities(((Component)this).transform.position, searchRange, foundEntities, 133120, (QueryTriggerInteraction)2);
		localPlayers.Clear();
		foreach (BaseEntity foundEntity in foundEntities)
		{
			if (!(foundEntity is BasePlayer basePlayer) || basePlayer is HumanNPC || basePlayer is NPCPlayer || IsInvalidPlayer(basePlayer))
			{
				continue;
			}
			if (playerRecords.ContainsKey(basePlayer))
			{
				VendorTargetInfo vendorTargetInfo = playerRecords[basePlayer];
				vendorTargetInfo.lastSeenTime = Time.time;
				playerRecords[basePlayer] = vendorTargetInfo;
				if (!IsPlayerIgnored(basePlayer))
				{
					localPlayers.Add(basePlayer);
				}
			}
			else
			{
				playerRecords.Add(basePlayer, new VendorTargetInfo
				{
					blockingAccumulator = 0f,
					ignoredUntil = 0f,
					lastBlockingTime = 0f,
					lastSeenTime = Time.time
				});
				localPlayers.Add(basePlayer);
			}
		}
	}

	private bool IsInvalidPlayer(BasePlayer player)
	{
		int result = (int)(0u | (player.IsDead() ? 1u : 0u) | (player.IsSleeping() ? 1u : 0u) | (player.IsHostile() ? 1u : 0u)) | (player.isClient ? 1 : 0);
		if (player.IsHostile())
		{
			IgnorePlayer(player);
		}
		return (byte)result != 0;
	}

	private void IgnorePlayer(BasePlayer player)
	{
		if (localPlayers.Contains(player))
		{
			localPlayers.Remove(player);
		}
		float num = 90f;
		if (playerRecords.ContainsKey(player))
		{
			VendorTargetInfo vendorTargetInfo = playerRecords[player];
			vendorTargetInfo.ignoredUntil = Time.time + num;
			playerRecords[player] = vendorTargetInfo;
		}
		else
		{
			playerRecords.Add(player, new VendorTargetInfo
			{
				blockingAccumulator = 0f,
				ignoredUntil = num,
				lastBlockingTime = 0f,
				lastSeenTime = Time.time
			});
		}
	}

	private bool IsValidPatrons()
	{
		List<BasePlayer> list = localPlayers;
		if ((list != null && list.Count == 0) || localPlayers == null)
		{
			return false;
		}
		return localPlayers.Count > 0;
	}

	private bool IsPlayerIgnored(BasePlayer player)
	{
		if (playerRecords.ContainsKey(player))
		{
			return playerRecords[player].IsIgnored;
		}
		return false;
	}
}


private enum TravellingVendorState
{
	Stopped,
	Travelling,
	Waiting,
	Aligning
}


public static class TravellingVendorFlags
{
	public const Flags Braking = Flags.Reserved1;

	public const Flags IndicateLeft = Flags.Reserved2;

	public const Flags IndicateRight = Flags.Reserved4;

	public const Flags Lights = Flags.Reserved5;

	public const Flags Hazards = Flags.Reserved6;
}


using System;

[Flags]
private enum WheelIsGroundedFlags
{
	RearLeft = 1,
	RearRight = 2,
	FrontLeft = 4,
	FrontRight = 8
}


using System;
using UnityEngine;

[Serializable]
private struct VendorTargetInfo
{
	public float lastSeenTime;

	public float lastBlockingTime;

	public float blockingAccumulator;

	public float ignoredUntil;

	public bool IsIgnored => ignoredUntil > Time.time;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;

[ExecuteInEditMode]
public class TreeEntity : ResourceEntity, IPrefabPreProcess
{
	[Header("Falling")]
	public bool fallOnDied = true;

	public float fallDuration = 1.5f;

	public GameObjectRef fallStartSound;

	public GameObjectRef fallImpactSound;

	public GameObjectRef fallImpactParticles;

	public SoundDefinition fallLeavesLoopDef;

	[NonSerialized]
	public bool[] usedHeights = new bool[20];

	public bool impactSoundPlayed;

	private float treeDistanceUponFalling;

	public GameObjectRef prefab;

	public bool hasBonusGame = true;

	public GameObjectRef bonusHitEffect;

	public GameObjectRef bonusHitSound;

	public Collider serverCollider;

	public Collider clientCollider;

	public SoundDefinition smallCrackSoundDef;

	public SoundDefinition medCrackSoundDef;

	private float lastAttackDamage;

	[Header("Tree Addition Settings")]
	public bool spawnTreeAddition;

	public GameObjectRef treeAdditionPrefab;

	public float treeAdditionSpawnChance = 0.1f;

	public Vector3 treeAdditionSpawnPosition;

	public Vector3 treeAdditionSpawnRotation;

	private BaseEntity treeAdditionRef;

	[NonSerialized]
	public BaseEntity xMarker;

	private int currentBonusLevel;

	private float lastDirection = -1f;

	private float lastHitTime;

	private int lastHitMarkerIndex = -1;

	private float nextBirdTime;

	private uint birdCycleIndex;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TreeEntity.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
	}

	public override float BoundsPadding()
	{
		return 1f;
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0336: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		bool canGather = info.CanGather;
		float num = Time.time - lastHitTime;
		lastHitTime = Time.time;
		DoBirds();
		if (!hasBonusGame || !canGather || (Object)(object)info.Initiator == (Object)null || (BonusActive() && !DidHitMarker(info)))
		{
			base.OnAttacked(info);
			return;
		}
		if ((Object)(object)xMarker != (Object)null && !info.DidGather && info.gatherScale > 0f)
		{
			xMarker.ClientRPC(null, "MarkerHit", currentBonusLevel);
			currentBonusLevel++;
			info.gatherScale = 1f + Mathf.Clamp((float)currentBonusLevel * 0.125f, 0f, 1f);
		}
		Vector3 val = (((Object)(object)xMarker != (Object)null) ? ((Component)xMarker).transform.position : info.HitPositionWorld);
		CleanupMarker();
		TreeMarkerData treeMarkerData = PrefabAttribute.server.Find<TreeMarkerData>(prefabID);
		if (treeMarkerData != null)
		{
			Vector3 nearbyPoint = treeMarkerData.GetNearbyPoint(((Component)this).transform.InverseTransformPoint(val), ref lastHitMarkerIndex, out var normal);
			nearbyPoint = ((Component)this).transform.TransformPoint(nearbyPoint);
			Quaternion rot = QuaternionEx.LookRotationNormal(((Component)this).transform.TransformDirection(normal));
			xMarker = GameManager.server.CreateEntity("assets/content/nature/treesprefabs/trees/effects/tree_marking_nospherecast.prefab", nearbyPoint, rot);
		}
		else
		{
			Vector3 val2 = Vector3Ex.Direction2D(((Component)this).transform.position, val);
			Vector3 val3 = Vector3.Cross(val2, Vector3.up);
			float num2 = lastDirection;
			float num3 = Random.Range(0.5f, 0.5f);
			Vector3 val4 = Vector3.Lerp(-val2, val3 * num2, num3);
			Vector3 val5 = ((Component)this).transform.InverseTransformDirection(((Vector3)(ref val4)).normalized) * 2.5f;
			val5 = ((Component)this).transform.InverseTransformPoint(serverCollider.ClosestPoint(((Component)this).transform.TransformPoint(val5)));
			Vector3 val6 = ((Component)this).transform.TransformPoint(val5);
			Vector3 val7 = ((Component)this).transform.InverseTransformPoint(info.HitPositionWorld);
			val5.y = val7.y;
			Vector3 val8 = ((Component)this).transform.InverseTransformPoint(info.Initiator.CenterPoint());
			float num4 = Mathf.Max(0.75f, val8.y);
			float num5 = val8.y + 0.5f;
			val5.y = Mathf.Clamp(val5.y + Random.Range(0.1f, 0.2f) * ((Random.Range(0, 2) == 0) ? (-1f) : 1f), num4, num5);
			Vector3 val9 = Vector3Ex.Direction2D(((Component)this).transform.position, val6);
			Vector3 val10 = val9;
			val9 = ((Component)this).transform.InverseTransformDirection(val9);
			Quaternion val11 = QuaternionEx.LookRotationNormal(-val9, Vector3.zero);
			val5 = ((Component)this).transform.TransformPoint(val5);
			val11 = QuaternionEx.LookRotationNormal(-val10, Vector3.zero);
			val5 = serverCollider.ClosestPoint(val5);
			Line val12 = default(Line);
			((Line)(ref val12))..ctor(((Component)serverCollider).transform.TransformPoint(new Vector3(0f, 10f, 0f)), ((Component)serverCollider).transform.TransformPoint(new Vector3(0f, -10f, 0f)));
			val11 = QuaternionEx.LookRotationNormal(-Vector3Ex.Direction(((Line)(ref val12)).ClosestPoint(val5), val5));
			xMarker = GameManager.server.CreateEntity("assets/content/nature/treesprefabs/trees/effects/tree_marking.prefab", val5, val11);
		}
		xMarker.Spawn();
		if (num > 5f)
		{
			StartBonusGame();
		}
		base.OnAttacked(info);
		if (health > 0f)
		{
			lastAttackDamage = info.damageTypes.Total();
			int num6 = Mathf.CeilToInt(health / lastAttackDamage);
			if (num6 < 2)
			{
				ClientRPC(null, "CrackSound", 1);
			}
			else if (num6 < 5)
			{
				ClientRPC(null, "CrackSound", 0);
			}
		}
	}

	public override void ServerInit()
	{
		if ((Object)(object)serverCollider == (Object)null)
		{
			serverCollider = clientCollider ?? ((Component)this).GetComponentInChildren<Collider>();
		}
		base.ServerInit();
		lastDirection = ((Random.Range(0, 2) != 0) ? 1 : (-1));
		TryAddTreeAddition();
	}

	public override void ServerInitPostNetworkGroupAssign()
	{
		base.ServerInitPostNetworkGroupAssign();
		TreeManager.OnTreeSpawned(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		CleanupMarker();
		TryKillTreeAddition();
		TreeManager.OnTreeDestroyed(this);
	}

	public bool DidHitMarker(HitInfo info)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)xMarker == (Object)null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnTreeMarkerHit", (object)this, (object)info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PrefabAttribute.server.Find<TreeMarkerData>(prefabID) != null)
		{
			Bounds val = default(Bounds);
			((Bounds)(ref val))..ctor(((Component)xMarker).transform.position, Vector3.one * 0.2f);
			if (((Bounds)(ref val)).Contains(info.HitPositionWorld))
			{
				return true;
			}
		}
		else
		{
			Vector3 val2 = Vector3Ex.Direction2D(((Component)this).transform.position, ((Component)xMarker).transform.position);
			Vector3 attackNormal = info.attackNormal;
			float num = Vector3.Dot(val2, attackNormal);
			float num2 = Vector3.Distance(((Component)xMarker).transform.position, info.HitPositionWorld);
			if (num >= 0.3f && num2 <= 0.2f)
			{
				return true;
			}
		}
		return false;
	}

	public void StartBonusGame()
	{
		if (((FacepunchBehaviour)this).IsInvoking((Action)StopBonusGame))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)StopBonusGame);
		}
		((FacepunchBehaviour)this).Invoke((Action)StopBonusGame, 60f);
	}

	public void StopBonusGame()
	{
		CleanupMarker();
		lastHitTime = 0f;
		currentBonusLevel = 0;
	}

	public bool BonusActive()
	{
		return (Object)(object)xMarker != (Object)null;
	}

	private void DoBirds()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && !(Time.realtimeSinceStartup < nextBirdTime) && !(((Bounds)(ref bounds)).extents.y < 6f))
		{
			uint num = (uint)(int)net.ID.Value + birdCycleIndex;
			if (SeedRandom.Range(ref num, 0, 2) == 0)
			{
				Effect.server.Run("assets/prefabs/npc/birds/birdemission.prefab", ((Component)this).transform.position + Vector3.up * Random.Range(((Bounds)(ref bounds)).extents.y * 0.65f, ((Bounds)(ref bounds)).extents.y * 0.9f), Vector3.up);
			}
			birdCycleIndex++;
			nextBirdTime = Time.realtimeSinceStartup + 90f;
		}
	}

	public void CleanupMarker()
	{
		if (Object.op_Implicit((Object)(object)xMarker))
		{
			xMarker.Kill();
		}
		xMarker = null;
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		if (isKilled)
		{
			return;
		}
		isKilled = true;
		CleanupMarker();
		if (base.isServer)
		{
			StabilityEntity.UpdateSurroundingsQueue updateSurroundingsQueue = StabilityEntity.updateSurroundingsQueue;
			OBB val = WorldSpaceBounds();
			((ObjectWorkQueue<Bounds>)updateSurroundingsQueue).Add(((OBB)(ref val)).ToBounds());
			TryKillTreeAddition();
		}
		if (fallOnDied)
		{
			Collider val2 = serverCollider;
			if (Object.op_Implicit((Object)(object)val2))
			{
				val2.enabled = false;
			}
			Vector3 val3 = info.attackNormal;
			if (val3 == Vector3.zero)
			{
				val3 = Vector3Ex.Direction2D(((Component)this).transform.position, info.PointStart);
			}
			PooledList<TimedExplosive> val4 = Pool.Get<PooledList<TimedExplosive>>();
			try
			{
				foreach (BaseEntity child in children)
				{
					if (child is TimedExplosive item)
					{
						((List<TimedExplosive>)(object)val4).Add(item);
					}
				}
				foreach (TimedExplosive item2 in (List<TimedExplosive>)(object)val4)
				{
					item2.UnStick();
				}
				OnFallServer();
				ClientRPC(RpcTarget.NetworkGroup("TreeFall"), val3);
				((FacepunchBehaviour)this).Invoke((Action)DelayedKill, fallDuration + 1f);
				return;
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
		}
		DelayedKill();
	}

	protected virtual void OnFallServer()
	{
	}

	public void DelayedKill()
	{
		Kill();
	}

	private void TryAddTreeAddition()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		if (spawnTreeAddition && treeAdditionPrefab.isValid && Random.value <= treeAdditionSpawnChance && !((Object)(object)treeAdditionRef != (Object)null))
		{
			treeAdditionRef = GameManager.server.CreateEntity(treeAdditionPrefab.resourcePath, Vector3.zero, Quaternion.identity);
			((Component)treeAdditionRef).transform.position = ((Component)this).transform.TransformPoint(treeAdditionSpawnPosition);
			((Component)treeAdditionRef).transform.rotation = ((Component)this).transform.rotation * Quaternion.Euler(treeAdditionSpawnRotation);
			if ((Object)(object)((Component)treeAdditionRef).GetComponent<Poolable>() != (Object)null)
			{
				((Component)treeAdditionRef).gameObject.AwakeFromInstantiate();
			}
			treeAdditionRef.Spawn();
			treeAdditionRef.SendNetworkUpdate();
		}
	}

	private void TryKillTreeAddition()
	{
		if (spawnTreeAddition && (Object)(object)treeAdditionRef != (Object)null)
		{
			if (treeAdditionRef is BaseCombatEntity baseCombatEntity)
			{
				baseCombatEntity.Die();
			}
			else
			{
				treeAdditionRef.Kill(DestroyMode.Gib);
			}
			treeAdditionRef = null;
		}
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (serverside)
		{
			globalBroadcast = Tree.global_broadcast;
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;
using UnityEngine.Assertions;

public class TreeManager : BaseEntity
{
	private struct ToProcess
	{
		public struct Telemetry
		{
			public TimeSpan InitialTime;

			public TimeSpan IterativeTime;

			public int FramesToComplete;

			public void Report(BasePlayer player)
			{
				TimeSpan timeSpan = InitialTime + IterativeTime;
				TimeSpan timeSpan2 = new TimeSpan((long)(PlayerBudgetMS * 10000f * (float)FramesToComplete));
				TimeSpan timeSpan3 = timeSpan - timeSpan2;
				TimeSpan timeSpan4 = timeSpan / FramesToComplete;
				RustLog.Log(RustLog.EntryType.Network, 1, ((Component)player).gameObject, "TreeManager: Initial: {0}ms, Iterative: {1}ms, Total: {2}ms({3}ms/frame), Overspent: {4}ms", InitialTime.TotalMilliseconds, IterativeTime.TotalMilliseconds, timeSpan.TotalMilliseconds, timeSpan4.TotalMilliseconds, timeSpan3.TotalMilliseconds);
			}
		}

		public BasePlayer Player;

		public BitArray SentCells;

		public int Left;

		public int Range;

		public int OldCellIndex;

		public int LastProcessedIndex;

		public Telemetry Stats;
	}

	private struct TreeCell
	{
		public TreeList TreeList;

		public MemoryStream SerializedCell;

		public bool IsDirty;
	}

	public static ListHashSet<BaseEntity> entities = new ListHashSet<BaseEntity>();

	public static TreeManager server;

	[ServerVar]
	public static bool EnableTreeStreaming = true;

	[ServerVar]
	public static float PlayerBudgetMS = 0.01f;

	[ServerVar]
	public static float UpdateBudgetMS = 1f;

	private const string CellSizeHelp = "Define cell size(in m) of a grid for trees  - only has effect on world load and must be > 1. This affects how much data we send per tree cell(bigger the cell - more trees we have to send). The smaller the cell, the more cells we have to process and the more memory we need per player to track what's left to send(gridSize ^ 2 / 8 bytes). We readjust CellSize to ensure gridSize never exceeds 512.";

	[ServerVar(Help = "Define cell size(in m) of a grid for trees  - only has effect on world load and must be > 1. This affects how much data we send per tree cell(bigger the cell - more trees we have to send). The smaller the cell, the more cells we have to process and the more memory we need per player to track what's left to send(gridSize ^ 2 / 8 bytes). We readjust CellSize to ensure gridSize never exceeds 512.")]
	public static int CellSize = 100;

	private const string UseLazySerializationHelp = "Instead of reserializing grid cell on every tree add/removal(which can cost 0.25ms on 4.5k world), defer it to the streaming update. This reduces amount of times we need to serialize the tree list, but causes the player queue to take longer to process, as that's where evaluation happens.";

	[ServerVar(Help = "Instead of reserializing grid cell on every tree add/removal(which can cost 0.25ms on 4.5k world), defer it to the streaming update. This reduces amount of times we need to serialize the tree list, but causes the player queue to take longer to process, as that's where evaluation happens.")]
	public static bool UseLazySerialization = true;

	private List<ToProcess> playersToProcess = new List<ToProcess>(100);

	private int gridSize = 64;

	private List<TreeCell> treesGrid;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TreeManager.OnRpcMessage", 0);
		try
		{
			if (rpc == 1907121457 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestTrees "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestTrees", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1907121457u, "SERVER_RequestTrees", this, player, 0uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_RequestTrees(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_RequestTrees");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static Vector3 ProtoHalf3ToVec3(Half3 half3)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result = default(Vector3);
		result.x = Mathf.HalfToFloat((ushort)half3.x);
		result.y = Mathf.HalfToFloat((ushort)half3.y);
		result.z = Mathf.HalfToFloat((ushort)half3.z);
		return result;
	}

	public static Half3 Vec3ToProtoHalf3(Vector3 vec3)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Half3 result = default(Half3);
		result.x = Mathf.FloatToHalf(vec3.x);
		result.y = Mathf.FloatToHalf(vec3.y);
		result.z = Mathf.FloatToHalf(vec3.z);
		return result;
	}

	public int GetTreeCount()
	{
		if ((Object)(object)server == (Object)(object)this)
		{
			return entities.Count;
		}
		return -1;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		server = this;
		InitTreeGrid();
	}

	private void InitTreeGrid()
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Expected O, but got Unknown
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		if (CellSize <= 0)
		{
			CellSize = 100;
		}
		gridSize = (int)Mathf.Ceil((float)World.Size / (float)CellSize);
		gridSize = Math.Clamp(gridSize, 1, 512);
		if (gridSize == 512)
		{
			CellSize = (int)Mathf.Ceil((float)World.Size / (float)gridSize);
		}
		RustLog.Log(RustLog.EntryType.Network, 1, null, "TreeManager: using {0}x{0} grid with cell size {1}", gridSize, CellSize);
		treesGrid = new List<TreeCell>(gridSize * gridSize);
		for (int i = 0; i < gridSize * gridSize; i++)
		{
			TreeCell item = default(TreeCell);
			item.TreeList = new TreeList();
			item.TreeList.trees = new List<Tree>();
			item.SerializedCell = new MemoryStream();
			treesGrid.Add(item);
		}
		Enumerator<BaseEntity> enumerator = entities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseEntity current = enumerator.Current;
				Vector2i val = ToCellIndices(current.ServerPosition);
				Tree val2 = Pool.Get<Tree>();
				ExtractTreeNetworkData(current, val2);
				treesGrid[val.y * gridSize + val.x].TreeList.trees.Add(val2);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (TreeCell item2 in treesGrid)
		{
			ProtoStreamExtensions.WriteToStream((IProto)(object)item2.TreeList, (Stream)item2.SerializedCell, false, 2097152);
		}
	}

	public void SendPendingTrees()
	{
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		playersToProcess.RemoveAll((ToProcess record) => (Object)(object)record.Player == (Object)null);
		if (playersToProcess.IsEmpty())
		{
			return;
		}
		playersToProcess.Sort((ToProcess left, ToProcess right) => right.Left - left.Left);
		Stopwatch stopwatch = Pool.Get<Stopwatch>();
		Stopwatch stopwatch2 = Pool.Get<Stopwatch>();
		stopwatch.Start();
		for (int i = 0; i < playersToProcess.Count; i++)
		{
			if (stopwatch.Elapsed.TotalMilliseconds > (double)UpdateBudgetMS)
			{
				break;
			}
			TimeWarning val = TimeWarning.New("Player", 0);
			try
			{
				stopwatch2.Restart();
				ToProcess record2 = playersToProcess[i];
				Vector2i val2 = ToCellIndices(record2.Player.ServerPosition);
				if (record2.OldCellIndex != val2.y * gridSize + val2.x)
				{
					record2.LastProcessedIndex = -1;
					record2.Range = 1;
					record2.OldCellIndex = val2.y * gridSize + val2.x;
				}
				int num = record2.Range;
				while (stopwatch2.Elapsed.TotalMilliseconds < (double)PlayerBudgetMS && record2.Left > 0)
				{
					int num2 = Math.Max(val2.x - num / 2, 0);
					int num3 = Math.Max(val2.y - num / 2, 0);
					int num4 = Math.Min(num2 + num, gridSize - 1);
					int num5 = Math.Min(num3 + num, gridSize - 1);
					for (int j = num2; j <= num4; j++)
					{
						if (SendToPlayer(num3 * gridSize + j, ref record2) && stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
						{
							stopwatch2.Stop();
							break;
						}
					}
					if (stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
					{
						stopwatch2.Stop();
						break;
					}
					if (num5 - num3 > 1)
					{
						for (int k = num3 + 1; k <= num5 - 1; k++)
						{
							if (SendToPlayer(k * gridSize + num2, ref record2) && stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
							{
								stopwatch2.Stop();
								break;
							}
							if (num4 != num2 && SendToPlayer(k * gridSize + num4, ref record2) && stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
							{
								stopwatch2.Stop();
								break;
							}
						}
					}
					if (stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
					{
						stopwatch2.Stop();
						break;
					}
					if (num5 != num3)
					{
						for (int l = num2; l <= num4; l++)
						{
							if (SendToPlayer(num5 * gridSize + l, ref record2) && stopwatch2.Elapsed.TotalMilliseconds >= (double)PlayerBudgetMS)
							{
								stopwatch2.Stop();
								break;
							}
						}
					}
					if (stopwatch2.IsRunning)
					{
						num++;
						record2.LastProcessedIndex = -1;
					}
				}
				record2.Range = num;
				stopwatch2.Stop();
				ToProcess.Telemetry stats = record2.Stats;
				stats.IterativeTime += stopwatch2.Elapsed;
				stats.FramesToComplete++;
				record2.Stats = stats;
				playersToProcess[i] = record2;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		Pool.FreeUnmanaged(ref stopwatch2);
		Pool.FreeUnmanaged(ref stopwatch);
		playersToProcess.RemoveAll(delegate(ToProcess record)
		{
			if (record.Left == 0)
			{
				record.Stats.Report(record.Player);
				return true;
			}
			return false;
		});
		static bool SendToPlayer(int index, ref ToProcess record)
		{
			if (record.LastProcessedIndex >= index || record.SentCells[index])
			{
				return false;
			}
			record.LastProcessedIndex = index;
			record.SentCells[index] = true;
			record.Left--;
			Debug.Assert(record.Left >= 0);
			TreeCell value = server.treesGrid[index];
			if (value.TreeList.trees.IsEmpty())
			{
				return false;
			}
			if (UseLazySerialization && value.IsDirty)
			{
				TimeWarning val3 = TimeWarning.New("LazySerialize", 0);
				try
				{
					value.SerializedCell.SetLength(0L);
					ProtoStreamExtensions.WriteToStream((IProto)(object)value.TreeList, (Stream)value.SerializedCell, false, 2097152);
					value.IsDirty = false;
					server.treesGrid[index] = value;
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			TimeWarning val4 = TimeWarning.New("RPC", 0);
			try
			{
				server.ClientRPC(RpcTarget.Player("CLIENT_ReceiveTrees", record.Player), value.SerializedCell);
				return true;
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
		}
	}

	public static void StartTreesBatch(BasePlayer player)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		Stopwatch stopwatch = Stopwatch.StartNew();
		int num = server.gridSize * server.gridSize;
		BitArray bitArray = new BitArray(num);
		Vector2i val = ToCellIndices(player.ServerPosition);
		int num2 = Math.Max(val.x - 1, 0);
		int num3 = Math.Max(val.y - 1, 0);
		int num4 = Math.Min(num2 + 3, server.gridSize - 1);
		int num5 = Math.Min(num3 + 3, server.gridSize - 1);
		for (int i = num3; i <= num5; i++)
		{
			for (int j = num2; j <= num4; j++)
			{
				int index = i * server.gridSize + j;
				TreeCell value = server.treesGrid[index];
				if (!value.TreeList.trees.IsEmpty())
				{
					if (UseLazySerialization && value.IsDirty)
					{
						TimeWarning val2 = TimeWarning.New("LazySerialize", 0);
						try
						{
							value.SerializedCell.SetLength(0L);
							ProtoStreamExtensions.WriteToStream((IProto)(object)value.TreeList, (Stream)value.SerializedCell, false, 2097152);
							value.IsDirty = false;
							server.treesGrid[index] = value;
						}
						finally
						{
							((IDisposable)val2)?.Dispose();
						}
					}
					server.ClientRPC(RpcTarget.Player("CLIENT_ReceiveTrees", player), value.SerializedCell);
				}
				bitArray[index] = true;
				num--;
			}
		}
		stopwatch.Stop();
		ToProcess toProcess = default(ToProcess);
		toProcess.Player = player;
		toProcess.SentCells = bitArray;
		toProcess.Left = num;
		toProcess.Range = 4;
		toProcess.OldCellIndex = val.y * server.gridSize + val.x;
		toProcess.LastProcessedIndex = -1;
		toProcess.Stats = new ToProcess.Telemetry
		{
			InitialTime = stopwatch.Elapsed,
			FramesToComplete = 1
		};
		ToProcess item = toProcess;
		server.playersToProcess.Add(item);
	}

	private static Vector2i ToCellIndices(Vector3 worldPos)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)World.Size / 2f;
		Vector2 val = Vector3Ex.XZ2D(worldPos) + new Vector2(num, num);
		val.x = Mathf.Clamp(val.x, 0f, (float)(World.Size - 1));
		val.y = Mathf.Clamp(val.y, 0f, (float)(World.Size - 1));
		return new Vector2i((int)(val.x / (float)CellSize), (int)(val.y / (float)CellSize));
	}

	public static void OnTreeDestroyed(BaseEntity billboardEntity)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		entities.Remove(billboardEntity);
		if (Application.isLoading || Application.isQuitting)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("TreeManager.OnTreeDestroyed", 0);
		try
		{
			Vector2i val2 = ToCellIndices(billboardEntity.ServerPosition);
			int index = val2.y * server.gridSize + val2.x;
			TreeCell value = server.treesGrid[index];
			List<Tree> trees = value.TreeList.trees;
			for (int i = 0; i < trees.Count; i++)
			{
				if (trees[i].netId == billboardEntity.net.ID)
				{
					Tree val3 = trees[i];
					Pool.Free<Tree>(ref val3);
					trees.RemoveAt(i);
					if (UseLazySerialization)
					{
						value.IsDirty = true;
						server.treesGrid[index] = value;
					}
					else
					{
						value.SerializedCell.SetLength(0L);
						ProtoStreamExtensions.WriteToStream((IProto)(object)value.TreeList, (Stream)value.SerializedCell, false, 2097152);
					}
					break;
				}
			}
			server.ClientRPC(RpcTarget.NetworkGroup("CLIENT_TreeDestroyed"), billboardEntity.net.ID);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void OnTreeSpawned(BaseEntity billboardEntity)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		if (billboardEntity.net.group != null && billboardEntity.net.group.restricted)
		{
			return;
		}
		entities.Add(billboardEntity);
		if (Application.isLoading || Application.isQuitting)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("TreeManager.OnTreeSpawned", 0);
		try
		{
			Vector2i val2 = ToCellIndices(billboardEntity.ServerPosition);
			int index = val2.y * server.gridSize + val2.x;
			Tree val3 = Pool.Get<Tree>();
			ExtractTreeNetworkData(billboardEntity, val3);
			TreeCell value = server.treesGrid[index];
			value.TreeList.trees.Add(val3);
			if (UseLazySerialization)
			{
				value.IsDirty = true;
				server.treesGrid[index] = value;
			}
			else
			{
				value.SerializedCell.SetLength(0L);
				ProtoStreamExtensions.WriteToStream((IProto)(object)value.TreeList, (Stream)value.SerializedCell, false, 2097152);
			}
			List<Connection> list = Pool.Get<List<Connection>>();
			foreach (Connection subscriber in server.net.group.subscribers)
			{
				bool flag = true;
				for (int i = 0; i < server.playersToProcess.Count; i++)
				{
					ToProcess toProcess = server.playersToProcess[i];
					if (toProcess.Player.Connection == subscriber && !toProcess.SentCells[index])
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					list.Add(subscriber);
				}
			}
			if (!list.IsEmpty())
			{
				Tree val4 = Pool.Get<Tree>();
				try
				{
					ExtractTreeNetworkData(billboardEntity, val4);
					server.ClientRPC(RpcTarget.Players("CLIENT_TreeSpawned", list), val4);
				}
				finally
				{
					((IDisposable)val4)?.Dispose();
				}
			}
			Pool.FreeUnmanaged<Connection>(ref list);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void ExtractTreeNetworkData(BaseEntity billboardEntity, Tree tree)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		tree.netId = billboardEntity.net.ID;
		tree.prefabId = billboardEntity.prefabID;
		tree.position = Vec3ToProtoHalf3(((Component)billboardEntity).transform.position);
		tree.scale = ((Component)billboardEntity).transform.lossyScale.y;
	}

	public static void SendSnapshot(BasePlayer player)
	{
		Stopwatch stopwatch = Stopwatch.StartNew();
		BufferList<BaseEntity> values = entities.Values;
		TreeList val = null;
		for (int i = 0; i < values.Count; i++)
		{
			BaseEntity billboardEntity = values[i];
			Tree val2 = Pool.Get<Tree>();
			ExtractTreeNetworkData(billboardEntity, val2);
			if (val == null)
			{
				val = Pool.Get<TreeList>();
				val.trees = Pool.Get<List<Tree>>();
			}
			val.trees.Add(val2);
			if (val.trees.Count >= ConVar.Server.maxpacketsize_globaltrees)
			{
				server.ClientRPC(RpcTarget.Player("CLIENT_ReceiveTrees", player), val);
				val.Dispose();
				val = null;
			}
		}
		if (val != null)
		{
			server.ClientRPC(RpcTarget.Player("CLIENT_ReceiveTrees", player), val);
			val.Dispose();
			val = null;
		}
		stopwatch.Stop();
		RustLog.Log(RustLog.EntryType.Network, 1, ((Component)player).gameObject, "Took {0}ms to send {1} global trees to {2}", stopwatch.Elapsed.TotalMilliseconds, values.Count, player);
	}

	[RPC_Server.CallsPerSecond(0uL)]
	[RPC_Server]
	private void SERVER_RequestTrees(RPCMessage msg)
	{
		if (EnableTreeStreaming)
		{
			StartTreesBatch(msg.player);
		}
		else
		{
			SendSnapshot(msg.player);
		}
	}
}


using System;
using System.Collections;
using UnityEngine;

private struct ToProcess
{
	public struct Telemetry
	{
		public TimeSpan InitialTime;

		public TimeSpan IterativeTime;

		public int FramesToComplete;

		public void Report(BasePlayer player)
		{
			TimeSpan timeSpan = InitialTime + IterativeTime;
			TimeSpan timeSpan2 = new TimeSpan((long)(PlayerBudgetMS * 10000f * (float)FramesToComplete));
			TimeSpan timeSpan3 = timeSpan - timeSpan2;
			TimeSpan timeSpan4 = timeSpan / FramesToComplete;
			RustLog.Log(RustLog.EntryType.Network, 1, ((Component)player).gameObject, "TreeManager: Initial: {0}ms, Iterative: {1}ms, Total: {2}ms({3}ms/frame), Overspent: {4}ms", InitialTime.TotalMilliseconds, IterativeTime.TotalMilliseconds, timeSpan.TotalMilliseconds, timeSpan4.TotalMilliseconds, timeSpan3.TotalMilliseconds);
		}
	}

	public BasePlayer Player;

	public BitArray SentCells;

	public int Left;

	public int Range;

	public int OldCellIndex;

	public int LastProcessedIndex;

	public Telemetry Stats;
}


using System;
using UnityEngine;

public struct Telemetry
{
	public TimeSpan InitialTime;

	public TimeSpan IterativeTime;

	public int FramesToComplete;

	public void Report(BasePlayer player)
	{
		TimeSpan timeSpan = InitialTime + IterativeTime;
		TimeSpan timeSpan2 = new TimeSpan((long)(PlayerBudgetMS * 10000f * (float)FramesToComplete));
		TimeSpan timeSpan3 = timeSpan - timeSpan2;
		TimeSpan timeSpan4 = timeSpan / FramesToComplete;
		RustLog.Log(RustLog.EntryType.Network, 1, ((Component)player).gameObject, "TreeManager: Initial: {0}ms, Iterative: {1}ms, Total: {2}ms({3}ms/frame), Overspent: {4}ms", InitialTime.TotalMilliseconds, IterativeTime.TotalMilliseconds, timeSpan.TotalMilliseconds, timeSpan4.TotalMilliseconds, timeSpan3.TotalMilliseconds);
	}
}


using System.IO;
using ProtoBuf;

private struct TreeCell
{
	public TreeList TreeList;

	public MemoryStream SerializedCell;

	public bool IsDirty;
}


using System;
using Facepunch;
using Network;
using ProtoBuf;
using Rust.UI;
using Sonar;
using UnityEngine;

public class Tugboat : MotorRowboat
{
	private const Flags Flag_Horn = Flags.Reserved18;

	[Header("Tugboat")]
	[SerializeField]
	private Canvas monitorCanvas;

	[SerializeField]
	private RustText fuelText;

	[SerializeField]
	private RustText speedText;

	[SerializeField]
	private ParticleSystemContainer exhaustEffect;

	[SerializeField]
	private SoundDefinition lightsToggleSound;

	[SerializeField]
	private Transform steeringWheelLeftHandTarget;

	[SerializeField]
	private Transform steeringWheelRightHandTarget;

	[SerializeField]
	private SonarSystem sonar;

	[SerializeField]
	private TugboatSounds tugboatSounds;

	[SerializeField]
	private CanvasGroup canvasGroup;

	[SerializeField]
	private EmissionToggle emissionToggle;

	[SerializeField]
	private AnimationCurve emissionCurve;

	[SerializeField]
	private ParticleSystemContainer fxLightDamage;

	[SerializeField]
	private ParticleSystemContainer fxMediumDamage;

	[SerializeField]
	private ParticleSystemContainer fxHeavyDamage;

	[SerializeField]
	private GameObject heavyDamageLights;

	[SerializeField]
	private TriggerParent parentTrigger;

	[Help("how long until boat corpses despawn (excluding tugboat)")]
	[ServerVar]
	public static float tugcorpseseconds = 7200f;

	[ServerVar(Help = "How long before a tugboat loses all its health while outside")]
	public static float tugdecayminutes = 2160f;

	[ServerVar(Help = "How long until decay begins after the tugboat was last used")]
	public static float tugdecaystartdelayminutes = 1440f;

	public bool LightsAreOn => HasFlag(Flags.Reserved5);

	protected override bool AllowKinematicDrift => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Tugboat.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}

	public override float MaxVelocity()
	{
		return 15f;
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("Tugboat.VehicleFixedUpdate", 0);
		try
		{
			int fuelAmount = fuelSystem.GetFuelAmount();
			base.VehicleFixedUpdate();
			int fuelAmount2 = fuelSystem.GetFuelAmount();
			if (fuelAmount2 != fuelAmount)
			{
				ClientRPC(RpcTarget.NetworkGroup("SetFuelAmount"), fuelAmount2);
			}
			if (LightsAreOn && !IsOn())
			{
				SetFlag(Flags.Reserved5, b: false);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.simpleUint = Pool.Get<SimpleUInt>();
		info.msg.simpleUint.value = (uint)fuelSystem.GetFuelAmount();
	}

	public override void BoatDecay()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!base.IsDying)
		{
			BaseBoat.WaterVehicleDecay(this, 60f, TimeSince.op_Implicit(timeSinceLastUsedFuel), tugdecayminutes, tugdecayminutes, tugdecaystartdelayminutes, preventDecayIndoors);
		}
	}

	public override int StartingFuelUnits()
	{
		return 0;
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			if (!IsOn())
			{
				SetFlag(Flags.Reserved5, b: false);
			}
			else
			{
				SetFlag(Flags.Reserved5, !LightsAreOn);
			}
		}
	}

	protected override void EnterCorpseState()
	{
		((FacepunchBehaviour)this).Invoke((Action)base.ActualDeath, tugcorpseseconds);
	}

	public override bool AnyPlayersOnBoat()
	{
		if (base.AnyPlayersOnBoat())
		{
			return true;
		}
		if ((Object)(object)parentTrigger != (Object)null && parentTrigger.HasAnyEntityContents)
		{
			foreach (BaseEntity entityContent in parentTrigger.entityContents)
			{
				if ((Object)(object)entityContent.ToPlayer() != (Object)null)
				{
					return true;
				}
			}
		}
		return false;
	}

	public override bool BuoyancySleep(bool inWater)
	{
		SetToKinematic();
		return true;
	}

	public override bool BuoyancyWake()
	{
		SetToNonKinematic();
		return true;
	}

	public override void DriverInput(InputState inputState, BasePlayer player)
	{
		base.DriverInput(inputState, player);
		bool flag = inputState.IsDown(BUTTON.FIRE_PRIMARY);
		if (flag != HasFlag(Flags.Reserved18))
		{
			SetFlag(Flags.Reserved18, flag);
		}
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override bool ForceDeployableSetParent()
	{
		return true;
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (IsOn())
		{
			return false;
		}
		if (!IsStationary() || (!(pusher.WaterFactor() <= 0.6f) && !IsFlipped()))
		{
			return false;
		}
		if (!IsFlipped() && pusher.IsStandingOnEntity(this, 1218652417))
		{
			return false;
		}
		if (pusher.IsBuildingBlockedByVehicle())
		{
			return false;
		}
		Vector3 val = ((Component)this).transform.TransformPoint(-Vector3.up);
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(val, waves: true, volumes: false, this);
		if (val.y - waterInfo.surfaceLevel > 2f)
		{
			return false;
		}
		if (base.IsDying)
		{
			return false;
		}
		if (!pusher.isMounted && pusher.IsOnGround())
		{
			return base.healthFraction > 0f;
		}
		return false;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Network.Visibility;
using ProtoBuf;
using UnityEngine;

public class TutorialIsland : BaseEntity, IEntityPingSource
{
	public struct IslandBounds
	{
		public OBB WorldBounds;

		public uint Id;

		public bool Contains(Vector3 pos)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return ((OBB)(ref WorldBounds)).Contains(pos);
		}
	}

	public EntityRef<BasePlayer> ForPlayer;

	public Transform InitialSpawnPoint;

	public Transform MidMissionSpawnPoint;

	public int SpawnLocationIndex;

	public TutorialNPC StartTutorialNPC;

	public TutorialContainer TutorialContainer;

	public MonumentNavMesh MonumentNavMesh;

	public MeshTerrainRoot MeshTerrain;

	public Transform KayakPoint;

	public BaseMission FinalMission;

	[Range(0f, 24f)]
	public float TimeOfDay = 18f;

	public ItemDefinition rockDefinition;

	public WeatherPreset Weather;

	[Header("Debugging")]
	public BaseMission TestMission;

	private TutorialBuildTarget[] buildTargets;

	public static Phrase NoTutorialIslandsAvailablePhrase = new Phrase("no_tutorial_islands_available", "No Tutorial Islands are currently available, please try again later...");

	public static Phrase TutorialIslandStartCooldown = new Phrase("tutorial_island_start_cooldown", "Please wait {0} seconds before starting the tutorial again");

	public static ListHashSet<IslandBounds> BoundsListServer = new ListHashSet<IslandBounds>();

	public static float TutorialBoundsSize = 400f;

	[ServerVar(Saved = true)]
	public static bool SpawnTutorialIslandForNewPlayer = true;

	private static ListHashSet<TutorialIsland> ActiveIslandsServer = new ListHashSet<TutorialIsland>();

	[ServerVar(Saved = true)]
	public static bool EnforceTrespassChecks = true;

	[ServerVar(Help = "Will place the tutorial as close as possible to this pos, only for debugging")]
	public static Vector3 OverrideTutorialLocation = Vector3.zero;

	private const string TutorialIslandAssetPath = "assets/prefabs/missions/tutorialisland/tutorialisland.prefab";

	private static float _tutorialWorldStart = 0f;

	public static Bounds WorldBoundsMinusTutorialIslands;

	private static List<Vector3> islandSpawnLocations;

	private static List<int> freeIslandLocations;

	private float tutorialDuration;

	private float disconnectedDuration;

	private bool readyToStartConversation;

	private float tickRate = 1f;

	private Vector3 kayakAnchorPoint = Vector3.zero;

	private Kayak kayakToAnchor;

	private TimeSince rockCheck;

	public static float TutorialWorldStart
	{
		get
		{
			if (_tutorialWorldStart <= 0f)
			{
				_tutorialWorldStart = ValidBounds.GetMaximumPoint() - TutorialBoundsSize;
			}
			return _tutorialWorldStart;
		}
	}

	public static float TutorialWorldNetworkThreshold => TutorialWorldStart - TutorialBoundsSize;

	public static int MaxTutorialIslandCount => islandSpawnLocations?.Count ?? 0;

	public TimeSpan TutorialDuration => TimeSpan.FromSeconds(tutorialDuration);

	public float DisconnectTimeOutDuration
	{
		get
		{
			if (AvailableIslandCount() > 0)
			{
				return 900f;
			}
			return 300f;
		}
	}

	public static bool HasAvailableTutorialIsland
	{
		get
		{
			if (Server.tutorialEnabled)
			{
				return freeIslandLocations.Count > 0;
			}
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TutorialIsland.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static ListHashSet<TutorialIsland> GetTutorialList(bool isServer)
	{
		if (isServer)
		{
			return ActiveIslandsServer;
		}
		return null;
	}

	public static uint GetTutorialGroupId(int index)
	{
		return (uint)(2 + index);
	}

	public static bool IsTutorialNetworkGroup(uint grp)
	{
		if (grp > 1)
		{
			return grp < 1000;
		}
		return false;
	}

	public static void GenerateIslandSpawnPoints(bool loadingSave = false)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		if (islandSpawnLocations != null && islandSpawnLocations.Count > 0)
		{
			return;
		}
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(0f - ValidBounds.GetMaximumPointTutorial(), 0f, 0f - ValidBounds.GetMaximumPointTutorial());
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(ValidBounds.GetMaximumPointTutorial(), 0f, ValidBounds.GetMaximumPointTutorial());
		Vector3 cellSize = default(Vector3);
		((Vector3)(ref cellSize))..ctor(400f, 0f, 400f);
		islandSpawnLocations = TutorialIslandSpawner.GetEdgeSpawnPoints(val, val2 - val, cellSize, 1, out WorldBoundsMinusTutorialIslands);
		freeIslandLocations = new List<int>();
		for (int i = 0; i < islandSpawnLocations.Count; i++)
		{
			freeIslandLocations.Add(i);
		}
		int num = 0;
		foreach (Vector3 islandSpawnLocation in islandSpawnLocations)
		{
			Group tutorialGroup = GetTutorialGroup(num++);
			OBB val3 = new OBB(islandSpawnLocation, Quaternion.identity, new Bounds(new Vector3(0f, 25f, 0f), new Vector3(400f, 80f, 400f)));
			tutorialGroup.bounds = ((OBB)(ref val3)).ToBounds();
			tutorialGroup.restricted = true;
		}
	}

	public static Group GetTutorialGroup(int index)
	{
		return Net.sv.visibility.Get((uint)(BaseNetworkable.LimboNetworkGroup.ID + 1 + index));
	}

	public static int AvailableIslandCount()
	{
		return freeIslandLocations.Count;
	}

	public static bool ShouldPlayerResumeTutorial(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		return player.IsInTutorial;
	}

	public static bool ShouldPlayerBeAskedToStartTutorial(BasePlayer player)
	{
		if (!Server.tutorialEnabled)
		{
			return false;
		}
		if (player.IsNpc || player.IsBot)
		{
			return false;
		}
		if (player.IsInTutorial)
		{
			return false;
		}
		if (!SpawnTutorialIslandForNewPlayer)
		{
			return false;
		}
		if (!HasAvailableTutorialIsland)
		{
			return false;
		}
		bool infoBool = player.GetInfoBool("client.hasdeclinedtutorial", defaultVal: false);
		if (!player.GetInfoBool("client.hascompletedtutorial", defaultVal: false))
		{
			return !infoBool;
		}
		return false;
	}

	public static TutorialIsland RestoreOrCreateIslandForPlayer(BasePlayer player, bool triggerAnalytics)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		if (player.IsNpc || player.IsBot)
		{
			return null;
		}
		bool flag = !player.HasPlayerFlag(BasePlayer.PlayerFlags.IsInTutorial);
		TutorialIsland tutorialIsland = (flag ? CreateIslandForPlayer(player) : player.GetCurrentTutorialIsland());
		if (!flag && (Object)(object)tutorialIsland != (Object)null)
		{
			SetupGroup(tutorialIsland.SpawnLocationIndex, ((Component)tutorialIsland).transform.position, ((Component)tutorialIsland).transform.rotation);
		}
		if ((Object)(object)tutorialIsland == (Object)null)
		{
			return null;
		}
		tutorialIsland.UpdateNetworkGroup();
		player.SetPlayerFlag(BasePlayer.PlayerFlags.IsInTutorial, b: true);
		if (flag)
		{
			player.net.SwitchGroup(tutorialIsland.net.group);
			player.Teleport(tutorialIsland.InitialSpawnPoint.position);
			((Component)player).transform.rotation = tutorialIsland.InitialSpawnPoint.rotation;
			player.OnStartedTutorial();
			player.inventory.GiveDefaultItems();
			if (triggerAnalytics)
			{
				Analytics.Azure.OnTutorialStarted(player);
			}
		}
		else
		{
			player.net.SwitchGroup(BaseNetworkable.LimboNetworkGroup);
			player.UpdateNetworkGroup();
			foreach (BaseEntity child in tutorialIsland.children)
			{
				if (child is TutorialContainer tutorialContainer)
				{
					tutorialIsland.TutorialContainer = tutorialContainer;
				}
			}
		}
		player.UpdateNetworkGroup();
		player.SendNetworkUpdateImmediate();
		player.ClientRPC(RpcTarget.Player("OnTutorialStarted", player), tutorialIsland.TimeOfDay, ((Object)tutorialIsland.Weather).name);
		tutorialIsland.TestMission = null;
		if (flag)
		{
			if (tutorialIsland.TestMission == null)
			{
				((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)tutorialIsland.StartInitialConversation, 1.5f);
			}
			else
			{
				Debug.LogWarning((object)"Starting test mission instead of initial conversation, clear TestMission field to test actual tutorial");
			}
			if (tutorialIsland.TestMission != null)
			{
				BaseMission.AssignMission(player, tutorialIsland.StartTutorialNPC, tutorialIsland.TestMission);
			}
		}
		Debug.Log((object)(player.displayName + " is being placed on a tutorial island"));
		return tutorialIsland;
	}

	private static TutorialIsland CreateIslandForPlayer(BasePlayer player)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 worldPos;
		Quaternion worldRot;
		int unusedTutorialIslandLocationRotation = GetUnusedTutorialIslandLocationRotation(out worldPos, out worldRot);
		if (unusedTutorialIslandLocationRotation == -1)
		{
			return null;
		}
		Group val = SetupGroup(unusedTutorialIslandLocationRotation, worldPos, worldRot);
		TutorialIsland tutorialIsland = GameManager.server.CreateEntity("assets/prefabs/missions/tutorialisland/tutorialisland.prefab", worldPos, worldRot) as TutorialIsland;
		tutorialIsland.SpawnLocationIndex = unusedTutorialIslandLocationRotation;
		tutorialIsland.GenerateNavMesh();
		ActiveIslandsServer.Add(tutorialIsland);
		AddIslandBounds(tutorialIsland.WorldSpaceBounds(), val.ID, isServer: true);
		tutorialIsland.ForPlayer.Set(player);
		tutorialIsland.Spawn();
		return tutorialIsland;
	}

	private static Group SetupGroup(int spawnLocationIndex, Vector3 worldPos, Quaternion worldRot)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		Group tutorialGroup = GetTutorialGroup(spawnLocationIndex);
		OBB val = new OBB(worldPos, worldRot, new Bounds(new Vector3(0f, 25f, 0f), new Vector3(400f, 80f, 400f)));
		tutorialGroup.bounds = ((OBB)(ref val)).ToBounds();
		tutorialGroup.restricted = true;
		return tutorialGroup;
	}

	private static int GetUnusedTutorialIslandLocationRotation(out Vector3 worldPos, out Quaternion worldRot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		worldRot = Quaternion.identity;
		worldPos = Vector3.zero;
		if (AvailableIslandCount() == 0)
		{
			return -1;
		}
		if (OverrideTutorialLocation != Vector3.zero)
		{
			int num = -1;
			float num2 = float.MaxValue;
			for (int i = 0; i < freeIslandLocations.Count; i++)
			{
				float num3 = Vector3.Distance(OverrideTutorialLocation, islandSpawnLocations[freeIslandLocations[i]]);
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
			worldPos = islandSpawnLocations[num];
			freeIslandLocations.RemoveAt(num);
			return num;
		}
		int num4 = freeIslandLocations[0];
		worldPos = islandSpawnLocations[num4];
		freeIslandLocations.RemoveAt(0);
		float height = TerrainMeta.HeightMap.GetHeight(worldPos);
		if (worldPos.y < height)
		{
			worldPos.y = height;
		}
		return num4;
	}

	public static void AddIslandFromSave(TutorialIsland island)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)("Island being added! Location index: " + island.SpawnLocationIndex));
		if (ActiveIslandsServer.Contains(island))
		{
			Debug.Log((object)"Warning, attempting to add duplicate Island!");
			return;
		}
		ActiveIslandsServer.Add(island);
		AddIslandBounds(island.WorldSpaceBounds(), GetTutorialGroupId(island.SpawnLocationIndex), isServer: true);
		freeIslandLocations.Remove(island.SpawnLocationIndex);
		Debug.Log((object)("Free locations remaining: " + freeIslandLocations.Count + ". Next Index: " + freeIslandLocations[0]));
		island.GenerateNavMesh();
	}

	public void GenerateNavMesh()
	{
		if (!((Object)(object)MonumentNavMesh == (Object)null))
		{
			((MonoBehaviour)this).StartCoroutine(UpdateNavMesh());
		}
	}

	public IEnumerator UpdateNavMesh()
	{
		yield return ((MonoBehaviour)this).StartCoroutine(MonumentNavMesh.UpdateNavMeshAndWait());
	}

	private void StartInitialConversation()
	{
		BasePlayer basePlayer = ForPlayer.Get(base.isServer);
		if ((Object)(object)basePlayer != (Object)null && (basePlayer.IsSleeping() || basePlayer.IsDucked()))
		{
			((FacepunchBehaviour)this).Invoke((Action)StartInitialConversation, 0.1f);
		}
		else if (!readyToStartConversation)
		{
			readyToStartConversation = true;
			((FacepunchBehaviour)this).Invoke((Action)StartInitialConversation, 0.5f);
		}
		else
		{
			StartTutorialNPC.Server_BeginTalking(ForPlayer.Get(base.isServer));
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)InitSpawnGroups, 1f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)Tick, tickRate, tickRate, 0.1f);
	}

	private void InitSpawnGroups()
	{
		List<SpawnGroup> list = Pool.Get<List<SpawnGroup>>();
		((Component)this).gameObject.GetComponentsInChildren<SpawnGroup>(list);
		foreach (SpawnGroup item in list)
		{
			if ((Object)(object)item != (Object)null)
			{
				item.Spawn();
			}
		}
		Pool.FreeUnmanaged<SpawnGroup>(ref list);
	}

	public void OnPlayerBuiltConstruction(BasePlayer player)
	{
		ClientRPC(RpcTarget.Player("ClientOnPlayerBuiltConstruction", player));
	}

	public override void Save(SaveInfo info)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.tutorialIsland == null)
		{
			info.msg.tutorialIsland = Pool.Get<TutorialIsland>();
		}
		TutorialIsland tutorialIsland = info.msg.tutorialIsland;
		tutorialIsland.targetPlayer = ForPlayer.uid;
		tutorialIsland.disconnectDuration = disconnectedDuration;
		tutorialIsland.spawnLocationIndex = SpawnLocationIndex;
		if (info.forDisk)
		{
			tutorialIsland.tutorialDuration = tutorialDuration;
		}
	}

	public void GetBuildTargets(List<TutorialBuildTarget> targetList, uint targetPrefab)
	{
		TutorialBuildTarget[] array = buildTargets;
		foreach (TutorialBuildTarget tutorialBuildTarget in array)
		{
			if (tutorialBuildTarget.TargetPrefab.isValid && tutorialBuildTarget.TargetPrefab.Get().prefabID == targetPrefab)
			{
				targetList.Add(tutorialBuildTarget);
			}
		}
	}

	public Vector3 GetWorldPosOfBuildTarget(int index)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (buildTargets.Length != 0)
		{
			return ((Component)buildTargets[index]).transform.position;
		}
		return ((Component)this).transform.position;
	}

	public void StartEndingCinematic(BasePlayer player)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		BaseMountable mounted = player.GetMounted();
		Vector3 pos = Vector3Ex.WithY(((Component)player).transform.position, Env.oceanlevel);
		if ((Object)(object)mounted != (Object)null && (Object)(object)mounted.VehicleParent() != (Object)null)
		{
			kayakToAnchor = mounted.VehicleParent() as Kayak;
			if ((Object)(object)kayakToAnchor != (Object)null)
			{
				kayakToAnchor.PrepareForTutorialCinematic(KayakPoint.rotation);
				kayakAnchorPoint = pos;
				kayakToAnchor.rigidBody.isKinematic = true;
				kayakToAnchor.rigidBody.useGravity = false;
				((FacepunchBehaviour)this).InvokeRepeating((Action)AnchorKayak, 0f, 0f);
			}
		}
		CinematicScenePlaybackEntity obj = GameManager.server.CreateEntity("assets/prefabs/missions/tutorialisland/endtutorialcinematic.prefab", pos, KayakPoint.rotation) as CinematicScenePlaybackEntity;
		obj.AssignPlayer(player);
		obj.Spawn();
	}

	private void AnchorKayak()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)kayakToAnchor != (Object)null)
		{
			((Component)kayakToAnchor).transform.position = kayakAnchorPoint;
		}
	}

	public void OnPlayerCompletedTutorial(BasePlayer player, bool isQuit, bool triggerAnalytics)
	{
		if ((Object)(object)ForPlayer.Get(serverside: true) != (Object)(object)player)
		{
			Debug.LogWarning((object)$"Attempting to complete tutorial for non-matching player {ForPlayer.Get(serverside: true)} != {player}");
			return;
		}
		_ = player.IsInTutorial;
		if (triggerAnalytics)
		{
			if (isQuit)
			{
				BaseMission.MissionInstance activeMissionInstance = player.GetActiveMissionInstance();
				Analytics.Azure.OnTutorialQuit(player, (activeMissionInstance != null && activeMissionInstance.GetMission() != null) ? activeMissionInstance.GetMission().shortname : "NULL");
			}
			else
			{
				Analytics.Azure.OnTutorialCompleted(player, tutorialDuration);
				player.GiveAchievement("COMPLETE_TUTORIAL", allowTutorial: true);
			}
		}
		((FacepunchBehaviour)this).Invoke((Action)KillPlayerAtEndOfTutorial, 0.1f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)DelayedCompleteTutorial, 0.5f, 0.5f);
	}

	private void KillPlayerAtEndOfTutorial()
	{
		Debug.Log((object)"Kill player");
		BasePlayer basePlayer = ForPlayer.Get(serverside: true);
		basePlayer.ClientRPC(RpcTarget.Player("NotifyTutorialCompleted", basePlayer));
		basePlayer.ClearTutorial();
		ServerMgr.SendReplicatedVars(basePlayer.Connection);
		DeathInfo val = Pool.Get<DeathInfo>();
		val.attackerName = "scientistnpc_full_any";
		if (basePlayer.IsGod())
		{
			basePlayer.net.connection.info.Set("global.god", "0");
		}
		basePlayer.SetOverrideDeathBlow(val);
		basePlayer.Hurt(9999f);
		if (basePlayer.IsGod())
		{
			Debug.LogWarning((object)("Attempting to kill player " + basePlayer.displayName + " at end of tutorial but god mode is active!"));
		}
		basePlayer.ClearTutorial_PostDeath();
	}

	private void DelayedCompleteTutorial()
	{
		BasePlayer basePlayer = ForPlayer.Get(serverside: true);
		if (!((Object)(object)basePlayer != (Object)null) || !basePlayer.IsDead())
		{
			ForPlayer.Set(null);
			Return();
		}
	}

	public void Return()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(WorldSpaceBounds(), list, -1, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!(item is BasePlayer) && !(item is TutorialIsland) && !item.isClient && !item.IsDestroyed)
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		BasePlayer basePlayer = ForPlayer.Get(serverside: true);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.AbandonActiveMission();
		}
		ForPlayer.Set(null);
		ReturnIsland(this);
		disconnectedDuration = 0f;
	}

	private static void ReturnIsland(TutorialIsland island)
	{
		freeIslandLocations.Add(island.SpawnLocationIndex);
		island.Kill();
	}

	public void Tick()
	{
		TickPlayerConnectionStatus();
	}

	private void TickPlayerConnectionStatus()
	{
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = ForPlayer.Get(base.isServer);
		tutorialDuration += tickRate;
		if ((Object)(object)basePlayer == (Object)null || basePlayer.IsSleeping())
		{
			disconnectedDuration += tickRate;
			if (disconnectedDuration >= DisconnectTimeOutDuration)
			{
				if ((Object)(object)basePlayer != (Object)null)
				{
					basePlayer.ClearTutorial();
					basePlayer.Hurt(99999f);
					basePlayer.ClearTutorial_PostDeath();
					basePlayer.ClientRPCPlayer(null, basePlayer, "NotifyTutorialCompleted");
				}
				Return();
			}
			return;
		}
		disconnectedDuration = 0f;
		if (!((Object)(object)basePlayer != (Object)null) || !((Object)(object)rockDefinition != (Object)null) || !(TimeSince.op_Implicit(rockCheck) > 10f))
		{
			return;
		}
		rockCheck = TimeSince.op_Implicit(0f);
		if (basePlayer.inventory.GetAmount(rockDefinition) == 0 && basePlayer.inventory.HasEmptySlotInBeltOrMain())
		{
			Item item = ItemManager.Create(rockDefinition, 1, 0uL);
			if (!basePlayer.inventory.GiveItem(item))
			{
				item.Remove();
			}
		}
	}

	public bool IsPingValid(MapNote note)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		TutorialBuildTarget[] array = buildTargets;
		foreach (TutorialBuildTarget tutorialBuildTarget in array)
		{
			if (((Component)tutorialBuildTarget).gameObject.activeSelf && Vector3.Distance(((Component)tutorialBuildTarget).transform.position, note.worldPosition) < 0.1f)
			{
				return true;
			}
		}
		Vector3 val = note.worldPosition - KayakPoint.position;
		if (((Vector3)(ref val)).sqrMagnitude < 10f)
		{
			return true;
		}
		return false;
	}

	public static TutorialIsland GetClosestTutorialIsland(Vector3 position, float maxRange)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		float num2 = float.MaxValue;
		for (int i = 0; i < ActiveIslandsServer.Count; i++)
		{
			TutorialIsland tutorialIsland = ActiveIslandsServer[i];
			if ((Object)(object)tutorialIsland != (Object)null)
			{
				float num3 = tutorialIsland.Distance2D(position);
				if (num3 < maxRange && num3 < num2)
				{
					num2 = num3;
					num = i;
				}
			}
		}
		if (num < 0)
		{
			return null;
		}
		return ActiveIslandsServer[num];
	}

	public void OnPlayerStartedMission(BasePlayer player)
	{
		TutorialBuildTarget[] array = buildTargets;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateActive(player);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.tutorialIsland != null)
		{
			TutorialIsland tutorialIsland = info.msg.tutorialIsland;
			ForPlayer.uid = tutorialIsland.targetPlayer;
			SpawnLocationIndex = tutorialIsland.spawnLocationIndex;
			disconnectedDuration = tutorialIsland.disconnectDuration;
			tutorialDuration = tutorialIsland.tutorialDuration;
			if (base.isServer && info.fromDisk)
			{
				AddIslandFromSave(this);
			}
		}
	}

	public bool CheckPlacement(Construction toConstruct, Construction.Target target, ref Construction.Placement placement)
	{
		TutorialBuildTarget[] array = buildTargets;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].IsValid(toConstruct, target, ref placement))
			{
				return true;
			}
		}
		return false;
	}

	public bool CheckPlacement(BasePlayer forPlayer, Deployable deployable, Vector3 worldPosition, Quaternion worldRotation)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		TutorialBuildTarget[] array = buildTargets;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].IsValid(forPlayer, deployable, worldPosition, worldRotation))
			{
				return true;
			}
		}
		return false;
	}

	public override void InitShared()
	{
		base.InitShared();
		buildTargets = ((Component)this).GetComponentsInChildren<TutorialBuildTarget>();
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer && ActiveIslandsServer.Contains(this))
		{
			RemoveIslandBounds(GetTutorialGroupId(SpawnLocationIndex), isServer: true);
			ActiveIslandsServer.Remove(this);
		}
	}

	private static void AddIslandBounds(OBB worldBounds, uint netId, bool isServer)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (isServer)
		{
			BoundsListServer.Add(new IslandBounds
			{
				Id = netId,
				WorldBounds = worldBounds
			});
		}
	}

	private static void RemoveIslandBounds(uint netId, bool isServer)
	{
		if (!isServer)
		{
			return;
		}
		for (int i = 0; i < BoundsListServer.Count; i++)
		{
			if (BoundsListServer[i].Id == netId)
			{
				BoundsListServer.RemoveAt(i);
				break;
			}
		}
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override bool ForceDeployableSetParent()
	{
		return true;
	}
}


using UnityEngine;

public struct IslandBounds
{
	public OBB WorldBounds;

	public uint Id;

	public bool Contains(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref WorldBounds)).Contains(pos);
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using Rust.Modular;
using UnityEngine;
using UnityEngine.Assertions;

public class VehicleModuleCamper : VehicleModuleSeating
{
	public GameObjectRef SleepingBagEntity;

	public Transform[] SleepingBagPoints;

	public GameObjectRef LockerEntity;

	public Transform LockerPoint;

	public GameObjectRef BbqEntity;

	public Transform BbqPoint;

	public GameObjectRef StorageEntity;

	public Transform StoragePoint;

	public EntityRef<BaseOven> activeBbq;

	public EntityRef<Locker> activeLocker;

	public EntityRef<StorageContainer> activeStorage;

	private bool wasLoaded;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehicleModuleCamper.OnRpcMessage", 0);
		try
		{
			if (rpc == 2501069650u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLocker "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLocker", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2501069650u, "RPC_OpenLocker", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_OpenLocker(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_OpenLocker");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4185921214u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenStorage "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenStorage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4185921214u, "RPC_OpenStorage", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_OpenStorage(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_OpenStorage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		activeBbq.Set(null);
		activeLocker.Set(null);
		activeStorage.Set(null);
		wasLoaded = false;
	}

	public override void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.ModuleAdded(vehicle, firstSocketIndex);
		if (!base.isServer)
		{
			return;
		}
		if (!Application.isLoadingSave && !wasLoaded)
		{
			for (int i = 0; i < SleepingBagPoints.Length; i++)
			{
				SleepingBagCamper sleepingBagCamper = base.gameManager.CreateEntity(SleepingBagEntity.resourcePath, SleepingBagPoints[i].localPosition, SleepingBagPoints[i].localRotation) as SleepingBagCamper;
				if ((Object)(object)sleepingBagCamper != (Object)null)
				{
					sleepingBagCamper.SetParent(this);
					sleepingBagCamper.SetSeat(GetSeatAtIndex(i));
					sleepingBagCamper.Spawn();
				}
			}
			PostConditionalRefresh();
			return;
		}
		int num = 0;
		foreach (BaseEntity child in children)
		{
			if (child is SleepingBagCamper sleepingBagCamper2)
			{
				sleepingBagCamper2.SetSeat(GetSeatAtIndex(num++), sendNetworkUpdate: true);
			}
			else if (child is IItemContainerEntity itemContainerEntity)
			{
				ItemContainer inventory = itemContainerEntity.inventory;
				inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			}
		}
	}

	protected override Vector3 ModifySeatPositionLocalSpace(int index, Vector3 desiredPos)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		CamperSeatConfig seatConfig = GetSeatConfig();
		if ((Object)(object)seatConfig != (Object)null && seatConfig.SeatPositions.Length > index)
		{
			return seatConfig.SeatPositions[index].localPosition;
		}
		return base.ModifySeatPositionLocalSpace(index, desiredPos);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		wasLoaded = true;
	}

	public override void Spawn()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			Locker locker = base.gameManager.CreateEntity(LockerEntity.resourcePath, LockerPoint.localPosition, LockerPoint.localRotation) as Locker;
			locker.SetParent(this);
			locker.Spawn();
			ItemContainer inventory = locker.inventory;
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			activeLocker.Set(locker);
			BaseOven baseOven = base.gameManager.CreateEntity(BbqEntity.resourcePath, BbqPoint.localPosition, BbqPoint.localRotation) as BaseOven;
			baseOven.SetParent(this);
			baseOven.Spawn();
			ItemContainer inventory2 = baseOven.inventory;
			inventory2.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory2.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			activeBbq.Set(baseOven);
			StorageContainer storageContainer = base.gameManager.CreateEntity(StorageEntity.resourcePath, StoragePoint.localPosition, StoragePoint.localRotation) as StorageContainer;
			storageContainer.SetParent(this);
			storageContainer.Spawn();
			ItemContainer inventory3 = storageContainer.inventory;
			inventory3.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory3.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			activeStorage.Set(storageContainer);
			PostConditionalRefresh();
		}
	}

	private void OnItemAddedRemoved(Item item, bool add)
	{
		AssociatedItemInstance?.LockUnlock(!CanBeMovedNowOnVehicle());
	}

	protected override bool CanBeMovedNowOnVehicle()
	{
		foreach (BaseEntity child in children)
		{
			if (child is IItemContainerEntity itemContainerEntity && !itemContainerEntity.IsUnityNull() && !itemContainerEntity.inventory.IsEmpty())
			{
				return false;
			}
		}
		return true;
	}

	protected override void PostConditionalRefresh()
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		base.PostConditionalRefresh();
		if (base.isClient)
		{
			return;
		}
		CamperSeatConfig seatConfig = GetSeatConfig();
		if ((Object)(object)seatConfig != (Object)null && mountPoints != null)
		{
			for (int i = 0; i < mountPoints.Count; i++)
			{
				if ((Object)(object)mountPoints[i].mountable != (Object)null)
				{
					((Component)mountPoints[i].mountable).transform.position = seatConfig.SeatPositions[i].position;
					mountPoints[i].mountable.SendNetworkUpdate();
				}
			}
		}
		if (activeBbq.IsValid(base.isServer) && (Object)(object)seatConfig != (Object)null)
		{
			BaseOven baseOven = activeBbq.Get(serverside: true);
			((Component)baseOven).transform.position = seatConfig.StovePosition.position;
			((Component)baseOven).transform.rotation = seatConfig.StovePosition.rotation;
			baseOven.SendNetworkUpdate();
		}
		if (activeStorage.IsValid(base.isServer) && (Object)(object)seatConfig != (Object)null)
		{
			StorageContainer storageContainer = activeStorage.Get(base.isServer);
			((Component)storageContainer).transform.position = seatConfig.StoragePosition.position;
			((Component)storageContainer).transform.rotation = seatConfig.StoragePosition.rotation;
			storageContainer.SendNetworkUpdate();
		}
	}

	private CamperSeatConfig GetSeatConfig()
	{
		List<ConditionalObject> list = GetConditionals();
		CamperSeatConfig result = null;
		CamperSeatConfig camperSeatConfig = default(CamperSeatConfig);
		foreach (ConditionalObject item in list)
		{
			if (item.gameObject.activeSelf && item.gameObject.TryGetComponent<CamperSeatConfig>(ref camperSeatConfig))
			{
				result = camperSeatConfig;
			}
		}
		return result;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.camperModule == null)
		{
			info.msg.camperModule = Pool.Get<CamperModule>();
		}
		info.msg.camperModule.bbqId = activeBbq.uid;
		info.msg.camperModule.lockerId = activeLocker.uid;
		info.msg.camperModule.storageID = activeStorage.uid;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_OpenLocker(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			IItemContainerEntity itemContainerEntity = activeLocker.Get(base.isServer);
			if (!itemContainerEntity.IsUnityNull())
			{
				itemContainerEntity.PlayerOpenLoot(player);
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_OpenStorage(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			IItemContainerEntity itemContainerEntity = activeStorage.Get(base.isServer);
			if (!itemContainerEntity.IsUnityNull())
			{
				itemContainerEntity.PlayerOpenLoot(player);
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
			}
		}
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot)
		{
			if (activeStorage.IsValid(base.isServer))
			{
				activeStorage.Get(base.isServer).DropItems();
			}
			if (activeBbq.IsValid(base.isServer))
			{
				activeBbq.Get(base.isServer).DropItems();
			}
			if (activeLocker.IsValid(base.isServer))
			{
				activeLocker.Get(base.isServer).DropItems();
			}
		}
		base.DoServerDestroy();
	}

	public IItemContainerEntity GetContainer()
	{
		Locker locker = activeLocker.Get(base.isServer);
		if ((Object)(object)locker != (Object)null && locker.IsValid() && !locker.inventory.IsEmpty())
		{
			return locker;
		}
		BaseOven baseOven = activeBbq.Get(base.isServer);
		if ((Object)(object)baseOven != (Object)null && baseOven.IsValid() && !baseOven.inventory.IsEmpty())
		{
			return baseOven;
		}
		StorageContainer storageContainer = activeStorage.Get(base.isServer);
		if ((Object)(object)storageContainer != (Object)null && storageContainer.IsValid() && !storageContainer.inventory.IsEmpty())
		{
			return storageContainer;
		}
		return null;
	}

	public override string Admin_Who()
	{
		StringBuilder stringBuilder = new StringBuilder();
		int num = 0;
		foreach (BaseEntity child in children)
		{
			if (child is SleepingBagCamper sleepingBagCamper)
			{
				stringBuilder.AppendLine($"Bag {num++}:");
				stringBuilder.AppendLine(sleepingBagCamper.Admin_Who());
			}
		}
		return stringBuilder.ToString();
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (base.IsOnAVehicle && base.Vehicle.IsDead())
		{
			return base.CanBeLooted(player);
		}
		if (base.CanBeLooted(player))
		{
			return IsOnThisModule(player);
		}
		return false;
	}

	public override bool IsOnThisModule(BasePlayer player)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (base.IsOnThisModule(player))
		{
			return true;
		}
		if (!player.isMounted)
		{
			return false;
		}
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(((Component)this).transform, bounds);
		return ((OBB)(ref val)).Contains(player.CenterPoint());
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.camperModule != null)
		{
			activeBbq.uid = info.msg.camperModule.bbqId;
			activeLocker.uid = info.msg.camperModule.lockerId;
			activeStorage.uid = info.msg.camperModule.storageID;
		}
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class VehicleModuleSeating : BaseVehicleModule, IPrefabPreProcess
{
	[Serializable]
	public class MountHotSpot
	{
		public Transform transform;

		public Vector2 size;
	}

	[Serializable]
	public class Seating
	{
		[Header("Seating & Controls")]
		public bool doorsAreLockable = true;

		[Obsolete("Use BaseVehicle.mountPoints instead")]
		[HideInInspector]
		public MountPointInfo[] mountPoints;

		public Transform steeringWheel;

		public Transform accelPedal;

		public Transform brakePedal;

		public Transform steeringWheelLeftGrip;

		public Transform steeringWheelRightGrip;

		public Transform accelPedalGrip;

		public Transform brakePedalGrip;

		public MountHotSpot[] mountHotSpots;

		[Header("Dashboard")]
		public Transform speedometer;

		public Transform fuelGauge;

		public Renderer dashboardRenderer;

		[Range(0f, 3f)]
		public int checkEngineLightMatIndex = 2;

		[ColorUsage(true, true)]
		public Color checkEngineLightEmission;

		[Range(0f, 3f)]
		public int fuelLightMatIndex = 3;

		[ColorUsage(true, true)]
		public Color fuelLightEmission;
	}

	[SerializeField]
	private ProtectionProperties passengerProtection;

	[SerializeField]
	private ModularCarCodeLockVisuals codeLockVisuals;

	[SerializeField]
	private Seating seating;

	[HideInInspector]
	[SerializeField]
	private Vector3 steerAngle;

	[SerializeField]
	[HideInInspector]
	private Vector3 accelAngle;

	[SerializeField]
	[HideInInspector]
	private Vector3 brakeAngle;

	[SerializeField]
	[HideInInspector]
	private Vector3 speedometerAngle;

	[SerializeField]
	[HideInInspector]
	private Vector3 fuelAngle;

	[SerializeField]
	[Header("Horn")]
	private SoundDefinition hornLoop;

	[SerializeField]
	private SoundDefinition hornStart;

	private const Flags FLAG_HORN = Flags.Reserved8;

	private float steerPercent;

	private float throttlePercent;

	private float brakePercent;

	private bool? checkEngineLightOn;

	private bool? fuelLightOn;

	protected IVehicleLockUser VehicleLockUser;

	private MaterialPropertyBlock dashboardLightPB;

	private static int emissionColorID = Shader.PropertyToID("_EmissionColor");

	private BasePlayer hornPlayer;

	public override bool HasSeating => mountPoints.Count > 0;

	public ModularCar Car { get; private set; }

	protected bool IsOnACar => (Object)(object)Car != (Object)null;

	protected bool IsOnAVehicleLockUser => VehicleLockUser != null;

	public bool DoorsAreLockable => seating.doorsAreLockable;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehicleModuleSeating.OnRpcMessage", 0);
		try
		{
			if (rpc == 2791546333u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_DestroyLock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_DestroyLock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2791546333u, "RPC_DestroyLock", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_DestroyLock(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_DestroyLock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if ((Object)(object)seating.steeringWheel != (Object)null)
		{
			steerAngle = seating.steeringWheel.localEulerAngles;
		}
		if ((Object)(object)seating.accelPedal != (Object)null)
		{
			accelAngle = seating.accelPedal.localEulerAngles;
		}
		if ((Object)(object)seating.brakePedal != (Object)null)
		{
			brakeAngle = seating.brakePedal.localEulerAngles;
		}
		if ((Object)(object)seating.speedometer != (Object)null)
		{
			speedometerAngle = new Vector3(-160f, 0f, -40f);
		}
		if ((Object)(object)seating.fuelGauge != (Object)null)
		{
			fuelAngle = seating.fuelGauge.localEulerAngles;
		}
	}

	public virtual bool IsOnThisModule(BasePlayer player)
	{
		BaseMountable mounted = player.GetMounted();
		if ((Object)(object)mounted != (Object)null)
		{
			return (Object)(object)(mounted.GetParentEntity() as VehicleModuleSeating) == (Object)(object)this;
		}
		return false;
	}

	public bool HasADriverSeat()
	{
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (mountPoint.isDriver)
			{
				return true;
			}
		}
		return false;
	}

	public override void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex)
	{
		base.ModuleAdded(vehicle, firstSocketIndex);
		Car = vehicle as ModularCar;
		VehicleLockUser = vehicle as IVehicleLockUser;
		if (!HasSeating || !base.isServer)
		{
			return;
		}
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (mountPoint.mountable is ModularCarSeat modularCarSeat)
			{
				modularCarSeat.associatedSeatingModule = this;
			}
		}
	}

	public override void ModuleRemoved()
	{
		base.ModuleRemoved();
		Car = null;
		VehicleLockUser = null;
	}

	public bool PlayerCanDestroyLock(BasePlayer player)
	{
		if (!IsOnAVehicleLockUser || (Object)(object)player == (Object)null)
		{
			return false;
		}
		if (base.Vehicle.IsDead())
		{
			return false;
		}
		if (!HasADriverSeat())
		{
			return false;
		}
		if (!VehicleLockUser.PlayerCanDestroyLock(player, this))
		{
			return false;
		}
		if (player.isMounted)
		{
			return !VehicleLockUser.PlayerHasUnlockPermission(player);
		}
		return true;
	}

	protected BaseVehicleSeat GetSeatAtIndex(int index)
	{
		return mountPoints[index].mountable as BaseVehicleSeat;
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		if ((Object)(object)passengerProtection != (Object)null)
		{
			passengerProtection.Scale(info.damageTypes);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if ((Object)(object)hornLoop != (Object)null && IsOnThisModule(player))
		{
			bool flag = inputState.IsDown(BUTTON.FIRE_PRIMARY);
			if (flag != HasFlag(Flags.Reserved8))
			{
				SetFlag(Flags.Reserved8, flag);
			}
			if (flag)
			{
				Interface.CallHook("OnVehicleHornPressed", (object)this, (object)player);
				hornPlayer = player;
			}
		}
	}

	public override void OnPlayerDismountedVehicle(BasePlayer player)
	{
		base.OnPlayerDismountedVehicle(player);
		if (HasFlag(Flags.Reserved8) && (Object)(object)player == (Object)(object)hornPlayer)
		{
			SetFlag(Flags.Reserved8, b: false);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_DestroyLock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (IsOnAVehicleLockUser && PlayerCanDestroyLock(player))
		{
			VehicleLockUser.RemoveLock();
		}
	}

	protected virtual Vector3 ModifySeatPositionLocalSpace(int index, Vector3 desiredPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return desiredPos;
	}

	public override void OnEngineStateChanged(VehicleEngineController<GroundVehicle>.EngineState oldState, VehicleEngineController<GroundVehicle>.EngineState newState)
	{
		base.OnEngineStateChanged(oldState, newState);
		if (!GameInfo.HasAchievements || base.isClient || newState != VehicleEngineController<GroundVehicle>.EngineState.On || mountPoints == null)
		{
			return;
		}
		bool flag = true;
		foreach (BaseVehicleModule attachedModuleEntity in Car.AttachedModuleEntities)
		{
			if (attachedModuleEntity is VehicleModuleEngine { AtPeakPerformance: false })
			{
				flag = false;
				break;
			}
		}
		if (!flag)
		{
			return;
		}
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if ((Object)(object)mountPoint.mountable.GetMounted() != (Object)null)
			{
				mountPoint.mountable.GetMounted().GiveAchievement("BUCKLE_UP");
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class MountHotSpot
{
	public Transform transform;

	public Vector2 size;
}


using System;
using UnityEngine;

[Serializable]
public class Seating
{
	[Header("Seating & Controls")]
	public bool doorsAreLockable = true;

	[Obsolete("Use BaseVehicle.mountPoints instead")]
	[HideInInspector]
	public MountPointInfo[] mountPoints;

	public Transform steeringWheel;

	public Transform accelPedal;

	public Transform brakePedal;

	public Transform steeringWheelLeftGrip;

	public Transform steeringWheelRightGrip;

	public Transform accelPedalGrip;

	public Transform brakePedalGrip;

	public MountHotSpot[] mountHotSpots;

	[Header("Dashboard")]
	public Transform speedometer;

	public Transform fuelGauge;

	public Renderer dashboardRenderer;

	[Range(0f, 3f)]
	public int checkEngineLightMatIndex = 2;

	[ColorUsage(true, true)]
	public Color checkEngineLightEmission;

	[Range(0f, 3f)]
	public int fuelLightMatIndex = 3;

	[ColorUsage(true, true)]
	public Color fuelLightEmission;
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class VehicleModuleStorage : VehicleModuleSeating
{
	[Serializable]
	public class Storage
	{
		public GameObjectRef storageUnitPrefab;

		public Transform storageUnitPoint;
	}

	[SerializeField]
	private Storage storage;

	private EntityRef storageUnitInstance;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehicleModuleStorage.OnRpcMessage", 0);
		try
		{
			if (rpc == 4254195175u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Open "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Open", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4254195175u, "RPC_Open", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Open(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Open");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 425471188 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TryOpenWithKeycode "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TryOpenWithKeycode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(425471188u, "RPC_TryOpenWithKeycode", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_TryOpenWithKeycode(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_TryOpenWithKeycode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public IItemContainerEntity GetContainer()
	{
		BaseEntity baseEntity = storageUnitInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as IItemContainerEntity;
		}
		return null;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		storageUnitInstance.uid = info.msg.simpleUID.uid;
	}

	public override void Spawn()
	{
		base.Spawn();
		if (!Application.isLoadingSave && ((Component)storage.storageUnitPoint).gameObject.activeSelf)
		{
			CreateStorageEntity();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		IItemContainerEntity container = GetContainer();
		if (!container.IsUnityNull())
		{
			ItemContainer inventory = container.inventory;
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
		}
	}

	private void OnItemAddedRemoved(Item item, bool add)
	{
		AssociatedItemInstance?.LockUnlock(!CanBeMovedNowOnVehicle());
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot)
		{
			IItemContainerEntity container = GetContainer();
			if (!container.IsUnityNull())
			{
				container.DropItems();
			}
		}
		base.DoServerDestroy();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.simpleUID = Pool.Get<SimpleUID>();
		info.msg.simpleUID.uid = storageUnitInstance.uid;
	}

	public void CreateStorageEntity()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (IsFullySpawned() && base.isServer && !storageUnitInstance.IsValid(base.isServer))
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(storage.storageUnitPrefab.resourcePath, storage.storageUnitPoint.localPosition, storage.storageUnitPoint.localRotation);
			storageUnitInstance.Set(baseEntity);
			baseEntity.SetParent(this);
			baseEntity.Spawn();
			ItemContainer inventory = GetContainer().inventory;
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
		}
	}

	public void DestroyStorageEntity()
	{
		if (!IsFullySpawned() || !base.isServer)
		{
			return;
		}
		BaseEntity baseEntity = storageUnitInstance.Get(base.isServer);
		if (baseEntity.IsValid())
		{
			if (baseEntity is BaseCombatEntity baseCombatEntity)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill();
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_Open(RPCMessage msg)
	{
		TryOpen(msg.player);
	}

	private bool TryOpen(BasePlayer player)
	{
		if (!player.IsValid() || !CanBeLooted(player))
		{
			return false;
		}
		IItemContainerEntity container = GetContainer();
		if (!container.IsUnityNull())
		{
			container.PlayerOpenLoot(player);
		}
		else
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": No container component found."));
		}
		return true;
	}

	protected override bool CanBeMovedNowOnVehicle()
	{
		IItemContainerEntity container = GetContainer();
		if (!container.IsUnityNull() && !container.inventory.IsEmpty())
		{
			return false;
		}
		return true;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_TryOpenWithKeycode(RPCMessage msg)
	{
		if (!base.IsOnACar)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null))
		{
			string codeEntered = msg.read.String(256, false);
			if (base.Car.CarLock.TryOpenWithCode(player, codeEntered))
			{
				TryOpen(player);
			}
			else
			{
				base.Car.ClientRPC(RpcTarget.NetworkGroup("CodeEntryFailed"));
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class Storage
{
	public GameObjectRef storageUnitPrefab;

	public Transform storageUnitPoint;
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class VehicleModuleTaxi : VehicleModuleStorage
{
	[Header("Taxi")]
	[SerializeField]
	private SoundDefinition kickButtonSound;

	[SerializeField]
	private SphereCollider kickButtonCollider;

	[SerializeField]
	private float maxKickVelocity = 4f;

	private Vector3 KickButtonPos => ((Component)kickButtonCollider).transform.position + ((Component)kickButtonCollider).transform.rotation * kickButtonCollider.center;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehicleModuleTaxi.OnRpcMessage", 0);
		try
		{
			if (rpc == 2714639811u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_KickPassengers "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_KickPassengers", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2714639811u, "RPC_KickPassengers", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_KickPassengers(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_KickPassengers");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private bool CanKickPassengers(BasePlayer player)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (!base.IsOnAVehicle)
		{
			return false;
		}
		if (base.Vehicle.GetSpeed() > maxKickVelocity)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (!base.Vehicle.PlayerIsMounted(player))
		{
			return false;
		}
		Vector3 val = KickButtonPos - ((Component)player).transform.position;
		if (Vector3.Dot(val, ((Component)player).transform.forward) < 0f)
		{
			return ((Vector3)(ref val)).sqrMagnitude < 4f;
		}
		return false;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_KickPassengers(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanKickPassengers(player))
		{
			KickPassengers();
		}
	}

	private void KickPassengers()
	{
		if (!base.IsOnAVehicle)
		{
			return;
		}
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			BaseMountable mountable = mountPoint.mountable;
			BasePlayer mounted = mountable.GetMounted();
			if ((Object)(object)mounted != (Object)null && mountable.HasValidDismountPosition(mounted))
			{
				mountable.AttemptDismount(mounted);
			}
		}
	}
}


using System;
using System.Linq;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class VehiclePrivilege : SimplePrivilege
{
	public GameObject assignDialog;

	public bool SupportFriendListAdd;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VehiclePrivilege.OnRpcMessage", 0);
		try
		{
			if (rpc == 82205621 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AddAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("AddAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(82205621u, "AddAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							AddAuthorize(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AddAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1092560690 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AddSelfAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("AddSelfAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1092560690u, "AddSelfAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							AddSelfAuthorize(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in AddSelfAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 253307592 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearList "));
				}
				TimeWarning val2 = TimeWarning.New("ClearList", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(253307592u, "ClearList", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							ClearList(rpc4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in ClearList");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3617985969u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RemoveSelfAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("RemoveSelfAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3617985969u, "RemoveSelfAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc5 = rPCMessage;
							RemoveSelfAuthorize(rpc5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RemoveSelfAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsDriver(BasePlayer player)
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return false;
		}
		BaseVehicle baseVehicle = baseEntity as BaseVehicle;
		if ((Object)(object)baseVehicle == (Object)null)
		{
			return false;
		}
		return baseVehicle.IsDriver(player);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void AddSelfAuthorize(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsDriver(rpc.player) && Interface.CallHook("OnCupboardAuthorize", (object)this, (object)rpc.player) == null)
		{
			AddPlayer(rpc.player);
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void AddAuthorize(RPCMessage rpc)
	{
		if (SupportFriendListAdd && rpc.player.CanInteract() && IsAuthed(rpc.player) && IsDriver(rpc.player))
		{
			ulong targetPlayerId = rpc.read.UInt64();
			AddPlayer(rpc.player, targetPlayerId);
			SendNetworkUpdate();
		}
	}

	public void AddPlayer(BasePlayer granter, ulong targetPlayerId)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Expected O, but got Unknown
		if (!AtMaxAuthCapacity())
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == targetPlayerId);
			PlayerNameID val = new PlayerNameID();
			val.userid = targetPlayerId;
			string username = BasePlayer.FindByID(targetPlayerId)?.displayName ?? "unknown";
			val.username = username;
			authorizedPlayers.Add(val);
			Analytics.Azure.OnEntityAuthChanged(this, granter, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", targetPlayerId);
			UpdateMaxAuthCapacity();
		}
	}

	public void AddPlayer(BasePlayer player)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Expected O, but got Unknown
		if (!AtMaxAuthCapacity())
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == (ulong)player.userID);
			PlayerNameID val = new PlayerNameID();
			val.userid = player.userID;
			val.username = player.displayName;
			authorizedPlayers.Add(val);
			Analytics.Azure.OnEntityAuthChanged(this, player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", player.userID);
			UpdateMaxAuthCapacity();
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (rpc2.player.CanInteract() && IsDriver(rpc2.player) && Interface.CallHook("OnCupboardDeauthorize", (object)this, (object)rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == (ulong)rpc2.player.userID);
			Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "removed", rpc2.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void ClearList(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsDriver(rpc.player) && Interface.CallHook("OnCupboardClearList", (object)this, (object)rpc.player) == null)
		{
			authorizedPlayers.Clear();
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class VendingMachine : ContainerIOEntity, IUGCBrowserEntity, IFoodSpoilModifier, PlayerInventory.ICanMoveFrom
{
	public static class VendingMachineFlags
	{
		public const Flags EmptyInv = Flags.Reserved1;

		public const Flags IsVending = Flags.Reserved2;

		public const Flags Broadcasting = Flags.Reserved4;

		public const Flags OutOfStock = Flags.Reserved5;

		public const Flags NoDirectAccess = Flags.Reserved6;
	}

	private enum HistoryCategory
	{
		History,
		BestSold,
		MostRevenue
	}

	[Serializable]
	public class PurchaseDetails
	{
		public int itemId;

		public int amount;

		public int priceId;

		public int price;

		public int timestamp;

		public bool itemIsBp;

		public bool priceIsBp;
	}

	[Header("VendingMachine")]
	public static readonly Phrase WaitForVendingMessage = new Phrase("vendingmachine.wait", "Please wait...");

	public GameObjectRef adminMenuPrefab;

	public string customerPanel = "";

	public SellOrderContainer sellOrders;

	public SoundPlayer buySound;

	public string shopName = "A Shop";

	public int maxCurrencyVolume = 1;

	public Vector3 localDropPosition = Vector3.zero;

	public GameObjectRef mapMarkerPrefab;

	public bool IsLocalized;

	[Range(0f, 1f)]
	public float PoweredFoodSpoilageRateMultiplier = 0.1f;

	public int PowerConsumption = 5;

	private Action fullUpdateCached;

	private ulong nameLastEditedBy;

	protected BasePlayer vend_Player;

	private int vend_sellOrderID;

	private int vend_numberOfTransactions;

	public bool transactionActive;

	private VendingMachineMapMarker myMarker;

	private bool industrialItemIncoming;

	public static readonly Phrase TooManySellOrders = new Phrase("error_toomanysellorders", "Too many sell orders");

	[ServerVar]
	public static int max_returned = 100;

	[ServerVar]
	public static int max_processed = 10000;

	[ServerVar]
	public static int max_history = 10000;

	private List<PurchaseDetails> purchaseHistory = new List<PurchaseDetails>();

	private Dictionary<ulong, int> uniqueCustomers = new Dictionary<ulong, int>();

	public ItemDefinition blueprintBaseDef => ItemManager.blueprintBaseDef;

	public uint[] GetContentCRCs => null;

	public UGCType ContentType => UGCType.VendingMachine;

	public List<ulong> EditingHistory => new List<ulong> { nameLastEditedBy };

	public BaseNetworkable UgcEntity
	{
		get
		{
			if (!(this is NPCVendingMachine))
			{
				return this;
			}
			return null;
		}
	}

	public string ContentString => shopName;

	public virtual EraRestriction CurrentEraRestriction => (EraRestriction)7;

	public virtual bool ShouldRecordStats => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VendingMachine.OnRpcMessage", 0);
		try
		{
			if (rpc == 3011053703u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BuyItem "));
				}
				TimeWarning val2 = TimeWarning.New("BuyItem", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3011053703u, "BuyItem", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3011053703u, "BuyItem", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							BuyItem(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in BuyItem");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1626480840 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_AddSellOrder "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_AddSellOrder", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1626480840u, "RPC_AddSellOrder", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_AddSellOrder(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_AddSellOrder");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 169239598 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Broadcast "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Broadcast", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(169239598u, "RPC_Broadcast", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_Broadcast(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_Broadcast");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3680901137u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_DeleteSellOrder "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_DeleteSellOrder", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3680901137u, "RPC_DeleteSellOrder", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_DeleteSellOrder(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_DeleteSellOrder");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2555993359u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenAdmin "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenAdmin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2555993359u, "RPC_OpenAdmin", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RPC_OpenAdmin(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in RPC_OpenAdmin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 36164441 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenShop "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenShop", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(36164441u, "RPC_OpenShop", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							RPC_OpenShop(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in RPC_OpenShop");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2947824655u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenShopNoLOS "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenShopNoLOS", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2947824655u, "RPC_OpenShopNoLOS", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							RPC_OpenShopNoLOS(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in RPC_OpenShopNoLOS");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3346513099u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RotateVM "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RotateVM", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3346513099u, "RPC_RotateVM", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							RPC_RotateVM(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogException(ex8);
						player.Kick("RPC Error in RPC_RotateVM");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1012779214 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_UpdateShopName "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_UpdateShopName", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1012779214u, "RPC_UpdateShopName", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg9 = rPCMessage;
							RPC_UpdateShopName(msg9);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogException(ex9);
						player.Kick("RPC Error in RPC_UpdateShopName");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1147600716 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_RequestLongTermData "));
				}
				TimeWarning val2 = TimeWarning.New("SV_RequestLongTermData", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1147600716u, "SV_RequestLongTermData", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1147600716u, "SV_RequestLongTermData", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg10 = rPCMessage;
							SV_RequestLongTermData(msg10);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogException(ex10);
						player.Kick("RPC Error in SV_RequestLongTermData");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3957849636u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_RequestPurchaseData "));
				}
				TimeWarning val2 = TimeWarning.New("SV_RequestPurchaseData", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3957849636u, "SV_RequestPurchaseData", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3957849636u, "SV_RequestPurchaseData", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg11 = rPCMessage;
							SV_RequestPurchaseData(msg11);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogException(ex11);
						player.Kick("RPC Error in SV_RequestPurchaseData");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3559014831u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - TransactionStart "));
				}
				TimeWarning val2 = TimeWarning.New("TransactionStart", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3559014831u, "TransactionStart", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							TransactionStart(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex12)
					{
						Debug.LogException(ex12);
						player.Kick("RPC Error in TransactionStart");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}

	public float GetSpoilMultiplier(Item arg)
	{
		if (IsPowered())
		{
			return PoweredFoodSpoilageRateMultiplier;
		}
		return 1f;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk && info.msg.vendingMachineStats != null)
		{
			purchaseHistory = GetListFromProto(info.msg.vendingMachineStats.purchaseHistory);
			for (int i = 0; i < info.msg.vendingMachineStats.customers.Count; i++)
			{
				uniqueCustomers.Add(info.msg.vendingMachineStats.customers[i], info.msg.vendingMachineStats.customersVisits[i]);
			}
		}
		if (info.msg.vendingMachine != null)
		{
			if (!IsLocalized)
			{
				shopName = info.msg.vendingMachine.shopName;
			}
			if (info.msg.vendingMachine.sellOrderContainer != null)
			{
				sellOrders = info.msg.vendingMachine.sellOrderContainer;
				sellOrders.ShouldPool = false;
			}
			if (info.fromDisk && base.isServer)
			{
				nameLastEditedBy = info.msg.vendingMachine.nameLastEditedBy;
				RefreshSellOrderStockLevel();
			}
		}
	}

	public static int GetTotalReceivedMerchandiseForOrder(SellOrder order)
	{
		return GetTotalReceivedMerchandiseForOrder(order.itemToSellAmount, order.receivedQuantityMultiplier);
	}

	public static int GetTotalReceivedMerchandiseForOrder(int merchAmountPerOrder, float multiplier)
	{
		float num = ((multiplier != 0f) ? multiplier : 1f);
		return Mathf.Max(Mathf.RoundToInt((float)merchAmountPerOrder * num), 1);
	}

	public static int GetTotalPriceForOrder(SellOrder order)
	{
		return GetTotalPriceForOrder(order.currencyAmountPerItem, order.priceMultiplier);
	}

	public static int GetTotalPriceForOrder(int currencyAmountPerItem, float multiplier)
	{
		float num = ((multiplier != 0f) ? multiplier : 1f);
		return Mathf.Max(Mathf.RoundToInt((float)currencyAmountPerItem * num), 1);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	public override void Save(SaveInfo info)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Expected O, but got Unknown
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Expected O, but got Unknown
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Expected O, but got Unknown
		base.Save(info);
		info.msg.vendingMachine = new VendingMachine();
		info.msg.vendingMachine.ShouldPool = false;
		info.msg.vendingMachine.shopName = shopName;
		if (info.forDisk)
		{
			info.msg.vendingMachine.nameLastEditedBy = nameLastEditedBy;
			if (ShouldRecordStats)
			{
				info.msg.vendingMachineStats = Pool.Get<VendingMachineStats>();
				info.msg.vendingMachineStats.purchaseHistory = GetEntriesProto(purchaseHistory);
				info.msg.vendingMachineStats.customers = uniqueCustomers.Keys.ToList();
				info.msg.vendingMachineStats.customersVisits = uniqueCustomers.Values.ToList();
			}
		}
		if (this is NPCVendingMachine)
		{
			info.msg.vendingMachine.translationToken = GetTranslationToken();
		}
		if (sellOrders == null)
		{
			return;
		}
		info.msg.vendingMachine.sellOrderContainer = new SellOrderContainer();
		info.msg.vendingMachine.sellOrderContainer.ShouldPool = false;
		info.msg.vendingMachine.sellOrderContainer.sellOrders = new List<SellOrder>();
		foreach (SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (CanSellOrBuyItem(sellOrder.itemToSellID, sellOrder.currencyID))
			{
				SellOrder val = new SellOrder();
				val.ShouldPool = false;
				sellOrder.CopyTo(val);
				info.msg.vendingMachine.sellOrderContainer.sellOrders.Add(val);
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (base.isServer)
		{
			InstallDefaultSellOrders();
			SetFlag(Flags.Reserved2, b: false);
			base.inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
			RefreshSellOrderStockLevel();
			ItemContainer itemContainer = base.inventory;
			itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
			UpdateMapMarker();
			fullUpdateCached = FullUpdate;
		}
	}

	public override void DestroyShared()
	{
		if (Object.op_Implicit((Object)(object)myMarker))
		{
			myMarker.Kill();
			myMarker = null;
		}
		base.DestroyShared();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return true;
	}

	public void FullUpdate()
	{
		RefreshSellOrderStockLevel();
		UpdateMapMarker();
		SendNetworkUpdate();
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		((FacepunchBehaviour)this).CancelInvoke(fullUpdateCached);
		((FacepunchBehaviour)this).Invoke(fullUpdateCached, 0.2f);
	}

	public void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)
	{
		int num = 0;
		foreach (SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (!((Object)(object)itemDef == (Object)null) && itemDef.itemid != sellOrder.itemToSellID)
			{
				continue;
			}
			List<Item> list = Pool.Get<List<Item>>();
			GetItemsToSell(sellOrder, list);
			int num2 = sellOrder.itemToSellAmount;
			if ((Object)(object)ItemManager.FindItemDefinition(sellOrder.itemToSellID) == (Object)(object)NPCVendingMachine.ScrapItem && sellOrder.receivedQuantityMultiplier != 1f)
			{
				num2 = GetTotalPriceForOrder(num2, sellOrder.receivedQuantityMultiplier);
			}
			int inStock;
			if (list.Count < 0)
			{
				inStock = 0;
			}
			else
			{
				List<Item> source = list;
				Func<Item, int> selector = (Item x) => x.amount;
				Interface.CallHook("OnRefreshVendingStock", (object)this, (object)itemDef);
				inStock = source.Sum(selector) / num2;
			}
			sellOrder.inStock = inStock;
			float itemCondition = 0f;
			float itemConditionMax = 0f;
			int instanceData = 0;
			List<int> list2 = Pool.Get<List<int>>();
			int totalAttachmentSlots = 0;
			int ammoType = 0;
			int ammoCount = 0;
			if (list.Count > 0)
			{
				if (list[0].hasCondition)
				{
					itemCondition = list[0].condition;
					itemConditionMax = list[0].maxCondition;
				}
				if ((Object)(object)list[0].info != (Object)null && (list[0].info.amountType == ItemDefinition.AmountType.Genetics || list[0].info.amountType == ItemDefinition.AmountType.NucleusGrades) && list[0].instanceData != null)
				{
					instanceData = list[0].instanceData.dataInt;
					sellOrder.inStock = list[0].amount;
				}
				if (list[0].contents != null && list[0].contents.capacity > 0 && list[0].contents.HasFlag(ItemContainer.Flag.ShowSlotsOnIcon))
				{
					foreach (Item item in list[0].contents.itemList)
					{
						list2.Add(item.info.itemid);
					}
					totalAttachmentSlots = list[0].contents.capacity;
				}
				if (list[0].GetHeldEntity() is BaseProjectile { primaryMagazine: not null } baseProjectile)
				{
					ammoCount = baseProjectile.primaryMagazine.contents;
					if ((Object)(object)baseProjectile.primaryMagazine.ammoType != (Object)null)
					{
						ammoType = baseProjectile.primaryMagazine.ammoType.itemid;
					}
				}
			}
			sellOrder.ammoType = ammoType;
			sellOrder.ammoCount = ammoCount;
			sellOrder.itemCondition = itemCondition;
			sellOrder.itemConditionMax = itemConditionMax;
			sellOrder.instanceData = instanceData;
			if (sellOrder.attachmentsList != null)
			{
				Pool.FreeUnmanaged<int>(ref sellOrder.attachmentsList);
			}
			sellOrder.attachmentsList = list2;
			sellOrder.totalAttachmentSlots = totalAttachmentSlots;
			sellOrder.priceMultiplier = GetDiscountForSlot(num, sellOrder);
			sellOrder.receivedQuantityMultiplier = GetReceivedQuantityMultiplier(num, sellOrder);
			num++;
			Pool.Free<Item>(ref list, false);
		}
	}

	protected virtual float GetDiscountForSlot(int sellOrderSlot, SellOrder forOrder)
	{
		return 1f;
	}

	protected virtual float GetReceivedQuantityMultiplier(int sellOrderSlot, SellOrder forOrder)
	{
		return 1f;
	}

	public bool OutOfStock()
	{
		foreach (SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (sellOrder.inStock > 0)
			{
				return true;
			}
		}
		return false;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Reserved2, b: false);
		RefreshSellOrderStockLevel();
		UpdateMapMarker();
	}

	public void UpdateEmptyFlag()
	{
		SetFlag(Flags.Reserved1, base.inventory.itemList.Count == 0);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.PlayerStoppedLooting(player);
		UpdateEmptyFlag();
		if ((Object)(object)vend_Player != (Object)null && (Object)(object)vend_Player == (Object)(object)player)
		{
			ClearPendingOrder();
		}
	}

	public virtual void InstallDefaultSellOrders()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		sellOrders = new SellOrderContainer();
		sellOrders.ShouldPool = false;
		sellOrders.sellOrders = new List<SellOrder>();
	}

	public virtual bool HasVendingSounds()
	{
		return true;
	}

	public virtual float GetBuyDuration()
	{
		return 2.5f;
	}

	public void SetPendingOrder(BasePlayer buyer, int sellOrderId, int numberOfTransactions)
	{
		ClearPendingOrder();
		vend_Player = buyer;
		vend_sellOrderID = sellOrderId;
		vend_numberOfTransactions = numberOfTransactions;
		SetFlag(Flags.Reserved2, b: true);
		if (HasVendingSounds())
		{
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_StartVendingSounds"), sellOrderId);
		}
	}

	public void ClearPendingOrder()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)CompletePendingOrder);
		vend_Player = null;
		vend_sellOrderID = -1;
		vend_numberOfTransactions = -1;
		SetFlag(Flags.Reserved2, b: false);
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_CancelVendingSounds"));
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void BuyItem(RPCMessage rpc)
	{
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		if (!OccupiedCheck(rpc.player))
		{
			return;
		}
		int num = rpc.read.Int32();
		int num2 = rpc.read.Int32();
		if (IsVending())
		{
			rpc.player.ShowToast(GameTip.Styles.Red_Normal, WaitForVendingMessage, false);
		}
		else
		{
			if (Interface.CallHook("OnBuyVendingItem", (object)this, (object)rpc.player, (object)num, (object)num2) != null)
			{
				return;
			}
			int num3 = 0;
			for (int i = 0; i < sellOrders.sellOrders.Count; i++)
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellOrders.sellOrders[i].itemToSellID);
				ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(sellOrders.sellOrders[i].currencyID);
				if (itemDefinition.IsAllowed(CurrentEraRestriction) && itemDefinition2.IsAllowed(CurrentEraRestriction))
				{
					if (num3 == num)
					{
						num = i;
						break;
					}
					num3++;
				}
			}
			SetPendingOrder(rpc.player, num, num2);
			((FacepunchBehaviour)this).Invoke((Action)CompletePendingOrder, GetBuyDuration());
		}
	}

	public virtual void CompletePendingOrder()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		DoTransaction(vend_Player, vend_sellOrderID, vend_numberOfTransactions);
		ClearPendingOrder();
		Decay.RadialDecayTouch(((Component)this).transform.position, 40f, 2097408);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void TransactionStart(RPCMessage rpc)
	{
	}

	private void GetItemsToSell(SellOrder sellOrder, List<Item> items)
	{
		if (sellOrder.itemToSellIsBP)
		{
			foreach (Item item in base.inventory.itemList)
			{
				if (item.info.itemid == blueprintBaseDef.itemid && item.blueprintTarget == sellOrder.itemToSellID)
				{
					items.Add(item);
				}
			}
			return;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if (item2.info.itemid == sellOrder.itemToSellID)
			{
				items.Add(item2);
			}
		}
	}

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action<BasePlayer, Item> onCurrencyRemoved = null, Action<BasePlayer, Item> onItemPurchased = null, MarketTerminal droneMarketTerminal = null)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_039e: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		if (sellOrderId < 0 || sellOrderId >= sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (targetContainer == null && Vector3.Distance(((Component)buyer).transform.position, ((Component)this).transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", (object)this, (object)buyer, (object)sellOrderId, (object)numberOfTransactions, (object)targetContainer);
		if (obj is bool)
		{
			return (bool)obj;
		}
		SellOrder val = sellOrders.sellOrders[sellOrderId];
		List<Item> list = Pool.Get<List<Item>>();
		GetItemsToSell(val, list);
		if (list == null || list.Count == 0)
		{
			Pool.FreeUnmanaged<Item>(ref list);
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, list[0].hasCondition ? 1 : 1000000);
		int num = val.itemToSellAmount * numberOfTransactions;
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(val.itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(val.currencyID);
		if (!itemDefinition.IsAllowed(CurrentEraRestriction) || !itemDefinition2.IsAllowed(CurrentEraRestriction))
		{
			return false;
		}
		if ((Object)(object)itemDefinition == (Object)(object)NPCVendingMachine.ScrapItem && val.receivedQuantityMultiplier != 1f)
		{
			num = GetTotalReceivedMerchandiseForOrder(val.itemToSellAmount, val.receivedQuantityMultiplier) * numberOfTransactions;
		}
		int num2 = list.Sum((Item x) => x.amount);
		if (num > num2)
		{
			Pool.FreeUnmanaged<Item>(ref list);
			return false;
		}
		int num3 = 0;
		PooledList<Item> val2 = Pool.Get<PooledList<Item>>();
		try
		{
			PooledList<Item> val3 = Pool.Get<PooledList<Item>>();
			try
			{
				buyer.inventory.FindItemsByItemID((List<Item>)(object)val3, val.currencyIsBP ? blueprintBaseDef.itemid : val.currencyID);
				for (int i = 0; i < ((List<Item>)(object)val3).Count; i++)
				{
					Item item = ((List<Item>)(object)val3)[i];
					if ((!val.currencyIsBP || item.blueprintTarget == val.currencyID) && (!item.hasCondition || (item.conditionNormalized >= 0.5f && item.maxConditionNormalized > 0.5f)) && item.GetItemVolume() <= maxCurrencyVolume)
					{
						((List<Item>)(object)val2).Add(item);
						num3 += item.amount;
					}
				}
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
			if (((List<Item>)(object)val2).Count == 0)
			{
				Pool.FreeUnmanaged<Item>(ref list);
				return false;
			}
			int num4 = GetTotalPriceForOrder(val) * numberOfTransactions;
			if (num3 < num4)
			{
				Pool.FreeUnmanaged<Item>(ref list);
				return false;
			}
			transactionActive = true;
			int num5 = 0;
			for (int j = 0; j < ((List<Item>)(object)val2).Count; j++)
			{
				Item item2 = ((List<Item>)(object)val2)[j];
				int num6 = Mathf.Min(num4 - num5, item2.amount);
				Item item3 = ((item2.amount > num6) ? item2.SplitItem(num6) : item2);
				TakeCurrencyItem(item3);
				onCurrencyRemoved?.Invoke(buyer, item3);
				num5 += num6;
				if (num5 >= num4)
				{
					break;
				}
			}
			int num7 = 0;
			foreach (Item item5 in list)
			{
				int num8 = num - num7;
				Item item4 = ((item5.amount > num8) ? item5.SplitItem(num8) : item5);
				if (item4 == null)
				{
					Debug.LogError((object)"Vending machine error, contact developers!");
				}
				else
				{
					num7 += item4.amount;
					object obj2 = Interface.CallHook("CanPurchaseItem", (object)buyer, (object)item4, (object)onItemPurchased, (object)this, (object)targetContainer);
					if (obj2 != null)
					{
						if (!(obj2 is bool))
						{
							return false;
						}
						return (bool)obj2;
					}
					RecordSaleAnalytics(item4, sellOrderId, val.currencyAmountPerItem);
					if (targetContainer == null)
					{
						GiveSoldItem(item4, buyer);
					}
					else if (!item4.MoveToContainer(targetContainer))
					{
						item4.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
					}
					if (ShouldRecordStats)
					{
						RegisterCustomer(buyer.userID);
					}
					onItemPurchased?.Invoke(buyer, item4);
				}
				if (num7 >= num)
				{
					break;
				}
			}
			Analytics.Azure.OnBuyFromVendingMachine(buyer, this, val.itemToSellID, num, val.itemToSellIsBP, val.currencyID, num5, val.currencyIsBP, numberOfTransactions, val.priceMultiplier, droneMarketTerminal);
			if (ShouldRecordStats)
			{
				AddPurchaseHistory(val.itemToSellID, num, val.currencyID, num5, val.itemToSellIsBP, val.currencyIsBP);
			}
			Pool.FreeUnmanaged<Item>(ref list);
			UpdateEmptyFlag();
			transactionActive = false;
			return true;
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	protected virtual void RecordSaleAnalytics(Item itemSold, int orderId, int currencyUsed)
	{
	}

	public virtual void TakeCurrencyItem(Item takenCurrencyItem)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnTakeCurrencyItem", (object)this, (object)takenCurrencyItem) == null && !takenCurrencyItem.MoveToContainer(base.inventory))
		{
			takenCurrencyItem.Drop(base.inventory.dropPosition, Vector3.zero);
		}
	}

	public virtual void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnGiveSoldItem", (object)this, (object)soldItem, (object)buyer) == null)
		{
			while (soldItem.amount > soldItem.MaxStackable())
			{
				Item item = soldItem.SplitItem(soldItem.MaxStackable());
				buyer.GiveItem(item, GiveItemReason.PickedUp);
			}
			buyer.GiveItem(soldItem, GiveItemReason.PickedUp);
		}
	}

	public void SendSellOrders(BasePlayer player = null)
	{
		if (Object.op_Implicit((Object)(object)player))
		{
			ClientRPC(RpcTarget.Player("CLIENT_ReceiveSellOrders", player), sellOrders);
		}
		else
		{
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_ReceiveSellOrders"), sellOrders);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Broadcast(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool b = msg.read.Bit();
		if (CanPlayerAdmin(player))
		{
			SetFlag(Flags.Reserved4, b);
			Interface.CallHook("OnToggleVendingBroadcast", (object)this, (object)player);
			UpdateMapMarker();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_UpdateShopName(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		string text = msg.read.String(32, false);
		if (CanPlayerAdmin(player) && Interface.CallHook("OnVendingShopRename", (object)this, (object)text, (object)player) == null)
		{
			shopName = text;
			nameLastEditedBy = player.userID.Get();
			UpdateMapMarker();
		}
	}

	public void UpdateMapMarkerPosition()
	{
		if (!((Object)(object)myMarker == (Object)null))
		{
			myMarker.TryUpdatePosition();
		}
	}

	public void UpdateMapMarker(bool updatePosition = false)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (!mapMarkerPrefab.isValid)
		{
			return;
		}
		if (IsBroadcasting())
		{
			bool flag = false;
			if ((Object)(object)myMarker == (Object)null)
			{
				myMarker = GameManager.server.CreateEntity(mapMarkerPrefab.resourcePath, ((Component)this).transform.position, Quaternion.identity) as VendingMachineMapMarker;
				flag = true;
			}
			myMarker.SetFlag(Flags.Busy, OutOfStock());
			myMarker.SetVendingMachine(this, shopName);
			if (flag)
			{
				myMarker.Spawn();
			}
			else
			{
				myMarker.SendNetworkUpdate();
			}
		}
		else if (Object.op_Implicit((Object)(object)myMarker))
		{
			myMarker.Kill();
			myMarker = null;
		}
	}

	public void OpenShop(BasePlayer ply)
	{
		SendSellOrders(ply);
		PlayerOpenLoot(ply, customerPanel);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_OpenShopNoLOS(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player))
		{
			OpenShop(msg.player);
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player) && Interface.CallHook("OnVendingShopOpen", (object)this, (object)msg.player) == null)
		{
			OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", (object)this, (object)msg.player);
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenAdmin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			OpenShop(player);
			ClientRPC(RpcTarget.Player("CLIENT_OpenAdminMenu", player));
			Interface.CallHook("OnOpenVendingAdmin", (object)this, (object)player);
		}
	}

	public void OnIndustrialItemTransferBegins()
	{
		industrialItemIncoming = true;
	}

	public void OnIndustrialItemTransferEnds()
	{
		industrialItemIncoming = false;
	}

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanVendingAcceptItem", (object)this, (object)item, (object)targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BasePlayer basePlayer = item.GetRootContainer()?.GetOwnerPlayer();
		if (transactionActive || industrialItemIncoming)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (base.inventory.itemList.Contains(item))
		{
			return true;
		}
		if ((Object)(object)basePlayer == (Object)null)
		{
			return item.GetEntityOwner() is ContainerCorpse;
		}
		return CanPlayerAdmin(basePlayer);
	}

	public bool CanMoveFrom(BasePlayer player, Item item)
	{
		return CanPlayerAdmin(player);
	}

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		object obj = Interface.CallHook("CanUseVending", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (panelName == customerPanel)
		{
			return true;
		}
		if (base.CanOpenLootPanel(player, panelName))
		{
			return CanPlayerAdmin(player);
		}
		return false;
	}

	public override Vector3 GetDropPosition()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(localDropPosition);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_DeleteSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			int num = msg.read.Int32();
			Interface.CallHook("OnDeleteVendingOffer", (object)this, (object)num);
			if (num >= 0 && num < sellOrders.sellOrders.Count)
			{
				SellOrder val = sellOrders.sellOrders[num];
				Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, val.itemToSellID, val.itemToSellAmount, val.itemToSellIsBP, val.currencyID, val.currencyAmountPerItem, val.currencyIsBP, added: false);
				sellOrders.sellOrders.RemoveAt(num);
			}
			RefreshSellOrderStockLevel();
			UpdateMapMarker();
			SendSellOrders(player);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_RotateVM(RPCMessage msg)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnRotateVendingMachine", (object)this, (object)msg.player) == null && CanRotate())
		{
			UpdateEmptyFlag();
			if (msg.player.CanBuild() && IsInventoryEmpty())
			{
				((Component)this).transform.rotation = Quaternion.LookRotation(-((Component)this).transform.forward, ((Component)this).transform.up);
				SendNetworkUpdate();
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_AddSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			if (sellOrders.sellOrders.Count >= 7)
			{
				player.ShowToast(GameTip.Styles.Error, TooManySellOrders, true);
				return;
			}
			int num = msg.read.Int32();
			int num2 = msg.read.Int32();
			int num3 = msg.read.Int32();
			int num4 = msg.read.Int32();
			byte b = msg.read.UInt8();
			AddSellOrder(num, num2, num3, num4, b);
			Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, num, num2, b == 2 || b == 3, num3, num4, b == 1 || b == 3, added: true);
		}
	}

	public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Expected O, but got Unknown
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);
		if (!((Object)(object)itemDefinition == (Object)null) && !((Object)(object)itemDefinition2 == (Object)null))
		{
			currencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);
			itemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);
			SellOrder val = new SellOrder();
			val.ShouldPool = false;
			val.itemToSellID = itemToSellID;
			val.itemToSellAmount = itemToSellAmount;
			val.currencyID = currencyToUseID;
			val.currencyAmountPerItem = currencyAmount;
			val.currencyIsBP = bpState == 3 || bpState == 2;
			val.itemToSellIsBP = bpState == 3 || bpState == 1;
			Interface.CallHook("OnAddVendingOffer", (object)this, (object)val);
			sellOrders.sellOrders.Add(val);
			RefreshSellOrderStockLevel(itemDefinition);
			UpdateMapMarker();
			SendNetworkUpdate();
		}
	}

	public void RefreshAndSendNetworkUpdate()
	{
		RefreshSellOrderStockLevel();
		SendNetworkUpdate();
	}

	public void UpdateOrCreateSalesSheet()
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("note");
		PooledList<Item> val = Pool.Get<PooledList<Item>>();
		try
		{
			base.inventory.FindItemsByItemID((List<Item>)(object)val, itemDefinition.itemid);
			Item item = null;
			foreach (Item item4 in (List<Item>)(object)val)
			{
				if (item4.text.Length == 0)
				{
					item = item4;
					break;
				}
			}
			if (item == null)
			{
				ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition("paper");
				Item item2 = base.inventory.FindItemByItemID(itemDefinition2.itemid);
				if (item2 != null)
				{
					item = ItemManager.CreateByItemID(itemDefinition.itemid, 1, 0uL);
					if (!item.MoveToContainer(base.inventory))
					{
						item.Drop(GetDropPosition(), GetDropVelocity());
					}
					item2.UseItem();
				}
			}
			if (item == null)
			{
				return;
			}
			foreach (SellOrder sellOrder in sellOrders.sellOrders)
			{
				ItemDefinition itemDefinition3 = ItemManager.FindItemDefinition(sellOrder.itemToSellID);
				Item item3 = item;
				item3.text = item3.text + itemDefinition3.displayName.translated + "\n";
			}
			item.MarkDirty();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ClearContent()
	{
		if (!(this is NPCVendingMachine))
		{
			shopName = "A Shop";
			nameLastEditedBy = 0uL;
			SendNetworkUpdate();
			UpdateMapMarker();
		}
	}

	protected virtual bool CanShop(BasePlayer bp)
	{
		return true;
	}

	protected virtual bool CanRotate()
	{
		if (!HasAttachedStorageMonitor())
		{
			return !HasAttachedStorageAdaptor();
		}
		return false;
	}

	public bool IsBroadcasting()
	{
		return HasFlag(Flags.Reserved4);
	}

	public bool IsInventoryEmpty()
	{
		return HasFlag(Flags.Reserved1);
	}

	public bool IsVending()
	{
		return HasFlag(Flags.Reserved2);
	}

	public bool PlayerBehind(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(forward, ((Vector3)(ref val)).normalized) <= -0.7f;
	}

	public bool PlayerInfront(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(forward, ((Vector3)(ref val)).normalized) >= 0.7f;
	}

	public virtual bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerBehind(player))
		{
			return OccupiedCheck(player);
		}
		return false;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public virtual string GetTranslationToken()
	{
		return "";
	}

	public bool CanSellOrBuyItem(int itemToSellID, int currencyID)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		if (ItemManager.FindItemDefinition(currencyID).IsAllowed(CurrentEraRestriction))
		{
			return itemDefinition.IsAllowed(CurrentEraRestriction);
		}
		return false;
	}

	[ServerVar(Help = "Wipe the backend stats data on all vending machines. Slow operation.")]
	public static void ClearAllVendingHistory()
	{
		VendingMachine[] array = Object.FindObjectsByType<VendingMachine>((FindObjectsSortMode)0);
		foreach (VendingMachine vendingMachine in array)
		{
			if (!vendingMachine.isClient)
			{
				vendingMachine.ClearPurchaseHistory();
			}
		}
	}

	[ServerVar(Help = "Wipe the backend customer stats data on all vending machines. Slow operation.")]
	public static void ClearAllVendingCustomerHistory()
	{
		VendingMachine[] array = Object.FindObjectsByType<VendingMachine>((FindObjectsSortMode)0);
		foreach (VendingMachine vendingMachine in array)
		{
			if (!vendingMachine.isClient)
			{
				vendingMachine.ClearCustomerHistory();
			}
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void SV_RequestLongTermData(RPCMessage msg)
	{
		int seconds = 86400;
		VendingMachineLongTermStats val = Pool.Get<VendingMachineLongTermStats>();
		val.numberOfPurchases = purchaseHistory.Count;
		val.bestSalesHour = GetPeakSaleHourTimestamp(seconds);
		val.uniqueCustomers = GetUniqueCustomers();
		val.repeatCustomers = GetRepeatCustomers();
		val.bestCustomer = GetBestCustomer();
		ClientRPC(RpcTarget.NetworkGroup("CL_ReceiveLongTermData"), val);
		val.Dispose();
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void SV_RequestPurchaseData(RPCMessage msg)
	{
		HistoryCategory historyCategory = (HistoryCategory)msg.read.Int32();
		int minutes = msg.read.Int32();
		VendingMachinePurchaseHistoryMessage proto = GetProto(historyCategory, minutes);
		ClientRPC(RpcTarget.NetworkGroup("CL_ReceivePurchaseData"), (int)historyCategory, proto);
		proto.Dispose();
	}

	public void AddPurchaseHistory(int itemId, int amount, int priceId, int price, bool itemIsBp, bool priceIsBp)
	{
		if (purchaseHistory.Count > max_history)
		{
			purchaseHistory.RemoveAt(0);
		}
		purchaseHistory.Add(new PurchaseDetails
		{
			itemId = itemId,
			amount = amount,
			priceId = priceId,
			price = price,
			timestamp = Epoch.Current,
			itemIsBp = itemIsBp,
			priceIsBp = priceIsBp
		});
	}

	public void RegisterCustomer(ulong userId)
	{
		if (uniqueCustomers.ContainsKey(userId))
		{
			uniqueCustomers[userId]++;
		}
		else
		{
			uniqueCustomers.Add(userId, 1);
		}
	}

	public void RemovePurchaseHistory(int index)
	{
		purchaseHistory.RemoveAt(index);
	}

	public void ClearPurchaseHistory()
	{
		purchaseHistory.Clear();
	}

	public void ClearCustomerHistory()
	{
		uniqueCustomers.Clear();
	}

	private VendingMachinePurchaseHistoryMessage GetProto(HistoryCategory category, int minutes)
	{
		if (minutes == 0)
		{
			minutes = 999999;
		}
		VendingMachinePurchaseHistoryMessage val = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		switch (category)
		{
		case HistoryCategory.History:
			val.transactions = GetEntriesProto(GetRecentPurchases(minutes * 60));
			break;
		case HistoryCategory.BestSold:
			val.smallTransactions = GetEntriesProtoSmall(GetBestSoldItems(minutes * 60));
			break;
		case HistoryCategory.MostRevenue:
			val.smallTransactions = GetEntriesProtoSmall(GetMostRevenueGeneratingItems(minutes * 60));
			break;
		}
		return val;
	}

	private List<VendingMachinePurchaseHistoryEntryMessage> GetEntriesProto(List<PurchaseDetails> details)
	{
		List<VendingMachinePurchaseHistoryEntryMessage> list = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
		foreach (PurchaseDetails detail in details)
		{
			list.Add(GetEntryProto(detail));
		}
		return list;
	}

	private List<PurchaseDetails> GetListFromProto(List<VendingMachinePurchaseHistoryEntryMessage> details)
	{
		List<PurchaseDetails> list = new List<PurchaseDetails>();
		foreach (VendingMachinePurchaseHistoryEntryMessage detail in details)
		{
			list.Add(new PurchaseDetails
			{
				itemId = detail.itemID,
				amount = detail.amount,
				priceId = detail.priceID,
				price = detail.price,
				timestamp = detail.dateTime,
				itemIsBp = detail.itemIsBp,
				priceIsBp = detail.priceIsBp
			});
		}
		return list;
	}

	private List<VendingMachinePurchaseHistoryEntrySmallMessage> GetEntriesProtoSmall(List<PurchaseDetails> details)
	{
		List<VendingMachinePurchaseHistoryEntrySmallMessage> list = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
		foreach (PurchaseDetails detail in details)
		{
			list.Add(GetEntryProtoSmall(detail));
		}
		return list;
	}

	private VendingMachinePurchaseHistoryEntryMessage GetEntryProto(PurchaseDetails details)
	{
		VendingMachinePurchaseHistoryEntryMessage obj = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		obj.itemID = details.itemId;
		obj.amount = details.amount;
		obj.priceID = details.priceId;
		obj.price = details.price;
		obj.dateTime = details.timestamp;
		obj.priceIsBp = details.priceIsBp;
		obj.itemIsBp = details.itemIsBp;
		return obj;
	}

	private VendingMachinePurchaseHistoryEntrySmallMessage GetEntryProtoSmall(PurchaseDetails details)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage obj = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		obj.itemID = details.itemId;
		obj.amount = details.amount;
		obj.priceID = details.priceId;
		obj.price = details.price;
		obj.priceIsBp = details.priceIsBp;
		obj.itemIsBp = details.itemIsBp;
		return obj;
	}

	public List<PurchaseDetails> GetRecentPurchases(int seconds)
	{
		int currentTime = Epoch.Current;
		return (from p in purchaseHistory
			where currentTime - p.timestamp <= seconds
			orderby p.timestamp descending
			select p).Take(max_returned).ToList();
	}

	public List<PurchaseDetails> GetBestSoldItems(int seconds)
	{
		int currentTime = Epoch.Current;
		return (from p in (from p in purchaseHistory
				where currentTime - p.timestamp <= seconds
				orderby p.timestamp descending
				select p).Take(max_processed)
			group p by new { p.itemId, p.itemIsBp, p.priceIsBp } into @group
			select new PurchaseDetails
			{
				itemId = @group.Key.itemId,
				amount = @group.Sum((PurchaseDetails p) => p.amount),
				priceId = 0,
				price = 0,
				timestamp = 0,
				itemIsBp = @group.Key.itemIsBp,
				priceIsBp = @group.Key.priceIsBp
			} into p
			orderby p.amount descending
			select p).Take(max_returned).ToList();
	}

	public List<PurchaseDetails> GetMostRevenueGeneratingItems(int seconds)
	{
		int currentTime = Epoch.Current;
		return (from p in (from p in purchaseHistory
				where currentTime - p.timestamp <= seconds
				orderby p.timestamp descending
				select p).Take(max_processed)
			group p by new { p.itemId, p.priceId, p.itemIsBp, p.priceIsBp } into @group
			select new PurchaseDetails
			{
				itemId = @group.Key.itemId,
				amount = @group.Sum((PurchaseDetails p) => p.amount),
				priceId = @group.Key.priceId,
				price = @group.Sum((PurchaseDetails p) => p.price),
				timestamp = 0,
				itemIsBp = @group.Key.itemIsBp,
				priceIsBp = @group.Key.priceIsBp
			} into p
			orderby p.price descending
			select p).Take(max_returned).ToList();
	}

	public long GetPeakSaleHourTimestamp(int seconds)
	{
		int currentTime = Epoch.Current;
		return (from p in (from p in purchaseHistory
				where currentTime - p.timestamp <= seconds
				orderby p.timestamp descending
				select p).Take(max_processed)
			group p by p.timestamp into @group
			select new
			{
				Timestamp = @group.Key,
				TotalSales = @group.Sum((PurchaseDetails p) => p.amount)
			} into s
			orderby s.TotalSales descending
			select s).FirstOrDefault()?.Timestamp ?? (-1);
	}

	public int GetUniqueCustomers()
	{
		return uniqueCustomers.Count;
	}

	public int GetRepeatCustomers()
	{
		return uniqueCustomers.Count((KeyValuePair<ulong, int> c) => c.Value > 1);
	}

	public int GetBestCustomer()
	{
		if (uniqueCustomers.Count == 0)
		{
			return 0;
		}
		return uniqueCustomers.Values.Max();
	}
}


public static class VendingMachineFlags
{
	public const Flags EmptyInv = Flags.Reserved1;

	public const Flags IsVending = Flags.Reserved2;

	public const Flags Broadcasting = Flags.Reserved4;

	public const Flags OutOfStock = Flags.Reserved5;

	public const Flags NoDirectAccess = Flags.Reserved6;
}


private enum HistoryCategory
{
	History,
	BestSold,
	MostRevenue
}


using System;

[Serializable]
public class PurchaseDetails
{
	public int itemId;

	public int amount;

	public int priceId;

	public int price;

	public int timestamp;

	public bool itemIsBp;

	public bool priceIsBp;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Spatial;
using UnityEngine;
using UnityEngine.Assertions;

public class VineMountable : BaseMountable
{
	public struct VinePoint
	{
		public EntityRef<VineSwingingTree> TreeEntity;

		public int PointIndex;

		public VineLaunchPoint Get(bool isServer)
		{
			VineSwingingTree vineSwingingTree = TreeEntity.Get(isServer);
			if ((Object)(object)vineSwingingTree != (Object)null)
			{
				return vineSwingingTree.LaunchPoints[PointIndex];
			}
			return null;
		}

		public void Set(VineLaunchPoint launchPoint)
		{
			TreeEntity.Set(launchPoint.ParentTree);
			PointIndex = launchPoint.Index();
		}

		public VineDestination Save()
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			VineDestination obj = Pool.Get<VineDestination>();
			obj.index = PointIndex;
			obj.targetTree = TreeEntity.uid;
			return obj;
		}

		public void Load(VineDestination destination)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			PointIndex = destination.index;
			TreeEntity.uid = destination.targetTree;
		}
	}

	public float moveSpeed;

	[Header("Rotation Settings")]
	public float rotationSpeed = 0.5f;

	public float descendSpeed = 5f;

	public Vector3 WorldSpaceAnchorPoint;

	private List<VinePoint> destinations = new List<VinePoint>();

	private VinePoint origin;

	public VinePoint currentLocation;

	public const Flags Away = Flags.Reserved1;

	public const Flags Descending = Flags.Reserved2;

	public const Flags Finished = Flags.Reserved3;

	public ViewModel VineViewModel;

	public float DismountViewmodelHoldTime = 0.2f;

	public GameObjectRef VineWorldModel;

	public Transform[] VineDirectionArrows;

	public CapsuleCollider ThisCollider;

	[ServerVar]
	public static bool allowChaining = true;

	private static readonly int DescendHash = Animator.StringToHash("descend");

	private static readonly int VineDescendingHash = Animator.StringToHash("vineDescending");

	private VineLaunchPoint activeOriginPoint;

	private VineLaunchPoint activeDestinationPoint;

	private float currentTime;

	private Vector3 lastPosition;

	private bool isDescending;

	private VineMountable chainTarget;

	private Vector3 lastValidLocation = Vector3.zero;

	private TimeSince lastValidLocationTime;

	private Action processMovementAction;

	private Action syncVineAtEndAction;

	public int DestinationCount => destinations.Count;

	public static Grid<VineMountable> pointGrid { get; private set; } = new Grid<VineMountable>(32, 8096f);

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("VineMountable.OnRpcMessage", 0);
		try
		{
			if (rpc == 2800581258u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_Descend "));
				}
				TimeWarning val2 = TimeWarning.New("SV_Descend", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2800581258u, "SV_Descend", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_Descend(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_Descend");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2867502127u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_Swing "));
				}
				TimeWarning val2 = TimeWarning.New("SV_Swing", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2867502127u, "SV_Swing", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SV_Swing(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SV_Swing");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public static void NotifyVinesLaunchSiteRemoved(VineLaunchPoint point)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		PooledList<VineMountable> val = Pool.Get<PooledList<VineMountable>>();
		try
		{
			Vector3 position = ((Component)point).transform.position;
			pointGrid.Query<VineMountable>(position.x, position.z, 100f, (List<VineMountable>)(object)val);
			foreach (VineMountable item in (List<VineMountable>)(object)val)
			{
				if ((Object)(object)item.origin.Get(isServer: true) == (Object)(object)point)
				{
					item.Kill();
					continue;
				}
				for (int i = 0; i < item.destinations.Count; i++)
				{
					if ((Object)(object)item.destinations[i].Get(isServer: true) == (Object)(object)point)
					{
						item.destinations.RemoveAt(i);
						if (item.HasFlag(Flags.Reserved1) && item.destinations.Count > 0)
						{
							item.Swing(null, shouldMount: false);
						}
						i--;
					}
				}
				if (item.destinations.Count == 0)
				{
					item.Kill();
				}
				else
				{
					item.SendNetworkUpdate();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		pointGrid.Add(this, ((Component)this).transform.position.x, ((Component)this).transform.position.z);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		VineLaunchPoint vineLaunchPoint = origin.Get(isServer: true);
		if ((Object)(object)vineLaunchPoint != (Object)null)
		{
			vineLaunchPoint.OnVineKilled();
		}
		pointGrid.Remove(this);
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerServerInput(inputState, player);
		chainTarget = null;
		if (!allowChaining || isDescending || !(currentTime > 0.5f) || !((Object)(object)activeDestinationPoint != (Object)null) || !inputState.IsDown(BUTTON.USE))
		{
			return;
		}
		PooledList<VineMountable> val = Pool.Get<PooledList<VineMountable>>();
		try
		{
			Vector3 position = ((Component)activeDestinationPoint).transform.position;
			pointGrid.Query<VineMountable>(position.x, position.z, 5f, (List<VineMountable>)(object)val);
			foreach (VineMountable item in (List<VineMountable>)(object)val)
			{
				if (item.isServer && (Object)(object)item != (Object)(object)this && item.Distance(position) < 5f && (Object)(object)item.GetTargetDestination(((Component)this).transform.position, ((Component)this).transform.forward, out var foundAngle) != (Object)null && foundAngle < 90f)
				{
					chainTarget = item;
					break;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool AttackedByPlayer(BasePlayer bp)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (!Server.allowVineSwinging)
		{
			return false;
		}
		float num = 2f;
		if ((Object)(object)bp != (Object)null)
		{
			if (bp.Distance((BaseEntity)this) < 2f)
			{
				return false;
			}
			if (HasFlag(Flags.Reserved1))
			{
				VineLaunchPoint vineLaunchPoint = origin.Get(base.isServer);
				if ((Object)(object)vineLaunchPoint != (Object)null && bp.Distance(((Component)vineLaunchPoint).transform.position) < num)
				{
					Swing(null, shouldMount: false);
					return true;
				}
			}
			else
			{
				foreach (VinePoint destination in destinations)
				{
					VineLaunchPoint vineLaunchPoint2 = destination.Get(isServer: true);
					if ((Object)(object)vineLaunchPoint2 != (Object)null && bp.Distance(((Component)vineLaunchPoint2).transform.position) < num)
					{
						Swing(null, shouldMount: false, vineLaunchPoint2);
						return true;
					}
				}
			}
		}
		return false;
	}

	private void ProcessMovement()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0310: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_039e: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03db: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		lastPosition = ((Component)this).transform.position;
		VineLaunchPoint vineLaunchPoint = activeDestinationPoint;
		VineLaunchPoint vineLaunchPoint2 = activeOriginPoint;
		if (HasFlag(Flags.Reserved3))
		{
			SetFlag(Flags.Reserved3, b: false);
		}
		currentTime = Mathf.MoveTowards(currentTime, 1f, moveSpeed * Time.deltaTime);
		float time = Mathf.SmoothStep(0f, 1f, currentTime);
		if (isDescending && (Object)(object)vineLaunchPoint2 != (Object)null)
		{
			if (GamePhysics.Trace(new Ray(((Component)this).transform.position, -Vector3.up), 0.2f, out var hitInfo, 50f, 1218519297, (QueryTriggerInteraction)0, this) && ((RaycastHit)(ref hitInfo)).distance < 1.5f && !(hitInfo.GetEntity() is VineMountable))
			{
				if (Vector3.Distance(((Component)this).transform.position, ((Component)vineLaunchPoint2).transform.position) < 2f)
				{
					((Component)this).transform.position = ((Component)vineLaunchPoint2).transform.position;
				}
				isDescending = false;
				SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
				SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
				OnArrived(null);
				if (!HasFlag(Flags.Reserved3))
				{
					SetFlag(Flags.Reserved3, b: true);
				}
				SendNetworkUpdate();
				((Component)this).transform.position = ((Component)vineLaunchPoint2).transform.position;
			}
			else
			{
				((Component)this).transform.Translate(-Vector3.up * descendSpeed * Time.deltaTime);
			}
			return;
		}
		if ((Object)(object)vineLaunchPoint == (Object)null || (Object)(object)vineLaunchPoint2 == (Object)null)
		{
			DismountAllPlayers();
			VineLaunchPoint vineLaunchPoint3 = origin.Get(isServer: true);
			if ((Object)(object)vineLaunchPoint3 != (Object)null)
			{
				OnArrived(vineLaunchPoint3);
			}
			return;
		}
		if (TimeSince.op_Implicit(lastValidLocationTime) > 0.1f)
		{
			lastValidLocation = ((Component)this).transform.position;
			lastValidLocationTime = TimeSince.op_Implicit(0f);
		}
		Vector3 swingPointAtTime = vineLaunchPoint2.GetSwingPointAtTime(time, vineLaunchPoint);
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = swingPointAtTime - position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		PooledList<RaycastHit> val2 = Pool.Get<PooledList<RaycastHit>>();
		try
		{
			float num = ThisCollider.height * 0.5f;
			Vector3 position2 = Vector3Ex.WithY(swingPointAtTime, swingPointAtTime.y - num);
			Vector3 position3 = Vector3Ex.WithY(swingPointAtTime, swingPointAtTime.y + num);
			GamePhysics.CapsuleSweep(position2, position3, ThisCollider.radius, normalized, Vector3.Distance(((Component)this).transform.position, swingPointAtTime) * 2f, (List<RaycastHit>)(object)val2, 2097152, (QueryTriggerInteraction)1);
			if (((List<RaycastHit>)(object)val2).Count > 0)
			{
				if (Vector3.Distance(lastValidLocation, ((Component)vineLaunchPoint2).transform.position) < 2f)
				{
					lastValidLocation = ((Component)vineLaunchPoint2).transform.position;
				}
				((Component)this).transform.position = lastValidLocation;
				DismountAllPlayers();
				return;
			}
			((Component)this).transform.position = swingPointAtTime;
			Vector3 val3 = swingPointAtTime - lastPosition;
			val = ((Vector3)(ref val3)).normalized;
			Quaternion val4 = ((!(((Vector3)(ref val)).sqrMagnitude > Mathf.Epsilon)) ? ((Component)this).transform.rotation : Quaternion.LookRotation(((Vector3)(ref val3)).normalized, Vector3.up));
			float num2 = Mathf.Abs((((Component)this).transform.position.y - lastPosition.y) / Time.deltaTime);
			float num3 = Mathf.Clamp01(Mathf.InverseLerp(0f, 6f, num2));
			Quaternion rotation = ((Component)this).transform.rotation;
			Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
			float num4 = Mathf.Clamp(((Quaternion)(ref val4)).eulerAngles.y, 0f - num3, num3);
			Quaternion val5 = Quaternion.Euler(eulerAngles.x, num4, eulerAngles.z);
			Quaternion rotation2 = Quaternion.Slerp(((Component)this).transform.rotation, val5 * val4, Time.deltaTime * rotationSpeed);
			((Component)this).transform.rotation = rotation2;
			if (currentTime >= 1f)
			{
				((Component)this).transform.position = vineLaunchPoint2.GetSwingPointAtTime(1f, vineLaunchPoint);
				OnArrived(vineLaunchPoint);
				if (!HasFlag(Flags.Reserved3))
				{
					SetFlag(Flags.Reserved3, b: true);
				}
				SendNetworkUpdate();
			}
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	public void Initialise(VineLaunchPoint originPoint, List<VineLaunchPoint> destinationPoints, Vector3 anchor)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		origin.Set(originPoint);
		currentLocation.Set(originPoint);
		destinations.Clear();
		foreach (VineLaunchPoint destinationPoint in destinationPoints)
		{
			VinePoint item = default(VinePoint);
			item.Set(destinationPoint);
			destinations.Add(item);
		}
		WorldSpaceAnchorPoint = anchor;
		Vector3 val = ((Component)destinationPoints[0]).transform.position - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		((Component)this).transform.rotation = Quaternion.LookRotation(normalized, Vector3.up);
		((Component)this).transform.localEulerAngles = Vector3Ex.WithX(((Component)this).transform.localEulerAngles, 0f);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.vineMountable = Pool.Get<VineMountable>();
		info.msg.vineMountable.anchorPoint = WorldSpaceAnchorPoint;
		info.msg.vineMountable.originPoint = origin.Save();
		info.msg.vineMountable.currentLocation = currentLocation.Save();
		info.msg.vineMountable.destinations = Pool.Get<List<VineDestination>>();
		foreach (VinePoint destination in destinations)
		{
			info.msg.vineMountable.destinations.Add(destination.Save());
		}
	}

	public override float MaxVelocity()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (activeOriginPoint.IsUnityNull() || activeDestinationPoint.IsUnityNull())
		{
			return 1f;
		}
		float num = Vector3.Distance(((Component)activeOriginPoint).transform.position, ((Component)activeDestinationPoint).transform.position);
		float num2 = ((moveSpeed > 0f) ? (1f / moveSpeed) : 1f);
		return Mathf.Clamp(num / num2, 1f, 50f);
	}

	private float GetMaxVineDistance(Vector3 origin)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		foreach (VinePoint destination in destinations)
		{
			VineLaunchPoint vineLaunchPoint = destination.Get(base.isServer);
			if ((Object)(object)vineLaunchPoint != (Object)null)
			{
				num = Mathf.Max(Vector3.Distance(((Component)vineLaunchPoint).transform.position, origin), num);
			}
		}
		if (num == 0f)
		{
			Debug.Log((object)(" there are " + destinations.Count + " destinations"));
			foreach (VinePoint destination2 in destinations)
			{
				VineLaunchPoint vineLaunchPoint2 = destination2.Get(isServer: false);
				if ((Object)(object)vineLaunchPoint2 != (Object)null)
				{
					float num2 = Vector3.Distance(((Component)vineLaunchPoint2).transform.position, origin);
					Vector3 val = ((Component)vineLaunchPoint2).transform.position;
					string? text = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
					val = origin;
					Debug.LogWarning((object)("Detected broken distance between " + text + " and origin " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString()));
					val = ((Component)this).transform.position;
					Debug.LogWarning((object)("home " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString()));
					Debug.LogWarning((object)("dist is  " + num2));
				}
			}
			return 5f;
		}
		return num;
	}

	public override void PostServerLoad()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.PostServerLoad();
		VineLaunchPoint vineLaunchPoint = origin.Get(base.isServer);
		if ((Object)(object)vineLaunchPoint != (Object)null)
		{
			((Component)this).transform.position = ((Component)vineLaunchPoint).transform.position;
			SetFlag(Flags.Reserved1, b: false);
		}
	}

	private void Descend(BasePlayer forPlayer)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)forPlayer == (Object)null) && !forPlayer.isMounted)
		{
			isDescending = true;
			activeOriginPoint = origin.Get(isServer: true);
			((Component)this).transform.forward = Vector3Ex.WithY(forPlayer.eyes.BodyForward(), 0f);
			currentTime = 0f;
			MountPlayer(forPlayer);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Reserved2, b: true);
		}
	}

	private void Swing(BasePlayer forPlayer, bool shouldMount, VineLaunchPoint overridePoint = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = (((Object)(object)forPlayer != (Object)null) ? forPlayer.eyes.BodyForward() : Vector3.forward);
		Vector3 playerPos = (((Object)(object)forPlayer != (Object)null) ? ((Component)forPlayer).transform.position : ((Component)this).transform.position);
		VineLaunchPoint vineLaunchPoint = null;
		vineLaunchPoint = (HasFlag(Flags.Reserved1) ? origin.Get(base.isServer) : ((!((Object)(object)overridePoint != (Object)null)) ? GetTargetDestination(playerPos, forward, out var _) : overridePoint));
		if ((Object)(object)vineLaunchPoint == (Object)null)
		{
			Debug.Log((object)"Could not find valid vine launch destination, should not happen");
			return;
		}
		Vector3 val = ((Component)vineLaunchPoint).transform.position - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		((Component)this).transform.rotation = Quaternion.LookRotation(normalized, Vector3.up);
		activeOriginPoint = currentLocation.Get(base.isServer);
		activeDestinationPoint = vineLaunchPoint;
		if ((Object)(object)forPlayer != (Object)null)
		{
			lastPosition = ((Component)forPlayer).transform.position;
			if (shouldMount)
			{
				MountPlayer(forPlayer);
			}
		}
		lastValidLocation = ((Component)this).transform.position;
		lastValidLocationTime = TimeSince.op_Implicit(0f);
		currentTime = 0f;
		SetFlag(Flags.Reserved1, !HasFlag(Flags.Reserved1));
		currentLocation.Set(vineLaunchPoint);
		SetFlag(Flags.On, b: true);
		SetFlag(Flags.Reserved2, b: false);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void SV_Swing(RPCMessage msg)
	{
		if (!IsMounted() && Server.allowVineSwinging)
		{
			BasePlayer player = msg.player;
			bool flag = msg.read.Bool();
			if (!flag || !((Object)(object)player != (Object)null) || !player.isMounted)
			{
				Swing(player, flag);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void SV_Descend(RPCMessage msg)
	{
		if (!IsMounted() && Server.allowVineSwinging)
		{
			BasePlayer player = msg.player;
			Descend(player);
		}
	}

	private void OnArrived(VineLaunchPoint point)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.forward = -((Component)this).transform.forward;
		((Component)this).transform.localEulerAngles = Vector3Ex.WithX(((Component)this).transform.localEulerAngles, 0f);
		SetFlag(Flags.On, b: false);
		if ((Object)(object)point != (Object)null && point.FindVacantArrivalPoint(this, out var worldPos))
		{
			((Component)this).transform.position = worldPos;
		}
		BasePlayer mounted = GetMounted();
		DismountAllPlayers();
		if ((Object)(object)chainTarget != (Object)null)
		{
			chainTarget.Swing(mounted, shouldMount: true);
		}
	}

	public void Highlight(BasePlayer forPlayer)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)origin.Get(base.isServer)).transform.position;
		foreach (VinePoint destination in destinations)
		{
			Vector3 position2 = ((Component)destination.Get(base.isServer)).transform.position;
			forPlayer.SendConsoleCommand("ddraw.arrow", "60", Color.red, position, position2, 25, 0, 0);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.vineMountable == null)
		{
			return;
		}
		WorldSpaceAnchorPoint = info.msg.vineMountable.anchorPoint;
		origin.Load(info.msg.vineMountable.originPoint);
		currentLocation.Load(info.msg.vineMountable.currentLocation);
		destinations.Clear();
		foreach (VineDestination destination in info.msg.vineMountable.destinations)
		{
			VinePoint item = default(VinePoint);
			item.Load(destination);
			destinations.Add(item);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!base.isServer)
		{
			return;
		}
		if (processMovementAction == null)
		{
			processMovementAction = ProcessMovement;
		}
		bool flag = IsOn();
		bool flag2 = ((FacepunchBehaviour)this).IsInvoking(processMovementAction);
		if (flag != flag2)
		{
			if (flag)
			{
				((FacepunchBehaviour)this).InvokeRepeating(processMovementAction, 0f, 0f);
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke(processMovementAction);
			}
		}
	}

	private VineLaunchPoint GetTargetDestination(Vector3 playerPos, Vector3 forward, out float foundAngle)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		VineLaunchPoint result = null;
		forward.y = 0f;
		foreach (VinePoint destination in destinations)
		{
			VineLaunchPoint vineLaunchPoint = destination.Get(base.isServer);
			if ((Object)(object)vineLaunchPoint != (Object)null)
			{
				Vector3 val = forward;
				Vector3 val2 = ((Component)vineLaunchPoint).transform.position - playerPos;
				float num2 = Vector3.Angle(val, Vector3Ex.WithY(((Vector3)(ref val2)).normalized, 0f));
				if (num2 < num)
				{
					result = vineLaunchPoint;
					num = num2;
				}
			}
		}
		foundAngle = num;
		return result;
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public struct VinePoint
{
	public EntityRef<VineSwingingTree> TreeEntity;

	public int PointIndex;

	public VineLaunchPoint Get(bool isServer)
	{
		VineSwingingTree vineSwingingTree = TreeEntity.Get(isServer);
		if ((Object)(object)vineSwingingTree != (Object)null)
		{
			return vineSwingingTree.LaunchPoints[PointIndex];
		}
		return null;
	}

	public void Set(VineLaunchPoint launchPoint)
	{
		TreeEntity.Set(launchPoint.ParentTree);
		PointIndex = launchPoint.Index();
	}

	public VineDestination Save()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		VineDestination obj = Pool.Get<VineDestination>();
		obj.index = PointIndex;
		obj.targetTree = TreeEntity.uid;
		return obj;
	}

	public void Load(VineDestination destination)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		PointIndex = destination.index;
		TreeEntity.uid = destination.targetTree;
	}
}


using System;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class WallpaperPlanner : Planner
{
	private ulong wallSkinID;

	private ulong flooringSkinID;

	private ulong ceilingSkinID;

	private WallpaperSettings.Category currentMode = WallpaperSettings.Category.Wall;

	private static WallpaperSettings _settings;

	public GameObjectRef SkinSelectPanel;

	public GameObject[] thirdPersonModels;

	public static WallpaperSettings Settings
	{
		get
		{
			if (_settings == null)
			{
				_settings = FileSystem.Load<WallpaperSettings>("Assets/Prefabs/Wallpaper/Wallpaper Settings.asset", true);
			}
			return _settings;
		}
	}

	public ItemAmount placementPrice => Settings.PlacementPrice;

	public override bool isTypeDeployable => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WallpaperPlanner.OnRpcMessage", 0);
		try
		{
			if (rpc == 4026651916u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_ChangeWallpaperToolSkin "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_ChangeWallpaperToolSkin", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4026651916u, "SERVER_ChangeWallpaperToolSkin", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(4026651916u, "SERVER_ChangeWallpaperToolSkin", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(4026651916u, "SERVER_ChangeWallpaperToolSkin", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_ChangeWallpaperToolSkin(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_ChangeWallpaperToolSkin");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 236604960 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_SwitchMode "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_SwitchMode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(236604960u, "SERVER_SwitchMode", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(236604960u, "SERVER_SwitchMode", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_SwitchMode(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_SwitchMode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override Deployable GetDeployable(NetworkableId entityId)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (((NetworkableId)(ref entityId)).IsValid)
		{
			BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityId) as BaseEntity;
			return Settings.GetDeployable(baseEntity as BuildingBlock);
		}
		return null;
	}

	public ulong GetSkinIDForCategory(WallpaperSettings.Category category)
	{
		return category switch
		{
			WallpaperSettings.Category.Wall => wallSkinID, 
			WallpaperSettings.Category.Floor => flooringSkinID, 
			WallpaperSettings.Category.Ceiling => ceilingSkinID, 
			_ => 0uL, 
		};
	}

	public override BaseEntity DoBuild(Construction.Target target, Construction component)
	{
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return null;
		}
		if (target.entity is BuildingBlock buildingBlock)
		{
			int side = ((!target.socket.socketName.EndsWith("1")) ? 1 : 0);
			if (!buildingBlock.CanSeeWallpaperSocket(GetOwnerPlayer(), side))
			{
				return null;
			}
			bool flag = buildingBlock.HasWallpaper(side);
			if (flag && buildingBlock.GetWallpaperSkin(side) == skinID)
			{
				float y = component.rotationAmount.y;
				int num = Mathf.RoundToInt(target.rotation.y / y) * (int)y % 360;
				int num2 = Mathf.RoundToInt(buildingBlock.GetWallpaperRotation(side) / y) * (int)y % 360;
				if (num == num2 || (num + 180) % 360 == num2)
				{
					return null;
				}
			}
			if (!flag)
			{
				PayForPlacement(ownerPlayer, component);
			}
			WallpaperSettings.Category category = Settings.GetCategory(buildingBlock, side);
			ulong skinIDForCategory = GetSkinIDForCategory(category);
			buildingBlock.SetWallpaper(skinIDForCategory, side, target.rotation.y);
			if (component.deployable.placeEffect.isValid)
			{
				Effect.server.Run(component.deployable.placeEffect.resourcePath, ((Component)buildingBlock).transform.TransformPoint(target.socket.worldPosition), ((Component)buildingBlock).transform.up);
			}
			Analytics.Azure.OnWallpaperPlaced(ownerPlayer, buildingBlock, skinID, side, reskin: false);
		}
		return null;
	}

	public override void PayForPlacement(BasePlayer player, Construction component)
	{
		if (Interface.CallHook("OnPayForPlacement", (object)player, (object)this, (object)component) == null && (!player.IsInCreativeMode || !Creative.freeBuild))
		{
			player.inventory.Take(null, placementPrice.itemid, (int)placementPrice.amount);
			player.Command("note.inv", placementPrice.itemid, (int)placementPrice.amount * -1);
		}
	}

	public override bool CanAffordToPlace(Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return false;
		}
		if (ownerPlayer.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		if ((float)ownerPlayer.inventory.GetAmount(placementPrice.itemid) < placementPrice.amount)
		{
			return false;
		}
		return true;
	}

	protected override void GetConstructionCost(ItemAmountList list, Construction component)
	{
		list.amount.Clear();
		list.itemID.Clear();
		list.itemID.Add(placementPrice.itemid);
		list.amount.Add((int)placementPrice.amount);
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	private void SERVER_ChangeWallpaperToolSkin(RPCMessage msg)
	{
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null || (Object)(object)player != (Object)(object)GetOwnerPlayer() || num2 < 0 || num2 > 3)
		{
			return;
		}
		bool unlockAllSkins = player.UnlockAllSkins;
		if (num == 0 || unlockAllSkins || player.blueprints.CheckSkinOwnership(num, player.userID))
		{
			ulong num3 = ItemDefinition.FindSkin(WallpaperSettings.GetItemDefForCategory((WallpaperSettings.Category)num2).itemid, num);
			switch ((WallpaperSettings.Category)num2)
			{
			case WallpaperSettings.Category.Wall:
				wallSkinID = num3;
				break;
			case WallpaperSettings.Category.Floor:
				flooringSkinID = num3;
				break;
			case WallpaperSettings.Category.Ceiling:
				ceilingSkinID = num3;
				break;
			}
			skinID = num3;
			SendNetworkUpdate();
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_ChangeSkin"), skinID, (int)currentMode);
		}
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server]
	public void SERVER_SwitchMode(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null || (Object)(object)player != (Object)(object)GetOwnerPlayer())
		{
			return;
		}
		int num = msg.read.Int32();
		if (currentMode != (WallpaperSettings.Category)num && num >= 0 && num <= 3)
		{
			currentMode = (WallpaperSettings.Category)num;
			switch (currentMode)
			{
			case WallpaperSettings.Category.Wall:
				skinID = wallSkinID;
				break;
			case WallpaperSettings.Category.Floor:
				skinID = flooringSkinID;
				break;
			case WallpaperSettings.Category.Ceiling:
				skinID = ceilingSkinID;
				break;
			}
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_SwitchMode"), skinID, (int)currentMode);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.wallpaperTool == null)
		{
			info.msg.wallpaperTool = Pool.Get<WallpaperTool>();
			info.msg.wallpaperTool.wallSkinID = wallSkinID;
			info.msg.wallpaperTool.flooringSkinID = flooringSkinID;
			info.msg.wallpaperTool.ceilingSkinID = ceilingSkinID;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.wallpaperTool != null)
		{
			wallSkinID = info.msg.wallpaperTool.wallSkinID;
			flooringSkinID = info.msg.wallpaperTool.flooringSkinID;
			ceilingSkinID = info.msg.wallpaperTool.ceilingSkinID;
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust.UI;
using UnityEngine;
using UnityEngine.Assertions;

public class WantedPoster : DecayEntity, ISignage, IUGCBrowserEntity, ILOD, IServerFileReceiver
{
	public uint imageCrc;

	public ulong playerId;

	public string playerName;

	public MeshRenderer PhotoImage;

	public RustText WantedName;

	public GameObjectRef AssignDialog;

	public const Flags HasTarget = Flags.Reserved1;

	public uiPlayerPreview.EffectMode EffectMode = uiPlayerPreview.EffectMode.Polaroid;

	public uint[] GetContentCRCs
	{
		get
		{
			if (imageCrc == 0)
			{
				return null;
			}
			return new uint[1] { imageCrc };
		}
	}

	public UGCType ContentType => UGCType.ImageJpg;

	public List<ulong> EditingHistory { get; } = new List<ulong>();

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public Vector2i TextureSize => new Vector2i(1024, 1024);

	public int TextureCount => 1;

	public NetworkableId NetworkID => net.ID;

	public FileStorage.Type FileType => FileStorage.Type.jpg;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WantedPoster.OnRpcMessage", 0);
		try
		{
			if (rpc == 2419123501u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearPlayer "));
				}
				TimeWarning val2 = TimeWarning.New("ClearPlayer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2419123501u, "ClearPlayer", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2419123501u, "ClearPlayer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ClearPlayer(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ClearPlayer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 657465493 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdatePoster "));
				}
				TimeWarning val2 = TimeWarning.New("UpdatePoster", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(657465493u, "UpdatePoster", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(657465493u, "UpdatePoster", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							UpdatePoster(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in UpdatePoster");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	private void UpdatePoster(RPCMessage msg)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)msg.player == (Object)null || !CanUpdateSign(msg.player))
		{
			return;
		}
		ulong num = msg.read.UInt64();
		string text = msg.read.String(256, false);
		byte[] array = msg.read.BytesWithSize(10485760u, false);
		playerId = num;
		playerName = text;
		SetFlag(Flags.Reserved1, b: true);
		if (array == null)
		{
			if (imageCrc != 0)
			{
				FileStorage.server.RemoveExact(imageCrc, FileType, net.ID, 0u);
			}
			imageCrc = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidJPG(array, 1024, 1024))
			{
				return;
			}
			if (imageCrc != 0)
			{
				FileStorage.server.RemoveExact(imageCrc, FileType, net.ID, 0u);
			}
			imageCrc = FileStorage.server.Store(array, FileType, net.ID);
		}
		SendNetworkUpdate();
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ClearPlayer(RPCMessage msg)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)msg.player == (Object)null) && CanUpdateSign(msg.player))
		{
			playerId = 0uL;
			playerName = string.Empty;
			SetFlag(Flags.Reserved1, b: false);
			if (imageCrc != 0)
			{
				FileStorage.server.RemoveExact(imageCrc, FileType, net.ID, 0u);
				imageCrc = 0u;
			}
			SendNetworkUpdate();
		}
	}

	public void SetTextureCRCs(uint[] crcs)
	{
		imageCrc = crcs[0];
		SendNetworkUpdate();
	}

	public void ClearContent()
	{
		imageCrc = 0u;
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.wantedPoster = Pool.Get<WantedPoster>();
		info.msg.wantedPoster.imageCrc = imageCrc;
		info.msg.wantedPoster.playerId = playerId;
		info.msg.wantedPoster.playerName = playerName;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.wantedPoster != null)
		{
			imageCrc = info.msg.wantedPoster.imageCrc;
			playerName = info.msg.wantedPoster.playerName;
			playerId = info.msg.wantedPoster.playerId;
		}
	}

	public bool CanUpdateSign(BasePlayer player)
	{
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

	public uint[] GetTextureCRCs()
	{
		return new uint[1] { imageCrc };
	}
}


using System;
using Network;
using UnityEngine;

public class WaterInflatable : BaseMountable, IPoolVehicle, INotifyTrigger
{
	private enum PaddleDirection
	{
		Forward,
		Left,
		Right,
		Back
	}

	public Transform centerOfMass;

	public float forwardPushForce = 5f;

	public float rearPushForce = 5f;

	public float rotationForce = 5f;

	public float maxSpeed = 3f;

	public float maxPaddleFrequency = 0.5f;

	public SoundDefinition paddleSfx;

	public SoundDefinition smallPlayerMovementSound;

	public SoundDefinition largePlayerMovementSound;

	public BlendedSoundLoops waterLoops;

	public float waterSoundSpeedDivisor = 1f;

	public float additiveDownhillVelocity;

	public GameObjectRef handSplashForwardEffect;

	public GameObjectRef handSplashBackEffect;

	public GameObjectRef footSplashEffect;

	public float animationLerpSpeed = 1f;

	public Transform smoothedEyePosition;

	public float smoothedEyeSpeed = 1f;

	public Buoyancy buoyancy;

	public bool driftTowardsIsland;

	public GameObjectRef mountEffect;

	[Range(0f, 1f)]
	public float handSplashOffset = 1f;

	public float velocitySplashMultiplier = 4f;

	public Vector3 modifyEyeOffset = Vector3.zero;

	[Range(0f, 1f)]
	public float inheritVelocityMultiplier;

	private TimeSince lastPaddle;

	public ParticleSystem[] movingParticleSystems;

	public float movingParticlesThreshold = 0.0005f;

	public Transform headSpaceCheckPosition;

	public float headSpaceCheckRadius = 0.4f;

	private TimeSince landFacingCheck;

	private bool isFacingLand;

	private float landPushAcceleration;

	private TimeSince inPoolCheck;

	private bool isInPool;

	private Vector3 lastPos = Vector3.zero;

	private Vector3 lastClipCheckPosition;

	private bool forceClippingCheck;

	private bool prevSleeping;

	public override bool IsSummerDlcVehicle => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WaterInflatable.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.centerOfMass = centerOfMass.localPosition;
		prevSleeping = false;
		((FacepunchBehaviour)this).InvokeRandomized((Action)LowPriorityCheck, 0f, 5f, 2.5f);
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		base.OnDeployed(parent, deployedBy, fromItem);
		if ((Object)(object)deployedBy != (Object)null)
		{
			Vector3 estimatedVelocity = deployedBy.estimatedVelocity;
			float num = Vector3.Dot(((Component)this).transform.forward, ((Vector3)(ref estimatedVelocity)).normalized);
			Vector3 val = Vector3.Lerp(Vector3.zero, estimatedVelocity, Mathf.Clamp(num, 0f, 1f));
			val *= inheritVelocityMultiplier;
			rigidBody.AddForce(val, (ForceMode)2);
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterInflatable.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			bool flag = rigidBody.IsSleeping();
			if (prevSleeping && !flag && (Object)(object)buoyancy != (Object)null)
			{
				buoyancy.Wake();
			}
			prevSleeping = flag;
			Vector3 velocity = rigidBody.velocity;
			if (((Vector3)(ref velocity)).magnitude > maxSpeed)
			{
				rigidBody.velocity = Vector3.ClampMagnitude(rigidBody.velocity, maxSpeed);
			}
			if (!AnyMounted() || !((Object)(object)headSpaceCheckPosition != (Object)null))
			{
				return;
			}
			Vector3 position = ((Component)this).transform.position;
			if (!forceClippingCheck && !(Vector3.Distance(position, lastClipCheckPosition) > headSpaceCheckRadius * 0.5f))
			{
				return;
			}
			forceClippingCheck = false;
			if (GamePhysics.CheckSphere(headSpaceCheckPosition.position, headSpaceCheckRadius, 1218511105, (QueryTriggerInteraction)1))
			{
				if (!GetDismountPosition(GetMounted(), out var _))
				{
					((Component)this).transform.position = lastClipCheckPosition;
				}
				DismountAllPlayers();
			}
			lastClipCheckPosition = position;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void LowPriorityCheck()
	{
		buoyancy.LowPriorityCheck(AnyMounted());
	}

	public override void OnPlayerMounted()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.OnPlayerMounted();
		lastPos = ((Component)this).transform.position;
		forceClippingCheck = true;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerServerInput(inputState, player);
		if (Vector3.Dot(((Component)this).transform.up, Vector3.up) < 0.1f)
		{
			DismountAllPlayers();
		}
		else
		{
			if (TimeSince.op_Implicit(lastPaddle) < maxPaddleFrequency || ((Object)(object)buoyancy != (Object)null && IsOutOfWaterServer()))
			{
				return;
			}
			if ((Object)(object)player.GetHeldEntity() == (Object)null)
			{
				if (inputState.IsDown(BUTTON.FORWARD))
				{
					Vector3 velocity = rigidBody.velocity;
					if (((Vector3)(ref velocity)).magnitude < maxSpeed)
					{
						rigidBody.AddForce(((Component)this).transform.forward * forwardPushForce, (ForceMode)1);
					}
					rigidBody.angularVelocity = Vector3.Lerp(rigidBody.angularVelocity, ((Component)this).transform.forward, 0.5f);
					lastPaddle = TimeSince.op_Implicit(0f);
					ClientRPC(RpcTarget.NetworkGroup("OnPaddled"), 0);
				}
				if (inputState.IsDown(BUTTON.BACKWARD))
				{
					rigidBody.AddForce(-((Component)this).transform.forward * rearPushForce, (ForceMode)1);
					rigidBody.angularVelocity = Vector3.Lerp(rigidBody.angularVelocity, -((Component)this).transform.forward, 0.5f);
					lastPaddle = TimeSince.op_Implicit(0f);
					ClientRPC(RpcTarget.NetworkGroup("OnPaddled"), 3);
				}
				if (inputState.IsDown(BUTTON.LEFT))
				{
					PaddleTurn(PaddleDirection.Left);
				}
				if (inputState.IsDown(BUTTON.RIGHT))
				{
					PaddleTurn(PaddleDirection.Right);
				}
			}
			if (TimeSince.op_Implicit(inPoolCheck) > 2f)
			{
				isInPool = IsInWaterVolume(((Component)this).transform.position, out var natural) && !natural;
				inPoolCheck = TimeSince.op_Implicit(0f);
			}
			if (additiveDownhillVelocity > 0f && !isInPool)
			{
				Vector3 val = ((Component)this).transform.TransformPoint(Vector3.forward);
				Vector3 position = ((Component)this).transform.position;
				if (val.y + 0.05f < position.y)
				{
					float num = additiveDownhillVelocity * (position.y - val.y);
					rigidBody.AddForce(num * Time.fixedDeltaTime * ((Component)this).transform.forward, (ForceMode)5);
				}
				Vector3 velocity2 = rigidBody.velocity;
				rigidBody.velocity = Vector3.Lerp(velocity2, ((Component)this).transform.forward * ((Vector3)(ref velocity2)).magnitude, 0.4f);
			}
			if (driftTowardsIsland && TimeSince.op_Implicit(landFacingCheck) > 2f && !isInPool)
			{
				isFacingLand = false;
				landFacingCheck = TimeSince.op_Implicit(0f);
				Vector3 position2 = ((Component)this).transform.position;
				if (!WaterResource.IsFreshWater(position2))
				{
					int num2 = 5;
					Vector3 forward = ((Component)this).transform.forward;
					forward.y = 0f;
					for (int i = 1; i <= num2; i++)
					{
						int mask = 128;
						if (!TerrainMeta.TopologyMap.GetTopology(position2 + (float)i * 15f * forward, mask))
						{
							isFacingLand = true;
							break;
						}
					}
				}
			}
			if (driftTowardsIsland && isFacingLand && !isInPool)
			{
				landPushAcceleration = Mathf.Clamp(landPushAcceleration + Time.deltaTime, 0f, 3f);
				rigidBody.AddForce(((Component)this).transform.forward * (Time.deltaTime * landPushAcceleration), (ForceMode)2);
			}
			else
			{
				landPushAcceleration = 0f;
			}
			lastPos = ((Component)this).transform.position;
		}
	}

	private void PaddleTurn(PaddleDirection direction)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (direction != 0 && direction != PaddleDirection.Back)
		{
			rigidBody.AddRelativeTorque(rotationForce * ((direction == PaddleDirection.Left) ? (-Vector3.up) : Vector3.up), (ForceMode)1);
			lastPaddle = TimeSince.op_Implicit(0f);
			ClientRPC(RpcTarget.NetworkGroup("OnPaddled"), (int)direction);
		}
	}

	public override float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		info = default(WaterLevel.WaterInfo);
		return 0f;
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		if (hitEntity is BaseVehicle baseVehicle && (baseVehicle.HasDriver() || baseVehicle.IsMoving() || baseVehicle.HasFlag(Flags.On)))
		{
			Kill(DestroyMode.Gib);
		}
	}

	private bool IsOutOfWaterServer()
	{
		return buoyancy.timeOutOfWater > 0.2f;
	}

	public void OnPoolDestroyed()
	{
		Kill(DestroyMode.Gib);
	}

	public void WakeUp()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody != (Object)null)
		{
			rigidBody.WakeUp();
			rigidBody.AddForce(Vector3.up * 0.1f, (ForceMode)1);
		}
		if ((Object)(object)buoyancy != (Object)null)
		{
			buoyancy.Wake();
		}
	}

	public void OnObjects(TriggerNotify trigger)
	{
		if (base.isClient)
		{
			return;
		}
		foreach (BaseEntity entityContent in trigger.entityContents)
		{
			if (entityContent is BaseVehicle baseVehicle && (baseVehicle.HasDriver() || baseVehicle.IsMoving() || baseVehicle.HasFlag(Flags.On)))
			{
				Kill(DestroyMode.Gib);
				break;
			}
		}
	}

	public void OnEmpty()
	{
	}
}


private enum PaddleDirection
{
	Forward,
	Left,
	Right,
	Back
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class WaterWell : LiquidContainer
{
	public Animator animator;

	private const Flags Pumping = Flags.Reserved2;

	private const Flags WaterFlow = Flags.Reserved3;

	public float caloriesPerPump = 5f;

	public float pressurePerPump = 0.2f;

	public float pressureForProduction = 1f;

	public float currentPressure;

	public int waterPerPump = 50;

	public GameObject waterLevelObj;

	public float waterLevelObjFullOffset;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WaterWell.OnRpcMessage", 0);
		try
		{
			if (rpc == 2538739344u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Pump "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Pump", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2538739344u, "RPC_Pump", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Pump(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Pump");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Reserved2, b: false);
		SetFlag(Flags.Reserved3, b: false);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_Pump(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !player.IsDead() && !player.IsSleeping() && !(player.metabolism.calories.value < caloriesPerPump) && !HasFlag(Flags.Reserved2))
		{
			SetFlag(Flags.Reserved2, b: true);
			player.metabolism.calories.value -= caloriesPerPump;
			player.metabolism.SendChangesToClient();
			currentPressure = Mathf.Clamp01(currentPressure + pressurePerPump);
			((FacepunchBehaviour)this).Invoke((Action)StopPump, 1.8f);
			if (currentPressure >= 0f)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Produce);
				((FacepunchBehaviour)this).Invoke((Action)Produce, 1f);
			}
			SendNetworkUpdateImmediate();
		}
	}

	public void StopPump()
	{
		SetFlag(Flags.Reserved2, b: false);
		SendNetworkUpdateImmediate();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		SendNetworkUpdate();
	}

	public void Produce()
	{
		base.inventory.AddItem(defaultLiquid, waterPerPump, 0uL);
		SetFlag(Flags.Reserved3, b: true);
		ScheduleTapOff();
		SendNetworkUpdateImmediate();
	}

	public void ScheduleTapOff()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)TapOff);
		((FacepunchBehaviour)this).Invoke((Action)TapOff, 1f);
	}

	private void TapOff()
	{
		SetFlag(Flags.Reserved3, b: false);
	}

	public void ReducePressure()
	{
		float num = Random.Range(0.1f, 0.2f);
		currentPressure = Mathf.Clamp01(currentPressure - num);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.waterwell = Pool.Get<WaterWell>();
		info.msg.waterwell.pressure = currentPressure;
		info.msg.waterwell.waterLevel = GetWaterAmount();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.waterwell != null)
		{
			currentPressure = info.msg.waterwell.pressure;
		}
	}

	public float GetWaterAmount()
	{
		if (base.isServer)
		{
			Item slot = base.inventory.GetSlot(0);
			if (slot == null)
			{
				return 0f;
			}
			return slot.amount;
		}
		return 0f;
	}
}


