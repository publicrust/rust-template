using System.IO;
using System.Threading.Tasks;
using Network;
using ProtoBuf;
using UnityEngine;

[Factory("demo")]
public class Demo : ConsoleSystem
{
	public class Header : DemoHeader, IDemoHeader
	{
		long IDemoHeader.Length
		{
			get
			{
				return base.length;
			}
			set
			{
				base.length = value;
			}
		}

		public void Write(BinaryWriter writer)
		{
			byte[] array = ((DemoHeader)this).ToProtoBytes();
			writer.Write("RUST DEMO FORMAT");
			writer.Write(array.Length);
			writer.Write(array);
			writer.Write('\0');
		}
	}

	public static uint Version = 3u;

	[ServerVar]
	public static float splitseconds = 3600f;

	[ServerVar]
	public static float splitmegabytes = 200f;

	[ServerVar(Saved = true)]
	public static string recordlist = "";

	private static int _recordListModeValue = 0;

	[ServerVar(Name = "upload_demos", Saved = true)]
	public static bool UploadDemos
	{
		get
		{
			return DemoConVars.UploadDemos;
		}
		set
		{
			DemoConVars.UploadDemos = value;
		}
	}

	[ServerVar(Name = "upload_url", Saved = true)]
	public static string UploadUrl
	{
		get
		{
			return DemoConVars.UploadEndpoint;
		}
		set
		{
			DemoConVars.UploadEndpoint = value;
		}
	}

	[ServerVar(Name = "full_server_demo", Saved = true)]
	public static bool ServerDemosEnabled
	{
		get
		{
			return DemoConVars.ServerDemosEnabled;
		}
		set
		{
			DemoConVars.EnableServerDemos(value);
		}
	}

	[ServerVar(Name = "server_flush_seconds", Saved = true)]
	public static int ServerDemoFlushInterval
	{
		get
		{
			return DemoConVars.ServerDemoFlushIntervalSeconds;
		}
		set
		{
			DemoConVars.ServerDemoFlushIntervalSeconds = Mathf.Clamp(value, 60, 1800);
		}
	}

	[ServerVar(Name = "upload_bandwidth_limit_ratio")]
	public static float UploadBandwidthLimitRatio
	{
		get
		{
			return DemoConVars.BandwidthLimitRatio;
		}
		set
		{
			DemoConVars.BandwidthLimitRatio = value;
		}
	}

	[ServerVar(Name = "server_demo_directory", Help = "Directory to save full server demos")]
	public static string ServerDemoDirectory
	{
		get
		{
			return DemoConVars.ServerDemoDirectory;
		}
		set
		{
			DemoConVars.ServerDemoDirectory = value;
		}
	}

	[ServerVar(Name = "delete_after_upload", Saved = true, Help = "Should the full server demos be deleted after they are uploaded")]
	public static bool DeleteDemoAfterUpload
	{
		get
		{
			return DemoConVars.DeleteDemoAfterUpload;
		}
		set
		{
			DemoConVars.DeleteDemoAfterUpload = value;
		}
	}

	[ServerVar(Name = "zip_demos", Saved = true, Help = "Should we be zipping the demos before we upload them")]
	public static bool ZipServerDemos
	{
		get
		{
			return DemoConVars.ZipServerDemos;
		}
		set
		{
			DemoConVars.ZipServerDemos = value;
		}
	}

	[ServerVar(Name = "server_demo_disk_space_gb", Saved = true, Help = "How much disk space full server demos can take before we start to delete them")]
	public static int MaxDemoDiskSpaceGB
	{
		get
		{
			return DemoConVars.MaxDemoDiskSpaceGB;
		}
		set
		{
			DemoConVars.MaxDemoDiskSpaceGB = Mathf.Max(value, 0);
		}
	}

	[ServerVar(Name = "server_demo_cleanup_interval", Saved = true, Help = "How many minutes between cleaning up demos from the disk")]
	public static int DemoDiskCleanupIntervalMinutes
	{
		get
		{
			return DemoConVars.DiskCleanupIntervalMinutes;
		}
		set
		{
			DemoConVars.DiskCleanupIntervalMinutes = Mathf.Max(value, 1);
		}
	}

	[ServerVar(Name = "max_upload_concurrency", Help = "Max parallel requests when uploading demos")]
	public static int DemoUploadConcurrency
	{
		get
		{
			return DemoConVars.MaxUploadConcurrency;
		}
		set
		{
			DemoConVars.MaxUploadConcurrency = Mathf.Max(value, 1);
		}
	}

	[ServerVar(Saved = true, Help = "Controls the behavior of recordlist, 0=whitelist, 1=blacklist")]
	public static int recordlistmode
	{
		get
		{
			return _recordListModeValue;
		}
		set
		{
			_recordListModeValue = Mathf.Clamp(value, 0, 1);
		}
	}

	[ServerVar(Name = "benchmark_demo_upload")]
	public static void BenchmarkDemoUpload(Arg arg)
	{
		Task.Run(delegate
		{
			((BaseNetwork)Net.sv).serverDemos.BenchmarkDemoUpload(arg.GetInt(0, 4), arg.GetString(2, ""), arg.GetInt(1, 0));
		});
	}

	[ServerVar]
	public static string record(Arg arg)
	{
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)playerOrSleeper) || playerOrSleeper.net == null || playerOrSleeper.net.connection == null)
		{
			return "Player not found";
		}
		if (playerOrSleeper.net.connection.IsRecording)
		{
			return "Player already recording a demo";
		}
		playerOrSleeper.StartDemoRecording();
		return null;
	}

	[ServerVar]
	public static string stop(Arg arg)
	{
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)playerOrSleeper) || playerOrSleeper.net == null || playerOrSleeper.net.connection == null)
		{
			return "Player not found";
		}
		if (!playerOrSleeper.net.connection.IsRecording)
		{
			return "Player not recording a demo";
		}
		playerOrSleeper.StopDemoRecording();
		return null;
	}
}


using System.IO;
using Network;
using ProtoBuf;

public class Header : DemoHeader, IDemoHeader
{
	long IDemoHeader.Length
	{
		get
		{
			return base.length;
		}
		set
		{
			base.length = value;
		}
	}

	public void Write(BinaryWriter writer)
	{
		byte[] array = ((DemoHeader)this).ToProtoBytes();
		writer.Write("RUST DEMO FORMAT");
		writer.Write(array.Length);
		writer.Write(array);
		writer.Write('\0');
	}
}


[Factory("editor")]
public class Editor : ConsoleSystem
{
}


[Factory("effects")]
public class Effects : ConsoleSystem
{
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using ConVar;
using Facepunch;
using UnityEngine;

[Factory("entity")]
public class Entity : ConsoleSystem
{
	private struct EntityInfo
	{
		public BaseNetworkable entity;

		public NetworkableId entityID;

		public uint groupID;

		public NetworkableId parentID;

		public string status;

		public EntityInfo(BaseNetworkable src)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			entity = src;
			BaseEntity baseEntity = entity as BaseEntity;
			BaseEntity baseEntity2 = (((Object)(object)baseEntity != (Object)null) ? baseEntity.GetParentEntity() : null);
			NetworkableId val;
			NetworkableId val2;
			if (!((Object)(object)entity != (Object)null) || entity.net == null)
			{
				val = default(NetworkableId);
				val2 = val;
			}
			else
			{
				val2 = entity.net.ID;
			}
			entityID = val2;
			groupID = (((Object)(object)entity != (Object)null && entity.net != null && entity.net.group != null) ? entity.net.group.ID : 0u);
			NetworkableId val3;
			if (!((Object)(object)baseEntity != (Object)null))
			{
				val = default(NetworkableId);
				val3 = val;
			}
			else
			{
				val3 = baseEntity.parentEntity.uid;
			}
			parentID = val3;
			if ((Object)(object)baseEntity != (Object)null)
			{
				val = baseEntity.parentEntity.uid;
				if (((NetworkableId)(ref val)).IsValid)
				{
					if ((Object)(object)baseEntity2 == (Object)null)
					{
						status = "orphan";
					}
					else
					{
						status = "child";
					}
					return;
				}
			}
			status = string.Empty;
		}
	}

	public struct EntitySpawnRequest
	{
		public string PrefabName;

		public string Error;

		public bool Valid => string.IsNullOrEmpty(Error);
	}

	private static TextTable GetEntityTable(Func<EntityInfo, bool> filter)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		TextTable val = new TextTable();
		val.AddColumn("realm");
		val.AddColumn("entity");
		val.AddColumn("group");
		val.AddColumn("parent");
		val.AddColumn("name");
		val.AddColumn("position");
		val.AddColumn("local");
		val.AddColumn("rotation");
		val.AddColumn("local");
		val.AddColumn("status");
		val.AddColumn("invokes");
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (!((Object)(object)current == (Object)null))
				{
					EntityInfo arg = new EntityInfo(current);
					if (filter(arg))
					{
						string[] obj = new string[11]
						{
							"sv",
							arg.entityID.Value.ToString(),
							arg.groupID.ToString(),
							arg.parentID.Value.ToString(),
							arg.entity.ShortPrefabName,
							null,
							null,
							null,
							null,
							null,
							null
						};
						Vector3 val2 = ((Component)arg.entity).transform.position;
						obj[5] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
						val2 = ((Component)arg.entity).transform.localPosition;
						obj[6] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
						Quaternion val3 = ((Component)arg.entity).transform.rotation;
						val2 = ((Quaternion)(ref val3)).eulerAngles;
						obj[7] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
						val3 = ((Component)arg.entity).transform.localRotation;
						val2 = ((Quaternion)(ref val3)).eulerAngles;
						obj[8] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
						obj[9] = arg.status;
						obj[10] = arg.entity.InvokeString();
						val.AddRow(obj);
					}
				}
			}
			return val;
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void find_entity(Arg args)
	{
		string filter = args.GetString(0, "");
		TextTable entityTable = GetEntityTable((EntityInfo info) => string.IsNullOrEmpty(filter) || info.entity.PrefabName.Contains(filter));
		args.ReplyWith(((object)entityTable).ToString());
	}

	[ServerVar]
	[ClientVar]
	public static void find_id(Arg args)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId filter = args.GetEntityID(0);
		TextTable entityTable = GetEntityTable((EntityInfo info) => info.entityID == filter);
		args.ReplyWith(((object)entityTable).ToString());
	}

	[ServerVar]
	[ClientVar]
	public static void find_group(Arg args)
	{
		uint filter = args.GetUInt(0, 0u);
		TextTable entityTable = GetEntityTable((EntityInfo info) => info.groupID == filter);
		args.ReplyWith(((object)entityTable).ToString());
	}

	[ClientVar]
	[ServerVar]
	public static void find_parent(Arg args)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId filter = args.GetEntityID(0);
		TextTable entityTable = GetEntityTable((EntityInfo info) => info.parentID == filter);
		args.ReplyWith(((object)entityTable).ToString());
	}

	[ClientVar]
	[ServerVar]
	public static void find_status(Arg args)
	{
		string filter = args.GetString(0, "");
		TextTable entityTable = GetEntityTable((EntityInfo info) => string.IsNullOrEmpty(filter) || info.status.Contains(filter));
		args.ReplyWith(((object)entityTable).ToString());
	}

	[ServerVar]
	[ClientVar]
	public static void find_radius(Arg args)
	{
		BasePlayer player = args.Player();
		if (!((Object)(object)player == (Object)null))
		{
			uint filter = args.GetUInt(0, 10u);
			TextTable entityTable = GetEntityTable((EntityInfo info) => Vector3.Distance(((Component)info.entity).transform.position, ((Component)player).transform.position) <= (float)filter);
			args.ReplyWith(((object)entityTable).ToString());
		}
	}

	[ServerVar]
	[ClientVar]
	public static void find_self(Arg args)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if (!((Object)(object)basePlayer == (Object)null) && basePlayer.net != null)
		{
			NetworkableId filter = basePlayer.net.ID;
			TextTable entityTable = GetEntityTable((EntityInfo info) => info.entityID == filter);
			args.ReplyWith(((object)entityTable).ToString());
		}
	}

	[ServerVar]
	public static void debug_toggle(Arg args)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId def = default(NetworkableId);
		NetworkableId entityID = args.GetEntityID(0, def);
		if (!((NetworkableId)(ref entityID)).IsValid)
		{
			return;
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
		if (!((Object)(object)baseEntity == (Object)null))
		{
			baseEntity.SetFlag(BaseEntity.Flags.Debugging, !baseEntity.IsDebugging());
			if (baseEntity.IsDebugging())
			{
				baseEntity.OnDebugStart();
			}
			def = baseEntity.net.ID;
			args.ReplyWith("Debugging for " + ((object)(NetworkableId)(ref def)/*cast due to .constrained prefix*/).ToString() + " " + (baseEntity.IsDebugging() ? "enabled" : "disabled"));
		}
	}

	[ServerVar]
	public static void nudge(Arg args)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityID = args.GetEntityID(0);
		if (((NetworkableId)(ref entityID)).IsValid)
		{
			BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
			if (!((Object)(object)baseEntity == (Object)null))
			{
				((Component)baseEntity).BroadcastMessage("DebugNudge", (SendMessageOptions)1);
			}
		}
	}

	public static EntitySpawnRequest GetSpawnEntityFromName(string name)
	{
		EntitySpawnRequest result;
		if (string.IsNullOrEmpty(name))
		{
			result = default(EntitySpawnRequest);
			result.Error = "No entity name provided";
			return result;
		}
		string[] array = (from x in GameManifest.Current.entities
			where StringEx.Contains(Path.GetFileNameWithoutExtension(x), name, CompareOptions.IgnoreCase)
			select x.ToLower()).ToArray();
		if (array.Length == 0)
		{
			result = default(EntitySpawnRequest);
			result.Error = "Entity type not found";
			return result;
		}
		if (array.Length > 1)
		{
			string text = array.FirstOrDefault((string x) => string.Compare(Path.GetFileNameWithoutExtension(x), name, StringComparison.OrdinalIgnoreCase) == 0);
			if (text == null)
			{
				result = default(EntitySpawnRequest);
				result.Error = "Unknown entity - could be:\n\n" + string.Join("\n", array.Select(Path.GetFileNameWithoutExtension).ToArray());
				return result;
			}
			array[0] = text;
		}
		result = default(EntitySpawnRequest);
		result.PrefabName = array[0];
		return result;
	}

	[ServerVar(Name = "spawn")]
	public static string svspawn(string name, Vector3 pos, Vector3 dir, int forceUp = 1)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer arg = ConsoleSystem.CurrentArgs.Player();
		EntitySpawnRequest spawnEntityFromName = GetSpawnEntityFromName(name);
		if (!spawnEntityFromName.Valid)
		{
			return spawnEntityFromName.Error;
		}
		bool flag = forceUp == 1;
		BaseEntity baseEntity = GameManager.server.CreateEntity(spawnEntityFromName.PrefabName, pos, flag ? Quaternion.LookRotation(dir, Vector3.up) : Quaternion.Euler(dir));
		if ((Object)(object)baseEntity == (Object)null)
		{
			Debug.Log((object)$"{arg} failed to spawn \"{spawnEntityFromName.PrefabName}\" (tried to spawn \"{name}\")");
			return "Couldn't spawn " + name;
		}
		BasePlayer basePlayer = baseEntity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (flag)
			{
				Quaternion val = Quaternion.LookRotation(dir, Vector3.up);
				basePlayer.OverrideViewAngles(((Quaternion)(ref val)).eulerAngles);
			}
			else
			{
				basePlayer.OverrideViewAngles(dir);
			}
		}
		baseEntity.Spawn();
		Debug.Log((object)$"{arg} spawned \"{baseEntity}\" at {pos}");
		string? obj = ((object)baseEntity)?.ToString();
		Vector3 val2 = pos;
		return "spawned " + obj + " at " + ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
	}

	[ServerVar(Name = "spawnitem")]
	public static string svspawnitem(string name, Vector3 pos)
	{
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = ConsoleSystem.CurrentArgs.Player();
		if (string.IsNullOrEmpty(name))
		{
			return "No entity name provided";
		}
		string[] array = (from x in ItemManager.itemList
			select x.shortname into x
			where StringEx.Contains(x, name, CompareOptions.IgnoreCase)
			select x).ToArray();
		if (array.Length == 0)
		{
			return "Entity type not found";
		}
		if (array.Length > 1)
		{
			string text = array.FirstOrDefault((string x) => string.Compare(x, name, StringComparison.OrdinalIgnoreCase) == 0);
			if (text == null)
			{
				Debug.Log((object)$"{basePlayer} failed to spawn \"{name}\"");
				return "Unknown entity - could be:\n\n" + string.Join("\n", array);
			}
			array[0] = text;
		}
		Item item = ItemManager.CreateByName(array[0], 1, 0uL);
		if (item == null)
		{
			Debug.Log((object)$"{basePlayer} failed to spawn \"{array[0]}\" (tried to spawnitem \"{name}\")");
			return "Couldn't spawn " + name;
		}
		item?.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		BaseEntity arg = item.CreateWorldObject(pos);
		Debug.Log((object)$"{basePlayer} spawned \"{arg}\" at {pos} (via spawnitem)");
		string obj = item?.ToString();
		Vector3 val = pos;
		return "spawned " + obj + " at " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
	}

	[ServerVar(Name = "spawngrid")]
	public static string svspawngrid(string name, int width = 5, int height = 5, int spacing = 5)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = ConsoleSystem.CurrentArgs.Player();
		EntitySpawnRequest spawnEntityFromName = GetSpawnEntityFromName(name);
		if (!spawnEntityFromName.Valid)
		{
			return spawnEntityFromName.Error;
		}
		Quaternion rotation = ((Component)basePlayer).transform.rotation;
		((Quaternion)(ref rotation)).eulerAngles = new Vector3(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
		Matrix4x4 val = Matrix4x4.TRS(((Component)basePlayer).transform.position, ((Component)basePlayer).transform.rotation, Vector3.one);
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				Vector3 pos = ((Matrix4x4)(ref val)).MultiplyPoint(new Vector3((float)(i * spacing), 0f, (float)(j * spacing)));
				BaseEntity baseEntity = GameManager.server.CreateEntity(spawnEntityFromName.PrefabName, pos, rotation);
				if ((Object)(object)baseEntity == (Object)null)
				{
					Debug.Log((object)$"{basePlayer} failed to spawn \"{spawnEntityFromName.PrefabName}\" (tried to spawn \"{name}\")");
					return "Couldn't spawn " + name;
				}
				baseEntity.Spawn();
			}
		}
		Debug.Log((object)($"{basePlayer} spawned ({width * height}) " + spawnEntityFromName.PrefabName));
		return $"spawned ({width * height}) " + spawnEntityFromName.PrefabName;
	}

	[ServerVar]
	public static void spawnlootfrom(Arg args)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		string @string = args.GetString(0, string.Empty);
		int @int = args.GetInt(1, 1);
		Vector3 vector = args.GetVector3(1, Object.op_Implicit((Object)(object)basePlayer) ? basePlayer.CenterPoint() : Vector3.zero);
		if (string.IsNullOrEmpty(@string))
		{
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(@string, vector);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return;
		}
		baseEntity.Spawn();
		basePlayer.ChatMessage("Contents of " + @string + " spawned " + @int + " times");
		LootContainer component = ((Component)baseEntity).GetComponent<LootContainer>();
		if ((Object)(object)component != (Object)null)
		{
			for (int i = 0; i < @int * component.maxDefinitionsToSpawn; i++)
			{
				component.lootDefinition.SpawnIntoContainer(basePlayer.inventory.containerMain);
			}
		}
		baseEntity.Kill();
	}

	public static int DeleteBy(ulong id)
	{
		List<ulong> list = Pool.Get<List<ulong>>();
		list.Add(id);
		int result = DeleteBy(list);
		Pool.FreeUnmanaged<ulong>(ref list);
		return result;
	}

	[ServerVar(Help = "Destroy all entities created by provided users (separate users by space)")]
	public static int DeleteBy(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			return 0;
		}
		List<ulong> list = Pool.Get<List<ulong>>();
		string[] args = arg.Args;
		for (int i = 0; i < args.Length; i++)
		{
			if (ulong.TryParse(args[i], out var result))
			{
				list.Add(result);
			}
		}
		int result2 = DeleteBy(list);
		Pool.FreeUnmanaged<ulong>(ref list);
		return result2;
	}

	private static int DeleteBy(List<ulong> ids)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseEntity baseEntity = (BaseEntity)enumerator.Current;
				if ((Object)(object)baseEntity == (Object)null)
				{
					continue;
				}
				bool flag = false;
				foreach (ulong id in ids)
				{
					if (baseEntity.OwnerID == id)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					((FacepunchBehaviour)baseEntity).Invoke((Action)baseEntity.KillMessage, (float)num * 0.2f);
					num++;
				}
			}
			return num;
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Destroy all entities created by users in the provided text block (can use with copied results from ent auth)")]
	public static void DeleteByTextBlock(Arg arg)
	{
		if (arg.Args.Length != 1)
		{
			arg.ReplyWith("Invalid arguments, provide a text block surrounded by \" and listing player id's at the start of each line");
			return;
		}
		MatchCollection matchCollection = Regex.Matches(arg.GetString(0, ""), "^\\b\\d{17}", RegexOptions.Multiline);
		List<ulong> list = Pool.Get<List<ulong>>();
		foreach (Match item in matchCollection)
		{
			if (ulong.TryParse(item.Value, out var result))
			{
				list.Add(result);
			}
		}
		int num = DeleteBy(list);
		Pool.FreeUnmanaged<ulong>(ref list);
		arg.ReplyWith($"Destroyed {num} entities");
	}

	[ServerVar]
	public static void set_battery_charge(Arg arg)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Usage: set_battery_charge <charge>");
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		ElectricBattery electricBattery = GamePhysics.RaycastEntity(GamePhysics.Realm.Server, basePlayer.eyes.HeadRay(), 5f, -5, (QueryTriggerInteraction)0) as ElectricBattery;
		if ((Object)(object)electricBattery == (Object)null)
		{
			arg.ReplyWith("Not looking at battery");
			return;
		}
		electricBattery.SetCharge(@float);
		arg.ReplyWith($"Set battery charge to {@float}");
	}
}


using UnityEngine;

private struct EntityInfo
{
	public BaseNetworkable entity;

	public NetworkableId entityID;

	public uint groupID;

	public NetworkableId parentID;

	public string status;

	public EntityInfo(BaseNetworkable src)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		entity = src;
		BaseEntity baseEntity = entity as BaseEntity;
		BaseEntity baseEntity2 = (((Object)(object)baseEntity != (Object)null) ? baseEntity.GetParentEntity() : null);
		NetworkableId val;
		NetworkableId val2;
		if (!((Object)(object)entity != (Object)null) || entity.net == null)
		{
			val = default(NetworkableId);
			val2 = val;
		}
		else
		{
			val2 = entity.net.ID;
		}
		entityID = val2;
		groupID = (((Object)(object)entity != (Object)null && entity.net != null && entity.net.group != null) ? entity.net.group.ID : 0u);
		NetworkableId val3;
		if (!((Object)(object)baseEntity != (Object)null))
		{
			val = default(NetworkableId);
			val3 = val;
		}
		else
		{
			val3 = baseEntity.parentEntity.uid;
		}
		parentID = val3;
		if ((Object)(object)baseEntity != (Object)null)
		{
			val = baseEntity.parentEntity.uid;
			if (((NetworkableId)(ref val)).IsValid)
			{
				if ((Object)(object)baseEntity2 == (Object)null)
				{
					status = "orphan";
				}
				else
				{
					status = "child";
				}
				return;
			}
		}
		status = string.Empty;
	}
}


public struct EntitySpawnRequest
{
	public string PrefabName;

	public string Error;

	public bool Valid => string.IsNullOrEmpty(Error);
}


using System;
using UnityEngine;

[Factory("env")]
public class Env : ConsoleSystem
{
	[ClientVar(Default = "1")]
	public static bool nightlight_enabled = true;

	[ReplicatedVar(Default = "0")]
	public static bool redMoon = false;

	[ClientVar(Default = "0", Help = "Toggles nightlight screen effect when using debug camera")]
	public static bool nightlight_debugcamera_enabled = true;

	private static float nightlight_distance_internal = 7f;

	private static float nightlight_fadefraction_internal = 0.65f;

	private static float nightlight_brightness_internal = 0.0175f;

	[ServerVar]
	public static bool progresstime
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return false;
			}
			return TOD_Sky.Instance.Components.Time.ProgressTime;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Components.Time.ProgressTime = value;
			}
		}
	}

	[ServerVar(ShowInAdminUI = true)]
	public static float time
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return 0f;
			}
			return TOD_Sky.Instance.Cycle.Hour;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Cycle.Hour = value;
			}
		}
	}

	[ServerVar]
	public static int day
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return 0;
			}
			return TOD_Sky.Instance.Cycle.Day;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Cycle.Day = value;
			}
		}
	}

	[ServerVar]
	public static int month
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return 0;
			}
			return TOD_Sky.Instance.Cycle.Month;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Cycle.Month = value;
			}
		}
	}

	[ServerVar]
	public static int year
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return 0;
			}
			return TOD_Sky.Instance.Cycle.Year;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Cycle.Year = value;
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float oceanlevel
	{
		get
		{
			return WaterSystem.OceanLevel;
		}
		set
		{
			WaterSystem.OceanLevel = value;
		}
	}

	[ReplicatedVar(Default = "7")]
	public static float nightlight_distance
	{
		get
		{
			return nightlight_distance_internal;
		}
		set
		{
			value = Mathf.Clamp(value, 0f, 25f);
			nightlight_distance_internal = value;
		}
	}

	[ReplicatedVar(Default = "0.65")]
	public static float nightlight_fadefraction
	{
		get
		{
			return nightlight_fadefraction_internal;
		}
		set
		{
			nightlight_fadefraction_internal = value;
		}
	}

	[ReplicatedVar(Default = "0.0175")]
	public static float nightlight_brightness
	{
		get
		{
			return nightlight_brightness_internal;
		}
		set
		{
			value = Mathf.Clamp(value, 0f, 0.2f);
			nightlight_brightness_internal = value;
		}
	}

	[ServerVar]
	public static void addtime(Arg arg)
	{
		if (!((Object)(object)TOD_Sky.Instance == (Object)null))
		{
			DateTime dateTime = TOD_Sky.Instance.Cycle.DateTime.AddTicks(arg.GetTicks(0, 0L));
			TOD_Sky.Instance.Cycle.DateTime = dateTime;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using UnityEngine;

[Factory("events")]
public class Events : ConsoleSystem
{
	public class PendingEventChange
	{
		public string Id;

		public float? MinHours;

		public float? MaxHours;

		public bool? Enabled;

		public bool Invalid;

		public PendingEventChange(string id)
		{
			Id = id;
		}
	}

	private const string BradleyEventId = "bradley";

	private static List<PendingEventChange> TargetChanges = new List<PendingEventChange>();

	private static PendingEventChange GetPendingChanges(string id, bool create)
	{
		PendingEventChange pendingEventChange = TargetChanges.FirstOrDefault((PendingEventChange c) => c.Id.Equals(id, StringComparison.OrdinalIgnoreCase));
		if (pendingEventChange == null && create)
		{
			pendingEventChange = new PendingEventChange(id);
			TargetChanges.Add(pendingEventChange);
		}
		return pendingEventChange;
	}

	private static void ApplyAllChanges()
	{
		foreach (PendingEventChange targetChange in TargetChanges)
		{
			UpdateServerEvent(targetChange);
		}
		TargetChanges.RemoveAll((PendingEventChange c) => c.Invalid);
	}

	public static void UpdateServerEvent(PendingEventChange targetState)
	{
		if (targetState.Id == "bradley")
		{
			Bradley.enabled = targetState.Enabled ?? Bradley.enabled;
			Bradley.respawnDelayMinutes = targetState.MinHours ?? targetState.MaxHours ?? Bradley.respawnDelayMinutes;
		}
		else if (HasAnyEvents())
		{
			EventSchedule eventSchedule = FindEventById(targetState.Id);
			if ((Object)(object)eventSchedule == (Object)null)
			{
				Debug.LogWarning((object)("Unknown event '" + targetState.Id + "' when applying settings to server events"));
				targetState.Invalid = true;
			}
			else
			{
				UpdateScheduleFromConVars(eventSchedule);
			}
		}
	}

	public static void UpdateScheduleFromConVars(EventSchedule schedule)
	{
		PendingEventChange pendingChanges = GetPendingChanges(schedule.Key, create: false);
		if (pendingChanges != null)
		{
			((Behaviour)schedule).enabled = pendingChanges.Enabled ?? ((Behaviour)schedule).enabled;
			schedule.minimumHoursBetween = pendingChanges.MinHours ?? schedule.minimumHoursBetween;
			schedule.maxmumHoursBetween = pendingChanges.MaxHours ?? schedule.maxmumHoursBetween;
		}
	}

	[ServerVar]
	public static void print_server_events(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		foreach (EventSchedule allEvent in EventSchedule.allEvents)
		{
			if (string.IsNullOrEmpty(allEvent.Key))
			{
				stringBuilder.AppendLine("WARNING: Missing event key for prefab '" + ((Object)((Component)allEvent).gameObject).name + "'");
				continue;
			}
			stringBuilder.AppendLine(allEvent.Key ?? "");
			stringBuilder.AppendLine($"  - enabled: {((Behaviour)allEvent).enabled}");
			stringBuilder.AppendLine($"  - min hours: {allEvent.minimumHoursBetween}");
			stringBuilder.AppendLine($"  - max hours: {allEvent.maxmumHoursBetween}");
			stringBuilder.AppendLine();
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void set_event_enabled(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Usage: set_event_enabled <event_name> <true|false>");
			return;
		}
		string @string = arg.GetString(0, "");
		bool @bool = arg.GetBool(1, false);
		GetPendingChanges(@string, create: true).Enabled = @bool;
		ApplyAllChanges();
		arg.ReplyWith((@bool ? "Enabled" : "Disabled") + " event '" + @string + "'");
	}

	[ServerVar]
	public static void set_event_min_delay(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Usage: set_event_max_delay <event_name> <float>");
			return;
		}
		string @string = arg.GetString(0, "");
		float @float = arg.GetFloat(1, 0f);
		GetPendingChanges(@string, create: true).MinHours = @float;
		ApplyAllChanges();
		arg.ReplyWith($"Set minimum delay for '{@string}' to {@float} in-game hours");
	}

	[ServerVar]
	public static void set_event_max_delay(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Usage: set_event_max_delay <event_name> <float>");
			return;
		}
		string @string = arg.GetString(0, "");
		float @float = arg.GetFloat(1, 0f);
		GetPendingChanges(@string, create: true).MaxHours = @float;
		ApplyAllChanges();
		arg.ReplyWith($"Set maximum delay for '{@string}' to {@float} in-game hours");
	}

	private static bool HasAnyEvents()
	{
		return EventSchedule.allEvents.Count > 0;
	}

	private static EventSchedule FindEventById(string key)
	{
		return EventSchedule.allEvents.FirstOrDefault((EventSchedule e) => e.Key.Equals(key, StringComparison.OrdinalIgnoreCase));
	}
}


public class PendingEventChange
{
	public string Id;

	public float? MinHours;

	public float? MaxHours;

	public bool? Enabled;

	public bool Invalid;

	public PendingEventChange(string id)
	{
		Id = id;
	}
}


[Factory("file")]
public class FileConVar : ConsoleSystem
{
	[ClientVar]
	public static bool debug
	{
		get
		{
			return FileSystem.LogDebug;
		}
		set
		{
			FileSystem.LogDebug = value;
		}
	}

	[ClientVar]
	public static bool time
	{
		get
		{
			return FileSystem.LogTime;
		}
		set
		{
			FileSystem.LogTime = value;
		}
	}
}


using UnityEngine;

[Factory("fps")]
public class FPS : ConsoleSystem
{
	private static int _limit = 240;

	private static int m_graph;

	[ServerVar(Saved = true)]
	[ClientVar(Saved = true)]
	public static int limit
	{
		get
		{
			if (_limit == -1)
			{
				_limit = Application.targetFrameRate;
			}
			return _limit;
		}
		set
		{
			_limit = value;
			Application.targetFrameRate = _limit;
		}
	}

	[ClientVar]
	public static int graph
	{
		get
		{
			return m_graph;
		}
		set
		{
			m_graph = value;
			if (Object.op_Implicit((Object)(object)MainCamera.mainCamera))
			{
				FPSGraph component = ((Component)MainCamera.mainCamera).GetComponent<FPSGraph>();
				if (Object.op_Implicit((Object)(object)component))
				{
					component.Refresh();
				}
			}
		}
	}
}


using UnityEngine;

[Factory("gamemode")]
public class gamemode : ConsoleSystem
{
	[ServerUserVar]
	public static void setteam(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode))
		{
			int @int = arg.GetInt(0, 0);
			if (@int >= 0 && @int < activeGameMode.GetNumTeams())
			{
				activeGameMode.ResetPlayerScores(basePlayer);
				activeGameMode.SetPlayerTeam(basePlayer, @int);
				basePlayer.Respawn();
			}
		}
	}

	[ServerVar]
	public static void set(Arg arg)
	{
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		if (string.IsNullOrEmpty(@string))
		{
			Debug.Log((object)"Invalid gamemode");
		}
		BaseGameMode baseGameMode = null;
		GameObjectRef gameObjectRef = null;
		GameModeManifest gameModeManifest = GameModeManifest.Get();
		Debug.Log((object)("total gamemodes : " + gameModeManifest.gameModePrefabs.Count));
		foreach (GameObjectRef gameModePrefab in gameModeManifest.gameModePrefabs)
		{
			BaseGameMode component = gameModePrefab.Get().GetComponent<BaseGameMode>();
			if (component.shortname == @string)
			{
				baseGameMode = component;
				gameObjectRef = gameModePrefab;
				Debug.Log((object)("Found :" + component.shortname + " prefab name is :" + component.PrefabName + ": rpath is " + gameModePrefab.resourcePath + ":"));
				break;
			}
			Debug.Log((object)("search name " + @string + "searched against : " + component.shortname));
		}
		if ((Object)(object)baseGameMode == (Object)null)
		{
			Debug.Log((object)("Unknown gamemode : " + @string));
			return;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode))
		{
			if (baseGameMode.shortname == activeGameMode.shortname)
			{
				Debug.Log((object)"Same gamemode, resetting");
			}
			if (activeGameMode.permanent)
			{
				Debug.LogError((object)"This game mode is permanent, you must reset the server to switch game modes.");
				return;
			}
			activeGameMode.ShutdownGame();
			activeGameMode.Kill();
			BaseGameMode.SetActiveGameMode(null, serverside: true);
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(gameObjectRef.resourcePath, Vector3.zero, Quaternion.identity);
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			Debug.Log((object)("Spawning new game mode : " + baseGameMode.shortname));
			baseEntity.Spawn();
		}
		else
		{
			Debug.Log((object)("Failed to create new game mode :" + baseGameMode.PrefabName));
		}
	}
}


using Rust;
using UnityEngine;
using UnityEngine.Scripting;

[Factory("gc")]
public class GC : ConsoleSystem
{
	[ClientVar]
	public static bool buffer_enabled = true;

	[ClientVar]
	public static int debuglevel = 1;

	[ClientVar(Saved = true)]
	public static int buffer = GC.gcDefaultValue;

	public static int safeBuffer
	{
		get
		{
			return GC.GetSafeGCValue(buffer);
		}
		set
		{
			buffer = value;
		}
	}

	[ServerVar]
	[ClientVar]
	public static bool incremental_enabled
	{
		get
		{
			return GarbageCollector.isIncremental;
		}
		set
		{
			Debug.LogWarning((object)"Cannot set gc.incremental as it is read only");
		}
	}

	[ClientVar]
	[ServerVar]
	public static int incremental_milliseconds
	{
		get
		{
			return (int)(GarbageCollector.incrementalTimeSliceNanoseconds / 1000000);
		}
		set
		{
			GarbageCollector.incrementalTimeSliceNanoseconds = 1000000uL * (ulong)Mathf.Max(value, 0);
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool enabled
	{
		get
		{
			return GC.Enabled;
		}
		set
		{
			Debug.LogWarning((object)"Cannot set gc.enabled as it is read only");
		}
	}

	[ClientVar]
	[ServerVar]
	public static void collect()
	{
		GC.Collect();
	}

	[ServerVar]
	[ClientVar]
	public static void unload()
	{
		Resources.UnloadUnusedAssets();
	}

	[ServerVar]
	[ClientVar]
	public static void alloc(Arg args)
	{
		byte[] array = new byte[args.GetInt(0, 1048576)];
		args.ReplyWith("Allocated " + array.Length + " bytes");
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Nexus.Models;
using Network;
using Network.Visibility;
using ProtoBuf;
using ProtoBuf.Nexus;
using Rust;
using Unity.Jobs.LowLevel.Unsafe;
using UnityEngine;
using UnityEngine.Profiling;
using UnityEngine.SceneManagement;

[Factory("global")]
public class Global : ConsoleSystem
{
	private static int _developer;

	[ClientVar(Help = "WARNING: This causes random crashes!")]
	[ServerVar]
	public static bool skipAssetWarmup_crashes = false;

	[ServerVar]
	[ClientVar]
	public static int maxthreads = 8;

	private const int DefaultWarmupConcurrency = 1;

	private const int DefaultPreloadConcurrency = 1;

	[ClientVar]
	[ServerVar]
	public static int warmupConcurrency = 1;

	[ServerVar]
	[ClientVar]
	public static int preloadConcurrency = 1;

	[ServerVar]
	[ClientVar]
	public static bool forceUnloadBundles = true;

	private const bool DefaultAsyncWarmupEnabled = false;

	[ServerVar]
	[ClientVar]
	public static bool asyncWarmup = false;

	[ClientVar(Saved = true, Help = "Experimental faster loading, requires game restart (0 = off, 1 = partial, 2 = full)")]
	public static int asyncLoadingPreset = 0;

	[ServerVar]
	public static bool updateNetworkPositionWithDebugCameraWhileSpectating = false;

	[ClientVar(Saved = true)]
	[ServerVar(Saved = true)]
	public static int perf = 0;

	[ClientVar(ClientInfo = true, Saved = true, Help = "If you're an admin this will enable god mode")]
	public static bool god = false;

	[ClientVar]
	[ServerVar(ClientAdmin = true, ServerAdmin = true, Help = "When enabled a player wearing a gingerbread suit will gib like the gingerbread NPC's")]
	public static bool cinematicGingerbreadCorpses = false;

	private static uint _gingerbreadMaterialID = 0u;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "Multiplier applied to SprayDuration if a spray isn't in the sprayers auth (cannot go above 1f)")]
	public static float SprayOutOfAuthMultiplier = 0.5f;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "Base time (in seconds) that sprays last")]
	public static float SprayDuration = 10800f;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "If a player sprays more than this, the oldest spray will be destroyed. 0 will disable")]
	public static int MaxSpraysPerPlayer = 40;

	[ServerVar(Help = "Disables the backpacks that appear after a corpse times out")]
	public static bool disableBagDropping = false;

	[ClientVar(Saved = true, Help = "Disables any emoji animations")]
	public static bool blockEmojiAnimations = false;

	[ClientVar(Saved = true, Help = "Blocks any emoji from appearing")]
	public static bool blockEmoji = false;

	[ClientVar(Saved = true, Help = "Blocks emoji provided by servers from appearing")]
	public static bool blockServerEmoji = false;

	[ClientVar(Saved = true, Help = "Displays any emoji rendering errors in the console")]
	public static bool showEmojiErrors = false;

	[ServerVar]
	[ClientVar]
	public static int developer
	{
		get
		{
			return _developer;
		}
		set
		{
			_developer = value;
			Array.Fill(RustLog.Levels, _developer);
		}
	}

	[ClientVar]
	[ServerVar]
	public static int job_system_threads
	{
		get
		{
			return JobsUtility.JobWorkerCount;
		}
		set
		{
			if (value < 1)
			{
				JobsUtility.ResetJobWorkerCount();
				return;
			}
			value = Mathf.Clamp(value, 1, JobsUtility.JobWorkerMaximumCount);
			JobsUtility.JobWorkerCount = value;
		}
	}

	public static void ApplyAsyncLoadingPreset()
	{
		if (asyncLoadingPreset != 0)
		{
			Debug.Log((object)$"Applying async loading preset number {asyncLoadingPreset}");
		}
		switch (asyncLoadingPreset)
		{
		case 1:
			if (warmupConcurrency <= 1)
			{
				warmupConcurrency = 256;
			}
			if (preloadConcurrency <= 1)
			{
				preloadConcurrency = 256;
			}
			asyncWarmup = false;
			break;
		case 2:
			if (warmupConcurrency <= 1)
			{
				warmupConcurrency = 256;
			}
			if (preloadConcurrency <= 1)
			{
				preloadConcurrency = 256;
			}
			asyncWarmup = false;
			break;
		default:
			Debug.LogWarning((object)$"There is no asyncLoading preset number {asyncLoadingPreset}");
			break;
		case 0:
			break;
		}
	}

	[ServerVar]
	public static void restart(Arg args)
	{
		ServerMgr.RestartServer(args.GetString(1, string.Empty), args.GetInt(0, 300));
	}

	[ClientVar]
	[ServerVar]
	public static void quit(Arg args)
	{
		if (args != null && args.HasArgs(1))
		{
			args.ReplyWith("Invalid quit command, quit only works if provided with no arguments.");
			return;
		}
		if (Application.isEditor)
		{
			Debug.LogWarning((object)"Aborting quit because we're in the editor");
			return;
		}
		if ((Object)(object)SingletonComponent<ServerMgr>.Instance != (Object)null)
		{
			SingletonComponent<ServerMgr>.Instance.Shutdown();
		}
		Application.isQuitting = true;
		Server sv = Net.sv;
		if (sv != null)
		{
			sv.Stop("quit");
		}
		Process.GetCurrentProcess().Kill();
		Debug.Log((object)"Quitting");
		Application.Quit();
	}

	[ServerVar]
	public static void report(Arg args)
	{
		ServerPerformance.DoReport();
	}

	[ClientVar]
	[ServerVar]
	public static void objects(Arg args)
	{
		Object[] array = Object.FindObjectsOfType<Object>();
		string text = "";
		Dictionary<Type, int> dictionary = new Dictionary<Type, int>();
		Dictionary<Type, long> dictionary2 = new Dictionary<Type, long>();
		Object[] array2 = array;
		foreach (Object val in array2)
		{
			int runtimeMemorySize = Profiler.GetRuntimeMemorySize(val);
			if (dictionary.ContainsKey(((object)val).GetType()))
			{
				dictionary[((object)val).GetType()]++;
			}
			else
			{
				dictionary.Add(((object)val).GetType(), 1);
			}
			if (dictionary2.ContainsKey(((object)val).GetType()))
			{
				dictionary2[((object)val).GetType()] += runtimeMemorySize;
			}
			else
			{
				dictionary2.Add(((object)val).GetType(), runtimeMemorySize);
			}
		}
		foreach (KeyValuePair<Type, long> item in dictionary2.OrderByDescending(delegate(KeyValuePair<Type, long> x)
		{
			KeyValuePair<Type, long> keyValuePair = x;
			return keyValuePair.Value;
		}))
		{
			text = text + dictionary[item.Key].ToString().PadLeft(10) + " " + NumberExtensions.FormatBytes<long>(item.Value, false).PadLeft(15) + "\t" + item.Key?.ToString() + "\n";
		}
		args.ReplyWith(text);
	}

	[ClientVar]
	[ServerVar]
	public static void textures(Arg args)
	{
		Texture[] array = Object.FindObjectsOfType<Texture>();
		string text = "";
		Texture[] array2 = array;
		foreach (Texture val in array2)
		{
			string text2 = NumberExtensions.FormatBytes<int>(Profiler.GetRuntimeMemorySize((Object)(object)val), false);
			text = text + ((object)val).ToString().PadRight(30) + ((Object)val).name.PadRight(30) + text2 + "\n";
		}
		args.ReplyWith(text);
	}

	[ClientVar]
	[ServerVar]
	public static void colliders(Arg args)
	{
		int num = (from x in Object.FindObjectsOfType<Collider>()
			where x.enabled
			select x).Count();
		int num2 = (from x in Object.FindObjectsOfType<Collider>()
			where !x.enabled
			select x).Count();
		string text = num + " colliders enabled, " + num2 + " disabled";
		args.ReplyWith(text);
	}

	[ClientVar]
	[ServerVar]
	public static void error(Arg args)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		((GameObject)null).transform.position = Vector3.zero;
	}

	[ClientVar]
	[ServerVar]
	public static void queue(Arg args)
	{
		string text = "";
		text = text + "stabilityCheckQueue:        " + ((ObjectWorkQueue<StabilityEntity>)StabilityEntity.stabilityCheckQueue).Info() + "\n";
		text = text + "updateSurroundingsQueue:    " + ((ObjectWorkQueue<Bounds>)StabilityEntity.updateSurroundingsQueue).Info() + "\n";
		args.ReplyWith(text);
	}

	[ServerUserVar]
	public static void setinfo(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			string @string = args.GetString(0, (string)null);
			string string2 = args.GetString(1, (string)null);
			if (@string != null && string2 != null)
			{
				basePlayer.SetInfo(@string, string2);
			}
		}
	}

	[ServerVar]
	public static void sleep(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsSleeping() && !basePlayer.IsSpectating() && !basePlayer.IsDead())
		{
			basePlayer.StartSleeping();
		}
	}

	[ServerVar]
	public static void sleeptarget(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			BasePlayer lookingAtPlayer = RelationshipManager.GetLookingAtPlayer(basePlayer);
			if (!((Object)(object)lookingAtPlayer == (Object)null))
			{
				lookingAtPlayer.StartSleeping();
			}
		}
	}

	[ServerUserVar]
	public static void kill(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer) || basePlayer.IsSpectating() || basePlayer.IsDead())
		{
			return;
		}
		if (basePlayer.IsRestrained)
		{
			Handcuffs handcuffs = basePlayer.Belt?.GetRestraintItem();
			if ((Object)(object)handcuffs != (Object)null && handcuffs.BlockSuicide)
			{
				return;
			}
		}
		if (basePlayer.CanSuicide())
		{
			basePlayer.MarkSuicide();
			basePlayer.Hurt(1000f, DamageType.Suicide, basePlayer, useProtection: false);
		}
		else
		{
			basePlayer.ConsoleMessage("You can't suicide again so quickly, wait a while");
		}
	}

	[ServerUserVar]
	public static void respawn(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		if (!basePlayer.IsDead() && !basePlayer.IsSpectating())
		{
			if (developer > 0)
			{
				Debug.LogWarning((object)(((object)basePlayer)?.ToString() + " wanted to respawn but isn't dead or spectating"));
			}
			basePlayer.SendNetworkUpdate();
		}
		else if (basePlayer.CanRespawn())
		{
			basePlayer.MarkRespawn();
			basePlayer.Respawn();
		}
		else
		{
			basePlayer.ConsoleMessage("You can't respawn again so quickly, wait a while");
		}
	}

	[ServerVar]
	public static void injure(Arg args)
	{
		InjurePlayer(args.Player());
	}

	public static void InjurePlayer(BasePlayer ply)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ply == (Object)null || ply.IsDead())
		{
			return;
		}
		HitInfo hitInfo = Pool.Get<HitInfo>();
		hitInfo.Init(ply, ply, DamageType.Suicide, 1000f, ((Component)ply).transform.position);
		hitInfo.UseProtection = false;
		if (ConVar.Server.woundingenabled && !ply.IsIncapacitated() && !ply.IsSleeping() && !ply.isMounted)
		{
			if (ply.IsCrawling())
			{
				ply.GoToIncapacitated(hitInfo);
			}
			else
			{
				ply.BecomeWounded(hitInfo);
			}
		}
		else
		{
			ply.ConsoleMessage("Can't go to wounded state right now.");
		}
	}

	[ServerVar]
	public static void recover(Arg args)
	{
		RecoverPlayer(args.Player());
	}

	public static void RecoverPlayer(BasePlayer ply)
	{
		if (!((Object)(object)ply == (Object)null) && !ply.IsDead())
		{
			ply.StopWounded();
		}
	}

	[ServerVar]
	public static void spectate(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer.wantsSpectate = true;
			if (!basePlayer.IsDead())
			{
				basePlayer.DieInstantly();
			}
			string @string = args.GetString(0, "");
			if (basePlayer.IsDead())
			{
				basePlayer.StartSpectating();
				basePlayer.UpdateSpectateTarget(@string);
			}
			basePlayer.wantsSpectate = false;
		}
	}

	[ServerVar]
	public static void toggleSpectateTeamInfo(Arg args)
	{
		bool @bool = args.GetBool(0, false);
		BasePlayer basePlayer = args.Player();
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetSpectateTeamInfo(@bool);
			args.ReplyWith($"ToggleSpectateTeamInfo is now {@bool}");
		}
		else
		{
			args.ReplyWith("Invalid player or player is not spectating");
		}
	}

	[ServerVar]
	public static void spectateid(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer.wantsSpectate = true;
			if (!basePlayer.IsDead())
			{
				basePlayer.DieInstantly();
			}
			ulong uLong = args.GetULong(0, 0uL);
			if (basePlayer.IsDead())
			{
				basePlayer.StartSpectating();
				basePlayer.UpdateSpectateTarget(uLong);
			}
			basePlayer.wantsSpectate = false;
		}
	}

	[ServerUserVar]
	public static void respawn_sleepingbag(Arg args)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer) || !basePlayer.IsDead())
		{
			return;
		}
		NetworkableId entityID = args.GetEntityID(0);
		if (!((NetworkableId)(ref entityID)).IsValid)
		{
			args.ReplyWith("Missing sleeping bag ID");
			return;
		}
		string @string = args.GetString(1, "");
		string errorMessage;
		if (NexusServer.Started && !string.IsNullOrWhiteSpace(@string))
		{
			if (!ZoneController.Instance.CanRespawnAcrossZones(basePlayer))
			{
				args.ReplyWith("You cannot respawn to a different zone");
				return;
			}
			NexusZoneDetails val = NexusServer.FindZone(@string);
			if (val == null)
			{
				args.ReplyWith("Zone was not found");
			}
			else if (!basePlayer.CanRespawn())
			{
				args.ReplyWith("You can't respawn again so quickly, wait a while");
			}
			else
			{
				NexusRespawn(basePlayer, val, entityID);
			}
		}
		else if (!SleepingBag.TrySpawnPlayer(basePlayer, entityID, out errorMessage))
		{
			args.ReplyWith(errorMessage);
		}
		static async void NexusRespawn(BasePlayer player, NexusZoneDetails toZone, NetworkableId sleepingBag)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			_ = 1;
			try
			{
				player.nextRespawnTime = float.PositiveInfinity;
				Request val2 = Pool.Get<Request>();
				val2.respawnAtBag = Pool.Get<SleepingBagRespawnRequest>();
				val2.respawnAtBag.userId = player.userID;
				val2.respawnAtBag.sleepingBagId = sleepingBag;
				val2.respawnAtBag.secondaryData = player.SaveSecondaryData();
				Response val3 = await NexusServer.ZoneRpc(toZone.Key, val2);
				try
				{
					if (!val3.status.success)
					{
						if (player.IsConnected)
						{
							player.ConsoleMessage("RespawnAtBag failed: " + val3.status.errorMessage);
						}
						return;
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
				await NexusServer.ZoneClient.Assign(player.UserIDString, toZone.Key);
				if (player.IsConnected)
				{
					ConsoleNetwork.SendClientCommandImmediate(player.net.connection, "nexus.redirect", toZone.IpAddress, toZone.GamePort, toZone.ConnectionProtocol());
					player.Kick("Redirecting to another zone...");
				}
			}
			catch (Exception ex)
			{
				if (player.IsConnected)
				{
					player.ConsoleMessage(ex.ToString());
				}
			}
			finally
			{
				player.MarkRespawn();
			}
		}
	}

	[ServerUserVar]
	public static void respawn_sleepingbag_remove(Arg args)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		NetworkableId entityID = args.GetEntityID(0);
		if (!((NetworkableId)(ref entityID)).IsValid)
		{
			args.ReplyWith("Missing sleeping bag ID");
			return;
		}
		string @string = args.GetString(1, "");
		if (NexusServer.Started && !string.IsNullOrWhiteSpace(@string))
		{
			NexusZoneDetails val = NexusServer.FindZone(@string);
			if (val == null)
			{
				args.ReplyWith("Zone was not found");
			}
			else if (ZoneController.Instance.CanRespawnAcrossZones(basePlayer))
			{
				NexusRemoveBag(basePlayer, val.Key, entityID);
			}
		}
		else
		{
			SleepingBag.DestroyBag(basePlayer.userID, entityID);
		}
		static async void NexusRemoveBag(BasePlayer player, string zoneKey, NetworkableId sleepingBag)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			try
			{
				Request val2 = Pool.Get<Request>();
				val2.destroyBag = Pool.Get<SleepingBagDestroyRequest>();
				val2.destroyBag.userId = player.userID;
				val2.destroyBag.sleepingBagId = sleepingBag;
				(await NexusServer.ZoneRpc(zoneKey, val2)).Dispose();
			}
			catch (Exception ex)
			{
				if (player.IsConnected)
				{
					player.ConsoleMessage(ex.ToString());
				}
			}
		}
	}

	[ServerUserVar]
	public static void status_sv(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			args.ReplyWith(basePlayer.GetDebugStatus());
		}
	}

	[ClientVar]
	public static void status_cl(Arg args)
	{
	}

	[ServerVar]
	public static void teleport(Arg args)
	{
		if (args.HasArgs(2))
		{
			BasePlayer playerOrSleeperOrBot = args.GetPlayerOrSleeperOrBot(0);
			if (Object.op_Implicit((Object)(object)playerOrSleeperOrBot) && playerOrSleeperOrBot.IsAlive())
			{
				BasePlayer playerOrSleeperOrBot2 = args.GetPlayerOrSleeperOrBot(1);
				if (Object.op_Implicit((Object)(object)playerOrSleeperOrBot2) && playerOrSleeperOrBot2.IsAlive())
				{
					playerOrSleeperOrBot.Teleport(playerOrSleeperOrBot2);
				}
			}
			return;
		}
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			BasePlayer playerOrSleeperOrBot3 = args.GetPlayerOrSleeperOrBot(0);
			if (Object.op_Implicit((Object)(object)playerOrSleeperOrBot3) && playerOrSleeperOrBot3.IsAlive())
			{
				basePlayer.Teleport(playerOrSleeperOrBot3);
			}
		}
	}

	[ServerVar]
	public static void teleport2me(Arg args)
	{
		BasePlayer playerOrSleeperOrBot = args.GetPlayerOrSleeperOrBot(0);
		if ((Object)(object)playerOrSleeperOrBot == (Object)null)
		{
			args.ReplyWith("Player or bot not found");
			return;
		}
		if (!playerOrSleeperOrBot.IsAlive())
		{
			args.ReplyWith("Target is not alive");
			return;
		}
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			playerOrSleeperOrBot.Teleport(basePlayer);
		}
	}

	[ServerVar]
	public static void teleporteveryone2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			TeleportPlayersToMe(basePlayer, includeSleepers: true, includeNonSleepers: true, 0uL);
		}
	}

	[ServerVar]
	public static void teleportsleepers2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			TeleportPlayersToMe(basePlayer, includeSleepers: true, includeNonSleepers: false, 0uL);
		}
	}

	[ServerVar]
	public static void teleportnonsleepers2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			TeleportPlayersToMe(basePlayer, includeSleepers: false, includeNonSleepers: true, 0uL);
		}
	}

	[ServerVar]
	public static void teleportteam2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			if (basePlayer.Team == null)
			{
				args.ReplyWith("Player is not in a team");
			}
			else
			{
				TeleportPlayersToMe(basePlayer, includeSleepers: true, includeNonSleepers: true, basePlayer.Team.teamID);
			}
		}
	}

	[ServerVar]
	public static void teleporttargetteam2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			if (basePlayer.Team == null)
			{
				args.ReplyWith("Player is not in a team");
				return;
			}
			ulong uLong = args.GetULong(0, 0uL);
			TeleportPlayersToMe(basePlayer, includeSleepers: true, includeNonSleepers: true, uLong);
		}
	}

	private static void TeleportPlayersToMe(BasePlayer player, bool includeSleepers, bool includeNonSleepers, ulong filterByTeam = 0uL)
	{
		if ((Object)(object)player == (Object)null || !Object.op_Implicit((Object)(object)player) || !player.IsAlive())
		{
			return;
		}
		foreach (BasePlayer allPlayer in BasePlayer.allPlayerList)
		{
			if (allPlayer.IsAlive() && !((Object)(object)allPlayer == (Object)(object)player) && (!allPlayer.IsSleeping() || includeSleepers) && (allPlayer.IsSleeping() || includeNonSleepers) && (filterByTeam == 0L || (allPlayer.Team != null && allPlayer.Team.teamID == filterByTeam)))
			{
				allPlayer.Teleport(player);
			}
		}
	}

	[ServerVar]
	public static void teleportany(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			basePlayer.Teleport(args.GetString(0, ""), playersOnly: false);
		}
	}

	[ServerVar]
	public static void teleportpos(Arg args)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			string text = args.FullString.Replace(", ", ",").Trim('"');
			basePlayer.Teleport(StringExtensions.ToVector3(text));
		}
	}

	[ServerVar]
	public static void teleportlos(Arg args)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			Ray val = basePlayer.eyes.HeadRay();
			int @int = args.GetInt(0, 1000);
			RaycastHit val2 = default(RaycastHit);
			if (Physics.Raycast(val, ref val2, (float)@int, 1218652417))
			{
				basePlayer.Teleport(((RaycastHit)(ref val2)).point);
			}
			else
			{
				basePlayer.Teleport(((Ray)(ref val)).origin + ((Ray)(ref val)).direction * (float)@int);
			}
		}
	}

	[ServerVar]
	public static void teleport2owneditem(Arg arg)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		ulong result;
		if ((Object)(object)playerOrSleeper != (Object)null)
		{
			result = playerOrSleeper.userID;
		}
		else if (!ulong.TryParse(arg.GetString(0, ""), out result))
		{
			arg.ReplyWith("No player with that id found");
			return;
		}
		string @string = arg.GetString(1, "");
		BaseEntity[] array = BaseEntity.Util.FindTargetsOwnedBy(result, @string);
		if (array.Length == 0)
		{
			arg.ReplyWith("No targets found");
			return;
		}
		int num = Random.Range(0, array.Length);
		arg.ReplyWith($"Teleporting to {array[num].ShortPrefabName} at {((Component)array[num]).transform.position}");
		basePlayer.Teleport(((Component)array[num]).transform.position);
	}

	[ServerVar]
	public static void teleport2autheditem(Arg arg)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		ulong result;
		if ((Object)(object)playerOrSleeper != (Object)null)
		{
			result = playerOrSleeper.userID;
		}
		else if (!ulong.TryParse(arg.GetString(0, ""), out result))
		{
			arg.ReplyWith("No player with that id found");
			return;
		}
		string @string = arg.GetString(1, "");
		BaseEntity[] array = BaseEntity.Util.FindTargetsAuthedTo(result, @string);
		if (array.Length == 0)
		{
			arg.ReplyWith("No targets found");
			return;
		}
		int num = Random.Range(0, array.Length);
		arg.ReplyWith($"Teleporting to {array[num].ShortPrefabName} at {((Component)array[num]).transform.position}");
		basePlayer.Teleport(((Component)array[num]).transform.position);
	}

	[ServerVar]
	public static void teleport2marker(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.State.pointsOfInterest == null || basePlayer.State.pointsOfInterest.Count == 0)
		{
			arg.ReplyWith("You don't have a marker set");
			return;
		}
		string @string = arg.GetString(0, "");
		if (arg.HasArgs(1) && @string != "True")
		{
			int num = arg.GetInt(0, 0);
			if (num == -1)
			{
				num = basePlayer.State.pointsOfInterest.Count - 1;
			}
			if (num >= 0 && num < basePlayer.State.pointsOfInterest.Count)
			{
				TeleportToMarker(basePlayer.State.pointsOfInterest[num], basePlayer);
				return;
			}
		}
		if (!string.IsNullOrEmpty(@string))
		{
			foreach (MapNote item in basePlayer.State.pointsOfInterest)
			{
				if (!string.IsNullOrEmpty(item.label) && string.Equals(item.label, @string, StringComparison.InvariantCultureIgnoreCase))
				{
					TeleportToMarker(item, basePlayer);
					return;
				}
			}
		}
		int debugMapMarkerIndex = basePlayer.DebugMapMarkerIndex;
		debugMapMarkerIndex++;
		if (debugMapMarkerIndex >= basePlayer.State.pointsOfInterest.Count)
		{
			debugMapMarkerIndex = 0;
		}
		TeleportToMarker(basePlayer.State.pointsOfInterest[debugMapMarkerIndex], basePlayer);
		basePlayer.DebugMapMarkerIndex = debugMapMarkerIndex;
	}

	private static void TeleportToMarker(MapNote marker, BasePlayer player)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		TeleportToTopOfBase(player, marker.worldPosition);
	}

	private static void TeleportToTopOfBase(BasePlayer player, Vector3 position)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		position.y = WaterLevel.GetWaterOrTerrainSurface(position, waves: true, volumes: true);
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(new Ray(position + Vector3.up * 100f, Vector3.down), ref val, 110f, 1218652417))
		{
			position.y = ((RaycastHit)(ref val)).point.y + 0.5f;
		}
		player.Teleport(position);
	}

	[ServerVar]
	public static void teleport2grid(Arg arg)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Vector3? val = MapHelper.StringToPosition(arg.GetString(0, ""));
			if (!val.HasValue)
			{
				arg.ReplyWith("Invalid grid reference, should look like 'A1'");
			}
			else
			{
				TeleportToTopOfBase(basePlayer, val.Value);
			}
		}
	}

	[ServerVar]
	public static void teleport2death(Arg arg)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.ServerCurrentDeathNote == null)
		{
			arg.ReplyWith("You don't have a current death note!");
			return;
		}
		Vector3 worldPosition = basePlayer.ServerCurrentDeathNote.worldPosition;
		basePlayer.Teleport(worldPosition);
	}

	[ServerVar]
	[ClientVar]
	public static void free(Arg args)
	{
		Pool.clear_prefabs(args);
		Pool.clear_assets(args);
		Pool.clear_memory(args);
		ConVar.GC.collect();
		ConVar.GC.unload();
	}

	[ClientVar]
	[ServerVar(ServerUser = true)]
	public static void version(Arg arg)
	{
		arg.ReplyWith($"Protocol: {Protocol.printable}\nBuild Date: {BuildInfo.Current.BuildDate}\nUnity Version: {Application.unityVersion}\nChangeset: {BuildInfo.Current.Scm.ChangeId}\nBranch: {BuildInfo.Current.Scm.Branch}");
	}

	[ClientVar]
	[ServerVar]
	public static void sysinfo(Arg arg)
	{
		arg.ReplyWith(SystemInfoGeneralText.currentInfo);
	}

	[ClientVar]
	[ServerVar]
	public static void sysuid(Arg arg)
	{
		arg.ReplyWith(SystemInfo.deviceUniqueIdentifier);
	}

	[ServerVar]
	public static void breakitem(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Item activeItem = basePlayer.GetActiveItem();
			activeItem?.LoseCondition(activeItem.condition);
		}
	}

	[ServerVar]
	public static void breakclothing(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		foreach (Item item in basePlayer.inventory.containerWear.itemList)
		{
			item?.LoseCondition(item.condition);
		}
	}

	[ClientVar]
	[ServerVar]
	public static void subscriptions(Arg arg)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		TextTable val = new TextTable();
		val.AddColumn("realm");
		val.AddColumn("group");
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Enumerator<Group> enumerator = basePlayer.net.subscriber.subscribed.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					Group current = enumerator.Current;
					val.AddRow(new string[2]
					{
						"sv",
						current.ID.ToString()
					});
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		arg.ReplyWith(arg.HasArg("--json", false) ? val.ToJson(true) : ((object)val).ToString());
	}

	public static uint GingerbreadMaterialID()
	{
		if (_gingerbreadMaterialID == 0)
		{
			_gingerbreadMaterialID = StringPool.Get("Gingerbread");
		}
		return _gingerbreadMaterialID;
	}

	[ServerVar]
	public static void ClearAllSprays()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		List<SprayCanSpray> list = Pool.Get<List<SprayCanSpray>>();
		Enumerator<SprayCanSpray> enumerator = SprayCanSpray.AllSprays.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				SprayCanSpray current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (SprayCanSpray item in list)
		{
			item.Kill();
		}
		Pool.FreeUnmanaged<SprayCanSpray>(ref list);
	}

	[ServerVar]
	public static void ClearAllSpraysByPlayer(Arg arg)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (!arg.HasArgs(1))
		{
			return;
		}
		ulong uLong = arg.GetULong(0, 0uL);
		List<SprayCanSpray> list = Pool.Get<List<SprayCanSpray>>();
		Enumerator<SprayCanSpray> enumerator = SprayCanSpray.AllSprays.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				SprayCanSpray current = enumerator.Current;
				if (current.sprayedByPlayer == uLong)
				{
					list.Add(current);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (SprayCanSpray item in list)
		{
			item.Kill();
		}
		int count = list.Count;
		Pool.FreeUnmanaged<SprayCanSpray>(ref list);
		arg.ReplyWith($"Deleted {count} sprays by {uLong}");
	}

	[ServerVar]
	public static void ClearSpraysInRadius(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			float @float = arg.GetFloat(0, 16f);
			int num = ClearSpraysInRadius(((Component)basePlayer).transform.position, @float);
			arg.ReplyWith($"Deleted {num} sprays within {@float} of {basePlayer.displayName}");
		}
	}

	private static int ClearSpraysInRadius(Vector3 position, float radius)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		List<SprayCanSpray> list = Pool.Get<List<SprayCanSpray>>();
		Enumerator<SprayCanSpray> enumerator = SprayCanSpray.AllSprays.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				SprayCanSpray current = enumerator.Current;
				if (current.Distance(position) <= radius)
				{
					list.Add(current);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (SprayCanSpray item in list)
		{
			item.Kill();
		}
		int count = list.Count;
		Pool.FreeUnmanaged<SprayCanSpray>(ref list);
		return count;
	}

	[ServerVar]
	public static void ClearSpraysAtPositionInRadius(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = arg.GetVector3(0, default(Vector3));
		float @float = arg.GetFloat(1, 0f);
		if (@float != 0f)
		{
			int num = ClearSpraysInRadius(vector, @float);
			arg.ReplyWith($"Deleted {num} sprays within {@float} of {vector}");
		}
	}

	[ServerVar]
	public static void ClearDroppedItems()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		List<DroppedItem> list = Pool.Get<List<DroppedItem>>();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is DroppedItem item)
				{
					list.Add(item);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (DroppedItem item2 in list)
		{
			item2.Kill();
		}
		Pool.FreeUnmanaged<DroppedItem>(ref list);
	}

	[ClientVar]
	[ServerVar]
	public static string printAllScenesInBuild(Arg args)
	{
		StringBuilder stringBuilder = new StringBuilder();
		int sceneCountInBuildSettings = SceneManager.sceneCountInBuildSettings;
		stringBuilder.AppendLine($"Scenes: {sceneCountInBuildSettings}");
		for (int i = 0; i < sceneCountInBuildSettings; i++)
		{
			stringBuilder.AppendLine(SceneUtility.GetScenePathByBuildIndex(i));
		}
		return stringBuilder.ToString();
	}

	[ServerVar(Clientside = true, Help = "Immediately update the manifest")]
	public static void UpdateManifest(Arg args)
	{
		Manifest.UpdateManifest();
	}
}


using Rust.Workshop;
using UnityEngine;

[Factory("graphics")]
public class Graphics : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static int shadowmode = 2;

	[ClientVar(Saved = true)]
	public static int shadowlights = 1;

	private static int _shadowquality = 1;

	[ClientVar(Saved = true)]
	public static bool grassshadows = false;

	[ClientVar(Saved = true)]
	public static bool contactshadows = false;

	[ClientVar(Saved = true)]
	public static float drawdistance = 2500f;

	private static EncryptedValue<float> _fov = 75f;

	[ClientVar]
	public static bool hud = true;

	[ClientVar(Saved = true)]
	public static bool chat = true;

	[ClientVar(Saved = true)]
	public static bool branding = true;

	[ClientVar(Saved = true)]
	public static int compass = 1;

	[ClientVar(Saved = true)]
	public static bool dof = false;

	[ClientVar(Saved = true)]
	public static float dof_aper = 12f;

	[ClientVar(Saved = true)]
	public static float dof_blur = 1f;

	[ClientVar(Saved = true, Help = "0 = auto 1 = manual 2 = dynamic based on target")]
	public static int dof_mode = 0;

	[ClientVar(Saved = true, Help = "distance from camera to focus on")]
	public static float dof_focus_dist = 10f;

	[ClientVar(Saved = true)]
	public static float dof_focus_time = 0.2f;

	[ClientVar(Saved = true, ClientAdmin = true)]
	public static float dof_squeeze = 0f;

	[ClientVar(Saved = true, ClientAdmin = true)]
	public static float dof_barrel = 0f;

	[ClientVar(Saved = true, ClientAdmin = true)]
	public static bool dof_debug = false;

	[ClientVar(Saved = true, Help = "Goes from 0 - 3, higher = more dof samples but slower perf")]
	public static int dof_kernel_count = 0;

	public static BaseEntity dof_focus_target_entity = null;

	[ClientVar(Saved = true, Help = "Whether to scale vm models with fov")]
	public static bool vm_fov_scale = true;

	[ClientVar(Saved = true, Help = "FLips viewmodels horizontally (for left handed players)")]
	public static bool vm_horizontal_flip = false;

	private static float _uiscale = 1f;

	private static int _anisotropic = 1;

	private static int _parallax = 0;

	[ClientVar(Help = "Represents the number of vertical syncs that should pass between each frame. An integer in the range of 0-4. ", Saved = true)]
	public static int vsync
	{
		get
		{
			return QualitySettings.vSyncCount;
		}
		set
		{
			QualitySettings.vSyncCount = Mathf.Clamp(value, 0, 4);
		}
	}

	[ClientVar(Saved = true)]
	public static int shadowquality
	{
		get
		{
			return _shadowquality;
		}
		set
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Invalid comparison between Unknown and I4
			_shadowquality = Mathf.Clamp(value, 0, 3);
			shadowmode = _shadowquality + 1;
			bool flag = (int)SystemInfo.graphicsDeviceType == 17;
			KeywordUtil.EnsureKeywordState("SHADOW_QUALITY_HIGH", !flag && _shadowquality == 2);
			KeywordUtil.EnsureKeywordState("SHADOW_QUALITY_VERYHIGH", !flag && _shadowquality == 3);
			KeywordUtil.EnsureKeywordState("FORWARD_SHADOWS_MEDIUM", _shadowquality == 1);
			KeywordUtil.EnsureKeywordState("FORWARD_SHADOWS_HIGH", _shadowquality >= 2);
		}
	}

	[ClientVar(Saved = true)]
	public static float fov
	{
		get
		{
			return _fov;
		}
		set
		{
			_fov = Mathf.Clamp(value, 70f, 90f);
		}
	}

	[ClientVar(Help = "Global multiplier for the LOD's switching distance. A larger value leads to a longer view distance before a lower resolution LOD is picked.", Saved = true)]
	public static float lodBias
	{
		get
		{
			return QualitySettings.lodBias;
		}
		set
		{
			QualitySettings.lodBias = Mathf.Clamp(value, 0.5f, 5f);
		}
	}

	[ClientVar(Saved = true)]
	public static int shaderlod
	{
		get
		{
			return Shader.globalMaximumLOD;
		}
		set
		{
			Shader.globalMaximumLOD = Mathf.Clamp(value, 100, 600);
		}
	}

	[ClientVar(Saved = true)]
	public static float uiscale
	{
		get
		{
			return _uiscale;
		}
		set
		{
			_uiscale = Mathf.Clamp(value, 0.5f, 1f);
		}
	}

	[ClientVar(Saved = true)]
	public static int af
	{
		get
		{
			return _anisotropic;
		}
		set
		{
			value = Mathf.Clamp(value, 1, 16);
			Texture.SetGlobalAnisotropicFilteringLimits(1, value);
			if (value <= 1)
			{
				Texture.anisotropicFiltering = (AnisotropicFiltering)0;
			}
			if (value > 1)
			{
				Texture.anisotropicFiltering = (AnisotropicFiltering)1;
			}
			_anisotropic = value;
		}
	}

	[ClientVar(Saved = true)]
	public static int parallax
	{
		get
		{
			return _parallax;
		}
		set
		{
			switch (value)
			{
			default:
				Shader.DisableKeyword("TERRAIN_PARALLAX_OFFSET");
				Shader.DisableKeyword("TERRAIN_PARALLAX_OCCLUSION");
				break;
			case 1:
				Shader.EnableKeyword("TERRAIN_PARALLAX_OFFSET");
				Shader.DisableKeyword("TERRAIN_PARALLAX_OCCLUSION");
				break;
			case 2:
				Shader.DisableKeyword("TERRAIN_PARALLAX_OFFSET");
				Shader.EnableKeyword("TERRAIN_PARALLAX_OCCLUSION");
				break;
			}
			_parallax = value;
		}
	}

	[ClientVar(ClientAdmin = true)]
	public static bool itemskins
	{
		get
		{
			return WorkshopSkin.AllowApply;
		}
		set
		{
			WorkshopSkin.AllowApply = value;
		}
	}

	[ClientVar]
	public static bool itemskinunload
	{
		get
		{
			return WorkshopSkin.AllowUnload;
		}
		set
		{
			WorkshopSkin.AllowUnload = value;
		}
	}

	[ClientVar(ClientAdmin = true)]
	public static float itemskintimeout
	{
		get
		{
			return WorkshopSkin.DownloadTimeout;
		}
		set
		{
			WorkshopSkin.DownloadTimeout = value;
		}
	}

	[ClientVar(ClientAdmin = true)]
	public static void dof_focus_target(Arg arg)
	{
	}

	[ClientVar]
	public static void dof_nudge(Arg arg)
	{
		float @float = arg.GetFloat(0, 0f);
		dof_focus_dist += @float;
		if (dof_focus_dist < 0f)
		{
			dof_focus_dist = 0f;
		}
	}
}


using System.Linq;
using UnityEngine;

[Factory("graphicssettings")]
public class GraphicsSettings : ConsoleSystem
{
	private const float MinShadowDistance = 100f;

	private const float MaxShadowDistance2Split = 600f;

	private const float MaxShadowDistance4Split = 1000f;

	private static float _shadowDistancePercent = 100f;

	[ClientVar(Help = "The maximum number of pixel lights that should affect any object.", Saved = true)]
	public static int pixelLightCount
	{
		get
		{
			return QualitySettings.pixelLightCount;
		}
		set
		{
			QualitySettings.pixelLightCount = Mathf.Clamp(value, 0, 8);
		}
	}

	[ClientVar(Help = "Indicates how many of the highest-resolution mips of each texture Unity does not upload at the given quality level.", Saved = true)]
	public static int globalTextureMipmapLimit
	{
		get
		{
			return QualitySettings.globalTextureMipmapLimit;
		}
		set
		{
			QualitySettings.globalTextureMipmapLimit = Mathf.Clamp(value, 0, 3);
		}
	}

	[ClientVar(Help = "Global anisotropic filtering mode. 0-2. Disabled, enabled per-texture, force-enabled for all textures.", Saved = true)]
	public static int anisotropicFiltering
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)QualitySettings.anisotropicFiltering;
		}
		set
		{
			QualitySettings.anisotropicFiltering = (AnisotropicFiltering)Mathf.Clamp(value, 0, 2);
		}
	}

	[ClientVar(Help = "Should soft blending be used for particles?", Saved = true)]
	public static bool softParticles
	{
		get
		{
			return QualitySettings.softParticles;
		}
		set
		{
			QualitySettings.softParticles = value;
		}
	}

	[ClientVar(Help = "Budget for how many ray casts can be performed per frame for approximate collision testing.", Saved = true)]
	public static int particleRaycastBudget
	{
		get
		{
			return QualitySettings.particleRaycastBudget;
		}
		set
		{
			QualitySettings.particleRaycastBudget = value;
		}
	}

	[ClientVar(Help = "If enabled, billboards will face towards camera position rather than camera orientation.", Saved = true)]
	public static bool billboardsFaceCameraPosition
	{
		get
		{
			return QualitySettings.billboardsFaceCameraPosition;
		}
		set
		{
			QualitySettings.billboardsFaceCameraPosition = value;
		}
	}

	[ClientVar(Help = "The rendering mode of Shadowmask. 0 = Shadowmask 1 = Distance Shadowmask", Saved = true)]
	public static int shadowmaskMode
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)QualitySettings.shadowmaskMode;
		}
		set
		{
			QualitySettings.shadowmaskMode = (ShadowmaskMode)Mathf.Clamp(value, 0, 1);
		}
	}

	[ClientVar(Help = "The default resolution of shadow maps. 0 = Low, 1 = Medium, 2 = High, 3 = Very High", Saved = true)]
	public static int shadowResolution
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)QualitySettings.shadowResolution;
		}
		set
		{
			QualitySettings.shadowResolution = (ShadowResolution)Mathf.Clamp(value, 0, 3);
		}
	}

	[ClientVar(Help = "Shadow drawing distance percentage", Saved = true)]
	public static float shadowDistancePercent
	{
		get
		{
			return _shadowDistancePercent;
		}
		set
		{
			_shadowDistancePercent = Mathf.Clamp(value, 0f, 100f);
			EnforceShadowDistanceBounds();
		}
	}

	[ClientVar(Help = "Number of cascades to use for directional light shadows. 1 = None, 2 = Two, 4 = Four", Saved = true)]
	public static int shadowCascades
	{
		get
		{
			return QualitySettings.shadowCascades;
		}
		set
		{
			QualitySettings.shadowCascades = ForceOption(value, 1, 1, 2, 4);
			EnforceShadowDistanceBounds();
		}
	}

	[ClientVar(Help = "Enables or disables LOD Cross Fade.", Saved = true)]
	public static bool enableLODCrossFade
	{
		get
		{
			return QualitySettings.enableLODCrossFade;
		}
		set
		{
			QualitySettings.enableLODCrossFade = value;
		}
	}

	public static void SetMandatoryDefaults()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		QualitySettings.useLegacyDetailDistribution = true;
		QualitySettings.terrainQualityOverrides = (TerrainQualityOverrides)0;
		QualitySettings.shadowNearPlaneOffset = 2f;
		QualitySettings.shadowCascade2Split = 0.1f;
		QualitySettings.shadowCascade4Split = new Vector3(0.01f, 0.03f, 0.1f);
		QualitySettings.asyncUploadTimeSlice = 2;
		QualitySettings.asyncUploadBufferSize = 4;
		QualitySettings.asyncUploadPersistentBuffer = true;
		QualitySettings.maximumLODLevel = 0;
		QualitySettings.enableLODCrossFade = true;
		QualitySettings.skinWeights = (SkinWeights)4;
		QualitySettings.resolutionScalingFixedDPIFactor = 1f;
		QualitySettings.shadows = (ShadowQuality)2;
		QualitySettings.shadowProjection = (ShadowProjection)1;
	}

	private static void EnforceShadowDistanceBounds()
	{
		float num = _shadowDistancePercent / 100f;
		float shadowDistance = ((QualitySettings.shadowCascades == 1) ? 100f : ((QualitySettings.shadowCascades != 2) ? (100f + 900f * num) : (100f + 500f * num)));
		QualitySettings.shadowDistance = shadowDistance;
	}

	private static int ForceOption(int value, int defaultValue, params int[] options)
	{
		if (options == null || options.Length == 0 || !options.Contains(value))
		{
			return defaultValue;
		}
		return value;
	}
}


[Factory("grass")]
public class Grass : ConsoleSystem
{
}


[Factory("halloween")]
public class Halloween : ConsoleSystem
{
	[ServerVar]
	public static bool enabled = false;

	[ServerVar(Help = "Population active on the server, per square km")]
	public static float murdererpopulation = 0f;

	[ServerVar(Help = "Population active on the server, per square km")]
	public static float scarecrowpopulation = 0f;

	[ServerVar(Help = "Scarecrows can throw beancans (Default: true).")]
	public static bool scarecrows_throw_beancans = true;

	[ServerVar(Help = "The delay globally on a server between each time a scarecrow throws a beancan (Default: 8 seconds).")]
	public static float scarecrow_throw_beancan_global_delay = 8f;

	[ServerVar(Help = "Modified damage from beancan explosion vs players (Default: 0.1).")]
	public static float scarecrow_beancan_vs_player_dmg_modifier = 0.1f;

	[ServerVar(Help = "Modifier to how much damage scarecrows take to the body. (Default: 0.25)")]
	public static float scarecrow_body_dmg_modifier = 0.25f;

	[ServerVar(Help = "Stopping distance for destinations set while chasing a target (Default: 0.5)")]
	public static float scarecrow_chase_stopping_distance = 0.5f;
}


[Factory("harmony")]
public class Harmony : ConsoleSystem
{
	[ServerVar(Name = "load")]
	public static void Load(Arg args)
	{
		HarmonyLoader.TryLoadMod(args.GetString(0, ""));
	}

	[ServerVar(Name = "unload")]
	public static void Unload(Arg args)
	{
		HarmonyLoader.TryUnloadMod(args.GetString(0, ""));
	}
}


using UnityEngine;

[Factory("heli")]
public class PatrolHelicopter : ConsoleSystem
{
	private const string path = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";

	[ServerVar]
	public static float lifetimeMinutes = 30f;

	[ServerVar]
	public static int guns = 1;

	[ServerVar]
	public static float bulletDamageScale = 1f;

	[ServerVar]
	public static float bulletAccuracy = 2f;

	[ServerVar]
	public static void drop(Arg arg)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Vector3 pos = ((Component)basePlayer).transform.position;
			Debug.Log((object)("heli called to : " + ((object)(Vector3)(ref pos)/*cast due to .constrained prefix*/).ToString()));
			GameManager server = GameManager.server;
			pos = default(Vector3);
			BaseEntity baseEntity = server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", pos);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).GetComponent<PatrolHelicopterAI>().SetInitialDestination(((Component)basePlayer).transform.position + new Vector3(0f, 10f, 0f), 0f);
				baseEntity.Spawn();
			}
		}
	}

	[ServerVar]
	public static void calltome(Arg arg)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Vector3 pos = ((Component)basePlayer).transform.position;
			Debug.Log((object)("heli called to : " + ((object)(Vector3)(ref pos)/*cast due to .constrained prefix*/).ToString()));
			GameManager server = GameManager.server;
			pos = default(Vector3);
			BaseEntity baseEntity = server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", pos);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).GetComponent<PatrolHelicopterAI>().SetInitialDestination(((Component)basePlayer).transform.position + new Vector3(0f, 10f, 0f));
				baseEntity.Spawn();
			}
		}
	}

	[ServerVar]
	public static void call(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)arg.Player()))
		{
			Debug.Log((object)"Helicopter inbound");
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab");
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.Spawn();
			}
		}
	}

	[ServerVar]
	public static void strafe(Arg arg)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.strafe_target = basePlayer;
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Strafe_Enter(basePlayer);
		}
	}

	[ServerVar]
	public static void orbit(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Orbit_Enter(70f);
		}
	}

	[ServerVar]
	public static void orbitstrafe(Arg arg)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.strafe_target = basePlayer;
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_OrbitStrafe_Enter();
		}
	}

	[ServerVar]
	public static void move(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Move_Enter(((Component)basePlayer).transform.position);
		}
	}

	[ServerVar]
	public static void flee(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Flee_Enter(((Component)basePlayer).transform.position);
		}
	}

	[ServerVar]
	public static void patrol(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Patrol_Enter();
		}
	}

	[ServerVar]
	public static void death(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Death_Enter();
		}
	}

	[ServerVar]
	public static void testpuzzle(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			_ = basePlayer.IsDeveloper;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[Factory("hierarchy")]
public class Hierarchy : ConsoleSystem
{
	private static GameObject currentDir;

	private static Transform[] GetCurrent()
	{
		if ((Object)(object)currentDir == (Object)null)
		{
			return TransformUtil.GetRootObjects().ToArray();
		}
		List<Transform> list = new List<Transform>();
		for (int i = 0; i < currentDir.transform.childCount; i++)
		{
			list.Add(currentDir.transform.GetChild(i));
		}
		return list.ToArray();
	}

	[ServerVar]
	public static void ls(Arg args)
	{
		string text = "";
		string filter = args.GetString(0, "");
		text = ((!Object.op_Implicit((Object)(object)currentDir)) ? (text + "Listing .\n\n") : (text + "Listing " + currentDir.transform.GetRecursiveName() + "\n\n"));
		foreach (Transform item in (from x in GetCurrent()
			where string.IsNullOrEmpty(filter) || ((Object)x).name.Contains(filter)
			select x).Take(40))
		{
			text += $"   {((Object)item).name} [{item.childCount}]\n";
		}
		text += "\n";
		args.ReplyWith(text);
	}

	[ServerVar]
	public static void cd(Arg args)
	{
		if (args.FullString == ".")
		{
			currentDir = null;
			args.ReplyWith("Changed to .");
			return;
		}
		if (args.FullString == "..")
		{
			if (Object.op_Implicit((Object)(object)currentDir))
			{
				currentDir = (Object.op_Implicit((Object)(object)currentDir.transform.parent) ? ((Component)currentDir.transform.parent).gameObject : null);
			}
			currentDir = null;
			if (Object.op_Implicit((Object)(object)currentDir))
			{
				args.ReplyWith("Changed to " + currentDir.transform.GetRecursiveName());
			}
			else
			{
				args.ReplyWith("Changed to .");
			}
			return;
		}
		Transform val = ((IEnumerable<Transform>)GetCurrent()).FirstOrDefault((Func<Transform, bool>)((Transform x) => ((Object)x).name.ToLower() == args.FullString.ToLower()));
		if ((Object)(object)val == (Object)null)
		{
			val = ((IEnumerable<Transform>)GetCurrent()).FirstOrDefault((Func<Transform, bool>)((Transform x) => ((Object)x).name.StartsWith(args.FullString, StringComparison.CurrentCultureIgnoreCase)));
		}
		if (Object.op_Implicit((Object)(object)val))
		{
			currentDir = ((Component)val).gameObject;
			args.ReplyWith("Changed to " + currentDir.transform.GetRecursiveName());
		}
		else
		{
			args.ReplyWith("Couldn't find \"" + args.FullString + "\"");
		}
	}

	[ServerVar]
	public static void del(Arg args)
	{
		if (!args.HasArgs(1))
		{
			return;
		}
		IEnumerable<Transform> enumerable = from x in GetCurrent()
			where ((Object)x).name.ToLower() == args.FullString.ToLower()
			select x;
		if (enumerable.Count() == 0)
		{
			enumerable = from x in GetCurrent()
				where ((Object)x).name.StartsWith(args.FullString, StringComparison.CurrentCultureIgnoreCase)
				select x;
		}
		if (enumerable.Count() == 0)
		{
			args.ReplyWith("Couldn't find  " + args.FullString);
			return;
		}
		foreach (Transform item in enumerable)
		{
			BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
			if (baseEntity.IsValid())
			{
				if (baseEntity.isServer)
				{
					baseEntity.Kill();
				}
			}
			else
			{
				GameManager.Destroy(((Component)item).gameObject);
			}
		}
		args.ReplyWith("Deleted " + enumerable.Count() + " objects");
	}
}


[Factory("input")]
public class Input : ConsoleSystem
{
}


[Factory("instruments")]
public class instruments : ConsoleSystem
{
	public const string InstrumentsFolder = "instruments";
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Newtonsoft.Json;
using Steamworks;
using UnityEngine;

[Factory("inventory")]
public class Inventory : ConsoleSystem
{
	public class SavedLoadout
	{
		public struct SavedItem
		{
			public int id;

			public int amount;

			public ulong skin;

			public int[] containedItems;

			public int blueprintTarget;
		}

		public SavedItem[] belt;

		public SavedItem[] wear;

		public SavedItem[] main;

		public SavedItem[] backpack;

		public int heldItemIndex;

		public SavedLoadout()
		{
		}

		public SavedLoadout(BasePlayer player)
		{
			belt = SaveItems(player.inventory.containerBelt);
			wear = SaveItems(player.inventory.containerWear);
			main = SaveItems(player.inventory.containerMain);
			Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
			if (backpackWithInventory != null)
			{
				backpack = SaveItems(backpackWithInventory.contents);
			}
			heldItemIndex = GetSlotIndex(player);
		}

		public SavedLoadout(PlayerInventoryProperties properties)
		{
			belt = SaveItems(properties.belt);
			wear = SaveItems(properties.wear);
			main = SaveItems(properties.main);
			heldItemIndex = 0;
		}

		private static SavedItem[] SaveItems(ItemContainer itemContainer)
		{
			List<SavedItem> list = new List<SavedItem>();
			for (int i = 0; i < itemContainer.capacity; i++)
			{
				Item slot = itemContainer.GetSlot(i);
				if (slot == null)
				{
					continue;
				}
				SavedItem savedItem = default(SavedItem);
				savedItem.id = slot.info.itemid;
				savedItem.amount = slot.amount;
				savedItem.skin = slot.skin;
				savedItem.blueprintTarget = slot.blueprintTarget;
				SavedItem item = savedItem;
				if (slot.contents != null && slot.contents.itemList != null)
				{
					List<int> list2 = new List<int>();
					foreach (Item item2 in slot.contents.itemList)
					{
						list2.Add(item2.info.itemid);
					}
					item.containedItems = list2.ToArray();
				}
				list.Add(item);
			}
			return list.ToArray();
		}

		private static SavedItem[] SaveItems(List<PlayerInventoryProperties.ItemAmountSkinned> items)
		{
			List<SavedItem> list = new List<SavedItem>();
			foreach (PlayerInventoryProperties.ItemAmountSkinned item2 in items)
			{
				SavedItem savedItem = default(SavedItem);
				savedItem.id = item2.itemid;
				savedItem.amount = (int)item2.amount;
				savedItem.skin = item2.skinOverride;
				SavedItem item = savedItem;
				if (item2.blueprint)
				{
					item.blueprintTarget = item.id;
					item.id = ItemManager.blueprintBaseDef.itemid;
				}
				list.Add(item);
			}
			return list.ToArray();
		}

		public void LoadItemsOnTo(BasePlayer player)
		{
			player.inventory.containerMain.Clear();
			player.inventory.containerBelt.Clear();
			player.inventory.containerWear.Clear();
			ItemManager.DoRemoves();
			LoadItems(belt, player.inventory.containerBelt);
			LoadItems(wear, player.inventory.containerWear);
			LoadItems(main, player.inventory.containerMain);
			if (backpack != null && backpack.Length != 0)
			{
				Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
				if (backpackWithInventory != null)
				{
					backpackWithInventory.contents.Clear();
					LoadItems(backpack, backpackWithInventory.contents);
				}
			}
			EquipItemInSlot(player, heldItemIndex);
			player.inventory.SendSnapshot();
			void LoadItems(SavedItem[] items, ItemContainer container)
			{
				foreach (SavedItem item in items)
				{
					player.inventory.GiveItem(LoadItem(item), container);
				}
			}
		}

		private Item LoadItem(SavedItem item)
		{
			Item item2 = ItemManager.CreateByItemID(item.id, item.amount, item.skin);
			if (item.blueprintTarget != 0)
			{
				item2.blueprintTarget = item.blueprintTarget;
			}
			if (item.containedItems != null && item.containedItems.Length != 0)
			{
				int[] containedItems = item.containedItems;
				foreach (int itemID in containedItems)
				{
					item2.contents.AddItem(ItemManager.FindItemDefinition(itemID), 1, 0uL);
				}
			}
			return item2;
		}
	}

	[ReplicatedVar(Help = "Disables all attire limitations, so NPC clothing and invalid overlaps can be equipped")]
	public static bool disableAttireLimitations;

	private const string LoadoutDirectory = "loadouts";

	[ServerVar]
	public static bool stackable_item_ownership;

	[ServerUserVar(Name = "lighttoggle")]
	public static void lighttoggle_sv(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead() && !basePlayer.IsSleeping() && !basePlayer.InGesture)
		{
			basePlayer.LightToggle();
		}
	}

	[ServerUserVar]
	public static void endloot(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead() && !basePlayer.IsSleeping())
		{
			basePlayer.inventory.loot.Clear();
		}
	}

	[ServerVar(Help = "{item} {amount} {condition} {skin} {container} {slot}")]
	public static void give(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		bool flag = arg.HasArg("--silent", true);
		Item item = ItemManager.CreateByPartialName(arg.GetString(0, ""), 1, arg.GetULong(3, 0uL));
		if (item == null)
		{
			arg.ReplyWith("Invalid Item!");
			return;
		}
		int num = (item.amount = arg.GetInt(1, 1));
		float @float = arg.GetFloat(2, 1f);
		item.conditionNormalized = @float;
		item.OnVirginSpawn();
		item.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		string @string = arg.GetString(4, "");
		int num2 = arg.GetInt(5, -1);
		ItemContainer itemContainer = null;
		switch (@string)
		{
		case "0":
		case "main":
			itemContainer = basePlayer.inventory.containerMain;
			break;
		case "1":
		case "belt":
			itemContainer = basePlayer.inventory.containerBelt;
			break;
		case "2":
		case "wear":
			itemContainer = basePlayer.inventory.containerWear;
			break;
		}
		if (itemContainer == null)
		{
			if (!basePlayer.inventory.GiveItem(item))
			{
				item.Remove();
				arg.ReplyWith("Couldn't give item (inventory full?)");
				return;
			}
		}
		else
		{
			if (num2 != -1)
			{
				Item slot = itemContainer.GetSlot(num2);
				if (slot != null && slot.contents != null)
				{
					itemContainer = slot.contents;
					num2 = -1;
				}
			}
			if (!item.MoveToContainer(itemContainer, num2))
			{
				item.Remove();
				arg.ReplyWith("Couldn't give item (inventory full?)");
				return;
			}
		}
		if (!flag)
		{
			basePlayer.Command("note.inv", item.info.itemid, num);
		}
		Debug.Log((object)("giving " + basePlayer.displayName + " " + num + " x " + item.info.displayName.english));
		if (basePlayer.IsDeveloper)
		{
			if (!flag)
			{
				basePlayer.ChatMessage("you silently gave yourself " + num + " x " + item.info.displayName.english);
			}
			return;
		}
		Chat.Broadcast(basePlayer.displayName + " gave themselves " + num + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
	}

	[ServerVar]
	public static void resetbp(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayer(0);
		if ((Object)(object)basePlayer == (Object)null)
		{
			if (arg.HasArgs(1))
			{
				arg.ReplyWith("Can't find player");
				return;
			}
			basePlayer = arg.Player();
		}
		basePlayer.blueprints.Reset();
	}

	[ServerVar]
	public static void unlockall(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayer(0);
		if ((Object)(object)basePlayer == (Object)null)
		{
			if (arg.HasArgs(1))
			{
				arg.ReplyWith("Can't find player");
				return;
			}
			basePlayer = arg.Player();
		}
		basePlayer.blueprints.UnlockAll();
	}

	[ServerVar]
	public static void giveall(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Item item = null;
		string text = "SERVER";
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null)
		{
			text = basePlayer.displayName;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				item = ItemManager.CreateByPartialName(arg.GetString(0, ""), 1, 0uL);
				if (item == null)
				{
					arg.ReplyWith("Invalid Item!");
					return;
				}
				int num = (item.amount = arg.GetInt(1, 1));
				item.OnVirginSpawn();
				item.SetItemOwnership(text, ItemOwnershipPhrases.SpawnedPhrase);
				if (!current.inventory.GiveItem(item))
				{
					item.Remove();
					arg.ReplyWith("Couldn't give item (inventory full?)");
					continue;
				}
				current.Command("note.inv", item.info.itemid, num);
				Debug.Log((object)(" [ServerVar] giving " + current.displayName + " " + item.amount + " x " + item.info.displayName.english));
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		if (item != null)
		{
			Chat.Broadcast(text + " gave everyone " + item.amount + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
		}
	}

	[ServerVar(Help = "{item} {player} {amount} {skin}")]
	public static void giveto(Arg arg)
	{
		string text = "SERVER";
		if ((Object)(object)arg.Player() != (Object)null)
		{
			text = arg.Player().displayName;
		}
		BasePlayer basePlayer = BasePlayer.Find(arg.GetString(0, ""));
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Couldn't find player!");
			return;
		}
		Item item = ItemManager.CreateByPartialName(arg.GetString(1, ""), 1, arg.GetULong(3, 0uL));
		if (item == null)
		{
			arg.ReplyWith("Invalid Item!");
			return;
		}
		int num = (item.amount = arg.GetInt(2, 1));
		item.OnVirginSpawn();
		item.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		if (!basePlayer.inventory.GiveItem(item))
		{
			item.Remove();
			arg.ReplyWith("Couldn't give item (inventory full?)");
			return;
		}
		basePlayer.Command("note.inv", item.info.itemid, num);
		Debug.Log((object)(" [ServerVar] giving " + basePlayer.displayName + " " + num + " x " + item.info.displayName.english));
		Chat.Broadcast(text + " gave " + basePlayer.displayName + " " + num + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
	}

	[ServerVar(Help = "{itemid} {amount}")]
	public static void giveid(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		Item item = ItemManager.CreateByItemID(arg.GetInt(0, 0), 1, 0uL);
		if (item == null)
		{
			arg.ReplyWith("Invalid Item!");
			return;
		}
		int num = (item.amount = arg.GetInt(1, 1));
		item.OnVirginSpawn();
		item.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		if (!basePlayer.inventory.GiveItem(item))
		{
			item.Remove();
			arg.ReplyWith("Couldn't give item (inventory full?)");
			return;
		}
		basePlayer.Command("note.inv", item.info.itemid, num);
		Debug.Log((object)(" [ServerVar] giving " + basePlayer.displayName + " " + num + " x " + item.info.displayName.english));
		if (basePlayer.IsDeveloper)
		{
			basePlayer.ChatMessage("you silently gave yourself " + num + " x " + item.info.displayName.english);
			return;
		}
		Chat.Broadcast(basePlayer.displayName + " gave themselves " + num + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
	}

	[ServerVar(Help = "{itemid} {amount}")]
	public static void givearm(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		Item item = ItemManager.CreateByItemID(arg.GetInt(0, 0), 1, 0uL);
		if (item == null)
		{
			arg.ReplyWith("Invalid Item!");
			return;
		}
		int num = (item.amount = arg.GetInt(1, 1));
		item.OnVirginSpawn();
		item.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		if (!basePlayer.inventory.GiveItem(item, basePlayer.inventory.containerBelt))
		{
			item.Remove();
			arg.ReplyWith("Couldn't give item (inventory full?)");
			return;
		}
		basePlayer.Command("note.inv", item.info.itemid, num);
		Debug.Log((object)(" [ServerVar] giving " + basePlayer.displayName + " " + item.amount + " x " + item.info.displayName.english));
		if (basePlayer.IsDeveloper)
		{
			basePlayer.ChatMessage("you silently gave yourself " + item.amount + " x " + item.info.displayName.english);
			return;
		}
		Chat.Broadcast(basePlayer.displayName + " gave themselves " + item.amount + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
	}

	[ServerVar]
	public static void pipetteid(Arg arg)
	{
		BasePlayer ply = arg.Player();
		int itemId = arg.GetInt(0, 0);
		List<Item> list = ply.inventory.FindItemsByItemID(itemId);
		ulong skinId = arg.GetULong(1, 1uL);
		bool flag = false;
		foreach (Item item in list)
		{
			if (item.skin == skinId)
			{
				flag = true;
			}
		}
		if (!flag)
		{
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemId);
			ply.Command($"give {itemDefinition.shortname} 1 1 {skinId}");
		}
		InvokeHandler.Invoke((Behaviour)(object)ply, (Action)delegate
		{
			ply.Command($"inventory.selectitem {itemId} {skinId}");
		}, 0.2f);
	}

	[ServerVar(Help = "Copies the players inventory to the player in front of them")]
	public static void copyTo(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic) || (Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		BasePlayer basePlayer2 = null;
		if (arg.HasArgs(1) && arg.GetString(0, "").ToLower() != "true")
		{
			basePlayer2 = arg.GetPlayer(0);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				uint uInt = arg.GetUInt(0, 0u);
				basePlayer2 = BasePlayer.FindByID(uInt);
				if ((Object)(object)basePlayer2 == (Object)null)
				{
					basePlayer2 = BasePlayer.FindBot(uInt);
				}
			}
		}
		else
		{
			basePlayer2 = RelationshipManager.GetLookingAtPlayer(basePlayer);
		}
		if (!((Object)(object)basePlayer2 == (Object)null))
		{
			copyTo(basePlayer, basePlayer2);
		}
	}

	public static void copyTo(BasePlayer from, BasePlayer toply)
	{
		toply.inventory.containerBelt.Clear();
		toply.inventory.containerWear.Clear();
		int num = 0;
		foreach (Item item4 in from.inventory.containerBelt.itemList)
		{
			toply.inventory.containerBelt.AddItem(item4.info, item4.amount, item4.skin);
			if (item4.contents != null && !CopyArmorSlots(item4, toply.inventory.containerBelt.itemList[num], toply))
			{
				Item item = toply.inventory.containerBelt.itemList[num];
				foreach (Item item5 in item4.contents.itemList)
				{
					item.contents.AddItem(item5.info, item5.amount, item5.skin);
				}
			}
			num++;
		}
		foreach (Item item6 in from.inventory.containerWear.itemList)
		{
			toply.inventory.containerWear.AddItem(item6.info, item6.amount, item6.skin);
			if (item6.contents == null)
			{
				continue;
			}
			List<Item> itemList = toply.inventory.containerWear.itemList;
			Item item2 = itemList[itemList.Count - 1];
			if (item6.IsBackpack())
			{
				if (item2 == null)
				{
					continue;
				}
				foreach (Item item7 in item6.contents.itemList)
				{
					item2.contents.AddItem(item7.info, item7.amount, item7.skin);
					if (item7.contents == null)
					{
						continue;
					}
					List<Item> itemList2 = item2.contents.itemList;
					Item item3 = itemList2[itemList2.Count - 1];
					if (CopyArmorSlots(item7, item3, toply))
					{
						continue;
					}
					foreach (Item item8 in item7.contents.itemList)
					{
						item3.contents.AddItem(item8.info, item8.amount, item8.skin);
					}
				}
			}
			else
			{
				CopyArmorSlots(item6, item2, toply);
			}
		}
		if (from.IsDeveloper)
		{
			from.ChatMessage("you silently copied items to " + toply.displayName);
		}
		else
		{
			Chat.Broadcast(from.displayName + " copied their inventory to " + toply.displayName, "SERVER", "#eee", 0uL);
		}
	}

	private static bool CopyArmorSlots(Item sourceItem, Item destItem, BasePlayer player)
	{
		if (sourceItem == null)
		{
			return false;
		}
		if (sourceItem.contents == null)
		{
			return false;
		}
		if (destItem == null)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		ItemModContainerArmorSlot itemModContainerArmorSlot = default(ItemModContainerArmorSlot);
		if (!((Component)sourceItem.info).TryGetComponent<ItemModContainerArmorSlot>(ref itemModContainerArmorSlot))
		{
			return false;
		}
		int capacity = sourceItem.contents.capacity;
		if (capacity == 0)
		{
			return false;
		}
		((Component)destItem.info).GetComponent<ItemModContainerArmorSlot>().CreateAtCapacity(capacity, destItem);
		foreach (Item item in sourceItem.contents.itemList)
		{
			destItem.contents.AddItem(item.info, item.amount, item.skin);
		}
		return true;
	}

	[ServerVar(Help = "Deploys a loadout to players in a radius eg. inventory.deployLoadoutInRange testloadout 30")]
	public static void deployLoadoutInRange(Arg arg)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic) || (Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		string @string = arg.GetString(0, "");
		if (!LoadLoadout(@string, out var so))
		{
			arg.ReplyWith("Can't find loadout: " + @string);
			return;
		}
		float @float = arg.GetFloat(1, 0f);
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)basePlayer).transform.position, @float, list, 131072, (QueryTriggerInteraction)2);
		int num = 0;
		foreach (BasePlayer item in list)
		{
			if (!((Object)(object)item == (Object)(object)basePlayer) && !item.isClient)
			{
				so.LoadItemsOnTo(item);
				num++;
			}
		}
		arg.ReplyWith($"Applied loadout {@string} to {num} players");
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar(Help = "Deploys the given loadout to a target player. eg. inventory.deployLoadout testloadout jim")]
	public static void deployLoadout(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic))
		{
			string @string = arg.GetString(0, "");
			BasePlayer basePlayer2 = (string.IsNullOrEmpty(arg.GetString(1, "")) ? null : arg.GetPlayerOrSleeperOrBot(1));
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				basePlayer2 = basePlayer;
			}
			SavedLoadout so;
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				arg.ReplyWith("Could not find player " + arg.GetString(1, "") + " and no local player available");
			}
			else if (LoadLoadout(@string, out so))
			{
				so.LoadItemsOnTo(basePlayer2);
				arg.ReplyWith("Deployed loadout " + @string + " to " + basePlayer2.displayName);
			}
			else
			{
				arg.ReplyWith("Could not find loadout " + @string);
			}
		}
	}

	[ServerVar(Help = "Clears the inventory of a target player. eg. inventory.clearInventory jim. Can take container names as arguments: --belt --wear --backpack")]
	public static void clearInventory(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic))
		{
			return;
		}
		arg.HasArg("True", true);
		arg.HasArg("False", false);
		BasePlayer basePlayer2 = basePlayer;
		StringBuilder stringBuilder = new StringBuilder();
		if (arg.Args == null || arg.Args.Length == 0)
		{
			basePlayer2.inventory.containerMain.Clear();
			basePlayer2.inventory.containerBelt.Clear();
			basePlayer2.inventory.containerWear.Clear();
			basePlayer2.inventory.GetContainer(PlayerInventory.Type.BackpackContents)?.Clear();
			stringBuilder.AppendLine("Whole inventory cleared");
		}
		else
		{
			int num = 0;
			basePlayer2 = arg.GetPlayerOrSleeperOrBot(0);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				switch (arg.GetString(0, "").ToLower())
				{
				case "--main":
				case "--belt":
				case "--wear":
				case "--backpack":
					break;
				default:
					arg.ReplyWith("Could not find player '" + arg.GetString(0, "") + "'");
					return;
				}
				basePlayer2 = basePlayer;
				num = 0;
			}
			else
			{
				num = 1;
			}
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			for (int i = num; i < arg.Args.Length; i++)
			{
				switch (arg.GetString(i, "").ToLower())
				{
				case "--main":
					flag = true;
					break;
				case "--belt":
					flag2 = true;
					break;
				case "--wear":
					flag3 = true;
					break;
				case "--backpack":
					flag4 = true;
					break;
				}
			}
			if (flag)
			{
				basePlayer2.inventory.containerMain.Clear();
				stringBuilder.AppendLine("Cleared " + basePlayer2.displayName + "'s main inventory");
			}
			if (flag2)
			{
				basePlayer2.inventory.containerBelt.Clear();
				stringBuilder.AppendLine("Cleared " + basePlayer2.displayName + "'s belt");
			}
			if (flag3)
			{
				basePlayer2.inventory.containerWear.Clear();
				stringBuilder.AppendLine("Cleared " + basePlayer2.displayName + "'s clothings");
			}
			if (flag4 && basePlayer2.inventory.GetContainer(PlayerInventory.Type.BackpackContents) != null)
			{
				basePlayer2.inventory.GetContainer(PlayerInventory.Type.BackpackContents).Clear();
				stringBuilder.AppendLine("Cleared " + basePlayer2.displayName + "'s backpack");
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
		ItemManager.DoRemoves();
	}

	private static string GetLoadoutPath(string loadoutName)
	{
		return Server.GetServerFolder("loadouts") + "/" + loadoutName + ".ldt";
	}

	[ServerVar(Help = "Saves the current equipped loadout of the calling player. eg. inventory.saveLoadout loaduoutname")]
	public static void saveloadout(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic))
		{
			string @string = arg.GetString(0, "");
			string contents = JsonConvert.SerializeObject((object)new SavedLoadout(basePlayer), (Formatting)1);
			string loadoutPath = GetLoadoutPath(@string);
			File.WriteAllText(loadoutPath, contents);
			arg.ReplyWith("Saved loadout to " + loadoutPath);
		}
	}

	public static bool LoadLoadout(string name, out SavedLoadout so)
	{
		PlayerInventoryProperties inventoryConfig = PlayerInventoryProperties.GetInventoryConfig(name);
		if (inventoryConfig != null)
		{
			Debug.Log((object)"Found builtin config!");
			so = new SavedLoadout(inventoryConfig);
			return true;
		}
		so = new SavedLoadout();
		string loadoutPath = GetLoadoutPath(name);
		if (!File.Exists(loadoutPath))
		{
			return false;
		}
		so = JsonConvert.DeserializeObject<SavedLoadout>(File.ReadAllText(loadoutPath));
		if (so == null)
		{
			return false;
		}
		return true;
	}

	[ServerVar(Help = "Prints all saved inventory loadouts")]
	public static void listloadouts(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic))
		{
			return;
		}
		string serverFolder = Server.GetServerFolder("loadouts");
		StringBuilder stringBuilder = new StringBuilder();
		foreach (string item in Directory.EnumerateFiles(serverFolder))
		{
			stringBuilder.AppendLine(item);
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ClientVar]
	[ServerVar]
	public static void defs(Arg arg)
	{
		if (SteamInventory.Definitions == null)
		{
			arg.ReplyWith("no definitions");
			return;
		}
		if (SteamInventory.Definitions.Length == 0)
		{
			arg.ReplyWith("0 definitions");
			return;
		}
		string[] array = SteamInventory.Definitions.Select((InventoryDef x) => x.Name).ToArray();
		arg.ReplyWith((object)array);
	}

	[ClientVar]
	[ServerVar]
	public static void reloaddefs(Arg arg)
	{
		SteamInventory.LoadItemDefinitions();
	}

	[ServerVar]
	public static void equipslottarget(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic) && !((Object)(object)basePlayer == (Object)null))
		{
			BasePlayer lookingAtPlayer = RelationshipManager.GetLookingAtPlayer(basePlayer);
			if (!((Object)(object)lookingAtPlayer == (Object)null))
			{
				int @int = arg.GetInt(0, 0);
				EquipItemInSlot(lookingAtPlayer, @int);
				arg.ReplyWith($"Equipped slot {@int} on player {lookingAtPlayer.displayName}");
			}
		}
	}

	[ServerVar]
	public static void equipslot(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic) || (Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		BasePlayer basePlayer2 = null;
		if (arg.HasArgs(2))
		{
			basePlayer2 = arg.GetPlayer(1);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				uint uInt = arg.GetUInt(1, 0u);
				basePlayer2 = BasePlayer.FindByID(uInt);
				if ((Object)(object)basePlayer2 == (Object)null)
				{
					basePlayer2 = BasePlayer.FindBot(uInt);
				}
			}
		}
		if (!((Object)(object)basePlayer2 == (Object)null))
		{
			int @int = arg.GetInt(0, 0);
			EquipItemInSlot(basePlayer2, @int);
			Debug.Log((object)$"Equipped slot {@int} on player {basePlayer2.displayName}");
		}
	}

	public static void EquipItemInSlot(BasePlayer player, int slot)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		ItemId itemID = default(ItemId);
		for (int i = 0; i < player.inventory.containerBelt.itemList.Count; i++)
		{
			if (player.inventory.containerBelt.itemList[i] != null && i == slot)
			{
				itemID = player.inventory.containerBelt.itemList[i].uid;
				break;
			}
		}
		player.UpdateActiveItem(itemID);
	}

	private static int GetSlotIndex(BasePlayer player)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (player.GetActiveItem() == null)
		{
			return -1;
		}
		ItemId uid = player.GetActiveItem().uid;
		for (int i = 0; i < player.inventory.containerBelt.itemList.Count; i++)
		{
			if (player.inventory.containerBelt.itemList[i] != null && player.inventory.containerBelt.itemList[i].uid == uid)
			{
				return i;
			}
		}
		return -1;
	}

	[ServerVar]
	public static void giveBp(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindDefinitionByPartialName(arg.GetString(0, ""));
		if ((Object)(object)itemDefinition == (Object)null)
		{
			arg.ReplyWith("Could not find item: " + arg.GetString(0, ""));
			return;
		}
		if ((Object)(object)itemDefinition.Blueprint == (Object)null)
		{
			arg.ReplyWith(itemDefinition.shortname + " has no blueprint!");
			return;
		}
		Item item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);
		item.blueprintTarget = itemDefinition.itemid;
		item.OnVirginSpawn();
		if (!basePlayer.inventory.GiveItem(item))
		{
			item.Remove();
			arg.ReplyWith("Couldn't give item (inventory full?)");
			return;
		}
		basePlayer.Command("note.inv", item.info.itemid, 1);
		Debug.Log((object)("giving " + basePlayer.displayName + " 1 x " + item.blueprintTargetDef.shortname + " blueprint"));
		if (basePlayer.IsDeveloper)
		{
			basePlayer.ChatMessage("you silently gave yourself 1 x " + item.blueprintTargetDef.shortname + " blueprint");
		}
		else
		{
			Chat.Broadcast(basePlayer.displayName + " gave themselves 1 x " + item.blueprintTargetDef.shortname + " blueprint", "SERVER", "#eee", 0uL);
		}
	}

	[ServerVar(Help = "Add ownership to item")]
	public static void addownership(Arg args)
	{
		Item activeItem = args.Player().GetActiveItem();
		if (activeItem == null)
		{
			args.ReplyWith("You must be holding an item to use this command");
			return;
		}
		if (!args.HasArgs(3))
		{
			args.ReplyWith("Usage: addownership {username} {reason} {amount}");
			return;
		}
		string @string = args.GetString(0, "");
		string string2 = args.GetString(1, "");
		int @int = args.GetInt(2, 1);
		activeItem.AddItemOwnership(@string, string2, @int);
		args.ReplyWith($"Added '{@int}' ownership to item");
	}

	[ServerVar(Help = "Reduce ownership to item to allow new ownership to be added")]
	public static void reduceownership(Arg args)
	{
		Item activeItem = args.Player().GetActiveItem();
		if (activeItem == null)
		{
			args.ReplyWith("You must be holding an item to use this command");
			return;
		}
		if (!args.HasArgs(1))
		{
			args.ReplyWith("Usage: reduceownership {amount}");
			return;
		}
		int @int = args.GetInt(0, 1);
		activeItem.ReduceItemOwnership(@int);
		args.ReplyWith($"Reduced ownership of item by '{@int}'");
	}

	[ServerVar(Help = "Reduce ownership to item to allow new ownership to be added")]
	public static void convertownership(Arg args)
	{
		Item activeItem = args.Player().GetActiveItem();
		if (activeItem == null)
		{
			args.ReplyWith("You must be holding an item to use this command");
			return;
		}
		if (!args.HasArgs(3))
		{
			args.ReplyWith("Usage: convertownership {username} {reason} {amount}");
			return;
		}
		string @string = args.GetString(0, "");
		string string2 = args.GetString(1, "");
		int @int = args.GetInt(2, 1);
		activeItem.ReduceItemOwnership(@int);
		activeItem.AddItemOwnership(@string, string2, @int);
		args.ReplyWith($"Converted '{@int}' ownership of item to '{@string}'");
	}
}


using System.Collections.Generic;

public class SavedLoadout
{
	public struct SavedItem
	{
		public int id;

		public int amount;

		public ulong skin;

		public int[] containedItems;

		public int blueprintTarget;
	}

	public SavedItem[] belt;

	public SavedItem[] wear;

	public SavedItem[] main;

	public SavedItem[] backpack;

	public int heldItemIndex;

	public SavedLoadout()
	{
	}

	public SavedLoadout(BasePlayer player)
	{
		belt = SaveItems(player.inventory.containerBelt);
		wear = SaveItems(player.inventory.containerWear);
		main = SaveItems(player.inventory.containerMain);
		Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
		if (backpackWithInventory != null)
		{
			backpack = SaveItems(backpackWithInventory.contents);
		}
		heldItemIndex = GetSlotIndex(player);
	}

	public SavedLoadout(PlayerInventoryProperties properties)
	{
		belt = SaveItems(properties.belt);
		wear = SaveItems(properties.wear);
		main = SaveItems(properties.main);
		heldItemIndex = 0;
	}

	private static SavedItem[] SaveItems(ItemContainer itemContainer)
	{
		List<SavedItem> list = new List<SavedItem>();
		for (int i = 0; i < itemContainer.capacity; i++)
		{
			Item slot = itemContainer.GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			SavedItem savedItem = default(SavedItem);
			savedItem.id = slot.info.itemid;
			savedItem.amount = slot.amount;
			savedItem.skin = slot.skin;
			savedItem.blueprintTarget = slot.blueprintTarget;
			SavedItem item = savedItem;
			if (slot.contents != null && slot.contents.itemList != null)
			{
				List<int> list2 = new List<int>();
				foreach (Item item2 in slot.contents.itemList)
				{
					list2.Add(item2.info.itemid);
				}
				item.containedItems = list2.ToArray();
			}
			list.Add(item);
		}
		return list.ToArray();
	}

	private static SavedItem[] SaveItems(List<PlayerInventoryProperties.ItemAmountSkinned> items)
	{
		List<SavedItem> list = new List<SavedItem>();
		foreach (PlayerInventoryProperties.ItemAmountSkinned item2 in items)
		{
			SavedItem savedItem = default(SavedItem);
			savedItem.id = item2.itemid;
			savedItem.amount = (int)item2.amount;
			savedItem.skin = item2.skinOverride;
			SavedItem item = savedItem;
			if (item2.blueprint)
			{
				item.blueprintTarget = item.id;
				item.id = ItemManager.blueprintBaseDef.itemid;
			}
			list.Add(item);
		}
		return list.ToArray();
	}

	public void LoadItemsOnTo(BasePlayer player)
	{
		player.inventory.containerMain.Clear();
		player.inventory.containerBelt.Clear();
		player.inventory.containerWear.Clear();
		ItemManager.DoRemoves();
		LoadItems(belt, player.inventory.containerBelt);
		LoadItems(wear, player.inventory.containerWear);
		LoadItems(main, player.inventory.containerMain);
		if (backpack != null && backpack.Length != 0)
		{
			Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
			if (backpackWithInventory != null)
			{
				backpackWithInventory.contents.Clear();
				LoadItems(backpack, backpackWithInventory.contents);
			}
		}
		EquipItemInSlot(player, heldItemIndex);
		player.inventory.SendSnapshot();
		void LoadItems(SavedItem[] items, ItemContainer container)
		{
			foreach (SavedItem item in items)
			{
				player.inventory.GiveItem(LoadItem(item), container);
			}
		}
	}

	private Item LoadItem(SavedItem item)
	{
		Item item2 = ItemManager.CreateByItemID(item.id, item.amount, item.skin);
		if (item.blueprintTarget != 0)
		{
			item2.blueprintTarget = item.blueprintTarget;
		}
		if (item.containedItems != null && item.containedItems.Length != 0)
		{
			int[] containedItems = item.containedItems;
			foreach (int itemID in containedItems)
			{
				item2.contents.AddItem(ItemManager.FindItemDefinition(itemID), 1, 0uL);
			}
		}
		return item2;
	}
}


public struct SavedItem
{
	public int id;

	public int amount;

	public ulong skin;

	public int[] containedItems;

	public int blueprintTarget;
}


[Factory("layer")]
public class Layer : ConsoleSystem
{
}


[Factory("legs")]
public class Legs : ConsoleSystem
{
}


[Factory("lerp")]
public class Lerp : ConsoleSystem
{
}


[Factory("lod")]
public class LOD : ConsoleSystem
{
}


using Facepunch;

public class Manifest
{
	[ClientVar]
	[ServerVar]
	public static object PrintManifest()
	{
		return Application.Manifest;
	}

	[ClientVar]
	[ServerVar]
	public static object PrintManifestRaw()
	{
		return Manifest.Contents;
	}
}


using System;
using System.IO;
using Unity.Profiling.Memory;

[Factory("memsnap")]
public class MemSnap : ConsoleSystem
{
	private static string NeedProfileFolder()
	{
		string path = "profile";
		if (!Directory.Exists(path))
		{
			return Directory.CreateDirectory(path).FullName;
		}
		return new DirectoryInfo(path).FullName;
	}

	[ClientVar]
	[ServerVar]
	public static void managed(Arg arg)
	{
		MemoryProfiler.TakeSnapshot(NeedProfileFolder() + "/memdump-" + DateTime.Now.ToString("MM-dd-yyyy-h-mm-ss") + ".snap", (Action<string, bool>)null, (CaptureFlags)1);
	}

	[ClientVar]
	[ServerVar]
	public static void native(Arg arg)
	{
		MemoryProfiler.TakeSnapshot(NeedProfileFolder() + "/memdump-" + DateTime.Now.ToString("MM-dd-yyyy-h-mm-ss") + ".snap", (Action<string, bool>)null, (CaptureFlags)2);
	}

	[ServerVar]
	[ClientVar]
	public static void full(Arg arg)
	{
		MemoryProfiler.TakeSnapshot(NeedProfileFolder() + "/memdump-" + DateTime.Now.ToString("MM-dd-yyyy-h-mm-ss") + ".snap", (Action<string, bool>)null, (CaptureFlags)31);
	}
}


[Factory("mesh")]
public class Mesh : ConsoleSystem
{
}


using System.Text;
using UnityEngine;

[Factory("music")]
public class Music : ConsoleSystem
{
	[ClientVar]
	public static bool enabled = true;

	[ClientVar]
	public static int songGapMin = 240;

	[ClientVar]
	public static int songGapMax = 480;

	[ClientVar]
	public static void info(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		if ((Object)(object)SingletonComponent<MusicManager>.Instance == (Object)null)
		{
			stringBuilder.Append("No music manager was found");
		}
		else
		{
			stringBuilder.Append("Current music info: ");
			stringBuilder.AppendLine();
			stringBuilder.Append("  theme: " + (object)SingletonComponent<MusicManager>.Instance.currentTheme);
			stringBuilder.AppendLine();
			stringBuilder.Append("  intensity: " + SingletonComponent<MusicManager>.Instance.intensity);
			stringBuilder.AppendLine();
			stringBuilder.Append("  next music: " + SingletonComponent<MusicManager>.Instance.nextMusic);
			stringBuilder.AppendLine();
			stringBuilder.Append("  current time: " + Time.time);
			stringBuilder.AppendLine();
		}
		arg.ReplyWith(stringBuilder.ToString());
	}
}


[Factory("net")]
public class Net : ConsoleSystem
{
	[ServerVar]
	public static bool visdebug = false;

	[ClientVar]
	public static bool debug = false;

	[ServerVar]
	public static int visibilityRadiusFarOverride = -1;

	[ServerVar]
	public static int visibilityRadiusNearOverride = -1;

	[ServerVar(Name = "global_networked_bases")]
	public static bool globalNetworkedBases = true;

	[ServerVar(Help = "Toggle printing time taken to send all global entities to client when they connect")]
	public static bool global_network_debug = false;

	[ServerVar(Help = "Toggle checking network group bounds whenever an entity changes its network group")]
	public static bool network_group_debug = false;

	[ServerVar(Help = "(default) true = only broadcast to clients with global networking enabled, false = broadcast to every client regardless")]
	public static bool limit_global_update_broadcast = true;
}


[Factory("netgraph")]
public class Netgraph : ConsoleSystem
{
}


using System;
using Facepunch;
using ProtoBuf.Nexus;
using UnityEngine;

[Factory("nexus")]
public class Nexus : ConsoleSystem
{
	public static readonly Phrase RedirectPhrase = new Phrase("loading.redirect", "Switching servers");

	private const string DefaultEndpoint = "https://api.facepunch.com/api/nexus/";

	[ReplicatedVar(Help = "URL endpoint to use for the Nexus API", Default = "https://api.facepunch.com/api/nexus/")]
	public static string endpoint = "https://api.facepunch.com/api/nexus/";

	[ServerVar(Clientside = true)]
	public static bool logging = true;

	[ServerVar]
	public static string secretKey = "";

	[ServerVar]
	public static string zoneController = "basic";

	[ServerVar(Help = "Time in seconds to allow the server to process nexus messages before re-sending (requires restart)")]
	public static int messageLockDuration = 5;

	[ServerVar(Help = "Maximum amount of time in seconds that transfers should be cached before auto-saving")]
	public static int transferFlushTime = 60;

	[ServerVar(Help = "How far away islands should be spawned, as a factor of the map size")]
	public static float islandSpawnDistance = 1.5f;

	[ServerVar(Help = "Default distance between zones to allow boat travel, if map.contactRadius isn't set in the nexus (uses normalized coordinates)")]
	public static float defaultZoneContactRadius = 0.33f;

	[ServerVar(Help = "Time offset in hours from the nexus clock")]
	public static float timeOffset = 0f;

	[ServerVar(Help = "Multiplier for nexus RPC timeout durations in case we expect different latencies")]
	public static float rpcTimeoutMultiplier = 1f;

	[ServerVar(Help = "Time in seconds to keep players in the loading state before going to sleep")]
	public static float loadingTimeout = 900f;

	[ServerVar(Help = "Time in seconds to wait between server status pings")]
	public static float pingInterval = 30f;

	[ServerVar(Help = "Maximum time in seconds to keep transfer protection enabled on entities")]
	public static float protectionDuration = 300f;

	[ServerVar(Help = "Maximum duration in seconds to batch clan chat messages to send to other servers on the nexus")]
	public static float clanClatBatchDuration = 1f;

	[ServerVar(Help = "Interval in seconds to broadcast the player manifest to other servers on the nexus")]
	public static float playerManifestInterval = 30f;

	[ServerVar(Help = "Scale of the map to render and upload to the nexus")]
	public static float mapImageScale = 0.5f;

	[ServerVar]
	public static void transfer(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
			return;
		}
		string text = arg.GetString(0, "")?.Trim();
		if (string.IsNullOrWhiteSpace(text))
		{
			arg.ReplyWith("Usage: nexus.transfer <target_zone>");
			return;
		}
		if (string.Equals(text, NexusServer.ZoneKey, StringComparison.InvariantCultureIgnoreCase))
		{
			arg.ReplyWith("You're already on the target zone");
			return;
		}
		BasePlayer basePlayer = arg.Connection.player as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Must be run as a player");
		}
		else
		{
			NexusServer.TransferEntity(basePlayer, text, "console", includeFerry: false);
		}
	}

	[ServerVar]
	public static void refreshislands(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
		}
		else
		{
			NexusServer.UpdateIslands();
		}
	}

	[ServerVar]
	public static void ping(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
			return;
		}
		string @string = arg.GetString(0, "");
		if (string.IsNullOrWhiteSpace(@string))
		{
			arg.ReplyWith("Usage: nexus.ping <target_zone>");
		}
		else
		{
			SendPing(arg.Player(), @string);
		}
		static async void SendPing(BasePlayer requester, string to)
		{
			Request val = Pool.Get<Request>();
			val.ping = Pool.Get<PingRequest>();
			float startTime = Time.realtimeSinceStartup;
			try
			{
				await NexusServer.ZoneRpc(to, val);
				float num = Time.realtimeSinceStartup - startTime;
				requester?.ConsoleMessage($"Ping took {num:F3}s");
			}
			catch (Exception arg2)
			{
				requester?.ConsoleMessage($"Failed to ping zone {to}: {arg2}");
			}
		}
	}

	[ServerVar]
	public static void broadcast_ping(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
		}
		else
		{
			SendBroadcastPing(arg.Player());
		}
		static async void SendBroadcastPing(BasePlayer requester)
		{
			Request val = Pool.Get<Request>();
			val.ping = Pool.Get<PingRequest>();
			float startTime = Time.realtimeSinceStartup;
			try
			{
				using NexusRpcResult nexusRpcResult = await NexusServer.BroadcastRpc(val);
				float num = Time.realtimeSinceStartup - startTime;
				string arg2 = string.Join(", ", nexusRpcResult.Responses.Keys);
				requester?.ConsoleMessage($"Broadcast ping took {num:F3}s, response received from zones: {arg2}");
			}
			catch (Exception arg3)
			{
				requester?.ConsoleMessage($"Failed to broadcast ping: {arg3}");
			}
		}
	}

	[ServerVar]
	public static void playeronline(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
			return;
		}
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt == 0L)
		{
			arg.ReplyWith("Usage: nexus.playeronline <steamID64>");
			return;
		}
		bool flag = NexusServer.IsOnline(uInt);
		arg.ReplyWith(flag ? "Online" : "Offline");
	}

	[ServerVar(Help = "Reupload the map image to the nexus. Normally happens automatically at server boot. WARNING: This will lag the server!")]
	public static void uploadmap(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
		}
		else
		{
			NexusServer.UploadMapImage(force: true);
		}
	}
}


[Factory("note")]
public class Note : ConsoleSystem
{
}


[Factory("npc")]
public class NPC_ConVars : ConsoleSystem
{
	[ReplicatedVar]
	public static bool vendor_minicopter_enabled = true;

	[ReplicatedVar]
	public static bool vendor_attack_heli_enabled = true;

	[ReplicatedVar]
	public static bool vendor_scrap_heli_enabled = true;

	[ReplicatedVar]
	public static bool vendor_hab_enabled = true;

	[ReplicatedVar]
	public static bool vendor_rowboat_enabled = true;

	[ReplicatedVar]
	public static bool vendor_rhib_enabled = true;

	[ReplicatedVar]
	public static bool vendor_sub_solo_enabled = true;

	[ReplicatedVar]
	public static bool vendor_sub_duo_enabled = true;
}


[Factory("particle")]
public class Particle : ConsoleSystem
{
}


using UnityEngine;

[Factory("physics")]
public class Physics : ConsoleSystem
{
	[ServerVar(Help = "The collision detection mode that dropped items and corpses should use")]
	public static int droppedmode = 2;

	[ServerVar(Help = "Send effects to clients when physics objects collide")]
	public static bool sendeffects = true;

	[ServerVar]
	public static bool groundwatchdebug = false;

	[ServerVar]
	public static int groundwatchfails = 1;

	[ServerVar]
	public static float groundwatchdelay = 0.1f;

	[ServerVar(Help = "The collision detection mode that server-side ragdolls should use")]
	public static int serverragdollmode = 3;

	private const float baseGravity = -9.81f;

	private static bool _serversideragdolls = false;

	[ServerVar]
	public static float towingmaxlinearaccelfromjoint = 40f;

	[ServerVar]
	public static bool allowplayertempragdoll = true;

	[ServerVar]
	public static bool allowhorsetempragdoll = true;

	[ClientVar]
	[ServerVar]
	public static bool batchsynctransforms = true;

	private static bool _treecollision = true;

	[ServerVar]
	public static float bouncethreshold
	{
		get
		{
			return Physics.bounceThreshold;
		}
		set
		{
			Physics.bounceThreshold = value;
		}
	}

	[ServerVar]
	public static float sleepthreshold
	{
		get
		{
			return Physics.sleepThreshold;
		}
		set
		{
			Physics.sleepThreshold = value;
		}
	}

	[ServerVar(Help = "The default solver iteration count permitted for any rigid bodies (default 7). Must be positive")]
	public static int solveriterationcount
	{
		get
		{
			return Physics.defaultSolverIterations;
		}
		set
		{
			Physics.defaultSolverIterations = value;
		}
	}

	[ReplicatedVar(Help = "Gravity multiplier", Default = "1.0")]
	public static float gravity
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			return Physics.gravity.y / -9.81f;
		}
		set
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			Physics.gravity = new Vector3(0f, value * -9.81f, 0f);
		}
	}

	[ReplicatedVar(Help = "Do ragdoll physics calculations on the server, or use the old client-side system", Saved = true, ShowInAdminUI = true)]
	public static bool serversideragdolls
	{
		get
		{
			return _serversideragdolls;
		}
		set
		{
			_serversideragdolls = value;
			Physics.IgnoreLayerCollision(9, 13, !_serversideragdolls);
			Physics.IgnoreLayerCollision(9, 11, !_serversideragdolls);
			Physics.IgnoreLayerCollision(9, 28, !_serversideragdolls);
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool autosynctransforms
	{
		get
		{
			return Physics.autoSyncTransforms;
		}
		set
		{
			Physics.autoSyncTransforms = value;
		}
	}

	[ReplicatedVar(Help = "Do players and vehicles collide with trees?", Saved = true, ShowInAdminUI = true)]
	public static bool treecollision
	{
		get
		{
			return _treecollision;
		}
		set
		{
			_treecollision = value;
			Physics.IgnoreLayerCollision(15, 30, !_treecollision);
			Physics.IgnoreLayerCollision(12, 30, !_treecollision);
		}
	}

	internal static void ApplyDropped(Rigidbody rigidBody)
	{
		if (droppedmode <= 0)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)0;
		}
		if (droppedmode == 1)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)1;
		}
		if (droppedmode == 2)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)2;
		}
		if (droppedmode >= 3)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)3;
		}
	}
}


using Facepunch.Ping;

[Factory("ping")]
public class Ping : ConsoleSystem
{
	[ServerVar]
	[ClientVar]
	public static int ping_samples
	{
		get
		{
			return PingEstimater.numSamples;
		}
		set
		{
			PingEstimater.numSamples = value;
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool ping_parallel
	{
		get
		{
			return PingEstimater.parallel;
		}
		set
		{
			PingEstimater.parallel = value;
		}
	}

	[ClientVar]
	[ServerVar]
	public static int ping_refresh_interval
	{
		get
		{
			return PingEstimater.refreshIntervalMinutes;
		}
		set
		{
			PingEstimater.refreshIntervalMinutes = value;
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool auto_refresh_region
	{
		get
		{
			return PingEstimater.AutoRefresh;
		}
		set
		{
			PingEstimater.AutoRefresh = value;
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool ping_estimate_logging
	{
		get
		{
			return PingEstimater.logging;
		}
		set
		{
			PingEstimater.logging = value;
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool ping_estimation
	{
		get
		{
			return PingEstimater.enabled;
		}
		set
		{
			PingEstimater.enabled = value;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

[Factory("player")]
public class Player : ConsoleSystem
{
	public const string serverTickRateDefaultString = "16";

	public static int serverTickRate = 16;

	public const int serverTickRateDefault = 16;

	public const int serverTickRateMin = 16;

	public const int serverTickRateMax = 128;

	public static float serverTickInterval = 0.0625f;

	public const string clientTickRateDefaultString = "32";

	public const int clientTickRateDefault = 32;

	public const int clientTickRateMin = 16;

	public const int clientTickRateMax = 128;

	public static EncryptedValue<int> clientTickRate = 32;

	public static EncryptedValue<float> clientTickInterval = 1f / 32f;

	[ClientVar(ClientInfo = true)]
	public static bool InfiniteAmmo = false;

	[ServerVar]
	public static bool keepteaondeath = false;

	[ServerVar]
	public static bool dropbackpackondeath = true;

	[ServerVar]
	public static bool dropbackpackondowned = true;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "Whether the crawling state expires")]
	public static bool woundforever = false;

	[ReplicatedVar(Default = "16")]
	public static int tickrate_sv
	{
		get
		{
			return serverTickRate;
		}
		set
		{
			serverTickRate = Mathf.Clamp(value, 16, 128);
			serverTickInterval = 1f / (float)serverTickRate;
		}
	}

	[ReplicatedVar(Default = "32")]
	public static int tickrate_cl
	{
		get
		{
			return clientTickRate;
		}
		set
		{
			clientTickRate = Mathf.Clamp(value, 16, 128);
			clientTickInterval = 1f / (float)(int)clientTickRate;
		}
	}

	[ClientVar(AllowRunFromServer = true)]
	[ServerUserVar]
	public static void cinematic_play(Arg arg)
	{
		if (!arg.HasArgs(1) || !arg.IsServerside)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			string strCommand = string.Empty;
			if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				strCommand = arg.cmd.FullName + " " + arg.FullString + " " + basePlayer.UserIDString;
			}
			else if (Server.cinematic)
			{
				strCommand = arg.cmd.FullName + " " + arg.GetString(0, "") + " " + basePlayer.UserIDString;
			}
			if (Server.cinematic)
			{
				ConsoleNetwork.BroadcastToAllClients(strCommand);
			}
			else if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				ConsoleNetwork.SendClientCommand(arg.Connection, strCommand);
			}
		}
	}

	[ServerUserVar]
	[ClientVar(AllowRunFromServer = true)]
	public static void cinematic_stop(Arg arg)
	{
		if (!arg.IsServerside)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			string strCommand = string.Empty;
			if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				strCommand = arg.cmd.FullName + " " + arg.FullString + " " + basePlayer.UserIDString;
			}
			else if (Server.cinematic)
			{
				strCommand = arg.cmd.FullName + " " + basePlayer.UserIDString;
			}
			if (Server.cinematic)
			{
				ConsoleNetwork.BroadcastToAllClients(strCommand);
			}
			else if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				ConsoleNetwork.SendClientCommand(arg.Connection, strCommand);
			}
		}
	}

	[ServerUserVar]
	public static void cinematic_gesture(Arg arg)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (Server.cinematic)
		{
			string @string = arg.GetString(0, "");
			BasePlayer basePlayer = arg.GetPlayer(1);
			if ((Object)(object)basePlayer == (Object)null)
			{
				basePlayer = arg.Player();
			}
			basePlayer.UpdateActiveItem(default(ItemId));
			basePlayer.SignalBroadcast(BaseEntity.Signal.Gesture, @string);
		}
	}

	[ServerUserVar]
	public static void copyrotation(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic)
		{
			uint uInt = arg.GetUInt(0, 0u);
			BasePlayer basePlayer2 = BasePlayer.FindByID(uInt);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				basePlayer2 = BasePlayer.FindBot(uInt);
			}
			if ((Object)(object)basePlayer2 != (Object)null)
			{
				basePlayer2.CopyRotation(basePlayer);
				Debug.Log((object)("Copied rotation of " + basePlayer2.UserIDString));
			}
		}
	}

	[ServerUserVar]
	public static void abandonmission(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.HasActiveMission())
		{
			basePlayer.AbandonActiveMission();
		}
	}

	[ServerUserVar]
	public static void mount(Arg arg)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		uint uInt = arg.GetUInt(0, 0u);
		BasePlayer basePlayer2 = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer2 == (Object)null)
		{
			basePlayer2 = BasePlayer.FindBot(uInt);
		}
		RaycastHit hit = default(RaycastHit);
		if (!Object.op_Implicit((Object)(object)basePlayer2) || !Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), ref hit, 5f, 10496, (QueryTriggerInteraction)1))
		{
			return;
		}
		BaseEntity entity = hit.GetEntity();
		if (!Object.op_Implicit((Object)(object)entity))
		{
			return;
		}
		BaseMountable baseMountable = ((Component)entity).GetComponent<BaseMountable>();
		if (!Object.op_Implicit((Object)(object)baseMountable))
		{
			BaseVehicle baseVehicle = ((Component)entity).GetComponentInParent<BaseVehicle>();
			if (Object.op_Implicit((Object)(object)baseVehicle))
			{
				if (!baseVehicle.isServer)
				{
					baseVehicle = BaseNetworkable.serverEntities.Find(baseVehicle.net.ID) as BaseVehicle;
				}
				baseVehicle.AttemptMount(basePlayer2);
				return;
			}
		}
		if (Object.op_Implicit((Object)(object)baseMountable) && !baseMountable.isServer)
		{
			baseMountable = BaseNetworkable.serverEntities.Find(baseMountable.net.ID) as BaseMountable;
		}
		if (Object.op_Implicit((Object)(object)baseMountable))
		{
			baseMountable.AttemptMount(basePlayer2);
		}
	}

	[ServerVar]
	public static void gotosleep(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		uint uInt = arg.GetUInt(0, 0u);
		BasePlayer basePlayer2 = BasePlayer.FindSleeping(uInt.ToString());
		if (!Object.op_Implicit((Object)(object)basePlayer2))
		{
			basePlayer2 = BasePlayer.FindBotClosestMatch(uInt.ToString());
			if (basePlayer2.IsSleeping())
			{
				basePlayer2 = null;
			}
		}
		if (Object.op_Implicit((Object)(object)basePlayer2))
		{
			basePlayer2.StartSleeping();
		}
	}

	[ServerVar(Help = "optional param {player}", ClientAdmin = true)]
	public static void ragdoll(Arg arg)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic)
		{
			BasePlayer basePlayer2 = arg.GetPlayerOrSleeperOrBot(0) ?? basePlayer;
			if (!((Object)(object)basePlayer2 == (Object)null))
			{
				basePlayer2.Ragdoll();
			}
		}
	}

	[ServerVar(Help = "Ragdolls a player you're looking at", ClientAdmin = true)]
	public static void ragdollother(Arg arg)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic) && GamePhysics.Trace(basePlayer.eyes.HeadRay(), 0.5f, out var hitInfo, 5f, 1218652417, (QueryTriggerInteraction)0, basePlayer) && hitInfo.GetEntity() is BasePlayer { isClient: false } basePlayer2)
		{
			basePlayer2.Ragdoll();
		}
	}

	[ServerVar(Help = "ragdolls")]
	public static void ragdollall(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Ragdoll();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.bots.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Ragdoll();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "ragdolls everyone except player")]
	public static void ragdollallbutme(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)(object)basePlayer))
				{
					current.Ragdoll();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.bots.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Ragdoll();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar]
	public static void dismount(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic)
		{
			uint uInt = arg.GetUInt(0, 0u);
			BasePlayer basePlayer2 = BasePlayer.FindByID(uInt);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				basePlayer2 = BasePlayer.FindBot(uInt);
			}
			if (Object.op_Implicit((Object)(object)basePlayer2) && Object.op_Implicit((Object)(object)basePlayer2) && basePlayer2.isMounted)
			{
				basePlayer2.GetMounted().DismountPlayer(basePlayer2);
			}
		}
	}

	[ServerVar]
	public static void swapseat(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		uint uInt = arg.GetUInt(0, 0u);
		BasePlayer basePlayer2 = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer2 == (Object)null)
		{
			basePlayer2 = BasePlayer.FindBot(uInt);
		}
		if (Object.op_Implicit((Object)(object)basePlayer2))
		{
			int @int = arg.GetInt(1, 0);
			if (Object.op_Implicit((Object)(object)basePlayer2) && basePlayer2.isMounted && Object.op_Implicit((Object)(object)basePlayer2.GetMounted().VehicleParent()))
			{
				basePlayer2.GetMounted().VehicleParent().SwapSeats(basePlayer2, @int);
			}
		}
	}

	[ServerVar]
	public static void wakeup(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic)
		{
			BasePlayer basePlayer2 = BasePlayer.FindSleeping(arg.GetUInt(0, 0u).ToString());
			if (Object.op_Implicit((Object)(object)basePlayer2))
			{
				basePlayer2.EndSleeping();
			}
		}
	}

	[ServerVar]
	public static void wakeupall(Arg arg)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Enumerator<BasePlayer> enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (BasePlayer item in list)
		{
			item.EndSleeping();
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar]
	public static void printstats(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsAlive:F1}s alive");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsSleeping:F1}s sleeping");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsSwimming:F1}s swimming");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsInBase:F1}s in base");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsWilderness:F1}s in wilderness");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsInMonument:F1}s in monuments");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsFlying:F1}s flying");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsBoating:F1}s boating");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsDriving:F1}s driving");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.metersRun:F1}m run");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.metersWalked:F1}m walked");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.totalDamageTaken:F1} damage taken");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.totalHealing:F1} damage healed");
		stringBuilder.AppendLine("===");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.killedPlayers} other players killed");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.killedScientists} scientists killed");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.killedAnimals} animals killed");
		stringBuilder.AppendLine("===");
		stringBuilder.AppendLine("Weapon stats:");
		if (basePlayer.lifeStory.weaponStats != null)
		{
			foreach (WeaponStats weaponStat in basePlayer.lifeStory.weaponStats)
			{
				float num = (float)weaponStat.shotsHit / (float)weaponStat.shotsFired;
				num *= 100f;
				stringBuilder.AppendLine($"{weaponStat.weaponName} - shots fired: {weaponStat.shotsFired} shots hit: {weaponStat.shotsHit} accuracy: {num:F1}%");
			}
		}
		stringBuilder.AppendLine("===");
		stringBuilder.AppendLine("Misc stats:");
		if (basePlayer.lifeStory.genericStats != null)
		{
			foreach (GenericStat genericStat in basePlayer.lifeStory.genericStats)
			{
				stringBuilder.AppendLine($"{genericStat.key} = {genericStat.value}");
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void printpresence(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		bool flag = (basePlayer.currentTimeCategory & 1) != 0;
		bool flag2 = (basePlayer.currentTimeCategory & 4) != 0;
		bool flag3 = (basePlayer.currentTimeCategory & 2) != 0;
		bool flag4 = (basePlayer.currentTimeCategory & 0x20) != 0;
		bool flag5 = (basePlayer.currentTimeCategory & 0x10) != 0;
		bool flag6 = (basePlayer.currentTimeCategory & 8) != 0;
		arg.ReplyWith($"Wilderness:{flag} Base:{flag2} Monument:{flag3} Swimming: {flag4} Boating: {flag5} Flying: {flag6}");
	}

	[ServerVar(Help = "Resets the PlayerState of the given player")]
	public static void resetstate(Arg args)
	{
		BasePlayer playerOrSleeper = args.GetPlayerOrSleeper(0);
		if ((Object)(object)playerOrSleeper == (Object)null)
		{
			args.ReplyWith("Player not found");
			return;
		}
		playerOrSleeper.ResetPlayerState();
		args.ReplyWith("Player state reset");
	}

	[ServerVar(ServerAdmin = true)]
	public static void fillwater(Arg arg)
	{
		bool flag = arg.GetString(0, "").ToLower() == "salt";
		bool num = arg.GetString(0, "").ToLower() == "rads";
		BasePlayer basePlayer = arg.Player();
		ItemDefinition itemDefinition = (flag ? WaterTypes.SaltWaterItemDef : WaterTypes.WaterItemDef);
		itemDefinition = (num ? WaterTypes.RadioactiveWaterItemDef : itemDefinition);
		ItemModContainer itemModContainer = default(ItemModContainer);
		for (int i = 0; i < PlayerBelt.MaxBeltSlots; i++)
		{
			Item itemInSlot = basePlayer.Belt.GetItemInSlot(i);
			if (itemInSlot != null && itemInSlot.GetHeldEntity() is BaseLiquidVessel { hasLid: not false } baseLiquidVessel)
			{
				int amount = 999;
				if (((Component)baseLiquidVessel.GetItem().info).TryGetComponent<ItemModContainer>(ref itemModContainer))
				{
					amount = itemModContainer.maxStackSize;
				}
				baseLiquidVessel.AddLiquid(itemDefinition, amount);
			}
		}
	}

	[ServerVar(ServerAdmin = true)]
	public static void reloadweapons(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		for (int i = 0; i < PlayerBelt.MaxBeltSlots; i++)
		{
			Item itemInSlot = basePlayer.Belt.GetItemInSlot(i);
			if (itemInSlot == null)
			{
				continue;
			}
			if (itemInSlot.GetHeldEntity() is BaseProjectile baseProjectile)
			{
				if (baseProjectile.primaryMagazine != null)
				{
					baseProjectile.SetAmmoCount(baseProjectile.primaryMagazine.capacity);
					baseProjectile.SendNetworkUpdateImmediate();
				}
			}
			else if (itemInSlot.GetHeldEntity() is FlameThrower flameThrower)
			{
				flameThrower.ammo = flameThrower.maxAmmo;
				flameThrower.SendNetworkUpdateImmediate();
			}
			else if (itemInSlot.GetHeldEntity() is LiquidWeapon liquidWeapon)
			{
				liquidWeapon.AddLiquid(WaterTypes.WaterItemDef, 999);
			}
		}
	}

	[ServerVar]
	public static void createskull(Arg arg)
	{
		string text = arg.GetString(0, "");
		BasePlayer basePlayer = arg.Player();
		if (string.IsNullOrEmpty(text))
		{
			text = RandomUsernames.Get(Random.Range(0, 1000));
		}
		Item item = ItemManager.Create(ItemManager.FindItemDefinition("skull.human"), 1, 0uL);
		item.name = HumanBodyResourceDispenser.CreateSkullName(text);
		item.streamerName = item.name;
		basePlayer.inventory.GiveItem(item);
	}

	[ServerVar]
	public static string createTrophy(Arg arg)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		Entity.EntitySpawnRequest spawnEntityFromName = Entity.GetSpawnEntityFromName(arg.GetString(0, ""));
		if (!spawnEntityFromName.Valid)
		{
			return spawnEntityFromName.Error;
		}
		BaseCombatEntity baseCombatEntity = default(BaseCombatEntity);
		if (GameManager.server.FindPrefab(spawnEntityFromName.PrefabName).TryGetComponent<BaseCombatEntity>(ref baseCombatEntity))
		{
			Item item = ItemManager.CreateByName("head.bag", 1, 0uL);
			HeadEntity associatedEntity = ItemModAssociatedEntity<HeadEntity>.GetAssociatedEntity(item);
			if ((Object)(object)associatedEntity != (Object)null)
			{
				associatedEntity.SetupSourceId(baseCombatEntity.prefabID);
			}
			if (basePlayer.inventory.GiveItem(item))
			{
				basePlayer.Command("note.inv", item.info.itemid, 1);
			}
			else
			{
				item.DropAndTossUpwards(basePlayer.eyes.position);
			}
		}
		return "Created head";
	}

	[ServerVar]
	public static void trigger_wildlife_trap(Arg arg)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		if (GamePhysics.Trace(basePlayer.eyes.HeadRay(), 0.5f, out var hitInfo, 5f, 1218652417, (QueryTriggerInteraction)0, basePlayer))
		{
			WildlifeTrap wildlifeTrap = hitInfo.GetEntity() as WildlifeTrap;
			if (wildlifeTrap != null)
			{
				if (wildlifeTrap.isClient)
				{
					wildlifeTrap = BaseNetworkable.serverEntities.Find(wildlifeTrap.net.ID) as WildlifeTrap;
				}
				if (!wildlifeTrap.IsTrapActive())
				{
					arg.ReplyWith("Trap is not loaded or active");
					return;
				}
				wildlifeTrap.TrapThink();
				arg.ReplyWith("Trap think triggered");
				return;
			}
		}
		arg.ReplyWith("Not looking at a trap");
	}

	[ServerVar]
	public static void gesture_radius(Arg arg)
	{
		gesture_radius(arg, includeMe: true);
	}

	[ServerVar]
	public static void gesture_radius_notme(Arg arg)
	{
		gesture_radius(arg, includeMe: false);
	}

	public static void gesture_radius(Arg arg, bool includeMe)
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		List<string> list = Pool.Get<List<string>>();
		for (int i = 0; i < 5; i++)
		{
			if (!string.IsNullOrEmpty(arg.GetString(i + 1, "")))
			{
				list.Add(arg.GetString(i + 1, ""));
			}
		}
		if (list.Count == 0)
		{
			arg.ReplyWith("No gestures provided. eg. player.gesture_radius 10f cabbagepatch raiseroof");
			return;
		}
		List<BasePlayer> list2 = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)basePlayer).transform.position, @float, list2, 131072, (QueryTriggerInteraction)2);
		foreach (BasePlayer item in list2)
		{
			if (includeMe || (!((Object)(object)item == (Object)(object)basePlayer) && !item.isClient))
			{
				GestureConfig toPlay = GestureCollection.Instance.StringToGesture(list[Random.Range(0, list.Count)]);
				item.Server_StartGesture(toPlay, BasePlayer.GestureStartSource.Player, bypassOwnershipCheck: true);
			}
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list2);
	}

	[ServerVar]
	public static void stopgesture_radius(Arg arg)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)basePlayer).transform.position, @float, list, 131072, (QueryTriggerInteraction)2);
		foreach (BasePlayer item in list)
		{
			item.Server_CancelGesture();
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar]
	public static void markhostile(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.MarkHostileFor();
		}
	}
}


public class PlayerCull : ConsoleSystem
{
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using Facepunch;
using Facepunch.Extend;
using Network;
using UnityEngine;

[Factory("pool")]
public class Pool : ConsoleSystem
{
	[ServerVar]
	[ClientVar]
	public static int mode = 2;

	[ClientVar]
	[ServerVar]
	public static bool prewarm = true;

	[ServerVar]
	[ClientVar]
	public static bool enabled = true;

	[ServerVar]
	[ClientVar]
	public static bool debug = false;

	[ServerVar]
	[ClientVar]
	public static void print_memory(Arg arg)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Expected O, but got Unknown
		if (Pool.Directory.Count == 0)
		{
			arg.ReplyWith("Memory pool is empty.");
			return;
		}
		bool flag = arg.HasArg("--raw", true);
		bool flag2 = arg.HasArg("--json", true);
		string @string = arg.GetString(0, (string)null);
		TextTable val = new TextTable();
		val.AddColumn("type");
		val.AddColumn("capacity");
		val.AddColumn("pooled");
		val.AddColumn("active");
		val.AddColumn("max");
		val.AddColumn("hits");
		val.AddColumn("misses");
		val.AddColumn("spills");
		foreach (KeyValuePair<Type, IPoolCollection> item in Pool.Directory.OrderByDescending((KeyValuePair<Type, IPoolCollection> x) => x.Value.ItemsCreated))
		{
			Type key = item.Key;
			IPoolCollection value = item.Value;
			if (@string == null || key.ToString().Contains(@string))
			{
				val.AddRow(new string[8]
				{
					key.ToString().Replace("System.Collections.Generic.", ""),
					flag ? value.ItemsCapacity.ToString() : NumberExtensions.FormatNumberShort(value.ItemsCapacity),
					flag ? value.ItemsInStack.ToString() : NumberExtensions.FormatNumberShort(value.ItemsInStack),
					flag ? value.ItemsInUse.ToString() : NumberExtensions.FormatNumberShort(value.ItemsInUse),
					flag ? value.MaxItemsInUse.ToString() : NumberExtensions.FormatNumberShort(value.MaxItemsInUse),
					flag ? value.ItemsTaken.ToString() : NumberExtensions.FormatNumberShort(value.ItemsTaken),
					flag ? value.ItemsCreated.ToString() : NumberExtensions.FormatNumberShort(value.ItemsCreated),
					flag ? value.ItemsSpilled.ToString() : NumberExtensions.FormatNumberShort(value.ItemsSpilled)
				});
			}
		}
		arg.ReplyWith(flag2 ? val.ToJson(true) : ((object)val).ToString());
	}

	[ClientVar]
	[ServerVar]
	public static void reset_max_pool_counter(Arg arg)
	{
		if (Pool.Directory.Count == 0)
		{
			arg.ReplyWith("Memory pool is empty.");
			return;
		}
		foreach (IPoolCollection value in Pool.Directory.Values)
		{
			value.ResetMaxUsageCounter();
		}
		arg.ReplyWith("Reset max item counter of pool");
	}

	[ServerVar]
	[ClientVar]
	public static void print_arraypool(Arg arg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		ArrayPool<byte> arrayPool = BaseNetwork.ArrayPool;
		ConcurrentQueue<byte[]>[] buffer = arrayPool.GetBuffer();
		TextTable val = new TextTable();
		val.AddColumn("index");
		val.AddColumn("size");
		val.AddColumn("bytes");
		val.AddColumn("count");
		val.AddColumn("memory");
		for (int i = 0; i < buffer.Length; i++)
		{
			int num = arrayPool.IndexToSize(i);
			int count = buffer[i].Count;
			int num2 = num * count;
			val.AddRow(new string[5]
			{
				i.ToString(),
				num.ToString(),
				NumberExtensions.FormatBytes<int>(num, false),
				count.ToString(),
				NumberExtensions.FormatBytes<int>(num2, false)
			});
		}
		arg.ReplyWith(arg.HasArg("--json", false) ? val.ToJson(true) : ((object)val).ToString());
	}

	[ClientVar]
	[ServerVar]
	public static void print_prefabs(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown
		PrefabPoolCollection pool = GameManager.server.pool;
		if (pool.storage.Count == 0)
		{
			arg.ReplyWith("Prefab pool is empty.");
			return;
		}
		string @string = arg.GetString(0, string.Empty);
		TextTable val = new TextTable();
		val.AddColumn("id");
		val.AddColumn("name");
		val.AddColumn("missed");
		val.AddColumn("count");
		val.AddColumn("target");
		val.AddColumn("added");
		val.AddColumn("removed");
		foreach (PrefabPool item in pool.storage.Values.OrderByDescending((PrefabPool x) => x.Missed))
		{
			string text = StringPool.Get(item.PrefabName).ToString();
			string prefabName = item.PrefabName;
			string text2 = item.Count.ToString();
			if (string.IsNullOrEmpty(@string) || StringEx.Contains(prefabName, @string, CompareOptions.IgnoreCase))
			{
				val.AddRow(new string[7]
				{
					text,
					Path.GetFileNameWithoutExtension(prefabName),
					text2,
					item.TargetCapacity.ToString(),
					item.Missed.ToString(),
					item.Pushed.ToString(),
					item.Popped.ToString()
				});
			}
		}
		arg.ReplyWith(arg.HasArg("--json", false) ? val.ToJson(true) : ((object)val).ToString());
	}

	[ServerVar]
	[ClientVar]
	public static void print_assets(Arg arg)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Expected O, but got Unknown
		if (AssetPool.storage.Count == 0)
		{
			arg.ReplyWith("Asset pool is empty.");
			return;
		}
		string @string = arg.GetString(0, string.Empty);
		TextTable val = new TextTable();
		val.AddColumn("type");
		val.AddColumn("allocated");
		val.AddColumn("available");
		foreach (KeyValuePair<Type, Pool> item in AssetPool.storage)
		{
			string text = item.Key.ToString();
			string text2 = item.Value.allocated.ToString();
			string text3 = item.Value.available.ToString();
			if (string.IsNullOrEmpty(@string) || StringEx.Contains(text, @string, CompareOptions.IgnoreCase))
			{
				val.AddRow(new string[3] { text, text2, text3 });
			}
		}
		arg.ReplyWith(arg.HasArg("--json", false) ? val.ToJson(true) : ((object)val).ToString());
	}

	[ClientVar]
	[ServerVar]
	public static void clear_memory(Arg arg)
	{
		Pool.Clear(arg.GetString(0, string.Empty));
	}

	[ClientVar]
	[ServerVar]
	public static void clear_prefabs(Arg arg)
	{
		string @string = arg.GetString(0, string.Empty);
		GameManager.server.pool.Clear(@string);
	}

	[ClientVar]
	[ServerVar]
	public static void clear_assets(Arg arg)
	{
		AssetPool.Clear(arg.GetString(0, string.Empty));
	}

	[ServerVar]
	[ClientVar]
	public static void export_prefabs(Arg arg)
	{
		PrefabPoolCollection pool = GameManager.server.pool;
		if (pool.storage.Count == 0)
		{
			arg.ReplyWith("Prefab pool is empty.");
			return;
		}
		string @string = arg.GetString(0, string.Empty);
		StringBuilder stringBuilder = new StringBuilder();
		foreach (KeyValuePair<uint, PrefabPool> item in pool.storage)
		{
			string arg2 = item.Key.ToString();
			string text = StringPool.Get(item.Key);
			string arg3 = item.Value.Count.ToString();
			if (string.IsNullOrEmpty(@string) || StringEx.Contains(text, @string, CompareOptions.IgnoreCase))
			{
				stringBuilder.AppendLine($"{arg2},{Path.GetFileNameWithoutExtension(text)},{arg3}");
			}
		}
		File.WriteAllText("prefabs.csv", stringBuilder.ToString());
	}

	[ServerVar]
	[ClientVar]
	public static void fill_prefabs(Arg arg)
	{
		string @string = arg.GetString(0, string.Empty);
		int @int = arg.GetInt(1, 0);
		PrefabPoolWarmup.Run(@string, @int);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using ConVar;
using Facepunch.Extend;
using UnityEngine;

[Factory("profile")]
public class Profile : ConsoleSystem
{
	private static Action delayedTakeSnapshot;

	private static bool exportDone = true;

	private const string PerfSnapshotHelp = "profile.perfsnapshot [delay=15, int] [name='Profile', str, no extension, max 32chars] [frames=10, int, max 10] [debug=false, dumps a binary snapshot as well]\nWill produce a JSON perf snapshot that can be viewed in Perfetto or similar tools";

	private static void NeedProfileFolder()
	{
		if (!Directory.Exists("profile"))
		{
			Directory.CreateDirectory("profile");
		}
	}

	[ClientVar]
	[ServerVar]
	public static void start(Arg arg)
	{
	}

	[ServerVar]
	[ClientVar]
	public static void stop(Arg arg)
	{
	}

	[ServerVar]
	[ClientVar]
	public static void flush_analytics(Arg arg)
	{
	}

	[ServerVar(Help = "profile.perfsnapshot [delay=15, int] [name='Profile', str, no extension, max 32chars] [frames=10, int, max 10] [debug=false, dumps a binary snapshot as well]\nWill produce a JSON perf snapshot that can be viewed in Perfetto or similar tools")]
	public static void PerfSnapshot(Arg arg)
	{
		if (!ServerProfiler.IsEnabled())
		{
			arg.ReplyWith("ServerProfiler is disabled");
			return;
		}
		if (!exportDone)
		{
			arg.ReplyWith("Already taking snapshot!");
			return;
		}
		int delay = arg.GetInt(0, 15);
		string name = StringExtensions.Truncate(arg.GetString(1, "Profile"), 32, (string)null);
		int frames = arg.GetInt(2, 4);
		bool generateBinary = arg.GetBool(3, false);
		if (delay == 0)
		{
			Chat.Broadcast("Server taking a perf snapshot", "SERVER", "#eee", 0uL);
			ServerProfiler.RecordNextFrames(frames, delegate(IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
			{
				Chat.Broadcast("Snapshot taken", "SERVER", "#eee", 0uL);
				Task.Run(delegate
				{
					if (generateBinary)
					{
						ProfileExporter.Binary.Export(name, profiles);
					}
					ProfileExporter.JSON.Export(name, profiles, memState);
					ServerProfiler.ReleaseResources();
					exportDone = true;
				});
			});
			return;
		}
		Chat.Broadcast($"Server will be taking a perf snapshot, expect stutters in {delay} seconds", "SERVER", "#eee", 0uL);
		delayedTakeSnapshot = delegate
		{
			delay--;
			if (delay > 10 && delay % 5 == 0)
			{
				Chat.Broadcast($"Server will be taking a perf snapshot, expect stutters in {delay} seconds", "SERVER", "#eee", 0uL);
			}
			else if (delay > 0 && delay <= 10)
			{
				Chat.Broadcast($"{delay}...", "SERVER", "#eee", 0uL);
			}
			if (delay == 0)
			{
				ServerProfiler.RecordNextFrames(frames, delegate(IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
				{
					Chat.Broadcast("Snapshot taken", "SERVER", "#eee", 0uL);
					Task.Run(delegate
					{
						if (generateBinary)
						{
							ProfileExporter.Binary.Export(name, profiles);
						}
						ProfileExporter.JSON.Export(name, profiles, memState);
						ServerProfiler.ReleaseResources();
						exportDone = true;
					});
				});
				InvokeHandler.CancelInvoke((Behaviour)(object)SingletonComponent<InvokeHandler>.Instance, delayedTakeSnapshot);
				delayedTakeSnapshot = null;
			}
		};
		InvokeHandler.InvokeRepeating((Behaviour)(object)SingletonComponent<InvokeHandler>.Instance, delayedTakeSnapshot, 0f, 1f);
	}
}


[Factory("reflection")]
public class Reflection : ConsoleSystem
{
}


using System.Collections.Generic;
using System.Linq;
using System.Text;
using ProtoBuf;

[Factory("render")]
public class Render : ConsoleSystem
{
	public static bool use_normal_rendering = false;

	[ClientVar(Saved = true, Help = "0 = off, 1 = on (must restart client for changes to take effect)")]
	public static int instanced_rendering = 0;

	[ClientVar(ClientAdmin = true, Help = "Developer command to toggle instanced rendering at runtime to measure performance impact")]
	public static bool instanced_toggle_all = true;

	[ClientVar(ClientAdmin = true, Help = "Toggle rendering of cliffs on / off")]
	public static bool instanced_toggle_cliffs = true;

	[ClientVar(ClientAdmin = true, Help = "Toggle rendering of buildings on / off")]
	public static bool instanced_toggle_buildings = true;

	[ClientVar(ClientAdmin = true, Help = "Toggle rendering of uncategorized meshes on / off")]
	public static bool instanced_toggle_other = true;

	[ClientVar(ClientAdmin = true, Help = "Allow unity to batch together multiple draw calls")]
	public static bool multidraw = true;

	[ClientVar(ClientAdmin = true, Help = "0 = CPU, 1 = GPU")]
	public static int upload_multidraw_meshes_mode = 0;

	[ClientVar(ClientAdmin = true)]
	public static bool render_shadows = true;

	[ClientVar(Help = "Whether to call ComputeBuffer.SetData immediately or at the end of the frame")]
	public static bool computebuffer_setdata_immediate = true;

	[ClientVar(ClientAdmin = true, Help = "Set the amount of instanced renderers to show for debugging")]
	public static int max_renderers = 0;

	[ClientVar(Saved = true, Help = "Max distance for instanced rendering, can be higher than normal render distance")]
	public static float instancing_render_distance = 1000f;

	public static bool IsInstancingDisabled => true;

	public static bool IsInstancingEnabled => !IsInstancingDisabled;

	[ClientVar(Name = "show_building_blocked", Saved = true)]
	public static bool show_building_blocked_client { get; set; } = true;

	[ClientVar(Name = "building_blocked_preview_distance", Help = "Distance from the border of building blocked to show the red preview")]
	public static float building_blocked_preview_distance { get; set; } = 100f;

	[ReplicatedVar]
	public static bool show_building_blocked_server { get; set; } = true;

	public static bool IsMultidrawEnabled => multidraw;

	[ClientVar(Name = "print_tree_counts", ClientAdmin = true, Help = "Print off count of trees to ensure server sent them all")]
	[ServerVar]
	public static void tree_entities(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Server Trees: {TreeManager.server.GetTreeCount()}");
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ClientVar(Name = "print_global_entities", ClientAdmin = true, Help = "Print off count of global building entities on the client")]
	[ServerVar(Name = "print_global_entities", Help = "Print off count of global building entities on the server")]
	public static void print_global_entities(Arg arg)
	{
		if (IsInstancingDisabled)
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("SERVER ENTITIES:");
		Dictionary<uint, int> dictionary = new Dictionary<uint, int>();
		foreach (GlobalEntityData value2 in GlobalNetworkHandler.server.serverData.Values)
		{
			dictionary.TryGetValue(value2.prefabId, out var value);
			dictionary[value2.prefabId] = value + 1;
		}
		KeyValuePair<uint, int>[] array = dictionary.OrderByDescending((KeyValuePair<uint, int> x) => x.Value).ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			KeyValuePair<uint, int> keyValuePair = array[i];
			stringBuilder.AppendLine($"{StringPool.Get(keyValuePair.Key)} - {keyValuePair.Value}");
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	private static void global_entities_client(StringBuilder builder)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(Name = "print_instanced_debug", Help = "Print off array size and memory usage to ensure no memory leaks & debug rendering system")]
	public static void instanced_memory_usage(Arg arg)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(ClientAdmin = true, Help = "Spawn (default 50k) prefabs spread across the map to quickly test instanced rendering system in isolation")]
	public static void test_instancing_culling(Arg arg)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(Name = "print_instanced_renderers", ClientAdmin = true, Help = "Print off number of each mesh inside instanced rendering system (including outside of render range)")]
	public static void instanced_renderers_debug(Arg arg)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(Name = "print_instanced_cell", ClientAdmin = true, Help = "Print number of meshes inside a single grid")]
	public static void print_instanced_grid(Arg arg)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(Name = "expand_instancing", ClientAdmin = true)]
	public static void expand_instancing(Arg arg)
	{
		_ = IsInstancingDisabled;
	}
}


using Facepunch;
using UnityEngine;

[Factory("reports")]
public class reports : ConsoleSystem
{
	[ClientVar(Default = "600")]
	[ServerVar(Default = "600")]
	public static int ExceptionReportMaxLength
	{
		get
		{
			return ExceptionReporter.ReportMessageMaxLength;
		}
		set
		{
			ExceptionReporter.ReportMessageMaxLength = Mathf.Max(value, 250);
		}
	}
}


[Factory("sentry")]
public class Sentry : ConsoleSystem
{
	[ServerVar(Help = "target everyone regardless of authorization")]
	public static bool targetall = false;

	[ServerVar(Help = "how long until something is considered hostile after it attacked")]
	public static float hostileduration = 120f;

	[ReplicatedVar(Help = "radius to check for other turrets")]
	public static float interferenceradius = 40f;

	[ReplicatedVar(Help = "max interference from other turrets")]
	public static int maxinterference = 12;

	[ServerVar(Help = "Prevents auto turrets getting added more than once to the IO queue")]
	public static bool debugPreventDuplicates = true;
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using Epic.OnlineServices.Logging;
using Epic.OnlineServices.Reports;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Rust;
using Network;
using Rust;
using UnityEngine;

[Factory("server")]
public class Server : ConsoleSystem
{
	[ServerVar]
	public static string ip = "";

	[ServerVar]
	public static int port = 28015;

	[ServerVar]
	public static int queryport = 0;

	[ServerVar(ShowInAdminUI = true)]
	public static int maxplayers = 500;

	[ServerVar(ShowInAdminUI = true)]
	public static string hostname = "My Untitled Rust Server";

	[ServerVar]
	public static string identity = "my_server_identity";

	[ServerVar]
	public static string filefolderoverride = "";

	[ServerVar]
	public static string level = "Procedural Map";

	[ServerVar]
	public static string levelurl = "";

	[ServerVar]
	public static bool leveltransfer = true;

	[ServerVar]
	public static int seed = 1337;

	[ServerVar]
	public static int salt = 1;

	[ServerVar]
	public static int worldsize = 4500;

	[ServerVar]
	public static int saveinterval = 600;

	[ServerVar]
	public static bool secure = true;

	[ServerVar]
	public static int encryption = 2;

	[ServerVar]
	public static string anticheatid = "xyza7891h6UjNfd0eb2HQGtaul0WhfvS";

	[ServerVar]
	public static string anticheatkey = "OWUDFZmi9VNL/7VhGVSSmCWALKTltKw8ISepa0VXs60";

	[ServerVar]
	public static bool anticheattoken = true;

	[ServerVar]
	public static bool strictauth_eac = false;

	[ServerVar]
	public static bool strictauth_steam = false;

	[ServerVar]
	public static int tickrate = 10;

	[ServerVar]
	public static int entityrate = 16;

	[ServerVar]
	public static float schematime = 1800f;

	[ServerVar]
	public static float cycletime = 500f;

	[ServerVar]
	public static bool official = false;

	[ServerVar]
	public static bool stats = false;

	[ServerVar]
	public static bool stability = true;

	[ServerVar(ShowInAdminUI = true)]
	public static bool radiation = true;

	[ServerVar]
	public static float itemdespawn = 300f;

	[ServerVar]
	public static float itemdespawn_container_scale = 2f;

	[ServerVar]
	public static int itemdespawn_container_max_multiplier = 24;

	[ServerVar]
	public static float itemdespawn_quick = 30f;

	[ServerVar]
	public static float corpsedespawn = 300f;

	[ServerVar]
	public static float debrisdespawn = 30f;

	[ServerVar]
	public static bool pve = false;

	[ReplicatedVar]
	public static bool cinematic = false;

	[ServerVar(ShowInAdminUI = true)]
	public static string description = "No server description has been provided.";

	[ServerVar(ShowInAdminUI = true)]
	public static string url = "";

	[ServerVar]
	public static string branch = "";

	[ServerVar]
	public static int queriesPerSecond = 2000;

	[ServerVar]
	public static int ipQueriesPerMin = 30;

	[ServerVar]
	public static bool statBackup = false;

	[ServerVar]
	public static int rejoin_delay = 300;

	[ServerVar]
	public static string ping_region_code_override = "";

	private static string _favoritesEndpoint = "";

	[ServerVar(Saved = true, ShowInAdminUI = true)]
	public static string headerimage = "";

	[ServerVar(Saved = true, ShowInAdminUI = true)]
	public static string logoimage = "";

	[ServerVar(Saved = true, ShowInAdminUI = true)]
	public static int saveBackupCount = 2;

	[ReplicatedVar(Saved = true, ShowInAdminUI = true)]
	public static string motd = "";

	[ServerVar(Saved = true)]
	public static float meleedamage = 1f;

	[ServerVar(Saved = true)]
	public static float arrowdamage = 1f;

	[ServerVar(Saved = true)]
	public static float bulletdamage = 1f;

	[ServerVar(Saved = true)]
	public static float bleedingdamage = 1f;

	[ServerVar(Saved = true)]
	public static float oilrig_radiation_amount_scale = 1f;

	[ServerVar(Saved = true)]
	public static float oilrig_radiation_time_scale = 1f;

	[ServerVar]
	public static float oilrig_radiation_alarm_threshold = 0f;

	[ReplicatedVar(Saved = true)]
	public static float funWaterDamageThreshold = 0.8f;

	[ReplicatedVar(Saved = true)]
	public static float funWaterWetnessGain = 0.05f;

	[ServerVar(Saved = true)]
	public static float meleearmor = 1f;

	[ServerVar(Saved = true)]
	public static float arrowarmor = 1f;

	[ServerVar(Saved = true)]
	public static float bulletarmor = 1f;

	[ServerVar(Saved = true)]
	public static float bleedingarmor = 1f;

	[ServerVar(Saved = true)]
	public static float pvpBulletDamageMultiplier = 1f;

	[ServerVar]
	public static int updatebatch = 512;

	[ServerVar]
	public static int updatebatchspawn = 1024;

	[ServerVar]
	public static int entitybatchsize = 100;

	[ServerVar]
	public static float entitybatchtime = 1f;

	[ServerVar]
	public static float composterUpdateInterval = 300f;

	[ReplicatedVar]
	public static float planttick = 60f;

	[ServerVar]
	public static float planttickscale = 1f;

	private static int _maxHttp = 32;

	[ServerVar]
	public static bool useMinimumPlantCondition = true;

	[ServerVar(Saved = true)]
	public static float nonPlanterDeathChancePerTick = 0.005f;

	[ServerVar(Saved = true)]
	public static float ceilingLightGrowableRange = 3f;

	[ReplicatedVar(Saved = true)]
	public static float artificialTemperatureGrowableRange = 4f;

	[ServerVar(Saved = true)]
	public static float ceilingLightHeightOffset = 3f;

	[ReplicatedVar(Saved = true)]
	public static float sprinklerRadius = 3f;

	[ServerVar(Saved = true)]
	public static float sprinklerEyeHeightOffset = 3f;

	[ServerVar(Saved = true)]
	public static bool useLegacySprinklerLoadProcess = false;

	[ServerVar(Saved = true)]
	public static float optimalPlanterQualitySaturation = 0.6f;

	[ServerVar]
	public static float metabolismtick = 1f;

	[ServerVar]
	public static float modifierTickRate = 1f;

	[ServerVar(Saved = true)]
	public static float rewounddelay = 60f;

	[ServerVar(Saved = true, Help = "Can players be wounded after receiving fatal damage")]
	public static bool woundingenabled = true;

	[ServerVar(Saved = true, Help = "Do players go into the crawling wounded state")]
	public static bool crawlingenabled = true;

	[ServerVar(Help = "Base chance of recovery after crawling wounded state", Saved = true)]
	public static float woundedrecoverchance = 0.2f;

	[ServerVar(Help = "Base chance of recovery after incapacitated wounded state", Saved = true)]
	public static float incapacitatedrecoverchance = 0.1f;

	[ServerVar(Help = "Maximum percent chance added to base wounded/incapacitated recovery chance, based on the player's food and water level", Saved = true)]
	public static float woundedmaxfoodandwaterbonus = 0.25f;

	[ServerVar(Help = "Minimum initial health given when a player dies and moves to crawling wounded state", Saved = false)]
	public static int crawlingminimumhealth = 7;

	[ServerVar(Help = "Maximum initial health given when a player dies and moves to crawling wounded state", Saved = false)]
	public static int crawlingmaximumhealth = 12;

	[ServerVar(Saved = true)]
	public static bool playerserverfall = true;

	[ServerVar]
	public static bool plantlightdetection = true;

	[ServerVar]
	public static float respawnresetrange = 50f;

	[ReplicatedVar]
	public static int max_sleeping_bags = 15;

	[ReplicatedVar]
	public static bool bag_quota_item_amount = true;

	[ServerVar]
	public static int maxunack = 4;

	[ServerVar]
	public static bool netcache = true;

	[ServerVar]
	public static bool corpses = true;

	[ServerVar]
	public static bool events = true;

	[ServerVar]
	public static bool dropitems = true;

	[ServerVar]
	public static int netcachesize = 0;

	[ServerVar]
	public static int savecachesize = 0;

	[ServerVar]
	public static int combatlogsize = 30;

	[ServerVar]
	public static int combatlogdelay = 10;

	[ServerVar]
	public static int authtimeout = 60;

	[ServerVar]
	public static int playertimeout = 60;

	[ServerVar(ShowInAdminUI = true)]
	public static int idlekick = 30;

	[ServerVar]
	public static int idlekickmode = 1;

	[ServerVar]
	public static int idlekickadmins = 0;

	private static string _gamemode;

	private static string _tags = "";

	[ServerVar(Help = "Censors the Steam player list to make player tracking more difficult")]
	public static bool censorplayerlist = true;

	[ServerVar(Help = "HTTP API endpoint for centralized banning (see wiki)")]
	public static string bansServerEndpoint = "";

	[ServerVar(Help = "Failure mode for centralized banning, set to 1 to reject players from joining if it's down (see wiki)")]
	public static int bansServerFailureMode = 0;

	[ServerVar(Help = "Timeout (in seconds) for centralized banning web server requests")]
	public static int bansServerTimeout = 5;

	[ServerVar(Help = "HTTP API endpoint for receiving F7 reports", Saved = true)]
	public static string reportsServerEndpoint = "";

	[ServerVar(Help = "If set, this key will be included with any reports sent via reportsServerEndpoint (for validation)", Saved = true)]
	public static string reportsServerEndpointKey = "";

	[ServerVar(Help = "Should F7 reports from players be printed to console", Saved = true)]
	public static bool printReportsToConsole = false;

	[ServerVar(Help = "If a player presses the respawn button, respawn at their death location (for trailer filming)")]
	public static bool respawnAtDeathPosition = false;

	[ServerVar(Help = "When a player respawns give them the loadout assigned to client.RespawnLoadout (created with inventory.saveloadout)")]
	public static bool respawnWithLoadout = false;

	[ServerVar(Help = "When transferring water, should containers keep 1 water behind. Enabling this should help performance if water IO is causing performance loss", Saved = true)]
	public static bool waterContainersLeaveWaterBehind = false;

	[ServerVar(Help = "How often industrial conveyors attempt to move items (value is an interval measured in seconds). Setting to 0 will disable all movement", Saved = true, ShowInAdminUI = true)]
	public static float conveyorMoveFrequency = 5f;

	[ServerVar(Help = "How often industrial crafters attempt to craft items (value is an interval measured in seconds). Setting to 0 will disable all crafting", Saved = true, ShowInAdminUI = true)]
	public static float industrialCrafterFrequency = 5f;

	[ReplicatedVar(Help = "How much scrap is required to research default blueprints", Saved = true, ShowInAdminUI = true)]
	public static int defaultBlueprintResearchCost = 10;

	[ServerVar(Help = "Whether to check for illegal industrial pipes when changing building block states (roof bunkers)", Saved = true, ShowInAdminUI = true)]
	public static bool enforcePipeChecksOnBuildingBlockChanges = true;

	[ServerVar(Help = "How many stacks a single conveyor can move in a single tick", Saved = true, ShowInAdminUI = true)]
	public static int maxItemStacksMovedPerTickIndustrial = 12;

	[ServerVar(Help = "How long per frame to spend on industrial jobs", Saved = true, ShowInAdminUI = true)]
	public static float industrialFrameBudgetMs = 0.5f;

	[ServerVar(Help = "When enabled industrial transfers will abort if they start to take too long. Will lead to inconsistent splitting but should retain performance", Saved = true)]
	public static bool industrialTransferStrictTimeLimits = false;

	[ServerVar(Help = "Enables a faster way to move items around during conveyor transfers. Should be on unless there's a issue")]
	public static bool industrialAllowQuickMove = true;

	[ServerVar(Help = "How long per frame to spend animating items moving into the hopper (will be instant if <= 0)", Saved = true, ShowInAdminUI = true)]
	public static float hopperAnimationBudgetMs = 0.1f;

	[ReplicatedVar(Help = "How many markers each player can place", Saved = true, ShowInAdminUI = true)]
	public static int maximumMapMarkers = 5;

	[ServerVar(Help = "How many pings can be placed by each player", Saved = true, ShowInAdminUI = true)]
	public static int maximumPings = 5;

	[ServerVar(Help = "How long a ping should last", Saved = true, ShowInAdminUI = true)]
	public static float pingDuration = 10f;

	[ServerVar(Help = "Allows backpack equipping while not grounded", Saved = true, ShowInAdminUI = true)]
	public static bool canEquipBackpacksInAir = false;

	[ReplicatedVar(Help = "How long it takes to pick up a used parachute in seconds", Saved = true, ShowInAdminUI = true)]
	public static float parachuteRepackTime = 8f;

	public static bool emojiOwnershipCheck = false;

	[ReplicatedVar(Help = "Skip death screen fade", Saved = false, ShowInAdminUI = false)]
	public static bool skipDeathScreenFade = false;

	[ReplicatedVar(Help = "Controls whether the tutorial is enabled on this server", Saved = true, ShowInAdminUI = true, Default = "false")]
	public static bool tutorialEnabled = false;

	[ReplicatedVar(Help = "How much of a tax to apply to workbench T1 tech unlocks. 10 = additional 10% scrap cost", Saved = true)]
	public static float workbench1TaxRate = 0f;

	[ServerVar(Help = "Automatically upload procedurally generated maps so that players download them (faster) instead of re-generating them", Saved = true, ShowInAdminUI = true)]
	public static bool autoUploadMap = true;

	[ReplicatedVar(Help = "How much of a tax to apply to workbench T2 tech unlocks. 10 = additional 10% scrap cost", Saved = true)]
	public static float workbench2TaxRate = 10f;

	[ReplicatedVar(Help = "How much of a tax to apply to workbench  T3tech unlocks. 10 = additional 10% scrap cost", Saved = true)]
	public static float workbench3TaxRate = 20f;

	[ServerVar(Help = "How often (in hours) the water well NPC's update their sell orders")]
	public static float waterWellNpcSalesRefreshFrequency = 1f;

	[ReplicatedVar(Help = "Opens a loot panel when interacting with a workbench instead of going straight into the tech tree. Designed for backwards compatibility with mods.")]
	public static bool useLegacyWorkbenchInteraction = false;

	[ServerVar(Help = "If no players are in this range kayaks, boogie boards and inner tubes will switch to a cheaper buoyancy system")]
	public static float lowPriorityBuoyancyRange = 30f;

	[ServerVar(Help = "If true hot air balloons can be shot down with homing missiles")]
	public static bool homingMissileTargetsHab = false;

	[ServerVar(Help = "Require a premium status account to connect to this server")]
	public static bool premium = false;

	[ReplicatedVar(Help = "Whether to run the food spoiling system")]
	public static bool foodSpoiling = true;

	[ServerVar]
	public static float foodSpoilingBudgetMs = 0.05f;

	[ServerVar(Help = "Maximum difference (in seconds) that two items with spoil timers can have and still be stackable")]
	public static float maxFoodSpoilTimeDiffForItemStack = 180f;

	[ServerVar(Help = "If two spoiled food items are both above this threshold then we will allow them to be stacked")]
	public static float normalisedFoodSpoilTimeStackThreshold = 0.9f;

	[ServerVar(Help = "Whether to run local avoidance for chickens, disabling might get a slight performance improvement but chickens will clip", Saved = true, ShowInAdminUI = true)]
	public static bool farmChickenLocalAvoidance = true;

	[ServerVar(Help = "Endpoint to use to check if players have premium status")]
	public static string premiumVerifyEndpoint = "https://rust-api.facepunch.com/api/premium/verify";

	[ServerVar(Help = "Minimum time to recheck premium status for already connected players (in seconds)")]
	public static float premiumRecheckMinSeconds = 300f;

	[ServerVar(Help = "How often to do premium status rechecks")]
	public static float premiumRecheckInterval = 300f;

	[ServerVar(Help = "Maximum number of players to recheck at a time")]
	public static int premiumRecheckMaxBatchSize = 100;

	[ServerVar(Saved = true)]
	public static bool showHolsteredItems = true;

	[ServerVar]
	public static int maxpacketspersecond_world = 1;

	[ServerVar]
	public static int maxpacketspersecond_rpc = 200;

	[ServerVar]
	public static int maxpacketspersecond_rpc_signal = 30;

	[ServerVar]
	public static int maxpacketspersecond_command = 100;

	[ServerVar]
	public static int maxpacketsize_command = 100000;

	[ServerVar]
	public static int maxpacketsize_globaltrees = 100;

	[ServerVar]
	public static int maxpacketsize_globalentities = 1000;

	[ServerVar]
	public static int maxpacketspersecond_tick = 300;

	[ServerVar]
	public static int maxpacketspersecond_voice = 100;

	[ServerVar]
	public static bool packetlog_enabled = false;

	[ServerVar]
	public static bool rpclog_enabled = false;

	[ServerVar]
	public static bool UsePlayerUpdateJobs = false;

	public const bool EmergencyDisablePlayerJobs = true;

	[ServerVar(Saved = true)]
	public static string server_id
	{
		get
		{
			return DemoConVars.ServerId;
		}
		set
		{
			DemoConVars.ServerId = value;
		}
	}

	[ServerVar(ShowInAdminUI = true, Saved = true, Help = "Domain name to save when players favorite your server. The port can be omitted if using the default port or a SRV DNS record is created.")]
	public static string favoritesEndpoint
	{
		get
		{
			return _favoritesEndpoint;
		}
		set
		{
			if (string.IsNullOrWhiteSpace(value))
			{
				_favoritesEndpoint = "";
				return;
			}
			value = value.Trim();
			if (value.StartsWith("https://"))
			{
				string text = value;
				int length = "https://".Length;
				value = text.Substring(length, text.Length - length);
			}
			if (value.StartsWith("http://"))
			{
				string text = value;
				int length = "http://".Length;
				value = text.Substring(length, text.Length - length);
			}
			_favoritesEndpoint = value.Trim().ToLowerInvariant();
		}
	}

	[ServerVar]
	public static int anticheatlog
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)EOS.LogLevel;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			EOS.LogLevel = (LogLevel)value;
		}
	}

	[ServerVar]
	public static int http_connection_limit
	{
		get
		{
			return _maxHttp;
		}
		set
		{
			_maxHttp = value;
			HttpManager.UpdateMaxConnections();
		}
	}

	[ServerVar]
	public static string gamemode
	{
		get
		{
			return _gamemode;
		}
		set
		{
			_gamemode = value;
			ApplyGamemode();
		}
	}

	[ServerVar(Help = "Comma-separated server browser tag values (see wiki)", Saved = true, ShowInAdminUI = true)]
	public static string tags
	{
		get
		{
			return _tags;
		}
		set
		{
			_tags = AutoCorrectTags(value);
		}
	}

	[ServerVar]
	public static int maxclientinfosize
	{
		get
		{
			return Connection.MaxClientInfoSize;
		}
		set
		{
			Connection.MaxClientInfoSize = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxconnectionsperip
	{
		get
		{
			return Server.MaxConnectionsPerIP;
		}
		set
		{
			Server.MaxConnectionsPerIP = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxreceivetime
	{
		get
		{
			return Server.MaxReceiveTime;
		}
		set
		{
			Server.MaxReceiveTime = Mathf.Clamp(value, 10, 1000);
		}
	}

	[ServerVar]
	public static int maxmainthreadwait
	{
		get
		{
			return Server.MaxMainThreadWait;
		}
		set
		{
			Server.MaxMainThreadWait = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxreadthreadwait
	{
		get
		{
			return Server.MaxReadThreadWait;
		}
		set
		{
			Server.MaxReadThreadWait = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxwritethreadwait
	{
		get
		{
			return Server.MaxWriteThreadWait;
		}
		set
		{
			Server.MaxWriteThreadWait = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxdecryptthreadwait
	{
		get
		{
			return Server.MaxDecryptThreadWait;
		}
		set
		{
			Server.MaxDecryptThreadWait = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxreadqueuelength
	{
		get
		{
			return Server.MaxReadQueueLength;
		}
		set
		{
			Server.MaxReadQueueLength = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxwritequeuelength
	{
		get
		{
			return Server.MaxWriteQueueLength;
		}
		set
		{
			Server.MaxWriteQueueLength = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxdecryptqueuelength
	{
		get
		{
			return Server.MaxDecryptQueueLength;
		}
		set
		{
			Server.MaxDecryptQueueLength = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxreadqueuebytes
	{
		get
		{
			return Server.MaxReadQueueBytes;
		}
		set
		{
			Server.MaxReadQueueBytes = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxwritequeuebytes
	{
		get
		{
			return Server.MaxWriteQueueBytes;
		}
		set
		{
			Server.MaxWriteQueueBytes = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxdecryptqueuebytes
	{
		get
		{
			return Server.MaxDecryptQueueBytes;
		}
		set
		{
			Server.MaxDecryptQueueBytes = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int player_state_cache_size
	{
		get
		{
			return SingletonComponent<ServerMgr>.Instance?.playerStateManager.CacheSize ?? 0;
		}
		set
		{
			SingletonComponent<ServerMgr>.Instance.playerStateManager.CacheSize = value;
		}
	}

	[ServerVar]
	public static int maxpacketspersecond
	{
		get
		{
			return (int)Server.MaxPacketsPerSecond;
		}
		set
		{
			Server.MaxPacketsPerSecond = (ulong)Mathf.Clamp(value, 1, 1000000);
		}
	}

	public static string rootFolder => "server/" + identity;

	public static string filesStorageFolder
	{
		get
		{
			if (!string.IsNullOrEmpty(filefolderoverride))
			{
				return filefolderoverride;
			}
			return rootFolder;
		}
	}

	public static string backupFolder => "backup/0/" + identity;

	public static string backupFolder1 => "backup/1/" + identity;

	public static string backupFolder2 => "backup/2/" + identity;

	public static string backupFolder3 => "backup/3/" + identity;

	[ServerVar]
	public static bool compression
	{
		get
		{
			if (Net.sv == null)
			{
				return false;
			}
			return Net.sv.compressionEnabled;
		}
		set
		{
			Net.sv.compressionEnabled = value;
		}
	}

	[ServerVar]
	public static bool netlog
	{
		get
		{
			if (Net.sv == null)
			{
				return false;
			}
			return Net.sv.logging;
		}
		set
		{
			Net.sv.logging = value;
		}
	}

	[ReplicatedVar(Name = "era", Help = "none,primitive,medieval,frontier,rust")]
	public static string era
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			Era val = Era;
			return ((object)(Era)(ref val)/*cast due to .constrained prefix*/).ToString();
		}
		set
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_014a: Unknown result type (might be due to invalid IL or missing references)
			if (string.IsNullOrEmpty(value) && (int)Era != 0)
			{
				Era = (Era)0;
				OnEraChanged();
				return;
			}
			Era val = Era;
			switch (value.ToLower())
			{
			case "unknown":
			case "none":
				Era = (Era)0;
				break;
			case "primitive":
				Era = (Era)10;
				break;
			case "siege":
			case "medieval":
				Era = (Era)20;
				break;
			case "frontier":
				Era = (Era)30;
				break;
			case "modern":
			case "rust":
				Era = (Era)1000;
				break;
			}
			if (val != Era)
			{
				OnEraChanged();
			}
		}
	}

	public static Era Era { get; private set; }

	private static void ApplyGamemode()
	{
		GameModeManifest gameModeManifest = GameModeManifest.Get();
		if ((Object)(object)gameModeManifest == (Object)null)
		{
			Debug.LogError((object)"No GameModeManifest found");
			return;
		}
		foreach (GameObjectRef gameModePrefab in gameModeManifest.gameModePrefabs)
		{
			object obj;
			if (gameModePrefab == null)
			{
				obj = null;
			}
			else
			{
				GameObject obj2 = gameModePrefab.Get();
				obj = ((obj2 != null) ? obj2.GetComponent<BaseGameMode>() : null);
			}
			BaseGameMode baseGameMode = (BaseGameMode)obj;
			if (baseGameMode.shortname == gamemode)
			{
				baseGameMode.ApplyConVars();
				return;
			}
		}
		Debug.LogWarning((object)("Couldn't find gamemode: " + gamemode));
	}

	public static float GetTaxRateForWorkbenchUnlock(int workbenchLevel)
	{
		float num = 0f;
		switch (workbenchLevel)
		{
		case 0:
			num = workbench1TaxRate;
			break;
		case 1:
			num = workbench2TaxRate;
			break;
		case 2:
			num = workbench3TaxRate;
			break;
		}
		return Mathf.Clamp(num, 0f, 100f);
	}

	public static float TickDelta()
	{
		return 1f / (float)tickrate;
	}

	public static float TickTime(uint tick)
	{
		return (float)((double)TickDelta() * (double)tick);
	}

	[ServerVar(Help = "Show holstered items on player bodies")]
	public static void setshowholstereditems(Arg arg)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		showHolsteredItems = arg.GetBool(0, showHolsteredItems);
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.inventory.UpdatedVisibleHolsteredItems();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.inventory.UpdatedVisibleHolsteredItems();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar]
	public static void player_state_cache_count(Arg args)
	{
		args.ReplyWith((object)SingletonComponent<ServerMgr>.Instance.playerStateManager.CacheCount);
	}

	[ServerVar]
	public static void player_state_cache_evictions(Arg args)
	{
		args.ReplyWith((object)SingletonComponent<ServerMgr>.Instance.playerStateManager.CacheEvictions);
	}

	[ServerVar]
	public static string printreadqueue(Arg arg)
	{
		return "Server read queue: " + ((BaseNetwork)Net.sv).ReadQueueLength + " items / " + NumberExtensions.FormatBytes<int>(((BaseNetwork)Net.sv).ReadQueueBytes, false);
	}

	[ServerVar]
	public static string printwritequeue(Arg arg)
	{
		return "Server write queue: " + ((BaseNetwork)Net.sv).WriteQueueLength + " items / " + NumberExtensions.FormatBytes<int>(((BaseNetwork)Net.sv).WriteQueueBytes, false);
	}

	[ServerVar]
	public static string printdecryptqueue(Arg arg)
	{
		return "Server decrypt queue: " + ((BaseNetwork)Net.sv).DecryptQueueLength + " items / " + NumberExtensions.FormatBytes<int>(((BaseNetwork)Net.sv).DecryptQueueBytes, false);
	}

	[ServerVar]
	public static string packetlog(Arg arg)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Expected O, but got Unknown
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		if (!packetlog_enabled)
		{
			return "Packet log is not enabled.";
		}
		List<Tuple<Type, ulong>> list = new List<Tuple<Type, ulong>>();
		foreach (KeyValuePair<Type, TimeAverageValue> item2 in SingletonComponent<ServerMgr>.Instance.packetHistory.dict)
		{
			list.Add(new Tuple<Type, ulong>(item2.Key, item2.Value.Calculate()));
		}
		TextTable val = new TextTable();
		val.AddColumn("type");
		val.AddColumn("calls");
		foreach (Tuple<Type, ulong> item3 in list.OrderByDescending((Tuple<Type, ulong> entry) => entry.Item2))
		{
			if (item3.Item2 == 0L)
			{
				break;
			}
			Type item = item3.Item1;
			string text = ((object)(Type)(ref item)/*cast due to .constrained prefix*/).ToString();
			string text2 = item3.Item2.ToString();
			val.AddRow(new string[2] { text, text2 });
		}
		if (!arg.HasArg("--json", false))
		{
			return ((object)val).ToString();
		}
		return val.ToJson(true);
	}

	[ServerVar]
	public static string rpclog(Arg arg)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Expected O, but got Unknown
		if (!rpclog_enabled)
		{
			return "RPC log is not enabled.";
		}
		List<Tuple<uint, ulong>> list = new List<Tuple<uint, ulong>>();
		foreach (KeyValuePair<uint, TimeAverageValue> item in SingletonComponent<ServerMgr>.Instance.rpcHistory.dict)
		{
			list.Add(new Tuple<uint, ulong>(item.Key, item.Value.Calculate()));
		}
		TextTable val = new TextTable();
		val.AddColumn("id");
		val.AddColumn("name");
		val.AddColumn("calls");
		foreach (Tuple<uint, ulong> item2 in list.OrderByDescending((Tuple<uint, ulong> entry) => entry.Item2))
		{
			if (item2.Item2 == 0L)
			{
				break;
			}
			string text = item2.Item1.ToString();
			string text2 = StringPool.Get(item2.Item1);
			string text3 = item2.Item2.ToString();
			val.AddRow(new string[3] { text, text2, text3 });
		}
		return ((object)val).ToString();
	}

	[ServerVar(Help = "Starts a server")]
	public static void start(Arg arg)
	{
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			arg.ReplyWith("There is already a server running!");
			return;
		}
		string @string = arg.GetString(0, level);
		if (!LevelManager.IsValid(@string))
		{
			arg.ReplyWith("Level '" + @string + "' isn't valid!");
			return;
		}
		if (Object.op_Implicit((Object)(object)Object.FindObjectOfType<ServerMgr>()))
		{
			arg.ReplyWith("There is already a server running!");
			return;
		}
		Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/shared.prefab"));
		Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/server.prefab"));
		LevelManager.LoadLevel(@string);
	}

	[ServerVar(Help = "Stops a server")]
	public static void stop(Arg arg)
	{
		if (!((BaseNetwork)Net.sv).IsConnected())
		{
			arg.ReplyWith("There isn't a server running!");
		}
		else
		{
			Net.sv.Stop(arg.GetString(0, "Stopping Server"));
		}
	}

	[ServerVar(Help = "Backup server folder")]
	public static void backup()
	{
		DirectoryEx.Backup(backupFolder, backupFolder1, backupFolder2, backupFolder3);
		DirectoryEx.CopyAll(rootFolder, backupFolder);
	}

	public static string GetServerFolder(string folder)
	{
		string text = rootFolder + "/" + folder;
		if (Directory.Exists(text))
		{
			return text;
		}
		Directory.CreateDirectory(text);
		return text;
	}

	[ServerVar(Help = "Writes config files")]
	public static void writecfg(Arg arg)
	{
		string contents = ConsoleSystem.SaveToConfigString(true);
		File.WriteAllText(GetServerFolder("cfg") + "/serverauto.cfg", contents);
		ServerUsers.Save();
		arg.ReplyWith("Config Saved");
	}

	[ServerVar]
	public static void fps(Arg arg)
	{
		arg.ReplyWith(Performance.report.frameRate + " FPS");
	}

	[ServerVar(Help = "Force save the current game")]
	public static void save(Arg arg)
	{
		Stopwatch stopwatch = Stopwatch.StartNew();
		foreach (BaseEntity save in BaseEntity.saveList)
		{
			save.InvalidateNetworkCache();
		}
		Debug.Log((object)("Invalidate Network Cache took " + stopwatch.Elapsed.TotalSeconds.ToString("0.00") + " seconds"));
		SaveRestore.Save(AndWait: true);
	}

	[ServerVar]
	public static string readcfg(Arg arg)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		string serverFolder = GetServerFolder("cfg");
		Option server;
		if (File.Exists(serverFolder + "/serverauto.cfg"))
		{
			string text = File.ReadAllText(serverFolder + "/serverauto.cfg");
			server = Option.Server;
			ConsoleSystem.RunFile(((Option)(ref server)).Quiet(), text);
		}
		if (File.Exists(serverFolder + "/server.cfg"))
		{
			string text2 = File.ReadAllText(serverFolder + "/server.cfg");
			server = Option.Server;
			ConsoleSystem.RunFile(((Option)(ref server)).Quiet(), text2);
		}
		return "Server Config Loaded";
	}

	[ServerVar]
	public static string netprotocol(Arg arg)
	{
		if (Net.sv == null)
		{
			return string.Empty;
		}
		return Net.sv.ProtocolId;
	}

	[ServerUserVar]
	public static void cheatreport(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			string text = arg.GetUInt64(0, 0uL).ToString();
			string @string = arg.GetString(1, "");
			Debug.LogWarning((object)(((object)basePlayer)?.ToString() + " reported " + text + ": " + StringEx.ToPrintable(@string, 140)));
			EACServer.SendPlayerBehaviorReport(basePlayer, (PlayerReportsCategory)1, text, @string);
		}
	}

	[ServerVar(Help = "Get info on player corpses on the server")]
	public static void corpseinfo(Arg arg)
	{
		PlayerCorpse[] array = BaseNetworkable.serverEntities.OfType<PlayerCorpse>().ToArray();
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		PlayerCorpse[] array2 = array;
		foreach (PlayerCorpse playerCorpse in array2)
		{
			if (playerCorpse.isClient)
			{
				continue;
			}
			num++;
			if (playerCorpse.CorpseIsRagdoll)
			{
				num2++;
				if (playerCorpse.CorpseRagdollScript.IsKinematic)
				{
					num3++;
				}
				else if (playerCorpse.CorpseRagdollScript.IsFullySleeping())
				{
					num4++;
				}
			}
		}
		int num5 = num2 - num3 - num4;
		float num6 = ((num2 > 0) ? ((float)num5 / (float)num2) : 0f);
		string text = $"Found {num} player corpses in the world, " + $"of which {num2} are using server-side ragdolls. " + $"{num5} of those are active ({num6:0%}), {num4} are sleeping, and {num3} are kinematic.";
		arg.ReplyWith(text);
	}

	[ServerAllVar(Help = "Get the player combat log")]
	public static string combatlog(Arg arg)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1) && arg.IsAdmin)
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if ((Object)(object)basePlayer == (Object)null || basePlayer.net == null)
		{
			return "invalid player";
		}
		CombatLog combat = basePlayer.stats.combat;
		int count = combatlogsize;
		bool json = arg.HasArg("--json", false);
		bool isAdmin = arg.IsAdmin;
		ulong requestingUser = arg.Connection?.userid ?? 0;
		return combat.Get(count, default(NetworkableId), json, isAdmin, requestingUser);
	}

	[ServerAllVar(Help = "Get the player combat log, only showing outgoing damage")]
	public static string combatlog_outgoing(Arg arg)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1) && arg.IsAdmin)
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if ((Object)(object)basePlayer == (Object)null)
		{
			return "invalid player";
		}
		return basePlayer.stats.combat.Get(combatlogsize, basePlayer.net.ID, arg.HasArg("--json", false), arg.IsAdmin, arg.Connection?.userid ?? 0);
	}

	[ServerVar(Help = "Print the current player position.")]
	public static string printpos(Arg arg)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1))
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Vector3 position = ((Component)basePlayer).transform.position;
			return ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
		}
		return "invalid player";
	}

	[ServerVar(Help = "Print the current player center position.")]
	public static string printposcenter(Arg arg)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1))
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Vector3 center = basePlayer.GetCenter(ducked: false);
			return ((object)(Vector3)(ref center)/*cast due to .constrained prefix*/).ToString();
		}
		return "invalid player";
	}

	[ServerVar(Help = "Print the current player rotation.")]
	public static string printrot(Arg arg)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1))
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Quaternion rotation = ((Component)basePlayer).transform.rotation;
			Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
			return ((object)(Vector3)(ref eulerAngles)/*cast due to .constrained prefix*/).ToString();
		}
		return "invalid player";
	}

	[ServerVar(Help = "Print the current player eyes.")]
	public static string printeyes(Arg arg)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1))
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Quaternion rotation = basePlayer.eyes.rotation;
			Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
			return ((object)(Vector3)(ref eulerAngles)/*cast due to .constrained prefix*/).ToString();
		}
		return "invalid player";
	}

	[ServerVar(ServerAdmin = true, Help = "This sends a snapshot of all the entities in the client's pvs. This is mostly redundant, but we request this when the client starts recording a demo.. so they get all the information.")]
	public static void snapshot(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Debug.Log((object)("Sending full snapshot to " + (object)basePlayer));
			basePlayer.SendNetworkUpdateImmediate();
			basePlayer.SendGlobalSnapshot();
			basePlayer.SendFullSnapshot();
			basePlayer.SendEntityUpdate();
			TreeManager.SendSnapshot(basePlayer);
			ServerMgr.SendReplicatedVars(basePlayer.net.connection);
		}
	}

	[ServerVar(Help = "Send network update for all players")]
	public static void sendnetworkupdate(Arg arg)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.SendNetworkUpdate();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static TextTable GetPlayerListPosTable(bool forJson)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Expected O, but got Unknown
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		TextTable val = new TextTable(!forJson);
		val.ResizeColumns(4);
		val.AddColumn("SteamID");
		val.AddColumn("DisplayName");
		val.AddColumn("POS");
		val.AddColumn("ROT");
		val.ResizeRows(BasePlayer.activePlayerList.Count);
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				val.AddValue(current.userID.Get());
				val.AddValue(current.displayName);
				val.AddValue(((Component)current).transform.position);
				val.AddValue(current.eyes.BodyForward());
			}
			return val;
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Prints the position of all players on the server")]
	public static void playerlistpos(Arg arg)
	{
		bool flag = arg.HasArg("--json", false);
		TextTable playerListPosTable = GetPlayerListPosTable(flag);
		arg.ReplyWith(flag ? playerListPosTable.ToJson(true) : ((object)playerListPosTable).ToString());
	}

	[ServerVar(Help = "Prints all the vending machines on the server")]
	public static void listvendingmachines(Arg arg)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		TextTable val = new TextTable();
		val.AddColumns(new string[3] { "EntityId", "Position", "Name" });
		foreach (VendingMachine item in BaseNetworkable.serverEntities.OfType<VendingMachine>())
		{
			string[] obj = new string[3]
			{
				((object)(NetworkableId)(ref item.net.ID)/*cast due to .constrained prefix*/).ToString(),
				null,
				null
			};
			Vector3 position = ((Component)item).transform.position;
			obj[1] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
			obj[2] = StringExtensions.QuoteSafe(item.shopName);
			val.AddRow(obj);
		}
		arg.ReplyWith(arg.HasArg("--json", false) ? val.ToJson(true) : ((object)val).ToString());
	}

	[ServerVar(Help = "Prints all the Tool Cupboards on the server")]
	public static void listtoolcupboards(Arg arg)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		TextTable val = new TextTable();
		val.AddColumns(new string[3] { "EntityId", "Position", "Authed" });
		foreach (BuildingPrivlidge item in BaseNetworkable.serverEntities.OfType<BuildingPrivlidge>())
		{
			string[] obj = new string[3]
			{
				((object)(NetworkableId)(ref item.net.ID)/*cast due to .constrained prefix*/).ToString(),
				null,
				null
			};
			Vector3 position = ((Component)item).transform.position;
			obj[1] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
			obj[2] = item.authorizedPlayers.Count.ToString();
			val.AddRow(obj);
		}
		arg.ReplyWith(arg.HasArg("--json", false) ? val.ToJson(true) : ((object)val).ToString());
	}

	[ServerVar]
	public static void BroadcastPlayVideo(Arg arg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		if (string.IsNullOrWhiteSpace(@string))
		{
			arg.ReplyWith("Missing video URL");
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Command("client.playvideo", @string);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Sent video to {BasePlayer.activePlayerList.Count} players");
	}

	[ServerVar(Help = "Rescans the serveremoji folder, note that clients will need to reconnect to get the latest emoji")]
	public static void ResetServerEmoji()
	{
		RustEmojiLibrary.ResetServerEmoji();
	}

	[ServerVar]
	public static string BotCount()
	{
		return BasePlayer.bots.Count.ToString();
	}

	[ServerVar(Help = "Prints the current wipe id of the sav")]
	public static void printwipeid(Arg arg)
	{
		if (string.IsNullOrEmpty(SaveRestore.WipeId))
		{
			arg.ReplyWith("ERROR: wipe ID is null or empty!");
		}
		else
		{
			arg.ReplyWith(SaveRestore.WipeId);
		}
	}

	[ServerVar(Help = "Clears the loot spawn cache used to restrict loot into each era")]
	public static void clear_loot_spawn_cache(Arg arg)
	{
		LootContainer[] source = (from x in GameManager.server.preProcessed.prefabList.Values
			select x.GetComponent<LootContainer>() into x
			where (Object)(object)x != (Object)null
			select x).ToArray();
		LootSpawn[] array = (from x in source.Select((LootContainer x) => x.lootDefinition).Concat(from x in source.SelectMany((LootContainer x) => x.LootSpawnSlots)
				select x.definition)
			where (Object)(object)x != (Object)null
			select x).ToArray();
		LootSpawn[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].ClearCache();
		}
		arg.ReplyWith($"Cleared {array.Length} loot spawn caches");
	}

	[ServerVar]
	public static void clear_trees_radius(Arg arg)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		float @float = arg.GetFloat(0, 0f);
		Vector3 position = (((Object)(object)basePlayer != (Object)null) ? ((Component)basePlayer).transform.position : Vector3.zero);
		if (arg.HasArgs(2))
		{
			position = arg.GetVector3(1, default(Vector3));
		}
		int num = 0;
		if ((Object)(object)basePlayer != (Object)null)
		{
			List<TreeEntity> list = Pool.Get<List<TreeEntity>>();
			Vis.Entities(position, @float, list, 1073741824, (QueryTriggerInteraction)2);
			foreach (TreeEntity item in list)
			{
				item.Kill();
				num++;
			}
		}
		arg.ReplyWith($"Deleted {num} server tree entities within {@float}m");
	}

	[ServerVar]
	public static void clear_bushes_radius(Arg arg)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		float @float = arg.GetFloat(0, 0f);
		Vector3 position = (((Object)(object)basePlayer != (Object)null) ? ((Component)basePlayer).transform.position : Vector3.zero);
		if (arg.HasArgs(2))
		{
			position = arg.GetVector3(1, default(Vector3));
		}
		int num = 0;
		if ((Object)(object)basePlayer != (Object)null)
		{
			PooledList<BushEntity> val = Pool.Get<PooledList<BushEntity>>();
			try
			{
				Vis.Entities(position, @float, (List<BushEntity>)(object)val, 67108864, (QueryTriggerInteraction)2);
				foreach (BushEntity item in (List<BushEntity>)(object)val)
				{
					item.Kill();
					num++;
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		arg.ReplyWith($"Deleted {num} server bush entities within {@float}m");
	}

	[ServerVar(Help = "Deletes items on the server that are not allowed in the era")]
	public static void enforce_era_restrictions(Arg arg)
	{
		int num = 0;
		int num2 = 0;
		Dictionary<string, int> dictionary = new Dictionary<string, int>();
		foreach (Item allItem in ItemManager.GetAllItems())
		{
			num++;
			if (!allItem.info.IsAllowedInEra((EraRestriction)0))
			{
				if (!dictionary.ContainsKey(allItem.info.shortname))
				{
					dictionary.Add(allItem.info.shortname, allItem.amount);
				}
				else
				{
					dictionary[allItem.info.shortname] += allItem.amount;
				}
				allItem.Remove();
				num2++;
			}
		}
		ItemManager.DoRemoves();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Iterated '{num}' items and removed '{num2}' restricted items");
		foreach (KeyValuePair<string, int> item in dictionary)
		{
			stringBuilder.AppendLine($"{item.Key}: {item.Value}");
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void fillChickenCoop(Arg arg)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		PooledList<ChickenCoop> val = Pool.Get<PooledList<ChickenCoop>>();
		try
		{
			Vis.Entities(((Component)basePlayer).transform.position, 5f, (List<ChickenCoop>)(object)val, 256, (QueryTriggerInteraction)2);
			foreach (ChickenCoop item in (List<ChickenCoop>)(object)val)
			{
				if (item.isServer)
				{
					item.DebugFillCoop();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void OnEraChanged()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is LootContainer lootContainer)
				{
					lootContainer.PopulateLoot();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		SingletonComponent<SpawnHandler>.Instance?.EnforceLimits();
	}

	private static string AutoCorrectTags(string value)
	{
		List<string> inputValues = (from s in value.Split(',', StringSplitOptions.RemoveEmptyEntries)
			select s.Trim().ToLowerInvariant()).ToList();
		List<string> outputValues = new List<string>();
		Add(new string[3] { "monthly", "biweekly", "weekly" });
		Add(new string[3] { "vanilla", "hardcore", "softcore" });
		Add(new string[1] { "roleplay" });
		Add(new string[1] { "creative" });
		Add(new string[1] { "minigame" });
		Add(new string[1] { "training" });
		Add(new string[1] { "battlefield" });
		Add(new string[1] { "broyale" });
		Add(new string[1] { "builds" });
		Add(new string[7] { "NA", "SA", "EU", "WA", "EA", "OC", "AF" });
		Add(new string[1] { "tut" });
		Add(new string[1] { "premium" });
		if (!pve)
		{
			Add(new string[1] { "pve" });
		}
		return string.Join(',', outputValues);
		void Add(string[] options)
		{
			if (outputValues.Count < 4)
			{
				foreach (string text in options)
				{
					if (inputValues.Contains<string>(text, StringComparer.InvariantCultureIgnoreCase))
					{
						outputValues.Add(text);
						break;
					}
				}
			}
		}
	}
}


using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using UnityEngine;

[Factory("spawn")]
public class Spawn : ConsoleSystem
{
	[ServerVar]
	public static float min_rate = 0.5f;

	[ServerVar]
	public static float max_rate = 1f;

	[ServerVar]
	public static float min_density = 0.5f;

	[ServerVar]
	public static float max_density = 1f;

	[ServerVar]
	public static float player_base = 100f;

	[ServerVar]
	public static float player_scale = 2f;

	[ServerVar]
	public static bool respawn_populations = true;

	[ServerVar]
	public static bool respawn_groups = true;

	[ServerVar]
	public static bool respawn_individuals = true;

	[ServerVar]
	public static float tick_populations = 60f;

	[ServerVar]
	public static float tick_individuals = 300f;

	[ServerVar]
	public static void fill_populations(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.FillPopulations();
		}
	}

	[ServerVar]
	public static void delete_populations(Arg args)
	{
		if (!args.HasArgs(1))
		{
			args.ReplyWith("Usage: delete_populations <population_name> ...");
			return;
		}
		string[] args2 = args.Args;
		foreach (string name in args2)
		{
			SingletonComponent<SpawnHandler>.Instance?.DeletePopulation(name);
		}
	}

	[ServerVar]
	public static void delete_all_populations(Arg args)
	{
		SingletonComponent<SpawnHandler>.Instance?.DeleteAllPopulations();
	}

	[ServerVar]
	public static void simulate_loot(Arg args)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = args.Player();
		if ((Object)(object)player == (Object)null)
		{
			args.ReplyWith("Must be called from player");
			return;
		}
		int num = Mathf.Clamp(args.GetInt(0, 100), 1, 10000);
		List<LootContainer> list = new List<LootContainer>();
		Vis.Entities(((Component)player).transform.position, 5f, list, -1, (QueryTriggerInteraction)1);
		LootContainer lootContainer = list.OrderByDescending((LootContainer x) => Vector3.Distance(((Component)player).transform.position, ((Component)x).transform.position)).FirstOrDefault();
		if ((Object)(object)lootContainer == (Object)null)
		{
			args.ReplyWith("No loot container found");
			return;
		}
		Dictionary<string, int> dictionary = new Dictionary<string, int>();
		for (int i = 0; i < num; i++)
		{
			lootContainer.inventory.Clear();
			ItemManager.DoRemoves();
			lootContainer.PopulateLoot();
			foreach (Item item in lootContainer.inventory.itemList)
			{
				if (item != null)
				{
					dictionary.TryGetValue(item.info.shortname, out var value);
					dictionary[item.info.shortname] = value + item.amount;
				}
			}
		}
		StringBuilder stringBuilder = new StringBuilder();
		foreach (KeyValuePair<string, int> item2 in dictionary.OrderByDescending((KeyValuePair<string, int> x) => x.Value))
		{
			stringBuilder.AppendLine($"{item2.Key}: {item2.Value}");
		}
		args.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void fill_groups(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.FillGroups();
		}
	}

	[ServerVar]
	public static void fill_individuals(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.FillIndividuals();
		}
	}

	[ServerVar]
	public static void report(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			bool @bool = args.GetBool(0, false);
			string @string = args.GetString(1, (string)null);
			args.ReplyWith(SingletonComponent<SpawnHandler>.Instance.GetReport(@bool, @string));
		}
		else
		{
			args.ReplyWith("No spawn handler found.");
		}
	}

	[ServerVar]
	public static void scalars(Arg args)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		TextTable val = new TextTable();
		val.AddColumn("Type");
		val.AddColumn("Value");
		val.AddRow(new string[2]
		{
			"Player Fraction",
			SpawnHandler.PlayerFraction().ToString()
		});
		val.AddRow(new string[2]
		{
			"Player Excess",
			SpawnHandler.PlayerExcess().ToString()
		});
		val.AddRow(new string[2]
		{
			"Population Rate",
			SpawnHandler.PlayerLerp(min_rate, max_rate).ToString()
		});
		val.AddRow(new string[2]
		{
			"Population Density",
			SpawnHandler.PlayerLerp(min_density, max_density).ToString()
		});
		val.AddRow(new string[2]
		{
			"Group Rate",
			SpawnHandler.PlayerScale(player_scale).ToString()
		});
		args.ReplyWith(args.HasArg("--json", false) ? val.ToJson(true) : ((object)val).ToString());
	}

	[ServerVar]
	public static void cargoshipevent(Arg args)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/content/vehicles/boats/cargoship/cargoshiptest.prefab");
		if ((Object)(object)baseEntity != (Object)null)
		{
			((Component)baseEntity).SendMessage("TriggeredEventSpawn", (SendMessageOptions)1);
			baseEntity.Spawn();
			args.ReplyWith("Cargo ship event has been started");
		}
		else
		{
			args.ReplyWith("Couldn't find cargo ship prefab - maybe it has been renamed?");
		}
	}

	[ServerVar]
	public static void ch47event(Arg args)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		if (!CH47LandingZone.HasAnyLandingZones)
		{
			args.ReplyWith("Couldn't find any landing zones for CH47. Not starting the event");
			return;
		}
		int @int = args.GetInt(0, 300);
		if (CH47ReinforcementListener.TryCall("assets/Prefabs/NPC/CH47/ch47scientists.entity.prefab", ((Component)basePlayer).transform.position, @int))
		{
			args.ReplyWith($"CH47 event has been started at a distance of {@int}m");
		}
		else
		{
			args.ReplyWith("Couldn't start CH47 event");
		}
	}

	[ServerVar]
	public static void cargoshipdockingtest(Arg args)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (CargoShip.TotalAvailableHarborDockingPaths == 0)
		{
			args.ReplyWith("No valid harbor dock points");
			return;
		}
		int @int = args.GetInt(0, 0);
		@int = Mathf.Clamp(@int, 0, CargoShip.TotalAvailableHarborDockingPaths);
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/content/vehicles/boats/cargoship/cargoshiptest.prefab");
		if ((Object)(object)baseEntity != (Object)null)
		{
			((Component)baseEntity).SendMessage("TriggeredEventSpawnDockingTest", (object)@int, (SendMessageOptions)1);
			baseEntity.Spawn();
			args.ReplyWith("Cargo ship event has been started");
		}
		else
		{
			args.ReplyWith("Couldn't find cargo ship prefab - maybe it has been renamed?");
		}
	}

	[ServerVar]
	public static void svShieldDummy(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = arg.GetVector3(0, default(Vector3));
		Vector3 vector2 = arg.GetVector3(1, default(Vector3));
		bool @bool = arg.GetBool(2, false);
		BasePlayer basePlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", vector, Quaternion.Euler(vector2)) as BasePlayer;
		basePlayer.Spawn();
		if (Inventory.LoadLoadout("Shields", out var so))
		{
			so.LoadItemsOnTo(basePlayer);
			if (!@bool)
			{
				Inventory.EquipItemInSlot(basePlayer, 0);
			}
			else
			{
				Inventory.EquipItemInSlot(basePlayer, -1);
			}
		}
	}
}


[Factory("SSS")]
public class SSS : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static bool enabled = true;

	[ClientVar(Saved = true)]
	public static int quality = 0;

	[ClientVar(Saved = true)]
	public static bool halfres = true;

	[ClientVar(Saved = true)]
	public static float scale = 1f;
}


using System.Linq;
using UnityEngine;

[Factory("stability")]
public class Stability : ConsoleSystem
{
	[ServerVar]
	public static int verbose = 0;

	[ServerVar]
	public static int strikes = 10;

	[ServerVar]
	public static float collapse = 0.05f;

	[ServerVar]
	public static float accuracy = 0.001f;

	[ServerVar]
	public static float stabilityqueue = 9f;

	[ServerVar]
	public static float surroundingsqueue = 3f;

	[ServerVar]
	public static void refresh_stability(Arg args)
	{
		StabilityEntity[] array = BaseNetworkable.serverEntities.OfType<StabilityEntity>().ToArray();
		Debug.Log((object)("Refreshing stability on " + array.Length + " entities..."));
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateStability();
		}
	}
}


public class Steam
{
	[ReplicatedVar(Saved = true, ShowInAdminUI = true)]
	public static bool server_allow_steam_nicknames { get; set; } = true;
}


public class Store
{
}


using UnityEngine;

[Factory("supply")]
public class Supply : ConsoleSystem
{
	private const string path = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";

	[ServerVar]
	public static void drop(Arg arg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Debug.Log((object)"Supply Drop Inbound");
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab");
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).GetComponent<CargoPlane>().InitDropPosition(((Component)basePlayer).transform.position + new Vector3(0f, 10f, 0f));
				baseEntity.Spawn();
			}
		}
	}

	[ServerVar]
	public static void call(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)arg.Player()))
		{
			Debug.Log((object)"Supply Drop Inbound");
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab");
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.Spawn();
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using UnityEngine;

[Factory("system")]
public static class SystemCommands
{
	public static bool appliedManualCpuAffinity;

	[ClientVar]
	[ServerVar]
	public static void cpu_affinity(Arg arg)
	{
		ulong num = 0uL;
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Format is 'cpu_affinity {core,core1-core2,etc}'");
			return;
		}
		string[] array = arg.GetString(0, "").Split(',');
		HashSet<int> hashSet = new HashSet<int>();
		string[] array2 = array;
		foreach (string text in array2)
		{
			if (int.TryParse(text, out var result))
			{
				hashSet.Add(result);
			}
			else
			{
				if (!text.Contains('-'))
				{
					continue;
				}
				string[] array3 = text.Split('-');
				if (array3.Length != 2)
				{
					arg.ReplyWith("Failed to parse section " + text + ", format should be '0-15'");
					continue;
				}
				if (!int.TryParse(array3[0], out var result2) || !int.TryParse(array3[1], out var result3))
				{
					arg.ReplyWith("Core range in section " + text + " are not valid numbers, format should be '0-15'");
					continue;
				}
				if (result2 > result3)
				{
					arg.ReplyWith("Core range in section " + text + " are not ordered from least to greatest, format should be '0-15'");
					continue;
				}
				if (result3 - result2 > 64)
				{
					arg.ReplyWith("Core range in section " + text + " are too big of a range, must be <64");
					return;
				}
				for (int j = result2; j <= result3; j++)
				{
					hashSet.Add(j);
				}
			}
		}
		if (hashSet.Any((int x) => x < 0 || x > 63))
		{
			arg.ReplyWith("Cores provided out of range! Must be in between 0 and 63");
			return;
		}
		for (int k = 0; k < 64; k++)
		{
			if (hashSet.Contains(k))
			{
				num |= (ulong)(1L << k);
			}
		}
		if (num == 0L)
		{
			arg.ReplyWith("No cores provided (bitmask empty)! Format is 'cpu_affinity {core,core1-core2,etc}'");
		}
		else if (SetCpuAffinity(num))
		{
			appliedManualCpuAffinity = true;
			arg.ReplyWith("Successfully changed CPU affinity");
		}
	}

	public static bool SetCpuAffinity(ulong affinityMask)
	{
		try
		{
			Process.GetCurrentProcess().ProcessorAffinity = (IntPtr)(long)affinityMask;
			return true;
		}
		catch (Exception arg)
		{
			Debug.LogWarning((object)$"Unable to set CPU affinity: {arg}");
			return false;
		}
	}

	[ServerVar]
	[ClientVar]
	public static void cpu_priority(Arg arg)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Invalid comparison between Unknown and I4
		if ((int)Application.platform == 1)
		{
			arg.ReplyWith("OSX is not a supported platform");
			return;
		}
		string @string = arg.GetString(0, "");
		ProcessPriorityClass priorityClass;
		switch (@string.Replace("-", "").Replace("_", ""))
		{
		case "belownormal":
			priorityClass = ProcessPriorityClass.BelowNormal;
			break;
		case "normal":
			priorityClass = ProcessPriorityClass.Normal;
			break;
		case "abovenormal":
			priorityClass = ProcessPriorityClass.AboveNormal;
			break;
		case "high":
			priorityClass = ProcessPriorityClass.High;
			break;
		default:
			arg.ReplyWith("Unknown priority '" + @string + "', possible values: below_normal, normal, above_normal, high");
			return;
		}
		try
		{
			Process.GetCurrentProcess().PriorityClass = priorityClass;
		}
		catch (Exception arg2)
		{
			Debug.LogWarning((object)$"Unable to set cpu priority: {arg2}");
			return;
		}
		arg.ReplyWith("Successfully changed cpu priority to " + priorityClass);
	}
}


[Factory("terrain")]
public class Terrain : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static float quality = 100f;
}


[Factory("texture")]
public class Texture : ConsoleSystem
{
}


using UnityEngine;

[Factory("time")]
public class Time : ConsoleSystem
{
	public const int SERVER_DEFAULT_TICKS = 16;

	public const int CLIENT_DEFAULT_TICKS = 32;

	public const string CLIENT_DEFAULT_TICKS_STR = "32";

	[Help("Pause time while loading")]
	[ServerVar]
	public static bool pausewhileloading = true;

	private static int _cl_steps = 32;

	private static int _cl_maxstepsperframe = 2;

	[ServerVar(Help = "Desired physics ticks per second on the server")]
	public static int sv_steps
	{
		get
		{
			return Mathf.RoundToInt(1f / Time.fixedDeltaTime);
		}
		set
		{
			value = Mathf.Clamp(value, 16, 64);
			int num = sv_maxstepsperframe;
			Time.fixedDeltaTime = 1f / (float)value;
			sv_maxstepsperframe = num;
		}
	}

	[ServerVar(Help = "The maximum amount physics ticks per frame on the server. If things are taking too long, time slows down")]
	public static int sv_maxstepsperframe
	{
		get
		{
			return Mathf.RoundToInt(Time.maximumDeltaTime / Time.fixedDeltaTime);
		}
		set
		{
			value = Mathf.Clamp(value, 2, 10);
			Time.maximumDeltaTime = (float)value * Time.fixedDeltaTime;
		}
	}

	[ServerVar]
	[Help("The time scale")]
	public static float timescale
	{
		get
		{
			return Time.timeScale;
		}
		set
		{
			Time.timeScale = value;
		}
	}

	[ReplicatedVar(Help = "Desired physics ticks per second on clients", Default = "32")]
	public static int cl_steps
	{
		get
		{
			return _cl_steps;
		}
		set
		{
			value = Mathf.Clamp(value, 32, 64);
			_cl_steps = value;
			cl_maxstepsperframe = _cl_maxstepsperframe;
		}
	}

	[ReplicatedVar(Help = "The maximum amount physics ticks per frame on clients. If things are taking too long, time slows down", Default = "2")]
	public static int cl_maxstepsperframe
	{
		get
		{
			return _cl_maxstepsperframe;
		}
		set
		{
			value = Mathf.Clamp(value, 2, 10);
			_cl_maxstepsperframe = value;
		}
	}
}


[Factory("tree")]
public class Tree : ConsoleSystem
{
	[ServerVar]
	public static bool global_broadcast;

	[ServerVar]
	public static bool simplified_collider;
}


using UnityEngine;

[Factory("vehicle")]
public class vehicle : ConsoleSystem
{
	[Help("how long until boat corpses despawn (excluding tugboat - use tugboat_corpse_seconds)")]
	[ServerVar]
	public static float boat_corpse_seconds = 300f;

	[ServerVar]
	public static bool disable_wheels_when_sleeping = true;

	[ServerVar(Help = "If true, trains always explode when destroyed, and hitting a barrier always destroys the train immediately. Default: false")]
	public static bool cinematictrains = false;

	[ServerVar(Help = "Determines whether trains stop automatically when there's no-one on them. Default: false")]
	public static bool trainskeeprunning = false;

	[ServerVar(Help = "Determines whether modular cars turn into wrecks when destroyed, or just immediately gib. Default: true")]
	public static bool carwrecks = true;

	[ServerVar(Help = "Determines whether vehicles drop storage items when destroyed. Default: true")]
	public static bool vehiclesdroploot = true;

	[ServerUserVar]
	public static void swapseats(Arg arg)
	{
		int targetSeat = 0;
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || basePlayer.SwapSeatCooldown())
		{
			return;
		}
		BaseMountable mounted = basePlayer.GetMounted();
		if (!((Object)(object)mounted == (Object)null))
		{
			BaseVehicle baseVehicle = ((Component)mounted).GetComponent<BaseVehicle>();
			if ((Object)(object)baseVehicle == (Object)null)
			{
				baseVehicle = mounted.VehicleParent();
			}
			if (!((Object)(object)baseVehicle == (Object)null))
			{
				baseVehicle.SwapSeats(basePlayer, targetSeat);
			}
		}
	}

	[ServerVar]
	public static void fixcars(Arg arg)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Null player.");
			return;
		}
		if (!basePlayer.IsAdmin)
		{
			arg.ReplyWith("Must be an admin to use fixcars.");
			return;
		}
		int @int = arg.GetInt(0, 2);
		@int = Mathf.Clamp(@int, 1, 3);
		BaseVehicle[] array = BaseEntity.Util.FindAll<BaseVehicle>();
		int num = 0;
		BaseVehicle[] array2 = array;
		foreach (BaseVehicle baseVehicle in array2)
		{
			if (baseVehicle.isServer && Vector3.Distance(((Component)baseVehicle).transform.position, ((Component)basePlayer).transform.position) <= 10f && baseVehicle.AdminFixUp(@int))
			{
				num++;
			}
		}
		MLRS[] array3 = BaseEntity.Util.FindAll<MLRS>();
		foreach (MLRS mLRS in array3)
		{
			if (mLRS.isServer && Vector3.Distance(((Component)mLRS).transform.position, ((Component)basePlayer).transform.position) <= 10f && mLRS.AdminFixUp())
			{
				num++;
			}
		}
		DiverPropulsionVehicle[] array4 = BaseEntity.Util.FindAll<DiverPropulsionVehicle>();
		foreach (DiverPropulsionVehicle diverPropulsionVehicle in array4)
		{
			if (diverPropulsionVehicle.isServer && Vector3.Distance(((Component)diverPropulsionVehicle).transform.position, ((Component)basePlayer).transform.position) <= 10f && diverPropulsionVehicle.AdminFixUp())
			{
				num++;
			}
		}
		arg.ReplyWith($"Fixed up {num} vehicles.");
	}

	[ServerVar]
	public static void autohover(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Null player.");
			return;
		}
		if (!basePlayer.IsAdmin)
		{
			arg.ReplyWith("Must be an admin to use autohover.");
			return;
		}
		BaseHelicopter baseHelicopter = basePlayer.GetMountedVehicle() as BaseHelicopter;
		if ((Object)(object)baseHelicopter != (Object)null)
		{
			bool flag = baseHelicopter.ToggleAutoHover(basePlayer);
			arg.ReplyWith($"Toggled auto-hover to {flag}.");
		}
		else
		{
			arg.ReplyWith("Must be mounted in a helicopter first.");
		}
	}

	[ServerVar]
	public static void stop_all_trains(Arg arg)
	{
		TrainEngine[] array = Object.FindObjectsOfType<TrainEngine>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].StopEngine();
		}
		arg.ReplyWith("All trains stopped.");
	}

	[ServerVar]
	public static void killcars(Arg args)
	{
		ModularCar[] array = BaseEntity.Util.FindAll<ModularCar>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
	}

	[ServerVar]
	public static void killpushbikes(Arg args)
	{
		Bike[] array = BaseEntity.Util.FindAll<Bike>();
		foreach (Bike bike in array)
		{
			if (bike.poweredBy == Bike.PoweredBy.Human)
			{
				bike.Kill();
			}
		}
	}

	[ServerVar]
	public static void killmotorbikes(Arg args)
	{
		Bike[] array = BaseEntity.Util.FindAll<Bike>();
		foreach (Bike bike in array)
		{
			if (bike.poweredBy == Bike.PoweredBy.Fuel)
			{
				bike.Kill();
			}
		}
	}

	[ServerVar]
	public static void killminis(Arg args)
	{
		PlayerHelicopter[] array = BaseEntity.Util.FindAll<PlayerHelicopter>();
		foreach (PlayerHelicopter playerHelicopter in array)
		{
			if (((Object)playerHelicopter).name.ToLower().Contains("minicopter"))
			{
				playerHelicopter.Kill();
			}
		}
	}

	[ServerVar]
	public static void killscraphelis(Arg args)
	{
		ScrapTransportHelicopter[] array = BaseEntity.Util.FindAll<ScrapTransportHelicopter>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
	}

	[ServerVar]
	public static void killtrains(Arg args)
	{
		TrainCar[] array = BaseEntity.Util.FindAll<TrainCar>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
	}

	[ServerVar]
	public static void killboats(Arg args)
	{
		BaseBoat[] array = BaseEntity.Util.FindAll<BaseBoat>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
	}

	[ServerVar]
	public static void killdrones(Arg args)
	{
		Drone[] array = BaseEntity.Util.FindAll<Drone>();
		foreach (Drone drone in array)
		{
			if (!(drone is DeliveryDrone))
			{
				drone.Kill();
			}
		}
	}

	[ServerVar(Help = "Print out boat drift status for all boats")]
	public static void boatdriftinfo(Arg args)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		TextTable val = new TextTable();
		val.AddColumn("id");
		val.AddColumn("name");
		val.AddColumn("position");
		val.AddColumn("status");
		val.AddColumn("drift");
		BaseBoat[] array = BaseEntity.Util.FindAll<BaseBoat>();
		BaseBoat[] array2 = array;
		foreach (BaseBoat baseBoat in array2)
		{
			if (baseBoat.IsValid())
			{
				string text = (baseBoat.IsAlive() ? "alive" : "dead");
				string driftStatus = baseBoat.GetDriftStatus();
				string[] obj = new string[5]
				{
					((object)(NetworkableId)(ref baseBoat.net.ID)/*cast due to .constrained prefix*/).ToString(),
					baseBoat.ShortPrefabName,
					null,
					null,
					null
				};
				Vector3 position = ((Component)baseBoat).transform.position;
				obj[2] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
				obj[3] = text;
				obj[4] = driftStatus;
				val.AddRow(obj);
			}
		}
		if (array.Length == 0)
		{
			args.ReplyWith("No boats in world");
		}
		args.ReplyWith(((object)val).ToString());
	}
}


[Factory("vis")]
public class Vis : ConsoleSystem
{
	[Help("Turns on debug display of lerp")]
	[ClientVar]
	public static bool lerp;

	[Help("Turns on debug display of damages")]
	[ServerVar]
	public static bool damage;

	[Help("Turns on debug display of attacks")]
	[ClientVar]
	[ServerVar]
	public static bool attack;

	[ClientVar]
	[ServerVar]
	[Help("Turns on debug display of protection")]
	public static bool protection;

	[ServerVar]
	[Help("Turns on debug display of weakspots")]
	public static bool weakspots;

	[ServerVar]
	[Help("Show trigger entries")]
	public static bool triggers;

	[ServerVar]
	[Help("Turns on debug display of hitboxes")]
	public static bool hitboxes;

	[Help("Turns on debug display of line of sight checks")]
	[ServerVar]
	public static bool lineofsight;

	[ServerVar]
	[Help("Turns on debug display of senses, which are received by Ai")]
	public static bool sense;
}


using UnityEngine;

[Factory("voice")]
public class Voice : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static bool loopback = false;

	private static float _voiceRangeBoostAmount = 50f;

	[ReplicatedVar]
	public static float voiceRangeBoostAmount
	{
		get
		{
			return _voiceRangeBoostAmount;
		}
		set
		{
			_voiceRangeBoostAmount = Mathf.Clamp(value, 0f, 200f);
		}
	}

	[ServerVar(Help = "Enabled/disables voice range boost for a player eg. ToggleVoiceRangeBoost sam 1")]
	public static void ToggleVoiceRangeBoost(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if ((Object)(object)player == (Object)null)
		{
			arg.ReplyWith("Invalid player: " + arg.GetString(0, ""));
			return;
		}
		bool @bool = arg.GetBool(1, false);
		player.SetPlayerFlag(BasePlayer.PlayerFlags.VoiceRangeBoost, @bool);
		arg.ReplyWith($"Set {player.displayName} volume boost to {@bool}");
	}
}


[Factory("water")]
public class Water : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static int quality = 1;

	public static int MaxQuality = 2;

	public static int MinQuality = 0;

	[ClientVar(Saved = true)]
	public static int reflections = 1;

	public static int MaxReflections = 2;

	public static int MinReflections = 0;

	[ClientVar(ClientAdmin = true, Default = "0")]
	public static bool scaled_time = false;
}


using System;
using System.Globalization;
using UnityEngine;

[Factory("weather")]
public class Weather : ConsoleSystem
{
	[ServerVar]
	public static float wetness_rain = 0.4f;

	[ServerVar]
	public static float wetness_snow = 0.2f;

	[ReplicatedVar(Default = "-1")]
	public static float ocean_time = -1f;

	[ReplicatedVar(Default = "1")]
	public static float clear_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 1f;
			}
			return SingletonComponent<Climate>.Instance.Weather.ClearChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.ClearChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float dust_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.DustChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.DustChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float fog_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.FogChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.FogChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float overcast_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.OvercastChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.OvercastChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float storm_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.StormChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.StormChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float rain_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.RainChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.RainChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float rain
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Rain;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Rain = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float wind
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Wind;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Wind = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float thunder
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Thunder;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Thunder = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float rainbow
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Rainbow;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Rainbow = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float fog
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Fogginess;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Fogginess = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_rayleigh
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.RayleighMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.RayleighMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_mie
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.MieMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.MieMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_brightness
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Brightness;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Brightness = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_contrast
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Contrast;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Contrast = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_directionality
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Directionality;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Directionality = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_size
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Size;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Size = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_opacity
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Opacity;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Opacity = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_coverage
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Coverage;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Coverage = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_sharpness
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Sharpness;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Sharpness = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_coloring
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Coloring;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Coloring = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_attenuation
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Attenuation;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Attenuation = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_saturation
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Saturation;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Saturation = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_scattering
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Scattering;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Scattering = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_brightness
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Brightness;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Brightness = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float ocean_scale
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.OceanScale;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.OceanScale = value;
			}
		}
	}

	[ClientVar]
	[ServerVar]
	public static void load(Arg args)
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			return;
		}
		string name = args.GetString(0, "");
		if (string.IsNullOrEmpty(name))
		{
			args.ReplyWith("Weather preset name invalid.");
			return;
		}
		WeatherPreset weatherPreset = Array.Find(SingletonComponent<Climate>.Instance.WeatherPresets, (WeatherPreset x) => StringEx.Contains(((Object)x).name, name, CompareOptions.IgnoreCase));
		if ((Object)(object)weatherPreset == (Object)null)
		{
			args.ReplyWith("Weather preset not found: " + name);
			return;
		}
		SingletonComponent<Climate>.Instance.WeatherOverrides.Set(weatherPreset);
		if (args.IsServerside)
		{
			ServerMgr.SendReplicatedVars("weather.");
		}
	}

	public static WeatherPreset GetWeatherPreset(string withName)
	{
		return Array.Find(SingletonComponent<Climate>.Instance.WeatherPresets, (WeatherPreset x) => StringEx.Contains(((Object)x).name, withName, CompareOptions.IgnoreCase));
	}

	[ClientVar]
	[ServerVar]
	public static void reset(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			SingletonComponent<Climate>.Instance.WeatherOverrides.Reset();
			if (args.IsServerside)
			{
				ServerMgr.SendReplicatedVars("weather.");
			}
		}
	}

	[ClientVar]
	[ServerVar]
	public static void report(Arg args)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			TextTable val = new TextTable();
			val.AddColumn(((Object)SingletonComponent<Climate>.Instance.WeatherStatePrevious).name);
			val.AddColumn("|");
			val.AddColumn(((Object)SingletonComponent<Climate>.Instance.WeatherStateTarget).name);
			val.AddColumn("|");
			val.AddColumn(((Object)SingletonComponent<Climate>.Instance.WeatherStateNext).name);
			int num = Mathf.RoundToInt(SingletonComponent<Climate>.Instance.WeatherStateBlend * 100f);
			if (num < 100)
			{
				val.AddRow(new string[5]
				{
					"fading out (" + (100 - num) + "%)",
					"|",
					"fading in (" + num + "%)",
					"|",
					"up next"
				});
			}
			else
			{
				val.AddRow(new string[5] { "previous", "|", "current", "|", "up next" });
			}
			args.ReplyWith(((object)val).ToString() + Environment.NewLine + ((object)SingletonComponent<Climate>.Instance.WeatherState).ToString());
		}
	}
}


[Factory("workshop")]
public class Workshop : ConsoleSystem
{
	[ServerVar]
	public static void print_approved_skins(Arg arg)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Expected O, but got Unknown
		if (!PlatformService.Instance.IsValid || PlatformService.Instance.ItemDefinitions == null)
		{
			return;
		}
		TextTable val = new TextTable();
		val.AddColumn("name");
		val.AddColumn("itemshortname");
		val.AddColumn("workshopid");
		val.AddColumn("workshopdownload");
		foreach (IPlayerItemDefinition itemDefinition in PlatformService.Instance.ItemDefinitions)
		{
			string name = itemDefinition.Name;
			string itemShortName = itemDefinition.ItemShortName;
			string text = itemDefinition.WorkshopId.ToString();
			string text2 = itemDefinition.WorkshopDownload.ToString();
			val.AddRow(new string[4] { name, itemShortName, text, text2 });
		}
		arg.ReplyWith(arg.HasArg("--json", false) ? val.ToJson(true) : ((object)val).ToString());
	}
}


using System;
using System.IO;
using UnityEngine;

[Factory("world")]
public class World : ConsoleSystem
{
	[ClientVar]
	[ServerVar]
	public static bool cache = true;

	[ClientVar]
	public static bool streaming = true;

	[ServerVar]
	public static string configString = string.Empty;

	[ServerVar]
	public static string configFile = string.Empty;

	[ClientVar]
	[ServerVar]
	public static void monuments(Arg arg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			return;
		}
		TextTable val = new TextTable();
		val.AddColumn("type");
		val.AddColumn("name");
		val.AddColumn("prefab");
		val.AddColumn("pos");
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			string[] obj = new string[4]
			{
				monument.Type.ToString(),
				monument.displayPhrase.translated,
				((Object)monument).name,
				null
			};
			Vector3 position = ((Component)monument).transform.position;
			obj[3] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
			val.AddRow(obj);
		}
		arg.ReplyWith(((object)val).ToString());
	}

	[ServerVar(Clientside = true, Help = "Renders a high resolution PNG of the current map")]
	public static void rendermap(Arg arg)
	{
		float @float = arg.GetFloat(0, 1f);
		int imageWidth;
		int imageHeight;
		Color background;
		byte[] array = MapImageRenderer.Render(out imageWidth, out imageHeight, out background, @float, lossy: false);
		if (array == null)
		{
			arg.ReplyWith("Failed to render the map (is a map loaded now?)");
			return;
		}
		string fullPath = Path.GetFullPath(Path.Combine(Environment.CurrentDirectory, $"map_{World.Size}_{World.Seed}.png"));
		File.WriteAllBytes(fullPath, array);
		arg.ReplyWith("Saved map render to: " + fullPath);
	}

	[ServerVar(Clientside = true, Help = "Renders a PNG of the current map's tunnel network")]
	public static void rendertunnels(Arg arg)
	{
		RenderMapLayerToFile(arg, "tunnels", MapLayer.TrainTunnels);
	}

	[ServerVar(Clientside = true, Help = "Renders a PNG of the current map's underwater labs, for a specific floor")]
	public static void renderlabs(Arg arg)
	{
		int underwaterLabFloorCount = MapLayerRenderer.GetOrCreate().GetUnderwaterLabFloorCount();
		int @int = arg.GetInt(0, 0);
		if (@int < 0 || @int >= underwaterLabFloorCount)
		{
			arg.ReplyWith($"Floor number must be between 0 and {underwaterLabFloorCount}");
		}
		else
		{
			RenderMapLayerToFile(arg, $"labs_{@int}", (MapLayer)(1 + @int));
		}
	}

	private static void RenderMapLayerToFile(Arg arg, string name, MapLayer layer)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Expected O, but got Unknown
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			MapLayerRenderer orCreate = MapLayerRenderer.GetOrCreate();
			orCreate.Render(layer);
			string fullPath = Path.GetFullPath(Path.Combine(Environment.CurrentDirectory, $"{name}_{World.Size}_{World.Seed}.png"));
			RenderTexture targetTexture = orCreate.renderCamera.targetTexture;
			Texture2D val = new Texture2D(((Texture)targetTexture).width, ((Texture)targetTexture).height);
			RenderTexture active = RenderTexture.active;
			try
			{
				RenderTexture.active = targetTexture;
				val.ReadPixels(new Rect(0f, 0f, (float)((Texture)targetTexture).width, (float)((Texture)targetTexture).height), 0, 0);
				val.Apply();
				File.WriteAllBytes(fullPath, ImageConversion.EncodeToPNG(val));
			}
			finally
			{
				RenderTexture.active = active;
				Object.DestroyImmediate((Object)(object)val);
			}
			arg.ReplyWith("Saved " + name + " render to: " + fullPath);
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)ex);
			arg.ReplyWith("Failed to render " + name);
		}
	}
}


using UnityEngine;

[Factory("xmas")]
public class XMas : ConsoleSystem
{
	private const string path = "assets/prefabs/misc/xmas/xmasrefill.prefab";

	[ServerVar]
	public static bool enabled = false;

	[ServerVar]
	public static float spawnRange = 40f;

	[ServerVar]
	public static int spawnAttempts = 5;

	[ServerVar]
	public static int giftsPerPlayer = 2;

	[ServerVar]
	public static void refill(Arg arg)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/misc/xmas/xmasrefill.prefab");
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			baseEntity.Spawn();
		}
	}
}


public static class Numlock
{
	public static bool IsOn => true;

	public static void TurnOn()
	{
	}
}


using System;
using UnityEngine;

public class GC : MonoBehaviour, IClientComponent
{
	public static int gcLowerBounds = 64;

	public static int gcDefaultValue = 256;

	public static int gcEditorDefaultValue = 4096;

	public static bool Enabled => true;

	public static void Collect()
	{
		GC.Collect();
	}

	public static int GetSafeGCValue(int val)
	{
		return Mathf.Clamp(val, gcLowerBounds, Mathf.Min(4096, SystemInfo.systemMemorySize / 8));
	}

	public static long GetTotalMemory()
	{
		return GC.GetTotalMemory(forceFullCollection: false) / 1048576;
	}

	public static int CollectionCount()
	{
		return GC.CollectionCount(0);
	}
}


public enum DamageType
{
	Generic,
	Hunger,
	Thirst,
	Cold,
	Drowned,
	Heat,
	Bleeding,
	Poison,
	Suicide,
	Bullet,
	Slash,
	Blunt,
	Fall,
	Radiation,
	Bite,
	Stab,
	Explosion,
	RadiationExposure,
	ColdExposure,
	Decay,
	ElectricShock,
	Arrow,
	AntiVehicle,
	Collision,
	Fun_Water,
	BeeSting,
	LAST
}


using System.Collections.Generic;
using Rust;

public class DamageTypeList
{
	public float[] types = new float[26];

	public void Set(DamageType index, float amount)
	{
		types[(int)index] = amount;
	}

	public float Get(DamageType index)
	{
		return types[(int)index];
	}

	public void Add(DamageType index, float amount)
	{
		Set(index, Get(index) + amount);
	}

	public void Scale(DamageType index, float amount)
	{
		Set(index, Get(index) * amount);
	}

	public bool Has(DamageType index)
	{
		return Get(index) > 0f;
	}

	public float Total()
	{
		float num = 0f;
		for (int i = 0; i < types.Length; i++)
		{
			float num2 = types[i];
			if (!float.IsNaN(num2) && !float.IsInfinity(num2))
			{
				num += num2;
			}
		}
		return num;
	}

	public void Clear()
	{
		for (int i = 0; i < types.Length; i++)
		{
			types[i] = 0f;
		}
	}

	public void Add(List<DamageTypeEntry> entries)
	{
		foreach (DamageTypeEntry entry in entries)
		{
			Add(entry.type, entry.amount);
		}
	}

	public void ScaleAll(float amount)
	{
		for (int i = 0; i < types.Length; i++)
		{
			Scale((DamageType)i, amount);
		}
	}

	public DamageType GetMajorityDamageType()
	{
		int result = 0;
		float num = 0f;
		for (int i = 0; i < types.Length; i++)
		{
			float num2 = types[i];
			if (!float.IsNaN(num2) && !float.IsInfinity(num2) && !(num2 < num))
			{
				result = i;
				num = num2;
			}
		}
		return (DamageType)result;
	}

	public bool Contains(DamageType damage)
	{
		if (damage < DamageType.Generic || (int)damage >= types.Length)
		{
			return false;
		}
		float num = types[(int)damage];
		if (!float.IsNaN(num) && !float.IsInfinity(num))
		{
			return num > 0f;
		}
		return false;
	}

	public bool IsMeleeType()
	{
		return GetMajorityDamageType().IsMeleeType();
	}

	public bool IsBleedCausing()
	{
		return GetMajorityDamageType().IsBleedCausing();
	}

	public bool IsConsideredAnAttack()
	{
		return GetMajorityDamageType().IsConsideredAnAttack();
	}

	public DamageTypeList Clone()
	{
		DamageTypeList damageTypeList = new DamageTypeList();
		for (int i = 0; i < types.Length; i++)
		{
			damageTypeList.types[i] = types[i];
		}
		return damageTypeList;
	}
}


using System;
using Rust;

[Serializable]
public class DamageTypeEntry
{
	public DamageType type;

	public float amount;
}


using Rust;

public static class DamageTypeEx
{
	public static bool IsMeleeType(this DamageType damageType)
	{
		if (damageType != DamageType.Blunt && damageType != DamageType.Slash)
		{
			return damageType == DamageType.Stab;
		}
		return true;
	}

	public static bool IsBleedCausing(this DamageType damageType)
	{
		if (damageType != DamageType.Bite && damageType != DamageType.Slash && damageType != DamageType.Stab && damageType != DamageType.Bullet)
		{
			return damageType == DamageType.Arrow;
		}
		return true;
	}

	public static bool IsConsideredAnAttack(this DamageType damageType)
	{
		if (damageType != DamageType.Decay)
		{
			return damageType != DamageType.Collision;
		}
		return false;
	}

	public static bool InterruptsRestraintMinigame(this DamageType damageType)
	{
		if (damageType != DamageType.Fall && damageType != DamageType.Blunt && damageType != DamageType.Slash && damageType != DamageType.Stab && damageType != DamageType.Bullet && damageType != DamageType.Explosion)
		{
			return damageType == DamageType.Arrow;
		}
		return true;
	}
}


using ConVar;
using UnityEngine;

internal static class GameInfo
{
	internal static bool IsOfficialServer
	{
		get
		{
			if (Application.isEditor)
			{
				return true;
			}
			return Server.official;
		}
	}

	internal static bool HasAchievements => IsOfficialServer;
}


public static class Defines
{
	public static class Connection
	{
		public const byte mode_steam = 228;
	}

	public static class Tags
	{
		public const string NotPlayerUsable = "Not Player Usable";
	}

	public static uint appID = 252490u;

	public const string resourceFolder = "assets/bundled";
}


public static class Connection
{
	public const byte mode_steam = 228;
}


public static class Tags
{
	public const string NotPlayerUsable = "Not Player Usable";
}


using UnityEngine.SceneManagement;

public static class Generic
{
	private static Scene _batchingScene;

	public static Scene BatchingScene
	{
		get
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!((Scene)(ref _batchingScene)).IsValid())
			{
				_batchingScene = SceneManager.CreateScene("Batching");
			}
			return _batchingScene;
		}
	}
}


using UnityEngine.SceneManagement;

public static class Server
{
	public const float UseDistance = 3f;

	private static Scene _entityScene;

	public static Scene EntityScene
	{
		get
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!((Scene)(ref _entityScene)).IsValid())
			{
				_entityScene = SceneManager.CreateScene("Server Entities");
			}
			return _entityScene;
		}
	}
}


using Facepunch;
using ProtoBuf.Nexus;

public interface INexusRequestHandler : IPooled
{
	Response Response { get; }

	void Execute();
}


using System;
using Facepunch;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public abstract class BaseNexusRequestHandler<T> : INexusRequestHandler, IPooled where T : class
{
	private bool _fireAndForget;

	protected NexusZoneDetails FromZone { get; private set; }

	protected Uuid RequestId { get; private set; }

	protected T Request { get; private set; }

	public Response Response { get; private set; }

	public void Initialize(NexusZoneDetails fromZone, Uuid id, bool fireAndForget, T request)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		FromZone = fromZone;
		RequestId = id;
		Request = request;
		_fireAndForget = fireAndForget;
	}

	public void EnterPool()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		FromZone = null;
		RequestId = Uuid.Empty;
		Request = null;
		Response = null;
		_fireAndForget = false;
		Reset();
	}

	public void LeavePool()
	{
	}

	public void Execute()
	{
		try
		{
			Handle();
			if (Response == null)
			{
				SendSuccess();
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			if (Response != null)
			{
				Debug.LogError((object)"Nexus RPC handler threw an exception but already sent a response!");
			}
			else
			{
				SendError(ex.Message);
			}
		}
	}

	protected abstract void Handle();

	protected virtual void Reset()
	{
	}

	protected void SendSuccess()
	{
		SendResult(success: true);
	}

	protected void SendSuccess(Response response)
	{
		SendResult(success: true, response);
	}

	protected void SendResult(bool success)
	{
		SendResult(success, NewResponse());
	}

	protected void SendResult(bool success, Response response)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (_fireAndForget)
		{
			response.Dispose();
			return;
		}
		if (Response != null)
		{
			response.Dispose();
			throw new InvalidOperationException("Already sent a response for this nexus RPC invocation!");
		}
		response.id = RequestId;
		response.status = Pool.Get<Status>();
		response.status.success = success;
		Response = response;
	}

	protected void SendError(string message)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (!_fireAndForget)
		{
			if (Response != null)
			{
				throw new InvalidOperationException("Already sent a response for this nexus RPC invocation!");
			}
			Response val = Pool.Get<Response>();
			val.id = RequestId;
			val.status = Pool.Get<Status>();
			val.status.success = false;
			val.status.errorMessage = message;
			Response = val;
		}
	}

	protected static Response NewResponse()
	{
		return Pool.Get<Response>();
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class ClanChatBatchHandler : BaseNexusRequestHandler<ClanChatBatchRequest>
{
	protected override void Handle()
	{
		if (!(ClanManager.ServerInstance.Backend is NexusClanBackend nexusClanBackend))
		{
			Debug.LogError((object)"Received a clan chat batch but this server isn't using the nexus clan backend!");
		}
		else
		{
			nexusClanBackend.HandleClanChatBatch(base.Request);
		}
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;

public class DestroyBagHandler : BaseNexusRequestHandler<SleepingBagDestroyRequest>
{
	protected override void Handle()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		SleepingBag.DestroyBag(base.Request.userId, base.Request.sleepingBagId);
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class FerryRetireHandler : BaseNexusRequestHandler<FerryRetireRequest>
{
	protected override void Handle()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NexusFerry nexusFerry = NexusFerry.Get(base.Request.entityId, base.Request.timestamp);
		if ((Object)(object)nexusFerry != (Object)null)
		{
			nexusFerry.Retire();
		}
		SendSuccess();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class FerryStatusHandler : BaseNexusRequestHandler<FerryStatusRequest>
{
	protected override void Handle()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		FerryStatusResponse val = Pool.Get<FerryStatusResponse>();
		val.statuses = Pool.Get<List<FerryStatus>>();
		Enumerator<NexusFerry> enumerator = NexusFerry.All.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				NexusFerry current = enumerator.Current;
				if (!((Object)(object)current == (Object)null))
				{
					FerryStatus status = current.GetStatus();
					val.statuses.Add(status);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Response val2 = Pool.Get<Response>();
		val2.ferryStatus = val;
		SendSuccess(val2);
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class FerryUpdateScheduleHandler : BaseNexusRequestHandler<FerryUpdateScheduleRequest>
{
	protected override void Handle()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NexusFerry nexusFerry = NexusFerry.Get(base.Request.entityId, base.Request.timestamp);
		if ((Object)(object)nexusFerry != (Object)null)
		{
			nexusFerry.UpdateSchedule(base.Request.schedule);
		}
		SendSuccess();
	}
}


using ConVar;
using Facepunch;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;

public class PingHandler : BaseNexusRequestHandler<PingRequest>
{
	protected override void Handle()
	{
		Response val = BaseNexusRequestHandler<PingRequest>.NewResponse();
		val.ping = Pool.Get<PingResponse>();
		val.ping.players = BasePlayer.activePlayerList.Count;
		val.ping.maxPlayers = Server.maxplayers;
		val.ping.queuedPlayers = SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued;
		SendSuccess(val);
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;

public class PlayerManifestHandler : BaseNexusRequestHandler<PlayerManifestRequest>
{
	protected override void Handle()
	{
		NexusServer.AddZonePlayerManifest(base.FromZone.Key, base.Request.userIds);
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class RespawnAtBagHandler : BaseNexusRequestHandler<SleepingBagRespawnRequest>
{
	protected override void Handle()
	{
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = BasePlayer.FindByID(base.Request.userId) ?? BasePlayer.FindSleeping(base.Request.userId);
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsConnected)
			{
				basePlayer.Kick("You're apparently respawning from a another zone - contact developers!");
			}
			basePlayer.Kill();
		}
		BasePlayer basePlayer2 = SingletonComponent<ServerMgr>.Instance.SpawnNewPlayer(null);
		basePlayer2.userID = base.Request.userId;
		basePlayer2.UserIDString = base.Request.userId.ToString();
		basePlayer2.displayName = basePlayer2.UserIDString;
		basePlayer2.SetPlayerFlag(BasePlayer.PlayerFlags.LoadingAfterTransfer, b: true);
		if (!SleepingBag.TrySpawnPlayer(basePlayer2, base.Request.sleepingBagId, out var errorMessage))
		{
			basePlayer2.Kill();
			SendError(errorMessage);
		}
		if (basePlayer2.isMounted)
		{
			basePlayer2.DisableTransferProtection();
		}
		else if (!basePlayer2.isMounted)
		{
			basePlayer2.SetPlayerFlag(BasePlayer.PlayerFlags.LoadingAfterTransfer, b: false);
		}
		basePlayer2.LoadSecondaryData(base.Request.secondaryData);
		basePlayer2.LoadClanInfo();
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;

public class SpawnOptionsHandler : BaseNexusRequestHandler<SpawnOptionsRequest>
{
	protected override void Handle()
	{
		Response val = BaseNexusRequestHandler<SpawnOptionsRequest>.NewResponse();
		val.spawnOptions = Pool.Get<SpawnOptionsResponse>();
		val.spawnOptions.spawnOptions = Pool.Get<List<SpawnOptions>>();
		BasePlayer.GetRespawnOptionsForPlayer(val.spawnOptions.spawnOptions, base.Request.userId);
		SendSuccess(val);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using ProtoBuf;
using ProtoBuf.Nexus;
using Rust;
using Rust.Nexus.Handlers;
using UnityEngine;

public class TransferHandler : BaseNexusRequestHandler<TransferRequest>
{
	private static readonly Dictionary<ulong, ulong> UidMapping = new Dictionary<ulong, ulong>();

	private static readonly Dictionary<NetworkableId, Entity> UidToEntity = new Dictionary<NetworkableId, Entity>();

	private static readonly Dictionary<BaseEntity, Entity> EntityToSpawn = new Dictionary<BaseEntity, Entity>();

	private static readonly Dictionary<ulong, BasePlayer> SpawnedPlayers = new Dictionary<ulong, BasePlayer>();

	private static readonly List<string> PlayerIds = new List<string>();

	private static readonly List<NetworkableId> EntitiesToProtect = new List<NetworkableId>();

	private static readonly Dictionary<ulong, RelationshipManager.PlayerTeam> TeamMapping = new Dictionary<ulong, RelationshipManager.PlayerTeam>();

	protected override void Handle()
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		UidMapping.Clear();
		base.Request.InspectUids((UidInspector<ulong>)UpdateWithNewUid);
		UidToEntity.Clear();
		PlayerIds.Clear();
		EntitiesToProtect.Clear();
		foreach (Entity entity in base.Request.entities)
		{
			UidToEntity.Add(entity.baseNetworkable.uid, entity);
			if (entity.basePlayer != null)
			{
				ulong userid = entity.basePlayer.userid;
				PlayerIds.Add(userid.ToString("G"));
				BasePlayer basePlayer = BasePlayer.FindByID(userid) ?? BasePlayer.FindSleeping(userid);
				if ((Object)(object)basePlayer != (Object)null)
				{
					if (basePlayer.IsConnected)
					{
						basePlayer.Kick("Player transfer is overwriting you - contact developers!");
					}
					basePlayer.Kill();
				}
				entity.basePlayer.currentTeam = 0uL;
				RelationshipManager.ServerInstance.FindPlayersTeam(userid)?.RemovePlayer(userid);
				if ((entity.basePlayer.playerFlags & 0x10) == 0)
				{
					BasePlayer basePlayer2 = entity.basePlayer;
					basePlayer2.playerFlags |= 0x2000000;
				}
				if (entity.basePlayer.loadingTimeout <= 0f || entity.basePlayer.loadingTimeout > Nexus.loadingTimeout)
				{
					entity.basePlayer.loadingTimeout = Nexus.loadingTimeout;
				}
			}
			if (entity.baseCombat != null && entity.baseNetworkable != null)
			{
				EntitiesToProtect.Add(entity.baseNetworkable.uid);
			}
		}
		RepositionEntitiesFromTransfer();
		SpawnedPlayers.Clear();
		SpawnEntities(SpawnedPlayers);
		foreach (NetworkableId item in EntitiesToProtect)
		{
			if (BaseNetworkable.serverEntities.Find(item) is BaseEntity baseEntity)
			{
				baseEntity.EnableTransferProtection();
			}
		}
		TeamMapping.Clear();
		foreach (PlayerSecondaryData secondaryDatum in base.Request.secondaryData)
		{
			if (!SpawnedPlayers.TryGetValue(secondaryDatum.userId, out var value))
			{
				Debug.LogError((object)$"Got secondary data for {secondaryDatum.userId} but they were not spawned in the transfer");
				continue;
			}
			value.LoadSecondaryData(secondaryDatum);
			if (secondaryDatum.isTeamLeader && secondaryDatum.teamId != 0L && !TeamMapping.ContainsKey(secondaryDatum.teamId))
			{
				RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.CreateTeam();
				playerTeam.teamLeader = value.userID;
				playerTeam.AddPlayer(value);
				TeamMapping.Add(secondaryDatum.teamId, playerTeam);
			}
		}
		foreach (PlayerSecondaryData secondaryDatum2 in base.Request.secondaryData)
		{
			if (SpawnedPlayers.TryGetValue(secondaryDatum2.userId, out var value2) && secondaryDatum2.teamId != 0L && !secondaryDatum2.isTeamLeader)
			{
				if (TeamMapping.TryGetValue(secondaryDatum2.teamId, out var value3))
				{
					value3.AddPlayer(value2);
					continue;
				}
				RelationshipManager.PlayerTeam playerTeam2 = RelationshipManager.ServerInstance.CreateTeam();
				playerTeam2.teamLeader = value2.userID;
				playerTeam2.AddPlayer(value2);
				TeamMapping.Add(secondaryDatum2.teamId, playerTeam2);
			}
		}
		if (PlayerIds.Count > 0)
		{
			CompleteTransfers();
		}
		static void UpdateWithNewUid(UidType type, ref ulong prevUid)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			if ((int)type == 3)
			{
				prevUid = 0uL;
			}
			else if (prevUid != 0L)
			{
				if (!UidMapping.TryGetValue(prevUid, out var value4))
				{
					value4 = Net.sv.TakeUID();
					UidMapping.Add(prevUid, value4);
				}
				prevUid = value4;
			}
		}
	}

	private static async void CompleteTransfers()
	{
		try
		{
			await NexusServer.ZoneClient.CompleteTransfers((IEnumerable<string>)PlayerIds);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private void RepositionEntitiesFromTransfer()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		Entity obj = base.Request.entities[0];
		Vector3 pos = obj.baseEntity.pos;
		Quaternion val = Quaternion.Euler(obj.baseEntity.rot);
		(Vector3 Position, Quaternion Rotation, bool PreserveY) tuple = ZoneController.Instance.ChooseTransferDestination(base.FromZone.Key, base.Request.method, base.Request.from, base.Request.to, pos, val);
		var (val2, val3, _) = tuple;
		if (tuple.PreserveY)
		{
			val2.y = pos.y;
		}
		Vector3 val4 = val2 - pos;
		Quaternion val5 = Quaternion.Inverse(val) * val3;
		foreach (Entity entity in base.Request.entities)
		{
			if (entity.baseEntity == null)
			{
				continue;
			}
			if (entity.parent != null && ((NetworkableId)(ref entity.parent.uid)).IsValid)
			{
				if (!UidToEntity.TryGetValue(entity.parent.uid, out var _))
				{
					Debug.LogError((object)$"Transferred entity (ID={entity.baseNetworkable.uid}) has a parent set but it wasn't found in the transfer! The parent is required to correctly restore this entity's position!");
				}
				if (((Vector3)(ref entity.baseEntity.pos)).magnitude > 100f)
				{
					Debug.LogError((object)$"Transferred entity (ID={entity.baseNetworkable.uid}) has a valid parent (ID={entity.parent.uid}) but its position ({entity.baseEntity.pos}) doesn't seem to be in local space! This will probably not work properly!");
				}
			}
			else
			{
				BaseEntity baseEntity = entity.baseEntity;
				baseEntity.pos += val4;
				BaseEntity baseEntity2 = entity.baseEntity;
				Quaternion val6 = Quaternion.Euler(entity.baseEntity.rot) * val5;
				baseEntity2.rot = ((Quaternion)(ref val6)).eulerAngles;
			}
		}
	}

	private void SpawnEntities(Dictionary<ulong, BasePlayer> players)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		Application.isLoadingSave = true;
		try
		{
			EntityToSpawn.Clear();
			foreach (Entity entity in base.Request.entities)
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(StringPool.Get(entity.baseNetworkable.prefabID), entity.baseEntity.pos, Quaternion.Euler(entity.baseEntity.rot));
				if ((Object)(object)baseEntity != (Object)null)
				{
					baseEntity.InitLoad(entity.baseNetworkable.uid);
					baseEntity.PreServerLoad();
					EntityToSpawn.Add(baseEntity, entity);
				}
			}
			foreach (KeyValuePair<BaseEntity, Entity> item in EntityToSpawn)
			{
				BaseEntity key = item.Key;
				if (!((Object)(object)key == (Object)null))
				{
					key.Spawn();
					key.Load(new BaseNetworkable.LoadInfo
					{
						fromDisk = true,
						fromTransfer = true,
						msg = item.Value
					});
				}
			}
			foreach (KeyValuePair<BaseEntity, Entity> item2 in EntityToSpawn)
			{
				BaseEntity key2 = item2.Key;
				if (!((Object)(object)key2 == (Object)null))
				{
					key2.UpdateNetworkGroup();
					key2.PostServerLoad();
					if (key2 is BasePlayer basePlayer)
					{
						players[basePlayer.userID] = basePlayer;
					}
				}
			}
		}
		finally
		{
			Application.isLoadingSave = false;
		}
	}
}


using Rust.Water5;
using Unity.Mathematics;
using UnityEngine;

public struct OceanDisplacementShort3
{
	private const float precision = 20f;

	private const float float2short = 32766f;

	private const float short2float = 3.051944E-05f;

	public short x;

	public short y;

	public short z;

	public static implicit operator Vector3(OceanDisplacementShort3 v)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result = default(Vector3);
		result.x = 3.051944E-05f * (float)v.x * 20f;
		result.y = 3.051944E-05f * (float)v.y * 20f;
		result.z = 3.051944E-05f * (float)v.z * 20f;
		return result;
	}

	public static implicit operator OceanDisplacementShort3(Vector3 v)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		OceanDisplacementShort3 result = default(OceanDisplacementShort3);
		result.x = (short)(v.x / 20f * 32766f + 0.5f);
		result.y = (short)(v.y / 20f * 32766f + 0.5f);
		result.z = (short)(v.z / 20f * 32766f + 0.5f);
		return result;
	}

	public static implicit operator OceanDisplacementShort3(float3 v)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		OceanDisplacementShort3 result = default(OceanDisplacementShort3);
		result.x = (short)(v.x / 20f * 32766f + 0.5f);
		result.y = (short)(v.y / 20f * 32766f + 0.5f);
		result.z = (short)(v.z / 20f * 32766f + 0.5f);
		return result;
	}

	public static implicit operator float3(OceanDisplacementShort3 v)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		float3 result = default(float3);
		result.x = 3.051944E-05f * (float)v.x * 20f;
		result.y = 3.051944E-05f * (float)v.y * 20f;
		result.z = 3.051944E-05f * (float)v.z * 20f;
		return result;
	}
}


using System;
using Rust.Water5;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

internal struct NativeOceanDisplacementShort3 : IDisposable
{
	private NativeArray<OceanDisplacementShort3> _arr;

	private int spectrumCount;

	private int frameCount;

	public OceanDisplacementShort3 this[int x, int y, int z]
	{
		get
		{
			return _arr[z * spectrumCount * frameCount + y * spectrumCount + x];
		}
		set
		{
			_arr[z * spectrumCount * frameCount + y * spectrumCount + x] = value;
		}
	}

	public int Length => _arr.Length;

	public static NativeOceanDisplacementShort3 Create(int x, int y, int z)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		NativeOceanDisplacementShort3 result = default(NativeOceanDisplacementShort3);
		result._arr = new NativeArray<OceanDisplacementShort3>(x * y * z, (Allocator)4, (NativeArrayOptions)0);
		result.spectrumCount = x;
		result.frameCount = y;
		return result;
	}

	public static NativeOceanDisplacementShort3 Create(OceanDisplacementShort3[,,] simData)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		NativeOceanDisplacementShort3 result = default(NativeOceanDisplacementShort3);
		result._arr = new NativeArray<OceanDisplacementShort3>(simData.Length, (Allocator)4, (NativeArrayOptions)1);
		result.spectrumCount = simData.GetLength(0);
		result.frameCount = simData.GetLength(1);
		for (int i = 0; i < result.spectrumCount; i++)
		{
			for (int j = 0; j < result.frameCount; j++)
			{
				for (int k = 0; k < simData.GetLength(2); k++)
				{
					result._arr[i * result.spectrumCount + j * result.frameCount + k] = simData[i, j, k];
				}
			}
		}
		return result;
	}

	public unsafe OceanDisplacementShort3* GetUnsafePtr()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		if (!_arr.IsCreated)
		{
			return null;
		}
		return (OceanDisplacementShort3*)NativeArrayUnsafeUtility.GetUnsafePtr<OceanDisplacementShort3>(_arr);
	}

	public ReadOnly<OceanDisplacementShort3> GetNativeRawReadOnly()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return _arr.AsReadOnly();
	}

	public NativeArray<OceanDisplacementShort3> GetNativeRaw()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _arr;
	}

	public void Dispose()
	{
		_arr.Dispose();
	}
}


using System;
using System.Runtime.CompilerServices;
using Rust.Water5;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Assertions;

public class OceanSimulation : IDisposable
{
	public const int octaveCount = 3;

	public const int simulationSize = 256;

	public const int physicsSimulationSize = 256;

	public const int physicsFrameRate = 4;

	public const int physicsLooptime = 18;

	public const int physicsFrameCount = 72;

	public const float phsyicsDeltaTime = 0.25f;

	public const float oneOverPhysicsSimulationSize = 0.00390625f;

	public const int physicsFrameSize = 65536;

	public const int physicsSpectrumOffset = 4718592;

	private OceanSettings oceanSettings;

	private float[] spectrumRanges;

	private float distanceAttenuationFactor;

	private float depthAttenuationFactor;

	private static float oneOverOctave0Scale;

	private static float[] beaufortValues;

	private int spectrum0;

	private int spectrum1;

	private float spectrumBlend;

	private int frame0;

	private int frame1;

	private float frameBlend;

	private float currentTime;

	private float prevUpdateComputeTime;

	private float deltaTime;

	private NativeOceanDisplacementShort3 nativeSimData;

	private GetHeightBatchedJob _cachedBatchJob;

	private GetHeightsJobIndirect _heightsJobIndirect;

	private NativeArray<float3> _batchPositionQueryArr;

	public int Spectrum0 => spectrum0;

	public int Spectrum1 => spectrum1;

	public float SpectrumBlend => spectrumBlend;

	public int Frame0 => frame0;

	public int Frame1 => frame1;

	public float FrameBlend => frameBlend;

	public OceanSimulation(OceanSettings oceanSettings)
	{
		this.oceanSettings = oceanSettings;
		oneOverOctave0Scale = 1f / oceanSettings.octaveScales[0];
		beaufortValues = new float[oceanSettings.spectrumSettings.Length];
		for (int i = 0; i < oceanSettings.spectrumSettings.Length; i++)
		{
			beaufortValues[i] = oceanSettings.spectrumSettings[i].beaufort;
		}
		nativeSimData = oceanSettings.LoadNativeSimData();
		spectrumRanges = oceanSettings.spectrumRanges;
		depthAttenuationFactor = oceanSettings.depthAttenuationFactor;
		distanceAttenuationFactor = oceanSettings.distanceAttenuationFactor;
		_cachedBatchJob = new GetHeightBatchedJob
		{
			SimData = nativeSimData
		};
		_heightsJobIndirect = new GetHeightsJobIndirect
		{
			SimData = nativeSimData
		};
	}

	public void Update(float time, float dt, float beaufort)
	{
		currentTime = time % 18f;
		deltaTime = dt;
		FindFrames(currentTime, out frame0, out frame1, out frameBlend);
		FindSpectra(beaufort, out spectrum0, out spectrum1, out spectrumBlend);
	}

	private static void FindSpectra(float beaufort, out int spectrum0, out int spectrum1, out float spectrumT)
	{
		beaufort = Mathf.Clamp(beaufort, 0f, 10f);
		spectrum0 = (spectrum1 = 0);
		spectrumT = 0f;
		for (int i = 1; i < beaufortValues.Length; i++)
		{
			float num = beaufortValues[i - 1];
			float num2 = beaufortValues[i];
			if (beaufort >= num && beaufort <= num2)
			{
				spectrum0 = i - 1;
				spectrum1 = i;
				spectrumT = math.remap(num, num2, 0f, 1f, beaufort);
				break;
			}
		}
	}

	public static void FindFrames(float time, out int frame0, out int frame1, out float frameBlend)
	{
		frame0 = (int)math.floor(time * 4f);
		frame1 = (int)math.floor(time * 4f);
		frame1 = (frame1 + 1) % 72;
		frameBlend = math.remap((float)frame0 * 0.25f, (float)(frame0 + 1) * 0.25f, 0f, 1f, time);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Trace(Ray ray, float maxDist, out Vector3 result)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Lerp(spectrumRanges[spectrum0], spectrumRanges[spectrum1], spectrumBlend);
		if (num <= 0.1f)
		{
			Plane val = default(Plane);
			((Plane)(ref val))..ctor(Vector3.up, -0f);
			float num2 = default(float);
			if (((Plane)(ref val)).Raycast(ray, ref num2) && num2 < maxDist)
			{
				result = ((Ray)(ref ray)).GetPoint(num2);
				return true;
			}
			result = Vector3.zero;
			return false;
		}
		float num3 = 0f - num;
		Vector3 point = ((Ray)(ref ray)).GetPoint(maxDist);
		if (((Ray)(ref ray)).origin.y > num && point.y > num)
		{
			result = Vector3.zero;
			return false;
		}
		if (((Ray)(ref ray)).origin.y < num3 && point.y < num3)
		{
			result = Vector3.zero;
			return false;
		}
		Vector3 val2 = ((Ray)(ref ray)).origin;
		Vector3 direction = ((Ray)(ref ray)).direction;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 2f / (math.abs(direction.y) + 1f);
		result = val2;
		if (direction.y <= -0.99f)
		{
			result.y = GetHeight(val2);
			return math.lengthsq(float3.op_Implicit(result - val2)) < maxDist * maxDist;
		}
		if (val2.y >= num + 0f)
		{
			num5 = (num4 = (0f - (val2.y - num - 0f)) / direction.y);
			val2 += num4 * direction;
			if (num5 >= maxDist)
			{
				result = Vector3.zero;
				return false;
			}
		}
		int num7 = 0;
		while (true)
		{
			float height = GetHeight(val2);
			num4 = num6 * Mathf.Abs(val2.y - height - 0f);
			val2 += num4 * direction;
			num5 += num4;
			if (num7 >= 16 || num4 < 0.1f)
			{
				break;
			}
			if (num5 >= maxDist)
			{
				return false;
			}
			num7++;
		}
		if (num4 < 0.1f && num5 >= 0f)
		{
			result = val2;
			return true;
		}
		if (direction.y < 0f)
		{
			num4 = (0f - (val2.y + num - 0f)) / direction.y;
			Vector3 val3 = val2;
			Vector3 val4 = val2 + num4 * ((Ray)(ref ray)).direction;
			for (int i = 0; i < 16; i++)
			{
				val2 = (val3 + val4) * 0.5f;
				float height2 = GetHeight(val2);
				if (val2.y - height2 - 0f > 0f)
				{
					val3 = val2;
				}
				else
				{
					val4 = val2;
				}
				if (math.abs(val2.y - height2) < 0.1f)
				{
					val2.y = height2;
					break;
				}
			}
			result = val2;
			return true;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float MinLevel()
	{
		return 0f - Mathf.Lerp(spectrumRanges[spectrum0], spectrumRanges[spectrum1], spectrumBlend);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float MaxLevel()
	{
		return Mathf.Lerp(spectrumRanges[spectrum0], spectrumRanges[spectrum1], spectrumBlend);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float GetHeight(Vector3[,,] simData, Vector3 position, float time, float beaufort, float distAttenFactor, float depthAttenFactor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Position.x;
		float z = TerrainMeta.Position.z;
		float x2 = TerrainMeta.OneOverSize.x;
		float z2 = TerrainMeta.OneOverSize.z;
		float num = (position.x - x) * x2;
		float num2 = (position.z - z) * z2;
		Vector2 uv = default(Vector2);
		((Vector2)(ref uv))..ctor(num, num2);
		float num3 = (((Object)(object)TerrainTexturing.Instance != (Object)null) ? TerrainTexturing.Instance.GetCoarseDistanceToShore(uv) : 0f);
		float num4 = (((Object)(object)TerrainMeta.HeightMap != (Object)null) ? TerrainMeta.HeightMap.GetHeightFast(uv) : 0f);
		float num5 = Mathf.Clamp01(num3 / distAttenFactor);
		float num6 = Mathf.Clamp01(Mathf.Abs(num4) / depthAttenFactor);
		Vector3 zero = Vector3.zero;
		zero = GetDisplacement(simData, position, time, beaufort);
		zero = GetDisplacement(simData, position - zero, time, beaufort);
		zero = GetDisplacement(simData, position - zero, time, beaufort);
		return GetDisplacement(simData, position - zero, time, beaufort).y * num5 * num6;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector3 GetDisplacement(Vector3[,,] simData, Vector3 position, float time, float beaufort)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		FindFrames(time, out var num, out var num2, out var num3);
		FindSpectra(beaufort, out var num4, out var num5, out var spectrumT);
		return GetDisplacement(simData, position, num, num2, num3, num4, num5, spectrumT);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector3 GetDisplacement(Vector3[,,] simData, Vector3 position, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		float normX = position.x * oneOverOctave0Scale;
		float normZ = position.z * oneOverOctave0Scale;
		return GetDisplacement(simData, normX, normZ, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector3 GetDisplacement(Vector3[,,] simData, float normX, float normZ, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		normX -= Mathf.Floor(normX);
		normZ -= Mathf.Floor(normZ);
		float num = normX * 256f - 0.5f;
		float num2 = normZ * 256f - 0.5f;
		int num3 = Mathf.FloorToInt(num);
		int num4 = Mathf.FloorToInt(num2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		int x = num3;
		int y = num4;
		int x2 = num3 + 1;
		int y2 = num4 + 1;
		Vector3 displacement = GetDisplacement(simData, x, y, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
		Vector3 displacement2 = GetDisplacement(simData, x2, y, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
		Vector3 displacement3 = GetDisplacement(simData, x, y2, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
		Vector3 displacement4 = GetDisplacement(simData, x2, y2, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
		Vector3 val = Vector3.LerpUnclamped(displacement, displacement2, num5);
		Vector3 val2 = Vector3.LerpUnclamped(displacement3, displacement4, num5);
		return Vector3.LerpUnclamped(val, val2, num6);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector3 GetDisplacement(Vector3[,,] simData, int x, int y, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		int num = x * 256 + y;
		Vector3 val = Vector3.LerpUnclamped(simData[spectrum0, frame0, num], simData[spectrum1, frame0, num], spectrumBlend);
		Vector3 val2 = Vector3.LerpUnclamped(simData[spectrum0, frame1, num], simData[spectrum1, frame1, num], spectrumBlend);
		return Vector3.LerpUnclamped(val, val2, frameBlend);
	}

	public void Dispose()
	{
		if (_batchPositionQueryArr.IsCreated)
		{
			_batchPositionQueryArr.Dispose();
		}
		nativeSimData.Dispose();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void GetHeightBatch(Vector2[] positions, float[] heights, float[] shore, float[] terrainHeight)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(positions.Length == heights.Length);
		PopulateBatchNative(positions);
		_cachedBatchJob.OneOverOctave0Scale = oneOverOctave0Scale;
		_cachedBatchJob.Frame0 = frame0;
		_cachedBatchJob.Frame1 = frame1;
		_cachedBatchJob.Spectrum0 = spectrum0;
		_cachedBatchJob.Spectrum1 = spectrum1;
		_cachedBatchJob.spectrumBlend = spectrumBlend;
		_cachedBatchJob.frameBlend = frameBlend;
		_cachedBatchJob.Positions = _batchPositionQueryArr;
		_cachedBatchJob.Count = positions.Length;
		IJobExtensions.RunByRef<GetHeightBatchedJob>(ref _cachedBatchJob);
		for (int i = 0; i < heights.Length; i++)
		{
			heights[i] = _batchPositionQueryArr[i].x * GetHeightAttenuation(shore[i], terrainHeight[i]);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void GetHeightBatch(NativeArray<float3> positions, Span<float> heights, ReadOnlySpan<float> shore, ReadOnlySpan<float> terrainHeight)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(positions.Length == heights.Length);
		_cachedBatchJob.OneOverOctave0Scale = oneOverOctave0Scale;
		_cachedBatchJob.Frame0 = frame0;
		_cachedBatchJob.Frame1 = frame1;
		_cachedBatchJob.Spectrum0 = spectrum0;
		_cachedBatchJob.Spectrum1 = spectrum1;
		_cachedBatchJob.spectrumBlend = spectrumBlend;
		_cachedBatchJob.frameBlend = frameBlend;
		_cachedBatchJob.Positions = positions;
		_cachedBatchJob.Count = positions.Length;
		IJobExtensions.RunByRef<GetHeightBatchedJob>(ref _cachedBatchJob);
		for (int i = 0; i < heights.Length; i++)
		{
			heights[i] = positions[i].x * GetHeightAttenuation(shore[i], terrainHeight[i]);
		}
	}

	public void GetHeightsIndirect(ReadOnly<Vector3> pos, ReadOnly<float> shore, ReadOnly<float> terrainHeight, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		_heightsJobIndirect.Heights = results;
		_heightsJobIndirect.Pos = pos;
		_heightsJobIndirect.ShoreDists = shore;
		_heightsJobIndirect.TerrainHeights = terrainHeight;
		_heightsJobIndirect.Indices = indices;
		_heightsJobIndirect.OneOverOctave0Scale = oneOverOctave0Scale;
		_heightsJobIndirect.Frame0 = frame0;
		_heightsJobIndirect.Frame1 = frame1;
		_heightsJobIndirect.Spectrum0 = spectrum0;
		_heightsJobIndirect.Spectrum1 = spectrum1;
		_heightsJobIndirect.SpectrumBlend = spectrumBlend;
		_heightsJobIndirect.FrameBlend = frameBlend;
		_heightsJobIndirect.DistanceAttenuationFactor = distanceAttenuationFactor;
		_heightsJobIndirect.DepthAttenuationFactor = depthAttenuationFactor;
		IJobExtensions.RunByRef<GetHeightsJobIndirect>(ref _heightsJobIndirect);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float GetHeight(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		float heightAttenuation = GetHeightAttenuation(position);
		_cachedBatchJob.OneOverOctave0Scale = oneOverOctave0Scale;
		_cachedBatchJob.Frame0 = frame0;
		_cachedBatchJob.Frame1 = frame1;
		_cachedBatchJob.Spectrum0 = spectrum0;
		_cachedBatchJob.Spectrum1 = spectrum1;
		_cachedBatchJob.spectrumBlend = spectrumBlend;
		_cachedBatchJob.frameBlend = frameBlend;
		PopulateBatchNative(position);
		_cachedBatchJob.Positions = _batchPositionQueryArr;
		_cachedBatchJob.Count = 1;
		IJobExtensions.RunByRef<GetHeightBatchedJob>(ref _cachedBatchJob);
		return _cachedBatchJob.Positions[0].x * heightAttenuation;
	}

	private void PopulateBatchNative(Vector3 position)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (!_batchPositionQueryArr.IsCreated || _batchPositionQueryArr.Length < 1)
		{
			if (_batchPositionQueryArr.IsCreated)
			{
				_batchPositionQueryArr.Dispose();
			}
			_batchPositionQueryArr = new NativeArray<float3>(1, (Allocator)4, (NativeArrayOptions)1);
		}
		_batchPositionQueryArr[0] = float3.op_Implicit(position);
	}

	private void PopulateBatchNative(Vector2[] positions)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (!_batchPositionQueryArr.IsCreated || _batchPositionQueryArr.Length < positions.Length)
		{
			if (_batchPositionQueryArr.IsCreated)
			{
				_batchPositionQueryArr.Dispose();
			}
			_batchPositionQueryArr = new NativeArray<float3>(positions.Length, (Allocator)4, (NativeArrayOptions)1);
		}
		for (int i = 0; i < positions.Length; i++)
		{
			_batchPositionQueryArr[i] = float3.op_Implicit(Vector3Ex.XZ3D(positions[i]));
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float GetHeightAttenuation(float shore, float terrainHeight)
	{
		float num = Mathf.Clamp01(shore / distanceAttenuationFactor);
		float num2 = Mathf.Clamp01(Mathf.Abs(terrainHeight) / depthAttenuationFactor);
		return num * num2;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float GetHeightAttenuation(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Position.x;
		float z = TerrainMeta.Position.z;
		float x2 = TerrainMeta.OneOverSize.x;
		float z2 = TerrainMeta.OneOverSize.z;
		float num = (position.x - x) * x2;
		float num2 = (position.z - z) * z2;
		Vector2 uv = default(Vector2);
		((Vector2)(ref uv))..ctor(num, num2);
		float num3 = (((Object)(object)TerrainTexturing.Instance != (Object)null) ? TerrainTexturing.Instance.GetCoarseDistanceToShore(uv) : 0f);
		float num4 = (((Object)(object)TerrainMeta.HeightMap != (Object)null) ? TerrainMeta.HeightMap.GetHeightFast(uv) : 0f);
		float num5 = Mathf.Clamp01(num3 / distanceAttenuationFactor);
		float num6 = Mathf.Clamp01(Mathf.Abs(num4) / depthAttenuationFactor);
		return num5 * num6;
	}
}


using Rust.Water5;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile]
internal struct GetHeightBatchedJob : IJob
{
	public NativeArray<float3> Positions;

	public int Count;

	public float OneOverOctave0Scale;

	public NativeOceanDisplacementShort3 SimData;

	public int Spectrum0;

	public int Spectrum1;

	public int Frame0;

	public int Frame1;

	public float spectrumBlend;

	public float frameBlend;

	public void Execute()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Count; i++)
		{
			ref NativeArray<float3> positions = ref Positions;
			int num = i;
			float3 val = Positions[i];
			positions[num] = float3.op_Implicit(GetHeightRaw(((float3)(ref val)).xyz));
		}
	}

	private float GetHeightRaw(float3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		float3 zero = float3.zero;
		zero = float3.op_Implicit(GetDisplacement(position));
		zero = float3.op_Implicit(GetDisplacement(position - zero));
		zero = float3.op_Implicit(GetDisplacement(position - zero));
		return GetDisplacement(position - zero).y;
	}

	private Vector3 GetDisplacement(float3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float normX = position.x * OneOverOctave0Scale;
		float normZ = position.z * OneOverOctave0Scale;
		return float3.op_Implicit(GetDisplacement(normX, normZ));
	}

	private float3 GetDisplacement(float normX, float normZ)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		normX -= math.floor(normX);
		normZ -= math.floor(normZ);
		float num = normX * 256f - 0.5f;
		float num2 = normZ * 256f - 0.5f;
		int num3 = (int)math.floor(num);
		int num4 = (int)math.floor(num2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		int num7 = num3 % 256;
		int num8 = num4 % 256;
		int x = (num7 + 256) % 256;
		int z = (num8 + 256) % 256;
		int x2 = (num7 + 1 + 256) % 256;
		int z2 = (num8 + 1 + 256) % 256;
		float3 displacementFromSimData = GetDisplacementFromSimData(x, z);
		float3 displacementFromSimData2 = GetDisplacementFromSimData(x2, z);
		float3 displacementFromSimData3 = GetDisplacementFromSimData(x, z2);
		float3 displacementFromSimData4 = GetDisplacementFromSimData(x2, z2);
		float3 val = math.lerp(displacementFromSimData, displacementFromSimData2, num5);
		float3 val2 = math.lerp(displacementFromSimData3, displacementFromSimData4, num5);
		return math.lerp(val, val2, num6);
	}

	private float3 GetDisplacementFromSimData(int x, int z)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		int z2 = x * 256 + z;
		float3 val = math.lerp((float3)SimData[Spectrum0, Frame0, z2], (float3)SimData[Spectrum1, Frame0, z2], spectrumBlend);
		float3 val2 = math.lerp((float3)SimData[Spectrum0, Frame1, z2], (float3)SimData[Spectrum1, Frame1, z2], spectrumBlend);
		return math.lerp(val, val2, frameBlend);
	}
}


using Rust.Water5;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile]
internal struct GetHeightsJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<float> ShoreDists;

	[ReadOnly]
	public ReadOnly<float> TerrainHeights;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public float OneOverOctave0Scale;

	[ReadOnly]
	public NativeOceanDisplacementShort3 SimData;

	[ReadOnly]
	public int Spectrum0;

	[ReadOnly]
	public int Spectrum1;

	[ReadOnly]
	public int Frame0;

	[ReadOnly]
	public int Frame1;

	[ReadOnly]
	public float SpectrumBlend;

	[ReadOnly]
	public float FrameBlend;

	[ReadOnly]
	public float DistanceAttenuationFactor;

	[ReadOnly]
	public float DepthAttenuationFactor;

	public void Execute()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			float heightRaw = GetHeightRaw(float3.op_Implicit(Pos[num]));
			Heights[num] = heightRaw * GetHeightAttenuation(ShoreDists[num], TerrainHeights[num]);
		}
	}

	private float GetHeightRaw(float3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		float3 zero = float3.zero;
		zero = float3.op_Implicit(GetDisplacement(position));
		zero = float3.op_Implicit(GetDisplacement(position - zero));
		zero = float3.op_Implicit(GetDisplacement(position - zero));
		return GetDisplacement(position - zero).y;
	}

	private Vector3 GetDisplacement(float3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float normX = position.x * OneOverOctave0Scale;
		float normZ = position.z * OneOverOctave0Scale;
		return float3.op_Implicit(GetDisplacement(normX, normZ));
	}

	private float3 GetDisplacement(float normX, float normZ)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		normX -= math.floor(normX);
		normZ -= math.floor(normZ);
		float num = normX * 256f - 0.5f;
		float num2 = normZ * 256f - 0.5f;
		int num3 = (int)math.floor(num);
		int num4 = (int)math.floor(num2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		int num7 = num3 % 256;
		int num8 = num4 % 256;
		int x = (num7 + 256) % 256;
		int z = (num8 + 256) % 256;
		int x2 = (num7 + 1 + 256) % 256;
		int z2 = (num8 + 1 + 256) % 256;
		float3 displacementFromSimData = GetDisplacementFromSimData(x, z);
		float3 displacementFromSimData2 = GetDisplacementFromSimData(x2, z);
		float3 displacementFromSimData3 = GetDisplacementFromSimData(x, z2);
		float3 displacementFromSimData4 = GetDisplacementFromSimData(x2, z2);
		float3 val = math.lerp(displacementFromSimData, displacementFromSimData2, num5);
		float3 val2 = math.lerp(displacementFromSimData3, displacementFromSimData4, num5);
		return math.lerp(val, val2, num6);
	}

	private float3 GetDisplacementFromSimData(int x, int z)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		int z2 = x * 256 + z;
		float3 val = math.lerp((float3)SimData[Spectrum0, Frame0, z2], (float3)SimData[Spectrum1, Frame0, z2], SpectrumBlend);
		float3 val2 = math.lerp((float3)SimData[Spectrum0, Frame1, z2], (float3)SimData[Spectrum1, Frame1, z2], SpectrumBlend);
		return math.lerp(val, val2, FrameBlend);
	}

	public float GetHeightAttenuation(float shore, float terrainHeight)
	{
		float num = Mathf.Clamp01(shore / DistanceAttenuationFactor);
		float num2 = Mathf.Clamp01(Mathf.Abs(terrainHeight) / DepthAttenuationFactor);
		return num * num2;
	}
}


using System;

[Serializable]
public struct SpectrumParameters
{
	public float scale;

	public float angle;

	public float spreadBlend;

	public float swell;

	public float alpha;

	public float peakOmega;

	public float gamma;

	public float shortWavesFade;
}


using System;
using UnityEngine;

[Serializable]
public struct SpectrumSettings
{
	[Range(0f, 1f)]
	public float scale;

	public float windSpeed;

	public float fetch;

	[Range(0f, 1f)]
	public float spreadBlend;

	[Range(0f, 1f)]
	public float swell;

	public float peakEnhancement;

	public float shortWavesFade;
}


using Rust.Water5;
using UnityEngine;

[CreateAssetMenu(fileName = "New Spectrum Settings", menuName = "Water5/Spectrum Settings")]
public class OceanSpectrumSettings : ScriptableObject
{
	public OceanSettings oceanSettings;

	[Header("Deep Wave Settings")]
	public float g;

	public float beaufort;

	public float depth;

	public SpectrumSettings local;

	public SpectrumSettings swell;

	[Header("Material Settings")]
	public Color color;

	public Color specColor;

	public float smoothness;

	public Color waterColor;

	public Color waterExtinction;

	public float scatteringCoefficient;

	public Color subSurfaceColor;

	public float subSurfaceFalloff;

	public float subSurfaceBase;

	public float subSurfaceSun;

	public float subSurfaceAmount;

	public float foamAmount;

	public float foamScale;

	public Color foamColor;

	public Color baseFoamColor;

	[Button("Update Spectrum")]
	public void UpdateSpectrum()
	{
		WaterSystem.Instance?.Refresh();
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.Events;

public class ClockSlider : RustSlider
{
	private bool isUpdatingText;

	public override float Value
	{
		get
		{
			return ((RustSlider)this).Value;
		}
		set
		{
			value = Mathf.Clamp(value, base.MinValue, base.MaxValue);
			if (base.Integer)
			{
				value = Mathf.Round(value);
			}
			if (base.ValueInternal != value)
			{
				base.ValueInternal = value;
			}
			string text = FormatText(value);
			if ((Object)(object)base.NumberInput != (Object)null && !base.NumberInput.IsFocused && base.NumberInput.Text != text)
			{
				UpdateTextNoNotify(text);
			}
			base.SliderCanvas.fillAmount = ((RustSlider)this).ValueNormalized;
			if (base.lastCallbackValue != value)
			{
				base.lastCallbackValue = value;
				((UnityEvent<float>)(object)base.OnChanged)?.Invoke(value);
			}
		}
	}

	protected override void Awake()
	{
		((RustSlider)this).Awake();
		if ((Object)(object)base.NumberInput != (Object)null)
		{
			((UnityEvent<string>)(object)base.NumberInput.OnValueChanged).RemoveListener((UnityAction<string>)TextChanged);
			((UnityEvent<string>)(object)base.NumberInput.OnValueChanged).AddListener((UnityAction<string>)TextChanged);
			((UnityEvent<string>)(object)base.NumberInput.OnEndEdit).RemoveListener((UnityAction<string>)OnEndEdit);
			((UnityEvent<string>)(object)base.NumberInput.OnEndEdit).AddListener((UnityAction<string>)OnEndEdit);
		}
	}

	public void OnEndEdit(string text)
	{
		if (isUpdatingText)
		{
			return;
		}
		if (!text.Contains(":"))
		{
			text = ((text.Length == 4) ? text.Insert(2, ":") : ((text.Length == 3) ? text.Insert(1, ":") : ((text.Length != 1) ? "00:00" : ("0" + text + ":00"))));
			UpdateTextNoNotify(text);
		}
		else
		{
			if (text.Length == 3)
			{
				text = text.Insert(3, "00");
			}
			UpdateTextNoNotify(text);
		}
		UpdateValue(text, updateText: true);
	}

	public void TextChanged(string text)
	{
		if (isUpdatingText)
		{
			return;
		}
		int num = -1;
		if (!text.Contains(":"))
		{
			if (text.Length == 2)
			{
				text = text.Insert(2, ":");
				num = 3;
			}
			if (text.Length == 1)
			{
				int.TryParse(text, out var result);
				if (result > 2)
				{
					text = "0" + text + ":";
					num = 3;
				}
			}
			UpdateTextNoNotify(text);
			if (num != -1)
			{
				base.NumberInput.InputField.caretPosition = num;
			}
		}
		UpdateValue(text, updateText: false);
	}

	private void UpdateValue(string text, bool updateText)
	{
		string[] array = text.Split(':');
		if (array.Length != 2 || !int.TryParse(array[0], out var result) || !int.TryParse(array[1], out var result2))
		{
			return;
		}
		result = Mathf.Clamp(result, 0, 23);
		result2 = Mathf.Clamp(result2, 0, 59);
		((RustSlider)this).Value = (float)result + (float)result2 / 60f;
		if (updateText)
		{
			string text2 = FormatText(((RustSlider)this).Value);
			if (base.NumberInput.Text != text2)
			{
				UpdateTextNoNotify(text2);
			}
		}
	}

	private string FormatText(float value)
	{
		int num = Mathf.RoundToInt(value * 60f);
		int num2 = num / 60;
		int num3 = num % 60;
		return $"{num2:D2}:{num3:D2}";
	}

	private void UpdateTextNoNotify(string text)
	{
		isUpdatingText = true;
		base.NumberInput.Text = text;
		isUpdatingText = false;
	}
}


using UnityEngine;

public class MuteListController : UIDialog
{
	public RectTransform ListParent;

	public GameObjectRef UserWidget;

	public SteamFriendsList SearchList;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ReportBug : UIDialog
{
	public GameObject GetInformation;

	public GameObject Finished;

	public RustInput Subject;

	public RustInput Message;

	public RustButton ReportButton;

	public RustButtonGroup Category;

	public RustIcon ProgressIcon;

	public RustText ProgressText;

	public RawImage ScreenshotImage;

	public GameObject ScreenshotRoot;

	public UIBackgroundBlur BlurController;

	public RustButton SubmitButton;

	public GameObject SubmitErrorRoot;

	public RustText CooldownText;

	public RustText ContentMissingText;
}


using Rust.UI;
using UnityEngine;

public class ReportPlayer : UIDialog
{
	public const string BreakServerRulesKey = "break_server_rules";

	public GameObject FindPlayer;

	public GameObject GetInformation;

	public GameObject Finished;

	public GameObject RecentlyReported;

	public Dropdown ReasonDropdown;

	public RustInput Subject;

	public RustInput Message;

	public RustButton ReportButton;

	public SteamUserButton SteamUserButton;

	public RustIcon ProgressIcon;

	public RustText ProgressText;

	public static Option[] ReportReasons = (Option[])(object)new Option[6]
	{
		new Option(new Phrase("report.reason.none", "Select an option"), "none", false, (Icons)61641),
		new Option(new Phrase("report.reason.abuse", "Racism/Sexism/Abusive"), "abusive", false, (Icons)62806),
		new Option(new Phrase("report.reason.cheat", "Cheating"), "cheat", false, (Icons)61531),
		new Option(new Phrase("report.reason.spam", "Spamming"), "spam", false, (Icons)61601),
		new Option(new Phrase("report.reason.name", "Offensive Name"), "name", false, (Icons)63417),
		new Option(new Phrase("report.reason.server_rules", "Breaking Server Rules"), "break_server_rules", false, (Icons)61546)
	};
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class SteamInventoryCrafting : MonoBehaviour
{
	public GameObject Container;

	public ToggleGroup ToggleGroup;

	public Button ConvertToItem;

	public Button DeleteButton;

	public TextMeshProUGUI WoodAmount;

	public TextMeshProUGUI ClothAmount;

	public TextMeshProUGUI MetalAmount;

	public TextMeshProUGUI InfoText;

	public SteamInventoryCrateOpen CraftModal;

	public GameObject CraftingContainer;

	public GameObject CraftingButton;

	public SteamInventoryNewItem NewItemModal;

	public IPlayerItemDefinition ResultItem { get; private set; }

	public Coroutine MarketCoroutine { get; private set; }
}


using Rust.UI;
using TMPro;
using UnityEngine;

public class SteamInventoryCrateOpen : MonoBehaviour
{
	public TextMeshProUGUI Name;

	public TextMeshProUGUI Requirements;

	public TextMeshProUGUI Label;

	public HttpImage IconImage;

	public GameObject ErrorPanel;

	public TextMeshProUGUI ErrorText;

	public GameObject CraftButton;

	public GameObject ProgressPanel;

	public SteamInventoryNewItem NewItemModal;
}


using UnityEngine;

public class SteamInventoryIcon : MonoBehaviour
{
}


using Facepunch.Extend;
using Rust.UI;
using TMPro;
using UnityEngine;

public class SteamInventoryItem : MonoBehaviour
{
	public IPlayerItem Item;

	public HttpImage Image;

	public bool Setup(IPlayerItem item)
	{
		Item = item;
		if (PlayerItemExtensions.GetDefinition(item) == null)
		{
			return false;
		}
		((TMP_Text)((Component)TransformEx.FindChildRecursive(((Component)this).transform, "ItemName")).GetComponent<TextMeshProUGUI>()).text = PlayerItemExtensions.GetDefinition(item).Name;
		return Image.Load(PlayerItemExtensions.GetDefinition(item).IconUrl);
	}
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;

public class SteamInventoryManager : SingletonComponent<SteamInventoryManager>
{
	public GameObject inventoryItemPrefab;

	public GameObject inventoryCanvas;

	public GameObject missingItems;

	public SteamInventoryCrafting CraftControl;

	public List<GameObject> items;

	public GameObject LoadingOverlay;
}


using System.Threading.Tasks;
using Rust.UI;
using UnityEngine;

public class SteamInventoryNewItem : MonoBehaviour
{
	public async Task Open(IPlayerItem item)
	{
		((Component)this).gameObject.SetActive(true);
		((Component)this).GetComponentInChildren<Rust.UI.SteamInventoryItem>().Setup(item);
		while (Object.op_Implicit((Object)(object)this) && ((Component)this).gameObject.activeSelf)
		{
			await Task.Delay(100);
		}
	}
}


using Rust.UI;
using UnityEngine;

public class ServerAdminConvarInfo : MonoBehaviour
{
	public RustText InfoName;

	public RustText InfoValue;

	public RustInput VariableInput;

	public Tooltip TooltipComponent;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminPlayerEntry : MonoBehaviour
{
	public RustText PlayerName;

	public RustText Ping;

	public RustButton Button;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminPlayerId : MonoBehaviour
{
	public RustText PlayerName;

	public RustText PlayerId;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminPlayerInfo : MonoBehaviour
{
	public RustText PlayerName;

	public RustText SteamID;

	public RustText OwnerSteamID;

	public RustText Ping;

	public RustText Address;

	public RustText ConnectedTime;

	public RustText ViolationLevel;

	public RustText Health;

	public RustInput KickReasonInput;

	public RustInput BanReasonInput;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminServerInfo : MonoBehaviour
{
	public RustText InfoName;

	public RustText InfoValue;
}


using UnityEngine;

public class ServerAdminUGCEntry : MonoBehaviour
{
}


using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;

public class ServerAdminUGCEntryAudio : ServerAdminUGCEntry
{
	public AudioSource AudioSpeaker;

	public RustText DurationText;

	public RustSlider ProgressSlider;

	public RustIcon PlayIcon;
}


using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;
using UnityEngine.UI;

public class ServerAdminUGCEntryImage : ServerAdminUGCEntry
{
	public RawImage Image;

	public RectTransform Backing;

	public GameObject MultiImageRoot;

	public RustText ImageIndex;

	public Vector2 OriginalImageSize;
}


using Rust.UI.ServerAdmin;
using UnityEngine;

public class ServerAdminUGCEntryPattern : ServerAdminUGCEntry
{
	public GameObjectRef StarPrefab;

	public RectTransform StarRoot;
}


using Rust.UI.ServerAdmin;
using UnityEngine;
using UnityEngine.UI;

public class ServerAdminUGCEntrySculpture : ServerAdminUGCEntry
{
	public Camera Camera;

	public Material MaterialToUse;

	public RawImage Target;
}


using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;

public class ServerAdminUGCEntryStub : MonoBehaviour
{
	public ServerAdminUGCEntryAudio AudioWidget;

	public ServerAdminUGCEntryImage ImageWidget;

	public ServerAdminUGCEntryPattern PatternWidget;

	public ServerAdminUGCEntryVendingMachine VendingWidget;

	public ServerAdminUGCEntrySculpture SculptureWidget;

	public RustText PrefabName;

	public RustButton HistoryButton;

	public ServerAdminPlayerId[] HistoryIds = new ServerAdminPlayerId[0];
}


using Rust.UI;
using Rust.UI.ServerAdmin;

public class ServerAdminUGCEntryVendingMachine : ServerAdminUGCEntry
{
	public RustText NameLabel;
}


using Facepunch;
using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;
using UnityEngine.UI;

public class ServerAdminUI : SingletonComponent<ServerAdminUI>
{
	public GameObjectRef PlayerEntry;

	public RectTransform PlayerInfoParent;

	public RustText PlayerCount;

	public RustInput PlayerNameFilter;

	public GameObjectRef ServerInfoEntry;

	public RectTransform ServerInfoParent;

	public GameObjectRef ConvarInfoEntry;

	public GameObjectRef ConvarInfoLongEntry;

	public RectTransform ConvarInfoParent;

	public ServerAdminPlayerInfo PlayerInfo;

	public RustInput UgcNameFilter;

	public GameObjectRef ImageEntry;

	public GameObjectRef PatternEntry;

	public GameObjectRef SoundEntry;

	public RustButton ShowWantedPostersButton;

	public VirtualScroll UgcVirtualScroll;

	public GameObject ExpandedUgcRoot;

	public RawImage ExpandedImage;

	public RectTransform ExpandedImageBacking;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class Hero : SingletonComponent<Hero>
{
	public CanvasGroup CanvasGroup;

	public Video VideoPlayer;

	public RustText TitleText;

	public RustText ButtonText;

	public HttpImage TitleImage;

	[Header("Item Store Links")]
	public RustButton ItemStoreButton;

	public RustButton LimitedTabButton;

	public RustButton GeneralTabButton;
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(Toggle))]
internal class ForceWeather : MonoBehaviour
{
	private Toggle component;

	public bool Rain;

	public bool Fog;

	public bool Wind;

	public bool Clouds;

	public void OnEnable()
	{
		component = ((Component)this).GetComponent<Toggle>();
	}

	public void Update()
	{
		if (!((Object)(object)SingletonComponent<Climate>.Instance == (Object)null))
		{
			if (Rain)
			{
				SingletonComponent<Climate>.Instance.Overrides.Rain = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Rain, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
			if (Fog)
			{
				SingletonComponent<Climate>.Instance.Overrides.Fog = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Fog, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
			if (Wind)
			{
				SingletonComponent<Climate>.Instance.Overrides.Wind = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Wind, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
			if (Clouds)
			{
				SingletonComponent<Climate>.Instance.Overrides.Clouds = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Clouds, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
		}
	}
}


using System;
using Rust.Modular;
using UnityEngine;

[Serializable]
public class ConditionalObject
{
	public enum AdjacentCondition
	{
		SameInFront,
		SameBehind,
		DifferentInFront,
		DifferentBehind,
		BothDifferent,
		BothSame
	}

	public enum AdjacentMatchType
	{
		GroupOrExact,
		ExactOnly,
		GroupNotExact
	}

	public GameObject gameObject;

	public GameObject ownerGameObject;

	public ConditionalSocketSettings[] socketSettings;

	public bool restrictOnHealth;

	public float healthRestrictionMin;

	public float healthRestrictionMax;

	public bool restrictOnAdjacent;

	public AdjacentCondition adjacentRestriction;

	public AdjacentMatchType adjacentMatch;

	public bool restrictOnLockable;

	public bool lockableRestriction;

	public bool? IsActive { get; private set; }

	public ConditionalObject(GameObject conditionalGO, GameObject ownerGO, int socketsTaken)
	{
		gameObject = conditionalGO;
		ownerGameObject = ownerGO;
		socketSettings = new ConditionalSocketSettings[socketsTaken];
	}

	public void SetActive(bool active)
	{
		if (!IsActive.HasValue || active != IsActive.Value)
		{
			gameObject.SetActive(active);
			IsActive = active;
		}
	}

	public void RefreshActive()
	{
		if (IsActive.HasValue)
		{
			gameObject.SetActive(IsActive.Value);
		}
	}
}


public enum AdjacentCondition
{
	SameInFront,
	SameBehind,
	DifferentInFront,
	DifferentBehind,
	BothDifferent,
	BothSame
}


public enum AdjacentMatchType
{
	GroupOrExact,
	ExactOnly,
	GroupNotExact
}


using System;
using Rust.Modular;

[Serializable]
public class ConditionalSocketSettings
{
	public enum LocationCondition
	{
		Middle,
		Front,
		Back,
		NotMiddle,
		NotFront,
		NotBack
	}

	public bool restrictOnLocation;

	public LocationCondition locationRestriction;

	public bool restrictOnWheel;

	public ModularVehicleSocket.SocketWheelType wheelRestriction;

	public bool HasSocketRestrictions
	{
		get
		{
			if (!restrictOnLocation)
			{
				return restrictOnWheel;
			}
			return true;
		}
	}
}


public enum LocationCondition
{
	Middle,
	Front,
	Back,
	NotMiddle,
	NotFront,
	NotBack
}


using UnityEngine;
using UnityEngine.Events;

public class EnableDisableEvent : MonoBehaviour
{
	[SerializeField]
	private UnityEvent enableEvent;

	[SerializeField]
	private UnityEvent disableEvent;

	protected void OnEnable()
	{
		if (enableEvent != null)
		{
			enableEvent.Invoke();
		}
	}

	protected void OnDisable()
	{
		if (disableEvent != null)
		{
			disableEvent.Invoke();
		}
	}
}


using Rust.Modular;

public static class EngineItemTypeEx
{
	public static bool BoostsAcceleration(this EngineStorage.EngineItemTypes engineItemType)
	{
		if (engineItemType != EngineStorage.EngineItemTypes.SparkPlug)
		{
			return engineItemType == EngineStorage.EngineItemTypes.Piston;
		}
		return true;
	}

	public static bool BoostsTopSpeed(this EngineStorage.EngineItemTypes engineItemType)
	{
		if (engineItemType != EngineStorage.EngineItemTypes.Carburetor && engineItemType != 0)
		{
			return engineItemType == EngineStorage.EngineItemTypes.Piston;
		}
		return true;
	}

	public static bool BoostsFuelEconomy(this EngineStorage.EngineItemTypes engineItemType)
	{
		if (engineItemType != EngineStorage.EngineItemTypes.Carburetor)
		{
			return engineItemType == EngineStorage.EngineItemTypes.Valve;
		}
		return true;
	}
}


using System;
using System.Linq;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust.Modular;
using UnityEngine;

public class EngineStorage : StorageContainer
{
	public enum EngineItemTypes
	{
		Crankshaft,
		Carburetor,
		SparkPlug,
		Piston,
		Valve
	}

	[Header("Engine Storage")]
	public Sprite engineIcon;

	public float internalDamageMultiplier = 0.5f;

	public EngineItemTypes[] slotTypes;

	[SerializeField]
	public VehicleModuleEngineItems allEngineItems;

	[SerializeField]
	[ReadOnly]
	public int accelerationBoostSlots;

	[SerializeField]
	[ReadOnly]
	public int topSpeedBoostSlots;

	[SerializeField]
	[ReadOnly]
	public int fuelEconomyBoostSlots;

	public bool isUsable { get; set; }

	public float accelerationBoostPercent { get; set; }

	public float topSpeedBoostPercent { get; set; }

	public float fuelEconomyBoostPercent { get; set; }

	public VehicleModuleEngine GetEngineModule()
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			return ((Component)baseEntity).GetComponent<VehicleModuleEngine>();
		}
		return null;
	}

	public float GetAveragedLoadoutPercent()
	{
		return (accelerationBoostPercent + topSpeedBoostPercent + fuelEconomyBoostPercent) / 3f;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.engineStorage != null)
		{
			isUsable = info.msg.engineStorage.isUsable;
			accelerationBoostPercent = info.msg.engineStorage.accelerationBoost;
			topSpeedBoostPercent = info.msg.engineStorage.topSpeedBoost;
			fuelEconomyBoostPercent = info.msg.engineStorage.fuelEconomyBoost;
		}
		GetEngineModule()?.RefreshPerformanceStats(this);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		VehicleModuleEngine engineModule = GetEngineModule();
		if ((Object)(object)engineModule != (Object)null)
		{
			return engineModule.CanBeLooted(player);
		}
		return false;
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		return GetValidSlot(item);
	}

	public int GetValidSlot(Item item)
	{
		ItemModEngineItem component = ((Component)item.info).GetComponent<ItemModEngineItem>();
		if ((Object)(object)component == (Object)null)
		{
			return -1;
		}
		EngineItemTypes engineItemType = component.engineItemType;
		for (int i = 0; i < inventorySlots; i++)
		{
			if (engineItemType == slotTypes[i] && !base.inventory.SlotTaken(item, i))
			{
				return i;
			}
		}
		return -1;
	}

	public override void OnInventoryFirstCreated(ItemContainer container)
	{
		RefreshLoadoutData();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		RefreshLoadoutData();
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (!base.ItemFilter(item, targetSlot))
		{
			return false;
		}
		if (targetSlot < 0 || targetSlot >= slotTypes.Length)
		{
			return false;
		}
		ItemModEngineItem component = ((Component)item.info).GetComponent<ItemModEngineItem>();
		if ((Object)(object)component != (Object)null && component.engineItemType == slotTypes[targetSlot])
		{
			return true;
		}
		return false;
	}

	public void RefreshLoadoutData()
	{
		if (Interface.CallHook("OnEngineLoadoutRefresh", (object)this) == null)
		{
			isUsable = base.inventory.IsFull() && base.inventory.itemList.All((Item item) => !item.isBroken);
			accelerationBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsAcceleration) / (float)accelerationBoostSlots;
			topSpeedBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsTopSpeed) / (float)topSpeedBoostSlots;
			fuelEconomyBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsFuelEconomy) / (float)fuelEconomyBoostSlots;
			SendNetworkUpdate();
			GetEngineModule()?.RefreshPerformanceStats(this);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.engineStorage = Pool.Get<EngineStorage>();
		info.msg.engineStorage.isUsable = isUsable;
		info.msg.engineStorage.accelerationBoost = accelerationBoostPercent;
		info.msg.engineStorage.topSpeedBoost = topSpeedBoostPercent;
		info.msg.engineStorage.fuelEconomyBoost = fuelEconomyBoostPercent;
	}

	public void OnModuleDamaged(float damageTaken)
	{
		if (damageTaken <= 0f)
		{
			return;
		}
		damageTaken *= internalDamageMultiplier;
		float[] array = new float[base.inventory.capacity];
		float num = 0f;
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = Random.value;
			num += array[i];
		}
		float num2 = damageTaken / num;
		for (int j = 0; j < array.Length; j++)
		{
			Item slot = base.inventory.GetSlot(j);
			if (slot != null)
			{
				slot.condition -= array[j] * num2;
			}
		}
		RefreshLoadoutData();
	}

	public void AdminAddParts(int tier)
	{
		if (base.inventory == null)
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": Null inventory on " + ((Object)this).name));
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				slot.RemoveFromContainer();
				slot.Remove();
			}
		}
		for (int j = 0; j < base.inventory.capacity; j++)
		{
			if (base.inventory.GetSlot(j) == null && allEngineItems.TryGetItem(tier, slotTypes[j], out var output))
			{
				ItemDefinition component = ((Component)output).GetComponent<ItemDefinition>();
				Item item = ItemManager.Create(component, 1, 0uL);
				if (item != null)
				{
					item.condition = component.condition.max;
					item.MoveToContainer(base.inventory, j, allowStack: false);
				}
				else
				{
					Debug.LogError((object)(((object)this).GetType().Name + ": Failed to create engine storage item."));
				}
			}
		}
	}

	public float GetContainerItemsValueFor(Func<EngineItemTypes, bool> boostConditional)
	{
		float num = 0f;
		foreach (Item item in base.inventory.itemList)
		{
			ItemModEngineItem component = ((Component)item.info).GetComponent<ItemModEngineItem>();
			if ((Object)(object)component != (Object)null && boostConditional(component.engineItemType) && !item.isBroken)
			{
				num += (float)item.amount * GetTierValue(component.tier);
			}
		}
		return num;
	}

	public float GetTierValue(int tier)
	{
		switch (tier)
		{
		case 1:
			return 0.6f;
		case 2:
			return 0.8f;
		case 3:
			return 1f;
		default:
			Debug.LogError((object)(((object)this).GetType().Name + ": Unrecognised item tier: " + tier));
			return 0f;
		}
	}
}


public enum EngineItemTypes
{
	Crankshaft,
	Carburetor,
	SparkPlug,
	Piston,
	Valve
}


using UnityEngine;

public class ModularCarAudio : GroundVehicleAudio
{
	public bool showDebug;

	[SerializeField]
	[Header("Skid")]
	private SoundDefinition skidSoundLoop;

	[SerializeField]
	private SoundDefinition skidSoundDirtLoop;

	[SerializeField]
	private SoundDefinition skidSoundSnowLoop;

	[SerializeField]
	private float skidMinSlip = 10f;

	[SerializeField]
	private float skidMaxSlip = 25f;

	[Header("Movement & Suspension")]
	[SerializeField]
	private SoundDefinition movementStartOneshot;

	[SerializeField]
	private SoundDefinition movementStopOneshot;

	[SerializeField]
	private float movementStartStopMinTimeBetweenSounds = 0.25f;

	[SerializeField]
	private SoundDefinition movementRattleLoop;

	[SerializeField]
	private float movementRattleMaxSpeed = 10f;

	[SerializeField]
	private float movementRattleMaxAngSpeed = 10f;

	[SerializeField]
	private float movementRattleIdleGain = 0.3f;

	[SerializeField]
	private SoundDefinition suspensionLurchSound;

	[SerializeField]
	private float suspensionLurchMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionLurchMinTimeBetweenSounds = 0.25f;

	[SerializeField]
	[Header("Wheels")]
	private SoundDefinition tyreRollingSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingWaterSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingGrassSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingSnowSoundDef;

	[SerializeField]
	private AnimationCurve tyreRollGainCurve;
}


using System;
using Facepunch;
using Rust;
using Rust.Modular;
using UnityEngine;

public class ModularVehicleInventory : IDisposable
{
	private ItemContainer moduleContainer;

	private ItemContainer chassisContainer;

	private readonly BaseModularVehicle vehicle;

	public ItemContainer ModuleContainer => moduleContainer;

	public ItemContainer ChassisContainer => chassisContainer;

	public ItemContainerId UID => moduleContainer.uid;

	private int TotalSockets => vehicle.TotalSockets;

	public ModularVehicleInventory(BaseModularVehicle vehicle, ItemDefinition chassisItemDef, bool giveUID)
	{
		this.vehicle = vehicle;
		moduleContainer = CreateModuleInventory(vehicle, giveUID);
		chassisContainer = CreateChassisInventory(vehicle, giveUID);
		vehicle.AssociatedItemInstance = ItemManager.Create(chassisItemDef, 1, 0uL);
		if (!Application.isLoadingSave)
		{
			vehicle.AssociatedItemInstance.MoveToContainer(chassisContainer, 0, allowStack: false);
		}
	}

	public void Dispose()
	{
		foreach (Item item in moduleContainer.itemList)
		{
			item.OnDirty -= OnModuleItemChanged;
		}
		Pool.Free<ItemContainer>(ref moduleContainer);
		Pool.Free<ItemContainer>(ref chassisContainer);
	}

	public void GiveUIDs()
	{
		moduleContainer.GiveUID();
		chassisContainer.GiveUID();
	}

	public bool SocketIsFree(int socketIndex, Item moduleItem = null)
	{
		Item item = null;
		int num = socketIndex;
		while (item == null && num >= 0)
		{
			item = moduleContainer.GetSlot(num);
			if (item != null)
			{
				if (item == moduleItem)
				{
					return true;
				}
				ItemModVehicleModule component = ((Component)item.info).GetComponent<ItemModVehicleModule>();
				return num + component.socketsTaken - 1 < socketIndex;
			}
			num--;
		}
		return true;
	}

	public bool SocketIsTaken(int socketIndex)
	{
		return !SocketIsFree(socketIndex);
	}

	public bool TryAddModuleItem(Item moduleItem, int socketIndex)
	{
		if (moduleItem == null)
		{
			Debug.LogError((object)(GetType().Name + ": Can't add null item."));
			return false;
		}
		return moduleItem.MoveToContainer(moduleContainer, socketIndex, allowStack: false);
	}

	public bool RemoveAndDestroy(Item itemToRemove)
	{
		bool result = moduleContainer.Remove(itemToRemove);
		itemToRemove.Remove();
		return result;
	}

	public int TryGetFreeSocket(int socketsTaken)
	{
		return TryGetFreeSocket(null, socketsTaken);
	}

	public int TryGetFreeSocket(Item moduleItem, int socketsTaken)
	{
		for (int i = 0; i <= TotalSockets - socketsTaken; i++)
		{
			if (SocketsAreFree(i, socketsTaken, moduleItem))
			{
				return i;
			}
		}
		return -1;
	}

	public bool SocketsAreFree(int firstIndex, int socketsTaken, Item moduleItem = null)
	{
		if (firstIndex < 0 || firstIndex + socketsTaken > TotalSockets)
		{
			return false;
		}
		for (int i = firstIndex; i < firstIndex + socketsTaken; i++)
		{
			if (!SocketIsFree(i, moduleItem))
			{
				return false;
			}
		}
		return true;
	}

	public bool TrySyncModuleInventory(BaseVehicleModule moduleEntity, int firstSocketIndex)
	{
		if (firstSocketIndex < 0)
		{
			Debug.LogError((object)$"{GetType().Name}: Invalid socket index ({firstSocketIndex}) for new module entity.", (Object)(object)((Component)vehicle).gameObject);
			return false;
		}
		Item slot = moduleContainer.GetSlot(firstSocketIndex);
		int numSocketsTaken = moduleEntity.GetNumSocketsTaken();
		if (!SocketsAreFree(firstSocketIndex, numSocketsTaken) && (slot == null || moduleEntity.AssociatedItemInstance != slot))
		{
			Debug.LogError((object)$"{GetType().Name}: Sockets are not free for new module entity. First: {firstSocketIndex} Taken: {numSocketsTaken}", (Object)(object)((Component)vehicle).gameObject);
			return false;
		}
		if (slot == null)
		{
			Item item = ItemManager.Create(moduleEntity.AssociatedItemDef, 1, 0uL);
			item.condition = moduleEntity.health;
			moduleEntity.AssociatedItemInstance = item;
			bool num = TryAddModuleItem(item, firstSocketIndex);
			if (num)
			{
				vehicle.SetUpModule(moduleEntity, item);
				return num;
			}
			item.Remove();
			return num;
		}
		return true;
	}

	private bool SocketIsUsed(Item item, int slotIndex)
	{
		return !SocketIsFree(slotIndex, item);
	}

	private ItemContainer CreateModuleInventory(BaseModularVehicle vehicle, bool giveUID)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.entityOwner = vehicle;
		itemContainer.allowedContents = ItemContainer.ContentsType.Generic;
		itemContainer.maxStackSize = 1;
		itemContainer.ServerInitialize(null, TotalSockets);
		if (giveUID)
		{
			itemContainer.GiveUID();
		}
		itemContainer.onItemAddedRemoved = OnSocketInventoryAddRemove;
		itemContainer.canAcceptItem = ItemFilter;
		itemContainer.slotIsReserved = SocketIsUsed;
		return itemContainer;
	}

	private ItemContainer CreateChassisInventory(BaseModularVehicle vehicle, bool giveUID)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.entityOwner = vehicle;
		itemContainer.allowedContents = ItemContainer.ContentsType.Generic;
		itemContainer.maxStackSize = 1;
		itemContainer.ServerInitialize(null, 1);
		if (giveUID)
		{
			itemContainer.GiveUID();
		}
		return itemContainer;
	}

	private void OnSocketInventoryAddRemove(Item moduleItem, bool added)
	{
		if (added)
		{
			ModuleItemAdded(moduleItem, moduleItem.position);
		}
		else
		{
			ModuleItemRemoved(moduleItem);
		}
	}

	private void ModuleItemAdded(Item moduleItem, int socketIndex)
	{
		ItemModVehicleModule component = ((Component)moduleItem.info).GetComponent<ItemModVehicleModule>();
		if (!Application.isLoadingSave && (Object)(object)vehicle.GetModuleForItem(moduleItem) == (Object)null)
		{
			vehicle.CreatePhysicalModuleEntity(moduleItem, component, socketIndex);
		}
		moduleItem.OnDirty += OnModuleItemChanged;
	}

	private void ModuleItemRemoved(Item moduleItem)
	{
		if (moduleItem == null)
		{
			Debug.LogError((object)"Null module item removed.", (Object)(object)((Component)vehicle).gameObject);
			return;
		}
		moduleItem.OnDirty -= OnModuleItemChanged;
		BaseVehicleModule moduleForItem = vehicle.GetModuleForItem(moduleItem);
		if ((Object)(object)moduleForItem != (Object)null)
		{
			if (!moduleForItem.IsFullySpawned())
			{
				Debug.LogError((object)"Module entity being removed before it's fully spawned. This could cause errors.", (Object)(object)((Component)vehicle).gameObject);
			}
			moduleForItem.Kill();
		}
		else
		{
			Debug.Log((object)"Couldn't find entity for this item.");
		}
	}

	private void OnModuleItemChanged(Item moduleItem)
	{
		BaseVehicleModule moduleForItem = vehicle.GetModuleForItem(moduleItem);
		if ((Object)(object)moduleForItem != (Object)null)
		{
			moduleForItem.SetHealth(moduleItem.condition);
			if (moduleForItem.FirstSocketIndex != moduleItem.position)
			{
				ModuleItemRemoved(moduleItem);
				ModuleItemAdded(moduleItem, moduleItem.position);
			}
		}
	}

	private bool ItemFilter(Item item, int targetSlot)
	{
		string failureReason;
		return vehicle.ModuleCanBeAdded(item, targetSlot, out failureReason);
	}
}


using System;
using Rust.Modular;
using UnityEngine;

[Serializable]
public class ModularVehicleSocket
{
	public enum SocketWheelType
	{
		NoWheel,
		ForwardWheel,
		BackWheel
	}

	public enum SocketLocationType
	{
		Middle,
		Front,
		Back
	}

	[SerializeField]
	private Transform socketTransform;

	[SerializeField]
	private SocketWheelType wheelType;

	[SerializeField]
	private SocketLocationType locationType;

	public Vector3 WorldPosition => socketTransform.position;

	public Quaternion WorldRotation => socketTransform.rotation;

	public SocketWheelType WheelType => wheelType;

	public SocketLocationType LocationType => locationType;

	public bool ShouldBeActive(ConditionalSocketSettings modelSettings)
	{
		bool flag = true;
		if (modelSettings.restrictOnLocation)
		{
			ConditionalSocketSettings.LocationCondition locationRestriction = modelSettings.locationRestriction;
			switch (LocationType)
			{
			case SocketLocationType.Back:
				flag = locationRestriction == ConditionalSocketSettings.LocationCondition.Back || locationRestriction == ConditionalSocketSettings.LocationCondition.NotFront || locationRestriction == ConditionalSocketSettings.LocationCondition.NotMiddle;
				break;
			case SocketLocationType.Front:
				flag = locationRestriction == ConditionalSocketSettings.LocationCondition.Front || locationRestriction == ConditionalSocketSettings.LocationCondition.NotBack || locationRestriction == ConditionalSocketSettings.LocationCondition.NotMiddle;
				break;
			case SocketLocationType.Middle:
				flag = locationRestriction == ConditionalSocketSettings.LocationCondition.Middle || locationRestriction == ConditionalSocketSettings.LocationCondition.NotFront || locationRestriction == ConditionalSocketSettings.LocationCondition.NotBack;
				break;
			}
		}
		if (flag && modelSettings.restrictOnWheel)
		{
			flag = WheelType == modelSettings.wheelRestriction;
		}
		return flag;
	}
}


public enum SocketWheelType
{
	NoWheel,
	ForwardWheel,
	BackWheel
}


public enum SocketLocationType
{
	Middle,
	Front,
	Back
}


using System.Collections.Generic;
using Facepunch;
using Rust.Modular;
using UnityEngine;

[CreateAssetMenu(fileName = "Vehicle Module Engine Items", menuName = "Scriptable Object/Vehicles/Module Engine Items")]
public class VehicleModuleEngineItems : ScriptableObject
{
	[SerializeField]
	private ItemModEngineItem[] engineItems;

	public bool TryGetItem(int tier, EngineStorage.EngineItemTypes type, out ItemModEngineItem output)
	{
		List<ItemModEngineItem> list = Pool.Get<List<ItemModEngineItem>>();
		bool result = false;
		output = null;
		ItemModEngineItem[] array = engineItems;
		foreach (ItemModEngineItem itemModEngineItem in array)
		{
			if (itemModEngineItem.tier == tier && itemModEngineItem.engineItemType == type)
			{
				list.Add(itemModEngineItem);
			}
		}
		if (list.Count > 0)
		{
			output = ListEx.GetRandom<ItemModEngineItem>(list);
			result = true;
		}
		Pool.FreeUnmanaged<ItemModEngineItem>(ref list);
		return result;
	}
}


using System;
using Rust.Modular;
using UnityEngine;

[Serializable]
public class VehicleModuleSlidingComponent
{
	[Serializable]
	public class SlidingPart
	{
		public Transform transform;

		public Vector3 openPosition;

		public Vector3 closedPosition;
	}

	public string interactionColliderName = "MyCollider";

	public BaseEntity.Flags flag_SliderOpen = BaseEntity.Flags.Reserved3;

	public float moveTime = 1f;

	public SlidingPart[] slidingParts;

	public SoundDefinition openSoundDef;

	public SoundDefinition closeSoundDef;

	private float positionPercent;

	public bool WantsOpenPos(BaseEntity parentEntity)
	{
		return parentEntity.HasFlag(flag_SliderOpen);
	}

	public void Use(BaseVehicleModule parentModule)
	{
		parentModule.SetFlag(flag_SliderOpen, !WantsOpenPos(parentModule));
	}

	public void ServerUpdateTick(BaseVehicleModule parentModule)
	{
		CheckPosition(parentModule, Time.fixedDeltaTime);
	}

	private void CheckPosition(BaseEntity parentEntity, float dt)
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		bool flag = WantsOpenPos(parentEntity);
		if ((flag && positionPercent == 1f) || (!flag && positionPercent == 0f))
		{
			return;
		}
		float num = (flag ? (dt / moveTime) : (0f - dt / moveTime));
		positionPercent = Mathf.Clamp01(positionPercent + num);
		SlidingPart[] array = slidingParts;
		foreach (SlidingPart slidingPart in array)
		{
			if (!((Object)(object)slidingPart.transform == (Object)null))
			{
				slidingPart.transform.localPosition = Vector3.Lerp(slidingPart.closedPosition, slidingPart.openPosition, positionPercent);
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class SlidingPart
{
	public Transform transform;

	public Vector3 openPosition;

	public Vector3 closedPosition;
}


using Rust.Modular;
using UnityEngine;

public class ItemModEngineItem : ItemMod
{
	public EngineStorage.EngineItemTypes engineItemType;

	[Range(1f, 3f)]
	public int tier = 1;
}


using UnityEngine;

public class ItemModVehicleChassis : ItemMod, VehicleModuleInformationPanel.IVehicleModuleInfo
{
	public GameObjectRef entityPrefab;

	[Range(1f, 6f)]
	public int socketsTaken = 1;

	public int SocketsTaken => socketsTaken;
}


using UnityEngine;

public class ItemModVehicleModule : ItemMod, VehicleModuleInformationPanel.IVehicleModuleInfo
{
	public GameObjectRef entityPrefab;

	[Range(1f, 2f)]
	public int socketsTaken = 1;

	public int SocketsTaken => socketsTaken;

	public BaseVehicleModule CreateModuleEntity(BaseEntity parent, Vector3 position, Quaternion rotation)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (!entityPrefab.isValid)
		{
			Debug.LogError((object)"Invalid entity prefab for module");
			return null;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(entityPrefab.resourcePath, position, rotation);
		BaseVehicleModule result = null;
		if ((Object)(object)baseEntity != (Object)null)
		{
			if ((Object)(object)parent != (Object)null)
			{
				baseEntity.SetParent(parent, worldPositionStays: true);
				baseEntity.canTriggerParent = false;
			}
			baseEntity.Spawn();
			result = ((Component)baseEntity).GetComponent<BaseVehicleModule>();
		}
		return result;
	}
}


public enum Notes
{
	A,
	B,
	C,
	D,
	E,
	F,
	G
}


using System.Collections.Generic;
using Rust.Interpolation;

public interface IGenericLerpTarget<T> where T : ISnapshot<T>, new()
{
	float GetInterpolationDelay(ILerpInfo.LerpType lerpType);

	float GetInterpolationSmoothing();

	void SetFrom(T snapshot);

	T GetCurrentState();

	void DebugInterpolationState(Interpolator<T>.Segment segment, List<T> entries);
}


using System;
using Rust.Interpolation;
using UnityEngine;

public class GenericLerp<T> : IDisposable where T : ISnapshot<T>, new()
{
	private readonly Interpolator<T> interpolator;

	private IGenericLerpTarget<T> target;

	private static T snapshotPrototype = new T();

	private static float timeOffset = 0f;

	private float timeOffset0 = float.MaxValue;

	private float timeOffset1 = float.MaxValue;

	private float timeOffset2 = float.MaxValue;

	private float timeOffset3 = float.MaxValue;

	private int timeOffsetCount;

	private int TimeOffsetInterval => PositionLerp.TimeOffsetInterval;

	private float LerpTime => PositionLerp.LerpTime;

	public GenericLerp(IGenericLerpTarget<T> target, int listCount)
	{
		this.target = target;
		interpolator = new Interpolator<T>(listCount);
	}

	public void Tick()
	{
		if (target != null)
		{
			float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Generic);
			float interpolationSmoothing = target.GetInterpolationSmoothing();
			Interpolator<T>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, 0f, interpolationSmoothing, ref snapshotPrototype);
			target.SetFrom(segment.tick);
		}
	}

	public void Snapshot(T snapshot)
	{
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Generic);
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		float num = interpolationDelay + interpolationSmoothing + 1f;
		float lerpTime = LerpTime;
		timeOffset0 = Mathf.Min(timeOffset0, lerpTime - snapshot.Time);
		timeOffsetCount++;
		if (timeOffsetCount >= TimeOffsetInterval / 4)
		{
			timeOffset3 = timeOffset2;
			timeOffset2 = timeOffset1;
			timeOffset1 = timeOffset0;
			timeOffset0 = float.MaxValue;
			timeOffsetCount = 0;
		}
		timeOffset = Mathx.Min(timeOffset0, timeOffset1, timeOffset2, timeOffset3);
		lerpTime = (snapshot.Time += timeOffset);
		interpolator.Add(snapshot);
		interpolator.Cull(lerpTime - num);
	}

	public void SnapTo(T snapshot)
	{
		interpolator.Clear();
		Snapshot(snapshot);
		target.SetFrom(snapshot);
	}

	public void SnapToNow(T snapshot)
	{
		snapshot.Time = LerpTime;
		interpolator.last = snapshot;
		Wipe();
	}

	public void SnapToEnd()
	{
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Generic);
		Interpolator<T>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, 0f, 0f, ref snapshotPrototype);
		target.SetFrom(segment.tick);
		Wipe();
	}

	public void Dispose()
	{
		target = null;
		interpolator.Clear();
		timeOffset0 = float.MaxValue;
		timeOffset1 = float.MaxValue;
		timeOffset2 = float.MaxValue;
		timeOffset3 = float.MaxValue;
		timeOffsetCount = 0;
	}

	private void Wipe()
	{
		interpolator.Clear();
		timeOffsetCount = 0;
		timeOffset0 = float.MaxValue;
		timeOffset1 = float.MaxValue;
		timeOffset2 = float.MaxValue;
		timeOffset3 = float.MaxValue;
	}
}


public interface ISnapshot<T>
{
	float Time { get; set; }

	void MatchValuesTo(T entry);

	void Lerp(T prev, T next, float delta);

	T GetNew();
}


using System.Collections.Generic;
using Rust.Interpolation;
using UnityEngine;

public class Interpolator<T> where T : ISnapshot<T>, new()
{
	public struct Segment
	{
		public T tick;

		public T prev;

		public T next;
	}

	public List<T> list;

	public T last;

	public Interpolator(int listCount)
	{
		list = new List<T>(listCount);
	}

	public void Add(T tick)
	{
		last = tick;
		list.Add(tick);
	}

	public void Cull(float beforeTime)
	{
		for (int i = 0; i < list.Count; i++)
		{
			if (list[i].Time < beforeTime)
			{
				list.RemoveAt(i);
				i--;
			}
		}
	}

	public void Clear()
	{
		list.Clear();
	}

	public Segment Query(float time, float interpolation, float extrapolation, float smoothing, ref T t)
	{
		Segment result = default(Segment);
		if (list.Count == 0)
		{
			result.prev = last;
			result.next = last;
			result.tick = last;
			return result;
		}
		float num = time - interpolation - smoothing * 0.5f;
		float num2 = Mathf.Min(time - interpolation, last.Time);
		float num3 = num2 - smoothing;
		T prev = list[0];
		T val = last;
		T prev2 = list[0];
		T val2 = last;
		foreach (T item in list)
		{
			if (item.Time < num3)
			{
				prev = item;
			}
			else if (val.Time >= item.Time)
			{
				val = item;
			}
			if (item.Time < num2)
			{
				prev2 = item;
			}
			else if (val2.Time >= item.Time)
			{
				val2 = item;
			}
		}
		T @new = t.GetNew();
		if (val.Time - prev.Time <= Mathf.Epsilon)
		{
			@new.Time = num3;
			@new.MatchValuesTo(val);
		}
		else
		{
			@new.Time = num3;
			@new.Lerp(prev, val, (num3 - prev.Time) / (val.Time - prev.Time));
		}
		result.prev = @new;
		T new2 = t.GetNew();
		if (val2.Time - prev2.Time <= Mathf.Epsilon)
		{
			new2.Time = num2;
			new2.MatchValuesTo(val2);
		}
		else
		{
			new2.Time = num2;
			new2.Lerp(prev2, val2, (num2 - prev2.Time) / (val2.Time - prev2.Time));
		}
		result.next = new2;
		if (new2.Time - @new.Time <= Mathf.Epsilon)
		{
			result.prev = new2;
			result.tick = new2;
			return result;
		}
		if (num - new2.Time > extrapolation)
		{
			result.prev = new2;
			result.tick = new2;
			return result;
		}
		T new3 = t.GetNew();
		new3.Time = num;
		new3.Lerp(@new, new2, Mathf.Min(num - @new.Time, new2.Time + extrapolation - @new.Time) / (new2.Time - @new.Time));
		result.tick = new3;
		return result;
	}
}


public struct Segment
{
	public T tick;

	public T prev;

	public T next;
}


using Rust.Interpolation;
using UnityEngine;

public struct TransformSnapshot : ISnapshot<TransformSnapshot>
{
	public Vector3 pos;

	public Quaternion rot;

	public float Time { get; set; }

	public TransformSnapshot(float time, Vector3 pos, Quaternion rot)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Time = time;
		this.pos = pos;
		this.rot = rot;
	}

	public void MatchValuesTo(TransformSnapshot entry)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		pos = entry.pos;
		rot = entry.rot;
	}

	public void Lerp(TransformSnapshot prev, TransformSnapshot next, float delta)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		pos = Vector3.LerpUnclamped(prev.pos, next.pos, delta);
		rot = Quaternion.SlerpUnclamped(prev.rot, next.rot, delta);
	}

	public TransformSnapshot GetNew()
	{
		return default(TransformSnapshot);
	}
}


using Rust.Interpolation;
using UnityEngine;

public struct FloatSnapshot : ISnapshot<FloatSnapshot>
{
	public float value;

	public float Time { get; set; }

	public FloatSnapshot(float time, float value)
	{
		Time = time;
		this.value = value;
	}

	public void MatchValuesTo(FloatSnapshot entry)
	{
		value = entry.value;
	}

	public void Lerp(FloatSnapshot prev, FloatSnapshot next, float delta)
	{
		value = Mathf.Lerp(prev.value, next.value, delta);
	}

	public FloatSnapshot GetNew()
	{
		return default(FloatSnapshot);
	}
}


using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;

public static class AStarPath
{
	private static float Heuristic(IAIPathNode from, IAIPathNode to)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Distance(from.Position, to.Position);
	}

	public static bool FindPath(IAIPathNode start, IAIPathNode goal, out Stack<IAIPathNode> path, out float pathCost)
	{
		path = null;
		pathCost = -1f;
		bool result = false;
		if (start == goal)
		{
			return false;
		}
		AStarNodeList aStarNodeList = new AStarNodeList();
		HashSet<IAIPathNode> hashSet = new HashSet<IAIPathNode>();
		AStarNode item = new AStarNode(0f, Heuristic(start, goal), null, start);
		aStarNodeList.Add(item);
		while (aStarNodeList.Count > 0)
		{
			AStarNode aStarNode = aStarNodeList[0];
			aStarNodeList.RemoveAt(0);
			hashSet.Add(aStarNode.Node);
			if (aStarNode.Satisfies(goal))
			{
				path = new Stack<IAIPathNode>();
				pathCost = 0f;
				while (aStarNode.Parent != null)
				{
					pathCost += aStarNode.F;
					path.Push(aStarNode.Node);
					aStarNode = aStarNode.Parent;
				}
				if (aStarNode != null)
				{
					path.Push(aStarNode.Node);
				}
				result = true;
				break;
			}
			foreach (IAIPathNode item2 in aStarNode.Node.Linked)
			{
				if (!hashSet.Contains(item2))
				{
					float num = aStarNode.G + Heuristic(aStarNode.Node, item2);
					AStarNode aStarNodeOf = aStarNodeList.GetAStarNodeOf(item2);
					if (aStarNodeOf == null)
					{
						aStarNodeOf = new AStarNode(num, Heuristic(item2, goal), aStarNode, item2);
						aStarNodeList.Add(aStarNodeOf);
						aStarNodeList.AStarNodeSort();
					}
					else if (num < aStarNodeOf.G)
					{
						aStarNodeOf.Update(num, aStarNodeOf.H, aStarNode, item2);
						aStarNodeList.AStarNodeSort();
					}
				}
			}
		}
		return result;
	}
}


using Rust.Ai;

public class AStarNode
{
	public AStarNode Parent;

	public float G;

	public float H;

	public IAIPathNode Node;

	public float F => G + H;

	public AStarNode(float g, float h, AStarNode parent, IAIPathNode node)
	{
		G = g;
		H = h;
		Parent = parent;
		Node = node;
	}

	public void Update(float g, float h, AStarNode parent, IAIPathNode node)
	{
		G = g;
		H = h;
		Parent = parent;
		Node = node;
	}

	public bool Satisfies(IAIPathNode node)
	{
		return Node == node;
	}

	public static bool operator <(AStarNode lhs, AStarNode rhs)
	{
		return lhs.F < rhs.F;
	}

	public static bool operator >(AStarNode lhs, AStarNode rhs)
	{
		return lhs.F > rhs.F;
	}
}


using System.Collections.Generic;
using Rust.Ai;

public class AStarNodeList : List<AStarNode>
{
	private class AStarNodeComparer : IComparer<AStarNode>
	{
		int IComparer<AStarNode>.Compare(AStarNode lhs, AStarNode rhs)
		{
			if (lhs < rhs)
			{
				return -1;
			}
			if (lhs > rhs)
			{
				return 1;
			}
			return 0;
		}
	}

	private readonly AStarNodeComparer comparer = new AStarNodeComparer();

	public bool Contains(IAIPathNode n)
	{
		for (int i = 0; i < base.Count; i++)
		{
			AStarNode aStarNode = base[i];
			if (aStarNode != null && aStarNode.Node.Equals(n))
			{
				return true;
			}
		}
		return false;
	}

	public AStarNode GetAStarNodeOf(IAIPathNode n)
	{
		for (int i = 0; i < base.Count; i++)
		{
			AStarNode aStarNode = base[i];
			if (aStarNode != null && aStarNode.Node.Equals(n))
			{
				return aStarNode;
			}
		}
		return null;
	}

	public void AStarNodeSort()
	{
		Sort(comparer);
	}
}


using System.Collections.Generic;

private class AStarNodeComparer : IComparer<AStarNode>
{
	int IComparer<AStarNode>.Compare(AStarNode lhs, AStarNode rhs)
	{
		if (lhs < rhs)
		{
			return -1;
		}
		if (lhs > rhs)
		{
			return 1;
		}
		return 0;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using Rust.Ai;
using UnityEngine;

public class SimpleAIMemory
{
	public struct SeenInfo
	{
		public BaseEntity Entity;

		public Vector3 Position;

		public float Timestamp;

		public float Danger;
	}

	public static HashSet<BasePlayer> PlayerIgnoreList = new HashSet<BasePlayer>();

	[NonSerialized]
	public List<SeenInfo> All = new List<SeenInfo>();

	[NonSerialized]
	public List<BaseEntity> Players = new List<BaseEntity>();

	[NonSerialized]
	public HashSet<BaseEntity> LOS = new HashSet<BaseEntity>();

	[NonSerialized]
	public List<BaseEntity> Targets = new List<BaseEntity>();

	[NonSerialized]
	public List<BaseEntity> Threats = new List<BaseEntity>();

	[NonSerialized]
	public List<BaseEntity> Friendlies = new List<BaseEntity>();

	public void SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses)
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnNpcTargetSense", (object)owner, (object)ent, (object)brainSenses) != null)
		{
			return;
		}
		IAISenses iAISenses = owner as IAISenses;
		BasePlayer basePlayer = ent as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null && PlayerIgnoreList.Contains(basePlayer))
		{
			return;
		}
		bool flag = false;
		if (iAISenses != null && iAISenses.IsThreat(ent))
		{
			flag = true;
			if (brainSenses != null)
			{
				brainSenses.LastThreatTimestamp = Time.realtimeSinceStartup;
			}
		}
		for (int i = 0; i < All.Count; i++)
		{
			if ((Object)(object)All[i].Entity == (Object)(object)ent)
			{
				SeenInfo value = All[i];
				value.Position = ((Component)ent).transform.position;
				value.Timestamp = Mathf.Max(Time.realtimeSinceStartup, value.Timestamp);
				All[i] = value;
				return;
			}
		}
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (AI.ignoreplayers && !basePlayer.IsNpc)
			{
				return;
			}
			Players.Add(ent);
		}
		if (iAISenses != null)
		{
			if (iAISenses.IsTarget(ent))
			{
				Targets.Add(ent);
			}
			if (iAISenses.IsFriendly(ent))
			{
				Friendlies.Add(ent);
			}
			if (flag)
			{
				Threats.Add(ent);
			}
		}
		All.Add(new SeenInfo
		{
			Entity = ent,
			Position = ((Component)ent).transform.position,
			Timestamp = Time.realtimeSinceStartup
		});
	}

	public void SetLOS(BaseEntity ent, bool flag)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			if (flag)
			{
				LOS.Add(ent);
			}
			else
			{
				LOS.Remove(ent);
			}
		}
	}

	public bool IsLOS(BaseEntity ent)
	{
		return LOS.Contains(ent);
	}

	public bool IsPlayerKnown(BasePlayer player)
	{
		return Players.Contains(player);
	}

	public void Forget(float secondsOld)
	{
		for (int i = 0; i < All.Count; i++)
		{
			if (!(Time.realtimeSinceStartup - All[i].Timestamp >= secondsOld))
			{
				continue;
			}
			BaseEntity entity = All[i].Entity;
			if ((Object)(object)entity != (Object)null)
			{
				if (entity is BasePlayer)
				{
					Players.Remove(entity);
				}
				Targets.Remove(entity);
				Threats.Remove(entity);
				Friendlies.Remove(entity);
				LOS.Remove(entity);
			}
			All.RemoveAt(i);
			i--;
		}
	}

	public static void AddIgnorePlayer(BasePlayer player)
	{
		if (!PlayerIgnoreList.Contains(player))
		{
			PlayerIgnoreList.Add(player);
		}
	}

	public static void RemoveIgnorePlayer(BasePlayer player)
	{
		PlayerIgnoreList.Remove(player);
	}

	public static void ClearIgnoredPlayers()
	{
		PlayerIgnoreList.Clear();
	}

	public static string GetIgnoredPlayers()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		TextTable val = new TextTable();
		val.AddColumns(new string[2] { "Name", "Steam ID" });
		foreach (BasePlayer playerIgnore in PlayerIgnoreList)
		{
			val.AddRow(new string[2]
			{
				playerIgnore.displayName,
				playerIgnore.userID.ToString()
			});
		}
		return ((object)val).ToString();
	}
}


using UnityEngine;

public struct SeenInfo
{
	public BaseEntity Entity;

	public Vector3 Position;

	public float Timestamp;

	public float Danger;
}


using System.Collections;
using Rust.Ai;
using UnityEngine;

public class CoverPoint
{
	public enum CoverType
	{
		Full,
		Partial,
		None
	}

	public CoverType NormalCoverType;

	public bool IsDynamic;

	public Transform SourceTransform;

	private Vector3 _staticPosition;

	private Vector3 _staticNormal;

	public CoverPointVolume Volume { get; private set; }

	public Vector3 Position
	{
		get
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if (IsDynamic && (Object)(object)SourceTransform != (Object)null)
			{
				return SourceTransform.position;
			}
			return _staticPosition;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_staticPosition = value;
		}
	}

	public Vector3 Normal
	{
		get
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if (IsDynamic && (Object)(object)SourceTransform != (Object)null)
			{
				return SourceTransform.forward;
			}
			return _staticNormal;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_staticNormal = value;
		}
	}

	public BaseEntity ReservedFor { get; set; }

	public bool IsReserved => (Object)(object)ReservedFor != (Object)null;

	public bool IsCompromised { get; set; }

	public float Score { get; set; }

	public bool IsValidFor(BaseEntity entity)
	{
		if (!IsCompromised)
		{
			if (!((Object)(object)ReservedFor == (Object)null))
			{
				return (Object)(object)ReservedFor == (Object)(object)entity;
			}
			return true;
		}
		return false;
	}

	public CoverPoint(CoverPointVolume volume, float score)
	{
		Volume = volume;
		Score = score;
	}

	public void CoverIsCompromised(float cooldown)
	{
		if (!IsCompromised && (Object)(object)Volume != (Object)null)
		{
			((MonoBehaviour)Volume).StartCoroutine(StartCooldown(cooldown));
		}
	}

	private IEnumerator StartCooldown(float cooldown)
	{
		IsCompromised = true;
		yield return CoroutineEx.waitForSeconds(cooldown);
		IsCompromised = false;
	}

	public bool ProvidesCoverFromPoint(Vector3 point, float arcThreshold)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Position - point;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		return Vector3.Dot(Normal, normalized) < arcThreshold;
	}
}


public enum CoverType
{
	Full,
	Partial,
	None
}


using UnityEngine;

[RequireComponent(typeof(Collider))]
public class CoverPointBlockerVolume : MonoBehaviour
{
}


using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class CoverPointVolume : MonoBehaviour, IServerComponent
{
	internal enum CoverType
	{
		None,
		Partial,
		Full
	}

	public float DefaultCoverPointScore = 1f;

	public float CoverPointRayLength = 1f;

	public LayerMask CoverLayerMask;

	public Transform BlockerGroup;

	public Transform ManualCoverPointGroup;

	[ServerVar(Help = "cover_point_sample_step_size defines the size of the steps we do horizontally for the cover point volume's cover point generation (smaller steps gives more accurate cover points, but at a higher processing cost). (default: 6.0)")]
	public static float cover_point_sample_step_size = 6f;

	[ServerVar(Help = "cover_point_sample_step_height defines the height of the steps we do vertically for the cover point volume's cover point generation (smaller steps gives more accurate cover points, but at a higher processing cost). (default: 2.0)")]
	public static float cover_point_sample_step_height = 2f;

	public readonly List<CoverPoint> CoverPoints = new List<CoverPoint>();

	private readonly List<CoverPointBlockerVolume> _coverPointBlockers = new List<CoverPointBlockerVolume>();

	private float _dynNavMeshBuildCompletionTime = -1f;

	private int _genAttempts;

	private Bounds bounds = new Bounds(Vector3.zero, Vector3.zero);

	public bool repeat => true;

	public float? ExecuteUpdate(float deltaTime, float nextInterval)
	{
		if (CoverPoints.Count == 0)
		{
			if (_dynNavMeshBuildCompletionTime < 0f)
			{
				if ((Object)(object)SingletonComponent<DynamicNavMesh>.Instance == (Object)null || !((Behaviour)SingletonComponent<DynamicNavMesh>.Instance).enabled || !SingletonComponent<DynamicNavMesh>.Instance.IsBuilding)
				{
					_dynNavMeshBuildCompletionTime = Time.realtimeSinceStartup;
				}
			}
			else if (_genAttempts < 4 && Time.realtimeSinceStartup - _dynNavMeshBuildCompletionTime > 0.25f)
			{
				GenerateCoverPoints(null);
				if (CoverPoints.Count != 0)
				{
					return null;
				}
				_dynNavMeshBuildCompletionTime = Time.realtimeSinceStartup;
				_genAttempts++;
				if (_genAttempts >= 4)
				{
					Object.Destroy((Object)(object)((Component)this).gameObject);
					return null;
				}
			}
		}
		return 1f + Random.value * 2f;
	}

	[ContextMenu("Clear Cover Points")]
	private void ClearCoverPoints()
	{
		CoverPoints.Clear();
		_coverPointBlockers.Clear();
	}

	public Bounds GetBounds()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 center = ((Bounds)(ref bounds)).center;
		if (Mathf.Approximately(((Vector3)(ref center)).sqrMagnitude, 0f))
		{
			bounds = new Bounds(((Component)this).transform.position, ((Component)this).transform.localScale);
		}
		return bounds;
	}

	[ContextMenu("Pre-Generate Cover Points")]
	public void PreGenerateCoverPoints()
	{
		GenerateCoverPoints(null);
	}

	[ContextMenu("Convert to Manual Cover Points")]
	public void ConvertToManualCoverPoints()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		foreach (CoverPoint coverPoint in CoverPoints)
		{
			ManualCoverPoint manualCoverPoint = new GameObject("MCP").AddComponent<ManualCoverPoint>();
			((Component)manualCoverPoint).transform.localPosition = Vector3.zero;
			((Component)manualCoverPoint).transform.position = coverPoint.Position;
			manualCoverPoint.Normal = coverPoint.Normal;
			manualCoverPoint.NormalCoverType = coverPoint.NormalCoverType;
			manualCoverPoint.Volume = this;
		}
	}

	public void GenerateCoverPoints(Transform coverPointGroup)
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		_ = Time.realtimeSinceStartup;
		ClearCoverPoints();
		if ((Object)(object)ManualCoverPointGroup == (Object)null)
		{
			ManualCoverPointGroup = coverPointGroup;
		}
		if ((Object)(object)ManualCoverPointGroup == (Object)null)
		{
			ManualCoverPointGroup = ((Component)this).transform;
		}
		if (ManualCoverPointGroup.childCount > 0)
		{
			ManualCoverPoint[] componentsInChildren = ((Component)ManualCoverPointGroup).GetComponentsInChildren<ManualCoverPoint>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				CoverPoint item = componentsInChildren[i].ToCoverPoint(this);
				CoverPoints.Add(item);
			}
		}
		if (_coverPointBlockers.Count == 0 && (Object)(object)BlockerGroup != (Object)null)
		{
			CoverPointBlockerVolume[] componentsInChildren2 = ((Component)BlockerGroup).GetComponentsInChildren<CoverPointBlockerVolume>();
			if (componentsInChildren2 != null && componentsInChildren2.Length != 0)
			{
				_coverPointBlockers.AddRange(componentsInChildren2);
			}
		}
		NavMeshHit val = default(NavMeshHit);
		if (CoverPoints.Count != 0 || !NavMesh.SamplePosition(((Component)this).transform.position, ref val, ((Component)this).transform.localScale.y * cover_point_sample_step_height, -1))
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		Vector3 val2 = ((Component)this).transform.lossyScale * 0.5f;
		NavMeshHit info = default(NavMeshHit);
		for (float num = position.x - val2.x + 1f; num < position.x + val2.x - 1f; num += cover_point_sample_step_size)
		{
			for (float num2 = position.z - val2.z + 1f; num2 < position.z + val2.z - 1f; num2 += cover_point_sample_step_size)
			{
				for (float num3 = position.y - val2.y; num3 < position.y + val2.y; num3 += cover_point_sample_step_height)
				{
					if (!NavMesh.FindClosestEdge(new Vector3(num, num3, num2), ref info, ((NavMeshHit)(ref val)).mask))
					{
						continue;
					}
					((NavMeshHit)(ref info)).position = new Vector3(((NavMeshHit)(ref info)).position.x, ((NavMeshHit)(ref info)).position.y + 0.5f, ((NavMeshHit)(ref info)).position.z);
					bool flag = true;
					foreach (CoverPoint coverPoint2 in CoverPoints)
					{
						Vector3 val3 = coverPoint2.Position - ((NavMeshHit)(ref info)).position;
						if (((Vector3)(ref val3)).sqrMagnitude < cover_point_sample_step_size * cover_point_sample_step_size)
						{
							flag = false;
							break;
						}
					}
					if (flag)
					{
						CoverPoint coverPoint = CalculateCoverPoint(info);
						if (coverPoint != null)
						{
							CoverPoints.Add(coverPoint);
						}
					}
				}
			}
		}
	}

	private CoverPoint CalculateCoverPoint(NavMeshHit info)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit rayHit;
		CoverType coverType = ProvidesCoverInDir(new Ray(((NavMeshHit)(ref info)).position, -((NavMeshHit)(ref info)).normal), CoverPointRayLength, out rayHit);
		if (coverType == CoverType.None)
		{
			return null;
		}
		CoverPoint coverPoint = new CoverPoint(this, DefaultCoverPointScore)
		{
			Position = ((NavMeshHit)(ref info)).position,
			Normal = -((NavMeshHit)(ref info)).normal
		};
		switch (coverType)
		{
		case CoverType.Full:
			coverPoint.NormalCoverType = CoverPoint.CoverType.Full;
			break;
		case CoverType.Partial:
			coverPoint.NormalCoverType = CoverPoint.CoverType.Partial;
			break;
		}
		return coverPoint;
	}

	internal CoverType ProvidesCoverInDir(Ray ray, float maxDistance, out RaycastHit rayHit)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		rayHit = default(RaycastHit);
		if (Vector3Ex.IsNaNOrInfinity(((Ray)(ref ray)).origin))
		{
			return CoverType.None;
		}
		if (Vector3Ex.IsNaNOrInfinity(((Ray)(ref ray)).direction))
		{
			return CoverType.None;
		}
		if (((Ray)(ref ray)).direction == Vector3.zero)
		{
			return CoverType.None;
		}
		((Ray)(ref ray)).origin = ((Ray)(ref ray)).origin + PlayerEyes.EyeOffset;
		if (Physics.Raycast(((Ray)(ref ray)).origin, ((Ray)(ref ray)).direction, ref rayHit, maxDistance, LayerMask.op_Implicit(CoverLayerMask)))
		{
			return CoverType.Full;
		}
		((Ray)(ref ray)).origin = ((Ray)(ref ray)).origin + PlayerEyes.DuckOffset;
		if (Physics.Raycast(((Ray)(ref ray)).origin, ((Ray)(ref ray)).direction, ref rayHit, maxDistance, LayerMask.op_Implicit(CoverLayerMask)))
		{
			return CoverType.Partial;
		}
		return CoverType.None;
	}

	public bool Contains(Vector3 point)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Bounds val = default(Bounds);
		((Bounds)(ref val))..ctor(((Component)this).transform.position, ((Component)this).transform.localScale);
		return ((Bounds)(ref val)).Contains(point);
	}
}


internal enum CoverType
{
	None,
	Partial,
	Full
}


using Rust.Ai;
using UnityEngine;

public class ManualCoverPoint : FacepunchBehaviour
{
	public bool IsDynamic;

	public float Score = 2f;

	public CoverPointVolume Volume;

	public Vector3 Normal;

	public CoverPoint.CoverType NormalCoverType;

	public Vector3 Position => ((Component)this).transform.position;

	public float DirectionMagnitude
	{
		get
		{
			if ((Object)(object)Volume != (Object)null)
			{
				return Volume.CoverPointRayLength;
			}
			return 1f;
		}
	}

	private void Awake()
	{
		if ((Object)(object)((Component)this).transform.parent != (Object)null)
		{
			Volume = ((Component)((Component)this).transform.parent).GetComponent<CoverPointVolume>();
		}
	}

	public CoverPoint ToCoverPoint(CoverPointVolume volume)
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Volume = volume;
		if (IsDynamic)
		{
			CoverPoint obj = new CoverPoint(Volume, Score)
			{
				IsDynamic = true,
				SourceTransform = ((Component)this).transform,
				NormalCoverType = NormalCoverType
			};
			Transform transform = ((Component)this).transform;
			obj.Position = ((transform != null) ? transform.position : Vector3.zero);
			return obj;
		}
		Vector3 val = ((Component)this).transform.rotation * Normal;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		return new CoverPoint(Volume, Score)
		{
			IsDynamic = false,
			Position = ((Component)this).transform.position,
			Normal = normalized,
			NormalCoverType = NormalCoverType
		};
	}
}


using System;
using Rust;
using Rust.Ai;
using UnityEngine;

[DefaultExecutionOrder(-102)]
public class AiManagedAgent : FacepunchBehaviour, IServerComponent
{
	[Tooltip("TODO: Replace with actual agent type id on the NavMeshAgent when we upgrade to 5.6.1 or above.")]
	public int AgentTypeIndex;

	[NonSerialized]
	[ReadOnly]
	public Vector2i NavmeshGridCoord;

	private bool isRegistered;

	private void OnEnable()
	{
		isRegistered = false;
		if ((Object)(object)SingletonComponent<AiManager>.Instance == (Object)null || !((Behaviour)SingletonComponent<AiManager>.Instance).enabled || AiManager.nav_disable)
		{
			((Behaviour)this).enabled = false;
		}
	}

	private void DelayedRegistration()
	{
		if (!isRegistered)
		{
			isRegistered = true;
		}
	}

	private void OnDisable()
	{
		if (!Application.isQuitting && !((Object)(object)SingletonComponent<AiManager>.Instance == (Object)null) && ((Behaviour)SingletonComponent<AiManager>.Instance).enabled)
		{
			_ = isRegistered;
		}
	}
}


using System;
using Rust;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

[DefaultExecutionOrder(-103)]
public class AiManager : SingletonComponent<AiManager>, IServerComponent
{
	[Header("Cover System")]
	[SerializeField]
	public bool UseCover = true;

	public float CoverPointVolumeCellSize = 20f;

	public float CoverPointVolumeCellHeight = 8f;

	public float CoverPointRayLength = 1f;

	public CoverPointVolume cpvPrefab;

	[SerializeField]
	public LayerMask DynamicCoverPointVolumeLayerMask;

	private WorldSpaceGrid<CoverPointVolume> coverPointVolumeGrid;

	[ServerVar(Help = "If true we'll wait for the navmesh to generate before completely starting the server. This might cause your server to hitch and lag as it generates in the background.")]
	public static bool nav_wait = true;

	[ServerVar(Help = "If set to true the navmesh won't generate.. which means Ai that uses the navmesh won't be able to move")]
	public static bool nav_disable = false;

	[ServerVar(Help = "If set to true, npcs will attempt to place themselves on the navmesh if not on a navmesh when set destination is called.")]
	public static bool setdestination_navmesh_failsafe = false;

	[ServerVar(Help = "If ai_dormant is true, any npc outside the range of players will render itself dormant and take up less resources, but wildlife won't simulate as well.")]
	public static bool ai_dormant = true;

	[ServerVar(Help = "If an agent is beyond this distance to a player, it's flagged for becoming dormant.")]
	public static float ai_to_player_distance_wakeup_range = 160f;

	[ServerVar(Help = "nav_obstacles_carve_state defines which obstacles can carve the terrain. 0 - No carving, 1 - Only player construction carves, 2 - All obstacles carve.")]
	public static int nav_obstacles_carve_state = 2;

	[ServerVar(Help = "ai_dormant_max_wakeup_per_tick defines the maximum number of dormant agents we will wake up in a single tick. (default: 30)")]
	public static int ai_dormant_max_wakeup_per_tick = 30;

	[ServerVar(Help = "ai_htn_player_tick_budget defines the maximum amount of milliseconds ticking htn player agents are allowed to consume. (default: 4 ms)")]
	public static float ai_htn_player_tick_budget = 4f;

	[ServerVar(Help = "ai_htn_player_junkpile_tick_budget defines the maximum amount of milliseconds ticking htn player junkpile agents are allowed to consume. (default: 4 ms)")]
	public static float ai_htn_player_junkpile_tick_budget = 4f;

	[ServerVar(Help = "ai_htn_animal_tick_budget defines the maximum amount of milliseconds ticking htn animal agents are allowed to consume. (default: 4 ms)")]
	public static float ai_htn_animal_tick_budget = 4f;

	[ServerVar(Help = "If ai_htn_use_agency_tick is true, the ai manager's agency system will tick htn agents at the ms budgets defined in ai_htn_player_tick_budget and ai_htn_animal_tick_budget. If it's false, each agent registers with the invoke system individually, with no frame-budget restrictions. (default: true)")]
	public static bool ai_htn_use_agency_tick = true;

	private readonly BasePlayer[] playerVicinityQuery = new BasePlayer[1];

	private readonly Func<BasePlayer, bool> filter = InterestedInPlayersOnly;

	[ServerVar(Help = "The maximum amount of nodes processed each frame in the asynchronous pathfinding process. Increasing this value will cause the paths to be processed faster, but can cause some hiccups in frame rate. Default value is 100, a good range for tuning is between 50 and 500.")]
	public static int pathfindingIterationsPerFrame
	{
		get
		{
			return NavMesh.pathfindingIterationsPerFrame;
		}
		set
		{
			NavMesh.pathfindingIterationsPerFrame = value;
		}
	}

	public bool repeat => true;

	internal void OnEnableAgency()
	{
	}

	internal void OnDisableAgency()
	{
	}

	internal void UpdateAgency()
	{
	}

	internal void OnEnableCover()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (coverPointVolumeGrid == null)
		{
			Vector3 size = TerrainMeta.Size;
			coverPointVolumeGrid = new WorldSpaceGrid<CoverPointVolume>(size.x, CoverPointVolumeCellSize, (RoundingMode)0);
		}
	}

	internal void OnDisableCover()
	{
		if (coverPointVolumeGrid != null && coverPointVolumeGrid.Cells != null)
		{
			for (int i = 0; i < coverPointVolumeGrid.Cells.Length; i++)
			{
				Object.Destroy((Object)(object)coverPointVolumeGrid.Cells[i]);
			}
		}
	}

	public static CoverPointVolume CreateNewCoverVolume(Vector3 point, Transform coverPointGroup)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SingletonComponent<AiManager>.Instance != (Object)null && ((Behaviour)SingletonComponent<AiManager>.Instance).enabled && SingletonComponent<AiManager>.Instance.UseCover)
		{
			CoverPointVolume coverPointVolume = SingletonComponent<AiManager>.Instance.GetCoverVolumeContaining(point);
			if ((Object)(object)coverPointVolume == (Object)null)
			{
				Vector2i val = SingletonComponent<AiManager>.Instance.coverPointVolumeGrid.WorldToGridCoords(point);
				coverPointVolume = ((!((Object)(object)SingletonComponent<AiManager>.Instance.cpvPrefab != (Object)null)) ? new GameObject("CoverPointVolume").AddComponent<CoverPointVolume>() : Object.Instantiate<CoverPointVolume>(SingletonComponent<AiManager>.Instance.cpvPrefab));
				((Component)coverPointVolume).transform.localPosition = default(Vector3);
				((Component)coverPointVolume).transform.position = SingletonComponent<AiManager>.Instance.coverPointVolumeGrid.GridToWorldCoords(val) + Vector3.up * point.y;
				((Component)coverPointVolume).transform.localScale = new Vector3(SingletonComponent<AiManager>.Instance.CoverPointVolumeCellSize, SingletonComponent<AiManager>.Instance.CoverPointVolumeCellHeight, SingletonComponent<AiManager>.Instance.CoverPointVolumeCellSize);
				coverPointVolume.CoverLayerMask = SingletonComponent<AiManager>.Instance.DynamicCoverPointVolumeLayerMask;
				coverPointVolume.CoverPointRayLength = SingletonComponent<AiManager>.Instance.CoverPointRayLength;
				SingletonComponent<AiManager>.Instance.coverPointVolumeGrid[val] = coverPointVolume;
				coverPointVolume.GenerateCoverPoints(coverPointGroup);
			}
			return coverPointVolume;
		}
		return null;
	}

	public CoverPointVolume GetCoverVolumeContaining(Vector3 point)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (coverPointVolumeGrid == null)
		{
			return null;
		}
		Vector2i val = coverPointVolumeGrid.WorldToGridCoords(point);
		return coverPointVolumeGrid[val];
	}

	public void Initialize()
	{
		OnEnableAgency();
		if (UseCover)
		{
			OnEnableCover();
		}
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			OnDisableAgency();
			if (UseCover)
			{
				OnDisableCover();
			}
		}
	}

	public float? ExecuteUpdate(float deltaTime, float nextInterval)
	{
		if (nav_disable)
		{
			return nextInterval;
		}
		UpdateAgency();
		return Random.value + 1f;
	}

	private static bool InterestedInPlayersOnly(BaseEntity entity)
	{
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return false;
		}
		if (basePlayer.IsSleeping() || !basePlayer.IsConnected)
		{
			return false;
		}
		return true;
	}
}


using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;

public class Memory
{
	public struct SeenInfo
	{
		public BaseEntity Entity;

		public Vector3 Position;

		public float Timestamp;

		public float Danger;
	}

	public struct ExtendedInfo
	{
		public BaseEntity Entity;

		public Vector3 Direction;

		public float Dot;

		public float DistanceSqr;

		public byte LineOfSight;

		public float LastHurtUsTime;
	}

	public List<BaseEntity> Visible = new List<BaseEntity>();

	public List<SeenInfo> All = new List<SeenInfo>();

	public List<ExtendedInfo> AllExtended = new List<ExtendedInfo>();

	public SeenInfo Update(BaseEntity entity, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, out ExtendedInfo extendedInfo)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return Update(entity, entity.ServerPosition, score, direction, dot, distanceSqr, lineOfSight, updateLastHurtUsTime, lastHurtUsTime, out extendedInfo);
	}

	public SeenInfo Update(BaseEntity entity, Vector3 position, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, out ExtendedInfo extendedInfo)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		extendedInfo = default(ExtendedInfo);
		bool flag = false;
		for (int i = 0; i < AllExtended.Count; i++)
		{
			if ((Object)(object)AllExtended[i].Entity == (Object)(object)entity)
			{
				ExtendedInfo extendedInfo2 = AllExtended[i];
				extendedInfo2.Direction = direction;
				extendedInfo2.Dot = dot;
				extendedInfo2.DistanceSqr = distanceSqr;
				extendedInfo2.LineOfSight = lineOfSight;
				if (updateLastHurtUsTime)
				{
					extendedInfo2.LastHurtUsTime = lastHurtUsTime;
				}
				AllExtended[i] = extendedInfo2;
				extendedInfo = extendedInfo2;
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			if (updateLastHurtUsTime)
			{
				ExtendedInfo extendedInfo3 = default(ExtendedInfo);
				extendedInfo3.Entity = entity;
				extendedInfo3.Direction = direction;
				extendedInfo3.Dot = dot;
				extendedInfo3.DistanceSqr = distanceSqr;
				extendedInfo3.LineOfSight = lineOfSight;
				extendedInfo3.LastHurtUsTime = lastHurtUsTime;
				ExtendedInfo extendedInfo4 = extendedInfo3;
				AllExtended.Add(extendedInfo4);
				extendedInfo = extendedInfo4;
			}
			else
			{
				ExtendedInfo extendedInfo3 = default(ExtendedInfo);
				extendedInfo3.Entity = entity;
				extendedInfo3.Direction = direction;
				extendedInfo3.Dot = dot;
				extendedInfo3.DistanceSqr = distanceSqr;
				extendedInfo3.LineOfSight = lineOfSight;
				ExtendedInfo extendedInfo5 = extendedInfo3;
				AllExtended.Add(extendedInfo5);
				extendedInfo = extendedInfo5;
			}
		}
		return Update(entity, position, score);
	}

	public SeenInfo Update(BaseEntity ent, float danger = 0f)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return Update(ent, ent.ServerPosition, danger);
	}

	public SeenInfo Update(BaseEntity ent, Vector3 position, float danger = 0f)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < All.Count; i++)
		{
			if ((Object)(object)All[i].Entity == (Object)(object)ent)
			{
				SeenInfo seenInfo = All[i];
				seenInfo.Position = position;
				seenInfo.Timestamp = Time.realtimeSinceStartup;
				seenInfo.Danger += danger;
				All[i] = seenInfo;
				return seenInfo;
			}
		}
		SeenInfo seenInfo2 = default(SeenInfo);
		seenInfo2.Entity = ent;
		seenInfo2.Position = position;
		seenInfo2.Timestamp = Time.realtimeSinceStartup;
		seenInfo2.Danger = danger;
		SeenInfo seenInfo3 = seenInfo2;
		All.Add(seenInfo3);
		Visible.Add(ent);
		return seenInfo3;
	}

	public void AddDanger(Vector3 position, float amount)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < All.Count; i++)
		{
			if (Mathf.Approximately(All[i].Position.x, position.x) && Mathf.Approximately(All[i].Position.y, position.y) && Mathf.Approximately(All[i].Position.z, position.z))
			{
				SeenInfo value = All[i];
				value.Danger = amount;
				All[i] = value;
				return;
			}
		}
		All.Add(new SeenInfo
		{
			Position = position,
			Timestamp = Time.realtimeSinceStartup,
			Danger = amount
		});
	}

	public SeenInfo GetInfo(BaseEntity entity)
	{
		foreach (SeenInfo item in All)
		{
			if ((Object)(object)item.Entity == (Object)(object)entity)
			{
				return item;
			}
		}
		return default(SeenInfo);
	}

	public SeenInfo GetInfo(Vector3 position)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		foreach (SeenInfo item in All)
		{
			Vector3 val = item.Position - position;
			if (((Vector3)(ref val)).sqrMagnitude < 1f)
			{
				return item;
			}
		}
		return default(SeenInfo);
	}

	public ExtendedInfo GetExtendedInfo(BaseEntity entity)
	{
		foreach (ExtendedInfo item in AllExtended)
		{
			if ((Object)(object)item.Entity == (Object)(object)entity)
			{
				return item;
			}
		}
		return default(ExtendedInfo);
	}

	internal void Forget(float maxSecondsOld)
	{
		for (int i = 0; i < All.Count; i++)
		{
			float num = Time.realtimeSinceStartup - All[i].Timestamp;
			if (num > maxSecondsOld)
			{
				if ((Object)(object)All[i].Entity != (Object)null)
				{
					Visible.Remove(All[i].Entity);
					for (int j = 0; j < AllExtended.Count; j++)
					{
						if ((Object)(object)AllExtended[j].Entity == (Object)(object)All[i].Entity)
						{
							AllExtended.RemoveAt(j);
							break;
						}
					}
				}
				All.RemoveAt(i);
				i--;
			}
			else
			{
				if (!(num > 0f))
				{
					continue;
				}
				float num2 = num / maxSecondsOld;
				if (All[i].Danger > 0f)
				{
					SeenInfo value = All[i];
					value.Danger -= num2;
					All[i] = value;
				}
				if (!(num >= 1f))
				{
					continue;
				}
				for (int k = 0; k < AllExtended.Count; k++)
				{
					if ((Object)(object)AllExtended[k].Entity == (Object)(object)All[i].Entity)
					{
						ExtendedInfo value2 = AllExtended[k];
						value2.LineOfSight = 0;
						AllExtended[k] = value2;
						break;
					}
				}
			}
		}
		for (int l = 0; l < Visible.Count; l++)
		{
			if ((Object)(object)Visible[l] == (Object)null)
			{
				Visible.RemoveAt(l);
				l--;
			}
		}
		for (int m = 0; m < AllExtended.Count; m++)
		{
			if ((Object)(object)AllExtended[m].Entity == (Object)null)
			{
				AllExtended.RemoveAt(m);
				m--;
			}
		}
	}
}


using UnityEngine;

public struct SeenInfo
{
	public BaseEntity Entity;

	public Vector3 Position;

	public float Timestamp;

	public float Danger;
}


using UnityEngine;

public struct ExtendedInfo
{
	public BaseEntity Entity;

	public Vector3 Direction;

	public float Dot;

	public float DistanceSqr;

	public byte LineOfSight;

	public float LastHurtUsTime;
}


using UnityEngine;

public class NavmeshPrefabInstantiator : MonoBehaviour
{
	public GameObjectRef NavmeshPrefab;

	private void Start()
	{
		if (NavmeshPrefab != null)
		{
			NavmeshPrefab.Instantiate(((Component)this).transform).SetActive(true);
			Object.Destroy((Object)(object)this);
		}
	}
}


using ConVar;
using Rust.Ai;
using UnityEngine;

public class ScientistSpawner : SpawnGroup
{
	[Header("Scientist Spawner")]
	public bool Mobile = true;

	public bool NeverMove;

	public bool SpawnHostile;

	public bool OnlyAggroMarkedTargets = true;

	public bool IsPeacekeeper = true;

	public bool IsBandit;

	public bool IsMilitaryTunnelLab;

	public WaypointSet Waypoints;

	public Transform[] LookAtInterestPointsStationary;

	public Vector2 RadioEffectRepeatRange = new Vector2(10f, 15f);

	public Model Model;

	[SerializeField]
	private AiLocationManager _mgr;

	private float _nextForcedRespawn = float.PositiveInfinity;

	private bool _lastSpawnCallHadAliveMembers;

	private bool _lastSpawnCallHadMaxAliveMembers;

	protected override void Spawn(int numToSpawn)
	{
		if (!AI.npc_enable)
		{
			return;
		}
		if (base.currentPopulation == maxPopulation)
		{
			_lastSpawnCallHadMaxAliveMembers = true;
			_lastSpawnCallHadAliveMembers = true;
			return;
		}
		if (_lastSpawnCallHadMaxAliveMembers)
		{
			_nextForcedRespawn = Time.time + 2200f;
		}
		if (Time.time < _nextForcedRespawn)
		{
			if (base.currentPopulation == 0 && _lastSpawnCallHadAliveMembers)
			{
				_lastSpawnCallHadMaxAliveMembers = false;
				_lastSpawnCallHadAliveMembers = false;
				return;
			}
			if (base.currentPopulation > 0)
			{
				_lastSpawnCallHadMaxAliveMembers = false;
				_lastSpawnCallHadAliveMembers = base.currentPopulation > 0;
				return;
			}
		}
		_lastSpawnCallHadMaxAliveMembers = false;
		_lastSpawnCallHadAliveMembers = base.currentPopulation > 0;
		base.Spawn(numToSpawn);
	}

	protected override void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
	{
	}

	protected override void OnDrawGizmos()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		base.OnDrawGizmos();
		if (LookAtInterestPointsStationary == null || LookAtInterestPointsStationary.Length == 0)
		{
			return;
		}
		Gizmos.color = Color.magenta - new Color(0f, 0f, 0f, 0.5f);
		Transform[] lookAtInterestPointsStationary = LookAtInterestPointsStationary;
		foreach (Transform val in lookAtInterestPointsStationary)
		{
			if ((Object)(object)val != (Object)null)
			{
				Gizmos.DrawSphere(val.position, 0.1f);
				Gizmos.DrawLine(((Component)this).transform.position, val.position);
			}
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class AiLocationManager : FacepunchBehaviour, IServerComponent
{
	public static List<AiLocationManager> Managers = new List<AiLocationManager>();

	[SerializeField]
	public AiLocationSpawner MainSpawner;

	[SerializeField]
	public AiLocationSpawner.SquadSpawnerLocation LocationWhenMainSpawnerIsNull = AiLocationSpawner.SquadSpawnerLocation.None;

	public Transform CoverPointGroup;

	public Transform PatrolPointGroup;

	public CoverPointVolume DynamicCoverPointVolume;

	public bool SnapCoverPointsToGround;

	private List<PathInterestNode> patrolPoints;

	public AiLocationSpawner.SquadSpawnerLocation LocationType
	{
		get
		{
			if ((Object)(object)MainSpawner != (Object)null)
			{
				return MainSpawner.Location;
			}
			return LocationWhenMainSpawnerIsNull;
		}
	}

	private void Awake()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Managers.Add(this);
		if (!SnapCoverPointsToGround)
		{
			return;
		}
		AICoverPoint[] componentsInChildren = ((Component)CoverPointGroup).GetComponentsInChildren<AICoverPoint>();
		NavMeshHit val = default(NavMeshHit);
		foreach (AICoverPoint aICoverPoint in componentsInChildren)
		{
			if (NavMesh.SamplePosition(((Component)aICoverPoint).transform.position, ref val, 4f, -1))
			{
				((Component)aICoverPoint).transform.position = ((NavMeshHit)(ref val)).position;
			}
		}
	}

	private void OnDestroy()
	{
		Managers.Remove(this);
	}

	public PathInterestNode GetFirstPatrolPointInRange(Vector3 from, float minRange = 10f, float maxRange = 100f)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)PatrolPointGroup == (Object)null)
		{
			return null;
		}
		if (patrolPoints == null)
		{
			patrolPoints = new List<PathInterestNode>(((Component)PatrolPointGroup).GetComponentsInChildren<PathInterestNode>());
		}
		if (patrolPoints.Count == 0)
		{
			return null;
		}
		float num = minRange * minRange;
		float num2 = maxRange * maxRange;
		foreach (PathInterestNode patrolPoint in patrolPoints)
		{
			Vector3 val = ((Component)patrolPoint).transform.position - from;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			if (sqrMagnitude >= num && sqrMagnitude <= num2)
			{
				return patrolPoint;
			}
		}
		return null;
	}

	public PathInterestNode GetRandomPatrolPointInRange(Vector3 from, float minRange = 10f, float maxRange = 100f, PathInterestNode currentPatrolPoint = null)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)PatrolPointGroup == (Object)null)
		{
			return null;
		}
		if (patrolPoints == null)
		{
			patrolPoints = new List<PathInterestNode>(((Component)PatrolPointGroup).GetComponentsInChildren<PathInterestNode>());
		}
		if (patrolPoints.Count == 0)
		{
			return null;
		}
		float num = minRange * minRange;
		float num2 = maxRange * maxRange;
		for (int i = 0; i < 20; i++)
		{
			PathInterestNode pathInterestNode = patrolPoints[Random.Range(0, patrolPoints.Count)];
			if (Time.time < pathInterestNode.NextVisitTime)
			{
				if ((Object)(object)pathInterestNode == (Object)(object)currentPatrolPoint)
				{
					return null;
				}
				continue;
			}
			Vector3 val = ((Component)pathInterestNode).transform.position - from;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			if (sqrMagnitude >= num && sqrMagnitude <= num2)
			{
				pathInterestNode.NextVisitTime = Time.time + AI.npc_patrol_point_cooldown;
				return pathInterestNode;
			}
		}
		return null;
	}
}


using ConVar;
using Rust.Ai;
using UnityEngine;

public class AiLocationSpawner : SpawnGroup
{
	public enum SquadSpawnerLocation
	{
		MilitaryTunnels,
		JunkpileA,
		JunkpileG,
		CH47,
		None,
		Compound,
		BanditTown,
		CargoShip
	}

	public SquadSpawnerLocation Location;

	public AiLocationManager Manager;

	public JunkPile Junkpile;

	public bool IsMainSpawner = true;

	public float chance = 1f;

	private int defaultMaxPopulation;

	private int defaultNumToSpawnPerTickMax;

	private int defaultNumToSpawnPerTickMin;

	public override void SpawnInitial()
	{
		if (IsMainSpawner)
		{
			if (Location == SquadSpawnerLocation.MilitaryTunnels)
			{
				maxPopulation = AI.npc_max_population_military_tunnels;
				numToSpawnPerTickMax = AI.npc_spawn_per_tick_max_military_tunnels;
				numToSpawnPerTickMin = AI.npc_spawn_per_tick_min_military_tunnels;
				respawnDelayMax = AI.npc_respawn_delay_max_military_tunnels;
				respawnDelayMin = AI.npc_respawn_delay_min_military_tunnels;
			}
			else
			{
				defaultMaxPopulation = maxPopulation;
				defaultNumToSpawnPerTickMax = numToSpawnPerTickMax;
				defaultNumToSpawnPerTickMin = numToSpawnPerTickMin;
			}
		}
		else
		{
			defaultMaxPopulation = maxPopulation;
			defaultNumToSpawnPerTickMax = numToSpawnPerTickMax;
			defaultNumToSpawnPerTickMin = numToSpawnPerTickMin;
		}
		base.SpawnInitial();
	}

	protected override void Spawn(int numToSpawn)
	{
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.npc_enable)
		{
			maxPopulation = 0;
			numToSpawnPerTickMax = 0;
			numToSpawnPerTickMin = 0;
			return;
		}
		if (numToSpawn == 0)
		{
			if (IsMainSpawner)
			{
				if (Location == SquadSpawnerLocation.MilitaryTunnels)
				{
					maxPopulation = AI.npc_max_population_military_tunnels;
					numToSpawnPerTickMax = AI.npc_spawn_per_tick_max_military_tunnels;
					numToSpawnPerTickMin = AI.npc_spawn_per_tick_min_military_tunnels;
					numToSpawn = Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1);
				}
				else
				{
					maxPopulation = defaultMaxPopulation;
					numToSpawnPerTickMax = defaultNumToSpawnPerTickMax;
					numToSpawnPerTickMin = defaultNumToSpawnPerTickMin;
					numToSpawn = Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1);
				}
			}
			else
			{
				maxPopulation = defaultMaxPopulation;
				numToSpawnPerTickMax = defaultNumToSpawnPerTickMax;
				numToSpawnPerTickMin = defaultNumToSpawnPerTickMin;
				numToSpawn = Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1);
			}
		}
		float npc_junkpilespawn_chance = chance;
		switch (Location)
		{
		case SquadSpawnerLocation.JunkpileA:
			npc_junkpilespawn_chance = AI.npc_junkpilespawn_chance;
			break;
		case SquadSpawnerLocation.JunkpileG:
			npc_junkpilespawn_chance = AI.npc_junkpilespawn_chance;
			break;
		}
		if (numToSpawn == 0 || Random.value > npc_junkpilespawn_chance)
		{
			return;
		}
		numToSpawn = Mathf.Min(numToSpawn, maxPopulation - base.currentPopulation);
		for (int i = 0; i < numToSpawn; i++)
		{
			GameObjectRef prefab = GetPrefab();
			Vector3 pos;
			Quaternion rot;
			BaseSpawnPoint spawnPoint = GetSpawnPoint(prefab, out pos, out rot);
			if (Object.op_Implicit((Object)(object)spawnPoint))
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(prefab.resourcePath, pos, rot);
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					baseEntity.Spawn();
					SpawnPointInstance spawnPointInstance = ((Component)baseEntity).gameObject.AddComponent<SpawnPointInstance>();
					spawnPointInstance.parentSpawnPointUser = this;
					spawnPointInstance.parentSpawnPoint = spawnPoint;
					spawnPointInstance.Entity = baseEntity;
					spawnPointInstance.Notify();
				}
			}
		}
	}

	protected override BaseSpawnPoint GetSpawnPoint(GameObjectRef prefabRef, out Vector3 pos, out Quaternion rot)
	{
		return base.GetSpawnPoint(prefabRef, out pos, out rot);
	}
}


public enum SquadSpawnerLocation
{
	MilitaryTunnels,
	JunkpileA,
	JunkpileG,
	CH47,
	None,
	Compound,
	BanditTown,
	CargoShip
}


using System;
using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;

public class WaypointSet : MonoBehaviour, IServerComponent
{
	public enum NavModes
	{
		Loop,
		PingPong
	}

	[Serializable]
	public struct Waypoint
	{
		public Transform Transform;

		public float WaitTime;

		public Transform[] LookatPoints;

		[NonSerialized]
		public bool IsOccupied;
	}

	[SerializeField]
	private List<Waypoint> _points = new List<Waypoint>();

	[SerializeField]
	private NavModes navMode;

	public List<Waypoint> Points
	{
		get
		{
			return _points;
		}
		set
		{
			_points = value;
		}
	}

	public NavModes NavMode => navMode;

	private void OnDrawGizmos()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Points.Count; i++)
		{
			Transform transform = Points[i].Transform;
			if ((Object)(object)transform != (Object)null)
			{
				if (Points[i].IsOccupied)
				{
					Gizmos.color = Color.red;
				}
				else
				{
					Gizmos.color = Color.cyan;
				}
				Gizmos.DrawSphere(transform.position, 0.25f);
				Gizmos.color = Color.cyan;
				if (i + 1 < Points.Count)
				{
					Gizmos.DrawLine(transform.position, Points[i + 1].Transform.position);
				}
				else if (NavMode == NavModes.Loop)
				{
					Gizmos.DrawLine(transform.position, Points[0].Transform.position);
				}
				Gizmos.color = Color.magenta - new Color(0f, 0f, 0f, 0.5f);
				Transform[] lookatPoints = Points[i].LookatPoints;
				foreach (Transform val in lookatPoints)
				{
					Gizmos.DrawSphere(val.position, 0.1f);
					Gizmos.DrawLine(transform.position, val.position);
				}
			}
		}
	}
}


public enum NavModes
{
	Loop,
	PingPong
}


using System;
using UnityEngine;

[Serializable]
public struct Waypoint
{
	public Transform Transform;

	public float WaitTime;

	public Transform[] LookatPoints;

	[NonSerialized]
	public bool IsOccupied;
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using Rust.Ai.HTN.ScientistJunkpile;
using UnityEngine;

public class ScientistJunkpileSpawner : MonoBehaviour, IServerComponent, ISpawnGroup
{
	public enum JunkpileType
	{
		A,
		B,
		C,
		D,
		E,
		F,
		G
	}

	public GameObjectRef ScientistPrefab;

	[NonSerialized]
	public List<BaseCombatEntity> Spawned = new List<BaseCombatEntity>();

	[NonSerialized]
	public BaseSpawnPoint[] SpawnPoints;

	public int MaxPopulation = 1;

	public bool InitialSpawn;

	public float MinRespawnTimeMinutes = 120f;

	public float MaxRespawnTimeMinutes = 120f;

	public float MovementRadius = -1f;

	public bool ReducedLongRangeAccuracy;

	public JunkpileType SpawnType;

	[Range(0f, 1f)]
	public float SpawnBaseChance = 1f;

	private float nextRespawnTime;

	private bool pendingRespawn;

	public int currentPopulation => Spawned.Count;

	private void Awake()
	{
		SpawnPoints = ((Component)this).GetComponentsInChildren<BaseSpawnPoint>();
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Add((ISpawnGroup)this);
		}
	}

	protected void OnDestroy()
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Remove((ISpawnGroup)this);
		}
		else
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": SpawnHandler instance not found."));
		}
	}

	public void Fill()
	{
		DoRespawn();
	}

	public void Clear()
	{
		if (Spawned == null)
		{
			return;
		}
		foreach (BaseCombatEntity item in Spawned)
		{
			if (!((Object)(object)item == (Object)null) && !((Object)(object)((Component)item).gameObject == (Object)null) && !((Object)(object)((Component)item).transform == (Object)null))
			{
				BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					baseEntity.Kill();
				}
			}
		}
		Spawned.Clear();
	}

	public void SpawnInitial()
	{
		nextRespawnTime = Time.time + Random.Range(3f, 4f);
		pendingRespawn = true;
	}

	public void SpawnRepeating()
	{
		CheckIfRespawnNeeded();
	}

	public void CheckIfRespawnNeeded()
	{
		if (!pendingRespawn)
		{
			if (Spawned == null || Spawned.Count == 0 || IsAllSpawnedDead())
			{
				ScheduleRespawn();
			}
		}
		else if ((Spawned == null || Spawned.Count == 0 || IsAllSpawnedDead()) && Time.time >= nextRespawnTime)
		{
			DoRespawn();
		}
	}

	private bool IsAllSpawnedDead()
	{
		int num = 0;
		while (num < Spawned.Count)
		{
			BaseCombatEntity baseCombatEntity = Spawned[num];
			if ((Object)(object)baseCombatEntity == (Object)null || (Object)(object)((Component)baseCombatEntity).transform == (Object)null || baseCombatEntity.IsDestroyed || baseCombatEntity.IsDead())
			{
				Spawned.RemoveAt(num);
				num--;
				num++;
				continue;
			}
			return false;
		}
		return true;
	}

	public void ScheduleRespawn()
	{
		nextRespawnTime = Time.time + Random.Range(MinRespawnTimeMinutes, MaxRespawnTimeMinutes) * 60f;
		pendingRespawn = true;
	}

	public void DoRespawn()
	{
		if (!Application.isLoading && !Application.isLoadingSave)
		{
			SpawnScientist();
		}
		pendingRespawn = false;
	}

	public void SpawnScientist()
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.npc_enable || Spawned == null || Spawned.Count >= MaxPopulation)
		{
			return;
		}
		float num = SpawnBaseChance;
		switch (SpawnType)
		{
		case JunkpileType.A:
			num = AI.npc_junkpilespawn_chance;
			break;
		case JunkpileType.G:
			num = AI.npc_junkpilespawn_chance;
			break;
		}
		if (Random.value > num)
		{
			return;
		}
		int num2 = MaxPopulation - Spawned.Count;
		for (int i = 0; i < num2; i++)
		{
			if (!((Object)(object)GetSpawnPoint(out var pos, out var rot) == (Object)null))
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(ScientistPrefab.resourcePath, pos, rot, startActive: false);
				if (!((Object)(object)baseEntity != (Object)null))
				{
					break;
				}
				baseEntity.enableSaving = false;
				((Component)baseEntity).gameObject.AwakeFromInstantiate();
				baseEntity.Spawn();
				Spawned.Add((BaseCombatEntity)baseEntity);
			}
		}
	}

	private BaseSpawnPoint GetSpawnPoint(out Vector3 pos, out Quaternion rot)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		BaseSpawnPoint baseSpawnPoint = null;
		pos = Vector3.zero;
		rot = Quaternion.identity;
		int num = Random.Range(0, SpawnPoints.Length);
		for (int i = 0; i < SpawnPoints.Length; i++)
		{
			baseSpawnPoint = SpawnPoints[(num + i) % SpawnPoints.Length];
			if (Object.op_Implicit((Object)(object)baseSpawnPoint) && ((Component)baseSpawnPoint).gameObject.activeSelf)
			{
				break;
			}
		}
		if (Object.op_Implicit((Object)(object)baseSpawnPoint))
		{
			baseSpawnPoint.GetLocation(out pos, out rot);
		}
		return baseSpawnPoint;
	}
}


public enum JunkpileType
{
	A,
	B,
	C,
	D,
	E,
	F,
	G
}


using System;
using FIMSpace.FLook;
using FIMSpace.FSpine;
using Network;
using Rust.Ai.Gen2;
using UnityEngine;

public class NPCAnimController : EntityComponent<BaseEntity>, IClientComponent
{
	public enum AnimatorType
	{
		NoStrafe,
		Strafe
	}

	[SerializeField]
	private AnimatorType animatorType;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private FSpineAnimator spineAnimator;

	[SerializeField]
	private FLookAnimator lookAnimator;

	[SerializeField]
	private float maxWalkingSpeed;

	[SerializeField]
	private string[] animationBlacklist = new string[4] { "prowl", "walk", "trot", "run" };

	[SerializeField]
	private int animatorLayer;

	[SerializeField]
	private float maxPitchToConformToSlope = 30f;

	[SerializeField]
	private string animationsPrefix = "wolf_";

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("NPCAnimController.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}
}


public enum AnimatorType
{
	NoStrafe,
	Strafe
}


using System;
using ConVar;
using Network;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(LimitedTurnNavAgent))]
public class RootMotionPlayer : EntityComponent<BaseEntity>
{
	private struct PlayServerState
	{
		public AnimationClip animCLip;

		public RootMotionData rmData;

		public Action onComplete;

		public float elapsedTime;

		public Vector3 lastFrameOffset;

		public Quaternion initialRotation;

		public Action ServerTickAction;

		public PlayServerState(RootMotionData data, Quaternion initialRotation, Action onComplete)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			rmData = data;
			animCLip = null;
			this.onComplete = onComplete;
			this.initialRotation = initialRotation;
			elapsedTime = 0f;
			lastFrameOffset = Vector3.zero;
			ServerTickAction = null;
		}

		public PlayServerState(AnimationClip data, Quaternion initialRotation, Action onComplete)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			animCLip = data;
			rmData = null;
			this.onComplete = onComplete;
			this.initialRotation = initialRotation;
			elapsedTime = 0f;
			lastFrameOffset = Vector3.zero;
			ServerTickAction = null;
		}

		public int GetAnimHash()
		{
			if (!(rmData != null))
			{
				return Animator.StringToHash(((Object)animCLip).name);
			}
			return Animator.StringToHash(((Object)rmData.inPlaceAnimation).name);
		}

		public float GetAnimLength()
		{
			if (!(rmData != null))
			{
				return animCLip.length;
			}
			return rmData.inPlaceAnimation.length;
		}
	}

	[Header("Client")]
	[SerializeField]
	private Animator animator;

	private LimitedTurnNavAgent _agent;

	private PlayServerState currentPlayState;

	private Action _playServerTickAction;

	private LockState.LockHandle lockHandle;

	private LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>());

	private Action PlayServerTickAction => PlayServerTick;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("RootMotionPlayer.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void PlayServer(RootMotionData Data, Action onComplete = null)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		currentPlayState = new PlayServerState(Data, ((Component)base.baseEntity).transform.rotation, onComplete);
		_PlayServer();
	}

	public void PlayServer(AnimationClip Data, Action onComplete = null)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		currentPlayState = new PlayServerState(Data, ((Component)base.baseEntity).transform.rotation, onComplete);
		_PlayServer();
	}

	private void _PlayServer()
	{
		StopServer(sendStopClientRPC: false);
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayAnimation"), currentPlayState.GetAnimHash());
		lockHandle = Agent.Pause();
		((FacepunchBehaviour)base.baseEntity).InvokeRepeating(PlayServerTickAction, 0f, 0f);
	}

	private void PlayServerTick()
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("RootMotionPlayer:PlayServerTick", 0);
		try
		{
			if (currentPlayState.rmData != null)
			{
				float num = currentPlayState.rmData.xMotionCurve.Evaluate(currentPlayState.elapsedTime);
				float num2 = currentPlayState.rmData.zMotionCurve.Evaluate(currentPlayState.elapsedTime);
				float num3 = currentPlayState.rmData.yRotationCurve.Evaluate(currentPlayState.elapsedTime);
				Vector3 val2 = currentPlayState.initialRotation * new Vector3(num, 0f, num2);
				Vector3 offset = val2 - currentPlayState.lastFrameOffset;
				currentPlayState.lastFrameOffset = val2;
				Agent.Move(offset);
				((Component)base.baseEntity).transform.rotation = Quaternion.Euler(0f, num3, 0f) * currentPlayState.initialRotation;
			}
			currentPlayState.elapsedTime += Time.deltaTime;
			if (currentPlayState.elapsedTime >= currentPlayState.GetAnimLength() - Animation.defaultFadeDuration)
			{
				StopServer(sendStopClientRPC: false);
				currentPlayState.onComplete?.Invoke();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void StopServer(bool sendStopClientRPC = true)
	{
		if (((FacepunchBehaviour)base.baseEntity).IsInvoking(PlayServerTickAction))
		{
			((FacepunchBehaviour)base.baseEntity).CancelInvoke(PlayServerTickAction);
			Agent.Unpause(ref lockHandle);
			if (sendStopClientRPC)
			{
				base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_StopAnimation"));
			}
		}
	}
}


using System;
using UnityEngine;

private struct PlayServerState
{
	public AnimationClip animCLip;

	public RootMotionData rmData;

	public Action onComplete;

	public float elapsedTime;

	public Vector3 lastFrameOffset;

	public Quaternion initialRotation;

	public Action ServerTickAction;

	public PlayServerState(RootMotionData data, Quaternion initialRotation, Action onComplete)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		rmData = data;
		animCLip = null;
		this.onComplete = onComplete;
		this.initialRotation = initialRotation;
		elapsedTime = 0f;
		lastFrameOffset = Vector3.zero;
		ServerTickAction = null;
	}

	public PlayServerState(AnimationClip data, Quaternion initialRotation, Action onComplete)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		animCLip = data;
		rmData = null;
		this.onComplete = onComplete;
		this.initialRotation = initialRotation;
		elapsedTime = 0f;
		lastFrameOffset = Vector3.zero;
		ServerTickAction = null;
	}

	public int GetAnimHash()
	{
		if (!(rmData != null))
		{
			return Animator.StringToHash(((Object)animCLip).name);
		}
		return Animator.StringToHash(((Object)rmData.inPlaceAnimation).name);
	}

	public float GetAnimLength()
	{
		if (!(rmData != null))
		{
			return animCLip.length;
		}
		return rmData.inPlaceAnimation.length;
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(Wolf2FSM))]
public class Wolf2 : BaseNPC2
{
	private Wolf2FSM FSM;

	public override string Categorize()
	{
		return "Wolf";
	}

	public override void ServerInit()
	{
		base.ServerInit();
		FSM = ((Component)this).GetComponent<Wolf2FSM>();
	}

	public override void Hurt(HitInfo hitInfo)
	{
		base.Hurt(hitInfo);
		if (!((Object)(object)FSM == (Object)null))
		{
			FSM.Hurt(hitInfo);
		}
	}

	public override void OnDied(HitInfo hitInfo)
	{
		if ((Object)(object)FSM == (Object)null)
		{
			base.OnDied(hitInfo);
		}
		else
		{
			FSM.Die(hitInfo);
		}
	}
}


public static class NPCRangeConstants
{
	public const float MeleeRange = 2f;

	public const float CloseRange = 10f;

	public const float MediumRange = 16f;

	public const float LongRange = 50f;
}


public static class FireConstants
{
	public const float fireCirclingRadius = 16f;

	public const string HitByFire = "HitByFire";
}


using System;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class Wolf2FSM : FSMComponent
{
	[Serializable]
	public class WolfFSMData
	{
		public State_PlayRandomAnimation randomIdle = new State_PlayRandomAnimation();

		public State_Roam roam = new State_Roam();

		public State_Howl howl = new State_Howl();

		public State_CircleDynamic approach = new State_CircleDynamic();

		public State_Bark bark = new State_Bark();

		public State_Growl growlFire = new State_Growl();

		public State_ApproachFire approachFire = new State_ApproachFire();

		public State_FleeFire fleeFire = new State_FleeFire();

		public State_MoveToTarget charge = new State_MoveToTarget();

		public State_Attack attack = new State_Attack();

		public State_PlayAnimationRM leapAway = new State_PlayAnimationRM();

		public State_Circle reacCircle = new State_Circle();

		public State_CircleDynamic fastApproach = new State_CircleDynamic();

		public State_Hurt hurt = new State_Hurt();

		public State_Intimidated intimidated = new State_Intimidated();

		public State_Flee flee = new State_Flee();

		public State_Flee fleeShort = new State_Flee();

		public State_Dead dead = new State_Dead();

		public State_ApproachFood approachFood = new State_ApproachFood();

		public State_EatFood eatFood = new State_EatFood();

		public State_PlayAnimationRM growlFood = new State_PlayAnimationRM();

		public State_PlayAnimLoop sleep = new State_PlayAnimLoop();

		public State_AttackUnreachable attackUnreachable = new State_AttackUnreachable();
	}

	[SerializeField]
	private WolfFSMData data = new WolfFSMData();

	private Trans_Triggerable_HitInfo HurtTrans;

	private Trans_Triggerable_HitInfo DeathTrans;

	private Trans_Triggerable<BaseEntity> AllyGotHurtNearby;

	private Trans_Triggerable<BaseEntity> HowlTrans;

	private Trans_Triggerable<BaseEntity> BarkTrans;

	private void Start()
	{
		BaseEntity.Query.Server.AddBrain(base.baseEntity);
	}

	private void OnDestroy()
	{
		if (!Application.isQuitting)
		{
			BaseEntity.Query.Server.RemoveBrain(base.baseEntity);
		}
	}

	public override void InitShared()
	{
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Expected O, but got Unknown
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Expected O, but got Unknown
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Expected O, but got Unknown
		if (base.baseEntity.isServer)
		{
			State_Nothing state = new State_Nothing
			{
				Name = "WaitForNavMesh"
			};
			State_Circle obj = new State_Circle
			{
				radius = 2f,
				speed = LimitedTurnNavAgent.Speeds.Sprint,
				Name = "Circle short"
			};
			State_MoveToTarget state2 = new State_MoveToTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Walk,
				decelerationOverride = 6f,
				Name = "Step forward"
			};
			State_MoveToLastReachablePointNearTarget state3 = new State_MoveToLastReachablePointNearTarget
			{
				speed = LimitedTurnNavAgent.Speeds.FullSprint,
				succeedWhenDestinationIsReached = true,
				Name = "Go to last destination"
			};
			FSMStateBase fSMStateBase = data.leapAway.Clone();
			fSMStateBase.Name = "Leap away unreachable";
			State_Flee state4 = new State_Flee
			{
				distance = 8f,
				desiredDistance = 16f,
				Name = "Flee fire after attack"
			};
			FSMStateBase fSMStateBase2 = obj.Clone();
			fSMStateBase2.Name = "Circle short fire";
			FSMStateBase fSMStateBase3 = data.charge.Clone();
			fSMStateBase3.Name = "Charge fire";
			FSMStateBase fSMStateBase4 = data.attack.Clone();
			fSMStateBase4.Name = "Attack fire";
			DeathTrans = new Trans_Triggerable_HitInfo();
			HurtTrans = new Trans_Triggerable_HitInfo();
			Trans_Triggerable PathFailedTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>().onPathFailed.AddListener((UnityAction)delegate
			{
				PathFailedTrans.Trigger();
			});
			Trans_Triggerable FireMeleeTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<SenseComponent>().onFireMelee.AddListener((UnityAction)delegate
			{
				FireMeleeTrans.Trigger();
			});
			Trans_Triggerable EncounterEndTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<NPCEncounterTimer>().onShouldGiveUp.AddListener((UnityAction)delegate
			{
				EncounterEndTrans.Trigger();
			});
			BarkTrans = new Trans_Triggerable<BaseEntity>();
			AllyGotHurtNearby = new Trans_Triggerable<BaseEntity>();
			HowlTrans = new Trans_Triggerable<BaseEntity>();
			TreeNode treeNode = new TreeNode();
			TreeNode treeNode2 = new TreeNode();
			TreeNode treeNode3 = new TreeNode();
			TreeNode treeNode4 = new TreeNode();
			TreeNode treeNode5 = new TreeNode();
			TreeNode treeNode6 = new TreeNode();
			TreeNode treeNode7 = new TreeNode();
			TreeNode treeNode8 = new TreeNode(data.howl);
			TreeNode treeNode9 = new TreeNode(data.approach);
			TreeNode treeNode10 = new TreeNode(data.bark);
			TreeNode treeNode11 = new TreeNode(data.charge);
			TreeNode treeNode12 = new TreeNode(data.attack);
			TreeNode treeNode13 = new TreeNode(data.leapAway);
			TreeNode treeNode14 = new TreeNode(obj);
			TreeNode treeNode15 = new TreeNode(data.reacCircle);
			TreeNode treeNode16 = new TreeNode(data.fastApproach);
			TreeNode treeNode17 = new TreeNode(data.fleeShort);
			TreeNode treeNode18 = new TreeNode();
			TreeNode treeNode19 = new TreeNode(state3);
			TreeNode treeNode20 = new TreeNode(data.attackUnreachable);
			TreeNode treeNode21 = new TreeNode(fSMStateBase);
			TreeNode treeNode22 = new TreeNode();
			TreeNode treeNode23 = new TreeNode(data.growlFire);
			TreeNode treeNode24 = new TreeNode(data.approachFire);
			TreeNode treeNode25 = new TreeNode(fSMStateBase2);
			TreeNode treeNode26 = new TreeNode(fSMStateBase3);
			TreeNode treeNode27 = new TreeNode(fSMStateBase4);
			TreeNode treeNode28 = new TreeNode(data.fleeFire);
			TreeNode treeNode29 = new TreeNode(state4);
			TreeNode treeNode30 = new TreeNode(state2);
			TreeNode treeNode31 = new TreeNode(data.intimidated);
			TreeNode treeNode32 = new TreeNode(data.flee);
			TreeNode treeNode33 = new TreeNode();
			TreeNode treeNode34 = new TreeNode(data.approachFood);
			TreeNode treeNode35 = new TreeNode(data.eatFood);
			TreeNode treeNode36 = new TreeNode(data.growlFood);
			TreeNode treeNode37 = new TreeNode();
			TreeNode treeNode38 = new TreeNode(data.roam);
			TreeNode treeNode39 = new TreeNode(data.hurt);
			TreeNode treeNode40 = new TreeNode(data.dead);
			TreeNode treeNode41 = new TreeNode(state);
			TreeNode treeNode42 = new TreeNode();
			TreeNode treeNode43 = new TreeNode();
			TreeNode treeNode44 = new TreeNode(data.sleep);
			TreeNode treeNode45 = new TreeNode(data.randomIdle);
			TreeNode treeNode46 = new TreeNode(new State_Nothing
			{
				Name = "Fire entry"
			});
			TreeNode treeNode47 = new TreeNode(new State_Nothing
			{
				Name = "Combat entry"
			});
			TreeNode treeNode48 = new TreeNode(new State_Nothing
			{
				Name = "Random post idle wait"
			});
			treeNode.AddChildren(treeNode2.AddTickTransition(treeNode40, DeathTrans).AddChildren(treeNode41.AddTickTransition(treeNode3, new Trans_IsNavmeshReady()), treeNode3.AddTickTransition(treeNode41, new Trans_IsNavmeshReady
			{
				Inverted = true
			}).AddChildren(treeNode4.AddTickTransition(treeNode39, HurtTrans).AddChildren(treeNode37.AddTickTransition(treeNode40, PathFailedTrans).AddTickTransition(treeNode9, HowlTrans).AddTickTransition(treeNode5, new Trans_HasTarget())
				.AddTickTransition(treeNode33, new Trans_SeesFood())
				.AddChildren(treeNode38.AddEndTransition(treeNode44, new Trans_RandomChance
				{
					chance = 0.25f
				}).AddEndTransition(treeNode45), treeNode44.AddEndTransition(treeNode38), treeNode45.AddEndTransition(treeNode48), treeNode48.AddTickTransition(treeNode38, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 0.0,
					MaxDuration = 3.0
				})), treeNode5.AddTickTransition(treeNode37, new Trans_HasTarget
			{
				Inverted = true
			}).AddTickTransition(treeNode32, EncounterEndTrans).AddTickTransition(treeNode32, new Trans_TargetIsInSafeZone())
				.AddChildren(treeNode7.AddTickTransition(treeNode32, new Trans_TargetOrSelfInWater()).AddTickTransition(treeNode18, PathFailedTrans).AddChildren(treeNode6.AddTickTransition(treeNode22, new Trans_TargetIsNearFire
				{
					onlySeeFireWhenClose = true
				}).AddChildren(treeNode47.AddTickTransition(treeNode8, new Trans_HasBlackboardBool
				{
					Key = "WolfNearbyAlreadyHowled",
					Inverted = true
				}).AddTickTransition(treeNode9, new Trans_AlwaysValid()), treeNode43.AddTickTransition(treeNode32, new Trans_And
				{
					AllyGotHurtNearby,
					new Trans_TargetIsNearFire()
				}).AddTickTransition(treeNode16, AllyGotHurtNearby).AddTickTransition(treeNode11, BarkTrans)
					.AddChildren(treeNode8.AddTickTransition(treeNode9, new Trans_TargetInRange
					{
						Range = 12f
					}).AddEndTransition(treeNode9), treeNode9.AddTickBranchingTrans(treeNode11, new Trans_TargetInRange
					{
						Range = 12f
					}, treeNode10, new Trans_HasBlackboardBool
					{
						Key = "WolfNearbyAlreadyBarked",
						Inverted = true
					}).AddTickTransition(treeNode33, new Trans_And
					{
						new Trans_SeesFood(),
						new Trans_HasBlackboardBool
						{
							Key = "TriedToApproachUnreachableFood",
							Inverted = true
						}
					})), treeNode10.AddTickTransition(treeNode11, new Trans_TargetInRange
				{
					Range = 2f
				}).AddEndTransition(treeNode11), treeNode11.AddTickTransition(treeNode16, AllyGotHurtNearby).AddTickTransition(treeNode12, new Trans_TargetInRange
				{
					Range = 2f
				}).AddTickTransition(treeNode9, new Trans_ElapsedTime
				{
					Duration = 5.0
				})
					.AddFailureTransition(treeNode18), treeNode12.AddEndTransition(treeNode13, new Trans_TargetInFront
				{
					Angle = 120f,
					Inverted = true
				}).AddEndTransition(treeNode14), treeNode13.AddEndTransition(treeNode14), treeNode14.AddTickTransition(treeNode11, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 0.75,
					MaxDuration = 1.5
				}).AddEndTransition(treeNode11), treeNode15.AddTickTransition(treeNode15, AllyGotHurtNearby).AddTickTransition(treeNode11, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 2.0,
					MaxDuration = 4.0
				}).AddEndTransition(treeNode11), treeNode16.AddTickTransition(treeNode15, new Trans_TargetInRange
				{
					Range = data.reacCircle.radius + 5f
				}).AddTickTransition(treeNode11, BarkTrans), treeNode17.AddEndTransition(treeNode8)), treeNode22.AddTickTransition(treeNode32, PathFailedTrans).AddTickTransition(treeNode32, AllyGotHurtNearby).AddChildren(treeNode46.AddTickTransition(treeNode31, new Trans_TargetInRange
				{
					Range = 12f
				}).AddTickTransition(treeNode23, new Trans_HasBlackboardBool
				{
					Key = "AlreadyGrowled",
					Inverted = true
				}).AddTickTransition(treeNode24, new Trans_AlwaysValid()), treeNode42.AddTickBranchingTrans(treeNode31, FireMeleeTrans, treeNode23, new Trans_RandomChance
				{
					chance = 0.75f
				}).AddChildren(treeNode24.AddTickTransition(treeNode25, new Trans_TargetInRange
				{
					Range = 5f
				}).AddTickTransition(treeNode16, new Trans_TargetIsNearFire
				{
					Inverted = true
				}).AddTickTransition(treeNode16, new Trans_TargetInRange
				{
					Range = 21f,
					Inverted = true
				}), treeNode30.AddTickTransition(treeNode25, new Trans_TargetInRange
				{
					Range = 5f
				}).AddTickTransition(treeNode24, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 1.0,
					MaxDuration = 3.0
				})), treeNode23.AddTickTransition(treeNode31, FireMeleeTrans).AddTickTransition(treeNode25, new Trans_TargetInRange
				{
					Range = 5f
				}).AddEndTransition(treeNode24), treeNode25.AddTickTransition(treeNode26, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 0.5,
					MaxDuration = 1.25
				}).AddEndTransition(treeNode26), treeNode26.AddTickTransition(treeNode27, new Trans_TargetInRange
				{
					Range = 2f
				}), treeNode27.AddEndTransition(treeNode29), treeNode31.AddEndTransition(treeNode28), treeNode28.AddEndTransition(treeNode30), treeNode29.AddEndTransition(treeNode30))), treeNode18.AddChildren(treeNode19.AddFailureTransition(treeNode32).AddTickTransition(treeNode32, FireMeleeTrans).AddTickTransition(treeNode11, new Trans_CanReachTarget_Slow())
					.AddEndTransition(treeNode11, new Trans_CanReachTarget_Slow())
					.AddEndTransition(treeNode20)
					.AddEndTransition(treeNode32), treeNode21.AddEndTransition(treeNode19)), treeNode32.AddTickTransition(treeNode40, PathFailedTrans).AddEndTransition(treeNode16, new Trans_TargetInRange
				{
					Range = data.flee.desiredDistance
				}).AddEndTransition(treeNode38)), treeNode33.AddTickTransition(treeNode22, new Trans_TargetIsNearFire
			{
				onlySeeFireWhenClose = true
			}).AddTickTransition(treeNode9, HowlTrans).AddTickTransition(treeNode16, AllyGotHurtNearby)
				.AddTickTransition(treeNode11, BarkTrans)
				.AddTickTransition(treeNode, new Trans_SeesFood
				{
					Inverted = true
				})
				.AddChildren(treeNode34.AddTickTransition(treeNode36, new Trans_TargetInRange
				{
					Range = 12f
				}).AddFailureTransition(treeNode).AddEndTransition(treeNode35), treeNode35.AddTickTransition(treeNode36, new Trans_TargetInRange
				{
					Range = 12f
				}).AddFailureTransition(treeNode).AddEndTransition(treeNode), treeNode36.AddTickTransition(treeNode10, new Trans_TargetInRange
				{
					Range = 5f
				}).AddEndTransition(treeNode10, new Trans_TargetInRange
				{
					Range = 12f
				}).AddEndTransition(treeNode34))), treeNode39.AddEndTransition(treeNode32, new Trans_IsHealthBelowPercentage()).AddEndTransition(treeNode32, new Trans_HasBlackboardBool
			{
				Key = "HitByFire"
			}).AddEndTransition(treeNode32, new Trans_TargetIsNearFire())
				.AddEndTransition(treeNode32, new Trans_TargetInRange
				{
					Range = 50f,
					Inverted = true
				})
				.AddEndTransition(treeNode17, new Trans_InitialAlliesNotFighting())
				.AddEndTransition(treeNode11, new Trans_And
				{
					new Trans_RandomChance
					{
						chance = 0.5f
					},
					new Trans_TargetInRange
					{
						Range = 12f
					}
				})
				.AddEndTransition(treeNode15, new Trans_TargetInRange
				{
					Range = data.reacCircle.radius + 5f
				})
				.AddEndTransition(treeNode16)), treeNode20.AddFailureTransition(treeNode32).AddEndTransition(treeNode32, new Trans_TargetIsNearFire()).AddEndTransition(treeNode21)), treeNode40);
			BuildFromTree(treeNode);
			SetState(treeNode.GetFirstChildLeaf().state);
			Run();
		}
	}

	public void Hurt(HitInfo hitInfo)
	{
		if (((Component)this).GetComponent<SenseComponent>().CanTarget(hitInfo.Initiator) && (hitInfo.Initiator.IsNonNpcPlayer() || !(Random.value > 0.5f)))
		{
			HurtTrans.Trigger(hitInfo);
		}
	}

	public void Intimidate(BaseEntity target)
	{
		AllyGotHurtNearby.Trigger(target);
	}

	public void Howl(BaseEntity target)
	{
		HowlTrans.Trigger(target);
	}

	public void Bark(BaseEntity target)
	{
		BarkTrans.Trigger(target);
	}

	public void Die(HitInfo hitInfo)
	{
		DeathTrans.Trigger(hitInfo);
	}
}


using System;

[Serializable]
public class WolfFSMData
{
	public State_PlayRandomAnimation randomIdle = new State_PlayRandomAnimation();

	public State_Roam roam = new State_Roam();

	public State_Howl howl = new State_Howl();

	public State_CircleDynamic approach = new State_CircleDynamic();

	public State_Bark bark = new State_Bark();

	public State_Growl growlFire = new State_Growl();

	public State_ApproachFire approachFire = new State_ApproachFire();

	public State_FleeFire fleeFire = new State_FleeFire();

	public State_MoveToTarget charge = new State_MoveToTarget();

	public State_Attack attack = new State_Attack();

	public State_PlayAnimationRM leapAway = new State_PlayAnimationRM();

	public State_Circle reacCircle = new State_Circle();

	public State_CircleDynamic fastApproach = new State_CircleDynamic();

	public State_Hurt hurt = new State_Hurt();

	public State_Intimidated intimidated = new State_Intimidated();

	public State_Flee flee = new State_Flee();

	public State_Flee fleeShort = new State_Flee();

	public State_Dead dead = new State_Dead();

	public State_ApproachFood approachFood = new State_ApproachFood();

	public State_EatFood eatFood = new State_EatFood();

	public State_PlayAnimationRM growlFood = new State_PlayAnimationRM();

	public State_PlayAnimLoop sleep = new State_PlayAnimLoop();

	public State_AttackUnreachable attackUnreachable = new State_AttackUnreachable();
}


using Facepunch;
using Rust.Ai.Gen2;

public class Trans_Triggerable_HitInfo : Trans_Triggerable
{
	private HitInfo HitInfo;

	public virtual void Trigger(HitInfo hitInfo)
	{
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
		HitInfo = Pool.Get<HitInfo>();
		HitInfo.CopyFrom(hitInfo);
		Trigger();
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		if (base.Triggered && to is IParametrized<HitInfo> parametrized)
		{
			parametrized.SetParameter(HitInfo);
		}
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
[SoftRequireComponent(typeof(LimitedTurnNavAgent), typeof(SenseComponent), typeof(BlackboardComponent))]
public class State_ApproachFood : State_MoveToTarget
{
	public const string TriedToApproachUnreachableFood = "TriedToApproachUnreachableFood";

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Agent.CanReach(((Component)food).transform.position))
		{
			base.Blackboard.Add("TriedToApproachUnreachableFood");
			SingletonComponent<NpcFoodManager>.Instance.Remove(food);
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			destination = Vector3.zero;
			return false;
		}
		destination = ((Component)food).transform.position;
		return true;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
[SoftRequireComponent(typeof(RootMotionPlayer))]
public class State_EatFood : FSMStateBase
{
	[SerializeField]
	protected AnimationClip Animation;

	private const float damageToCorpsesPerLoop = 2.5f;

	private const float timeToForgetSightingWhileEating = 5f;

	private bool isAnimationPlaying;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 val = ((Component)food).transform.position - ((Component)Owner).transform.position;
		val.y = 0f;
		((Component)Owner).transform.rotation = Quaternion.LookRotation(val);
		base.Senses.timeToForgetSightings.Value = 5f;
		PlayAnimation();
		return base.OnStateEnter();
	}

	private void PlayAnimation()
	{
		isAnimationPlaying = true;
		base.AnimPlayer.PlayServer(Animation, OnAnimationEnd);
	}

	private void OnAnimationEnd()
	{
		isAnimationPlaying = false;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (isAnimationPlaying)
		{
			return base.OnStateUpdate(deltaTime);
		}
		if (food is BaseCorpse baseCorpse)
		{
			baseCorpse.Hurt(2.5f);
			if (baseCorpse.IsDead())
			{
				base.Senses.ClearTarget();
				return EFSMStateStatus.Success;
			}
			PlayAnimation();
		}
		else if (food is DroppedItem droppedItem)
		{
			droppedItem.item.amount = Mathf.FloorToInt((float)droppedItem.item.amount * 0.5f);
			if (droppedItem.item.amount <= 0)
			{
				droppedItem.DestroyItem();
				droppedItem.Kill();
				base.Senses.ClearTarget();
				return EFSMStateStatus.Success;
			}
			droppedItem.item.MarkDirty();
			PlayAnimation();
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Senses.timeToForgetSightings.Reset();
		base.AnimPlayer.StopServer();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Flee : FSMStateBase
{
	[SerializeField]
	public LimitedTurnNavAgent.Speeds speed = LimitedTurnNavAgent.Speeds.Sprint;

	[SerializeField]
	public float distance = 20f;

	[SerializeField]
	public float desiredDistance = 50f;

	[SerializeField]
	public int maxAttempts = 3;

	private int attempts;

	private float startDistance;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		base.Blackboard.Remove("HitByFire");
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		attempts = 0;
		base.Agent.SetSpeed(speed);
		base.Agent.shouldStopAtDestination = false;
		startDistance = Vector3.Distance(((Component)Owner).transform.position, targetPosition);
		MoveAwayFromTarget();
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (base.Agent.IsFollowingPath)
		{
			return base.OnStateUpdate(deltaTime);
		}
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		if (Vector3.Distance(targetPosition, ((Component)Owner).transform.position) > desiredDistance + startDistance)
		{
			return EFSMStateStatus.Success;
		}
		attempts++;
		if (attempts >= maxAttempts)
		{
			return EFSMStateStatus.Success;
		}
		return MoveAwayFromTarget();
	}

	private EFSMStateStatus MoveAwayFromTarget()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		Vector3 normalizedDirection = Vector3Ex.NormalizeXZ(((Component)Owner).transform.position - targetPosition);
		if (!base.Agent.SetDestinationFromDirection(normalizedDirection, distance))
		{
			return EFSMStateStatus.Failure;
		}
		return EFSMStateStatus.None;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_FleeFire : State_Flee
{
	private int numExecutions;

	private int maxExecutionsBeforeMinDist = 2;

	private float minDistance = 8f;

	private float maxDistance = 20f;

	private double timeOfLastExecution;

	public override EFSMStateStatus OnStateEnter()
	{
		if (Time.timeAsDouble - timeOfLastExecution > 30.0)
		{
			numExecutions = 0;
		}
		timeOfLastExecution = Time.timeAsDouble;
		distance = 7f;
		desiredDistance = Mathx.RemapValClamped((float)numExecutions, 0f, (float)maxExecutionsBeforeMinDist, maxDistance, minDistance);
		numExecutions++;
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (base.Senses.FindTargetPosition(out var targetPosition) && Time.timeAsDouble - timeOfLastExecution > 1.0 && Vector3.Distance(((Component)Owner).transform.position, targetPosition) > desiredDistance)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Roam : FSMStateBase
{
	[SerializeField]
	private Vector2 distanceRange = new Vector2(10f, 20f);

	[SerializeField]
	private float homeRadius = 50f;

	private Vector3? homePosition;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		Reset();
		if (!homePosition.HasValue)
		{
			homePosition = ((Component)Owner).transform.position;
		}
		float num = Random.Range(distanceRange.x, distanceRange.y);
		Vector3 val;
		if (!(Vector3.Distance(homePosition.Value, ((Component)Owner).transform.position) > homeRadius))
		{
			val = Random.insideUnitSphere;
		}
		else
		{
			Vector3 val2 = homePosition.Value - ((Component)Owner).transform.position;
			val = ((Vector3)(ref val2)).normalized;
		}
		Vector3 val3 = val;
		float ratio = Mathf.InverseLerp(0f, distanceRange.y, num);
		base.Agent.SetSpeed(ratio);
		if (!base.Agent.SetDestinationFromDirection(Vector3Ex.XZ3D(val3), num, restrictTerrain: true))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Agent.IsFollowingPath)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	private void Reset()
	{
		base.Senses.ClearTarget();
		base.Blackboard.Clear();
		if (Owner is BaseCombatEntity { healthFraction: <1f, SecondsSinceAttacked: >120f } baseCombatEntity)
		{
			baseCombatEntity.SetHealth(Owner.MaxHealth());
		}
	}
}


using System;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Dead : FSMStateBase
{
	[SerializeField]
	private string deathStatName;

	[SerializeField]
	private GameObjectRef CorpsePrefab;

	private HitInfo HitInfo;

	public void SetParameter(HitInfo parameter)
	{
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
		if (parameter == null)
		{
			Debug.LogWarning((object)"No parameter set for hurt state");
		}
		HitInfo = Pool.Get<HitInfo>();
		HitInfo.CopyFrom(parameter);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		if (HitInfo != null && (Object)(object)HitInfo.InitiatorPlayer != (Object)null)
		{
			BasePlayer initiatorPlayer = HitInfo.InitiatorPlayer;
			initiatorPlayer.GiveAchievement("KILL_ANIMAL");
			if (!string.IsNullOrEmpty(deathStatName))
			{
				initiatorPlayer.stats.Add(deathStatName, 1, (Stats)5);
				initiatorPlayer.stats.Save();
			}
			if (Owner is BaseCombatEntity killed)
			{
				initiatorPlayer.LifeStoryKill(killed);
			}
		}
		BaseCorpse baseCorpse = Owner.DropCorpse(CorpsePrefab.resourcePath);
		if (Object.op_Implicit((Object)(object)baseCorpse))
		{
			baseCorpse.Spawn();
			baseCorpse.TakeChildren(Owner);
		}
		((FacepunchBehaviour)Owner).Invoke((Action)Owner.KillMessage, 0.5f);
		return base.OnStateEnter();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Howl : State_PlayAnimation
{
	public const string WolfNearbyAlreadyHowled = "WolfNearbyAlreadyHowled";

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var targetEntity))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Agent.CanReach(((Component)targetEntity).transform.position, triggerPathFailed: true))
		{
			return EFSMStateStatus.Failure;
		}
		base.Blackboard.Add("WolfNearbyAlreadyHowled");
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetInitialAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<BlackboardComponent>().Add("WolfNearbyAlreadyHowled");
				Wolf2FSM otherWolf = ((Component)item).GetComponent<Wolf2FSM>();
				((FacepunchBehaviour)Owner).Invoke((Action)delegate
				{
					otherWolf.Howl(targetEntity);
				}, 1f);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_Growl : State_PlayAnimationRM
{
	public const string AlreadyGrowled = "AlreadyGrowled";

	public override EFSMStateStatus OnStateEnter()
	{
		base.Blackboard.Add("AlreadyGrowled");
		return base.OnStateEnter();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Bark : State_PlayAnimation
{
	public const string WolfNearbyAlreadyBarked = "WolfNearbyAlreadyBarked";

	public override EFSMStateStatus OnStateEnter()
	{
		if (!base.Senses.FindTarget(out var targetEntity))
		{
			return EFSMStateStatus.Failure;
		}
		base.Blackboard.Add("WolfNearbyAlreadyBarked");
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetInitialAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<BlackboardComponent>().Add("WolfNearbyAlreadyBarked");
				Wolf2FSM otherWolf = ((Component)item).GetComponent<Wolf2FSM>();
				((FacepunchBehaviour)Owner).Invoke((Action)delegate
				{
					otherWolf.Bark(targetEntity);
				}, Mathf.Max(0f, Animation.length + Random.Range(-0.5f, 0.5f)));
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Intimidated : State_PlayAnimationRM
{
	private static readonly float facingAwayDotThreshold = Mathf.Cos(MathF.PI / 2f);

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		FaceTarget = true;
		if (base.Senses.FindTargetPosition(out var targetPosition))
		{
			Vector3 forward = ((Component)Owner).transform.forward;
			Vector3 val = ((Component)Owner).transform.position - targetPosition;
			if (Vector3.Dot(forward, ((Vector3)(ref val)).normalized) > facingAwayDotThreshold)
			{
				return EFSMStateStatus.Success;
			}
		}
		return base.OnStateEnter();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Hurt : State_PlayAnimationRM, IParametrized<HitInfo>
{
	[SerializeField]
	private RootMotionData StrongHitL;

	[SerializeField]
	private RootMotionData StrongHitR;

	[SerializeField]
	private RootMotionData WeakHit;

	[SerializeField]
	private float StaggerRatio = 0.5f;

	private HitInfo HitInfo;

	public void SetParameter(HitInfo parameter)
	{
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
		if (parameter == null)
		{
			Debug.LogWarning((object)"No parameter set for hurt state");
		}
		HitInfo = Pool.Get<HitInfo>();
		HitInfo.CopyFrom(parameter);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		if (HitInfo == null)
		{
			Debug.LogWarning((object)"No hitinfo set for hurt state");
			return base.OnStateEnter();
		}
		if (Object.op_Implicit((Object)(object)HitInfo.InitiatorPlayer) && !HitInfo.damageTypes.IsMeleeType())
		{
			HitInfo.InitiatorPlayer.LifeStoryShotHit(HitInfo.Weapon);
		}
		if (HitInfo.damageTypes.Has(DamageType.Heat))
		{
			base.Blackboard.Add("HitByFire");
		}
		float num = Owner.Health() + HitInfo.damageTypes.Total();
		float num2 = Owner.MaxHealth() * StaggerRatio;
		if (num > num2 && Owner.Health() < num2)
		{
			bool flag = Vector3.Dot(HitInfo.attackNormal, ((Component)Owner).transform.right) > 0f;
			Animation = (flag ? StrongHitL : StrongHitR);
		}
		else
		{
			Animation = WeakHit;
		}
		if (HitInfo.Initiator is BaseCombatEntity baseCombatEntity)
		{
			bool flag2 = true;
			if (base.Senses.FindTarget(out var target))
			{
				bool num3 = Owner.Distance((BaseEntity)baseCombatEntity) < 16f;
				bool flag3 = !target.IsNonNpcPlayer() && baseCombatEntity.IsNonNpcPlayer();
				flag2 = num3 || flag3;
			}
			if (flag2)
			{
				base.Senses.TrySetTarget(baseCombatEntity);
			}
		}
		if (!base.Senses.FindTarget(out var target2))
		{
			Debug.LogWarning((object)"Got attacked but couldn't find a target");
			return base.OnStateEnter();
		}
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetInitialAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<Wolf2FSM>().Intimidate(target2);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		Pool.Free<HitInfo>(ref HitInfo);
		base.OnStateExit();
	}
}


using System;
using Facepunch;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Assertions;

[Serializable]
public class State_Attack : State_PlayAnimationRM
{
	[SerializeField]
	public float Damage = 20f;

	[SerializeField]
	public float Delay = 0.5f;

	[SerializeField]
	public DamageType DamageType = DamageType.Bite;

	private Action _doDamageAction;

	private Action DoDamageAction => DoDamage;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(Delay < Animation.inPlaceAnimation.length);
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		FaceTarget = false;
		Vector3 val = Vector3Ex.NormalizeXZ(((Component)Owner).transform.position - targetPosition);
		Vector3 val2 = Vector3.Cross(Vector3.up, val);
		targetPosition += ((Random.value > 0.5f) ? 1f : (-1f)) * val2;
		Vector3 val3 = Vector3Ex.NormalizeXZ(targetPosition - ((Component)Owner).transform.position);
		((Component)Owner).transform.rotation = Quaternion.LookRotation(val3);
		((FacepunchBehaviour)Owner).Invoke(DoDamageAction, Delay);
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		((FacepunchBehaviour)Owner).CancelInvoke(DoDamageAction);
		base.OnStateExit();
	}

	private void DoDamage()
	{
		if (base.Senses.FindTarget(out var target) && target is BaseCombatEntity baseCombatEntity && TryApplyShieldDamage(Owner, baseCombatEntity, DamageType, Damage))
		{
			baseCombatEntity.Hurt(Damage, DamageType, Owner);
		}
	}

	public static bool TryApplyShieldDamage(BaseEntity attacker, BaseCombatEntity combatTarget, DamageType damageType, float damageAmount)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		bool result = true;
		if (combatTarget is BasePlayer basePlayer && basePlayer.GetActiveShield(out var foundShield) && foundShield.IsBlocking())
		{
			Vector3 position = ((Component)attacker).transform.position;
			Vector3 val = position - Vector3Ex.WithY(((Component)combatTarget).transform.position, position.y);
			Vector3 val2 = Vector3Ex.WithY(basePlayer.eyes.BodyForward(), 0f);
			if (Vector3.Angle(val, val2) < 90f)
			{
				HitInfo hitInfo = Pool.Get<HitInfo>();
				hitInfo.Initiator = attacker;
				hitInfo.damageTypes.Set(damageType, damageAmount);
				hitInfo.HitEntity = foundShield;
				foundShield.OnAttacked(hitInfo);
				Pool.Free<HitInfo>(ref hitInfo);
				result = false;
			}
		}
		return result;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_Circle : FSMStateBase, IParametrized<BaseEntity>
{
	[SerializeField]
	public float radius = 16f;

	[SerializeField]
	public LimitedTurnNavAgent.Speeds speed = LimitedTurnNavAgent.Speeds.Sprint;

	private bool clockWise = true;

	private float radiusOffset;

	public void SetParameter(BaseEntity target)
	{
		base.Senses.TrySetTarget(target);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		base.Agent.SetSpeed(speed);
		radiusOffset = Random.Range(-1f, 1f);
		clockWise = Random.value > 0.5f;
		base.Agent.shouldStopAtDestination = false;
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	protected virtual bool GetCircleOrigin(out Vector3 origin)
	{
		return base.Senses.FindTargetPosition(out origin);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		if (!GetCircleOrigin(out var origin))
		{
			return EFSMStateStatus.Failure;
		}
		float num = radius + radiusOffset;
		Quaternion val = Quaternion.LookRotation(((Component)Owner).transform.position - origin);
		float num2 = (((Quaternion)(ref val)).eulerAngles.y + 5f * (float)(clockWise ? 1 : (-1))) * (MathF.PI / 180f);
		Vector3 val2 = origin + new Vector3(Mathf.Sin(num2), 0f, Mathf.Cos(num2)) * num;
		val2.y = Mathf.Lerp(origin.y, ((Component)Owner).transform.position.y, Mathf.InverseLerp(0f, Vector3.Distance(origin, ((Component)Owner).transform.position), num));
		NavMeshHit val3 = default(NavMeshHit);
		if (NavMesh.Raycast(((Component)Owner).transform.position, val2, ref val3, -1))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Agent.SetDestination(val2))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_ApproachFire : State_CircleDynamic
{
	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		base.Agent.deceleration.Value = 6f;
		distanceSpeedRange.x = 16f;
		return result;
	}

	public override void OnStateExit()
	{
		base.Agent.deceleration.Reset();
		base.OnStateExit();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_CircleDynamic : FSMStateBase, IParametrized<BaseEntity>
{
	[SerializeField]
	private LimitedTurnNavAgent.Speeds minSpeed;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds maxSpeed = LimitedTurnNavAgent.Speeds.Sprint;

	[SerializeField]
	protected Vector2 distanceSpeedRange = new Vector2(10f, 50f);

	[SerializeField]
	private Vector2 angleRange = Vector2.op_Implicit(new Vector3(20f, 80f));

	[SerializeField]
	private Vector2 angleDurationRange = new Vector2(1f, 3f);

	[SerializeField]
	private Vector2 burstDurationRange = new Vector2(1f, 3f);

	[SerializeField]
	private Vector2 burstCooldownRange = new Vector2(1f, 10f);

	private Action _updateBurstAction;

	private Action _endBurstAction;

	private Action _updateAngleAction;

	private bool clockWise = true;

	private int burstSpeedIndexOffset;

	private float randomAngle;

	private Action UpdateBurstAction => UpdateBurst;

	private Action EndBurstAction => EndBurst;

	private Action UpdateAngleAction => UpdateAngle;

	public void SetParameter(BaseEntity target)
	{
		base.Senses.TrySetTarget(target);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		clockWise = Random.value > 0.5f;
		EndBurst();
		UpdateAngle();
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		((FacepunchBehaviour)Owner).CancelInvoke(UpdateBurstAction);
		((FacepunchBehaviour)Owner).CancelInvoke(EndBurstAction);
		((FacepunchBehaviour)Owner).CancelInvoke(UpdateAngleAction);
		base.OnStateExit();
	}

	private void UpdateAngle()
	{
		randomAngle = Random.Range(angleRange.x, angleRange.y) * (float)(clockWise ? 1 : (-1));
		((FacepunchBehaviour)Owner).Invoke(UpdateAngleAction, Random.Range(angleDurationRange.x, angleDurationRange.y));
	}

	private void UpdateBurst()
	{
		burstSpeedIndexOffset = 2;
		clockWise = Random.value > 0.5f;
		float num = Random.Range(burstDurationRange.x, burstDurationRange.y);
		((FacepunchBehaviour)Owner).Invoke(EndBurstAction, num);
	}

	private void EndBurst()
	{
		burstSpeedIndexOffset = 0;
		float num = Random.Range(burstCooldownRange.x, burstCooldownRange.y);
		((FacepunchBehaviour)Owner).Invoke(UpdateBurstAction, num);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		float num = Vector3.Distance(((Component)Owner).transform.position, targetPosition);
		float ratio = Mathf.InverseLerp(distanceSpeedRange.x, distanceSpeedRange.y, num);
		base.Agent.SetSpeed(ratio, minSpeed, maxSpeed, burstSpeedIndexOffset);
		float currentDeviation = Mathx.RemapValClamped(num, distanceSpeedRange.x, distanceSpeedRange.y, randomAngle, 0f);
		base.Agent.currentDeviation = currentDeviation;
		Vector3 newDestination = targetPosition;
		if (!base.Agent.SetDestination(newDestination))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public class State_MoveToLastReachablePointNearTarget : State_MoveToTarget
{
	private const float maxHorizontalDist = 7f;

	private const float maxVerticalDist = 2.7f;

	private const float traceVerticalOffset = 1f;

	private Vector3 reachableDestination;

	private LockState.LockHandle targetLock;

	public static bool CanJumpFromPosToPos(BaseEntity owner, Vector3 ownerLocation, Vector3 targetPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if (Mathf.Abs(targetPos.y - ownerLocation.y) > 2.7f)
		{
			return false;
		}
		if (Vector3.Distance(ownerLocation, targetPos) > 7f)
		{
			return false;
		}
		if (!owner.CanSee(ownerLocation + 1f * Vector3.up, targetPos + 1f * Vector3.up))
		{
			return false;
		}
		return true;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		if (!FindReachableLocation(out reachableDestination))
		{
			return EFSMStateStatus.Failure;
		}
		targetLock = base.Senses.LockCurrentTarget();
		base.Agent.deceleration.Value = 6f;
		return base.OnStateEnter();
	}

	private bool FindReachableLocation(out Vector3 location)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		location = default(Vector3);
		if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer basePlayer))
		{
			return false;
		}
		if (basePlayer.isMounted)
		{
			return false;
		}
		Vector3 position = ((Component)target).transform.position;
		if (Vector3.Distance(((Component)Owner).transform.position, position) > 50f)
		{
			return false;
		}
		Vector3? val = null;
		if (base.Agent.lastValidDestination.HasValue && Vector3.Distance(base.Agent.lastValidDestination.Value, position) <= 7f && base.Agent.SamplePosition(base.Agent.lastValidDestination.Value, out var sample, 7f) && CanJumpFromPosToPos(Owner, sample, position))
		{
			val = sample;
		}
		if (!val.HasValue && base.Agent.SamplePosition(position, out var sample2, 7f) && CanJumpFromPosToPos(Owner, sample2, position))
		{
			val = sample2;
		}
		if (!val.HasValue)
		{
			return false;
		}
		location = val.Value;
		return true;
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		destination = reachableDestination;
		return true;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		float ratio = Mathx.RemapValClamped(Vector3.Distance(((Component)Owner).transform.position, reachableDestination), 4f, 16f, 0f, 1f);
		if (Trans_TargetIsNearFire.Test(Owner, base.Senses))
		{
			base.Agent.SetSpeed(ratio, LimitedTurnNavAgent.Speeds.Sneak, LimitedTurnNavAgent.Speeds.Jog);
		}
		else
		{
			base.Agent.SetSpeed(ratio, LimitedTurnNavAgent.Speeds.Run);
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.OnStateExit();
		base.Senses.UnlockTarget(ref targetLock);
		base.Agent.deceleration.Reset();
	}
}


using System;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_AttackUnreachable : FSMStateBase
{
	private enum Phase
	{
		PreJump,
		Jump,
		Attack,
		JumpBack,
		PostJumpBack
	}

	private const float preJumpEnd = 0.29f;

	private const float jumpEnd = 0.395f;

	private const float attackEnd = 0.67f;

	private const float jumpBackEnd = 0.765f;

	private const float postJumpBackEnd = 0.95f;

	private const float groundCheckDistance = 2f;

	private const float damage = 35f;

	private const float meleeAttackRange = 1.7f;

	private const DamageType damageType = DamageType.Bite;

	public RootMotionData animClip;

	private Vector3 startLocation;

	private Quaternion startRotation;

	private Vector3 destination;

	private float elapsedTime;

	private LockState.LockHandle targetLock;

	private LockState.LockHandle movementLock;

	private Phase phase;

	private float previousOffsetZ;

	public static bool SampleGroundPositionUnderTarget(LimitedTurnNavAgent agent, BasePlayer targetAsPlayer, out Vector3 projectedLocation)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		float radius = targetAsPlayer.GetRadius();
		return agent.SampleGroundPositionWithPhysics(((Component)targetAsPlayer).transform.position, out projectedLocation, 2f, radius);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer basePlayer))
		{
			return EFSMStateStatus.Failure;
		}
		destination = ((Component)target).transform.position;
		if (!basePlayer.IsOnGround() && !SampleGroundPositionUnderTarget(base.Agent, basePlayer, out destination))
		{
			return EFSMStateStatus.Failure;
		}
		if (!State_MoveToLastReachablePointNearTarget.CanJumpFromPosToPos(Owner, ((Component)Owner).transform.position, destination))
		{
			return EFSMStateStatus.Failure;
		}
		movementLock = base.Agent.Pause();
		elapsedTime = 0f;
		targetLock = base.Senses.LockCurrentTarget();
		base.AnimPlayer.PlayServer(animClip.inPlaceAnimation);
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = false;
		SetPhase(Phase.PreJump);
		return base.OnStateEnter();
	}

	private void SetPhase(Phase newPhase)
	{
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		phase = newPhase;
		previousOffsetZ = animClip.zMotionCurve.Evaluate(elapsedTime);
		if (phase == Phase.Jump)
		{
			if (base.Senses.FindTarget(out var target) && target is BasePlayer targetAsPlayer)
			{
				SampleGroundPositionUnderTarget(base.Agent, targetAsPlayer, out destination);
			}
			startLocation = ((Component)Owner).transform.position;
			((Component)Owner).transform.rotation = Quaternion.LookRotation(Vector3Ex.WithY(destination - ((Component)Owner).transform.position, 0f));
			Owner.ClientRPC(RpcTarget.NetworkGroup("CL_SetFloorSnappingEnabled"), arg1: false);
		}
		else if (phase == Phase.Attack)
		{
			startRotation = ((Component)Owner).transform.rotation;
			if (base.Senses.FindTarget(out var target2))
			{
				if (target2 is BaseCombatEntity baseCombatEntity && Vector3.Distance(((Component)Owner).transform.position, ((Component)baseCombatEntity).transform.position) <= 1.7f)
				{
					baseCombatEntity.Hurt(35f, DamageType.Bite, Owner);
				}
				if (target2 is BasePlayer basePlayer && Vector3.Distance(((Component)Owner).transform.position, ((Component)basePlayer).transform.position) <= 1f)
				{
					basePlayer.ClientRPC<Vector3>(RpcTarget.Player("RPC_DoPush", basePlayer), ((Component)Owner).transform.forward * 10f + Vector3.up * 3f);
				}
			}
		}
		else if (phase == Phase.PostJumpBack)
		{
			Owner.ClientRPC(RpcTarget.NetworkGroup("CL_SetFloorSnappingEnabled"), arg1: true);
		}
	}

	private Vector3 ThreePointLerp(Vector3 a, Vector3 b, Vector3 c, float t)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Lerp(Vector3.Lerp(a, b, t), Vector3.Lerp(b, c, t), t);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		elapsedTime += deltaTime;
		float num = elapsedTime / Mathf.Max(animClip.inPlaceAnimation.length, 0.001f);
		if (phase == Phase.PreJump)
		{
			Quaternion val = Quaternion.LookRotation(Vector3Ex.WithY(destination - ((Component)Owner).transform.position, 0f));
			((Component)Owner).transform.rotation = Quaternion.Slerp(((Component)Owner).transform.rotation, val, 2f * deltaTime);
			float num2 = animClip.zMotionCurve.Evaluate(elapsedTime);
			Vector3 val2 = ((Component)Owner).transform.forward * (num2 - previousOffsetZ);
			previousOffsetZ = num2;
			Transform transform = ((Component)Owner).transform;
			transform.position += val2;
			if (num >= 0.29f)
			{
				SetPhase(Phase.Jump);
			}
		}
		if (phase == Phase.Jump)
		{
			Vector3 b = (startLocation + destination) * 0.5f;
			b.y = Mathf.Max(startLocation.y, destination.y);
			float t = Mathx.RemapValClamped(num, 0.29f, 0.395f, 0f, 1f);
			Vector3 position = ThreePointLerp(startLocation, b, destination, t);
			((Component)Owner).transform.position = position;
			if (num >= 0.395f)
			{
				SetPhase(Phase.Attack);
			}
		}
		if (phase == Phase.Attack)
		{
			((Component)Owner).transform.rotation = startRotation * Quaternion.AngleAxis(animClip.yRotationCurve.Evaluate(elapsedTime), Vector3.up);
			if (num > 0.67f)
			{
				SetPhase(Phase.JumpBack);
			}
		}
		if (phase == Phase.JumpBack)
		{
			Vector3 b2 = (startLocation + destination) * 0.5f;
			b2.y = Mathf.Max(startLocation.y, destination.y);
			float t2 = Mathx.RemapValClamped(num, 0.67f, 0.765f, 0f, 1f);
			Vector3 position2 = ThreePointLerp(destination, b2, startLocation, t2);
			((Component)Owner).transform.position = position2;
			((Component)Owner).transform.rotation = Quaternion.LookRotation(Vector3Ex.WithY(startLocation - destination, 0f));
			if (num >= 0.765f)
			{
				SetPhase(Phase.PostJumpBack);
			}
		}
		if (phase == Phase.PostJumpBack)
		{
			float num3 = animClip.zMotionCurve.Evaluate(elapsedTime);
			Vector3 val3 = ((Component)Owner).transform.forward * (num3 - previousOffsetZ);
			previousOffsetZ = num3;
			Transform transform2 = ((Component)Owner).transform;
			transform2.position -= val3;
		}
		if (num >= 0.95f)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = true;
		base.Senses.UnlockTarget(ref targetLock);
		base.Agent.Unpause(ref movementLock);
		if (phase != Phase.PostJumpBack)
		{
			Owner.ClientRPC(RpcTarget.NetworkGroup("CL_SetFloorSnappingEnabled"), arg1: true);
		}
		base.OnStateExit();
	}
}


private enum Phase
{
	PreJump,
	Jump,
	Attack,
	JumpBack,
	PostJumpBack
}


public class AIArena2 : FacepunchBehaviour, IClientComponent
{
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class BlackboardComponent : EntityComponent<BaseEntity>, IServerComponent
{
	[SerializeField]
	private float factDuration = 30f;

	private HashSet<string> addedFacts = new HashSet<string>();

	private Dictionary<string, float> factExpirationTimes = new Dictionary<string, float>();

	public override void InitShared()
	{
		base.InitShared();
		((MonoBehaviour)this).InvokeRepeating("CleanExpiredFacts", Random.value, 1f);
	}

	public void Add(string value)
	{
		if (addedFacts.Add(value))
		{
			factExpirationTimes[value] = Time.time + factDuration;
		}
	}

	public void Remove(string value)
	{
		if (addedFacts.Remove(value))
		{
			factExpirationTimes.Remove(value);
		}
	}

	public void Clear()
	{
		addedFacts.Clear();
		factExpirationTimes.Clear();
	}

	public bool Has(string value)
	{
		return addedFacts.Contains(value);
	}

	public void CleanExpiredFacts()
	{
		TimeWarning val = TimeWarning.New("BlackboardComponent.CleanExpiredFacts", 0);
		try
		{
			float time = Time.time;
			PooledList<string> val2 = Pool.Get<PooledList<string>>();
			try
			{
				foreach (string addedFact in addedFacts)
				{
					if (factExpirationTimes[addedFact] < time)
					{
						((List<string>)(object)val2).Add(addedFact);
					}
				}
				foreach (string item in (List<string>)(object)val2)
				{
					Remove(item);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;

[Flags]
public enum EFSMStateStatus
{
	None = 0,
	Success = 1,
	Failure = 2
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(LimitedTurnNavAgent), typeof(RootMotionPlayer), typeof(SenseComponent))]
[SoftRequireComponent(typeof(BlackboardComponent), typeof(NPCEncounterTimer))]
public class FSMComponent : EntityComponent<BaseEntity>, IServerComponent
{
	public class TreeNode
	{
		public FSMStateBase state;

		public List<(FSMTransitionBase transition, TreeNode dstState)> tickTransitions;

		public List<(FSMTransitionBase transition, TreeNode dstState, EFSMStateStatus status)> endTransitions;

		public List<TreeNode> children;

		public TreeNode parent;

		public TreeNode(FSMStateBase state = null)
		{
			this.state = state;
		}

		public bool IsLeaf()
		{
			return children == null;
		}

		public TreeNode GetFirstChildLeaf()
		{
			if (IsLeaf())
			{
				return this;
			}
			foreach (TreeNode child in children)
			{
				if (child.IsLeaf())
				{
					return child;
				}
				TreeNode firstChildLeaf = child.GetFirstChildLeaf();
				if (firstChildLeaf != null)
				{
					return firstChildLeaf;
				}
			}
			return null;
		}

		public void GetAllNestedStates(HashSet<FSMStateBase> nestedStates)
		{
			if (IsLeaf())
			{
				return;
			}
			foreach (TreeNode child in children)
			{
				if (child.IsLeaf())
				{
					nestedStates.Add(child.state);
				}
				else
				{
					child.GetAllNestedStates(nestedStates);
				}
			}
		}

		public TreeNode AddEndTransition(TreeNode dstState, FSMTransitionBase transition = null)
		{
			if (endTransitions == null)
			{
				endTransitions = new List<(FSMTransitionBase, TreeNode, EFSMStateStatus)>();
			}
			endTransitions.Add((transition, dstState, EFSMStateStatus.Success | EFSMStateStatus.Failure));
			return this;
		}

		public TreeNode AddFailureTransition(TreeNode dstState)
		{
			if (endTransitions == null)
			{
				endTransitions = new List<(FSMTransitionBase, TreeNode, EFSMStateStatus)>();
			}
			endTransitions.Add((null, dstState, EFSMStateStatus.Failure));
			return this;
		}

		public TreeNode AddTickTransition(TreeNode dstState, FSMTransitionBase transition)
		{
			if (tickTransitions == null)
			{
				tickTransitions = new List<(FSMTransitionBase, TreeNode)>();
			}
			tickTransitions.Add((transition, dstState));
			return this;
		}

		public TreeNode AddTickBranchingTrans(TreeNode dstState1, FSMTransitionBase sharedTransition, TreeNode dstState2, FSMTransitionBase dstState2Trans)
		{
			if (tickTransitions == null)
			{
				tickTransitions = new List<(FSMTransitionBase, TreeNode)>();
			}
			tickTransitions.Add((new Trans_And { sharedTransition, dstState2Trans }, dstState2));
			tickTransitions.Add((sharedTransition, dstState1));
			return this;
		}

		public TreeNode AddChild(TreeNode child)
		{
			if (state != null)
			{
				Debug.LogError((object)"Can't add children to node with a state");
			}
			if (children == null)
			{
				children = new List<TreeNode>();
			}
			children.Add(child);
			child.parent = this;
			return child;
		}

		public TreeNode AddChildren(TreeNode child1, TreeNode child2 = null, TreeNode child3 = null, TreeNode child4 = null, TreeNode child5 = null, TreeNode child6 = null, TreeNode child7 = null, TreeNode child8 = null, TreeNode child9 = null, TreeNode child10 = null)
		{
			AddChild(child1);
			if (child2 != null)
			{
				AddChild(child2);
			}
			if (child3 != null)
			{
				AddChild(child3);
			}
			if (child4 != null)
			{
				AddChild(child4);
			}
			if (child5 != null)
			{
				AddChild(child5);
			}
			if (child6 != null)
			{
				AddChild(child6);
			}
			if (child7 != null)
			{
				AddChild(child7);
			}
			if (child8 != null)
			{
				AddChild(child8);
			}
			if (child9 != null)
			{
				AddChild(child9);
			}
			if (child10 != null)
			{
				AddChild(child10);
			}
			return this;
		}
	}

	public class TickFSMWorkQueue : PersistentObjectWorkQueue<FSMComponent>
	{
		protected override void RunJob(FSMComponent component)
		{
			if (((PersistentObjectWorkQueue<FSMComponent>)this).ShouldAdd(component) && ((Behaviour)component).enabled)
			{
				component.Senses.Tick();
				((Component)component).GetComponent<NPCEncounterTimer>().Tick();
				component.Tick();
			}
		}

		protected override bool ShouldAdd(FSMComponent component)
		{
			if (base.ShouldAdd(component))
			{
				return component.baseEntity.IsValid();
			}
			return false;
		}
	}

	private bool isRunning;

	private SenseComponent _senses;

	[ServerVar]
	public static float minRefreshIntervalSeconds = 0f;

	[ServerVar]
	public static float maxRefreshIntervalSeconds = 0.5f;

	private double? _lastTickTime;

	private double nextRefreshTime;

	private const int maxStateChangesPerTick = 3;

	private List<FSMStateBase> sameFrameStateChangesHistory = new List<FSMStateBase>();

	private FSMStateBase pendingStateChange;

	public static TickFSMWorkQueue workQueue = new TickFSMWorkQueue();

	[ServerVar(Help = "How many milliseconds to spend on the AIs FSMs per frame")]
	public static float frameBudgetMs = 0.5f;

	public FSMStateBase CurrentState { get; private set; }

	private SenseComponent Senses => _senses ?? (_senses = ((Component)base.baseEntity).GetComponent<SenseComponent>());

	private float RefreshInterval
	{
		get
		{
			if (!Senses.ShouldRefreshFast)
			{
				return maxRefreshIntervalSeconds;
			}
			return minRefreshIntervalSeconds;
		}
	}

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	public void Run()
	{
		if (isRunning)
		{
			Debug.LogWarning((object)("[FSM] Trying to start a FSM that's already running on " + ((Object)((Component)base.baseEntity).gameObject).name));
			return;
		}
		isRunning = true;
		_lastTickTime = null;
		((PersistentObjectWorkQueue<FSMComponent>)workQueue).Add(this);
	}

	public void Stop()
	{
		if (!isRunning)
		{
			Debug.LogWarning((object)("[FSM] Trying to stop a FSM that is not running on " + ((Object)((Component)base.baseEntity).gameObject).name));
			return;
		}
		isRunning = false;
		((PersistentObjectWorkQueue<FSMComponent>)workQueue).Remove(this);
	}

	private void OnDestroy()
	{
		Stop();
	}

	public static void ShowDebugInfoAroundLocation(BasePlayer player, float radius = 100f)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (!player.IsValid())
		{
			return;
		}
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			BaseEntity.Query.Server.GetBrainsInSphere(((Component)player).transform.position, radius, (List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				FSMComponent component = ((Component)item).GetComponent<FSMComponent>();
				if (!((Object)(object)component == (Object)null) && component.CurrentState != null && component.isRunning)
				{
					player.ClientRPC<Vector3, string>(RpcTarget.Player("CL_ShowStateDebugInfo", player), ((Component)component.baseEntity).transform.position, component.CurrentState.Name);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Tick()
	{
		TimeWarning val = TimeWarning.New("FSMComponent.Tick", 0);
		try
		{
			if (Time.timeAsDouble < nextRefreshTime)
			{
				return;
			}
			nextRefreshTime = Time.timeAsDouble + (double)RefreshInterval;
			float deltaTime = (float)(Time.timeAsDouble - LastTickTime);
			LastTickTime = Time.timeAsDouble;
			sameFrameStateChangesHistory.Clear();
			if (pendingStateChange != null)
			{
				SetState(pendingStateChange);
			}
			else
			{
				if (CurrentState == null)
				{
					return;
				}
				TimeWarning val2 = TimeWarning.New("NormalTransitions", 0);
				try
				{
					foreach (var (fSMTransitionBase, fSMStateBase) in CurrentState.transitions)
					{
						if (fSMTransitionBase.Evaluate())
						{
							fSMStateBase.Owner = base.baseEntity;
							fSMTransitionBase.OnTransitionTaken(CurrentState, fSMStateBase);
							SetState(fSMStateBase);
							return;
						}
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				EFSMStateStatus currentStateStatus = EFSMStateStatus.None;
				TimeWarning val3 = TimeWarning.New("StateTick", 0);
				try
				{
					TimeWarning val4 = TimeWarning.New(CurrentState.Name, 0);
					try
					{
						currentStateStatus = CurrentState.OnStateUpdate(deltaTime);
					}
					finally
					{
						((IDisposable)val4)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
				EvaluateEndTransitions(currentStateStatus);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void EvaluateEndTransitions(EFSMStateStatus currentStateStatus)
	{
		TimeWarning val = TimeWarning.New("EndTransitions", 0);
		try
		{
			if (currentStateStatus == EFSMStateStatus.None)
			{
				return;
			}
			foreach (var (fSMTransitionBase, fSMStateBase, eFSMStateStatus) in CurrentState.endTransitions)
			{
				if ((eFSMStateStatus == (EFSMStateStatus.Success | EFSMStateStatus.Failure) || eFSMStateStatus == currentStateStatus) && (fSMTransitionBase == null || fSMTransitionBase.Evaluate()))
				{
					fSMStateBase.Owner = base.baseEntity;
					fSMTransitionBase?.OnTransitionTaken(CurrentState, fSMStateBase);
					SetState(fSMStateBase);
					break;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void SetState(FSMStateBase newState)
	{
		TimeWarning val = TimeWarning.New("SetState", 0);
		try
		{
			pendingStateChange = null;
			sameFrameStateChangesHistory.Add(newState);
			if (sameFrameStateChangesHistory.Count > 3)
			{
				if (!AI.logIssues)
				{
					return;
				}
				StringBuilder stringBuilder = Pool.Get<StringBuilder>();
				stringBuilder.AppendFormat("[FSM] Possible endless recursion detected from {0} to {1} on {2}\n", CurrentState?.Name, newState.Name, base.baseEntity);
				foreach (FSMStateBase item in sameFrameStateChangesHistory)
				{
					stringBuilder.AppendFormat("{0} -> ", item.Name);
				}
				Debug.LogWarning((object)stringBuilder);
				pendingStateChange = newState;
				Pool.FreeUnmanaged(ref stringBuilder);
				return;
			}
			if (CurrentState != null)
			{
				TimeWarning val2 = TimeWarning.New("Transitions OnStateExit", 0);
				try
				{
					foreach (var endTransition in CurrentState.endTransitions)
					{
						endTransition.transition?.OnStateExit();
					}
					foreach (var transition in CurrentState.transitions)
					{
						transition.transition.OnStateExit();
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				TimeWarning val3 = TimeWarning.New("OnStateExit", 0);
				try
				{
					TimeWarning val4 = TimeWarning.New(CurrentState.Name, 0);
					try
					{
						CurrentState.OnStateExit();
					}
					finally
					{
						((IDisposable)val4)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			CurrentState = newState;
			TimeWarning val5 = TimeWarning.New("Transitions OnStateEnter", 0);
			try
			{
				foreach (var endTransition2 in CurrentState.endTransitions)
				{
					endTransition2.transition?.OnStateEnter();
				}
				foreach (var transition2 in CurrentState.transitions)
				{
					transition2.transition.OnStateEnter();
				}
			}
			finally
			{
				((IDisposable)val5)?.Dispose();
			}
			TimeWarning val6 = TimeWarning.New("OnStateEnter", 0);
			try
			{
				TimeWarning val7 = TimeWarning.New(CurrentState.Name, 0);
				try
				{
					EFSMStateStatus currentStateStatus = CurrentState.OnStateEnter();
					EvaluateEndTransitions(currentStateStatus);
				}
				finally
				{
					((IDisposable)val7)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val6)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public T AddTransition<T>(FSMStateBase from, FSMStateBase to, T transition) where T : FSMTransitionBase
	{
		transition.Init(base.baseEntity);
		from.transitions.Add((transition, to));
		return transition;
	}

	public FSMTransitionBase AddEndTransition(FSMStateBase from, FSMStateBase to, FSMTransitionBase transition = null, EFSMStateStatus status = EFSMStateStatus.Success | EFSMStateStatus.Failure)
	{
		transition?.Init(base.baseEntity);
		from.endTransitions.Add((transition, to, status));
		return transition;
	}

	public T AddTransitionMulti<T>(HashSet<FSMStateBase> from, FSMStateBase to, T transition) where T : FSMTransitionBase
	{
		transition.Init(base.baseEntity);
		foreach (FSMStateBase item in from)
		{
			item.transitions.Add((transition, to));
		}
		return transition;
	}

	public void BuildFromTree(TreeNode node)
	{
		if (!node.IsLeaf())
		{
			HashSet<FSMStateBase> hashSet = new HashSet<FSMStateBase>();
			node.GetAllNestedStates(hashSet);
			if (node.tickTransitions != null)
			{
				foreach (var (transition, treeNode) in node.tickTransitions)
				{
					AddTransitionMulti(hashSet, treeNode.GetFirstChildLeaf().state, transition);
				}
			}
			{
				foreach (TreeNode child in node.children)
				{
					BuildFromTree(child);
				}
				return;
			}
		}
		if (node.tickTransitions != null)
		{
			foreach (var (transition2, treeNode2) in node.tickTransitions)
			{
				AddTransition(node.state, treeNode2.GetFirstChildLeaf().state, transition2);
			}
		}
		if (node.endTransitions == null)
		{
			return;
		}
		foreach (var (transition3, treeNode3, status) in node.endTransitions)
		{
			AddEndTransition(node.state, treeNode3.GetFirstChildLeaf().state, transition3, status);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class TreeNode
{
	public FSMStateBase state;

	public List<(FSMTransitionBase transition, TreeNode dstState)> tickTransitions;

	public List<(FSMTransitionBase transition, TreeNode dstState, EFSMStateStatus status)> endTransitions;

	public List<TreeNode> children;

	public TreeNode parent;

	public TreeNode(FSMStateBase state = null)
	{
		this.state = state;
	}

	public bool IsLeaf()
	{
		return children == null;
	}

	public TreeNode GetFirstChildLeaf()
	{
		if (IsLeaf())
		{
			return this;
		}
		foreach (TreeNode child in children)
		{
			if (child.IsLeaf())
			{
				return child;
			}
			TreeNode firstChildLeaf = child.GetFirstChildLeaf();
			if (firstChildLeaf != null)
			{
				return firstChildLeaf;
			}
		}
		return null;
	}

	public void GetAllNestedStates(HashSet<FSMStateBase> nestedStates)
	{
		if (IsLeaf())
		{
			return;
		}
		foreach (TreeNode child in children)
		{
			if (child.IsLeaf())
			{
				nestedStates.Add(child.state);
			}
			else
			{
				child.GetAllNestedStates(nestedStates);
			}
		}
	}

	public TreeNode AddEndTransition(TreeNode dstState, FSMTransitionBase transition = null)
	{
		if (endTransitions == null)
		{
			endTransitions = new List<(FSMTransitionBase, TreeNode, EFSMStateStatus)>();
		}
		endTransitions.Add((transition, dstState, EFSMStateStatus.Success | EFSMStateStatus.Failure));
		return this;
	}

	public TreeNode AddFailureTransition(TreeNode dstState)
	{
		if (endTransitions == null)
		{
			endTransitions = new List<(FSMTransitionBase, TreeNode, EFSMStateStatus)>();
		}
		endTransitions.Add((null, dstState, EFSMStateStatus.Failure));
		return this;
	}

	public TreeNode AddTickTransition(TreeNode dstState, FSMTransitionBase transition)
	{
		if (tickTransitions == null)
		{
			tickTransitions = new List<(FSMTransitionBase, TreeNode)>();
		}
		tickTransitions.Add((transition, dstState));
		return this;
	}

	public TreeNode AddTickBranchingTrans(TreeNode dstState1, FSMTransitionBase sharedTransition, TreeNode dstState2, FSMTransitionBase dstState2Trans)
	{
		if (tickTransitions == null)
		{
			tickTransitions = new List<(FSMTransitionBase, TreeNode)>();
		}
		tickTransitions.Add((new Trans_And { sharedTransition, dstState2Trans }, dstState2));
		tickTransitions.Add((sharedTransition, dstState1));
		return this;
	}

	public TreeNode AddChild(TreeNode child)
	{
		if (state != null)
		{
			Debug.LogError((object)"Can't add children to node with a state");
		}
		if (children == null)
		{
			children = new List<TreeNode>();
		}
		children.Add(child);
		child.parent = this;
		return child;
	}

	public TreeNode AddChildren(TreeNode child1, TreeNode child2 = null, TreeNode child3 = null, TreeNode child4 = null, TreeNode child5 = null, TreeNode child6 = null, TreeNode child7 = null, TreeNode child8 = null, TreeNode child9 = null, TreeNode child10 = null)
	{
		AddChild(child1);
		if (child2 != null)
		{
			AddChild(child2);
		}
		if (child3 != null)
		{
			AddChild(child3);
		}
		if (child4 != null)
		{
			AddChild(child4);
		}
		if (child5 != null)
		{
			AddChild(child5);
		}
		if (child6 != null)
		{
			AddChild(child6);
		}
		if (child7 != null)
		{
			AddChild(child7);
		}
		if (child8 != null)
		{
			AddChild(child8);
		}
		if (child9 != null)
		{
			AddChild(child9);
		}
		if (child10 != null)
		{
			AddChild(child10);
		}
		return this;
	}
}


using UnityEngine;

public class TickFSMWorkQueue : PersistentObjectWorkQueue<FSMComponent>
{
	protected override void RunJob(FSMComponent component)
	{
		if (((PersistentObjectWorkQueue<FSMComponent>)this).ShouldAdd(component) && ((Behaviour)component).enabled)
		{
			component.Senses.Tick();
			((Component)component).GetComponent<NPCEncounterTimer>().Tick();
			component.Tick();
		}
	}

	protected override bool ShouldAdd(FSMComponent component)
	{
		if (base.ShouldAdd(component))
		{
			return component.baseEntity.IsValid();
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Rust.Ai.Gen2;
using UnityEngine;

public abstract class FSMStateBase
{
	[NonSerialized]
	public BaseEntity Owner;

	[SerializeField]
	private string _Name;

	public List<(FSMTransitionBase transition, FSMStateBase dstState)> transitions = new List<(FSMTransitionBase, FSMStateBase)>();

	public List<(FSMTransitionBase transition, FSMStateBase dstState, EFSMStateStatus status)> endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();

	private SenseComponent _senses;

	private LimitedTurnNavAgent _agent;

	private RootMotionPlayer _animPlayer;

	private BlackboardComponent _blackboard;

	public string Name
	{
		get
		{
			if (string.IsNullOrEmpty(_Name))
			{
				_Name = GetType().Name.Replace("State_", "");
			}
			return _Name;
		}
		set
		{
			_Name = value;
		}
	}

	protected SenseComponent Senses => _senses ?? (_senses = ((Component)Owner).GetComponent<SenseComponent>());

	protected LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)Owner).GetComponent<LimitedTurnNavAgent>());

	protected RootMotionPlayer AnimPlayer => _animPlayer ?? (_animPlayer = ((Component)Owner).GetComponent<RootMotionPlayer>());

	protected BlackboardComponent Blackboard => _blackboard ?? (_blackboard = ((Component)Owner).GetComponent<BlackboardComponent>());

	public virtual EFSMStateStatus OnStateEnter()
	{
		return EFSMStateStatus.None;
	}

	public virtual EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		return EFSMStateStatus.None;
	}

	public virtual void OnStateExit()
	{
	}

	protected T GetRootFSM<T>() where T : FSMComponent
	{
		return ((Component)Owner).GetComponent<T>();
	}

	public virtual FSMStateBase Clone()
	{
		FSMStateBase obj = (FSMStateBase)MemberwiseClone();
		obj.transitions = new List<(FSMTransitionBase, FSMStateBase)>();
		obj.endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();
		return obj;
	}
}


public interface IParametrized<T>
{
	void SetParameter(T parameter);
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_Nothing : FSMStateBase
{
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_MoveToTarget : FSMStateBase, IParametrized<BaseEntity>
{
	[SerializeField]
	public LimitedTurnNavAgent.Speeds speed = LimitedTurnNavAgent.Speeds.FullSprint;

	[SerializeField]
	public bool succeedWhenDestinationIsReached = true;

	[SerializeField]
	public bool stopAtDestination = true;

	[SerializeField]
	public float accelerationOverride;

	[SerializeField]
	public float decelerationOverride;

	public void SetParameter(BaseEntity target)
	{
		base.Senses.TrySetTarget(target);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		base.Agent.ResetPath();
		base.Agent.shouldStopAtDestination = stopAtDestination;
		base.Agent.SetSpeed(speed);
		if (accelerationOverride > 0f)
		{
			base.Agent.acceleration.Value = accelerationOverride;
		}
		if (decelerationOverride > 0f)
		{
			base.Agent.deceleration.Value = decelerationOverride;
		}
		if (!GetMoveDestination(out var destination) || !base.Agent.SetDestination(destination))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Agent.IsFollowingPath && succeedWhenDestinationIsReached)
		{
			return EFSMStateStatus.Success;
		}
		if (!GetMoveDestination(out var destination) || !base.Agent.SetDestination(destination))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	protected virtual bool GetMoveDestination(out Vector3 destination)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			destination = Vector3.zero;
			return false;
		}
		destination = targetPosition;
		return true;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

public abstract class State_PlayAnimationBase : FSMStateBase
{
	[SerializeField]
	public bool FaceTarget;

	private EFSMStateStatus _status;

	private Action _succeedAction;

	protected Action SucceedAction => Succeed;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (FaceTarget && base.Senses.FindTargetPosition(out var targetPosition))
		{
			Vector3 val = targetPosition - ((Component)Owner).transform.position;
			val.y = 0f;
			((Component)Owner).transform.rotation = Quaternion.LookRotation(val);
		}
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		return _status;
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServer();
		_status = EFSMStateStatus.None;
	}

	private void Succeed()
	{
		_status = EFSMStateStatus.Success;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimation : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip Animation;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		base.AnimPlayer.PlayServer(Animation, base.SucceedAction);
		return result;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimationRM : State_PlayAnimationBase
{
	[SerializeField]
	public RootMotionData Animation;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		base.AnimPlayer.PlayServer(Animation, base.SucceedAction);
		return result;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayRandomAnimation : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip[] animations;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		base.AnimPlayer.PlayServer(animations.GetRandom(), base.SucceedAction);
		return result;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimLoop : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip Start;

	[SerializeField]
	public AnimationClip Loop;

	[SerializeField]
	public AnimationClip Stop;

	[SerializeField]
	public float MinDuration = 7f;

	[SerializeField]
	public float MaxDuration = 14f;

	private float duration;

	private Action _playLoopAction;

	private Action PlayLoopAction => PlayLoop;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		duration = Random.Range(MinDuration, MaxDuration);
		base.AnimPlayer.PlayServer(Start, PlayLoopAction);
		return result;
	}

	private void PlayLoop()
	{
		if (!(duration <= 0f))
		{
			base.AnimPlayer.PlayServer(Loop, PlayLoopAction);
		}
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (duration > 0f)
		{
			duration -= deltaTime;
			if (duration <= 0f)
			{
				base.AnimPlayer.PlayServer(Stop, base.SucceedAction);
			}
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using System.Linq;
using Rust.Ai.Gen2;
using UnityEngine;

public abstract class FSMTransitionBase
{
	[SerializeField]
	public bool Inverted;

	[NonSerialized]
	public BaseEntity Owner;

	private SenseComponent _senses;

	private LimitedTurnNavAgent _agent;

	protected SenseComponent Senses => _senses ?? (_senses = ((Component)Owner).GetComponent<SenseComponent>());

	protected LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)Owner).GetComponent<LimitedTurnNavAgent>());

	public virtual void Init(BaseEntity owner)
	{
		Owner = owner;
	}

	public virtual void OnStateEnter()
	{
	}

	public virtual void OnStateExit()
	{
	}

	public virtual void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
	}

	public bool Evaluate()
	{
		if (!Inverted)
		{
			return EvaluateInternal();
		}
		return !EvaluateInternal();
	}

	protected virtual bool EvaluateInternal()
	{
		return false;
	}

	public virtual string GetName()
	{
		return (Inverted ? "!" : "") + GetGenericTypeName(GetType());
	}

	protected static string GetGenericTypeName(Type type)
	{
		if (type.IsGenericType)
		{
			string name = type.Name;
			return (name[..name.IndexOf('`')] + "<" + string.Join(", ", type.GetGenericArguments().Select(GetGenericTypeName)) + ">").Replace("Trans_", "");
		}
		return type.Name.Replace("Trans_", "");
	}

	public virtual FSMTransitionBase Clone()
	{
		return (FSMTransitionBase)MemberwiseClone();
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_AlwaysValid : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		return true;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public abstract class Trans_Composite : FSMTransitionBase, IEnumerable<FSMTransitionBase>, IEnumerable
{
	[SerializeField]
	protected List<FSMTransitionBase> transitions = new List<FSMTransitionBase>();

	public IEnumerator<FSMTransitionBase> GetEnumerator()
	{
		return transitions.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public void Add(FSMTransitionBase transition)
	{
		transitions.Add(transition);
	}

	public Trans_Composite()
	{
	}

	public override void Init(BaseEntity owner)
	{
		base.Init(owner);
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.Init(owner);
		}
	}

	public Trans_Composite(List<FSMTransitionBase> transitions)
	{
		this.transitions = transitions;
	}

	public override void OnStateEnter()
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnStateEnter();
		}
	}

	public override void OnStateExit()
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnStateExit();
		}
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnTransitionTaken(from, to);
		}
	}

	protected virtual string GetNameSeparator()
	{
		return " ";
	}

	public override string GetName()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("(");
		for (int i = 0; i < transitions.Count; i++)
		{
			stringBuilder.Append(transitions[i].GetName());
			if (i < transitions.Count - 1)
			{
				stringBuilder.Append(" ");
				stringBuilder.Append(GetNameSeparator());
				stringBuilder.Append(" ");
			}
		}
		stringBuilder.Append(" )");
		return stringBuilder.ToString();
	}

	public override FSMTransitionBase Clone()
	{
		Trans_Composite obj = base.Clone() as Trans_Composite;
		obj.transitions = new List<FSMTransitionBase>();
		return obj;
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_And : Trans_Composite
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_And", 0);
		try
		{
			foreach (FSMTransitionBase transition in transitions)
			{
				if (!transition.Evaluate())
				{
					return false;
				}
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override string GetNameSeparator()
	{
		return "&&";
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_Or : Trans_Composite
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Or", 0);
		try
		{
			foreach (FSMTransitionBase transition in transitions)
			{
				if (transition.Evaluate())
				{
					return true;
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override string GetNameSeparator()
	{
		return "||";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

public class Trans_Lambda : FSMTransitionBase
{
	private Func<BaseEntity, bool> EvaluateFunc;

	public Trans_Lambda(Func<BaseEntity, bool> evaluateFunc)
	{
		EvaluateFunc = evaluateFunc;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Lambda", 0);
		try
		{
			if ((Object)(object)Owner == (Object)null)
			{
				return false;
			}
			return EvaluateFunc(Owner);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_RandomChance : FSMTransitionBase
{
	[SerializeField]
	public float chance = 0.5f;

	private bool Triggered;

	public override void OnStateEnter()
	{
		Triggered = Random.value <= chance;
	}

	public override void OnStateExit()
	{
		Triggered = false;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_RandomChance", 0);
		try
		{
			return Triggered;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_Cooldown : FSMTransitionBase
{
	[SerializeField]
	public float cooldown = 20f;

	private double? lastTakenTime;

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		base.OnTransitionTaken(from, to);
		lastTakenTime = Time.timeAsDouble;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Cooldown", 0);
		try
		{
			return !lastTakenTime.HasValue || Time.timeAsDouble - lastTakenTime.Value >= (double)cooldown;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {cooldown}s";
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_Triggerable : FSMTransitionBase
{
	protected bool Triggered { get; private set; }

	public void Trigger()
	{
		Triggered = true;
	}

	public override void OnStateEnter()
	{
		Triggered = false;
	}

	public override void OnStateExit()
	{
		Triggered = false;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Triggerable", 0);
		try
		{
			return Triggered;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using Rust.Ai.Gen2;

public class Trans_Triggerable<T> : Trans_Triggerable
{
	private T Parameter;

	public void Trigger(T parameter)
	{
		Parameter = parameter;
		Trigger();
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		if (base.Triggered && to is IParametrized<T> parametrized)
		{
			parametrized.SetParameter(Parameter);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_ElapsedTime : FSMTransitionBase
{
	[SerializeField]
	public double Duration = 6.0;

	private double startTime;

	public override void OnStateEnter()
	{
		startTime = Time.timeAsDouble;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_ElapsedTime", 0);
		try
		{
			return Time.timeAsDouble >= startTime + Duration;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {Duration}s";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_ElapsedTimeRandomized : Trans_ElapsedTime
{
	[SerializeField]
	public double MinDuration = 2.0;

	[SerializeField]
	public double MaxDuration = 6.0;

	public override void OnStateEnter()
	{
		Duration = MinDuration + (double)Random.value * (MaxDuration - MinDuration);
		base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_TargetInRange : FSMTransitionBase
{
	[SerializeField]
	public float Range = 4f;

	private float rangeSq;

	public override void Init(BaseEntity owner)
	{
		base.Init(owner);
		rangeSq = Range * Range;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetInRange", 0);
		try
		{
			return base.Senses.IsTargetInRangeSq(rangeSq);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return string.Format("{0} {1}{2}m", base.GetName(), Inverted ? ">=" : "<", Range);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_TargetInFront : FSMTransitionBase
{
	[SerializeField]
	public float Angle = 90f;

	protected override bool EvaluateInternal()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TargetInFront", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			Vector3 val2 = targetPosition - ((Component)Owner).transform.position;
			return Vector3.Angle(((Component)Owner).transform.forward, val2) < Angle;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return string.Format("{0} {1}{2}", base.GetName(), Inverted ? ">=" : "<", Angle);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_TargetIsNearFire : FSMTransitionBase
{
	public bool onlySeeFireWhenClose;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetIsNearFire", 0);
		try
		{
			return Test(Owner, base.Senses, onlySeeFireWhenClose);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool Test(BaseEntity owner, SenseComponent senses, bool onlySeeFireWhenClose = false)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Test", 0);
		try
		{
			if (!senses.FindTarget(out var target))
			{
				return false;
			}
			if (target.ToNonNpcPlayer(out var player) && SingletonComponent<NpcNoiseManager>.Instance.HasPlayerSpokenNear(owner, player))
			{
				return true;
			}
			if (!senses.FindFire(out var fire))
			{
				return false;
			}
			bool flag = Vector3.Distance(((Component)target).transform.position, ((Component)fire).transform.position) < 16f;
			bool flag2 = Vector3.Distance(((Component)owner).transform.position, ((Component)target).transform.position) < 18f;
			if (onlySeeFireWhenClose)
			{
				return flag && flag2;
			}
			return flag;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_HasTarget : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasTarget", 0);
		try
		{
			BaseEntity target;
			return base.Senses.FindTarget(out target);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

internal abstract class FSMSlowTransitionBase : FSMTransitionBase
{
	private bool cachedEvalResult;

	private double? lastEvalTime;

	private double cacheLifeTime = 1.0;

	protected sealed override bool EvaluateInternal()
	{
		double timeAsDouble = Time.timeAsDouble;
		if (!lastEvalTime.HasValue || timeAsDouble - lastEvalTime.Value > cacheLifeTime)
		{
			cachedEvalResult = EvaluateAtInterval();
			lastEvalTime = timeAsDouble;
		}
		return cachedEvalResult;
	}

	protected abstract bool EvaluateAtInterval();
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_CanReachTarget_Slow : FSMSlowTransitionBase
{
	protected override bool EvaluateAtInterval()
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_CanReachTarget_Slow", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			LimitedTurnNavAgent component = ((Component)Owner).GetComponent<LimitedTurnNavAgent>();
			if ((Object)(object)component == (Object)null)
			{
				return false;
			}
			return component.CanReach(targetPosition);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsHealthBelowPercentage : FSMTransitionBase
{
	[SerializeField]
	public float percentage = 0.25f;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsHealthBelowPercentage", 0);
		try
		{
			return Owner is BaseCombatEntity baseCombatEntity && baseCombatEntity.healthFraction < percentage;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} <{percentage * 100f}%";
	}
}


using System;
using ConVar;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_IsNavmeshReady : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsNavmeshReady", 0);
		try
		{
			return AI.move && base.Agent.IsNavmeshReady;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_InitialAlliesNotFighting : FSMTransitionBase
{
	[SerializeField]
	public float MinAllyHealthFraction = 0.3f;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_InitialAlliesNotFighting", 0);
		try
		{
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				base.Senses.GetInitialAllies((List<BaseEntity>)(object)val2);
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (!((Component)item).GetComponent<SenseComponent>().FindTarget(out var _) && (!(item is BaseCombatEntity baseCombatEntity) || !(baseCombatEntity.healthFraction < MinAllyHealthFraction)))
					{
						return true;
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_HasBlackboardBool : FSMTransitionBase
{
	[SerializeField]
	public string Key;

	private BlackboardComponent _blackboard;

	private BlackboardComponent Blackboard => _blackboard ?? (_blackboard = ((Component)Owner).GetComponent<BlackboardComponent>());

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasBlackboardBool", 0);
		try
		{
			return Blackboard.Has(Key);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return base.GetName() + " " + Key;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_NoiseNearby : FSMTransitionBase
{
	[SerializeField]
	public float distance = 7f;

	protected override bool EvaluateInternal()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_NoiseNearby", 0);
		try
		{
			NpcNoiseEvent currentNoise = base.Senses.currentNoise;
			return currentNoise != null && Vector3.Distance(((Component)Owner).transform.position, currentNoise.Position) < distance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		base.OnTransitionTaken(from, to);
		if (base.Senses.currentNoise != null)
		{
			if (to is IParametrized<NpcNoiseEvent> parametrized)
			{
				parametrized.SetParameter(base.Senses.currentNoise);
			}
			base.Senses.ConsumeCurrentNoise();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} <{distance}m";
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_SeesFood : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_SeesFood", 0);
		try
		{
			BaseEntity food;
			return base.Senses.FindFood(out food);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_TargetOrSelfInWater : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TargetOrSelfInWater", 0);
		try
		{
			if (base.Senses.FindTarget(out var target) && target.ToNonNpcPlayer(out var _) && !LimitedTurnNavAgent.IsAcceptableWaterDepth(Owner, ((Component)target).transform.position, ((Bounds)(ref Owner.bounds)).extents.y))
			{
				return true;
			}
			return !LimitedTurnNavAgent.IsAcceptableWaterDepth(Owner, ((Component)Owner).transform.position, ((Bounds)(ref Owner.bounds)).extents.y);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_TargetIsInSafeZone : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetIsInSafeZone", 0);
		try
		{
			BaseEntity target;
			return base.Senses.FindTarget(out target) && target.InSafeZone();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Events;

[SoftRequireComponent(typeof(NavMeshAgent))]
public class LimitedTurnNavAgent : EntityComponent<BaseEntity>, IServerComponent
{
	public enum Speeds
	{
		Sneak,
		Walk,
		Jog,
		Run,
		Sprint,
		FullSprint
	}

	[SerializeField]
	private NavMeshAgent agent;

	[Header("Speed")]
	[SerializeField]
	private float sneakSpeed = 0.6f;

	[SerializeField]
	private float walkSpeed = 0.89f;

	[SerializeField]
	private float jogSpeed = 2.45f;

	[SerializeField]
	private float runSpeed = 4.4f;

	[SerializeField]
	private float sprintSpeed = 6f;

	[SerializeField]
	private float fullSprintSpeed = 9f;

	[SerializeField]
	public ResettableFloat acceleration = new ResettableFloat(10f);

	[SerializeField]
	public ResettableFloat deceleration = new ResettableFloat(2f);

	[SerializeField]
	private float maxTurnRadius = 2f;

	[SerializeField]
	private Enum preferedTopology = (Enum)537002081;

	[SerializeField]
	private Enum preferedBiome = (Enum)15;

	private static NavMeshPath path;

	[NonSerialized]
	public UnityEvent onPathFailed = new UnityEvent();

	private LockState movementLock = new LockState();

	private bool isNavMeshReady;

	private static ListHashSet<LimitedTurnNavAgent> steeringComponents = new ListHashSet<LimitedTurnNavAgent>(8);

	[NonSerialized]
	public float currentDeviation;

	[NonSerialized]
	public bool shouldStopAtDestination = true;

	private float cachedPathLength;

	private Vector3? previousLocalPosition;

	private float curSpeed;

	private float desiredSpeed;

	public bool IsNavmeshReady => isNavMeshReady;

	public Vector3? lastValidDestination { get; private set; }

	public bool IsFollowingPath
	{
		get
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			if (agent.hasPath)
			{
				return agent.remainingDistance > (shouldStopAtDestination ? ((Bounds)(ref base.baseEntity.bounds)).extents.z : maxTurnRadius);
			}
			return false;
		}
	}

	public LockState.LockHandle Pause()
	{
		if (!movementLock.IsLocked)
		{
			OnPaused();
		}
		return movementLock.AddLock();
	}

	public bool Unpause(ref LockState.LockHandle handle)
	{
		bool result = movementLock.RemoveLock(ref handle);
		if (!movementLock.IsLocked)
		{
			OnUnpaused();
		}
		return result;
	}

	public void Move(Vector3 offset)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:Move", 0);
		try
		{
			agent.Move(offset);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ResetPath()
	{
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:ResetPath", 0);
		try
		{
			shouldStopAtDestination = true;
			acceleration.Reset();
			deceleration.Reset();
			currentDeviation = 0f;
			if (agent.hasPath)
			{
				agent.ResetPath();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool CanReach(Vector3 location, bool triggerPathFailed = false)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Invalid comparison between Unknown and I4
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:CanReach", 0);
		try
		{
			if (!IsPositionOnNavmesh(location, out var sample))
			{
				if (triggerPathFailed)
				{
					FailPath(location);
				}
				return false;
			}
			if (!CalculatePathCustom(sample, path))
			{
				if (triggerPathFailed)
				{
					FailPath(sample, path);
				}
				return false;
			}
			bool flag = (int)path.status == 0;
			if (!flag && triggerPathFailed)
			{
				FailPath(sample, path);
			}
			else if (flag && triggerPathFailed)
			{
				lastValidDestination = path.GetDestination();
			}
			return flag;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool SetDestination(Vector3 newDestination, bool acceptPartialPaths = false)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Invalid comparison between Unknown and I4
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Invalid comparison between Unknown and I4
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:SetDestination", 0);
		try
		{
			if (shouldStopAtDestination && agent.hasPath && Vector3.Distance(agent.destination, newDestination) < 1f)
			{
				return true;
			}
			if (!CalculatePathCustom(newDestination, path))
			{
				FailPath(newDestination, path);
				return false;
			}
			if (!(acceptPartialPaths ? ((int)path.status != 2) : ((int)path.status == 0)))
			{
				FailPath(newDestination, path);
				return false;
			}
			SetPath(path);
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool SetDestinationFromDirection(Vector3 normalizedDirection, float distance = 10f, bool restrictTerrain = false)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:SetDestinationFromDirection", 0);
		try
		{
			PooledList<Vector3> val2 = Pool.Get<PooledList<Vector3>>();
			try
			{
				SamplePositionsInDonutShape(((Component)base.baseEntity).transform.position, (List<Vector3>)(object)val2, distance, distance);
				PooledList<(Vector3, float)> val3 = Pool.Get<PooledList<(Vector3, float)>>();
				try
				{
					Vector3 val4;
					foreach (Vector3 item2 in (List<Vector3>)(object)val2)
					{
						val4 = item2 - ((Component)base.baseEntity).transform.position;
						float item = Vector3.Dot(((Vector3)(ref val4)).normalized, normalizedDirection);
						((List<(Vector3, float)>)(object)val3).Add((item2, item));
					}
					((List<(Vector3, float)>)(object)val3).Sort((Comparison<(Vector3, float)>)(((Vector3 position, float score) a, (Vector3 position, float score) b) => b.score.CompareTo(a.score)));
					for (int i = 0; i < ((List<(Vector3, float)>)(object)val3).Count; i++)
					{
						((List<Vector3>)(object)val2)[i] = ((List<(Vector3, float)>)(object)val3)[i].Item1;
					}
					if (!GetFirstReachablePoint((List<Vector3>)(object)val2, ref path, restrictTerrain, restrictWater: true))
					{
						((List<(Vector3, float)>)(object)val3).Clear();
						foreach (Vector3 item3 in (List<Vector3>)(object)val2)
						{
							val4 = item3 - ((Component)base.baseEntity).transform.position;
							float num = Vector3.Dot(((Vector3)(ref val4)).normalized, normalizedDirection);
							if (restrictTerrain && !IsPositionOnValidTerrain(item3))
							{
								num -= 100f;
							}
							float overallWaterDepth = WaterLevel.GetOverallWaterDepth(item3, waves: false, volumes: false);
							if (overallWaterDepth > 0.01f)
							{
								num -= (1f + overallWaterDepth) * 1000f;
							}
							((List<(Vector3, float)>)(object)val3).Add((item3, num));
						}
						((List<(Vector3, float)>)(object)val3).Sort((Comparison<(Vector3, float)>)(((Vector3 position, float score) a, (Vector3 position, float score) b) => b.score.CompareTo(a.score)));
						for (int j = 0; j < ((List<(Vector3, float)>)(object)val3).Count; j++)
						{
							((List<Vector3>)(object)val2)[j] = ((List<(Vector3, float)>)(object)val3)[j].Item1;
						}
						if (!GetFirstReachablePoint((List<Vector3>)(object)val2, ref path, restrictTerrain: false, restrictWater: false))
						{
							FailPath(null);
							return false;
						}
					}
					SetPath(path);
					return true;
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void InitShared()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Expected O, but got Unknown
		base.InitShared();
		if (path == null)
		{
			path = new NavMeshPath();
		}
	}

	private void OnPaused()
	{
		if (((Behaviour)agent).enabled && agent.isOnNavMesh)
		{
			ResetPath();
		}
	}

	private void OnUnpaused()
	{
	}

	private void SetPath(NavMeshPath newPath)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:SetPath", 0);
		try
		{
			if (agent.path != newPath)
			{
				agent.SetPath(newPath);
			}
			cachedPathLength = newPath.GetPathLength();
			lastValidDestination = newPath.GetDestination();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ShowFailedPath(Vector3? destination, NavMeshPath failedPath)
	{
	}

	private void FailPath(Vector3? destination, NavMeshPath failedPath = null)
	{
		ShowFailedPath(destination, failedPath);
		onPathFailed.Invoke();
		ResetPath();
	}

	public void SetSpeed(Speeds speed)
	{
		switch (speed)
		{
		case Speeds.Sneak:
			desiredSpeed = sneakSpeed;
			break;
		case Speeds.Walk:
			desiredSpeed = walkSpeed;
			break;
		case Speeds.Jog:
			desiredSpeed = jogSpeed;
			break;
		case Speeds.Run:
			desiredSpeed = runSpeed;
			break;
		case Speeds.Sprint:
			desiredSpeed = sprintSpeed;
			break;
		case Speeds.FullSprint:
			desiredSpeed = fullSprintSpeed;
			break;
		default:
			desiredSpeed = walkSpeed;
			break;
		}
	}

	public void SetSpeed(float ratio, Speeds minSpeed = Speeds.Sneak, Speeds maxSpeed = Speeds.Sprint, int offset = 0)
	{
		int num = Mathf.FloorToInt(Mathf.Lerp((float)minSpeed, (float)maxSpeed, ratio));
		num = Mathf.Clamp(num + offset, (int)minSpeed, (int)maxSpeed);
		SetSpeed((Speeds)num);
	}

	private void OnEnable()
	{
		steeringComponents.TryAdd(this);
	}

	private void OnDisable()
	{
		steeringComponents.Remove(this);
	}

	public static void TickSteering()
	{
		for (int num = steeringComponents.Count - 1; num >= 0; num--)
		{
			LimitedTurnNavAgent limitedTurnNavAgent = steeringComponents[num];
			if (limitedTurnNavAgent.IsUnityNull() || !limitedTurnNavAgent.baseEntity.IsValid())
			{
				steeringComponents.RemoveAt(num);
			}
			else
			{
				limitedTurnNavAgent.Tick();
			}
		}
	}

	private void Tick()
	{
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:Tick", 0);
		try
		{
			try
			{
				if (!AI.move)
				{
					return;
				}
				if (!isNavMeshReady)
				{
					isNavMeshReady = (Object)(object)agent != (Object)null && ((Behaviour)agent).enabled && agent.isOnNavMesh;
					if (!isNavMeshReady)
					{
						return;
					}
					agent.updateRotation = false;
					agent.updateUpAxis = false;
					agent.isStopped = true;
				}
				if (movementLock.IsLocked)
				{
					if (previousLocalPosition.HasValue)
					{
						Vector3 val2 = ((Component)base.baseEntity).transform.localPosition - previousLocalPosition.Value;
						curSpeed = ((Vector3)(ref val2)).magnitude / Time.deltaTime;
					}
				}
				else if (!shouldStopAtDestination || IsFollowingPath)
				{
					SteerTowardsWaypoint();
				}
				else
				{
					curSpeed = 0f;
					ResetPath();
				}
			}
			finally
			{
				previousLocalPosition = ((Component)base.baseEntity).transform.localPosition;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static float GetBrakingDistance(float speed, float brakingDeceleration)
	{
		float num = speed / Mathf.Max(brakingDeceleration, 0.001f);
		return 0.5f * brakingDeceleration * num * num;
	}

	private void SteerTowardsWaypoint()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SteerTowardsWaypoint", 0);
		try
		{
			Transform transform = ((Component)base.baseEntity).transform;
			Vector3 val2 = agent.steeringTarget - transform.position;
			Vector3 val3 = ((Vector3)(ref val2)).normalized;
			if (Mathf.Abs(cachedPathLength - Vector3.Distance(transform.position, agent.destination)) < 5f)
			{
				val3 = Quaternion.AngleAxis(currentDeviation, Vector3.up) * val3;
			}
			if (shouldStopAtDestination && agent.remainingDistance - maxTurnRadius < GetBrakingDistance(curSpeed, deceleration.Value))
			{
				curSpeed = Mathf.Max(1f, curSpeed - deceleration.Value * Time.deltaTime);
			}
			else if (curSpeed > desiredSpeed)
			{
				curSpeed = Mathf.Max(desiredSpeed, curSpeed - deceleration.Value * Time.deltaTime);
			}
			else if (curSpeed < desiredSpeed)
			{
				curSpeed = Mathf.Min(desiredSpeed, curSpeed + acceleration.Value * Time.deltaTime);
			}
			agent.isStopped = true;
			if (!(((Vector3)(ref val3)).magnitude < 0.01f))
			{
				float num = (shouldStopAtDestination ? Mathx.RemapValClamped(agent.remainingDistance, maxTurnRadius * 2f, 0f, maxTurnRadius, 0.001f) : maxTurnRadius);
				float num2 = curSpeed / num;
				Vector3 val4 = Vector3.RotateTowards(transform.forward, val3, num2 * Time.deltaTime, 0f);
				Vector3 offset = val4 * (curSpeed * Time.deltaTime);
				transform.rotation = Quaternion.LookRotation(Vector3Ex.WithY(val4, 0f));
				Move(offset);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionOnValidTerrain(Vector3 position)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionOnValidTerrain", 0);
		try
		{
			return IsPositionAtTopologyRequirement(base.baseEntity, position, preferedTopology) && IsPositionABiomeRequirement(base.baseEntity, position, preferedBiome);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionOnNavmesh(Vector3 position, out Vector3 sample)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return SamplePosition(position, out sample, 0.5f);
	}

	public bool SampleGroundPositionWithPhysics(Vector3 position, out Vector3 sample, float maxDistance, float radius = 0f)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SampleGroundPositionWithPhysics", 0);
		try
		{
			sample = position;
			Vector3 val2 = position + Vector3.up * radius * 1.5f;
			float maxDistance2 = maxDistance + radius * 1.5f;
			if (GamePhysics.Trace(new Ray(val2, Vector3.down), radius, out var hitInfo, maxDistance2, 1503731969, (QueryTriggerInteraction)1))
			{
				if (radius == 0f || ((RaycastHit)(ref hitInfo)).distance > 0f)
				{
					sample = ((RaycastHit)(ref hitInfo)).point;
				}
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool SamplePosition(Vector3 position, out Vector3 sample, float maxDistance)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SamplePosition", 0);
		try
		{
			sample = position;
			NavMeshHit val2 = default(NavMeshHit);
			if (!NavMesh.SamplePosition(position, ref val2, maxDistance, agent.areaMask))
			{
				return false;
			}
			sample = ((NavMeshHit)(ref val2)).position;
			return ((NavMeshHit)(ref val2)).hit;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void SamplePositionsInDonutShape(Vector3 center, List<Vector3> sampledPositions, float outerRadius = 10f, float innerRadius = 10f, int numRings = 1, int itemsPerRing = 8)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SamplePositionsInDonutShape", 0);
		try
		{
			for (int i = 0; i < numRings; i++)
			{
				float num = ((numRings != 1) ? Mathf.Lerp(innerRadius, outerRadius, (float)i / (float)(numRings - 1)) : outerRadius);
				for (int j = 0; j < itemsPerRing; j++)
				{
					float num2 = (float)i * MathF.PI / (float)numRings;
					float num3 = MathF.PI * 2f * (float)j / (float)itemsPerRing + num2;
					Vector3 item = center + new Vector3(Mathf.Cos(num3), 0f, Mathf.Sin(num3)) * num;
					sampledPositions.Add(item);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool CalculatePathCustom(Vector3 destination, NavMeshPath path)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("CalculatePathCustom", 0);
		try
		{
			return agent.CalculatePath(destination, path);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetFirstReachablePoint(List<Vector3> points, ref NavMeshPath navPath, bool restrictTerrain, bool restrictWater)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetFirstReachablePoint", 0);
		try
		{
			foreach (Vector3 point in points)
			{
				if (!SamplePosition(point, out var sample, 10f) || (restrictTerrain && !IsPositionOnValidTerrain(sample)) || (restrictWater && !IsAcceptableWaterDepth(base.baseEntity, sample)))
				{
					continue;
				}
				if (CalculatePathCustom(sample, navPath))
				{
					if ((int)navPath.status == 0)
					{
						return true;
					}
				}
				else
				{
					ShowFailedPath(sample, navPath);
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsPositionAtTopologyRequirement(BaseEntity baseEntity, Vector3 position, Enum topologyRequirement)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionAtTopologyRequirement", 0);
		try
		{
			if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
			{
				return false;
			}
			Enum val2 = (Enum)TerrainMeta.TopologyMap.GetTopology(position);
			if ((topologyRequirement & val2) == 0)
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsPositionABiomeRequirement(BaseEntity baseEntity, Vector3 position, Enum biomeRequirement)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionABiomeRequirement", 0);
		try
		{
			if ((int)biomeRequirement == 0)
			{
				return true;
			}
			if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
			{
				return false;
			}
			Enum val2 = (Enum)TerrainMeta.BiomeMap.GetBiomeMaxType(position);
			if ((biomeRequirement & val2) == 0)
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsAcceptableWaterDepth(BaseEntity baseEntity, Vector3 position, float maxDepth = 0.1f)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsAcceptableWaterDepth", 0);
		try
		{
			if (WaterLevel.GetOverallWaterDepth(position, waves: false, volumes: false) > maxDepth)
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public enum Speeds
{
	Sneak,
	Walk,
	Jog,
	Run,
	Sprint,
	FullSprint
}


using System;
using UnityEngine;
using UnityEngine.AI;

public static class NavMeshPathEx
{
	private static Vector3[] cornersBuffer = (Vector3[])(object)new Vector3[128];

	public static float GetPathLength(this NavMeshPath path)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetPathLength", 0);
		try
		{
			float num = 0f;
			int cornersNonAlloc = path.GetCornersNonAlloc(cornersBuffer);
			if (cornersNonAlloc < 2)
			{
				return num;
			}
			for (int i = 0; i < cornersNonAlloc - 1; i++)
			{
				num += Vector3.Distance(cornersBuffer[i], cornersBuffer[i + 1]);
			}
			return num;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetOrigin(this NavMeshPath path)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetOrigin", 0);
		try
		{
			if (path.GetCornersNonAlloc(cornersBuffer) < 1)
			{
				return Vector3.zero;
			}
			return cornersBuffer[0];
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetDestination(this NavMeshPath path)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetDestination", 0);
		try
		{
			int cornersNonAlloc = path.GetCornersNonAlloc(cornersBuffer);
			if (cornersNonAlloc < 1)
			{
				return Vector3.zero;
			}
			return cornersBuffer[cornersNonAlloc - 1];
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using UnityEngine;

public class BaseNPC2 : BaseCombatEntity
{
	[SerializeField]
	private float mass = 45f;

	public override bool IsNpc => true;

	public bool IsAnimal => true;

	public override float RealisticMass => mass;

	public override float MaxVelocity()
	{
		return 10f;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

[SoftRequireComponent(typeof(SenseComponent))]
public class NPCEncounterTimer : EntityComponent<BaseEntity>, IServerComponent
{
	[NonSerialized]
	public UnityEvent onShouldGiveUp = new UnityEvent();

	private const float giveUpDurationSeconds = 120f;

	private const float fireTimeMultiplier = 4f;

	private const float mountedTimeMultiplier = 12f;

	private float? encounterRemainingTimeSeconds;

	private double? _lastTickTime;

	private SenseComponent _senseComponent;

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	private SenseComponent Senses => _senseComponent ?? (_senseComponent = ((Component)base.baseEntity).GetComponent<SenseComponent>());

	public void Tick()
	{
		float num = (float)(Time.timeAsDouble - LastTickTime);
		LastTickTime = Time.timeAsDouble;
		BaseEntity target;
		bool flag = Senses.FindTarget(out target);
		if (encounterRemainingTimeSeconds.HasValue && !flag)
		{
			encounterRemainingTimeSeconds = null;
		}
		else if (!encounterRemainingTimeSeconds.HasValue && flag)
		{
			StartTimer();
		}
		else
		{
			if (!encounterRemainingTimeSeconds.HasValue)
			{
				return;
			}
			if (base.baseEntity is BaseCombatEntity { SecondsSinceAttacked: <5f })
			{
				StartTimer();
				PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					Senses.GetInitialAllies((List<BaseEntity>)(object)val);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val)
					{
						((Component)item).GetComponent<NPCEncounterTimer>().StartTimer();
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			float num2 = 1f;
			if (target.ToNonNpcPlayer(out var player) && player.isMounted)
			{
				num2 = 12f;
			}
			else if (Trans_TargetIsNearFire.Test(base.baseEntity, Senses))
			{
				num2 = 4f;
			}
			encounterRemainingTimeSeconds -= num * num2;
			if (!(encounterRemainingTimeSeconds <= 0f))
			{
				return;
			}
			GiveUp();
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				Senses.GetInitialAllies((List<BaseEntity>)(object)val2);
				foreach (BaseEntity item2 in (List<BaseEntity>)(object)val2)
				{
					((Component)item2).GetComponent<NPCEncounterTimer>().GiveUp();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
	}

	private void StartTimer()
	{
		encounterRemainingTimeSeconds = 120f;
	}

	private void GiveUp()
	{
		if (encounterRemainingTimeSeconds.HasValue)
		{
			encounterRemainingTimeSeconds = null;
			onShouldGiveUp.Invoke();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using Rust.Ai;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class SenseComponent : EntityComponent<BaseEntity>, IServerComponent
{
	[Serializable]
	public struct Cone
	{
		public float halfAngle;

		public float range;

		public Cone(float halfAngle = 80f, float range = 10f)
		{
			this.halfAngle = halfAngle;
			this.range = range;
		}
	}

	public class VisibilityStatus : IPooled
	{
		public Vector3 position;

		public bool isVisible;

		public double lastTimeVisibleChanged;

		public void UpdateVisibility(bool isNowVisible, Vector3? position = null)
		{
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			if (isVisible != isNowVisible)
			{
				lastTimeVisibleChanged = Time.timeAsDouble;
				isVisible = isNowVisible;
			}
			if (position.HasValue)
			{
				this.position = position.Value;
			}
		}

		public float GetTimeSeen()
		{
			if (!isVisible)
			{
				return 0f;
			}
			return (float)(Time.timeAsDouble - lastTimeVisibleChanged);
		}

		public float GetTimeNotSeen()
		{
			if (isVisible)
			{
				return 0f;
			}
			return (float)(Time.timeAsDouble - lastTimeVisibleChanged);
		}

		public void EnterPool()
		{
		}

		public void LeavePool()
		{
			isVisible = true;
			lastTimeVisibleChanged = Time.timeAsDouble;
		}
	}

	private readonly struct DistanceCache
	{
		public readonly float distanceToTargetSq;

		public readonly int lastFrameDistanceUpdated;

		public readonly BaseEntity target;

		public DistanceCache(BaseEntity self, BaseEntity target)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			this.target = target;
			distanceToTargetSq = Vector3.SqrMagnitude(((Component)target).transform.position - ((Component)self).transform.position);
			lastFrameDistanceUpdated = Time.frameCount;
		}

		public bool IsCacheStale(BaseEntity currentTarget)
		{
			if (lastFrameDistanceUpdated == Time.frameCount)
			{
				return (Object)(object)target != (Object)(object)currentTarget;
			}
			return true;
		}
	}

	[SerializeField]
	private Vector3 LongRangeVisionRectangle = new Vector3(6f, 30f, 60f);

	[SerializeField]
	private Cone ShortRangeVisionCone = new Cone(100f, 30f);

	[SerializeField]
	private float touchDistance = 6f;

	[SerializeField]
	private float hearingMultiplier = 1f;

	[NonSerialized]
	public ResettableFloat timeToForgetSightings = new ResettableFloat(30f);

	private const float timeToForgetNoises = 5f;

	private static HashSet<BaseEntity> entitiesUpdatedThisFrame = new HashSet<BaseEntity>();

	[ServerVar]
	public static float minRefreshIntervalSeconds = 0.2f;

	[ServerVar]
	public static float maxRefreshIntervalSeconds = 1f;

	private double? _lastTickTime;

	private double nextRefreshTime;

	private double spawnTime;

	private Dictionary<BaseEntity, double> _alliesWeAreAwareOf = new Dictionary<BaseEntity, double>(3);

	private Dictionary<BaseEntity, VisibilityStatus> entitiesWeAreAwareOf = new Dictionary<BaseEntity, VisibilityStatus>(8);

	private static readonly Dictionary<NpcNoiseIntensity, float> noiseRadii = new Dictionary<NpcNoiseIntensity, float>
	{
		{
			NpcNoiseIntensity.None,
			0f
		},
		{
			NpcNoiseIntensity.Low,
			10f
		},
		{
			NpcNoiseIntensity.Medium,
			50f
		},
		{
			NpcNoiseIntensity.High,
			100f
		}
	};

	private NpcNoiseEvent _currentNoise;

	[SerializeField]
	private float foodDetectionRange = 30f;

	private BaseEntity _nearestFood;

	[SerializeField]
	private float fireDetectionRange = 20f;

	[NonSerialized]
	public UnityEvent onFireMelee = new UnityEvent();

	private BaseEntity _nearestFire;

	private double? lastMeleeTime;

	[SerializeField]
	private float TargetingCooldown = 5f;

	private const float npcDistPenaltyToFavorTargetingPlayers = 10f;

	private BaseEntity _target;

	private double? lastTargetTime;

	private LockState lockState = new LockState();

	private DistanceCache? distanceCache;

	public float RefreshInterval
	{
		get
		{
			if (!ShouldRefreshFast)
			{
				return maxRefreshIntervalSeconds;
			}
			return minRefreshIntervalSeconds;
		}
	}

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	public bool HasPlayerInVicinity { get; private set; }

	public bool ShouldRefreshFast
	{
		get
		{
			if (!HasPlayerInVicinity)
			{
				if ((Object)(object)_target != (Object)null)
				{
					return _target.IsNonNpcPlayer();
				}
				return false;
			}
			return true;
		}
	}

	public NpcNoiseEvent currentNoise => _currentNoise;

	private bool ChangedTargetRecently
	{
		get
		{
			if (lastTargetTime.HasValue)
			{
				return Time.timeAsDouble - lastTargetTime.Value < (double)TargetingCooldown;
			}
			return true;
		}
	}

	public void GetInitialAllies(List<BaseEntity> allies)
	{
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			foreach (var (baseEntity2, num2) in _alliesWeAreAwareOf)
			{
				if (!baseEntity2.IsValid() || (baseEntity2 is BaseCombatEntity baseCombatEntity && baseCombatEntity.IsDead()))
				{
					((List<BaseEntity>)(object)val).Add(baseEntity2);
				}
				else if (!(num2 - spawnTime > (double)(maxRefreshIntervalSeconds * 2f)))
				{
					allies.Add(baseEntity2);
				}
			}
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				_alliesWeAreAwareOf.Remove(item);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Vector3? GetLKP(BaseEntity entity)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (GetVisibilityStatus(entity, out var status))
		{
			return status.isVisible ? ((Component)entity).transform.position : status.position;
		}
		return null;
	}

	public bool GetVisibilityStatus(BaseEntity entity, out VisibilityStatus status)
	{
		status = null;
		if (!CanTarget(entity))
		{
			return false;
		}
		if (!entitiesWeAreAwareOf.TryGetValue(entity, out status))
		{
			return false;
		}
		return true;
	}

	public bool Forget(BaseEntity entity)
	{
		if (!entitiesWeAreAwareOf.TryGetValue(entity, out var value))
		{
			return false;
		}
		entitiesWeAreAwareOf.Remove(entity);
		Pool.Free<VisibilityStatus>(ref value);
		return true;
	}

	public bool IsVisible(BaseEntity entity)
	{
		if (!GetVisibilityStatus(entity, out var status))
		{
			return false;
		}
		return status.isVisible;
	}

	public void GetSeenEntities(List<BaseEntity> perceivedEntities)
	{
		TimeWarning val = TimeWarning.New("SenseComponent:GetSeenEntities", 0);
		try
		{
			foreach (BaseEntity key in entitiesWeAreAwareOf.Keys)
			{
				if (IsVisible(key))
				{
					perceivedEntities.Add(key);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetOncePerceivedEntities(List<BaseEntity> perceivedEntities)
	{
		foreach (BaseEntity key in entitiesWeAreAwareOf.Keys)
		{
			if (GetVisibilityStatus(key, out var _))
			{
				perceivedEntities.Add(key);
			}
		}
	}

	private Matrix4x4 GetEyeTransform()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		return Matrix4x4.TRS(base.baseEntity.CenterPoint(), ((Component)base.baseEntity).transform.rotation, Vector3.one);
	}

	public override void InitShared()
	{
		base.InitShared();
		spawnTime = Time.timeAsDouble;
	}

	public void Tick()
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:Tick", 0);
		try
		{
			double timeAsDouble = Time.timeAsDouble;
			if (timeAsDouble < nextRefreshTime)
			{
				return;
			}
			float deltaTime = (float)(timeAsDouble - LastTickTime);
			LastTickTime = timeAsDouble;
			HasPlayerInVicinity = false;
			entitiesUpdatedThisFrame.Clear();
			TimeWarning val2 = TimeWarning.New("SenseComponent:Tick:ProcessEntities", 0);
			try
			{
				PooledList<BaseEntity> val3 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					BaseEntity.Query.Server.GetPlayersAndBrainsInSphere(((Component)base.baseEntity).transform.position, LongRangeVisionRectangle.z, (List<BaseEntity>)(object)val3, BaseEntity.Query.DistanceCheckType.None);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val3)
					{
						if (!((Object)(object)item == (Object)(object)base.baseEntity))
						{
							if (item.IsNonNpcPlayer())
							{
								HasPlayerInVicinity = true;
							}
							if (base.baseEntity.InSameNpcTeam(item) && !_alliesWeAreAwareOf.ContainsKey(item))
							{
								_alliesWeAreAwareOf.Add(item, timeAsDouble);
							}
							if (CanTarget(item))
							{
								ProcessEntity(item);
							}
						}
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			TimeWarning val4 = TimeWarning.New("SenseComponent:Tick:RemoveEntities", 0);
			try
			{
				PooledList<BaseEntity> val5 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					foreach (var (baseEntity2, visibilityStatus2) in entitiesWeAreAwareOf)
					{
						if (!CanTarget(baseEntity2))
						{
							((List<BaseEntity>)(object)val5).Add(baseEntity2);
						}
						else if (!visibilityStatus2.isVisible && visibilityStatus2.GetTimeNotSeen() > timeToForgetSightings.Value)
						{
							((List<BaseEntity>)(object)val5).Add(baseEntity2);
						}
						else if (!entitiesUpdatedThisFrame.Contains(baseEntity2) && visibilityStatus2.isVisible)
						{
							entitiesWeAreAwareOf[baseEntity2].UpdateVisibility(isNowVisible: false, null);
						}
					}
					entitiesUpdatedThisFrame.Clear();
					foreach (BaseEntity item2 in (List<BaseEntity>)(object)val5)
					{
						if (_target.IsValid() && (Object)(object)_target == (Object)(object)item2)
						{
							ClearTarget();
						}
						Forget(item2);
					}
				}
				finally
				{
					((IDisposable)val5)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
			TickHearing(deltaTime);
			TickFoodDetection(deltaTime);
			TickFireDetection(deltaTime);
			TickTargeting(deltaTime);
			nextRefreshTime = Time.timeAsDouble + (double)RefreshInterval;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void GetModifiedSenses(BaseEntity entity, out float modTouchDistance, out float modHalfAngle, out float modShortVisionRange, out Vector3 modLongVisionRectangle)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		modTouchDistance = touchDistance;
		modHalfAngle = ShortRangeVisionCone.halfAngle;
		modShortVisionRange = ShortRangeVisionCone.range;
		modLongVisionRectangle = LongRangeVisionRectangle;
		if (entity.ToNonNpcPlayer(out var player))
		{
			if (player.IsDucked())
			{
				modTouchDistance = ((Bounds)(ref base.baseEntity.bounds)).extents.z * 1.5f;
				modHalfAngle = ShortRangeVisionCone.halfAngle * 0.85f;
				modShortVisionRange = ShortRangeVisionCone.range * 0.5f;
				modLongVisionRectangle = Vector3.Scale(LongRangeVisionRectangle, new Vector3(3f, 0.5f, 0.5f));
			}
			else if (player.IsRunning())
			{
				modTouchDistance = touchDistance * 3f;
				modHalfAngle = ShortRangeVisionCone.halfAngle;
				modShortVisionRange = ShortRangeVisionCone.range * 1.3f;
				modLongVisionRectangle = LongRangeVisionRectangle * 1.15f;
			}
		}
	}

	private bool IsInAnyRange(BaseEntity entity)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsInAnyRange", 0);
		try
		{
			Matrix4x4 eyeTransform = GetEyeTransform();
			Vector3 position = ((Matrix4x4)(ref eyeTransform)).GetPosition();
			eyeTransform = GetEyeTransform();
			Vector3 val2 = ((Matrix4x4)(ref eyeTransform)).rotation * Vector3.forward;
			Vector3 val3 = ((Component)entity).transform.position - position;
			float magnitude = ((Vector3)(ref val3)).magnitude;
			GetModifiedSenses(entity, out var modTouchDistance, out var modHalfAngle, out var modShortVisionRange, out var modLongVisionRectangle);
			if (magnitude < modTouchDistance)
			{
				return true;
			}
			if (Vector3.Angle(val2, ((Vector3)(ref val3)).normalized) < modHalfAngle)
			{
				if (magnitude < modShortVisionRange)
				{
					return true;
				}
				if (TOD_Sky.Instance.IsDay && magnitude < modLongVisionRectangle.z && Mathf.Abs(((Component)entity).transform.position.y - position.y) < modLongVisionRectangle.y * 0.5f)
				{
					Vector3 val4 = Vector3.Cross(val2, ((Component)entity).transform.position - position);
					if (((Vector3)(ref val4)).magnitude < modLongVisionRectangle.x * 0.5f)
					{
						return true;
					}
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ProcessEntity(BaseEntity entity)
	{
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		bool flag = IsInAnyRange(entity);
		if (flag && entity.ToNonNpcPlayer(out var player))
		{
			TimeWarning val = TimeWarning.New("SenseComponent:ProcessEntity:CanSee", 0);
			try
			{
				Matrix4x4 eyeTransform = GetEyeTransform();
				Vector3 position = ((Matrix4x4)(ref eyeTransform)).GetPosition();
				flag = base.baseEntity.CanSee(position, player.eyes.position);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (entitiesWeAreAwareOf.TryGetValue(entity, out var value))
		{
			value.UpdateVisibility(flag, flag ? new Vector3?(((Component)entity).transform.position) : ((Vector3?)null));
			entitiesUpdatedThisFrame.Add(entity);
		}
		else if (flag)
		{
			VisibilityStatus visibilityStatus = Pool.Get<VisibilityStatus>();
			visibilityStatus.position = ((Component)entity).transform.position;
			entitiesWeAreAwareOf.Add(entity, visibilityStatus);
			entitiesUpdatedThisFrame.Add(entity);
		}
	}

	private void TickHearing(float deltaTime)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickHearing", 0);
		try
		{
			if (_currentNoise != null)
			{
				Pool.Free<NpcNoiseEvent>(ref _currentNoise);
			}
			if (hearingMultiplier <= 0f)
			{
				return;
			}
			PooledList<NpcNoiseEvent> val2 = Pool.Get<PooledList<NpcNoiseEvent>>();
			try
			{
				SingletonComponent<NpcNoiseManager>.Instance.GetNoisesAround(((Component)base.baseEntity).transform.position, noiseRadii[NpcNoiseIntensity.High] * hearingMultiplier, (List<NpcNoiseEvent>)(object)val2);
				NpcNoiseEvent npcNoiseEvent = null;
				foreach (NpcNoiseEvent item in (List<NpcNoiseEvent>)(object)val2)
				{
					if ((Object)(object)item.Initiator == (Object)(object)base.baseEntity || Time.timeAsDouble - item.EventTime > 5.0 || (npcNoiseEvent != null && item.Intensity < npcNoiseEvent.Intensity))
					{
						continue;
					}
					if (!noiseRadii.TryGetValue(item.Intensity, out var value))
					{
						Debug.LogError((object)$"Unknown noise intensity: {item.Intensity}");
						continue;
					}
					float num = Vector3.Distance(item.Position, ((Component)base.baseEntity).transform.position);
					if (!(num > value * hearingMultiplier) && (npcNoiseEvent == null || item.Intensity != npcNoiseEvent.Intensity || !(num > Vector3.Distance(npcNoiseEvent.Position, ((Component)base.baseEntity).transform.position))))
					{
						npcNoiseEvent = item;
					}
				}
				if (npcNoiseEvent != null)
				{
					_currentNoise = Pool.Get<NpcNoiseEvent>();
					_currentNoise.Initiator = npcNoiseEvent.Initiator;
					_currentNoise.Position = npcNoiseEvent.Position;
					_currentNoise.Intensity = npcNoiseEvent.Intensity;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool ConsumeCurrentNoise()
	{
		if (_currentNoise == null)
		{
			return false;
		}
		Pool.Free<NpcNoiseEvent>(ref _currentNoise);
		return true;
	}

	public bool FindFood(out BaseEntity food)
	{
		if ((Object)(object)_nearestFood == (Object)null || _nearestFood.IsDestroyed)
		{
			food = null;
			return false;
		}
		food = _nearestFood;
		return true;
	}

	private void TickFoodDetection(float deltaTime)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickFoodDetection", 0);
		try
		{
			_nearestFood = null;
			if (foodDetectionRange <= 0f)
			{
				return;
			}
			float num = foodDetectionRange * foodDetectionRange;
			float num2 = float.MaxValue;
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				SingletonComponent<NpcFoodManager>.Instance.GetFoodAround(((Component)base.baseEntity).transform.position, foodDetectionRange, (List<BaseEntity>)(object)val2);
				LimitedTurnNavAgent component = ((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>();
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (!NpcFoodManager.IsFoodImmobile(item))
					{
						continue;
					}
					if (!component.IsPositionOnNavmesh(((Component)item).transform.position, out var sample))
					{
						SingletonComponent<NpcFoodManager>.Instance.Remove(item);
						continue;
					}
					sample = ((Component)item).transform.position - ((Component)base.baseEntity).transform.position;
					float sqrMagnitude = ((Vector3)(ref sample)).sqrMagnitude;
					if (sqrMagnitude < num2 && sqrMagnitude < num)
					{
						_nearestFood = item;
						num2 = sqrMagnitude;
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool FindFire(out BaseEntity fire)
	{
		if (!_nearestFire.IsValid() || _nearestFire.IsDestroyed || !NpcFireManager.IsOnFire(_nearestFire))
		{
			_nearestFire = null;
		}
		fire = _nearestFire;
		return (Object)(object)fire != (Object)null;
	}

	private void TickFireDetection(float deltaTime)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickFireDetection", 0);
		try
		{
			if (fireDetectionRange <= 0f)
			{
				return;
			}
			if ((Object)(object)_target != (Object)null && SingletonComponent<NpcFireManager>.Instance.DidMeleeWithFireRecently(base.baseEntity, _target, out var meleeTime) && (!lastMeleeTime.HasValue || meleeTime != lastMeleeTime.Value))
			{
				lastMeleeTime = meleeTime;
				onFireMelee.Invoke();
			}
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				SingletonComponent<NpcFireManager>.Instance.GetFiresAround(((Component)base.baseEntity).transform.position, fireDetectionRange, (List<BaseEntity>)(object)val2);
				BaseEntity baseEntity = null;
				float num = fireDetectionRange * fireDetectionRange;
				float num2 = float.MaxValue;
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					Vector3 val3 = ((Component)item).transform.position - ((Component)base.baseEntity).transform.position;
					float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
					if (sqrMagnitude < num2 && sqrMagnitude < num)
					{
						baseEntity = item;
						num2 = sqrMagnitude;
					}
				}
				if ((Object)(object)baseEntity != (Object)null)
				{
					_nearestFire = baseEntity;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public LockState.LockHandle LockCurrentTarget()
	{
		return lockState.AddLock();
	}

	public bool UnlockTarget(ref LockState.LockHandle handle)
	{
		return lockState.RemoveLock(ref handle);
	}

	public bool CanTarget(BaseEntity entity)
	{
		if (!entity.IsValid())
		{
			return false;
		}
		if (entity.IsTransferProtected())
		{
			return false;
		}
		if (entity.IsDestroyed)
		{
			return false;
		}
		if (!entity.IsNonNpcPlayer() && !entity.IsNpc)
		{
			return false;
		}
		if (entity.IsNpcPlayer())
		{
			return false;
		}
		if (entity is BaseCombatEntity baseCombatEntity && baseCombatEntity.IsDead())
		{
			return false;
		}
		if (base.baseEntity.InSameNpcTeam(entity))
		{
			return false;
		}
		if (entity is BasePlayer item)
		{
			if (AI.ignoreplayers)
			{
				return false;
			}
			if (SimpleAIMemory.PlayerIgnoreList.Contains(item))
			{
				return false;
			}
		}
		object obj = Interface.CallHook("IOnNpcTarget", (object)this, (object)entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public bool FindTarget(out BaseEntity target)
	{
		if (!CanTarget(_target))
		{
			ClearTarget();
			target = null;
			return false;
		}
		target = _target;
		return (Object)(object)target != (Object)null;
	}

	public bool FindTargetPosition(out Vector3 targetPosition)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!FindTarget(out var target))
		{
			targetPosition = Vector3.zero;
			return false;
		}
		targetPosition = ((Component)target).transform.position;
		return true;
	}

	public bool TrySetTarget(BaseEntity newTarget, bool bypassCooldown = true)
	{
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		if (lockState.IsLocked)
		{
			return false;
		}
		if ((Object)(object)newTarget == (Object)null)
		{
			ClearTarget();
			return true;
		}
		if ((Object)(object)newTarget == (Object)(object)_target)
		{
			return true;
		}
		if (!CanTarget(newTarget))
		{
			return false;
		}
		if ((Object)(object)_target != (Object)null && !bypassCooldown && ChangedTargetRecently)
		{
			return false;
		}
		lastTargetTime = Time.timeAsDouble;
		_target = newTarget;
		base.baseEntity.ClientRPC<NetworkableId>(RpcTarget.NetworkGroup("CL_SetLookAtTarget"), _target.net.ID);
		return true;
	}

	public bool IsTargetInRange(float range)
	{
		return IsTargetInRangeSq(range * range);
	}

	public bool IsTargetInRangeSq(float rangeSq)
	{
		if ((Object)(object)_target == (Object)null)
		{
			return false;
		}
		if (!distanceCache.HasValue || distanceCache.Value.IsCacheStale(_target))
		{
			distanceCache = new DistanceCache(base.baseEntity, _target);
		}
		return distanceCache.Value.distanceToTargetSq < rangeSq;
	}

	public void ClearTarget(bool forget = true)
	{
		if (_target.IsValid())
		{
			if (forget)
			{
				Forget(_target);
			}
			lastTargetTime = null;
			_target = null;
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_ClearTarget"));
		}
	}

	private void TickTargeting(float deltaTime)
	{
		TimeWarning val = TimeWarning.New("SenseComponent:TickTargeting", 0);
		try
		{
			if ((Object)(object)_target != (Object)null && !CanTarget(_target))
			{
				ClearTarget();
			}
			if ((Object)(object)_target != (Object)null && ChangedTargetRecently)
			{
				return;
			}
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				GetOncePerceivedEntities((List<BaseEntity>)(object)val2);
				if (((List<BaseEntity>)(object)val2).Count == 0)
				{
					return;
				}
				BaseEntity baseEntity = null;
				float num = float.MaxValue;
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (CanTarget(item))
					{
						float num2 = base.baseEntity.SqrDistance(item);
						if (item.IsNpc)
						{
							num2 += 100f;
						}
						if (num2 < num)
						{
							num = num2;
							baseEntity = item;
						}
					}
				}
				if ((Object)(object)baseEntity != (Object)null)
				{
					TrySetTarget(baseEntity, bypassCooldown: false);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;

[Serializable]
public struct Cone
{
	public float halfAngle;

	public float range;

	public Cone(float halfAngle = 80f, float range = 10f)
	{
		this.halfAngle = halfAngle;
		this.range = range;
	}
}


using Facepunch;
using UnityEngine;

public class VisibilityStatus : IPooled
{
	public Vector3 position;

	public bool isVisible;

	public double lastTimeVisibleChanged;

	public void UpdateVisibility(bool isNowVisible, Vector3? position = null)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (isVisible != isNowVisible)
		{
			lastTimeVisibleChanged = Time.timeAsDouble;
			isVisible = isNowVisible;
		}
		if (position.HasValue)
		{
			this.position = position.Value;
		}
	}

	public float GetTimeSeen()
	{
		if (!isVisible)
		{
			return 0f;
		}
		return (float)(Time.timeAsDouble - lastTimeVisibleChanged);
	}

	public float GetTimeNotSeen()
	{
		if (isVisible)
		{
			return 0f;
		}
		return (float)(Time.timeAsDouble - lastTimeVisibleChanged);
	}

	public void EnterPool()
	{
	}

	public void LeavePool()
	{
		isVisible = true;
		lastTimeVisibleChanged = Time.timeAsDouble;
	}
}


using UnityEngine;

private readonly struct DistanceCache
{
	public readonly float distanceToTargetSq;

	public readonly int lastFrameDistanceUpdated;

	public readonly BaseEntity target;

	public DistanceCache(BaseEntity self, BaseEntity target)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		this.target = target;
		distanceToTargetSq = Vector3.SqrMagnitude(((Component)target).transform.position - ((Component)self).transform.position);
		lastFrameDistanceUpdated = Time.frameCount;
	}

	public bool IsCacheStale(BaseEntity currentTarget)
	{
		if (lastFrameDistanceUpdated == Time.frameCount)
		{
			return (Object)(object)target != (Object)(object)currentTarget;
		}
		return true;
	}
}


using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine.Assertions;

public class LockState
{
	public class LockHandle
	{
	}

	private HashSet<LockHandle> locks = new HashSet<LockHandle>();

	public bool IsLocked => locks.Count > 0;

	public LockHandle AddLock()
	{
		LockHandle lockHandle = Pool.Get<LockHandle>();
		locks.Add(lockHandle);
		return lockHandle;
	}

	public bool RemoveLock(ref LockHandle handle)
	{
		if (handle == null)
		{
			return false;
		}
		bool num = locks.Remove(handle);
		Assert.IsTrue(num, "Trying to remove a lock that doesn't exist");
		if (num)
		{
			Pool.FreeUnsafe<LockHandle>(ref handle);
		}
		return num;
	}
}


public class LockHandle
{
}


using UnityEngine;

public static class BaseEntityTargettingExtensions
{
	public static bool InSameNpcTeam(this BaseEntity entity, BaseEntity other)
	{
		if ((Object)(object)entity == (Object)null || (Object)(object)other == (Object)null)
		{
			return false;
		}
		return ((object)entity).GetType() == ((object)other).GetType();
	}

	public static bool IsNonNpcPlayer(this BaseEntity entity)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			return !basePlayer.IsNpc;
		}
		return false;
	}

	public static bool IsNpcPlayer(this BaseEntity entity)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			return basePlayer.IsNpc;
		}
		return false;
	}

	public static bool ToNonNpcPlayer(this BaseEntity entity, out BasePlayer player)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer == (Object)null || basePlayer.IsNpc)
		{
			player = null;
			return false;
		}
		player = basePlayer;
		return true;
	}
}


public static class PlayerMenuAnimation
{
	public enum Layers
	{
		Movement
	}

	public static class Groups
	{
	}
}


public enum Layers
{
	Movement
}


public static class Groups
{
}


using System;
using BasePlayerJobs;
using CompanionServer.Cameras;
using Facepunch.MarchingCubes;
using Facepunch.NativeMeshSimplification;
using Instancing;
using Rust.Water5;
using TerrainHeightMapJobs;
using TerrainTexturingJobs;
using TerrainTopologyMapJobs;
using TerrainWaterMapJobs;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.Jobs;
using WaterLevelJobs;

[DOTSCompilerGenerated]
internal class __JobReflectionRegistrationOutput__1221673671587648887
{
	public static void CreateJobReflectionData()
	{
		try
		{
			IJobExtensions.EarlyJobInit<FishShoal.FishCollisionGatherJob>();
			IJobExtensions.EarlyJobInit<FishShoal.FishCollisionProcessJob>();
			IJobParallelForExtensions.EarlyJobInit<FishShoal.FishUpdateJob>();
			IJobExtensions.EarlyJobInit<FishShoal.KillFish>();
			IJobParallelForTransformExtensions.EarlyJobInit<TransformLineRenderer.LineRendererUpdateJob>();
			IJobExtensions.EarlyJobInit<AddAndBlurSphereJob>();
			IJobForExtensions.EarlyJobInit<BoxBlur3DJob>();
			IJobExtensions.EarlyJobInit<BoxBlurCylinderJob>();
			IJobExtensions.EarlyJobInit<BoxBlurSphereJob>();
			IJobExtensions.EarlyJobInit<CarveAndBlurCylinderJob>();
			IJobExtensions.EarlyJobInit<CarveAndBlurSphereJob>();
			IJobExtensions.EarlyJobInit<CleanFloatingIslandsJob>();
			IJobParallelForExtensions.EarlyJobInit<Hopper.FillRaycastJob>();
			IJobExtensions.EarlyJobInit<CalculatePathBetweenGridsJob>();
			IJobExtensions.EarlyJobInit<CoarseQueryGridPosRadJob>();
			IJobExtensions.EarlyJobInit<CoarseQueryGridPosRadBatchJobIndirect>();
			IJobExtensions.EarlyJobInit<CoarseQueryGridBoundsJob>();
			IJobExtensions.EarlyJobInit<CoarseQueryGridBoundsJobIndirect>();
			IJobExtensions.EarlyJobInit<CoarseQueryGridRayJob>();
			IJobExtensions.EarlyJobInit<PostCullingJob>();
			IJobExtensions.EarlyJobInit<RaycastSamplePositionsJob>();
			IJobExtensions.EarlyJobInit<RaycastBufferSetupJob>();
			IJobParallelForExtensions.EarlyJobInit<RaycastRaySetupJob>();
			IJobParallelForExtensions.EarlyJobInit<RaycastRayProcessingJob>();
			IJobExtensions.EarlyJobInit<RaycastOutputCompressJob>();
			IJobExtensions.EarlyJobInit<RaycastColliderProcessingJob>();
			IJobExtensions.EarlyJobInit<PreCullingJob>();
			IJobExtensions.EarlyJobInit<GetCoarseDistsToShoreJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightByPosJob>();
			IJobExtensions.EarlyJobInit<GetHeightByUVJob>();
			IJobExtensions.EarlyJobInit<GetHeightByUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightByIndexJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByPosJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByUVJob>();
			IJobExtensions.EarlyJobInit<GetTopologyRadiusJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GetTopologyByIndexJob>();
			IJobExtensions.EarlyJobInit<GetHeightsFastJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightsJob>();
			IJobExtensions.EarlyJobInit<TerrainHeightMapJobs.GetHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<ToUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherWavesIndicesJobIndirect>();
			IJobExtensions.EarlyJobInit<ApplyMaxHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<FillFloatJob>();
			IJobExtensions.EarlyJobInit<FillIntJob>();
			IJobExtensions.EarlyJobInit<SelectMaxWaterLevelJobIndirect>();
			IJobExtensions.EarlyJobInit<CalcCenterJobIndirect>();
			IJobExtensions.EarlyJobInit<InitialValidateInfoJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherValidInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherInvalidInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<UpdateWaterHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<SetupHeadQueryJobIndirect>();
			IJobExtensions.EarlyJobInit<ApplyHeadQueryResultsJobIndirect>();
			IJobExtensions.EarlyJobInit<ResolveWaterInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<UpdateWaterCache>();
			IJobParallelForTransformExtensions.EarlyJobInit<RecacheTransforms>();
			IJobExtensions.EarlyJobInit<CalcWaterFactorsJobIndirect>();
			IJobExtensions.EarlyJobInit<GetWaterFactorsParamsJobIndirect>();
			IJobExtensions.EarlyJobInit<CopyBackJob>();
			IJobExtensions.EarlyJobInit<PopulateArraysJob>();
			IJobExtensions.EarlyJobInit<SimplifyMeshJob>();
			IJobParallelForExtensions.EarlyJobInit<BakePhysicsMeshesJob>();
			IJobExtensions.EarlyJobInit<CleanupDuplicateVerticesJob>();
			IJobExtensions.EarlyJobInit<MarchJob>();
			IJobExtensions.EarlyJobInit<GetHeightBatchedJob>();
			IJobExtensions.EarlyJobInit<Rust.Water5.GetHeightsJobIndirect>();
		}
		catch (Exception ex)
		{
			EarlyInitHelpers.JobReflectionDataCreationFailed(ex);
		}
	}

	[RuntimeInitializeOnLoadMethod(/*Could not decode attribute arguments.*/)]
	public static void EarlyInit()
	{
		CreateJobReflectionData();
	}
}


