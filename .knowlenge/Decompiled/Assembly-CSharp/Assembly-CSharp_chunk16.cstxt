using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

public class BufferSet
{
	public int width;

	public int height;

	public Texture2D inputTexture;

	public RenderTexture resultTexture;

	public Color[] inputData = (Color[])(object)new Color[0];

	public Color32[] resultData = (Color32[])(object)new Color32[0];

	private Material coverageMat;

	private const int MaxAsyncGPUReadbackRequests = 10;

	private Queue<AsyncGPUReadbackRequest> asyncRequests = new Queue<AsyncGPUReadbackRequest>();

	public void Attach(Material coverageMat)
	{
		this.coverageMat = coverageMat;
	}

	public void Dispose(bool data = true)
	{
		if ((Object)(object)inputTexture != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)inputTexture);
			inputTexture = null;
		}
		if ((Object)(object)resultTexture != (Object)null)
		{
			RenderTexture.active = null;
			resultTexture.Release();
			Object.DestroyImmediate((Object)(object)resultTexture);
			resultTexture = null;
		}
		if (data)
		{
			inputData = (Color[])(object)new Color[0];
			resultData = (Color32[])(object)new Color32[0];
		}
	}

	public bool CheckResize(int count)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Expected O, but got Unknown
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Expected O, but got Unknown
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		if (count > inputData.Length || ((Object)(object)resultTexture != (Object)null && !resultTexture.IsCreated()))
		{
			Dispose(data: false);
			width = Mathf.CeilToInt(Mathf.Sqrt((float)count));
			height = Mathf.CeilToInt((float)count / (float)width);
			inputTexture = new Texture2D(width, height, (TextureFormat)20, false, true);
			((Object)inputTexture).name = "_Input";
			((Texture)inputTexture).filterMode = (FilterMode)0;
			((Texture)inputTexture).wrapMode = (TextureWrapMode)1;
			resultTexture = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
			((Object)resultTexture).name = "_Result";
			((Texture)resultTexture).filterMode = (FilterMode)0;
			((Texture)resultTexture).wrapMode = (TextureWrapMode)1;
			resultTexture.useMipMap = false;
			resultTexture.Create();
			int num = resultData.Length;
			int num2 = width * height;
			Array.Resize(ref inputData, num2);
			Array.Resize(ref resultData, num2);
			Color32 val = default(Color32);
			((Color32)(ref val))..ctor(byte.MaxValue, (byte)0, (byte)0, (byte)0);
			for (int i = num; i < num2; i++)
			{
				resultData[i] = val;
			}
			return true;
		}
		return false;
	}

	public void UploadData()
	{
		if (inputData.Length != 0)
		{
			inputTexture.SetPixels(inputData);
			inputTexture.Apply();
		}
	}

	public void Dispatch(int count)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (inputData.Length != 0)
		{
			RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
			RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
			coverageMat.SetTexture("_Input", (Texture)(object)inputTexture);
			Graphics.Blit((Texture)(object)inputTexture, resultTexture, coverageMat, 0);
			Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
		}
	}

	public void IssueRead()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (asyncRequests.Count < 10)
		{
			asyncRequests.Enqueue(AsyncGPUReadback.Request((Texture)(object)resultTexture, 0, (Action<AsyncGPUReadbackRequest>)null));
		}
	}

	public void GetResults()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (resultData.Length == 0)
		{
			return;
		}
		while (asyncRequests.Count > 0)
		{
			AsyncGPUReadbackRequest val = asyncRequests.Peek();
			if (((AsyncGPUReadbackRequest)(ref val)).hasError)
			{
				asyncRequests.Dequeue();
				continue;
			}
			if (((AsyncGPUReadbackRequest)(ref val)).done)
			{
				NativeArray<Color32> data = ((AsyncGPUReadbackRequest)(ref val)).GetData<Color32>(0);
				for (int i = 0; i < data.Length; i++)
				{
					resultData[i] = data[i];
				}
				asyncRequests.Dequeue();
				continue;
			}
			break;
		}
	}
}


public enum RadiusSpace
{
	ScreenNormalized,
	World
}


using UnityEngine;

public class Query
{
	public struct Input
	{
		public Vector3 position;

		public RadiusSpace radiusSpace;

		public float radius;

		public int sampleCount;

		public float smoothingSpeed;
	}

	public struct Internal
	{
		public int id;

		public void Reset()
		{
			id = -1;
		}
	}

	public struct Result
	{
		public int passed;

		public float coverage;

		public float smoothCoverage;

		public float weightedCoverage;

		public float weightedSmoothCoverage;

		public bool originOccluded;

		public int frame;

		public float originVisibility;

		public float originSmoothVisibility;

		public void Reset()
		{
			passed = 0;
			coverage = 0f;
			smoothCoverage = 0f;
			weightedCoverage = 0f;
			weightedSmoothCoverage = 0f;
			originOccluded = true;
			frame = -1;
			originVisibility = 0f;
			originSmoothVisibility = 0f;
		}
	}

	public Input input;

	public Internal intern;

	public Result result;

	public bool IsRegistered => intern.id >= 0;
}


using UnityEngine;

public struct Input
{
	public Vector3 position;

	public RadiusSpace radiusSpace;

	public float radius;

	public int sampleCount;

	public float smoothingSpeed;
}


public struct Internal
{
	public int id;

	public void Reset()
	{
		id = -1;
	}
}


public struct Result
{
	public int passed;

	public float coverage;

	public float smoothCoverage;

	public float weightedCoverage;

	public float weightedSmoothCoverage;

	public bool originOccluded;

	public int frame;

	public float originVisibility;

	public float originSmoothVisibility;

	public void Reset()
	{
		passed = 0;
		coverage = 0f;
		smoothCoverage = 0f;
		weightedCoverage = 0f;
		weightedSmoothCoverage = 0f;
		originOccluded = true;
		frame = -1;
		originVisibility = 0f;
		originSmoothVisibility = 0f;
	}
}


using EasyRoads3Dv3;
using UnityEngine;

public class ERVegetationStudio : ScriptableObject
{
	public static bool VegetationStudio()
	{
		return false;
	}

	public static bool VegetationStudioPro()
	{
		return false;
	}

	public static void CreateVegetationMaskLine(GameObject go, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter)
	{
	}

	public static void UpdateVegetationMaskLine(GameObject go, ERVSData[] vsData, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter)
	{
	}

	public static void UpdateHeightmap(Bounds bounds)
	{
	}

	public static void RemoveVegetationMaskLine(GameObject go)
	{
	}

	public static void CreateBiomeArea(GameObject go, float distance, float blendDistance, float noise)
	{
	}

	public static void UpdateBiomeArea(GameObject go, ERVSData[] vsData, float distance, float blendDistance, float noise)
	{
	}

	public static void RemoveBiomeArea(GameObject go)
	{
	}
}


using EasyRoads3Dv3;
using UnityEngine;

public class runtimeScript : MonoBehaviour
{
	public ERRoadNetwork roadNetwork;

	public ERRoad road;

	public GameObject go;

	public int currentElement;

	public float distance;

	public float speed = 5f;

	private void Start()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Expected O, but got Unknown
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Expected O, but got Unknown
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)"Please read the comments at the top of the runtime script (/Assets/EasyRoads3D/Scripts/runtimeScript) before using the runtime API!");
		roadNetwork = new ERRoadNetwork();
		ERRoadType val = new ERRoadType();
		val.roadWidth = 6f;
		ref Material roadMaterial = ref val.roadMaterial;
		Object obj = Resources.Load("Materials/roads/road material");
		roadMaterial = (Material)(object)((obj is Material) ? obj : null);
		val.layer = 1;
		val.tag = "Untagged";
		Vector3[] array = (Vector3[])(object)new Vector3[4]
		{
			new Vector3(200f, 5f, 200f),
			new Vector3(250f, 5f, 200f),
			new Vector3(250f, 5f, 250f),
			new Vector3(300f, 5f, 250f)
		};
		road = roadNetwork.CreateRoad("road 1", val, array);
		road.AddMarker(new Vector3(300f, 5f, 300f));
		road.InsertMarker(new Vector3(275f, 5f, 235f));
		road.DeleteMarker(2);
		roadNetwork.BuildRoadNetwork();
		go = GameObject.CreatePrimitive((PrimitiveType)3);
	}

	private void Update()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (roadNetwork != null)
		{
			float num = Time.deltaTime * speed;
			distance += num;
			Vector3 position = road.GetPosition(distance, ref currentElement);
			position.y += 1f;
			go.transform.position = position;
			go.transform.forward = road.GetLookatSmooth(distance, currentElement);
		}
	}

	private void OnDestroy()
	{
		if (roadNetwork != null && roadNetwork.isInBuildMode)
		{
			roadNetwork.RestoreRoadNetwork();
			Debug.Log((object)"Restore Road Network");
		}
	}
}


using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_Demo_RMCharacterController : FSimpleFitter
{
	protected FAnimationClips clips;

	protected Animator animator;

	private float gravity;

	protected override void Start()
	{
		base.Start();
		animator = ((Component)this).GetComponentInChildren<Animator>();
		clips = new FAnimationClips(animator);
		clips.AddClip("Idle");
		clips.AddClip("Walk");
		clips.AddClip("RotateL");
		clips.AddClip("RotateR");
	}

	public void Update()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)optionalCharContr))
		{
			if (optionalCharContr.isGrounded)
			{
				gravity = 0f;
			}
			else
			{
				gravity += Time.deltaTime * 10f;
				optionalCharContr.Move(Vector3.down * gravity * Time.deltaTime);
			}
		}
		if (Input.GetKey((KeyCode)97))
		{
			clips.CrossFade("RotateL");
		}
		else if (Input.GetKey((KeyCode)100))
		{
			clips.CrossFade("RotateR");
		}
		else if (Input.GetKey((KeyCode)119))
		{
			clips.CrossFade("Walk");
		}
		else
		{
			clips.CrossFade("Idle");
		}
	}
}


using System;
using UnityEngine;

public static class FEasing
{
	public enum EFease
	{
		EaseInCubic,
		EaseOutCubic,
		EaseInOutCubic,
		EaseInOutElastic,
		EaseInElastic,
		EaseOutElastic,
		EaseInExpo,
		EaseOutExpo,
		EaseInOutExpo,
		Linear
	}

	public delegate float Function(float s, float e, float v, float extraParameter = 1f);

	public static float EaseInCubic(float start, float end, float value, float ignore = 1f)
	{
		end -= start;
		return end * value * value * value + start;
	}

	public static float EaseOutCubic(float start, float end, float value, float ignore = 1f)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value + 1f) + start;
	}

	public static float EaseInOutCubic(float start, float end, float value, float ignore = 1f)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value + start;
		}
		value -= 2f;
		return end * 0.5f * (value * value * value + 2f) + start;
	}

	public static float EaseOutElastic(float start, float end, float value, float rangeMul = 1f)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f * rangeMul;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 * 0.25f * rangeMul;
		}
		else
		{
			num4 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num3);
		}
		return num3 * Mathf.Pow(2f, -10f * value * rangeMul) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2) + end + start;
	}

	public static float EaseInElastic(float start, float end, float value, float rangeMul = 1f)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f * rangeMul;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 / 4f * rangeMul;
		}
		else
		{
			num4 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num3);
		}
		return 0f - num3 * Mathf.Pow(2f, 10f * rangeMul * (value -= 1f)) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2) + start;
	}

	public static float EaseInOutElastic(float start, float end, float value, float rangeMul = 1f)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f * rangeMul;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num * 0.5f) == 2f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 / 4f * rangeMul;
		}
		else
		{
			num4 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num3);
		}
		if (value < 1f)
		{
			return -0.5f * (num3 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2)) + start;
		}
		return num3 * Mathf.Pow(2f, -10f * rangeMul * (value -= 1f)) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2) * 0.5f + end + start;
	}

	public static float EaseInExpo(float start, float end, float value, float ignore = 1f)
	{
		end -= start;
		return end * Mathf.Pow(2f, 10f * (value - 1f)) + start;
	}

	public static float EaseOutExpo(float start, float end, float value, float ignore = 1f)
	{
		end -= start;
		return end * (0f - Mathf.Pow(2f, -10f * value) + 1f) + start;
	}

	public static float EaseInOutExpo(float start, float end, float value, float ignore = 1f)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}
		value -= 1f;
		return end * 0.5f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
	}

	public static float Linear(float start, float end, float value, float ignore = 1f)
	{
		return Mathf.Lerp(start, end, value);
	}

	public static Function GetEasingFunction(EFease easingFunction)
	{
		return easingFunction switch
		{
			EFease.EaseInCubic => EaseInCubic, 
			EFease.EaseOutCubic => EaseOutCubic, 
			EFease.EaseInOutCubic => EaseInOutCubic, 
			EFease.EaseInElastic => EaseInElastic, 
			EFease.EaseOutElastic => EaseOutElastic, 
			EFease.EaseInOutElastic => EaseInOutElastic, 
			EFease.EaseInExpo => EaseInExpo, 
			EFease.EaseOutExpo => EaseOutExpo, 
			EFease.EaseInOutExpo => EaseInOutExpo, 
			EFease.Linear => Linear, 
			_ => null, 
		};
	}
}


public enum EFease
{
	EaseInCubic,
	EaseOutCubic,
	EaseInOutCubic,
	EaseInOutElastic,
	EaseInElastic,
	EaseOutElastic,
	EaseInExpo,
	EaseOutExpo,
	EaseInOutExpo,
	Linear
}


public delegate float Function(float s, float e, float v, float extraParameter = 1f);


using UnityEngine;

public class FHierarchyIcons
{
	static FHierarchyIcons()
	{
	}

	private static void EvaluateIcons(int instanceId, Rect selectionRect)
	{
	}

	private static void DrawIcon(string texName, Rect rect)
	{
	}

	private static Texture2D GetTex(string name)
	{
		return null;
	}
}


public interface IFHierarchyIcon
{
	string EditorIconPath { get; }
}


using System;
using UnityEngine;

public static class FSceneIcons
{
	public static void SetGizmoIconEnabled(MonoBehaviour beh, bool on)
	{
		if (!((Object)(object)beh == (Object)null))
		{
			SetGizmoIconEnabled(((object)beh).GetType(), on);
		}
	}

	public static void SetGizmoIconEnabled(Type type, bool on)
	{
	}
}


using UnityEngine;

public class FPD_FixedCurveWindowAttribute : PropertyAttribute
{
	public float StartTime;

	public float EndTime;

	public float StartValue;

	public float EndValue;

	public Color Color;

	public FPD_FixedCurveWindowAttribute(float startTime = 0f, float startValue = 0f, float endTime = 1f, float endValue = 1f, float r = 0f, float g = 1f, float b = 1f, float a = 1f)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		StartTime = startTime;
		StartValue = startValue;
		EndTime = endTime;
		EndValue = endValue;
		Color = new Color(r, g, b, a);
	}
}


using UnityEngine;

public class FPD_FoldableAttribute : PropertyAttribute
{
	public string FoldVariable;

	public FPD_FoldableAttribute(string boolFoldVariable)
	{
		FoldVariable = boolFoldVariable;
	}
}


using UnityEngine;

public class FPD_HeaderAttribute : PropertyAttribute
{
	public string HeaderText;

	public float UpperPadding;

	public float BottomPadding;

	public float Height;

	public FPD_HeaderAttribute(string headerText, float upperPadding = 6f, float bottomPadding = 4f, int addHeight = 2)
	{
		HeaderText = headerText;
		UpperPadding = upperPadding;
		BottomPadding = bottomPadding;
		Height = addHeight;
	}
}


using System;
using UnityEngine;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field, Inherited = true)]
public class FPD_HideOnBoolAttribute : PropertyAttribute
{
	public string BoolVarName = "";

	public bool HideInInspector;

	public FPD_HideOnBoolAttribute(string boolVariableName)
	{
		BoolVarName = boolVariableName;
		HideInInspector = false;
	}

	public FPD_HideOnBoolAttribute(string conditionalSourceField, bool hideInInspector)
	{
		BoolVarName = conditionalSourceField;
		HideInInspector = hideInInspector;
	}
}


using UnityEngine;

public class FPD_LayersAttribute : PropertyAttribute
{
}


using UnityEngine;

public class FPD_MinMaxSliderAttribute : PropertyAttribute
{
	public float MinValue = -60f;

	public float MaxValue = 60f;

	public FPD_MinMaxSliderAttribute(int min, int max)
	{
		MinValue = min;
		MaxValue = max;
	}
}


using UnityEngine;

public class FPD_OverridableFloatAttribute : PropertyAttribute
{
	public string BoolVarName;

	public string TargetVarName;

	public int LabelWidth;

	public FPD_OverridableFloatAttribute(string boolVariableName, string targetVariableName, int labelWidth = 90)
	{
		BoolVarName = boolVariableName;
		TargetVarName = targetVariableName;
		LabelWidth = labelWidth;
	}
}


using UnityEngine;

public class BackgroundColorAttribute : PropertyAttribute
{
	public float r;

	public float g;

	public float b;

	public float a;

	public Color Color => new Color(r, g, b, a);

	public BackgroundColorAttribute()
	{
		r = (g = (b = (a = 1f)));
	}

	public BackgroundColorAttribute(float aR, float aG, float aB, float aA)
	{
		r = aR;
		g = aG;
		b = aB;
		a = aA;
	}
}


using UnityEngine;

public class FPD_WidthAttribute : PropertyAttribute
{
	public float LabelWidth;

	public FPD_WidthAttribute(int labelWidth)
	{
		LabelWidth = labelWidth;
	}
}


using UnityEngine;

public class FPD_IndentAttribute : PropertyAttribute
{
	public int IndentCount = 1;

	public int LabelsWidth;

	public int SpaceAfter;

	public FPD_IndentAttribute(int indent = 1, int labelsWidth = 0, int spaceAfter = 0)
	{
		IndentCount = indent;
		LabelsWidth = labelsWidth;
		SpaceAfter = spaceAfter;
	}
}


using UnityEngine;

public class FPD_HorizontalLineAttribute : PropertyAttribute
{
	public Color color;

	public FPD_HorizontalLineAttribute(float r = 0.55f, float g = 0.55f, float b = 0.55f, float a = 0.7f)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		color = new Color(r, g, b, a);
	}
}


using UnityEngine;

public class FPD_PercentageAttribute : PropertyAttribute
{
	public enum SuffixMode
	{
		From0to100,
		PercentageUnclamped,
		FromMinToMax,
		FromMinToMaxRounded
	}

	public readonly float Min;

	public readonly float Max;

	public readonly string Suffix;

	public readonly bool from0to100;

	public readonly bool editableValue;

	public readonly bool basic;

	public FPD_PercentageAttribute(float min, float max, bool goOver100Perc = false, bool editable = true, string suffix = "%", bool basicFromTo = false)
	{
		Min = min;
		Max = max;
		from0to100 = !goOver100Perc;
		editableValue = editable;
		Suffix = suffix;
		basic = basicFromTo;
	}
}


public enum SuffixMode
{
	From0to100,
	PercentageUnclamped,
	FromMinToMax,
	FromMinToMaxRounded
}


using UnityEngine;

public class FPD_SuffixAttribute : PropertyAttribute
{
	public enum SuffixMode
	{
		From0to100,
		PercentageUnclamped,
		FromMinToMax,
		FromMinToMaxRounded
	}

	public readonly float Min;

	public readonly float Max;

	public readonly SuffixMode Mode;

	public readonly string Suffix;

	public readonly bool editableValue;

	public readonly int widerField;

	public FPD_SuffixAttribute(float min, float max, SuffixMode mode = SuffixMode.From0to100, string suffix = "%", bool editable = true, int wider = 0)
	{
		Min = min;
		Max = max;
		Mode = mode;
		Suffix = suffix;
		editableValue = editable;
		widerField = wider;
	}
}


public enum SuffixMode
{
	From0to100,
	PercentageUnclamped,
	FromMinToMax,
	FromMinToMaxRounded
}


using UnityEngine;

public class FPD_TabAttribute : PropertyAttribute
{
	public string HeaderText;

	public float R;

	public float G;

	public float B;

	public string IconContent;

	public string ResourcesIconPath;

	public int IconSize;

	public string FoldVariable;

	public FPD_TabAttribute(string headerText, float r = 0.5f, float g = 0.5f, float b = 1f, string iconContent = "", string resourcesIconPath = "", int iconSize = 24, string foldVariable = "")
	{
		HeaderText = headerText;
		R = r;
		G = g;
		B = b;
		IconContent = iconContent;
		ResourcesIconPath = resourcesIconPath;
		IconSize = iconSize;
		FoldVariable = foldVariable;
	}
}


using UnityEngine;

[AddComponentMenu("Image Effects/FXAA")]
public class FXAA : FXAAPostEffectsBase, IImageEffect
{
	public Shader shader;

	private Material mat;

	private void CreateMaterials()
	{
		if ((Object)(object)mat == (Object)null)
		{
			mat = CheckShaderAndCreateMaterial(shader, mat);
		}
	}

	private void Start()
	{
		CreateMaterials();
		CheckSupport(needDepth: false);
	}

	public bool IsActive()
	{
		return ((Behaviour)this).enabled;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		CreateMaterials();
		float num = 1f / (float)Screen.width;
		float num2 = 1f / (float)Screen.height;
		mat.SetVector("_rcpFrame", new Vector4(num, num2, 0f, 0f));
		mat.SetVector("_rcpFrameOpt", new Vector4(num * 2f, num2 * 2f, num * 0.5f, num2 * 0.5f));
		Graphics.Blit((Texture)(object)source, destination, mat);
	}
}


using UnityEngine;

public class FXAAPostEffectsBase : MonoBehaviour
{
	protected bool supportHDRTextures = true;

	protected bool isSupported = true;

	public Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Expected O, but got Unknown
		if (!Object.op_Implicit((Object)(object)s))
		{
			Debug.Log((object)("Missing shader in " + ((object)this).ToString()));
			((Behaviour)this).enabled = false;
			return null;
		}
		if (s.isSupported && Object.op_Implicit((Object)(object)m2Create) && (Object)(object)m2Create.shader == (Object)(object)s)
		{
			return m2Create;
		}
		if (!s.isSupported)
		{
			NotSupported();
			Debug.LogError((object)("The shader " + ((object)s).ToString() + " on effect " + ((object)this).ToString() + " is not supported on this platform!"));
			return null;
		}
		m2Create = new Material(s);
		((Object)m2Create).hideFlags = (HideFlags)52;
		if (Object.op_Implicit((Object)(object)m2Create))
		{
			return m2Create;
		}
		return null;
	}

	private Material CreateMaterial(Shader s, Material m2Create)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Expected O, but got Unknown
		if (!Object.op_Implicit((Object)(object)s))
		{
			Debug.Log((object)("Missing shader in " + ((object)this).ToString()));
			return null;
		}
		if (Object.op_Implicit((Object)(object)m2Create) && (Object)(object)m2Create.shader == (Object)(object)s && s.isSupported)
		{
			return m2Create;
		}
		if (!s.isSupported)
		{
			return null;
		}
		m2Create = new Material(s);
		((Object)m2Create).hideFlags = (HideFlags)52;
		if (Object.op_Implicit((Object)(object)m2Create))
		{
			return m2Create;
		}
		return null;
	}

	private void OnEnable()
	{
		isSupported = true;
	}

	private bool CheckSupport()
	{
		return CheckSupport(needDepth: false);
	}

	private bool CheckResources()
	{
		Debug.LogWarning((object)("CheckResources () for " + ((object)this).ToString() + " should be overwritten."));
		return isSupported;
	}

	private void Start()
	{
		CheckResources();
	}

	public bool CheckSupport(bool needDepth)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		isSupported = true;
		supportHDRTextures = SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)2);
		if (!SystemInfo.supportsImageEffects || !SystemInfo.supportsRenderTextures)
		{
			NotSupported();
			return false;
		}
		if (needDepth && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)1))
		{
			NotSupported();
			return false;
		}
		if (needDepth)
		{
			Camera component = ((Component)this).GetComponent<Camera>();
			component.depthTextureMode = (DepthTextureMode)(component.depthTextureMode | 1);
		}
		return true;
	}

	private bool CheckSupport(bool needDepth, bool needHdr)
	{
		if (!CheckSupport(needDepth))
		{
			return false;
		}
		if (needHdr && !supportHDRTextures)
		{
			NotSupported();
			return false;
		}
		return true;
	}

	private void ReportAutoDisable()
	{
		Debug.LogWarning((object)("The image effect " + ((object)this).ToString() + " has been disabled as it's not supported on the current platform."));
	}

	private bool CheckShader(Shader s)
	{
		Debug.Log((object)("The shader " + ((object)s).ToString() + " on effect " + ((object)this).ToString() + " is not part of the Unity 3.2+ effects suite anymore. For best performance and quality, please ensure you are using the latest Standard Assets Image Effects (Pro only) package."));
		if (!s.isSupported)
		{
			NotSupported();
			return false;
		}
		return false;
	}

	private void NotSupported()
	{
		((Behaviour)this).enabled = false;
		isSupported = false;
	}

	private void DrawBorder(RenderTexture dest, Material material)
	{
		RenderTexture.active = dest;
		bool flag = true;
		GL.PushMatrix();
		GL.LoadOrtho();
		for (int i = 0; i < material.passCount; i++)
		{
			material.SetPass(i);
			float num;
			float num2;
			if (flag)
			{
				num = 1f;
				num2 = 0f;
			}
			else
			{
				num = 0f;
				num2 = 1f;
			}
			float num3 = 0f + 1f / ((float)((Texture)dest).width * 1f);
			float num4 = 0f;
			float num5 = 1f;
			GL.Begin(7);
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			float num6 = 1f - 1f / ((float)((Texture)dest).width * 1f);
			num3 = 1f;
			num4 = 0f;
			num5 = 1f;
			GL.TexCoord2(0f, num);
			GL.Vertex3(num6, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(num6, num5, 0.1f);
			num3 = 1f;
			num4 = 0f;
			num5 = 0f + 1f / ((float)((Texture)dest).height * 1f);
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			num3 = 1f;
			num4 = 1f - 1f / ((float)((Texture)dest).height * 1f);
			num5 = 1f;
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			GL.End();
		}
		GL.PopMatrix();
	}
}


using System;
using UnityEngine;

[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
[ImageEffectAllowedInSceneView]
[AddComponentMenu("KriptoFX/Explosion_Bloom")]
public class Explosion_Bloom : MonoBehaviour
{
	[Serializable]
	public struct Settings
	{
		[Tooltip("Filters out pixels under this level of brightness.")]
		[SerializeField]
		public float threshold;

		[Tooltip("Makes transition between under/over-threshold gradual.")]
		[SerializeField]
		[Range(0f, 1f)]
		public float softKnee;

		[Range(1f, 7f)]
		[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
		[SerializeField]
		public float radius;

		[SerializeField]
		[Tooltip("Blend factor of the result image.")]
		public float intensity;

		[Tooltip("Controls filter quality and buffer resolution.")]
		[SerializeField]
		public bool highQuality;

		[Tooltip("Reduces flashing noise with an additional filter.")]
		[SerializeField]
		public bool antiFlicker;

		public float thresholdGamma
		{
			get
			{
				return Mathf.Max(0f, threshold);
			}
			set
			{
				threshold = value;
			}
		}

		public float thresholdLinear
		{
			get
			{
				return Mathf.GammaToLinearSpace(thresholdGamma);
			}
			set
			{
				threshold = Mathf.LinearToGammaSpace(value);
			}
		}

		public static Settings defaultSettings
		{
			get
			{
				Settings result = default(Settings);
				result.threshold = 2f;
				result.softKnee = 0f;
				result.radius = 7f;
				result.intensity = 0.7f;
				result.highQuality = true;
				result.antiFlicker = true;
				return result;
			}
		}
	}

	[SerializeField]
	public Settings settings = Settings.defaultSettings;

	[HideInInspector]
	[SerializeField]
	private Shader m_Shader;

	private Material m_Material;

	private const int kMaxIterations = 16;

	private RenderTexture[] m_blurBuffer1 = (RenderTexture[])(object)new RenderTexture[16];

	private RenderTexture[] m_blurBuffer2 = (RenderTexture[])(object)new RenderTexture[16];

	private int m_Threshold;

	private int m_Curve;

	private int m_PrefilterOffs;

	private int m_SampleScale;

	private int m_Intensity;

	private int m_BaseTex;

	public Shader shader
	{
		get
		{
			if ((Object)(object)m_Shader == (Object)null)
			{
				m_Shader = Shader.Find("Hidden/KriptoFX/PostEffects/Explosion_Bloom");
			}
			return m_Shader;
		}
	}

	public Material material
	{
		get
		{
			if ((Object)(object)m_Material == (Object)null)
			{
				m_Material = CheckShaderAndCreateMaterial(shader);
			}
			return m_Material;
		}
	}

	public static bool supportsDX11
	{
		get
		{
			if (SystemInfo.graphicsShaderLevel >= 50)
			{
				return SystemInfo.supportsComputeShaders;
			}
			return false;
		}
	}

	public static bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
	{
		if ((Object)(object)s == (Object)null || !s.isSupported)
		{
			Debug.LogWarningFormat("Missing shader for image effect {0}", new object[1] { effect });
			return false;
		}
		if (!SystemInfo.supportsImageEffects)
		{
			Debug.LogWarningFormat("Image effects aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		if (needDepth && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)1))
		{
			Debug.LogWarningFormat("Depth textures aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		if (needHdr && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)2))
		{
			Debug.LogWarningFormat("Floating point textures aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		return true;
	}

	public static Material CheckShaderAndCreateMaterial(Shader s)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected O, but got Unknown
		if ((Object)(object)s == (Object)null || !s.isSupported)
		{
			return null;
		}
		return new Material(s)
		{
			hideFlags = (HideFlags)52
		};
	}

	private void Awake()
	{
		m_Threshold = Shader.PropertyToID("_Threshold");
		m_Curve = Shader.PropertyToID("_Curve");
		m_PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");
		m_SampleScale = Shader.PropertyToID("_SampleScale");
		m_Intensity = Shader.PropertyToID("_Intensity");
		m_BaseTex = Shader.PropertyToID("_BaseTex");
	}

	private void OnEnable()
	{
		if (!IsSupported(shader, needDepth: true, needHdr: false, (MonoBehaviour)(object)this))
		{
			((Behaviour)this).enabled = false;
		}
	}

	private void OnDisable()
	{
		if ((Object)(object)m_Material != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)m_Material);
		}
		m_Material = null;
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		bool isMobilePlatform = Application.isMobilePlatform;
		int num = ((Texture)source).width;
		int num2 = ((Texture)source).height;
		if (!settings.highQuality)
		{
			num /= 2;
			num2 /= 2;
		}
		RenderTextureFormat val = (RenderTextureFormat)(isMobilePlatform ? 7 : 9);
		float num3 = Mathf.Log((float)num2, 2f) + settings.radius - 8f;
		int num4 = (int)num3;
		int num5 = Mathf.Clamp(num4, 1, 16);
		float thresholdLinear = settings.thresholdLinear;
		material.SetFloat(m_Threshold, thresholdLinear);
		float num6 = thresholdLinear * settings.softKnee + 1E-05f;
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(thresholdLinear - num6, num6 * 2f, 0.25f / num6);
		material.SetVector(m_Curve, Vector4.op_Implicit(val2));
		bool flag = !settings.highQuality && settings.antiFlicker;
		material.SetFloat(m_PrefilterOffs, flag ? (-0.5f) : 0f);
		material.SetFloat(m_SampleScale, 0.5f + num3 - (float)num4);
		material.SetFloat(m_Intensity, Mathf.Max(0f, settings.intensity));
		RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, val);
		Graphics.Blit((Texture)(object)source, temporary, material, settings.antiFlicker ? 1 : 0);
		RenderTexture val3 = temporary;
		for (int i = 0; i < num5; i++)
		{
			m_blurBuffer1[i] = RenderTexture.GetTemporary(((Texture)val3).width / 2, ((Texture)val3).height / 2, 0, val);
			Graphics.Blit((Texture)(object)val3, m_blurBuffer1[i], material, (i == 0) ? (settings.antiFlicker ? 3 : 2) : 4);
			val3 = m_blurBuffer1[i];
		}
		for (int num7 = num5 - 2; num7 >= 0; num7--)
		{
			RenderTexture val4 = m_blurBuffer1[num7];
			material.SetTexture(m_BaseTex, (Texture)(object)val4);
			m_blurBuffer2[num7] = RenderTexture.GetTemporary(((Texture)val4).width, ((Texture)val4).height, 0, val);
			Graphics.Blit((Texture)(object)val3, m_blurBuffer2[num7], material, settings.highQuality ? 6 : 5);
			val3 = m_blurBuffer2[num7];
		}
		int num8 = 7;
		num8 += (settings.highQuality ? 1 : 0);
		material.SetTexture(m_BaseTex, (Texture)(object)source);
		Graphics.Blit((Texture)(object)val3, destination, material, num8);
		for (int j = 0; j < 16; j++)
		{
			if ((Object)(object)m_blurBuffer1[j] != (Object)null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
			}
			if ((Object)(object)m_blurBuffer2[j] != (Object)null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
			}
			m_blurBuffer1[j] = null;
			m_blurBuffer2[j] = null;
		}
		RenderTexture.ReleaseTemporary(temporary);
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Settings
{
	[Tooltip("Filters out pixels under this level of brightness.")]
	[SerializeField]
	public float threshold;

	[Tooltip("Makes transition between under/over-threshold gradual.")]
	[SerializeField]
	[Range(0f, 1f)]
	public float softKnee;

	[Range(1f, 7f)]
	[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
	[SerializeField]
	public float radius;

	[SerializeField]
	[Tooltip("Blend factor of the result image.")]
	public float intensity;

	[Tooltip("Controls filter quality and buffer resolution.")]
	[SerializeField]
	public bool highQuality;

	[Tooltip("Reduces flashing noise with an additional filter.")]
	[SerializeField]
	public bool antiFlicker;

	public float thresholdGamma
	{
		get
		{
			return Mathf.Max(0f, threshold);
		}
		set
		{
			threshold = value;
		}
	}

	public float thresholdLinear
	{
		get
		{
			return Mathf.GammaToLinearSpace(thresholdGamma);
		}
		set
		{
			threshold = Mathf.LinearToGammaSpace(value);
		}
	}

	public static Settings defaultSettings
	{
		get
		{
			Settings result = default(Settings);
			result.threshold = 2f;
			result.softKnee = 0f;
			result.radius = 7f;
			result.intensity = 0.7f;
			result.highQuality = true;
			result.antiFlicker = true;
			return result;
		}
	}
}


using UnityEngine;

public class ExplosionDemoGUI : MonoBehaviour
{
	public GameObject[] Prefabs;

	public float reactivateTime = 4f;

	public Light Sun;

	private int currentNomber;

	private GameObject currentInstance;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private float sunIntensity;

	private float dpiScale;

	private void Start()
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeader.normal.textColor = new Color(0.15f, 0.15f, 0.15f);
		currentInstance = Object.Instantiate<GameObject>(Prefabs[currentNomber], ((Component)this).transform.position, default(Quaternion));
		currentInstance.AddComponent<ExplosionDemoReactivator>().TimeDelayToReactivate = reactivateTime;
		sunIntensity = Sun.intensity;
	}

	private void OnGUI()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT"))
		{
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT"))
		{
			ChangeCurrent(1);
		}
		sunIntensity = GUI.HorizontalSlider(new Rect(10f * dpiScale, 70f * dpiScale, 285f * dpiScale, 15f * dpiScale), sunIntensity, 0f, 0.6f);
		Sun.intensity = sunIntensity;
		GUI.Label(new Rect(300f * dpiScale, 70f * dpiScale, 30f * dpiScale, 30f * dpiScale), "SUN INTENSITY", guiStyleHeader);
		GUI.Label(new Rect(400f * dpiScale, 15f * dpiScale, 100f * dpiScale, 20f * dpiScale), "Prefab name is \"" + ((Object)Prefabs[currentNomber]).name + "\"  \r\nHold any mouse button that would move the camera", guiStyleHeader);
	}

	private void ChangeCurrent(int delta)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if ((Object)(object)currentInstance != (Object)null)
		{
			Object.Destroy((Object)(object)currentInstance);
		}
		currentInstance = Object.Instantiate<GameObject>(Prefabs[currentNomber], ((Component)this).transform.position, default(Quaternion));
		currentInstance.AddComponent<ExplosionDemoReactivator>().TimeDelayToReactivate = reactivateTime;
	}
}


using UnityEngine;

public class ExplosionDemoReactivator : MonoBehaviour
{
	public float TimeDelayToReactivate = 3f;

	private void Start()
	{
		((MonoBehaviour)this).InvokeRepeating("Reactivate", 0f, TimeDelayToReactivate);
	}

	private void Reactivate()
	{
		Transform[] componentsInChildren = ((Component)this).GetComponentsInChildren<Transform>();
		foreach (Transform obj in componentsInChildren)
		{
			((Component)obj).gameObject.SetActive(false);
			((Component)obj).gameObject.SetActive(true);
		}
	}
}


using UnityEngine;

public class ExplosionPlatformActivator : MonoBehaviour
{
	public GameObject Effect;

	public float TimeDelay;

	public float DefaultRepeatTime = 5f;

	public float NearRepeatTime = 3f;

	private float currentTime;

	private float currentRepeatTime;

	private bool canUpdate;

	private void Start()
	{
		currentRepeatTime = DefaultRepeatTime;
		((MonoBehaviour)this).Invoke("Init", TimeDelay);
	}

	private void Init()
	{
		canUpdate = true;
		Effect.SetActive(true);
	}

	private void Update()
	{
		if (canUpdate && !((Object)(object)Effect == (Object)null))
		{
			currentTime += Time.deltaTime;
			if (currentTime > currentRepeatTime)
			{
				currentTime = 0f;
				Effect.SetActive(false);
				Effect.SetActive(true);
			}
		}
	}

	private void OnTriggerEnter(Collider coll)
	{
		currentRepeatTime = NearRepeatTime;
	}

	private void OnTriggerExit(Collider other)
	{
		currentRepeatTime = DefaultRepeatTime;
	}
}


using UnityEngine;

public class ExplosionsFPS : MonoBehaviour
{
	private readonly GUIStyle guiStyleHeader = new GUIStyle();

	private float timeleft;

	private float fps;

	private int frames;

	private void Awake()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		guiStyleHeader.fontSize = 14;
		guiStyleHeader.normal.textColor = new Color(1f, 1f, 1f);
	}

	private void OnGUI()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		GUI.Label(new Rect(0f, 0f, 30f, 30f), "FPS: " + (int)fps, guiStyleHeader);
	}

	private void Update()
	{
		timeleft -= Time.deltaTime;
		frames++;
		if ((double)timeleft <= 0.0)
		{
			fps = frames;
			timeleft = 1f;
			frames = 0;
		}
	}
}


using UnityEngine;

public class ExplosionsBillboard : MonoBehaviour
{
	public Camera Camera;

	public bool Active = true;

	public bool AutoInitCamera = true;

	private GameObject myContainer;

	private Transform t;

	private Transform camT;

	private Transform contT;

	private void Awake()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Expected O, but got Unknown
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		if (AutoInitCamera)
		{
			Camera = Camera.main;
			Active = true;
		}
		t = ((Component)this).transform;
		Vector3 localScale = ((Component)t.parent).transform.localScale;
		localScale.z = localScale.x;
		((Component)t.parent).transform.localScale = localScale;
		camT = ((Component)Camera).transform;
		Transform parent = t.parent;
		myContainer = new GameObject
		{
			name = "Billboard_" + ((Object)((Component)t).gameObject).name
		};
		contT = myContainer.transform;
		contT.position = t.position;
		t.parent = myContainer.transform;
		contT.parent = parent;
	}

	private void Update()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (Active)
		{
			contT.LookAt(contT.position + camT.rotation * Vector3.back, camT.rotation * Vector3.up);
		}
	}
}


using UnityEngine;

public class ExplosionsDeactivateRendererByTime : MonoBehaviour
{
	public float TimeDelay = 1f;

	private Renderer rend;

	private void Awake()
	{
		rend = ((Component)this).GetComponent<Renderer>();
	}

	private void DeactivateRenderer()
	{
		rend.enabled = false;
	}

	private void OnEnable()
	{
		rend.enabled = true;
		((MonoBehaviour)this).Invoke("DeactivateRenderer", TimeDelay);
	}
}


using UnityEngine;

public class ExplosionsLightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	private bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = ((Component)this).GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
		}
		if (num >= GraphTimeMultiplier)
		{
			canUpdate = false;
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class ExplosionsParticleSystemScaler : MonoBehaviour
{
	public float particlesScale = 1f;

	private void Start()
	{
	}

	private void Update()
	{
	}
}


using UnityEngine;

public class ExplosionsScaleCurves : MonoBehaviour
{
	public AnimationCurve ScaleCurveX = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public AnimationCurve ScaleCurveY = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public AnimationCurve ScaleCurveZ = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public Vector3 GraphTimeMultiplier = Vector3.one;

	public Vector3 GraphScaleMultiplier = Vector3.one;

	private float startTime;

	private Transform t;

	private float evalX;

	private float evalY;

	private float evalZ;

	private void Awake()
	{
		t = ((Component)this).transform;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		evalX = 0f;
		evalY = 0f;
		evalZ = 0f;
	}

	private void Update()
	{
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time - startTime;
		if (num <= GraphTimeMultiplier.x)
		{
			evalX = ScaleCurveX.Evaluate(num / GraphTimeMultiplier.x) * GraphScaleMultiplier.x;
		}
		if (num <= GraphTimeMultiplier.y)
		{
			evalY = ScaleCurveY.Evaluate(num / GraphTimeMultiplier.y) * GraphScaleMultiplier.y;
		}
		if (num <= GraphTimeMultiplier.z)
		{
			evalZ = ScaleCurveZ.Evaluate(num / GraphTimeMultiplier.z) * GraphScaleMultiplier.z;
		}
		t.localScale = new Vector3(evalX, evalY, evalZ);
	}
}


using UnityEngine;

public class ExplosionsShaderColorGradient : MonoBehaviour
{
	public string ShaderProperty = "_TintColor";

	public int MaterialID;

	public Gradient Color = new Gradient();

	public float TimeMultiplier = 1f;

	private bool canUpdate;

	private Material matInstance;

	private int propertyID;

	private float startTime;

	private Color oldColor;

	private void Start()
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Material[] materials = ((Component)this).GetComponent<Renderer>().materials;
		if (MaterialID >= materials.Length)
		{
			Debug.Log((object)"ShaderColorGradient: Material ID more than shader materials count.");
		}
		matInstance = materials[MaterialID];
		if (!matInstance.HasProperty(ShaderProperty))
		{
			Debug.Log((object)("ShaderColorGradient: Shader not have \"" + ShaderProperty + "\" property"));
		}
		propertyID = Shader.PropertyToID(ShaderProperty);
		oldColor = matInstance.GetColor(propertyID);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time - startTime;
		if (canUpdate)
		{
			Color val = Color.Evaluate(num / TimeMultiplier);
			matInstance.SetColor(propertyID, val * oldColor);
		}
		if (num >= TimeMultiplier)
		{
			canUpdate = false;
		}
	}
}


using UnityEngine;

public class ExplosionsShaderFloatCurves : MonoBehaviour
{
	public string ShaderProperty = "_BumpAmt";

	public int MaterialID;

	public AnimationCurve FloatPropertyCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphScaleMultiplier = 1f;

	private bool canUpdate;

	private Material matInstance;

	private int propertyID;

	private float startTime;

	private void Start()
	{
		Material[] materials = ((Component)this).GetComponent<Renderer>().materials;
		if (MaterialID >= materials.Length)
		{
			Debug.Log((object)"ShaderColorGradient: Material ID more than shader materials count.");
		}
		matInstance = materials[MaterialID];
		if (!matInstance.HasProperty(ShaderProperty))
		{
			Debug.Log((object)("ShaderColorGradient: Shader not have \"" + ShaderProperty + "\" property"));
		}
		propertyID = Shader.PropertyToID(ShaderProperty);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = FloatPropertyCurve.Evaluate(num / GraphTimeMultiplier) * GraphScaleMultiplier;
			matInstance.SetFloat(propertyID, num2);
		}
		if (num >= GraphTimeMultiplier)
		{
			canUpdate = false;
		}
	}
}


using UnityEngine;

public class ExplosionsShaderQueue : MonoBehaviour
{
	public int AddQueue = 1;

	private Renderer rend;

	private void Start()
	{
		rend = ((Component)this).GetComponent<Renderer>();
		if ((Object)(object)rend != (Object)null)
		{
			Material sharedMaterial = rend.sharedMaterial;
			sharedMaterial.renderQueue += AddQueue;
		}
		else
		{
			((MonoBehaviour)this).Invoke("SetProjectorQueue", 0.1f);
		}
	}

	private void SetProjectorQueue()
	{
		Material material = ((Component)this).GetComponent<Projector>().material;
		material.renderQueue += AddQueue;
	}

	private void OnDisable()
	{
		if ((Object)(object)rend != (Object)null)
		{
			rend.sharedMaterial.renderQueue = -1;
		}
	}
}


using System;
using System.Collections;
using UnityEngine;

internal class ExplosionsSpriteSheetAnimation : MonoBehaviour
{
	public int TilesX = 4;

	public int TilesY = 4;

	public float AnimationFPS = 30f;

	public bool IsInterpolateFrames;

	public int StartFrameOffset;

	public bool IsLoop = true;

	public float StartDelay;

	public AnimationCurve FrameOverTime = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	private bool isInizialised;

	private int index;

	private int count;

	private int allCount;

	private float animationLifeTime;

	private bool isVisible;

	private bool isCorutineStarted;

	private Renderer currentRenderer;

	private Material instanceMaterial;

	private float currentInterpolatedTime;

	private float animationStartTime;

	private bool animationStoped;

	private void Start()
	{
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		InitDefaultVariables();
		isInizialised = true;
		isVisible = true;
		Play();
	}

	private void InitDefaultVariables()
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		if ((Object)(object)currentRenderer == (Object)null)
		{
			throw new Exception("UvTextureAnimator can't get renderer");
		}
		if (!currentRenderer.enabled)
		{
			currentRenderer.enabled = true;
		}
		allCount = 0;
		animationStoped = false;
		animationLifeTime = (float)(TilesX * TilesY) / AnimationFPS;
		count = TilesY * TilesX;
		index = TilesX - 1;
		Vector3 zero = Vector3.zero;
		StartFrameOffset -= StartFrameOffset / count * count;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(1f / (float)TilesX, 1f / (float)TilesY);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial = currentRenderer.material;
			instanceMaterial.SetTextureScale("_MainTex", val);
			instanceMaterial.SetTextureOffset("_MainTex", Vector2.op_Implicit(zero));
		}
	}

	private void Play()
	{
		if (!isCorutineStarted)
		{
			if (StartDelay > 0.0001f)
			{
				((MonoBehaviour)this).Invoke("PlayDelay", StartDelay);
			}
			else
			{
				((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
			}
			isCorutineStarted = true;
		}
	}

	private void PlayDelay()
	{
		((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
	}

	private void OnEnable()
	{
		if (isInizialised)
		{
			InitDefaultVariables();
			isVisible = true;
			Play();
		}
	}

	private void OnDisable()
	{
		isCorutineStarted = false;
		isVisible = false;
		((MonoBehaviour)this).StopAllCoroutines();
		((MonoBehaviour)this).CancelInvoke("PlayDelay");
	}

	private IEnumerator UpdateCorutine()
	{
		animationStartTime = Time.time;
		while (isVisible && (IsLoop || !animationStoped))
		{
			UpdateFrame();
			if (!IsLoop && animationStoped)
			{
				break;
			}
			float num = (Time.time - animationStartTime) / animationLifeTime;
			float num2 = FrameOverTime.Evaluate(Mathf.Clamp01(num));
			yield return (object)new WaitForSeconds(1f / (AnimationFPS * num2));
		}
		isCorutineStarted = false;
		currentRenderer.enabled = false;
	}

	private void UpdateFrame()
	{
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		allCount++;
		index++;
		if (index >= count)
		{
			index = 0;
		}
		if (count == allCount)
		{
			animationStartTime = Time.time;
			allCount = 0;
			animationStoped = true;
		}
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)index / (float)TilesX - (float)(index / TilesX), 1f - (float)(index / TilesX) / (float)TilesY);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial.SetTextureOffset("_MainTex", val);
		}
		if (IsInterpolateFrames)
		{
			currentInterpolatedTime = 0f;
		}
	}

	private void Update()
	{
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if (IsInterpolateFrames)
		{
			currentInterpolatedTime += Time.deltaTime;
			int num = index + 1;
			if (allCount == 0)
			{
				num = index;
			}
			Vector4 val = default(Vector4);
			((Vector4)(ref val))..ctor(1f / (float)TilesX, 1f / (float)TilesY, (float)num / (float)TilesX - (float)(num / TilesX), 1f - (float)(num / TilesX) / (float)TilesY);
			if ((Object)(object)currentRenderer != (Object)null)
			{
				instanceMaterial.SetVector("_MainTex_NextFrame", val);
				float num2 = (Time.time - animationStartTime) / animationLifeTime;
				float num3 = FrameOverTime.Evaluate(Mathf.Clamp01(num2));
				instanceMaterial.SetFloat("InterpolationValue", Mathf.Clamp01(currentInterpolatedTime * AnimationFPS * num3));
			}
		}
	}

	private void OnDestroy()
	{
		if ((Object)(object)instanceMaterial != (Object)null)
		{
			Object.Destroy((Object)(object)instanceMaterial);
			instanceMaterial = null;
		}
	}
}


using ConVar;
using UnityEngine;

[RequireComponent(typeof(Light))]
[ExecuteInEditMode]
public class NGSS_Directional : MonoBehaviour
{
	public enum SAMPLER_COUNT
	{
		SAMPLERS_16,
		SAMPLERS_25,
		SAMPLERS_32,
		SAMPLERS_64
	}

	[Tooltip("Overall softness for both PCF and PCSS shadows.\nRecommended value: 0.01.")]
	[Range(0f, 0.02f)]
	public float PCSS_GLOBAL_SOFTNESS = 0.01f;

	[Range(0f, 1f)]
	[Tooltip("PCSS softness when shadows is close to caster.\nRecommended value: 0.05.")]
	public float PCSS_FILTER_DIR_MIN = 0.05f;

	[Range(0f, 0.5f)]
	[Tooltip("PCSS softness when shadows is far from caster.\nRecommended value: 0.25.\nIf too high can lead to visible artifacts when early bailout is enabled.")]
	public float PCSS_FILTER_DIR_MAX = 0.25f;

	[Range(0f, 10f)]
	[Tooltip("Amount of banding or noise. Example: 0.0 gives 100 % Banding and 10.0 gives 100 % Noise.")]
	public float BANDING_NOISE_AMOUNT = 1f;

	[Tooltip("Recommended values: Mobile = 16, Consoles = 25, Desktop Low = 32, Desktop High = 64")]
	public SAMPLER_COUNT SAMPLERS_COUNT;

	private void Update()
	{
		bool globalSettings = Graphics.shadowquality >= 2;
		SetGlobalSettings(globalSettings);
	}

	private void SetGlobalSettings(bool enabled)
	{
		if (enabled)
		{
			Shader.SetGlobalFloat("NGSS_PCSS_GLOBAL_SOFTNESS", PCSS_GLOBAL_SOFTNESS);
			Shader.SetGlobalFloat("NGSS_PCSS_FILTER_DIR_MIN", (PCSS_FILTER_DIR_MIN > PCSS_FILTER_DIR_MAX) ? PCSS_FILTER_DIR_MAX : PCSS_FILTER_DIR_MIN);
			Shader.SetGlobalFloat("NGSS_PCSS_FILTER_DIR_MAX", (PCSS_FILTER_DIR_MAX < PCSS_FILTER_DIR_MIN) ? PCSS_FILTER_DIR_MIN : PCSS_FILTER_DIR_MAX);
			Shader.SetGlobalFloat("NGSS_POISSON_SAMPLING_NOISE_DIR", BANDING_NOISE_AMOUNT);
		}
	}
}


public enum SAMPLER_COUNT
{
	SAMPLERS_16,
	SAMPLERS_25,
	SAMPLERS_32,
	SAMPLERS_64
}


using UnityEngine;

public struct OccludeeSphere
{
	public int id;

	public OccludeeState state;

	public OcclusionCulling.Sphere sphere;

	public bool IsRegistered => id >= 0;

	public void Invalidate()
	{
		id = -1;
		state = null;
		sphere = default(OcclusionCulling.Sphere);
	}

	public OccludeeSphere(int id)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		this.id = id;
		state = ((id < 0) ? null : OcclusionCulling.GetStateById(id));
		sphere = new OcclusionCulling.Sphere(Vector3.zero, 0f);
	}

	public OccludeeSphere(int id, OcclusionCulling.Sphere sphere)
	{
		this.id = id;
		state = ((id < 0) ? null : OcclusionCulling.GetStateById(id));
		this.sphere = sphere;
	}
}


using System.Runtime.InteropServices;
using UnityEngine;

public class OccludeeState : OcclusionCulling.SmartListValue
{
	[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 32)]
	public struct State
	{
		[FieldOffset(0)]
		public Vector4 sphereBounds;

		[FieldOffset(16)]
		public float minTimeVisible;

		[FieldOffset(20)]
		public float waitTime;

		[FieldOffset(24)]
		public uint waitFrame;

		[FieldOffset(28)]
		public byte isVisible;

		[FieldOffset(29)]
		public byte active;

		[FieldOffset(30)]
		public byte callback;

		[FieldOffset(31)]
		public byte pad1;

		public static State Unused = new State
		{
			active = 0
		};
	}

	public int slot;

	public bool isStatic;

	public int layer;

	public OcclusionCulling.OnVisibilityChanged onVisibilityChanged;

	public OcclusionCulling.Cell cell;

	public OcclusionCulling.SimpleList<State> states;

	public bool isVisible => states[slot].isVisible != 0;

	public OccludeeState Initialize(OcclusionCulling.SimpleList<State> states, OcclusionCulling.BufferSet set, int slot, Vector4 sphereBounds, bool isVisible, float minTimeVisible, bool isStatic, int layer, OcclusionCulling.OnVisibilityChanged onVisibilityChanged)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		states[slot] = new State
		{
			sphereBounds = sphereBounds,
			minTimeVisible = minTimeVisible,
			waitTime = (isVisible ? (Time.time + minTimeVisible) : 0f),
			waitFrame = (uint)(Time.frameCount + 1),
			isVisible = (byte)(isVisible ? 1 : 0),
			active = 1,
			callback = ((onVisibilityChanged != null) ? ((byte)1) : ((byte)0))
		};
		this.slot = slot;
		this.isStatic = isStatic;
		this.layer = layer;
		this.onVisibilityChanged = onVisibilityChanged;
		cell = null;
		this.states = states;
		return this;
	}

	public void Invalidate()
	{
		states[slot] = State.Unused;
		slot = -1;
		onVisibilityChanged = null;
		cell = null;
	}

	public void MakeVisible()
	{
		states.array[slot].waitTime = Time.time + states[slot].minTimeVisible;
		states.array[slot].isVisible = 1;
		if (onVisibilityChanged != null)
		{
			onVisibilityChanged(visible: true);
		}
	}
}


using System.Runtime.InteropServices;
using UnityEngine;

[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 32)]
public struct State
{
	[FieldOffset(0)]
	public Vector4 sphereBounds;

	[FieldOffset(16)]
	public float minTimeVisible;

	[FieldOffset(20)]
	public float waitTime;

	[FieldOffset(24)]
	public uint waitFrame;

	[FieldOffset(28)]
	public byte isVisible;

	[FieldOffset(29)]
	public byte active;

	[FieldOffset(30)]
	public byte callback;

	[FieldOffset(31)]
	public byte pad1;

	public static State Unused = new State
	{
		active = 0
	};
}


using UnityEngine;

public class Occludee : MonoBehaviour
{
	public float minTimeVisible = 0.1f;

	public bool isStatic = true;

	public bool autoRegister;

	public bool stickyGizmos;

	public OccludeeState state;

	protected int occludeeId = -1;

	protected Vector3 center;

	protected float radius;

	protected Renderer renderer;

	protected Collider collider;

	protected virtual void Awake()
	{
		renderer = ((Component)this).GetComponent<Renderer>();
		collider = ((Component)this).GetComponent<Collider>();
	}

	public void OnEnable()
	{
		if (autoRegister && (Object)(object)collider != (Object)null)
		{
			Register();
		}
	}

	public void OnDisable()
	{
		if (autoRegister && occludeeId >= 0)
		{
			Unregister();
		}
	}

	public void Register()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = collider.bounds;
		center = ((Bounds)(ref bounds)).center;
		bounds = collider.bounds;
		float x = ((Bounds)(ref bounds)).extents.x;
		bounds = collider.bounds;
		float num = Mathf.Max(x, ((Bounds)(ref bounds)).extents.y);
		bounds = collider.bounds;
		radius = Mathf.Max(num, ((Bounds)(ref bounds)).extents.z);
		occludeeId = OcclusionCulling.RegisterOccludee(center, radius, renderer.enabled, minTimeVisible, isStatic, ((Component)this).gameObject.layer, OnVisibilityChanged);
		if (occludeeId < 0)
		{
			Debug.LogWarning((object)("[OcclusionCulling] Occludee registration failed for " + ((Object)this).name + ". Too many registered."));
		}
		state = OcclusionCulling.GetStateById(occludeeId);
	}

	public void Unregister()
	{
		OcclusionCulling.UnregisterOccludee(occludeeId);
	}

	protected virtual void OnVisibilityChanged(bool visible)
	{
		if ((Object)(object)renderer != (Object)null)
		{
			renderer.enabled = visible;
		}
	}
}


public class OcclusionCPUTest
{
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using RustNative;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(Camera))]
public class OcclusionCulling : MonoBehaviour
{
	public class BufferSet
	{
		public ComputeBuffer inputBuffer;

		public ComputeBuffer resultBuffer;

		public int width;

		public int height;

		public int capacity;

		public int count;

		public Texture2D inputTexture;

		public RenderTexture resultTexture;

		public Texture2D resultReadTexture;

		public Color[] inputData = (Color[])(object)new Color[0];

		public Color32[] resultData = (Color32[])(object)new Color32[0];

		private OcclusionCulling culling;

		private const int MaxAsyncGPUReadbackRequests = 10;

		private Queue<AsyncGPUReadbackRequest> asyncRequests = new Queue<AsyncGPUReadbackRequest>();

		public IntPtr readbackInst = IntPtr.Zero;

		public bool Ready => resultData.Length != 0;

		public void Attach(OcclusionCulling culling)
		{
			this.culling = culling;
		}

		public void Dispose(bool data = true)
		{
			if (inputBuffer != null)
			{
				inputBuffer.Dispose();
				inputBuffer = null;
			}
			if (resultBuffer != null)
			{
				resultBuffer.Dispose();
				resultBuffer = null;
			}
			if ((Object)(object)inputTexture != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)inputTexture);
				inputTexture = null;
			}
			if ((Object)(object)resultTexture != (Object)null)
			{
				RenderTexture.active = null;
				resultTexture.Release();
				Object.DestroyImmediate((Object)(object)resultTexture);
				resultTexture = null;
			}
			if ((Object)(object)resultReadTexture != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)resultReadTexture);
				resultReadTexture = null;
			}
			if (readbackInst != IntPtr.Zero)
			{
				BufferReadback.Destroy(readbackInst);
				readbackInst = IntPtr.Zero;
			}
			if (data)
			{
				inputData = (Color[])(object)new Color[0];
				resultData = (Color32[])(object)new Color32[0];
				capacity = 0;
				count = 0;
			}
		}

		public bool CheckResize(int count, int granularity)
		{
			//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c2: Expected O, but got Unknown
			//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cf: Expected O, but got Unknown
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Expected O, but got Unknown
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Expected O, but got Unknown
			//IL_0133: Unknown result type (might be due to invalid IL or missing references)
			//IL_013d: Expected O, but got Unknown
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			//IL_019a: Expected I4, but got Unknown
			//IL_024a: Unknown result type (might be due to invalid IL or missing references)
			//IL_024b: Unknown result type (might be due to invalid IL or missing references)
			if (count > capacity || (culling.usePixelShaderFallback && (Object)(object)resultTexture != (Object)null && !resultTexture.IsCreated()))
			{
				Dispose(data: false);
				int num = capacity;
				int num2 = count / granularity * granularity + granularity;
				if (culling.usePixelShaderFallback)
				{
					width = Mathf.CeilToInt(Mathf.Sqrt((float)num2));
					height = Mathf.CeilToInt((float)num2 / (float)width);
					inputTexture = new Texture2D(width, height, (TextureFormat)20, false, true);
					((Object)inputTexture).name = "_Input";
					((Texture)inputTexture).filterMode = (FilterMode)0;
					((Texture)inputTexture).wrapMode = (TextureWrapMode)1;
					resultTexture = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
					((Object)resultTexture).name = "_Result";
					((Texture)resultTexture).filterMode = (FilterMode)0;
					((Texture)resultTexture).wrapMode = (TextureWrapMode)1;
					resultTexture.useMipMap = false;
					resultTexture.Create();
					resultReadTexture = new Texture2D(width, height, (TextureFormat)5, false, true);
					((Object)resultReadTexture).name = "_ResultRead";
					((Texture)resultReadTexture).filterMode = (FilterMode)0;
					((Texture)resultReadTexture).wrapMode = (TextureWrapMode)1;
					if (!culling.useAsyncReadAPI)
					{
						readbackInst = BufferReadback.CreateForTexture(((Texture)resultTexture).GetNativeTexturePtr(), (uint)width, (uint)height, (uint)(int)resultTexture.format);
					}
					capacity = width * height;
				}
				else
				{
					inputBuffer = new ComputeBuffer(num2, 16);
					resultBuffer = new ComputeBuffer(num2, 4);
					if (!culling.useAsyncReadAPI)
					{
						uint num3 = (uint)(capacity * 4);
						readbackInst = BufferReadback.CreateForBuffer(resultBuffer.GetNativeBufferPtr(), num3);
					}
					capacity = num2;
				}
				Array.Resize(ref inputData, capacity);
				Array.Resize(ref resultData, capacity);
				Color32 val = default(Color32);
				((Color32)(ref val))..ctor(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
				for (int i = num; i < capacity; i++)
				{
					resultData[i] = val;
				}
				this.count = count;
				return true;
			}
			return false;
		}

		public void UploadData()
		{
			if (culling.usePixelShaderFallback)
			{
				inputTexture.SetPixels(inputData);
				inputTexture.Apply();
			}
			else
			{
				inputBuffer.SetData((Array)inputData);
			}
		}

		private int AlignDispatchSize(int dispatchSize)
		{
			return (dispatchSize + 63) / 64;
		}

		public void Dispatch(int count)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			if (culling.usePixelShaderFallback)
			{
				RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
				RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
				culling.fallbackMat.SetTexture("_Input", (Texture)(object)inputTexture);
				Graphics.Blit((Texture)(object)inputTexture, resultTexture, culling.fallbackMat, 0);
				Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
			}
			else if (inputBuffer != null)
			{
				culling.computeShader.SetBuffer(0, "_Input", inputBuffer);
				culling.computeShader.SetBuffer(0, "_Result", resultBuffer);
				culling.computeShader.Dispatch(0, AlignDispatchSize(count), 1, 1);
			}
		}

		public void IssueRead()
		{
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			if (SafeMode)
			{
				return;
			}
			if (culling.useAsyncReadAPI)
			{
				if (asyncRequests.Count < 10)
				{
					AsyncGPUReadbackRequest item = ((!culling.usePixelShaderFallback) ? AsyncGPUReadback.Request(resultBuffer, (Action<AsyncGPUReadbackRequest>)null) : AsyncGPUReadback.Request((Texture)(object)resultTexture, 0, (Action<AsyncGPUReadbackRequest>)null));
					asyncRequests.Enqueue(item);
				}
			}
			else if (readbackInst != IntPtr.Zero)
			{
				BufferReadback.IssueRead(readbackInst);
			}
		}

		public void GetResults()
		{
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			if (resultData == null || resultData.Length == 0)
			{
				return;
			}
			if (!SafeMode)
			{
				if (culling.useAsyncReadAPI)
				{
					while (asyncRequests.Count > 0)
					{
						AsyncGPUReadbackRequest val = asyncRequests.Peek();
						if (((AsyncGPUReadbackRequest)(ref val)).hasError)
						{
							asyncRequests.Dequeue();
							continue;
						}
						if (((AsyncGPUReadbackRequest)(ref val)).done)
						{
							NativeArray<Color32> data = ((AsyncGPUReadbackRequest)(ref val)).GetData<Color32>(0);
							for (int i = 0; i < data.Length; i++)
							{
								resultData[i] = data[i];
							}
							asyncRequests.Dequeue();
							continue;
						}
						break;
					}
				}
				else if (readbackInst != IntPtr.Zero)
				{
					BufferReadback.GetData(readbackInst, ref resultData[0]);
				}
			}
			else if (culling.usePixelShaderFallback)
			{
				RenderTexture.active = resultTexture;
				resultReadTexture.ReadPixels(new Rect(0f, 0f, (float)width, (float)height), 0, 0);
				resultReadTexture.Apply();
				Array.Copy(resultReadTexture.GetPixels32(), resultData, resultData.Length);
			}
			else
			{
				resultBuffer.GetData((Array)resultData);
			}
		}
	}

	public delegate void OnVisibilityChanged(bool visible);

	public enum DebugFilter
	{
		Off,
		Dynamic,
		Static,
		Grid,
		All
	}

	[Flags]
	public enum DebugMask
	{
		Off = 0,
		Dynamic = 1,
		Static = 2,
		Grid = 4,
		All = 7
	}

	[Serializable]
	public class DebugSettings
	{
		public bool log;

		public bool showAllVisible;

		public bool showMipChain;

		public bool showMain;

		public int showMainLod;

		public bool showFallback;

		public bool showStats;

		public bool showScreenBounds;

		public DebugMask showMask;

		public LayerMask layerFilter = LayerMask.op_Implicit(-1);
	}

	public class HashedPoolValue
	{
		public ulong hashedPoolKey = ulong.MaxValue;

		public int hashedPoolIndex = -1;
	}

	public class HashedPool<TValueType> where TValueType : HashedPoolValue, new()
	{
		private int granularity;

		private Dictionary<ulong, TValueType> dict;

		private List<TValueType> pool;

		private List<TValueType> list;

		private Queue<TValueType> recycled;

		public int Size => list.Count;

		public int Count => dict.Count;

		public TValueType this[int i]
		{
			get
			{
				return list[i];
			}
			set
			{
				list[i] = value;
			}
		}

		public HashedPool(int capacity, int granularity)
		{
			this.granularity = granularity;
			dict = new Dictionary<ulong, TValueType>(capacity);
			pool = new List<TValueType>(capacity);
			list = new List<TValueType>(capacity);
			recycled = new Queue<TValueType>();
		}

		public void Clear()
		{
			dict.Clear();
			pool.Clear();
			list.Clear();
			recycled.Clear();
		}

		public TValueType Add(ulong key, int capacityGranularity = 16)
		{
			TValueType val;
			if (recycled.Count > 0)
			{
				val = recycled.Dequeue();
				list[val.hashedPoolIndex] = val;
			}
			else
			{
				int count = pool.Count;
				if (count == pool.Capacity)
				{
					pool.Capacity += granularity;
				}
				val = new TValueType
				{
					hashedPoolIndex = count
				};
				pool.Add(val);
				list.Add(val);
			}
			val.hashedPoolKey = key;
			dict.Add(key, val);
			return val;
		}

		public void Remove(TValueType value)
		{
			dict.Remove(value.hashedPoolKey);
			list[value.hashedPoolIndex] = null;
			recycled.Enqueue(value);
			value.hashedPoolKey = ulong.MaxValue;
		}

		public bool TryGetValue(ulong key, out TValueType value)
		{
			return dict.TryGetValue(key, out value);
		}

		public bool ContainsKey(ulong key)
		{
			return dict.ContainsKey(key);
		}
	}

	public class SimpleList<T>
	{
		private const int defaultCapacity = 16;

		private static readonly T[] emptyArray = new T[0];

		public T[] array;

		public int count;

		public int Count => count;

		public int Capacity
		{
			get
			{
				return array.Length;
			}
			set
			{
				if (value == array.Length)
				{
					return;
				}
				if (value > 0)
				{
					T[] destinationArray = new T[value];
					if (count > 0)
					{
						Array.Copy(array, 0, destinationArray, 0, count);
					}
					array = destinationArray;
				}
				else
				{
					array = emptyArray;
				}
			}
		}

		public T this[int index]
		{
			get
			{
				return array[index];
			}
			set
			{
				array[index] = value;
			}
		}

		public SimpleList()
		{
			array = emptyArray;
		}

		public SimpleList(int capacity)
		{
			array = ((capacity == 0) ? emptyArray : new T[capacity]);
		}

		public void Add(T item)
		{
			if (count == array.Length)
			{
				EnsureCapacity(count + 1);
			}
			array[count++] = item;
		}

		public void Clear()
		{
			if (count > 0)
			{
				Array.Clear(array, 0, count);
				count = 0;
			}
		}

		public bool Contains(T item)
		{
			for (int i = 0; i < count; i++)
			{
				if (array[i].Equals(item))
				{
					return true;
				}
			}
			return false;
		}

		public void CopyTo(T[] array)
		{
			Array.Copy(this.array, 0, array, 0, count);
		}

		public void EnsureCapacity(int min)
		{
			if (array.Length < min)
			{
				int num = ((array.Length == 0) ? 16 : (array.Length * 2));
				num = ((num < min) ? min : num);
				Capacity = num;
			}
		}
	}

	public class SmartListValue
	{
		public int hashedListIndex = -1;
	}

	public class SmartList
	{
		private const int defaultCapacity = 16;

		private static readonly OccludeeState[] emptyList = new OccludeeState[0];

		private static readonly int[] emptySlots = new int[0];

		private OccludeeState[] list;

		private int[] slots;

		private Queue<int> recycled;

		private int count;

		public OccludeeState[] List => list;

		public int[] Slots => slots;

		public int Size => count;

		public int Count => count - recycled.Count;

		public OccludeeState this[int i]
		{
			get
			{
				return list[i];
			}
			set
			{
				list[i] = value;
			}
		}

		public int Capacity
		{
			get
			{
				return list.Length;
			}
			set
			{
				if (value == list.Length)
				{
					return;
				}
				if (value > 0)
				{
					OccludeeState[] destinationArray = new OccludeeState[value];
					int[] destinationArray2 = new int[value];
					if (count > 0)
					{
						Array.Copy(list, destinationArray, count);
						Array.Copy(slots, destinationArray2, count);
					}
					list = destinationArray;
					slots = destinationArray2;
				}
				else
				{
					list = emptyList;
					slots = emptySlots;
				}
			}
		}

		public SmartList(int capacity)
		{
			list = new OccludeeState[capacity];
			slots = new int[capacity];
			recycled = new Queue<int>();
			count = 0;
		}

		public void Add(OccludeeState value, int capacityGranularity = 16)
		{
			int num;
			if (recycled.Count > 0)
			{
				num = recycled.Dequeue();
				list[num] = value;
				slots[num] = value.slot;
			}
			else
			{
				num = count;
				if (num == list.Length)
				{
					EnsureCapacity(count + 1);
				}
				list[num] = value;
				slots[num] = value.slot;
				count++;
			}
			value.hashedListIndex = num;
		}

		public void Remove(OccludeeState value)
		{
			int hashedListIndex = value.hashedListIndex;
			list[hashedListIndex] = null;
			slots[hashedListIndex] = -1;
			recycled.Enqueue(hashedListIndex);
			value.hashedListIndex = -1;
		}

		public bool Contains(OccludeeState value)
		{
			int hashedListIndex = value.hashedListIndex;
			if (hashedListIndex >= 0)
			{
				return list[hashedListIndex] != null;
			}
			return false;
		}

		public void EnsureCapacity(int min)
		{
			if (list.Length < min)
			{
				int num = ((list.Length == 0) ? 16 : (list.Length * 2));
				num = ((num < min) ? min : num);
				Capacity = num;
			}
		}
	}

	[Serializable]
	public class Cell : HashedPoolValue
	{
		public int x;

		public int y;

		public int z;

		public Bounds bounds;

		public Vector4 sphereBounds;

		public bool isVisible;

		public SmartList staticBucket;

		public SmartList dynamicBucket;

		public void Reset()
		{
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			x = (y = (z = 0));
			bounds = default(Bounds);
			sphereBounds = Vector4.zero;
			isVisible = true;
			staticBucket = null;
			dynamicBucket = null;
		}

		public Cell Initialize(int x, int y, int z, Bounds bounds)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			this.x = x;
			this.y = y;
			this.z = z;
			this.bounds = bounds;
			float num = ((Bounds)(ref bounds)).center.x;
			float num2 = ((Bounds)(ref bounds)).center.y;
			float num3 = ((Bounds)(ref bounds)).center.z;
			Vector3 extents = ((Bounds)(ref bounds)).extents;
			sphereBounds = new Vector4(num, num2, num3, ((Vector3)(ref extents)).magnitude);
			isVisible = true;
			staticBucket = new SmartList(32);
			dynamicBucket = new SmartList(32);
			return this;
		}
	}

	public struct Sphere
	{
		public Vector3 position;

		public float radius;

		public bool IsValid()
		{
			return radius > 0f;
		}

		public Sphere(Vector3 position, float radius)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			this.position = position;
			this.radius = radius;
		}
	}

	public ComputeShader computeShader;

	public bool usePixelShaderFallback = true;

	public bool useAsyncReadAPI;

	private Camera camera;

	private const int ComputeThreadsPerGroup = 64;

	private const int InputBufferStride = 16;

	private const int ResultBufferStride = 4;

	private const int OccludeeMaxSlotsPerPool = 1048576;

	private const int OccludeePoolGranularity = 2048;

	private const int StateBufferGranularity = 2048;

	private const int GridBufferGranularity = 256;

	private static Queue<OccludeeState> statePool = new Queue<OccludeeState>();

	private static SimpleList<OccludeeState> staticOccludees = new SimpleList<OccludeeState>(2048);

	private static SimpleList<OccludeeState.State> staticStates = new SimpleList<OccludeeState.State>(2048);

	private static SimpleList<int> staticVisibilityChanged = new SimpleList<int>(1024);

	private static SimpleList<OccludeeState> dynamicOccludees = new SimpleList<OccludeeState>(2048);

	private static SimpleList<OccludeeState.State> dynamicStates = new SimpleList<OccludeeState.State>(2048);

	private static SimpleList<int> dynamicVisibilityChanged = new SimpleList<int>(1024);

	private static List<int> staticChanged = new List<int>(256);

	private static Queue<int> staticRecycled = new Queue<int>();

	private static List<int> dynamicChanged = new List<int>(1024);

	private static Queue<int> dynamicRecycled = new Queue<int>();

	private static BufferSet staticSet = new BufferSet();

	private static BufferSet dynamicSet = new BufferSet();

	private static BufferSet gridSet = new BufferSet();

	private Vector4[] frustumPlanes = (Vector4[])(object)new Vector4[6];

	private string[] frustumPropNames = new string[6];

	private float[] matrixToFloatTemp = new float[16];

	private Material fallbackMat;

	private Material depthCopyMat;

	private Matrix4x4 viewMatrix;

	private Matrix4x4 projMatrix;

	private Matrix4x4 viewProjMatrix;

	private Matrix4x4 prevViewProjMatrix;

	private Matrix4x4 invViewProjMatrix;

	private bool useNativePath = true;

	private static OcclusionCulling instance;

	public static bool Passthrough = false;

	private static GraphicsDeviceType[] supportedDeviceTypes = (GraphicsDeviceType[])(object)new GraphicsDeviceType[1] { (GraphicsDeviceType)2 };

	private static bool _enabled = false;

	private static bool _safeMode = false;

	private static DebugFilter _debugShow = DebugFilter.Off;

	public DebugSettings debugSettings = new DebugSettings();

	private Material debugMipMat;

	private const float debugDrawDuration = 0.0334f;

	private Material downscaleMat;

	private Material blitCopyMat;

	private int hiZLevelCount;

	private int hiZWidth;

	private int hiZHeight;

	private RenderTexture depthTexture;

	private RenderTexture hiZTexture;

	private RenderTexture[] hiZLevels;

	private const int GridCellsPerAxis = 2097152;

	private const int GridHalfCellsPerAxis = 1048576;

	private const int GridMinHalfCellsPerAxis = -1048575;

	private const int GridMaxHalfCellsPerAxis = 1048575;

	private const float GridCellSize = 100f;

	private const float GridHalfCellSize = 50f;

	private const float GridRcpCellSize = 0.01f;

	private const int GridPoolCapacity = 16384;

	private const int GridPoolGranularity = 4096;

	private static HashedPool<Cell> grid = new HashedPool<Cell>(16384, 4096);

	private static Queue<Cell> gridChanged = new Queue<Cell>();

	public static OcclusionCulling Instance => instance;

	public static bool Supported => supportedDeviceTypes.Contains(SystemInfo.graphicsDeviceType);

	public static bool Enabled
	{
		get
		{
			return _enabled;
		}
		set
		{
			_enabled = value;
			if ((Object)(object)instance != (Object)null)
			{
				((Behaviour)instance).enabled = value;
			}
		}
	}

	public static bool SafeMode
	{
		get
		{
			return _safeMode;
		}
		set
		{
			_safeMode = value;
		}
	}

	public static DebugFilter DebugShow
	{
		get
		{
			return _debugShow;
		}
		set
		{
			_debugShow = value;
		}
	}

	public bool HiZReady
	{
		get
		{
			if ((Object)(object)hiZTexture != (Object)null && hiZWidth > 0)
			{
				return hiZHeight > 0;
			}
			return false;
		}
	}

	private static void GrowStatePool()
	{
		for (int i = 0; i < 2048; i++)
		{
			statePool.Enqueue(new OccludeeState());
		}
	}

	private static OccludeeState Allocate()
	{
		if (statePool.Count == 0)
		{
			GrowStatePool();
		}
		return statePool.Dequeue();
	}

	private static void Release(OccludeeState state)
	{
		statePool.Enqueue(state);
	}

	private void Awake()
	{
		instance = this;
		camera = ((Component)this).GetComponent<Camera>();
		for (int i = 0; i < 6; i++)
		{
			frustumPropNames[i] = "_FrustumPlane" + i;
		}
	}

	private void OnEnable()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Invalid comparison between Unknown and I4
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Expected O, but got Unknown
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Expected O, but got Unknown
		if (!Enabled)
		{
			Enabled = false;
			return;
		}
		GraphicsDeviceType graphicsDeviceType;
		if (!Supported)
		{
			graphicsDeviceType = SystemInfo.graphicsDeviceType;
			Debug.LogWarning((object)("[OcclusionCulling] Disabled due to graphics device type " + ((object)(GraphicsDeviceType)(ref graphicsDeviceType)/*cast due to .constrained prefix*/).ToString() + " not supported."));
			Enabled = false;
			return;
		}
		usePixelShaderFallback = usePixelShaderFallback || !SystemInfo.supportsComputeShaders || (Object)(object)computeShader == (Object)null || !computeShader.HasKernel("compute_cull");
		useNativePath = (int)SystemInfo.graphicsDeviceType == 2 && SupportsNativePath();
		useAsyncReadAPI = !useNativePath && SystemInfo.supportsAsyncGPUReadback;
		if (!useNativePath && !useAsyncReadAPI)
		{
			graphicsDeviceType = SystemInfo.graphicsDeviceType;
			Debug.LogWarning((object)("[OcclusionCulling] Disabled due to unsupported Async GPU Reads on device " + ((object)(GraphicsDeviceType)(ref graphicsDeviceType)/*cast due to .constrained prefix*/).ToString()));
			Enabled = false;
			return;
		}
		for (int i = 0; i < staticOccludees.Count; i++)
		{
			staticChanged.Add(i);
		}
		for (int j = 0; j < dynamicOccludees.Count; j++)
		{
			dynamicChanged.Add(j);
		}
		if (usePixelShaderFallback)
		{
			fallbackMat = new Material(Shader.Find("Hidden/OcclusionCulling/Culling"))
			{
				hideFlags = (HideFlags)61
			};
		}
		staticSet.Attach(this);
		dynamicSet.Attach(this);
		gridSet.Attach(this);
		depthCopyMat = new Material(Shader.Find("Hidden/OcclusionCulling/DepthCopy"))
		{
			hideFlags = (HideFlags)61
		};
		InitializeHiZMap();
		UpdateCameraMatrices(starting: true);
	}

	private bool SupportsNativePath()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		bool result = true;
		try
		{
			OccludeeState.State states = default(OccludeeState.State);
			Color32 results = default(Color32);
			((Color32)(ref results))..ctor((byte)0, (byte)0, (byte)0, (byte)0);
			Vector4 zero = Vector4.zero;
			int bucket = 0;
			int changed = 0;
			int changedCount = 0;
			ProcessOccludees_Native(ref states, ref bucket, 0, ref results, 0, ref changed, ref changedCount, ref zero, 0f, 0u);
		}
		catch (EntryPointNotFoundException)
		{
			Debug.Log((object)"[OcclusionCulling] Fast native path not available. Reverting to managed fallback.");
			result = false;
		}
		return result;
	}

	private void OnDisable()
	{
		if ((Object)(object)fallbackMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)fallbackMat);
			fallbackMat = null;
		}
		if ((Object)(object)depthCopyMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)depthCopyMat);
			depthCopyMat = null;
		}
		staticSet.Dispose();
		dynamicSet.Dispose();
		gridSet.Dispose();
		FinalizeHiZMap();
	}

	public static void MakeAllVisible()
	{
		for (int i = 0; i < staticOccludees.Count; i++)
		{
			if (staticOccludees[i] != null)
			{
				staticOccludees[i].MakeVisible();
			}
		}
		for (int j = 0; j < dynamicOccludees.Count; j++)
		{
			if (dynamicOccludees[j] != null)
			{
				dynamicOccludees[j].MakeVisible();
			}
		}
	}

	private void Update()
	{
		if (!Enabled)
		{
			((Behaviour)this).enabled = false;
			return;
		}
		CheckResizeHiZMap();
		DebugUpdate();
		DebugDraw();
	}

	public static void RecursiveAddOccludees<T>(Transform transform, float minTimeVisible = 0.1f, bool isStatic = true, bool stickyGizmos = false) where T : Occludee
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Expected O, but got Unknown
		Renderer component = ((Component)transform).GetComponent<Renderer>();
		Collider component2 = ((Component)transform).GetComponent<Collider>();
		if ((Object)(object)component != (Object)null && (Object)(object)component2 != (Object)null)
		{
			T component3 = ((Component)component).gameObject.GetComponent<T>();
			component3 = (((Object)(object)component3 == (Object)null) ? ((Component)component).gameObject.AddComponent<T>() : component3);
			component3.minTimeVisible = minTimeVisible;
			component3.isStatic = isStatic;
			component3.stickyGizmos = stickyGizmos;
			component3.Register();
		}
		foreach (Transform item in transform)
		{
			RecursiveAddOccludees<T>(item, minTimeVisible, isStatic, stickyGizmos);
		}
	}

	private static int FindFreeSlot(SimpleList<OccludeeState> occludees, SimpleList<OccludeeState.State> states, Queue<int> recycled)
	{
		int result;
		if (recycled.Count > 0)
		{
			result = recycled.Dequeue();
		}
		else
		{
			if (occludees.Count == occludees.Capacity)
			{
				int num = Mathf.Min(occludees.Capacity + 2048, 1048576);
				if (num > 0)
				{
					occludees.Capacity = num;
					states.Capacity = num;
				}
			}
			if (occludees.Count < occludees.Capacity)
			{
				result = occludees.Count;
				occludees.Add(null);
				states.Add(default(OccludeeState.State));
			}
			else
			{
				result = -1;
			}
		}
		return result;
	}

	public static OccludeeState GetStateById(int id)
	{
		if (id >= 0 && id < 2097152)
		{
			bool num = id < 1048576;
			int index = (num ? id : (id - 1048576));
			if (num)
			{
				return staticOccludees[index];
			}
			return dynamicOccludees[index];
		}
		return null;
	}

	public static int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged = null)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		num = ((!isStatic) ? RegisterOccludee(center, radius, isVisible, minTimeVisible, isStatic, layer, onVisibilityChanged, dynamicOccludees, dynamicStates, dynamicRecycled, dynamicChanged, dynamicSet, dynamicVisibilityChanged) : RegisterOccludee(center, radius, isVisible, minTimeVisible, isStatic, layer, onVisibilityChanged, staticOccludees, staticStates, staticRecycled, staticChanged, staticSet, staticVisibilityChanged));
		if (!(num < 0 || isStatic))
		{
			return num + 1048576;
		}
		return num;
	}

	private static int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged, SimpleList<OccludeeState> occludees, SimpleList<OccludeeState.State> states, Queue<int> recycled, List<int> changed, BufferSet set, SimpleList<int> visibilityChanged)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		int num = FindFreeSlot(occludees, states, recycled);
		if (num >= 0)
		{
			Vector4 sphereBounds = default(Vector4);
			((Vector4)(ref sphereBounds))..ctor(center.x, center.y, center.z, radius);
			OccludeeState occludeeState = Allocate().Initialize(states, set, num, sphereBounds, isVisible, minTimeVisible, isStatic, layer, onVisibilityChanged);
			occludeeState.cell = RegisterToGrid(occludeeState);
			occludees[num] = occludeeState;
			changed.Add(num);
			if (states.array[num].isVisible != 0 != occludeeState.cell.isVisible)
			{
				visibilityChanged.Add(num);
			}
		}
		return num;
	}

	public static void UnregisterOccludee(int id)
	{
		if (id >= 0 && id < 2097152)
		{
			bool num = id < 1048576;
			int slot = (num ? id : (id - 1048576));
			if (num)
			{
				UnregisterOccludee(slot, staticOccludees, staticRecycled, staticChanged);
			}
			else
			{
				UnregisterOccludee(slot, dynamicOccludees, dynamicRecycled, dynamicChanged);
			}
		}
	}

	private static void UnregisterOccludee(int slot, SimpleList<OccludeeState> occludees, Queue<int> recycled, List<int> changed)
	{
		OccludeeState occludeeState = occludees[slot];
		UnregisterFromGrid(occludeeState);
		recycled.Enqueue(slot);
		changed.Add(slot);
		Release(occludeeState);
		occludees[slot] = null;
		occludeeState.Invalidate();
	}

	public static void UpdateDynamicOccludee(int id, Vector3 center, float radius)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		int num = id - 1048576;
		if (num >= 0 && num < 1048576)
		{
			dynamicStates.array[num].sphereBounds = new Vector4(center.x, center.y, center.z, radius);
			dynamicChanged.Add(num);
		}
	}

	private void UpdateBuffers(SimpleList<OccludeeState> occludees, SimpleList<OccludeeState.State> states, BufferSet set, List<int> changed, bool isStatic)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		int count = occludees.Count;
		bool flag = changed.Count > 0;
		set.CheckResize(count, 2048);
		for (int i = 0; i < changed.Count; i++)
		{
			int num = changed[i];
			OccludeeState occludeeState = occludees[num];
			if (occludeeState != null)
			{
				if (!isStatic)
				{
					UpdateInGrid(occludeeState);
				}
				set.inputData[num] = Color.op_Implicit(states[num].sphereBounds);
			}
			else
			{
				set.inputData[num] = Color.op_Implicit(Vector4.zero);
			}
		}
		changed.Clear();
		if (flag)
		{
			set.UploadData();
		}
	}

	private void UpdateCameraMatrices(bool starting = false)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		if (!starting)
		{
			prevViewProjMatrix = viewProjMatrix;
		}
		Matrix4x4 val = Matrix4x4.Perspective(camera.fieldOfView, camera.aspect, camera.nearClipPlane, camera.farClipPlane);
		viewMatrix = camera.worldToCameraMatrix;
		projMatrix = GL.GetGPUProjectionMatrix(val, false);
		viewProjMatrix = projMatrix * viewMatrix;
		invViewProjMatrix = Matrix4x4.Inverse(viewProjMatrix);
		if (starting)
		{
			prevViewProjMatrix = viewProjMatrix;
		}
	}

	private void OnPreCull()
	{
		UpdateCameraMatrices();
		GenerateHiZMipChain();
		PrepareAndDispatch();
		IssueRead();
		if (grid.Size <= gridSet.resultData.Length)
		{
			RetrieveAndApplyVisibility();
		}
		else
		{
			Debug.LogWarning((object)("[OcclusionCulling] Grid size and result capacity are out of sync: " + grid.Size + ", " + gridSet.resultData.Length));
		}
	}

	private void OnPostRender()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		bool sRGBWrite = GL.sRGBWrite;
		RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
		RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
		GrabDepthTexture();
		Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
		GL.sRGBWrite = sRGBWrite;
	}

	private float[] MatrixToFloatArray(Matrix4x4 m)
	{
		int i = 0;
		int num = 0;
		for (; i < 4; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				matrixToFloatTemp[num++] = ((Matrix4x4)(ref m))[j, i];
			}
		}
		return matrixToFloatTemp;
	}

	private void PrepareAndDispatch()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)hiZWidth, (float)hiZHeight);
		ExtractFrustum(viewProjMatrix, ref frustumPlanes);
		bool flag = true;
		if (usePixelShaderFallback)
		{
			fallbackMat.SetTexture("_HiZMap", (Texture)(object)hiZTexture);
			fallbackMat.SetFloat("_HiZMaxLod", (float)(hiZLevelCount - 1));
			fallbackMat.SetMatrix("_ViewMatrix", viewMatrix);
			fallbackMat.SetMatrix("_ProjMatrix", projMatrix);
			fallbackMat.SetMatrix("_ViewProjMatrix", viewProjMatrix);
			fallbackMat.SetVector("_CameraWorldPos", Vector4.op_Implicit(((Component)this).transform.position));
			fallbackMat.SetVector("_ViewportSize", Vector4.op_Implicit(val));
			fallbackMat.SetFloat("_FrustumCull", flag ? 0f : 1f);
			for (int i = 0; i < 6; i++)
			{
				fallbackMat.SetVector(frustumPropNames[i], frustumPlanes[i]);
			}
		}
		else
		{
			computeShader.SetTexture(0, "_HiZMap", (Texture)(object)hiZTexture);
			computeShader.SetFloat("_HiZMaxLod", (float)(hiZLevelCount - 1));
			computeShader.SetFloats("_ViewMatrix", MatrixToFloatArray(viewMatrix));
			computeShader.SetFloats("_ProjMatrix", MatrixToFloatArray(projMatrix));
			computeShader.SetFloats("_ViewProjMatrix", MatrixToFloatArray(viewProjMatrix));
			computeShader.SetVector("_CameraWorldPos", Vector4.op_Implicit(((Component)this).transform.position));
			computeShader.SetVector("_ViewportSize", Vector4.op_Implicit(val));
			computeShader.SetFloat("_FrustumCull", flag ? 0f : 1f);
			for (int j = 0; j < 6; j++)
			{
				computeShader.SetVector(frustumPropNames[j], frustumPlanes[j]);
			}
		}
		if (staticOccludees.Count > 0)
		{
			UpdateBuffers(staticOccludees, staticStates, staticSet, staticChanged, isStatic: true);
			staticSet.Dispatch(staticOccludees.Count);
		}
		if (dynamicOccludees.Count > 0)
		{
			UpdateBuffers(dynamicOccludees, dynamicStates, dynamicSet, dynamicChanged, isStatic: false);
			dynamicSet.Dispatch(dynamicOccludees.Count);
		}
		UpdateGridBuffers();
		gridSet.Dispatch(grid.Size);
	}

	private void IssueRead()
	{
		if (staticOccludees.Count > 0)
		{
			staticSet.IssueRead();
		}
		if (dynamicOccludees.Count > 0)
		{
			dynamicSet.IssueRead();
		}
		if (grid.Count > 0)
		{
			gridSet.IssueRead();
		}
		GL.IssuePluginEvent(Graphics.GetRenderEventFunc(), 2);
	}

	public void ResetTiming(SmartList bucket)
	{
		for (int i = 0; i < bucket.Size; i++)
		{
			OccludeeState occludeeState = bucket[i];
			if (occludeeState != null)
			{
				occludeeState.states.array[occludeeState.slot].waitTime = 0f;
			}
		}
	}

	public void ResetTiming()
	{
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell != null)
			{
				ResetTiming(cell.staticBucket);
				ResetTiming(cell.dynamicBucket);
			}
		}
	}

	private void ProcessCallbacks(SimpleList<OccludeeState> occludees, SimpleList<OccludeeState.State> states, SimpleList<int> changed)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Expected O, but got Unknown
		for (int i = 0; i < changed.Count; i++)
		{
			int num = changed[i];
			OccludeeState occludeeState = occludees[num];
			if (occludeeState != null)
			{
				bool flag = states.array[num].isVisible == 0;
				OnVisibilityChanged onVisibilityChanged = occludeeState.onVisibilityChanged;
				if (onVisibilityChanged != null && (Object)onVisibilityChanged.Target != (Object)null)
				{
					onVisibilityChanged(flag);
				}
				if (occludeeState.slot >= 0)
				{
					states.array[occludeeState.slot].isVisible = (byte)(flag ? 1 : 0);
				}
			}
		}
		changed.Clear();
	}

	public void RetrieveAndApplyVisibility()
	{
		if (staticOccludees.Count > 0)
		{
			staticSet.GetResults();
		}
		if (dynamicOccludees.Count > 0)
		{
			dynamicSet.GetResults();
		}
		if (grid.Count > 0)
		{
			gridSet.GetResults();
		}
		if (debugSettings.showAllVisible)
		{
			for (int i = 0; i < staticSet.resultData.Length; i++)
			{
				staticSet.resultData[i].r = 1;
			}
			for (int j = 0; j < dynamicSet.resultData.Length; j++)
			{
				dynamicSet.resultData[j].r = 1;
			}
			for (int k = 0; k < gridSet.resultData.Length; k++)
			{
				gridSet.resultData[k].r = 1;
			}
		}
		staticVisibilityChanged.EnsureCapacity(staticOccludees.Count);
		dynamicVisibilityChanged.EnsureCapacity(dynamicOccludees.Count);
		float time = Time.time;
		uint frameCount = (uint)Time.frameCount;
		if (!Passthrough)
		{
			if (useNativePath)
			{
				ApplyVisibility_Native(time, frameCount);
			}
			else
			{
				ApplyVisibility_Fast(time, frameCount);
			}
		}
		else
		{
			ApplyVisibility_Passthrough(time, frameCount);
		}
		ProcessCallbacks(staticOccludees, staticStates, staticVisibilityChanged);
		ProcessCallbacks(dynamicOccludees, dynamicStates, dynamicVisibilityChanged);
	}

	public static bool DebugFilterIsDynamic(int filter)
	{
		if (filter != 1)
		{
			return filter == 4;
		}
		return true;
	}

	public static bool DebugFilterIsStatic(int filter)
	{
		if (filter != 2)
		{
			return filter == 4;
		}
		return true;
	}

	public static bool DebugFilterIsGrid(int filter)
	{
		if (filter != 3)
		{
			return filter == 4;
		}
		return true;
	}

	private void DebugInitialize()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		debugMipMat = new Material(Shader.Find("Hidden/OcclusionCulling/DebugMip"))
		{
			hideFlags = (HideFlags)61
		};
	}

	private void DebugShutdown()
	{
		if ((Object)(object)debugMipMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)debugMipMat);
			debugMipMat = null;
		}
	}

	private void DebugUpdate()
	{
		if (HiZReady)
		{
			debugSettings.showMainLod = Mathf.Clamp(debugSettings.showMainLod, 0, hiZLevels.Length - 1);
		}
	}

	private void DebugDraw()
	{
	}

	public static void NormalizePlane(ref Vector4 plane)
	{
		float num = Mathf.Sqrt(plane.x * plane.x + plane.y * plane.y + plane.z * plane.z);
		plane.x /= num;
		plane.y /= num;
		plane.z /= num;
		plane.w /= num;
	}

	public static void ExtractFrustum(Matrix4x4 viewProjMatrix, ref Vector4[] planes)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		planes[0].x = viewProjMatrix.m30 + viewProjMatrix.m00;
		planes[0].y = viewProjMatrix.m31 + viewProjMatrix.m01;
		planes[0].z = viewProjMatrix.m32 + viewProjMatrix.m02;
		planes[0].w = viewProjMatrix.m33 + viewProjMatrix.m03;
		NormalizePlane(ref planes[0]);
		planes[1].x = viewProjMatrix.m30 - viewProjMatrix.m00;
		planes[1].y = viewProjMatrix.m31 - viewProjMatrix.m01;
		planes[1].z = viewProjMatrix.m32 - viewProjMatrix.m02;
		planes[1].w = viewProjMatrix.m33 - viewProjMatrix.m03;
		NormalizePlane(ref planes[1]);
		planes[2].x = viewProjMatrix.m30 - viewProjMatrix.m10;
		planes[2].y = viewProjMatrix.m31 - viewProjMatrix.m11;
		planes[2].z = viewProjMatrix.m32 - viewProjMatrix.m12;
		planes[2].w = viewProjMatrix.m33 - viewProjMatrix.m13;
		NormalizePlane(ref planes[2]);
		planes[3].x = viewProjMatrix.m30 + viewProjMatrix.m10;
		planes[3].y = viewProjMatrix.m31 + viewProjMatrix.m11;
		planes[3].z = viewProjMatrix.m32 + viewProjMatrix.m12;
		planes[3].w = viewProjMatrix.m33 + viewProjMatrix.m13;
		NormalizePlane(ref planes[3]);
		planes[4].x = viewProjMatrix.m20;
		planes[4].y = viewProjMatrix.m21;
		planes[4].z = viewProjMatrix.m22;
		planes[4].w = viewProjMatrix.m23;
		NormalizePlane(ref planes[4]);
		planes[5].x = viewProjMatrix.m30 - viewProjMatrix.m20;
		planes[5].y = viewProjMatrix.m31 - viewProjMatrix.m21;
		planes[5].z = viewProjMatrix.m32 - viewProjMatrix.m22;
		planes[5].w = viewProjMatrix.m33 - viewProjMatrix.m23;
		NormalizePlane(ref planes[5]);
	}

	public void CheckResizeHiZMap()
	{
		int pixelWidth = camera.pixelWidth;
		int pixelHeight = camera.pixelHeight;
		if (pixelWidth <= 0 || pixelHeight <= 0)
		{
			return;
		}
		int num = pixelWidth / 4;
		int num2 = pixelHeight / 4;
		if (hiZLevels == null || hiZWidth != num || hiZHeight != num2)
		{
			InitializeHiZMap(num, num2);
			hiZWidth = num;
			hiZHeight = num2;
			if (debugSettings.log)
			{
				Debug.Log((object)("[OcclusionCulling] Resized HiZ Map to " + hiZWidth + " x " + hiZHeight));
			}
		}
	}

	private void InitializeHiZMap()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected O, but got Unknown
		Shader val = Shader.Find("Hidden/OcclusionCulling/DepthDownscale");
		Shader val2 = Shader.Find("Hidden/OcclusionCulling/BlitCopy");
		downscaleMat = new Material(val)
		{
			hideFlags = (HideFlags)61
		};
		blitCopyMat = new Material(val2)
		{
			hideFlags = (HideFlags)61
		};
		CheckResizeHiZMap();
	}

	private void FinalizeHiZMap()
	{
		DestroyHiZMap();
		if ((Object)(object)downscaleMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)downscaleMat);
			downscaleMat = null;
		}
		if ((Object)(object)blitCopyMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)blitCopyMat);
			blitCopyMat = null;
		}
	}

	private void InitializeHiZMap(int width, int height)
	{
		DestroyHiZMap();
		width = Mathf.Clamp(width, 1, 65536);
		height = Mathf.Clamp(height, 1, 65536);
		int num = Mathf.Min(width, height);
		hiZLevelCount = (int)(Mathf.Log((float)num, 2f) + 1f);
		hiZLevels = (RenderTexture[])(object)new RenderTexture[hiZLevelCount];
		depthTexture = CreateDepthTexture("DepthTex", width, height);
		hiZTexture = CreateDepthTexture("HiZMapTex", width, height, mips: true);
		for (int i = 0; i < hiZLevelCount; i++)
		{
			hiZLevels[i] = CreateDepthTextureMip("HiZMap" + i, width, height, i);
		}
	}

	private void DestroyHiZMap()
	{
		if ((Object)(object)depthTexture != (Object)null)
		{
			RenderTexture.active = null;
			Object.DestroyImmediate((Object)(object)depthTexture);
			depthTexture = null;
		}
		if ((Object)(object)hiZTexture != (Object)null)
		{
			RenderTexture.active = null;
			Object.DestroyImmediate((Object)(object)hiZTexture);
			hiZTexture = null;
		}
		if (hiZLevels != null)
		{
			for (int i = 0; i < hiZLevels.Length; i++)
			{
				Object.DestroyImmediate((Object)(object)hiZLevels[i]);
			}
			hiZLevels = null;
		}
	}

	private RenderTexture CreateDepthTexture(string name, int width, int height, bool mips = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown
		RenderTexture val = new RenderTexture(width, height, 0, (RenderTextureFormat)14, (RenderTextureReadWrite)1)
		{
			name = name,
			useMipMap = mips,
			autoGenerateMips = false,
			wrapMode = (TextureWrapMode)1,
			filterMode = (FilterMode)0
		};
		val.Create();
		return val;
	}

	private RenderTexture CreateDepthTextureMip(string name, int width, int height, int mip)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Expected O, but got Unknown
		int num = width >> mip;
		int num2 = height >> mip;
		RenderTexture val = new RenderTexture(num, num2, 0, (RenderTextureFormat)14, (RenderTextureReadWrite)1)
		{
			name = name,
			useMipMap = false,
			wrapMode = (TextureWrapMode)1,
			filterMode = (FilterMode)0
		};
		val.Create();
		return val;
	}

	public void GrabDepthTexture()
	{
		if ((Object)(object)depthTexture != (Object)null)
		{
			Graphics.Blit((Texture)null, depthTexture, depthCopyMat, 0);
		}
	}

	public void GenerateHiZMipChain()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (HiZReady)
		{
			bool flag = true;
			depthCopyMat.SetMatrix("_CameraReprojection", prevViewProjMatrix * invViewProjMatrix);
			depthCopyMat.SetFloat("_FrustumNoDataDepth", flag ? 1f : 0f);
			Graphics.Blit((Texture)(object)depthTexture, hiZLevels[0], depthCopyMat, 1);
			for (int i = 1; i < hiZLevels.Length; i++)
			{
				RenderTexture val = hiZLevels[i - 1];
				RenderTexture val2 = hiZLevels[i];
				int num = (((((Texture)val).width & 1) != 0 || (((Texture)val).height & 1) != 0) ? 1 : 0);
				downscaleMat.SetTexture("_MainTex", (Texture)(object)val);
				Graphics.Blit((Texture)(object)val, val2, downscaleMat, num);
			}
			for (int j = 0; j < hiZLevels.Length; j++)
			{
				Graphics.SetRenderTarget(hiZTexture, j);
				Graphics.Blit((Texture)(object)hiZLevels[j], blitCopyMat);
			}
		}
	}

	private void DebugDrawGizmos()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		Camera component = ((Component)this).GetComponent<Camera>();
		Gizmos.color = new Color(0.75f, 0.75f, 0f, 0.5f);
		Gizmos.matrix = Matrix4x4.TRS(((Component)this).transform.position, ((Component)this).transform.rotation, Vector3.one);
		Gizmos.DrawFrustum(Vector3.zero, component.fieldOfView, component.farClipPlane, component.nearClipPlane, component.aspect);
		Gizmos.color = Color.red;
		Gizmos.matrix = Matrix4x4.identity;
		Matrix4x4 worldToCameraMatrix = component.worldToCameraMatrix;
		Matrix4x4 val = GL.GetGPUProjectionMatrix(component.projectionMatrix, false) * worldToCameraMatrix;
		Vector4[] planes = (Vector4[])(object)new Vector4[6];
		ExtractFrustum(val, ref planes);
		for (int i = 0; i < planes.Length; i++)
		{
			Vector3 val2 = new Vector3(planes[i].x, planes[i].y, planes[i].z);
			float w = planes[i].w;
			Vector3 val3 = -val2 * w;
			Gizmos.DrawLine(val3, val3 * 2f);
		}
	}

	private static int floor(float x)
	{
		int num = (int)x;
		if (!(x < (float)num))
		{
			return num;
		}
		return num - 1;
	}

	public static Cell RegisterToGrid(OccludeeState occludee)
	{
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		int num = floor(occludee.states.array[occludee.slot].sphereBounds.x * 0.01f);
		int num2 = floor(occludee.states.array[occludee.slot].sphereBounds.y * 0.01f);
		int num3 = floor(occludee.states.array[occludee.slot].sphereBounds.z * 0.01f);
		int num4 = Mathf.Clamp(num, -1048575, 1048575);
		int num5 = Mathf.Clamp(num2, -1048575, 1048575);
		int num6 = Mathf.Clamp(num3, -1048575, 1048575);
		long num7 = ((num4 >= 0) ? num4 : (num4 + 1048575));
		ulong num8 = (ulong)((num5 >= 0) ? num5 : (num5 + 1048575));
		ulong num9 = (ulong)((num6 >= 0) ? num6 : (num6 + 1048575));
		ulong key = (ulong)(num7 << 42) | (num8 << 21) | num9;
		Cell value;
		bool num10 = grid.TryGetValue(key, out value);
		if (!num10)
		{
			Vector3 val = new Vector3
			{
				x = (float)num * 100f + 50f,
				y = (float)num2 * 100f + 50f,
				z = (float)num3 * 100f + 50f
			};
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(100f, 100f, 100f);
			value = grid.Add(key).Initialize(num, num2, num3, new Bounds(val, val2));
		}
		SmartList smartList = (occludee.isStatic ? value.staticBucket : value.dynamicBucket);
		if (!num10 || !smartList.Contains(occludee))
		{
			occludee.cell = value;
			smartList.Add(occludee);
			gridChanged.Enqueue(value);
		}
		return value;
	}

	public static void UpdateInGrid(OccludeeState occludee)
	{
		int num = floor(occludee.states.array[occludee.slot].sphereBounds.x * 0.01f);
		int num2 = floor(occludee.states.array[occludee.slot].sphereBounds.y * 0.01f);
		int num3 = floor(occludee.states.array[occludee.slot].sphereBounds.z * 0.01f);
		if (num != occludee.cell.x || num2 != occludee.cell.y || num3 != occludee.cell.z)
		{
			UnregisterFromGrid(occludee);
			RegisterToGrid(occludee);
		}
	}

	public static void UnregisterFromGrid(OccludeeState occludee)
	{
		Cell cell = occludee.cell;
		SmartList obj = (occludee.isStatic ? cell.staticBucket : cell.dynamicBucket);
		gridChanged.Enqueue(cell);
		obj.Remove(occludee);
		if (cell.staticBucket.Count == 0 && cell.dynamicBucket.Count == 0)
		{
			grid.Remove(cell);
			cell.Reset();
		}
		occludee.cell = null;
	}

	public void UpdateGridBuffers()
	{
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		if (gridSet.CheckResize(grid.Size, 256))
		{
			if (debugSettings.log)
			{
				Debug.Log((object)("[OcclusionCulling] Resized grid to " + grid.Size));
			}
			for (int i = 0; i < grid.Size; i++)
			{
				if (grid[i] != null)
				{
					gridChanged.Enqueue(grid[i]);
				}
			}
		}
		bool flag = gridChanged.Count > 0;
		while (gridChanged.Count > 0)
		{
			Cell cell = gridChanged.Dequeue();
			gridSet.inputData[cell.hashedPoolIndex] = Color.op_Implicit(cell.sphereBounds);
		}
		if (flag)
		{
			gridSet.UploadData();
		}
	}

	private static bool FrustumCull(Vector4[] planes, Vector4 testSphere)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 6; i++)
		{
			if (planes[i].x * testSphere.x + planes[i].y * testSphere.y + planes[i].z * testSphere.z + planes[i].w < 0f - testSphere.w)
			{
				return false;
			}
		}
		return true;
	}

	private static int ProcessOccludees_Safe(SimpleList<OccludeeState.State> states, SmartList bucket, Color32[] results, SimpleList<int> changed, Vector4[] frustumPlanes, float time, uint frame)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < bucket.Size; i++)
		{
			OccludeeState occludeeState = bucket[i];
			if (occludeeState == null || occludeeState.slot >= results.Length)
			{
				continue;
			}
			int slot = occludeeState.slot;
			OccludeeState.State value = states[slot];
			bool flag = FrustumCull(frustumPlanes, value.sphereBounds);
			bool flag2 = results[slot].r > 0 && flag;
			if (flag2 || frame < value.waitFrame)
			{
				value.waitTime = time + value.minTimeVisible;
			}
			if (!flag2)
			{
				flag2 = time < value.waitTime;
			}
			if (flag2 != (value.isVisible != 0))
			{
				if (value.callback != 0)
				{
					changed.Add(slot);
				}
				else
				{
					value.isVisible = (byte)(flag2 ? 1 : 0);
				}
			}
			states[slot] = value;
			num += value.isVisible;
		}
		return num;
	}

	private static int ProcessOccludees_Fast(OccludeeState.State[] states, int[] bucket, int bucketCount, Color32[] results, int resultCount, int[] changed, ref int changedCount, Vector4[] frustumPlanes, float time, uint frame)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < bucketCount; i++)
		{
			int num2 = bucket[i];
			if (num2 < 0 || num2 >= resultCount || states[num2].active == 0)
			{
				continue;
			}
			OccludeeState.State state = states[num2];
			bool flag = FrustumCull(frustumPlanes, state.sphereBounds);
			bool flag2 = results[num2].r > 0 && flag;
			if (flag2 || frame < state.waitFrame)
			{
				state.waitTime = time + state.minTimeVisible;
			}
			if (!flag2)
			{
				flag2 = time < state.waitTime;
			}
			if (flag2 != (state.isVisible != 0))
			{
				if (state.callback != 0)
				{
					changed[changedCount++] = num2;
				}
				else
				{
					state.isVisible = (byte)(flag2 ? 1 : 0);
				}
			}
			states[num2] = state;
			num += ((!flag2) ? 1 : 0);
		}
		return num;
	}

	[DllImport("Renderer", EntryPoint = "CULL_ProcessOccludees")]
	private static extern int ProcessOccludees_Native(ref OccludeeState.State states, ref int bucket, int bucketCount, ref Color32 results, int resultCount, ref int changed, ref int changedCount, ref Vector4 frustumPlanes, float time, uint frame);

	private void ApplyVisibility_Safe(float time, uint frame)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		bool ready = staticSet.Ready;
		bool ready2 = dynamicSet.Ready;
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell == null || gridSet.resultData.Length == 0)
			{
				continue;
			}
			bool flag = FrustumCull(frustumPlanes, cell.sphereBounds);
			bool flag2 = gridSet.resultData[i].r > 0 && flag;
			if (cell.isVisible || flag2)
			{
				int num = 0;
				int num2 = 0;
				if (ready && cell.staticBucket.Count > 0)
				{
					num = ProcessOccludees_Safe(staticStates, cell.staticBucket, staticSet.resultData, staticVisibilityChanged, frustumPlanes, time, frame);
				}
				if (ready2 && cell.dynamicBucket.Count > 0)
				{
					num2 = ProcessOccludees_Safe(dynamicStates, cell.dynamicBucket, dynamicSet.resultData, dynamicVisibilityChanged, frustumPlanes, time, frame);
				}
				cell.isVisible = flag2 || num < cell.staticBucket.Count || num2 < cell.dynamicBucket.Count;
			}
		}
	}

	private void ApplyVisibility_Fast(float time, uint frame)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		bool ready = staticSet.Ready;
		bool ready2 = dynamicSet.Ready;
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell == null || gridSet.resultData.Length == 0)
			{
				continue;
			}
			bool flag = FrustumCull(frustumPlanes, cell.sphereBounds);
			bool flag2 = gridSet.resultData[i].r > 0 && flag;
			if (cell.isVisible || flag2)
			{
				int num = 0;
				int num2 = 0;
				if (ready && cell.staticBucket.Count > 0)
				{
					num = ProcessOccludees_Fast(staticStates.array, cell.staticBucket.Slots, cell.staticBucket.Size, staticSet.resultData, staticSet.resultData.Length, staticVisibilityChanged.array, ref staticVisibilityChanged.count, frustumPlanes, time, frame);
				}
				if (ready2 && cell.dynamicBucket.Count > 0)
				{
					num2 = ProcessOccludees_Fast(dynamicStates.array, cell.dynamicBucket.Slots, cell.dynamicBucket.Size, dynamicSet.resultData, dynamicSet.resultData.Length, dynamicVisibilityChanged.array, ref dynamicVisibilityChanged.count, frustumPlanes, time, frame);
				}
				cell.isVisible = flag2 || num < cell.staticBucket.Count || num2 < cell.dynamicBucket.Count;
			}
		}
	}

	private void ApplyVisibility_Native(float time, uint frame)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		bool ready = staticSet.Ready;
		bool ready2 = dynamicSet.Ready;
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell == null || gridSet.resultData.Length == 0)
			{
				continue;
			}
			bool flag = FrustumCull(frustumPlanes, cell.sphereBounds);
			bool flag2 = gridSet.resultData[i].r > 0 && flag;
			if (cell.isVisible || flag2)
			{
				int num = 0;
				int num2 = 0;
				if (ready && cell.staticBucket.Count > 0)
				{
					num = ProcessOccludees_Native(ref staticStates.array[0], ref cell.staticBucket.Slots[0], cell.staticBucket.Size, ref staticSet.resultData[0], staticSet.resultData.Length, ref staticVisibilityChanged.array[0], ref staticVisibilityChanged.count, ref frustumPlanes[0], time, frame);
				}
				if (ready2 && cell.dynamicBucket.Count > 0)
				{
					num2 = ProcessOccludees_Native(ref dynamicStates.array[0], ref cell.dynamicBucket.Slots[0], cell.dynamicBucket.Size, ref dynamicSet.resultData[0], dynamicSet.resultData.Length, ref dynamicVisibilityChanged.array[0], ref dynamicVisibilityChanged.count, ref frustumPlanes[0], time, frame);
				}
				cell.isVisible = flag2 || num < cell.staticBucket.Count || num2 < cell.dynamicBucket.Count;
			}
		}
	}

	private void ApplyVisibility_Passthrough(float time, uint frame)
	{
		OccludeeState.State[] array = staticStates.array;
		OccludeeState.State[] array2 = dynamicStates.array;
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell == null)
			{
				continue;
			}
			int[] slots = cell.staticBucket.Slots;
			int size = cell.staticBucket.Size;
			int num = staticSet.resultData.Length;
			for (int j = 0; j < size; j++)
			{
				int num2 = slots[j];
				if (num2 >= 0 && num2 < num && array[num2].active != 0 && array[num2].isVisible == 0)
				{
					if (array[num2].callback != 0)
					{
						staticVisibilityChanged.array[staticVisibilityChanged.count++] = num2;
					}
					else
					{
						array[num2].isVisible = 1;
					}
				}
			}
			int[] slots2 = cell.dynamicBucket.Slots;
			int size2 = cell.dynamicBucket.Size;
			int num3 = dynamicSet.resultData.Length;
			for (int k = 0; k < size2; k++)
			{
				int num4 = slots2[k];
				if (num4 >= 0 && num4 < num3 && array2[num4].active != 0 && array2[num4].isVisible == 0)
				{
					if (array2[num4].callback != 0)
					{
						dynamicVisibilityChanged.array[dynamicVisibilityChanged.count++] = num4;
					}
					else
					{
						array2[num4].isVisible = 1;
					}
				}
			}
			cell.isVisible = true;
		}
	}
}


using System;
using System.Collections.Generic;
using RustNative;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

public class BufferSet
{
	public ComputeBuffer inputBuffer;

	public ComputeBuffer resultBuffer;

	public int width;

	public int height;

	public int capacity;

	public int count;

	public Texture2D inputTexture;

	public RenderTexture resultTexture;

	public Texture2D resultReadTexture;

	public Color[] inputData = (Color[])(object)new Color[0];

	public Color32[] resultData = (Color32[])(object)new Color32[0];

	private OcclusionCulling culling;

	private const int MaxAsyncGPUReadbackRequests = 10;

	private Queue<AsyncGPUReadbackRequest> asyncRequests = new Queue<AsyncGPUReadbackRequest>();

	public IntPtr readbackInst = IntPtr.Zero;

	public bool Ready => resultData.Length != 0;

	public void Attach(OcclusionCulling culling)
	{
		this.culling = culling;
	}

	public void Dispose(bool data = true)
	{
		if (inputBuffer != null)
		{
			inputBuffer.Dispose();
			inputBuffer = null;
		}
		if (resultBuffer != null)
		{
			resultBuffer.Dispose();
			resultBuffer = null;
		}
		if ((Object)(object)inputTexture != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)inputTexture);
			inputTexture = null;
		}
		if ((Object)(object)resultTexture != (Object)null)
		{
			RenderTexture.active = null;
			resultTexture.Release();
			Object.DestroyImmediate((Object)(object)resultTexture);
			resultTexture = null;
		}
		if ((Object)(object)resultReadTexture != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)resultReadTexture);
			resultReadTexture = null;
		}
		if (readbackInst != IntPtr.Zero)
		{
			BufferReadback.Destroy(readbackInst);
			readbackInst = IntPtr.Zero;
		}
		if (data)
		{
			inputData = (Color[])(object)new Color[0];
			resultData = (Color32[])(object)new Color32[0];
			capacity = 0;
			count = 0;
		}
	}

	public bool CheckResize(int count, int granularity)
	{
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Expected O, but got Unknown
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Expected O, but got Unknown
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Expected O, but got Unknown
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Expected O, but got Unknown
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Expected O, but got Unknown
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Expected I4, but got Unknown
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		if (count > capacity || (culling.usePixelShaderFallback && (Object)(object)resultTexture != (Object)null && !resultTexture.IsCreated()))
		{
			Dispose(data: false);
			int num = capacity;
			int num2 = count / granularity * granularity + granularity;
			if (culling.usePixelShaderFallback)
			{
				width = Mathf.CeilToInt(Mathf.Sqrt((float)num2));
				height = Mathf.CeilToInt((float)num2 / (float)width);
				inputTexture = new Texture2D(width, height, (TextureFormat)20, false, true);
				((Object)inputTexture).name = "_Input";
				((Texture)inputTexture).filterMode = (FilterMode)0;
				((Texture)inputTexture).wrapMode = (TextureWrapMode)1;
				resultTexture = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
				((Object)resultTexture).name = "_Result";
				((Texture)resultTexture).filterMode = (FilterMode)0;
				((Texture)resultTexture).wrapMode = (TextureWrapMode)1;
				resultTexture.useMipMap = false;
				resultTexture.Create();
				resultReadTexture = new Texture2D(width, height, (TextureFormat)5, false, true);
				((Object)resultReadTexture).name = "_ResultRead";
				((Texture)resultReadTexture).filterMode = (FilterMode)0;
				((Texture)resultReadTexture).wrapMode = (TextureWrapMode)1;
				if (!culling.useAsyncReadAPI)
				{
					readbackInst = BufferReadback.CreateForTexture(((Texture)resultTexture).GetNativeTexturePtr(), (uint)width, (uint)height, (uint)(int)resultTexture.format);
				}
				capacity = width * height;
			}
			else
			{
				inputBuffer = new ComputeBuffer(num2, 16);
				resultBuffer = new ComputeBuffer(num2, 4);
				if (!culling.useAsyncReadAPI)
				{
					uint num3 = (uint)(capacity * 4);
					readbackInst = BufferReadback.CreateForBuffer(resultBuffer.GetNativeBufferPtr(), num3);
				}
				capacity = num2;
			}
			Array.Resize(ref inputData, capacity);
			Array.Resize(ref resultData, capacity);
			Color32 val = default(Color32);
			((Color32)(ref val))..ctor(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
			for (int i = num; i < capacity; i++)
			{
				resultData[i] = val;
			}
			this.count = count;
			return true;
		}
		return false;
	}

	public void UploadData()
	{
		if (culling.usePixelShaderFallback)
		{
			inputTexture.SetPixels(inputData);
			inputTexture.Apply();
		}
		else
		{
			inputBuffer.SetData((Array)inputData);
		}
	}

	private int AlignDispatchSize(int dispatchSize)
	{
		return (dispatchSize + 63) / 64;
	}

	public void Dispatch(int count)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (culling.usePixelShaderFallback)
		{
			RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
			RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
			culling.fallbackMat.SetTexture("_Input", (Texture)(object)inputTexture);
			Graphics.Blit((Texture)(object)inputTexture, resultTexture, culling.fallbackMat, 0);
			Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
		}
		else if (inputBuffer != null)
		{
			culling.computeShader.SetBuffer(0, "_Input", inputBuffer);
			culling.computeShader.SetBuffer(0, "_Result", resultBuffer);
			culling.computeShader.Dispatch(0, AlignDispatchSize(count), 1, 1);
		}
	}

	public void IssueRead()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (SafeMode)
		{
			return;
		}
		if (culling.useAsyncReadAPI)
		{
			if (asyncRequests.Count < 10)
			{
				AsyncGPUReadbackRequest item = ((!culling.usePixelShaderFallback) ? AsyncGPUReadback.Request(resultBuffer, (Action<AsyncGPUReadbackRequest>)null) : AsyncGPUReadback.Request((Texture)(object)resultTexture, 0, (Action<AsyncGPUReadbackRequest>)null));
				asyncRequests.Enqueue(item);
			}
		}
		else if (readbackInst != IntPtr.Zero)
		{
			BufferReadback.IssueRead(readbackInst);
		}
	}

	public void GetResults()
	{
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (resultData == null || resultData.Length == 0)
		{
			return;
		}
		if (!SafeMode)
		{
			if (culling.useAsyncReadAPI)
			{
				while (asyncRequests.Count > 0)
				{
					AsyncGPUReadbackRequest val = asyncRequests.Peek();
					if (((AsyncGPUReadbackRequest)(ref val)).hasError)
					{
						asyncRequests.Dequeue();
						continue;
					}
					if (((AsyncGPUReadbackRequest)(ref val)).done)
					{
						NativeArray<Color32> data = ((AsyncGPUReadbackRequest)(ref val)).GetData<Color32>(0);
						for (int i = 0; i < data.Length; i++)
						{
							resultData[i] = data[i];
						}
						asyncRequests.Dequeue();
						continue;
					}
					break;
				}
			}
			else if (readbackInst != IntPtr.Zero)
			{
				BufferReadback.GetData(readbackInst, ref resultData[0]);
			}
		}
		else if (culling.usePixelShaderFallback)
		{
			RenderTexture.active = resultTexture;
			resultReadTexture.ReadPixels(new Rect(0f, 0f, (float)width, (float)height), 0, 0);
			resultReadTexture.Apply();
			Array.Copy(resultReadTexture.GetPixels32(), resultData, resultData.Length);
		}
		else
		{
			resultBuffer.GetData((Array)resultData);
		}
	}
}


public delegate void OnVisibilityChanged(bool visible);


public enum DebugFilter
{
	Off,
	Dynamic,
	Static,
	Grid,
	All
}


using System;

[Flags]
public enum DebugMask
{
	Off = 0,
	Dynamic = 1,
	Static = 2,
	Grid = 4,
	All = 7
}


using System;
using UnityEngine;

[Serializable]
public class DebugSettings
{
	public bool log;

	public bool showAllVisible;

	public bool showMipChain;

	public bool showMain;

	public int showMainLod;

	public bool showFallback;

	public bool showStats;

	public bool showScreenBounds;

	public DebugMask showMask;

	public LayerMask layerFilter = LayerMask.op_Implicit(-1);
}


public class HashedPoolValue
{
	public ulong hashedPoolKey = ulong.MaxValue;

	public int hashedPoolIndex = -1;
}


using System.Collections.Generic;

public class HashedPool<TValueType> where TValueType : HashedPoolValue, new()
{
	private int granularity;

	private Dictionary<ulong, TValueType> dict;

	private List<TValueType> pool;

	private List<TValueType> list;

	private Queue<TValueType> recycled;

	public int Size => list.Count;

	public int Count => dict.Count;

	public TValueType this[int i]
	{
		get
		{
			return list[i];
		}
		set
		{
			list[i] = value;
		}
	}

	public HashedPool(int capacity, int granularity)
	{
		this.granularity = granularity;
		dict = new Dictionary<ulong, TValueType>(capacity);
		pool = new List<TValueType>(capacity);
		list = new List<TValueType>(capacity);
		recycled = new Queue<TValueType>();
	}

	public void Clear()
	{
		dict.Clear();
		pool.Clear();
		list.Clear();
		recycled.Clear();
	}

	public TValueType Add(ulong key, int capacityGranularity = 16)
	{
		TValueType val;
		if (recycled.Count > 0)
		{
			val = recycled.Dequeue();
			list[val.hashedPoolIndex] = val;
		}
		else
		{
			int count = pool.Count;
			if (count == pool.Capacity)
			{
				pool.Capacity += granularity;
			}
			val = new TValueType
			{
				hashedPoolIndex = count
			};
			pool.Add(val);
			list.Add(val);
		}
		val.hashedPoolKey = key;
		dict.Add(key, val);
		return val;
	}

	public void Remove(TValueType value)
	{
		dict.Remove(value.hashedPoolKey);
		list[value.hashedPoolIndex] = null;
		recycled.Enqueue(value);
		value.hashedPoolKey = ulong.MaxValue;
	}

	public bool TryGetValue(ulong key, out TValueType value)
	{
		return dict.TryGetValue(key, out value);
	}

	public bool ContainsKey(ulong key)
	{
		return dict.ContainsKey(key);
	}
}


using System;

public class SimpleList<T>
{
	private const int defaultCapacity = 16;

	private static readonly T[] emptyArray = new T[0];

	public T[] array;

	public int count;

	public int Count => count;

	public int Capacity
	{
		get
		{
			return array.Length;
		}
		set
		{
			if (value == array.Length)
			{
				return;
			}
			if (value > 0)
			{
				T[] destinationArray = new T[value];
				if (count > 0)
				{
					Array.Copy(array, 0, destinationArray, 0, count);
				}
				array = destinationArray;
			}
			else
			{
				array = emptyArray;
			}
		}
	}

	public T this[int index]
	{
		get
		{
			return array[index];
		}
		set
		{
			array[index] = value;
		}
	}

	public SimpleList()
	{
		array = emptyArray;
	}

	public SimpleList(int capacity)
	{
		array = ((capacity == 0) ? emptyArray : new T[capacity]);
	}

	public void Add(T item)
	{
		if (count == array.Length)
		{
			EnsureCapacity(count + 1);
		}
		array[count++] = item;
	}

	public void Clear()
	{
		if (count > 0)
		{
			Array.Clear(array, 0, count);
			count = 0;
		}
	}

	public bool Contains(T item)
	{
		for (int i = 0; i < count; i++)
		{
			if (array[i].Equals(item))
			{
				return true;
			}
		}
		return false;
	}

	public void CopyTo(T[] array)
	{
		Array.Copy(this.array, 0, array, 0, count);
	}

	public void EnsureCapacity(int min)
	{
		if (array.Length < min)
		{
			int num = ((array.Length == 0) ? 16 : (array.Length * 2));
			num = ((num < min) ? min : num);
			Capacity = num;
		}
	}
}


public class SmartListValue
{
	public int hashedListIndex = -1;
}


using System;
using System.Collections.Generic;

public class SmartList
{
	private const int defaultCapacity = 16;

	private static readonly OccludeeState[] emptyList = new OccludeeState[0];

	private static readonly int[] emptySlots = new int[0];

	private OccludeeState[] list;

	private int[] slots;

	private Queue<int> recycled;

	private int count;

	public OccludeeState[] List => list;

	public int[] Slots => slots;

	public int Size => count;

	public int Count => count - recycled.Count;

	public OccludeeState this[int i]
	{
		get
		{
			return list[i];
		}
		set
		{
			list[i] = value;
		}
	}

	public int Capacity
	{
		get
		{
			return list.Length;
		}
		set
		{
			if (value == list.Length)
			{
				return;
			}
			if (value > 0)
			{
				OccludeeState[] destinationArray = new OccludeeState[value];
				int[] destinationArray2 = new int[value];
				if (count > 0)
				{
					Array.Copy(list, destinationArray, count);
					Array.Copy(slots, destinationArray2, count);
				}
				list = destinationArray;
				slots = destinationArray2;
			}
			else
			{
				list = emptyList;
				slots = emptySlots;
			}
		}
	}

	public SmartList(int capacity)
	{
		list = new OccludeeState[capacity];
		slots = new int[capacity];
		recycled = new Queue<int>();
		count = 0;
	}

	public void Add(OccludeeState value, int capacityGranularity = 16)
	{
		int num;
		if (recycled.Count > 0)
		{
			num = recycled.Dequeue();
			list[num] = value;
			slots[num] = value.slot;
		}
		else
		{
			num = count;
			if (num == list.Length)
			{
				EnsureCapacity(count + 1);
			}
			list[num] = value;
			slots[num] = value.slot;
			count++;
		}
		value.hashedListIndex = num;
	}

	public void Remove(OccludeeState value)
	{
		int hashedListIndex = value.hashedListIndex;
		list[hashedListIndex] = null;
		slots[hashedListIndex] = -1;
		recycled.Enqueue(hashedListIndex);
		value.hashedListIndex = -1;
	}

	public bool Contains(OccludeeState value)
	{
		int hashedListIndex = value.hashedListIndex;
		if (hashedListIndex >= 0)
		{
			return list[hashedListIndex] != null;
		}
		return false;
	}

	public void EnsureCapacity(int min)
	{
		if (list.Length < min)
		{
			int num = ((list.Length == 0) ? 16 : (list.Length * 2));
			num = ((num < min) ? min : num);
			Capacity = num;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class Cell : HashedPoolValue
{
	public int x;

	public int y;

	public int z;

	public Bounds bounds;

	public Vector4 sphereBounds;

	public bool isVisible;

	public SmartList staticBucket;

	public SmartList dynamicBucket;

	public void Reset()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		x = (y = (z = 0));
		bounds = default(Bounds);
		sphereBounds = Vector4.zero;
		isVisible = true;
		staticBucket = null;
		dynamicBucket = null;
	}

	public Cell Initialize(int x, int y, int z, Bounds bounds)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		this.x = x;
		this.y = y;
		this.z = z;
		this.bounds = bounds;
		float num = ((Bounds)(ref bounds)).center.x;
		float num2 = ((Bounds)(ref bounds)).center.y;
		float num3 = ((Bounds)(ref bounds)).center.z;
		Vector3 extents = ((Bounds)(ref bounds)).extents;
		sphereBounds = new Vector4(num, num2, num3, ((Vector3)(ref extents)).magnitude);
		isVisible = true;
		staticBucket = new SmartList(32);
		dynamicBucket = new SmartList(32);
		return this;
	}
}


using UnityEngine;

public struct Sphere
{
	public Vector3 position;

	public float radius;

	public bool IsValid()
	{
		return radius > 0f;
	}

	public Sphere(Vector3 position, float radius)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		this.position = position;
		this.radius = radius;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Sonic Ether/SE Screen-Space Shadows")]
public class SEScreenSpaceShadows : SingletonComponent<SEScreenSpaceShadows>, IClientComponent
{
	private CommandBuffer blendShadowsCommandBuffer;

	private CommandBuffer renderShadowsCommandBuffer;

	private Camera attachedCamera;

	public Light sun;

	[Range(0f, 1f)]
	public float blendStrength = 1f;

	[Range(0f, 1f)]
	public float accumulation = 0.9f;

	[Range(0.1f, 5f)]
	public float lengthFade = 0.7f;

	[Range(0.01f, 5f)]
	public float range = 0.7f;

	[Range(0f, 1f)]
	public float zThickness = 0.1f;

	[Range(2f, 92f)]
	public int samples = 32;

	[Range(0.5f, 4f)]
	public float nearSampleQuality = 1.5f;

	[Range(0f, 1f)]
	public float traceBias = 0.03f;

	public bool stochasticSampling = true;

	public bool leverageTemporalAA;

	public bool bilateralBlur = true;

	[Range(1f, 2f)]
	public int blurPasses = 1;

	[Range(0.01f, 0.5f)]
	public float blurDepthTolerance = 0.1f;
}


using UnityEngine;

public class VTP : MonoBehaviour
{
	public static Color getSingleVertexColorAtHit(Transform transform, RaycastHit hit)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] vertices = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices;
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Color[] colors = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		float num = float.PositiveInfinity;
		int num2 = 0;
		for (int i = 0; i < 3; i++)
		{
			float num3 = Vector3.Distance(transform.TransformPoint(vertices[triangles[triangleIndex * 3 + i]]), ((RaycastHit)(ref hit)).point);
			if (num3 < num)
			{
				num2 = triangles[triangleIndex * 3 + i];
				num = num3;
			}
		}
		return colors[num2];
	}

	public static Color getFaceVerticesColorAtHit(Transform transform, RaycastHit hit)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Color[] colors = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		int num = triangles[triangleIndex * 3];
		return (colors[num] + colors[num + 1] + colors[num + 2]) / 3f;
	}

	public static void paintSingleVertexOnHit(Transform transform, RaycastHit hit, Color color, float strength)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] vertices = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices;
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Color[] colors = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		float num = float.PositiveInfinity;
		int num2 = 0;
		for (int i = 0; i < 3; i += 3)
		{
			float num3 = Vector3.Distance(transform.TransformPoint(vertices[triangles[triangleIndex * 3 + i]]), ((RaycastHit)(ref hit)).point);
			if (num3 < num)
			{
				num2 = triangles[triangleIndex * 3 + i];
				num = num3;
			}
		}
		Color val = VertexColorLerp(colors[num2], color, strength);
		colors[num2] = val;
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors = colors;
	}

	public static void paintFaceVerticesOnHit(Transform transform, RaycastHit hit, Color color, float strength)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Color[] colors = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		int num = 0;
		for (int i = 0; i < 3; i++)
		{
			num = triangles[triangleIndex * 3 + i];
			Color val = VertexColorLerp(colors[num], color, strength);
			colors[num] = val;
		}
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors = colors;
	}

	public static void deformSingleVertexOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] vertices = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices;
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Vector3[] normals = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.normals;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		float num = float.PositiveInfinity;
		int num2 = 0;
		for (int i = 0; i < 3; i++)
		{
			float num3 = Vector3.Distance(transform.TransformPoint(vertices[triangles[triangleIndex * 3 + i]]), ((RaycastHit)(ref hit)).point);
			if (num3 < num)
			{
				num2 = triangles[triangleIndex * 3 + i];
				num = num3;
			}
		}
		int num4 = 1;
		if (!up)
		{
			num4 = -1;
		}
		ref Vector3 reference = ref vertices[num2];
		reference += (float)num4 * 0.1f * strength * normals[num2];
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices = vertices;
		if (recalculateNormals)
		{
			((Component)transform).GetComponent<MeshFilter>().sharedMesh.RecalculateNormals();
		}
		if (recalculateCollider)
		{
			((Component)transform).GetComponent<MeshCollider>().sharedMesh = ((Component)transform).GetComponent<MeshFilter>().sharedMesh;
		}
		if (recalculateFlow)
		{
			Vector4[] array = calculateMeshTangents(triangles, vertices, ((Component)transform).GetComponent<MeshCollider>().sharedMesh.uv, normals);
			((Component)transform).GetComponent<MeshCollider>().sharedMesh.tangents = array;
			recalculateMeshForFlow(transform, vertices, normals, array);
		}
	}

	public static void deformFaceVerticesOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] vertices = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices;
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Vector3[] normals = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.normals;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		int num = 0;
		int num2 = 1;
		if (!up)
		{
			num2 = -1;
		}
		for (int i = 0; i < 3; i++)
		{
			num = triangles[triangleIndex * 3 + i];
			ref Vector3 reference = ref vertices[num];
			reference += (float)num2 * 0.1f * strength * normals[num];
		}
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices = vertices;
		if (recalculateNormals)
		{
			((Component)transform).GetComponent<MeshFilter>().sharedMesh.RecalculateNormals();
		}
		if (recalculateCollider)
		{
			((Component)transform).GetComponent<MeshCollider>().sharedMesh = ((Component)transform).GetComponent<MeshFilter>().sharedMesh;
		}
		if (recalculateFlow)
		{
			Vector4[] array = calculateMeshTangents(triangles, vertices, ((Component)transform).GetComponent<MeshCollider>().sharedMesh.uv, normals);
			((Component)transform).GetComponent<MeshCollider>().sharedMesh.tangents = array;
			recalculateMeshForFlow(transform, vertices, normals, array);
		}
	}

	private static void recalculateMeshForFlow(Transform transform, Vector3[] currentVertices, Vector3[] currentNormals, Vector4[] currentTangents)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		Vector2[] uv = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.uv4;
		for (int i = 0; i < currentVertices.Length; i++)
		{
			Vector3 val = Vector3.Cross(currentNormals[i], new Vector3(currentTangents[i].x, currentTangents[i].y, currentTangents[i].z));
			Vector3 val2 = transform.TransformDirection(((Vector3)(ref val)).normalized * currentTangents[i].w);
			Vector3 val3 = transform.TransformDirection(Vector4.op_Implicit(((Vector4)(ref currentTangents[i])).normalized));
			float num = 0.5f + 0.5f * val3.y;
			float num2 = 0.5f + 0.5f * val2.y;
			uv[i] = new Vector2(num, num2);
		}
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.uv4 = uv;
	}

	private static Vector4[] calculateMeshTangents(int[] triangles, Vector3[] vertices, Vector2[] uv, Vector3[] normals)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		int num = triangles.Length;
		int num2 = vertices.Length;
		Vector3[] array = (Vector3[])(object)new Vector3[num2];
		Vector3[] array2 = (Vector3[])(object)new Vector3[num2];
		Vector4[] array3 = (Vector4[])(object)new Vector4[num2];
		Vector3 val7 = default(Vector3);
		Vector3 val8 = default(Vector3);
		for (long num3 = 0L; num3 < num; num3 += 3)
		{
			long num4 = triangles[num3];
			long num5 = triangles[num3 + 1];
			long num6 = triangles[num3 + 2];
			Vector3 val = vertices[num4];
			Vector3 val2 = vertices[num5];
			Vector3 val3 = vertices[num6];
			Vector2 val4 = uv[num4];
			Vector2 val5 = uv[num5];
			Vector2 val6 = uv[num6];
			float num7 = val2.x - val.x;
			float num8 = val3.x - val.x;
			float num9 = val2.y - val.y;
			float num10 = val3.y - val.y;
			float num11 = val2.z - val.z;
			float num12 = val3.z - val.z;
			float num13 = val5.x - val4.x;
			float num14 = val6.x - val4.x;
			float num15 = val5.y - val4.y;
			float num16 = val6.y - val4.y;
			float num17 = num13 * num16 - num14 * num15;
			float num18 = ((num17 == 0f) ? 0f : (1f / num17));
			((Vector3)(ref val7))..ctor((num16 * num7 - num15 * num8) * num18, (num16 * num9 - num15 * num10) * num18, (num16 * num11 - num15 * num12) * num18);
			((Vector3)(ref val8))..ctor((num13 * num8 - num14 * num7) * num18, (num13 * num10 - num14 * num9) * num18, (num13 * num12 - num14 * num11) * num18);
			ref Vector3 reference = ref array[num4];
			reference += val7;
			ref Vector3 reference2 = ref array[num5];
			reference2 += val7;
			ref Vector3 reference3 = ref array[num6];
			reference3 += val7;
			ref Vector3 reference4 = ref array2[num4];
			reference4 += val8;
			ref Vector3 reference5 = ref array2[num5];
			reference5 += val8;
			ref Vector3 reference6 = ref array2[num6];
			reference6 += val8;
		}
		for (long num19 = 0L; num19 < num2; num19++)
		{
			Vector3 val9 = normals[num19];
			Vector3 val10 = array[num19];
			Vector3.OrthoNormalize(ref val9, ref val10);
			array3[num19].x = val10.x;
			array3[num19].y = val10.y;
			array3[num19].z = val10.z;
			array3[num19].w = ((Vector3.Dot(Vector3.Cross(val9, val10), array2[num19]) < 0f) ? (-1f) : 1f);
		}
		return array3;
	}

	public static Color VertexColorLerp(Color colorA, Color colorB, float value)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (value >= 1f)
		{
			return colorB;
		}
		if (value <= 0f)
		{
			return colorA;
		}
		return new Color(colorA.r + (colorB.r - colorA.r) * value, colorA.g + (colorB.g - colorA.g) * value, colorA.b + (colorB.b - colorA.b) * value, colorA.a + (colorB.a - colorA.a) * value);
	}
}


using System;
using UnityEngine;

[Serializable]
public class MeshHolder
{
	[HideInInspector]
	public Vector3[] _vertices;

	[HideInInspector]
	public Vector3[] _normals;

	[HideInInspector]
	public int[] _triangles;

	[HideInInspector]
	public trisPerSubmesh[] _TrianglesOfSubs;

	[HideInInspector]
	public Matrix4x4[] _bindPoses;

	[HideInInspector]
	public BoneWeight[] _boneWeights;

	[HideInInspector]
	public Bounds _bounds;

	[HideInInspector]
	public int _subMeshCount;

	[HideInInspector]
	public Vector4[] _tangents;

	[HideInInspector]
	public Vector2[] _uv;

	[HideInInspector]
	public Vector2[] _uv2;

	[HideInInspector]
	public Vector2[] _uv3;

	[HideInInspector]
	public Color[] _colors;

	[HideInInspector]
	public Vector2[] _uv4;

	public void setAnimationData(Mesh mesh)
	{
		_colors = mesh.colors;
	}
}


using System;

[Serializable]
public class trisPerSubmesh
{
	public int[] triangles;
}


using System.Collections.Generic;
using UnityEngine;

public class VertexColorAnimator : MonoBehaviour
{
	public List<MeshHolder> animationMeshes;

	public List<float> animationKeyframes;

	public float timeScale = 2f;

	public int mode;

	private float elapsedTime;

	public void initLists()
	{
		animationMeshes = new List<MeshHolder>();
		animationKeyframes = new List<float>();
	}

	public void addMesh(Mesh mesh, float atPosition)
	{
		MeshHolder meshHolder = new MeshHolder();
		meshHolder.setAnimationData(mesh);
		animationMeshes.Add(meshHolder);
		animationKeyframes.Add(atPosition);
	}

	private void Start()
	{
		elapsedTime = 0f;
	}

	public void replaceKeyframe(int frameIndex, Mesh mesh)
	{
		animationMeshes[frameIndex].setAnimationData(mesh);
	}

	public void deleteKeyframe(int frameIndex)
	{
		animationMeshes.RemoveAt(frameIndex);
		animationKeyframes.RemoveAt(frameIndex);
	}

	public void scrobble(float scrobblePos)
	{
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if (animationMeshes.Count == 0)
		{
			return;
		}
		Color[] array = (Color[])(object)new Color[((Component)this).GetComponent<MeshFilter>().sharedMesh.colors.Length];
		int num = 0;
		for (int i = 0; i < animationKeyframes.Count; i++)
		{
			if (scrobblePos >= animationKeyframes[i])
			{
				num = i;
			}
		}
		if (num >= animationKeyframes.Count - 1)
		{
			((Component)this).GetComponent<VertexColorStream>().setColors(animationMeshes[num]._colors);
			return;
		}
		float num2 = animationKeyframes[num + 1] - animationKeyframes[num];
		float num3 = animationKeyframes[num];
		float num4 = (scrobblePos - num3) / num2;
		for (int j = 0; j < array.Length; j++)
		{
			array[j] = Color.Lerp(animationMeshes[num]._colors[j], animationMeshes[num + 1]._colors[j], num4);
		}
		((Component)this).GetComponent<VertexColorStream>().setColors(array);
	}

	private void Update()
	{
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		if (mode == 0)
		{
			elapsedTime += Time.fixedDeltaTime / timeScale;
		}
		else if (mode == 1)
		{
			elapsedTime += Time.fixedDeltaTime / timeScale;
			if (elapsedTime > 1f)
			{
				elapsedTime = 0f;
			}
		}
		else if (mode == 2)
		{
			if (Mathf.FloorToInt(Time.fixedTime / timeScale) % 2 == 0)
			{
				elapsedTime += Time.fixedDeltaTime / timeScale;
			}
			else
			{
				elapsedTime -= Time.fixedDeltaTime / timeScale;
			}
		}
		Color[] array = (Color[])(object)new Color[((Component)this).GetComponent<MeshFilter>().sharedMesh.colors.Length];
		int num = 0;
		for (int i = 0; i < animationKeyframes.Count; i++)
		{
			if (elapsedTime >= animationKeyframes[i])
			{
				num = i;
			}
		}
		if (num < animationKeyframes.Count - 1)
		{
			float num2 = animationKeyframes[num + 1] - animationKeyframes[num];
			float num3 = animationKeyframes[num];
			float num4 = (elapsedTime - num3) / num2;
			for (int j = 0; j < array.Length; j++)
			{
				array[j] = Color.Lerp(animationMeshes[num]._colors[j], animationMeshes[num + 1]._colors[j], num4);
			}
		}
		else
		{
			array = animationMeshes[num]._colors;
		}
		((Component)this).GetComponent<VertexColorStream>().setColors(array);
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class VertexColorStream : MonoBehaviour
{
	[HideInInspector]
	public Mesh originalMesh;

	[HideInInspector]
	public Mesh paintedMesh;

	[HideInInspector]
	public MeshHolder meshHold;

	[HideInInspector]
	public Vector3[] _vertices;

	[HideInInspector]
	public Vector3[] _normals;

	[HideInInspector]
	public int[] _triangles;

	[HideInInspector]
	public int[][] _Subtriangles;

	[HideInInspector]
	public Matrix4x4[] _bindPoses;

	[HideInInspector]
	public BoneWeight[] _boneWeights;

	[HideInInspector]
	public Bounds _bounds;

	[HideInInspector]
	public int _subMeshCount;

	[HideInInspector]
	public Vector4[] _tangents;

	[HideInInspector]
	public Vector2[] _uv;

	[HideInInspector]
	public Vector2[] _uv2;

	[HideInInspector]
	public Vector2[] _uv3;

	[HideInInspector]
	public Color[] _colors;

	[HideInInspector]
	public Vector2[] _uv4;

	private void OnDidApplyAnimationProperties()
	{
	}

	public void init(Mesh origMesh, bool destroyOld)
	{
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		originalMesh = origMesh;
		paintedMesh = Object.Instantiate<Mesh>(origMesh);
		if (destroyOld)
		{
			Object.DestroyImmediate((Object)(object)origMesh);
		}
		((Object)paintedMesh).hideFlags = (HideFlags)0;
		((Object)paintedMesh).name = "vpp_" + ((Object)((Component)this).gameObject).name;
		meshHold = new MeshHolder();
		meshHold._vertices = paintedMesh.vertices;
		meshHold._normals = paintedMesh.normals;
		meshHold._triangles = paintedMesh.triangles;
		meshHold._TrianglesOfSubs = new trisPerSubmesh[paintedMesh.subMeshCount];
		for (int i = 0; i < paintedMesh.subMeshCount; i++)
		{
			meshHold._TrianglesOfSubs[i] = new trisPerSubmesh();
			meshHold._TrianglesOfSubs[i].triangles = paintedMesh.GetTriangles(i);
		}
		meshHold._bindPoses = paintedMesh.bindposes;
		meshHold._boneWeights = paintedMesh.boneWeights;
		meshHold._bounds = paintedMesh.bounds;
		meshHold._subMeshCount = paintedMesh.subMeshCount;
		meshHold._tangents = paintedMesh.tangents;
		meshHold._uv = paintedMesh.uv;
		meshHold._uv2 = paintedMesh.uv2;
		meshHold._uv3 = paintedMesh.uv3;
		meshHold._colors = paintedMesh.colors;
		meshHold._uv4 = paintedMesh.uv4;
		((Component)this).GetComponent<MeshFilter>().sharedMesh = paintedMesh;
		if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<MeshCollider>()))
		{
			((Component)this).GetComponent<MeshCollider>().sharedMesh = paintedMesh;
		}
	}

	public void setWholeMesh(Mesh tmpMesh)
	{
		paintedMesh.vertices = tmpMesh.vertices;
		paintedMesh.triangles = tmpMesh.triangles;
		paintedMesh.normals = tmpMesh.normals;
		paintedMesh.colors = tmpMesh.colors;
		paintedMesh.uv = tmpMesh.uv;
		paintedMesh.uv2 = tmpMesh.uv2;
		paintedMesh.uv3 = tmpMesh.uv3;
		meshHold._vertices = tmpMesh.vertices;
		meshHold._triangles = tmpMesh.triangles;
		meshHold._normals = tmpMesh.normals;
		meshHold._colors = tmpMesh.colors;
		meshHold._uv = tmpMesh.uv;
		meshHold._uv2 = tmpMesh.uv2;
		meshHold._uv3 = tmpMesh.uv3;
	}

	public Vector3[] setVertices(Vector3[] _deformedVertices)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		paintedMesh.vertices = _deformedVertices;
		meshHold._vertices = _deformedVertices;
		paintedMesh.RecalculateNormals();
		paintedMesh.RecalculateBounds();
		meshHold._normals = paintedMesh.normals;
		meshHold._bounds = paintedMesh.bounds;
		((Component)this).GetComponent<MeshCollider>().sharedMesh = null;
		if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<MeshCollider>()))
		{
			((Component)this).GetComponent<MeshCollider>().sharedMesh = paintedMesh;
		}
		return meshHold._normals;
	}

	public Vector3[] getVertices()
	{
		return paintedMesh.vertices;
	}

	public Vector3[] getNormals()
	{
		return paintedMesh.normals;
	}

	public int[] getTriangles()
	{
		return paintedMesh.triangles;
	}

	public void setTangents(Vector4[] _meshTangents)
	{
		paintedMesh.tangents = _meshTangents;
		meshHold._tangents = _meshTangents;
	}

	public Vector4[] getTangents()
	{
		return paintedMesh.tangents;
	}

	public void setColors(Color[] _vertexColors)
	{
		paintedMesh.colors = _vertexColors;
		meshHold._colors = _vertexColors;
	}

	public Color[] getColors()
	{
		return paintedMesh.colors;
	}

	public Vector2[] getUVs()
	{
		return paintedMesh.uv;
	}

	public void setUV4s(Vector2[] _uv4s)
	{
		paintedMesh.uv4 = _uv4s;
		meshHold._uv4 = _uv4s;
	}

	public Vector2[] getUV4s()
	{
		return paintedMesh.uv4;
	}

	public void unlink()
	{
		init(paintedMesh, destroyOld: false);
	}

	public void rebuild()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)((Component)this).GetComponent<MeshFilter>()))
		{
			return;
		}
		paintedMesh = new Mesh();
		((Object)paintedMesh).hideFlags = (HideFlags)61;
		((Object)paintedMesh).name = "vpp_" + ((Object)((Component)this).gameObject).name;
		if (meshHold == null || meshHold._vertices.Length == 0 || meshHold._TrianglesOfSubs.Length == 0)
		{
			paintedMesh.subMeshCount = _subMeshCount;
			paintedMesh.vertices = _vertices;
			paintedMesh.normals = _normals;
			paintedMesh.triangles = _triangles;
			meshHold._TrianglesOfSubs = new trisPerSubmesh[paintedMesh.subMeshCount];
			for (int i = 0; i < paintedMesh.subMeshCount; i++)
			{
				meshHold._TrianglesOfSubs[i] = new trisPerSubmesh();
				meshHold._TrianglesOfSubs[i].triangles = paintedMesh.GetTriangles(i);
			}
			paintedMesh.bindposes = _bindPoses;
			paintedMesh.boneWeights = _boneWeights;
			paintedMesh.bounds = _bounds;
			paintedMesh.tangents = _tangents;
			paintedMesh.uv = _uv;
			paintedMesh.uv2 = _uv2;
			paintedMesh.uv3 = _uv3;
			paintedMesh.colors = _colors;
			paintedMesh.uv4 = _uv4;
			init(paintedMesh, destroyOld: true);
		}
		else
		{
			paintedMesh.subMeshCount = meshHold._subMeshCount;
			paintedMesh.vertices = meshHold._vertices;
			paintedMesh.normals = meshHold._normals;
			for (int j = 0; j < meshHold._subMeshCount; j++)
			{
				paintedMesh.SetTriangles(meshHold._TrianglesOfSubs[j].triangles, j);
			}
			paintedMesh.bindposes = meshHold._bindPoses;
			paintedMesh.boneWeights = meshHold._boneWeights;
			paintedMesh.bounds = meshHold._bounds;
			paintedMesh.tangents = meshHold._tangents;
			paintedMesh.uv = meshHold._uv;
			paintedMesh.uv2 = meshHold._uv2;
			paintedMesh.uv3 = meshHold._uv3;
			paintedMesh.colors = meshHold._colors;
			paintedMesh.uv4 = meshHold._uv4;
			init(paintedMesh, destroyOld: true);
		}
	}

	private void Start()
	{
		if (!Object.op_Implicit((Object)(object)paintedMesh) || meshHold == null)
		{
			rebuild();
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class VertexStreamChildrenRebuilder : MonoBehaviour
{
}


using System;
using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Rendering/Visualize Texture Density")]
[ImageEffectAllowedInSceneView]
public class VisualizeTexelDensity : MonoBehaviour
{
	public Shader shader;

	public string shaderTag = "RenderType";

	[Range(1f, 1024f)]
	public int texelsPerMeter = 256;

	[Range(0f, 1f)]
	public float overlayOpacity = 0.5f;

	public bool showHUD = true;

	private Camera mainCamera;

	private bool initialized;

	private int screenWidth;

	private int screenHeight;

	private Camera texelDensityCamera;

	private RenderTexture texelDensityRT;

	private Texture texelDensityGradTex;

	private Material texelDensityOverlayMat;

	private static VisualizeTexelDensity instance;

	public static VisualizeTexelDensity Instance => instance;

	private void Awake()
	{
		instance = this;
		mainCamera = ((Component)this).GetComponent<Camera>();
	}

	private void OnEnable()
	{
		mainCamera = ((Component)this).GetComponent<Camera>();
		screenWidth = Screen.width;
		screenHeight = Screen.height;
		LoadResources();
		initialized = true;
	}

	private void OnDisable()
	{
		SafeDestroyViewTexelDensity();
		SafeDestroyViewTexelDensityRT();
		initialized = false;
	}

	private void LoadResources()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Expected O, but got Unknown
		if ((Object)(object)texelDensityGradTex == (Object)null)
		{
			ref Texture reference = ref texelDensityGradTex;
			Object obj = Resources.Load("TexelDensityGrad");
			reference = (Texture)(object)((obj is Texture) ? obj : null);
		}
		if ((Object)(object)texelDensityOverlayMat == (Object)null)
		{
			texelDensityOverlayMat = new Material(Shader.Find("Hidden/TexelDensityOverlay"))
			{
				hideFlags = (HideFlags)52
			};
		}
	}

	private void SafeDestroyViewTexelDensity()
	{
		if ((Object)(object)texelDensityCamera != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)((Component)texelDensityCamera).gameObject);
			texelDensityCamera = null;
		}
		if ((Object)(object)texelDensityGradTex != (Object)null)
		{
			Resources.UnloadAsset((Object)(object)texelDensityGradTex);
			texelDensityGradTex = null;
		}
		if ((Object)(object)texelDensityOverlayMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)texelDensityOverlayMat);
			texelDensityOverlayMat = null;
		}
	}

	private void SafeDestroyViewTexelDensityRT()
	{
		if ((Object)(object)texelDensityRT != (Object)null)
		{
			Graphics.SetRenderTarget((RenderTexture)null);
			texelDensityRT.Release();
			Object.DestroyImmediate((Object)(object)texelDensityRT);
			texelDensityRT = null;
		}
	}

	private void UpdateViewTexelDensity(bool screenResized)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Expected O, but got Unknown
		if ((Object)(object)texelDensityCamera == (Object)null)
		{
			GameObject val = new GameObject("Texel Density Camera", new Type[1] { typeof(Camera) })
			{
				hideFlags = (HideFlags)61
			};
			val.transform.parent = ((Component)mainCamera).transform;
			val.transform.localPosition = Vector3.zero;
			val.transform.localRotation = Quaternion.identity;
			texelDensityCamera = val.GetComponent<Camera>();
			texelDensityCamera.CopyFrom(mainCamera);
			texelDensityCamera.renderingPath = (RenderingPath)1;
			texelDensityCamera.allowMSAA = false;
			texelDensityCamera.allowHDR = false;
			texelDensityCamera.clearFlags = (CameraClearFlags)1;
			texelDensityCamera.depthTextureMode = (DepthTextureMode)0;
			texelDensityCamera.SetReplacementShader(shader, shaderTag);
			((Behaviour)texelDensityCamera).enabled = false;
		}
		if ((Object)(object)texelDensityRT == (Object)null || screenResized || !texelDensityRT.IsCreated())
		{
			texelDensityCamera.targetTexture = null;
			SafeDestroyViewTexelDensityRT();
			texelDensityRT = new RenderTexture(screenWidth, screenHeight, 24, (RenderTextureFormat)0)
			{
				hideFlags = (HideFlags)52
			};
			((Object)texelDensityRT).name = "TexelDensityRT";
			((Texture)texelDensityRT).filterMode = (FilterMode)0;
			((Texture)texelDensityRT).wrapMode = (TextureWrapMode)1;
			texelDensityRT.Create();
		}
		if ((Object)(object)texelDensityCamera.targetTexture != (Object)(object)texelDensityRT)
		{
			texelDensityCamera.targetTexture = texelDensityRT;
		}
		Shader.SetGlobalFloat("global_TexelsPerMeter", (float)texelsPerMeter);
		Shader.SetGlobalTexture("global_TexelDensityGrad", texelDensityGradTex);
		texelDensityCamera.fieldOfView = mainCamera.fieldOfView;
		texelDensityCamera.nearClipPlane = mainCamera.nearClipPlane;
		texelDensityCamera.farClipPlane = mainCamera.farClipPlane;
		texelDensityCamera.cullingMask = mainCamera.cullingMask;
	}

	private bool CheckScreenResized(int width, int height)
	{
		if (screenWidth != width || screenHeight != height)
		{
			screenWidth = width;
			screenHeight = height;
			return true;
		}
		return false;
	}

	private void OnPreCull()
	{
		if ((Object)(object)texelDensityCamera != (Object)null)
		{
			texelDensityCamera.Render();
		}
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (initialized)
		{
			UpdateViewTexelDensity(CheckScreenResized(((Texture)source).width, ((Texture)source).height));
			texelDensityOverlayMat.SetTexture("_TexelDensityMap", (Texture)(object)texelDensityRT);
			texelDensityOverlayMat.SetFloat("_Opacity", overlayOpacity);
			Graphics.Blit((Texture)(object)source, destination, texelDensityOverlayMat, 0);
		}
		else
		{
			Graphics.Blit((Texture)(object)source, destination);
		}
	}

	private void DrawGUIText(float x, float y, Vector2 size, string text, GUIStyle fontStyle)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		fontStyle.normal.textColor = Color.black;
		GUI.Label(new Rect(x - 1f, y + 1f, size.x, size.y), text, fontStyle);
		GUI.Label(new Rect(x + 1f, y - 1f, size.x, size.y), text, fontStyle);
		GUI.Label(new Rect(x + 1f, y + 1f, size.x, size.y), text, fontStyle);
		GUI.Label(new Rect(x - 1f, y - 1f, size.x, size.y), text, fontStyle);
		fontStyle.normal.textColor = Color.white;
		GUI.Label(new Rect(x, y, size.x, size.y), text, fontStyle);
	}

	private void OnGUI()
	{
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Expected O, but got Unknown
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Expected O, but got Unknown
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Expected O, but got Unknown
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Expected O, but got Unknown
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Expected O, but got Unknown
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		if (initialized && showHUD)
		{
			string text = "Texels Per Meter";
			string text2 = "0";
			string text3 = texelsPerMeter.ToString();
			string text4 = (texelsPerMeter << 1) + "+";
			float num = texelDensityGradTex.width;
			float num2 = texelDensityGradTex.height * 2;
			float num3 = (Screen.width - texelDensityGradTex.width) / 2;
			float num4 = 32f;
			GL.PushMatrix();
			GL.LoadPixelMatrix(0f, (float)Screen.width, (float)Screen.height, 0f);
			Graphics.DrawTexture(new Rect(num3 - 2f, num4 - 2f, num + 4f, num2 + 4f), (Texture)(object)Texture2D.whiteTexture);
			Graphics.DrawTexture(new Rect(num3, num4, num, num2), texelDensityGradTex);
			GL.PopMatrix();
			GUIStyle val = new GUIStyle();
			val.fontSize = 13;
			Vector2 val2 = val.CalcSize(new GUIContent(text));
			Vector2 size = val.CalcSize(new GUIContent(text2));
			Vector2 val3 = val.CalcSize(new GUIContent(text3));
			Vector2 val4 = val.CalcSize(new GUIContent(text4));
			DrawGUIText(((float)Screen.width - val2.x) / 2f, num4 - val2.y - 5f, val2, text, val);
			DrawGUIText(num3, num4 + num2 + 6f, size, text2, val);
			DrawGUIText(((float)Screen.width - val3.x) / 2f, num4 + num2 + 6f, val3, text3, val);
			DrawGUIText(num3 + num - val4.x, num4 + num2 + 6f, val4, text4, val);
		}
	}
}


using System;
using Facepunch;
using UnityEngine;

public class ViewmodelClothing : MonoBehaviour
{
	[Flags]
	public enum SkinArea
	{
		Arms = 1,
		Hands = 2
	}

	public enum Slot
	{
		Under,
		Over
	}

	public SkeletonSkin[] SkeletonSkins;

	public bool DisableHandsEntirely;

	[Header("Conditional Logic")]
	public bool isConditional;

	[Tooltip("This is the slot the clothing will fit into. Over clothing will use MaxSkins when on top of under clothing.")]
	public Slot ClothingSlot;

	[Tooltip("A mask to allow multiple over clothing on the same model, but affecting different areas.")]
	public SkinArea AreasCovered = SkinArea.Arms | SkinArea.Hands;

	[Tooltip("Max Skins are the skins displayed if clothing is on top.")]
	public SkeletonSkin[] MaxSkin;
}


using System;

[Flags]
public enum SkinArea
{
	Arms = 1,
	Hands = 2
}


public enum Slot
{
	Under,
	Over
}


using UnityEngine;

public class WorkshopIconRender : MonoBehaviour
{
	public int MinimumId;

	public int MaximumId = -1;
}


