using UnityEngine;

private struct GlueAttachement
{
	public RaycastHit AttachHit;

	public Transform AttachedTo;

	public Vector3 PosInAttachementLocal;

	public Vector3 NormalInAttachementLocal;

	public Quaternion RotInAttachementLocal;

	public bool NoTransform { get; private set; }

	public GlueAttachement(Leg leg, RaycastHit legGroundHit)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		AttachHit = legGroundHit;
		AttachedTo = ((RaycastHit)(ref legGroundHit)).transform;
		if ((Object)(object)((RaycastHit)(ref legGroundHit)).transform == (Object)null)
		{
			NoTransform = true;
			PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).point;
			NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).normal;
			RotInAttachementLocal = leg._PreviousFinalIKRot;
			return;
		}
		NoTransform = false;
		PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformPoint(((RaycastHit)(ref legGroundHit)).point);
		NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformDirection(((RaycastHit)(ref legGroundHit)).normal);
		if (!leg.Owner.AnimateFeet)
		{
			RotInAttachementLocal = Quaternion.identity;
		}
		else
		{
			RotInAttachementLocal = AttachedTo.rotation.QToLocal(leg.GetAlignedOnGroundHitRot(leg._SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal));
		}
	}

	internal Vector3 GetRelevantAlignedHitPoint(Leg leg)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		Vector3 relevantHitPoint = GetRelevantHitPoint();
		return leg.GetAlignedOnGroundHitPos(leg.ToRootLocalSpace(relevantHitPoint), relevantHitPoint, GetRelevantNormal());
	}

	internal Vector3 GetRelevantHitPoint()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (NoTransform || (Object)(object)AttachedTo == (Object)null)
		{
			return PosInAttachementLocal;
		}
		return AttachedTo.TransformPoint(PosInAttachementLocal);
	}

	internal Vector3 GetRelevantNormal()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (NoTransform)
		{
			return NormalInAttachementLocal;
		}
		return AttachedTo.TransformDirection(NormalInAttachementLocal);
	}

	internal Quaternion GetRelevantAttachementRotation()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (NoTransform)
		{
			return RotInAttachementLocal;
		}
		return AttachedTo.rotation.QToWorld(RotInAttachementLocal);
	}

	internal void OverwritePosition(Vector3 legAnimPos)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)AttachedTo == (Object)null)
		{
			PosInAttachementLocal = legAnimPos;
		}
		else
		{
			PosInAttachementLocal = ((Component)AttachedTo).transform.InverseTransformPoint(legAnimPos);
		}
	}
}


using UnityEngine;

private class GlueAttachementHandler
{
	public class LegTransitionAnimation
	{
		private enum EMoveType
		{
			FromAnimation,
			FromLastAttachement
		}

		private GlueAttachementHandler handler;

		public float LegAdjustementYOffset;

		public float LegAdjustementFootAngleOffset;

		private Vector3 _legSpherizeLocalVector = Vector3.zero;

		private float _legMoveDurMul = 1f;

		private Quaternion baseRotationOnStepUp;

		public float legMoveDistanceFactor;

		private float sd_trProgress;

		private Vector3 previousPositionLocal;

		private Vector3 previousPositionWorld;

		private Quaternion previousRotationWorld;

		private Vector3 lastAppliedGluePosition;

		private Vector3 lastAppliedGluePositionLocal;

		private Quaternion lastAppliedGlueRotation;

		private float lastSpeedup;

		private EMoveType animationMoveType;

		private bool _instantTransition;

		private bool _wasAnimatingLeg;

		private LegsAnimator Owner => handler.Owner;

		private Leg leg => handler.leg;

		public bool duringLegAdjustMovement { get; private set; }

		public bool wasAttaching { get; private set; }

		public bool attached { get; private set; }

		public float transitionProgress { get; private set; }

		public float lastAttachCompleteTime { get; private set; }

		public float transitionProgressLastFrame { get; private set; }

		public EGlueMode LastAnimationGlueMode
		{
			get
			{
				if (animationMoveType != 0)
				{
					return EGlueMode.Idle;
				}
				return EGlueMode.Moving;
			}
		}

		public LegTransitionAnimation(GlueAttachementHandler glueTransitionHelper)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			handler = glueTransitionHelper;
			Reset();
		}

		public void Reset()
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			animationMoveType = EMoveType.FromAnimation;
			transitionProgress = 0f;
			transitionProgressLastFrame = 0f;
			baseRotationOnStepUp = Owner.BaseTransform.rotation;
			duringLegAdjustMovement = false;
			wasAttaching = false;
			attached = false;
			_legSpherizeLocalVector = Vector3.zero;
			ReInitialize();
		}

		public void ReInitialize()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			lastAppliedGluePosition = leg._SourceIKPos;
			lastAppliedGlueRotation = leg._SourceIKRot;
			previousPositionWorld = leg._SourceIKPos;
			previousRotationWorld = leg._SourceIKRot;
			previousPositionLocal = leg.ToRootLocalSpace(leg._SourceIKPos);
		}

		internal void ScheduleInstantTransition()
		{
			_instantTransition = true;
		}

		internal void DoAttaching(bool canAttach)
		{
			if (canAttach != wasAttaching)
			{
				wasAttaching = canAttach;
				if (canAttach)
				{
					OnChangeTargetPosition();
				}
				else
				{
					attached = false;
					if (transitionProgress != 0f)
					{
						OnChangeTargetPosition();
					}
				}
			}
			if (duringLegAdjustMovement && transitionProgress >= 1f)
			{
				duringLegAdjustMovement = false;
			}
		}

		internal Vector3 EnsureAnkleNotOverlappingGroundLevel(Vector3 legAnimPos)
		{
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0070: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			if (leg.A_PreWasAligning && leg.A_WasAligningFrameBack)
			{
				Vector3 val = Owner.ToRootLocalSpace(legAnimPos);
				Vector3 val2 = ((!(Owner.SmoothSuddenSteps < 0.0001f)) ? (leg.A_WasSmoothing ? leg.A_LastSmoothTargetedPosLocal : leg.ankleAlignedOnGroundHitRootLocal) : leg.ankleAlignedOnGroundHitRootLocal);
				if (val.y < val2.y)
				{
					val.y = val2.y;
					legAnimPos = Owner.RootToWorldSpace(val);
				}
			}
			return legAnimPos;
		}

		public Vector3 CalculateAnimatedLegPosition(Vector3 a, Vector3 b)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_012a: Unknown result type (might be due to invalid IL or missing references)
			LegStepAnimatingParameters legAnimatingSettings = leg.LegAnimatingSettings;
			Vector3 val = Vector3.LerpUnclamped(a, b, legAnimatingSettings.MoveToGoalCurve.Evaluate(transitionProgress));
			if (legAnimatingSettings.SpherizeTrack.length > 1)
			{
				float num = legAnimatingSettings.SpherizeTrack.Evaluate(transitionProgress) * legAnimatingSettings.SpherizePower * Owner.BaseTransform.lossyScale.x;
				val += leg.RootSpaceToWorldVec(_legSpherizeLocalVector * (num * 12f));
			}
			if (Owner.AnimateFeet)
			{
				LegAdjustementFootAngleOffset = legAnimatingSettings.FootRotationCurve.Evaluate(transitionProgress) * 90f * Mathf.Min(0.5f, legMoveDistanceFactor * 1.1f);
				LegAdjustementFootAngleOffset /= lastSpeedup;
			}
			float num2 = Owner.ScaleReferenceNoScale * 0.75f;
			float num3 = Mathf.Lerp(legAnimatingSettings.MinFootRaise, legAnimatingSettings.MaxFootRaise, legMoveDistanceFactor);
			num3 *= num2;
			LegAdjustementYOffset = num3 * legAnimatingSettings.RaiseYAxisCurve.Evaluate(transitionProgress);
			_wasAnimatingLeg = true;
			return val;
		}

		internal Vector3 GetTargetPosition()
		{
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_0144: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_0154: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0177: Unknown result type (might be due to invalid IL or missing references)
			//IL_017e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0183: Unknown result type (might be due to invalid IL or missing references)
			//IL_0188: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0172: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			float glueAnimationBlend = handler.glueAnimationBlend;
			if (animationMoveType == EMoveType.FromAnimation)
			{
				if (glueAnimationBlend < 0.0001f)
				{
					return Owner.RootToWorldSpace(previousPositionLocal);
				}
				Vector3 val = Owner.RootToWorldSpace(previousPositionLocal);
				if (transitionProgress < 0.0001f)
				{
					return val;
				}
				Vector3 val2 = ((!attached) ? leg.ankleAlignedOnGroundHitWorldPos : ((glueAnimationBlend > 0.9995f) ? leg._GlueLastAttachPosition : ((!leg.Owner.OnlyLocalAnimation) ? Vector3.LerpUnclamped(leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal), leg._GlueLastAttachPosition, glueAnimationBlend) : leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal))));
				if (transitionProgress > 0.9995f)
				{
					return val2;
				}
				return Vector3.LerpUnclamped(val, val2, transitionProgress);
			}
			Vector3 val3;
			if (leg.Owner.OnlyLocalAnimation)
			{
				val3 = Owner.RootToWorldSpace(previousPositionLocal);
				if (transitionProgress < 0.0001f)
				{
					return val3;
				}
			}
			else
			{
				val3 = previousPositionWorld;
				if (transitionProgress < 0.0001f)
				{
					return val3;
				}
				val3 = Vector3.LerpUnclamped(previousPositionWorld, Owner.RootToWorldSpace(previousPositionLocal), transitionProgress);
			}
			Vector3 val4 = ((!(transitionProgress > 0.9995f)) ? CalculateAnimatedLegPosition(val3, leg.ankleAlignedOnGroundHitWorldPos) : leg._GlueLastAttachPosition);
			if (transitionProgress >= 1f)
			{
				return val4;
			}
			float num = 1f - transitionProgress;
			return Vector3.LerpUnclamped(val3, val4, 1f - num * num);
		}

		internal void RequireRepose()
		{
			if (attached)
			{
				attached = false;
				OnChangeTargetPosition();
			}
		}

		internal Quaternion GetTargetRotation()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			Quaternion val = previousRotationWorld;
			if (transitionProgress < 0.001f)
			{
				return val;
			}
			Quaternion val2 = ((!attached) ? leg.ankleAlignedOnGroundHitRotation : leg._GlueLastAttachRotation);
			if (transitionProgress > 0.9995f)
			{
				return val2;
			}
			return Quaternion.LerpUnclamped(val, val2, transitionProgress);
		}

		internal void OnChangeTargetPosition()
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0105: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0152: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_0158: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_019c: Unknown result type (might be due to invalid IL or missing references)
			//IL_019d: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_0247: Unknown result type (might be due to invalid IL or missing references)
			//IL_024c: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0211: Unknown result type (might be due to invalid IL or missing references)
			//IL_0213: Unknown result type (might be due to invalid IL or missing references)
			//IL_0223: Unknown result type (might be due to invalid IL or missing references)
			//IL_022d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0232: Unknown result type (might be due to invalid IL or missing references)
			handler.lasGlueModeOnAttaching = Owner._glueModeExecuted;
			baseRotationOnStepUp = Owner.BaseTransform.rotation;
			if (handler.glueAnimationBlend < 0.2f)
			{
				animationMoveType = EMoveType.FromAnimation;
			}
			else if (handler.lasGlueModeOnAttaching == EGlueMode.Moving)
			{
				animationMoveType = EMoveType.FromAnimation;
			}
			else if (animationMoveType == EMoveType.FromLastAttachement)
			{
				animationMoveType = EMoveType.FromLastAttachement;
			}
			else if (handler.glueAnimationBlend > 0.75f)
			{
				if (transitionProgress < 0.1f || transitionProgress > 0.9f)
				{
					animationMoveType = EMoveType.FromLastAttachement;
				}
				else
				{
					animationMoveType = EMoveType.FromAnimation;
				}
			}
			else
			{
				animationMoveType = EMoveType.FromAnimation;
			}
			if (leg.Owner.OnlyLocalAnimation)
			{
				previousPositionWorld = leg.RootSpaceToWorld(lastAppliedGluePositionLocal);
			}
			else
			{
				previousPositionWorld = lastAppliedGluePosition;
			}
			previousRotationWorld = lastAppliedGlueRotation;
			previousPositionLocal = Owner.ToRootLocalSpace(previousPositionWorld);
			if (animationMoveType == EMoveType.FromLastAttachement)
			{
				if (!(transitionProgress > 0.1f) || !(transitionProgress < 0.9f))
				{
					transitionProgress = 0f;
				}
				Vector3 val = previousPositionWorld;
				Vector3 val2 = leg.ankleAlignedOnGroundHitWorldPos - val;
				float magnitude = ((Vector3)(ref val2)).magnitude;
				legMoveDistanceFactor = magnitude / (Owner.ScaleReference * 0.6f);
				legMoveDistanceFactor = Mathf.Clamp(legMoveDistanceFactor, 0.05f, 1f);
				Vector3 val3 = ((Vector3)(ref val2)).normalized;
				val3 = Vector3.ProjectOnPlane(val3, Owner.Up);
				((Vector3)(ref val3)).Normalize();
				leg.SendRaiseEvent(magnitude);
				if (legMoveDistanceFactor > 0.0401f)
				{
					_legMoveDurMul = Mathf.Lerp(1.55f, 0.85f, legMoveDistanceFactor * 2f);
					Vector3 worldDir = Vector3.Cross(val3, Owner.Up);
					((Vector3)(ref worldDir)).Normalize();
					_legSpherizeLocalVector = leg.ToRootLocalSpaceDir(worldDir) * Owner.ScaleReferenceNoScale * -0.03f;
					duringLegAdjustMovement = true;
				}
				else
				{
					animationMoveType = EMoveType.FromAnimation;
					_legSpherizeLocalVector = Vector3.zero;
					duringLegAdjustMovement = false;
				}
			}
			else
			{
				duringLegAdjustMovement = false;
				transitionProgress = 0f;
			}
		}

		public void UpdateAnimation()
		{
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0211: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0192: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
			float num = (Owner.JustGrounded ? 0.2f : 1f);
			float num2 = (Owner.JustGrounded ? 5f : 1f);
			transitionProgressLastFrame = transitionProgress;
			if (_instantTransition)
			{
				_instantTransition = false;
				transitionProgress = 1f;
				lastAttachCompleteTime = Time.time;
			}
			if (!Owner.IsGrounded)
			{
				return;
			}
			if (animationMoveType == EMoveType.FromLastAttachement)
			{
				float num3 = 1f / (leg.LegAnimatingSettings.StepMoveDuration * 0.8f);
				float num4 = 1f;
				lastSpeedup = 1f;
				if (leg.LegAnimatingSettings.AllowSpeedups > 0f)
				{
					if (leg.hasOppositeleg)
					{
						Leg oppositeLeg = leg.GetOppositeLeg();
						Vector3 targetPos = oppositeLeg._PreviousFinalIKPos;
						if (leg.Owner.OnlyLocalAnimation)
						{
							targetPos = leg.RootSpaceToWorld(oppositeLeg._PreviousFinalIKPosRootLocal);
						}
						float stretchValue = oppositeLeg.IKProcessor.GetStretchValue(targetPos);
						if (stretchValue > leg.LegStretchLimit * 0.95f)
						{
							float num5 = (stretchValue - leg.LegStretchLimit * 0.95f) * 2f;
							if (num5 < 0f)
							{
								num5 = 0f;
							}
							num4 += num5;
						}
						if (!oppositeLeg._UsingCustomRaycast && oppositeLeg.G_AttachementHandler.legMoveAnimation.attached)
						{
							Vector3 val = leg.RootSpaceToWorld(oppositeLeg.AnkleH.LastKeyframeRootPos) - oppositeLeg.G_Attachement.GetRelevantHitPoint();
							float magnitude = ((Vector3)(ref val)).magnitude;
							float num6 = Owner.ScaleReference * 0.4f;
							if (magnitude > num6)
							{
								float num7 = magnitude - num6;
								num4 += num7 / num6 * 2f;
							}
						}
					}
					if (leg.LegAnimatingSettings.AllowSpeedups > 0.25f)
					{
						float num8 = Quaternion.Angle(baseRotationOnStepUp, Owner.BaseTransform.rotation);
						if (num8 > 12f)
						{
							float num9 = Mathf.InverseLerp(30f, 135f, num8);
							num9 = Mathf.LerpUnclamped(0.5f, 2f, num9) * (0.4f + leg.LegAnimatingSettings.AllowSpeedups * 0.6f);
							transitionProgress += Owner.DeltaTime * num9 * num2;
						}
					}
					num4 = Mathf.LerpUnclamped(1f, num4, leg.LegAnimatingSettings.AllowSpeedups);
				}
				lastSpeedup = num4;
				transitionProgress = Mathf.MoveTowards(transitionProgress, 1f, num3 * num4 * _legMoveDurMul * leg.LegMoveSpeedMultiplier * Owner.DeltaTime * num2);
				if (transitionProgress > 0.9995f && duringLegAdjustMovement)
				{
					TriggerAttach();
				}
			}
			else if (transitionProgress > 0.9995f && handler.glueAnimationBlend > 0.95f)
			{
				TriggerAttach();
			}
			else
			{
				transitionProgress = Mathf.SmoothDamp(transitionProgress, 1.001f, ref sd_trProgress, (0.01f + Mathf.LerpUnclamped(0.225f, 0.01f, wasAttaching ? Owner.GlueFadeInSpeed : Owner.GlueFadeOutSpeed)) * num, 10000000f, Owner.DeltaTime);
			}
		}

		private void TriggerAttach()
		{
			if (!attached)
			{
				transitionProgress = 1f;
				lastAttachCompleteTime = Time.time;
				attached = leg.Glue_TriggerFinalAttach();
				duringLegAdjustMovement = false;
			}
		}

		public void PostUpdate()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			lastAppliedGluePosition = leg._GluePosition;
			lastAppliedGluePositionLocal = leg.ToRootLocalSpace(lastAppliedGluePosition);
			lastAppliedGlueRotation = leg._GlueRotation;
			if (!_wasAnimatingLeg)
			{
				LegAdjustementFootAngleOffset = Mathf.MoveTowards(LegAdjustementFootAngleOffset, 0f, leg.DeltaTime * 20f);
				LegAdjustementYOffset = Mathf.MoveTowards(LegAdjustementYOffset, 0f, leg.DeltaTime * 20f);
			}
			else
			{
				_wasAnimatingLeg = false;
			}
		}
	}

	private LegsAnimator Owner;

	private Leg ParentLeg;

	private float _sd_glueAnimationBlend;

	private bool _instantTransition;

	private Vector3 lastGluePosition = Vector3.zero;

	private Quaternion lastGlueRotation = Quaternion.identity;

	public LegTransitionAnimation legMoveAnimation { get; private set; }

	private Leg leg => ParentLeg;

	public float glueAnimationBlend { get; private set; }

	public float attachTransitionProgress => legMoveAnimation.transitionProgress;

	public float attachTransitionProgressLastFrame => legMoveAnimation.transitionProgressLastFrame;

	public float legMoveDistanceFactor => legMoveAnimation.legMoveDistanceFactor;

	public EGlueMode lasGlueModeOnAttaching { get; private set; }

	public GlueAttachementHandler(Leg leg)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		ParentLeg = leg;
		Owner = leg.Owner;
		legMoveAnimation = new LegTransitionAnimation(this);
		lasGlueModeOnAttaching = Owner._glueModeExecuted;
		Reset(initializing: true);
	}

	public void Reset(bool initializing)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		glueAnimationBlend = 0f;
		_sd_glueAnimationBlend = 0f;
		if (initializing)
		{
			lastGluePosition = leg.BoneEnd.position;
			lastGlueRotation = leg.BoneEnd.rotation;
		}
		legMoveAnimation.Reset();
	}

	public void SheduleInstantTransition()
	{
		_instantTransition = true;
		legMoveAnimation.ScheduleInstantTransition();
	}

	public void TransitionToGlueAnimation()
	{
		legMoveAnimation.DoAttaching(canAttach: true);
		ChangeGlueAnimationBlendTo(1f, Owner.GlueFadeInSpeed);
	}

	public void TransitionToDisableGlueAnimation()
	{
		legMoveAnimation.DoAttaching(canAttach: false);
		ChangeGlueAnimationBlendTo(0f, Owner.GlueFadeOutSpeed);
	}

	public Vector3 GetGluePosition()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (glueAnimationBlend > 0.9995f)
		{
			lastGluePosition = legMoveAnimation.GetTargetPosition();
		}
		else if (glueAnimationBlend < 0.0001f)
		{
			lastGluePosition = leg.A_PreIKPosForGluing;
		}
		else
		{
			lastGluePosition = Vector3.LerpUnclamped(leg.A_PreIKPosForGluing, legMoveAnimation.GetTargetPosition(), glueAnimationBlend);
		}
		return lastGluePosition;
	}

	public Quaternion GetGlueRotation()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (glueAnimationBlend > 0.999f)
		{
			lastGlueRotation = legMoveAnimation.GetTargetRotation();
		}
		else if (glueAnimationBlend < 0f)
		{
			lastGlueRotation = leg._FinalIKRot;
		}
		else
		{
			lastGlueRotation = Quaternion.LerpUnclamped(leg._FinalIKRot, legMoveAnimation.GetTargetRotation(), glueAnimationBlend);
		}
		return lastGlueRotation;
	}

	public void UpdateTransitioning(bool attaching)
	{
		legMoveAnimation.UpdateAnimation();
	}

	public void PostUpdate()
	{
		legMoveAnimation.PostUpdate();
	}

	internal void OnLegRequireRepose()
	{
		legMoveAnimation.RequireRepose();
	}

	private void ChangeGlueAnimationBlendTo(float target, float speed)
	{
		if (Owner.GroundedTime < 0f)
		{
			speed = 0.99f;
		}
		if (_instantTransition && target > 0f)
		{
			glueAnimationBlend = target;
			_instantTransition = false;
			return;
		}
		if (speed >= 1f)
		{
			glueAnimationBlend = target;
			return;
		}
		if (leg.G_JustLanded)
		{
			glueAnimationBlend = Mathf.MoveTowards(glueAnimationBlend, target, Owner.DeltaTime * 3f);
		}
		glueAnimationBlend = Mathf.SmoothDamp(glueAnimationBlend, target, ref _sd_glueAnimationBlend, Mathf.LerpUnclamped(0.2f, 0.005f, speed), 100000f, Owner.DeltaTime);
		if (float.IsNaN(_sd_glueAnimationBlend))
		{
			_sd_glueAnimationBlend = 0f;
		}
	}
}


using UnityEngine;

public class LegTransitionAnimation
{
	private enum EMoveType
	{
		FromAnimation,
		FromLastAttachement
	}

	private GlueAttachementHandler handler;

	public float LegAdjustementYOffset;

	public float LegAdjustementFootAngleOffset;

	private Vector3 _legSpherizeLocalVector = Vector3.zero;

	private float _legMoveDurMul = 1f;

	private Quaternion baseRotationOnStepUp;

	public float legMoveDistanceFactor;

	private float sd_trProgress;

	private Vector3 previousPositionLocal;

	private Vector3 previousPositionWorld;

	private Quaternion previousRotationWorld;

	private Vector3 lastAppliedGluePosition;

	private Vector3 lastAppliedGluePositionLocal;

	private Quaternion lastAppliedGlueRotation;

	private float lastSpeedup;

	private EMoveType animationMoveType;

	private bool _instantTransition;

	private bool _wasAnimatingLeg;

	private LegsAnimator Owner => handler.Owner;

	private Leg leg => handler.leg;

	public bool duringLegAdjustMovement { get; private set; }

	public bool wasAttaching { get; private set; }

	public bool attached { get; private set; }

	public float transitionProgress { get; private set; }

	public float lastAttachCompleteTime { get; private set; }

	public float transitionProgressLastFrame { get; private set; }

	public EGlueMode LastAnimationGlueMode
	{
		get
		{
			if (animationMoveType != 0)
			{
				return EGlueMode.Idle;
			}
			return EGlueMode.Moving;
		}
	}

	public LegTransitionAnimation(GlueAttachementHandler glueTransitionHelper)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		handler = glueTransitionHelper;
		Reset();
	}

	public void Reset()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		animationMoveType = EMoveType.FromAnimation;
		transitionProgress = 0f;
		transitionProgressLastFrame = 0f;
		baseRotationOnStepUp = Owner.BaseTransform.rotation;
		duringLegAdjustMovement = false;
		wasAttaching = false;
		attached = false;
		_legSpherizeLocalVector = Vector3.zero;
		ReInitialize();
	}

	public void ReInitialize()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		lastAppliedGluePosition = leg._SourceIKPos;
		lastAppliedGlueRotation = leg._SourceIKRot;
		previousPositionWorld = leg._SourceIKPos;
		previousRotationWorld = leg._SourceIKRot;
		previousPositionLocal = leg.ToRootLocalSpace(leg._SourceIKPos);
	}

	internal void ScheduleInstantTransition()
	{
		_instantTransition = true;
	}

	internal void DoAttaching(bool canAttach)
	{
		if (canAttach != wasAttaching)
		{
			wasAttaching = canAttach;
			if (canAttach)
			{
				OnChangeTargetPosition();
			}
			else
			{
				attached = false;
				if (transitionProgress != 0f)
				{
					OnChangeTargetPosition();
				}
			}
		}
		if (duringLegAdjustMovement && transitionProgress >= 1f)
		{
			duringLegAdjustMovement = false;
		}
	}

	internal Vector3 EnsureAnkleNotOverlappingGroundLevel(Vector3 legAnimPos)
	{
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (leg.A_PreWasAligning && leg.A_WasAligningFrameBack)
		{
			Vector3 val = Owner.ToRootLocalSpace(legAnimPos);
			Vector3 val2 = ((!(Owner.SmoothSuddenSteps < 0.0001f)) ? (leg.A_WasSmoothing ? leg.A_LastSmoothTargetedPosLocal : leg.ankleAlignedOnGroundHitRootLocal) : leg.ankleAlignedOnGroundHitRootLocal);
			if (val.y < val2.y)
			{
				val.y = val2.y;
				legAnimPos = Owner.RootToWorldSpace(val);
			}
		}
		return legAnimPos;
	}

	public Vector3 CalculateAnimatedLegPosition(Vector3 a, Vector3 b)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		LegStepAnimatingParameters legAnimatingSettings = leg.LegAnimatingSettings;
		Vector3 val = Vector3.LerpUnclamped(a, b, legAnimatingSettings.MoveToGoalCurve.Evaluate(transitionProgress));
		if (legAnimatingSettings.SpherizeTrack.length > 1)
		{
			float num = legAnimatingSettings.SpherizeTrack.Evaluate(transitionProgress) * legAnimatingSettings.SpherizePower * Owner.BaseTransform.lossyScale.x;
			val += leg.RootSpaceToWorldVec(_legSpherizeLocalVector * (num * 12f));
		}
		if (Owner.AnimateFeet)
		{
			LegAdjustementFootAngleOffset = legAnimatingSettings.FootRotationCurve.Evaluate(transitionProgress) * 90f * Mathf.Min(0.5f, legMoveDistanceFactor * 1.1f);
			LegAdjustementFootAngleOffset /= lastSpeedup;
		}
		float num2 = Owner.ScaleReferenceNoScale * 0.75f;
		float num3 = Mathf.Lerp(legAnimatingSettings.MinFootRaise, legAnimatingSettings.MaxFootRaise, legMoveDistanceFactor);
		num3 *= num2;
		LegAdjustementYOffset = num3 * legAnimatingSettings.RaiseYAxisCurve.Evaluate(transitionProgress);
		_wasAnimatingLeg = true;
		return val;
	}

	internal Vector3 GetTargetPosition()
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		float glueAnimationBlend = handler.glueAnimationBlend;
		if (animationMoveType == EMoveType.FromAnimation)
		{
			if (glueAnimationBlend < 0.0001f)
			{
				return Owner.RootToWorldSpace(previousPositionLocal);
			}
			Vector3 val = Owner.RootToWorldSpace(previousPositionLocal);
			if (transitionProgress < 0.0001f)
			{
				return val;
			}
			Vector3 val2 = ((!attached) ? leg.ankleAlignedOnGroundHitWorldPos : ((glueAnimationBlend > 0.9995f) ? leg._GlueLastAttachPosition : ((!leg.Owner.OnlyLocalAnimation) ? Vector3.LerpUnclamped(leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal), leg._GlueLastAttachPosition, glueAnimationBlend) : leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal))));
			if (transitionProgress > 0.9995f)
			{
				return val2;
			}
			return Vector3.LerpUnclamped(val, val2, transitionProgress);
		}
		Vector3 val3;
		if (leg.Owner.OnlyLocalAnimation)
		{
			val3 = Owner.RootToWorldSpace(previousPositionLocal);
			if (transitionProgress < 0.0001f)
			{
				return val3;
			}
		}
		else
		{
			val3 = previousPositionWorld;
			if (transitionProgress < 0.0001f)
			{
				return val3;
			}
			val3 = Vector3.LerpUnclamped(previousPositionWorld, Owner.RootToWorldSpace(previousPositionLocal), transitionProgress);
		}
		Vector3 val4 = ((!(transitionProgress > 0.9995f)) ? CalculateAnimatedLegPosition(val3, leg.ankleAlignedOnGroundHitWorldPos) : leg._GlueLastAttachPosition);
		if (transitionProgress >= 1f)
		{
			return val4;
		}
		float num = 1f - transitionProgress;
		return Vector3.LerpUnclamped(val3, val4, 1f - num * num);
	}

	internal void RequireRepose()
	{
		if (attached)
		{
			attached = false;
			OnChangeTargetPosition();
		}
	}

	internal Quaternion GetTargetRotation()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = previousRotationWorld;
		if (transitionProgress < 0.001f)
		{
			return val;
		}
		Quaternion val2 = ((!attached) ? leg.ankleAlignedOnGroundHitRotation : leg._GlueLastAttachRotation);
		if (transitionProgress > 0.9995f)
		{
			return val2;
		}
		return Quaternion.LerpUnclamped(val, val2, transitionProgress);
	}

	internal void OnChangeTargetPosition()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		handler.lasGlueModeOnAttaching = Owner._glueModeExecuted;
		baseRotationOnStepUp = Owner.BaseTransform.rotation;
		if (handler.glueAnimationBlend < 0.2f)
		{
			animationMoveType = EMoveType.FromAnimation;
		}
		else if (handler.lasGlueModeOnAttaching == EGlueMode.Moving)
		{
			animationMoveType = EMoveType.FromAnimation;
		}
		else if (animationMoveType == EMoveType.FromLastAttachement)
		{
			animationMoveType = EMoveType.FromLastAttachement;
		}
		else if (handler.glueAnimationBlend > 0.75f)
		{
			if (transitionProgress < 0.1f || transitionProgress > 0.9f)
			{
				animationMoveType = EMoveType.FromLastAttachement;
			}
			else
			{
				animationMoveType = EMoveType.FromAnimation;
			}
		}
		else
		{
			animationMoveType = EMoveType.FromAnimation;
		}
		if (leg.Owner.OnlyLocalAnimation)
		{
			previousPositionWorld = leg.RootSpaceToWorld(lastAppliedGluePositionLocal);
		}
		else
		{
			previousPositionWorld = lastAppliedGluePosition;
		}
		previousRotationWorld = lastAppliedGlueRotation;
		previousPositionLocal = Owner.ToRootLocalSpace(previousPositionWorld);
		if (animationMoveType == EMoveType.FromLastAttachement)
		{
			if (!(transitionProgress > 0.1f) || !(transitionProgress < 0.9f))
			{
				transitionProgress = 0f;
			}
			Vector3 val = previousPositionWorld;
			Vector3 val2 = leg.ankleAlignedOnGroundHitWorldPos - val;
			float magnitude = ((Vector3)(ref val2)).magnitude;
			legMoveDistanceFactor = magnitude / (Owner.ScaleReference * 0.6f);
			legMoveDistanceFactor = Mathf.Clamp(legMoveDistanceFactor, 0.05f, 1f);
			Vector3 val3 = ((Vector3)(ref val2)).normalized;
			val3 = Vector3.ProjectOnPlane(val3, Owner.Up);
			((Vector3)(ref val3)).Normalize();
			leg.SendRaiseEvent(magnitude);
			if (legMoveDistanceFactor > 0.0401f)
			{
				_legMoveDurMul = Mathf.Lerp(1.55f, 0.85f, legMoveDistanceFactor * 2f);
				Vector3 worldDir = Vector3.Cross(val3, Owner.Up);
				((Vector3)(ref worldDir)).Normalize();
				_legSpherizeLocalVector = leg.ToRootLocalSpaceDir(worldDir) * Owner.ScaleReferenceNoScale * -0.03f;
				duringLegAdjustMovement = true;
			}
			else
			{
				animationMoveType = EMoveType.FromAnimation;
				_legSpherizeLocalVector = Vector3.zero;
				duringLegAdjustMovement = false;
			}
		}
		else
		{
			duringLegAdjustMovement = false;
			transitionProgress = 0f;
		}
	}

	public void UpdateAnimation()
	{
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		float num = (Owner.JustGrounded ? 0.2f : 1f);
		float num2 = (Owner.JustGrounded ? 5f : 1f);
		transitionProgressLastFrame = transitionProgress;
		if (_instantTransition)
		{
			_instantTransition = false;
			transitionProgress = 1f;
			lastAttachCompleteTime = Time.time;
		}
		if (!Owner.IsGrounded)
		{
			return;
		}
		if (animationMoveType == EMoveType.FromLastAttachement)
		{
			float num3 = 1f / (leg.LegAnimatingSettings.StepMoveDuration * 0.8f);
			float num4 = 1f;
			lastSpeedup = 1f;
			if (leg.LegAnimatingSettings.AllowSpeedups > 0f)
			{
				if (leg.hasOppositeleg)
				{
					Leg oppositeLeg = leg.GetOppositeLeg();
					Vector3 targetPos = oppositeLeg._PreviousFinalIKPos;
					if (leg.Owner.OnlyLocalAnimation)
					{
						targetPos = leg.RootSpaceToWorld(oppositeLeg._PreviousFinalIKPosRootLocal);
					}
					float stretchValue = oppositeLeg.IKProcessor.GetStretchValue(targetPos);
					if (stretchValue > leg.LegStretchLimit * 0.95f)
					{
						float num5 = (stretchValue - leg.LegStretchLimit * 0.95f) * 2f;
						if (num5 < 0f)
						{
							num5 = 0f;
						}
						num4 += num5;
					}
					if (!oppositeLeg._UsingCustomRaycast && oppositeLeg.G_AttachementHandler.legMoveAnimation.attached)
					{
						Vector3 val = leg.RootSpaceToWorld(oppositeLeg.AnkleH.LastKeyframeRootPos) - oppositeLeg.G_Attachement.GetRelevantHitPoint();
						float magnitude = ((Vector3)(ref val)).magnitude;
						float num6 = Owner.ScaleReference * 0.4f;
						if (magnitude > num6)
						{
							float num7 = magnitude - num6;
							num4 += num7 / num6 * 2f;
						}
					}
				}
				if (leg.LegAnimatingSettings.AllowSpeedups > 0.25f)
				{
					float num8 = Quaternion.Angle(baseRotationOnStepUp, Owner.BaseTransform.rotation);
					if (num8 > 12f)
					{
						float num9 = Mathf.InverseLerp(30f, 135f, num8);
						num9 = Mathf.LerpUnclamped(0.5f, 2f, num9) * (0.4f + leg.LegAnimatingSettings.AllowSpeedups * 0.6f);
						transitionProgress += Owner.DeltaTime * num9 * num2;
					}
				}
				num4 = Mathf.LerpUnclamped(1f, num4, leg.LegAnimatingSettings.AllowSpeedups);
			}
			lastSpeedup = num4;
			transitionProgress = Mathf.MoveTowards(transitionProgress, 1f, num3 * num4 * _legMoveDurMul * leg.LegMoveSpeedMultiplier * Owner.DeltaTime * num2);
			if (transitionProgress > 0.9995f && duringLegAdjustMovement)
			{
				TriggerAttach();
			}
		}
		else if (transitionProgress > 0.9995f && handler.glueAnimationBlend > 0.95f)
		{
			TriggerAttach();
		}
		else
		{
			transitionProgress = Mathf.SmoothDamp(transitionProgress, 1.001f, ref sd_trProgress, (0.01f + Mathf.LerpUnclamped(0.225f, 0.01f, wasAttaching ? Owner.GlueFadeInSpeed : Owner.GlueFadeOutSpeed)) * num, 10000000f, Owner.DeltaTime);
		}
	}

	private void TriggerAttach()
	{
		if (!attached)
		{
			transitionProgress = 1f;
			lastAttachCompleteTime = Time.time;
			attached = leg.Glue_TriggerFinalAttach();
			duringLegAdjustMovement = false;
		}
	}

	public void PostUpdate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		lastAppliedGluePosition = leg._GluePosition;
		lastAppliedGluePositionLocal = leg.ToRootLocalSpace(lastAppliedGluePosition);
		lastAppliedGlueRotation = leg._GlueRotation;
		if (!_wasAnimatingLeg)
		{
			LegAdjustementFootAngleOffset = Mathf.MoveTowards(LegAdjustementFootAngleOffset, 0f, leg.DeltaTime * 20f);
			LegAdjustementYOffset = Mathf.MoveTowards(LegAdjustementYOffset, 0f, leg.DeltaTime * 20f);
		}
		else
		{
			_wasAnimatingLeg = false;
		}
	}
}


private enum EMoveType
{
	FromAnimation,
	FromLastAttachement
}


public enum GlueReposeRequest
{
	None,
	Repose,
	ReposeIfFar
}


using UnityEngine;

public class LegHelper
{
	public Transform Bone;

	public LegHelper Child;

	public Vector3 InitPositionRootSpace;

	public Vector3 LastKeyframeRootPos;

	public LegHelper(Leg leg, Transform bone)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Bone = bone;
		InitPositionRootSpace = leg.ToRootLocalSpace(bone.position);
	}

	public void Calibrate(Leg leg, Vector3 wPos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		LastKeyframeRootPos = leg.ToRootLocalSpace(wPos);
	}
}


public enum ELegSide
{
	Undefined,
	Left,
	Right
}


using System;
using System.Globalization;
using UnityEngine;

[Serializable]
public class LegStepAnimatingParameters
{
	[Range(0.1f, 1f)]
	[Tooltip("Average duration of the automatic leg animation")]
	public float StepMoveDuration = 0.375f;

	[Tooltip("Curve of ik point going towards desired position (just XZ movement, to Y - no leg rise curve)")]
	[FPD_FixedCurveWindow(0f, 0f, 1f, 1.25f, 0.4f, 0.5f, 1f, 1f)]
	public AnimationCurve MoveToGoalCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	[Tooltip("Making foot motion move towards target not in full linear straight towards target motion but adding a bit curve back (positive value) or forward (negative values) making movement a bit more natural")]
	[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0.4f, 0.6f, 0.9f, 1f)]
	public AnimationCurve SpherizeTrack = AnimationCurve.EaseInOut(0f, 0f, 1f, 0f);

	[Range(0f, 2f)]
	public float SpherizePower = 0.3f;

	[Tooltip("Minimum leg raise height. If distance of target step animation is small, then foot raise is smaller - down to this minimum raise value.")]
	[Range(0f, 1f)]
	public float MinFootRaise = 0.1f;

	[Tooltip("Maximum leg raise height. If distance of target step animation is very big, then foot raise is bigger - up to this maximum raise value.")]
	[Range(0f, 1f)]
	public float MaxFootRaise = 0.4f;

	[Tooltip("Raise height step animation curve evaluated on step animation duration.")]
	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.5f, 1f, 0.5f, 1f)]
	public AnimationCurve RaiseYAxisCurve;

	[Tooltip("Allowing to speed up leg adjusting animation when leg is getting stretched, when opposite leg is requesting adjustement or when main character is rotating in place quickly")]
	[Range(0f, 1f)]
	[Space(3f)]
	public float AllowSpeedups = 0.4f;

	[Tooltip("You can allow to use opposite leg before idle glue leg adjustement finishes")]
	[Range(0.1f, 1f)]
	public float AllowDetachBefore = 1f;

	[Tooltip("Extra hips push power animation curve evaluated on step animation duration.")]
	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 1f, 0.6f, 0.6f, 1f)]
	public AnimationCurve PushHipsOnMoveCurve;

	[Tooltip("Extra foot ankle rotation animation curve evaluated on step animation duration.")]
	[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0f, 1f, 1f, 1f)]
	public AnimationCurve FootRotationCurve;

	public void RefreshDefaultCurves()
	{
		Curves_RefreshMoveToGoalCurve();
		Curves_RefreshRaiseYAxisCurve();
		Curves_RefreshSpherizeTrack();
		Curves_RefreshFootRotationCurve();
		Curves_RefreshPushHipsOnMoveCurve();
	}

	public void Curves_RefreshRaiseYAxisCurve()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		RaiseYAxisCurve = new AnimationCurve();
		RaiseYAxisCurve.AddKey(new Keyframe(0f, 0f, 0.8504464f, 0.8504464f, 0f, 0.6517575f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.2731183f, 0.45f, 0.9770691f, 0.9770691f, 0.3333333f, 0.3387407f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.505118f, 0.5f, -0.2710344f, -0.2710344f, 0.3333333f, 0.3333333f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.9110107f, 0f, -0.1500788f, -0.1500788f, 0.5409704f, 0f));
	}

	public void Curves_RefreshRaiseYAxisCurveSpiderPreset()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		RaiseYAxisCurve = new AnimationCurve();
		RaiseYAxisCurve.AddKey(new Keyframe(0f, 0f, 0.8504464f, 0.8504464f, 0f, 0.6517575f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.2731183f, 0.45f, 0.9770691f, 0.9770691f, 0.3333333f, 0.3387407f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.5943514f, 0.7946472f, -0.2710344f, -0.2710344f, 0.3333333f, 0.3333333f));
		RaiseYAxisCurve.AddKey(new Keyframe(1f, 0f, -0.1500788f, -0.1500788f, 0.5409704f, 0f));
	}

	public void Curves_RefreshMoveToGoalCurve()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		MoveToGoalCurve = new AnimationCurve();
		MoveToGoalCurve.AddKey(new Keyframe(0f, 0f, 0f, 0f, 0f, 0.1842105f));
		MoveToGoalCurve.AddKey(new Keyframe(0.4885197f, 0.8972011f, 1.38764f, 1.38764f, 0.3333333f, 0.3333333f));
		MoveToGoalCurve.AddKey(new Keyframe(1f, 1f, 0f, 0f, 0f, 0f));
	}

	public void Curves_RefreshFootRotationCurve()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		FootRotationCurve = new AnimationCurve();
		FootRotationCurve.AddKey(new Keyframe(0f, 0f, 0.5764588f, 0.5764588f, 0f, 0.4956417f));
		FootRotationCurve.AddKey(new Keyframe(0.4378169f, 0.2035736f, -0.2411275f, -0.2411275f, 0.3333333f, 0.4033037f));
		FootRotationCurve.AddKey(new Keyframe(0.7841034f, -0.1339308f, 0.3331003f, 0.3331003f, 0.3333333f, 0.3333333f));
		FootRotationCurve.AddKey(new Keyframe(1f, 0f, 0.3498169f, 0.3498169f, 0.5534658f, 0f));
	}

	public void Curves_RefreshPushHipsOnMoveCurve()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		PushHipsOnMoveCurve = new AnimationCurve();
		PushHipsOnMoveCurve.AddKey(new Keyframe(0f, 0f, 5.630541f, 5.630541f, 0f, 0.198735f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(0.383f, 0.3733972f, -0.1664574f, -0.1664574f, 0.333f, 0.2940554f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(0.7075226f, 0.1460427f, -1.565806f, -1.565806f, 0.3605607f, 0.3446763f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(1f, 0f, 0f, 0f, 0.09374858f, 0f));
	}

	public void Curves_RefreshPushHipsOnMoveCurveSpiderPreset()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		PushHipsOnMoveCurve = new AnimationCurve();
		PushHipsOnMoveCurve.AddKey(new Keyframe(0f, 0f, 5.630541f, 5.630541f, 0f, 0.198735f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(0.320017f, 0.654645f, -0.1664574f, -0.1664574f, 0.333f, 0.2940554f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(0.6681702f, 0.2174691f, -1.565806f, -1.565806f, 0.3605607f, 0.3446763f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(1f, 0f, 0f, 0f, 0.09374858f, 0f));
	}

	public void Curves_RefreshSpherizeTrack()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		SpherizeTrack = new AnimationCurve();
		SpherizeTrack.AddKey(new Keyframe(0f, 0f, 0.6958197f, 0.6958197f, 0f, 0.460011f));
		SpherizeTrack.AddKey(new Keyframe(0.4f, 0.3f, -0.04204308f, -0.04204308f, 0.333f, 0.3410656f));
		SpherizeTrack.AddKey(new Keyframe(0.85f, 0f, -0.2721428f, -0.2721428f, 0.3953607f, 0f));
	}

	public void LogCurve(string name, AnimationCurve c)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		string text = "";
		IFormatProvider invariantCulture = CultureInfo.InvariantCulture;
		for (int i = 0; i < c.keys.Length; i++)
		{
			Keyframe val = c.keys[i];
			text = text + "\n" + name + ".AddKey(new Keyframe(" + ((Keyframe)(ref val)).time.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).value.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).inTangent.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).outTangent.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).inWeight.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).outWeight.ToString(invariantCulture) + "f));";
		}
		Debug.Log((object)text);
	}
}


using UnityEngine;

public enum EGlueMode
{
	[Tooltip("Idle Mode is applying leg animation with extra motion and is checking some extra conditions like opposite leg grounded state etc.")]
	Idle,
	[Tooltip("Moving Mode is dedicated to be applied during playing animations with dynamic legs, it's checking less conditions than Idle Mode and is snapping glue points in a more straight forward slide animation.")]
	Moving,
	[Tooltip("Automatic mode is syncing with IsMoving/IsIdling LegsAnimator flags.")]
	Automatic
}


using System;
using UnityEngine;

[Serializable]
public class Variable
{
	public enum EVariableType
	{
		Number,
		Bool,
		Vector2,
		Vector3,
		String,
		Curve,
		UnityObject,
		CustomObject
	}

	public string VariableName = "Variable";

	[SerializeField]
	private string Tooltip = "";

	private bool _tooltipWasSet;

	[SerializeField]
	private Vector4 _value = Vector4.zero;

	[SerializeField]
	private string _string = "";

	[SerializeField]
	private AnimationCurve _curve;

	[SerializeField]
	private Object _uObject;

	[SerializeField]
	private object _object;

	[NonSerialized]
	private int nameHash;

	public EVariableType VariableType;

	[SerializeField]
	private Vector4 _rangeHelper = Vector4.zero;

	public bool TooltipAssigned => _tooltipWasSet;

	public int GetNameHash
	{
		get
		{
			if (nameHash == 0)
			{
				nameHash = VariableName.GetHashCode();
			}
			return nameHash;
		}
	}

	public void AssignTooltip(string tooltip)
	{
		if (!_tooltipWasSet)
		{
			Tooltip = tooltip;
			_tooltipWasSet = true;
		}
	}

	public Variable(string name, object value)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		VariableName = name;
		SetValue(value);
	}

	public void SetValue(object o)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		if (o is int)
		{
			_value = new Vector4((float)(int)o, 0f, 0f, 1f);
			VariableType = EVariableType.Number;
		}
		else if (o is float)
		{
			_value = new Vector4((float)o, 0f, 0f, 0f);
			VariableType = EVariableType.Number;
		}
		else if (o is bool)
		{
			if ((bool)o)
			{
				_value.x = 1f;
			}
			else
			{
				_value.x = 0f;
			}
			VariableType = EVariableType.Bool;
		}
		else if (o is Vector2 val)
		{
			_value = Vector4.op_Implicit(val);
			VariableType = EVariableType.Vector2;
		}
		else if (o is Vector3 val2)
		{
			_value = Vector4.op_Implicit(val2);
			VariableType = EVariableType.Vector3;
		}
		else if (o is string)
		{
			_string = o as string;
			VariableType = EVariableType.String;
		}
		else if (o is AnimationCurve)
		{
			_curve = (AnimationCurve)((o is AnimationCurve) ? o : null);
			VariableType = EVariableType.Curve;
		}
		else if (o is Object)
		{
			_uObject = (Object)((o is Object) ? o : null);
			VariableType = EVariableType.UnityObject;
		}
		else
		{
			_object = o;
			VariableType = EVariableType.CustomObject;
		}
	}

	public int GetInt()
	{
		return (int)_value.x;
	}

	public float GetFloat()
	{
		return _value.x;
	}

	public bool GetBool()
	{
		return _value.x == 1f;
	}

	public Vector2 GetVector2()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(_value.x, _value.y);
	}

	public Vector3 GetVector3()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(_value.x, _value.y, _value.z);
	}

	public string GetString()
	{
		return _string;
	}

	public AnimationCurve GetCurve()
	{
		return _curve;
	}

	public Object GetUnityObject()
	{
		return _uObject;
	}

	public object GetObject()
	{
		return _object;
	}

	public void SetMinMaxSlider(float min, float max)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		_rangeHelper = new Vector4(min, max, 0f, 0f);
	}

	public void SetCurveFixedRange(float startTime, float startValue, float endTime, float endValue)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		_rangeHelper = new Vector4(startTime, startValue, endTime, endValue);
	}

	public bool Editor_DisplayVariableGUI()
	{
		return false;
	}
}


public enum EVariableType
{
	Number,
	Bool,
	Vector2,
	Vector3,
	String,
	Curve,
	UnityObject,
	CustomObject
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class ReferencePose
{
	[Serializable]
	public class LegPoseReference
	{
		public BonePoseReference UpperLegPose = new BonePoseReference();

		public BonePoseReference LowerLegPose = new BonePoseReference();

		public BonePoseReference AnklePose = new BonePoseReference();

		public BonePoseReference FeetPose = new BonePoseReference();

		public void SaveLegPose(Leg leg, LegsAnimator animator)
		{
			UpperLegPose.SavePose(leg.BoneStart, animator);
			LowerLegPose.SavePose(leg.BoneMid, animator);
			AnklePose.SavePose(leg.BoneEnd, animator);
			FeetPose.SavePose(leg.BoneFeet, animator);
		}

		public void RestoreLegPose(LegsAnimator animator)
		{
			UpperLegPose.RestorePose(animator);
			LowerLegPose.RestorePose(animator);
			AnklePose.RestorePose(animator);
			FeetPose.RestorePose(animator);
		}
	}

	[Serializable]
	public class BonePoseReference
	{
		public Transform SourceTransform;

		public Quaternion RotationInRoot;

		public Vector3 PositionInRoot;

		public void SavePose(Transform transform, LegsAnimator animator)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)animator == (Object)null) && !((Object)(object)transform == (Object)null))
			{
				SourceTransform = transform;
				PositionInRoot = animator.BaseTransform.InverseTransformPoint(transform.position);
				RotationInRoot = animator.BaseTransform.rotation.QToLocal(transform.rotation);
			}
		}

		public void RestorePose(LegsAnimator animator)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)animator == (Object)null) && !((Object)(object)SourceTransform == (Object)null))
			{
				SourceTransform.position = animator.BaseTransform.TransformPoint(PositionInRoot);
				SourceTransform.rotation = animator.BaseTransform.rotation.QToWorld(RotationInRoot);
			}
		}
	}

	public BonePoseReference MainHipsPose = new BonePoseReference();

	public List<BonePoseReference> HipsPoses = new List<BonePoseReference>();

	public List<LegPoseReference> LegPoses = new List<LegPoseReference>();

	public bool IsSet(LegsAnimator animator)
	{
		if ((Object)(object)MainHipsPose.SourceTransform != (Object)null && HipsPoses.Count == animator.ExtraHipsHubs.Count)
		{
			return LegPoses.Count == animator.Legs.Count;
		}
		return false;
	}

	public void TweakListsFor(LegsAnimator animator)
	{
		while (HipsPoses.Count > animator.ExtraHipsHubs.Count)
		{
			HipsPoses.RemoveAt(HipsPoses.Count - 1);
		}
		while (HipsPoses.Count < animator.ExtraHipsHubs.Count)
		{
			HipsPoses.Add(new BonePoseReference());
		}
		while (LegPoses.Count > animator.Legs.Count)
		{
			LegPoses.RemoveAt(LegPoses.Count - 1);
		}
		while (LegPoses.Count < animator.Legs.Count)
		{
			LegPoses.Add(new LegPoseReference());
		}
	}

	public void Clear()
	{
		MainHipsPose.SourceTransform = null;
		HipsPoses.Clear();
		LegPoses.Clear();
	}
}


using System;

[Serializable]
public class LegPoseReference
{
	public BonePoseReference UpperLegPose = new BonePoseReference();

	public BonePoseReference LowerLegPose = new BonePoseReference();

	public BonePoseReference AnklePose = new BonePoseReference();

	public BonePoseReference FeetPose = new BonePoseReference();

	public void SaveLegPose(Leg leg, LegsAnimator animator)
	{
		UpperLegPose.SavePose(leg.BoneStart, animator);
		LowerLegPose.SavePose(leg.BoneMid, animator);
		AnklePose.SavePose(leg.BoneEnd, animator);
		FeetPose.SavePose(leg.BoneFeet, animator);
	}

	public void RestoreLegPose(LegsAnimator animator)
	{
		UpperLegPose.RestorePose(animator);
		LowerLegPose.RestorePose(animator);
		AnklePose.RestorePose(animator);
		FeetPose.RestorePose(animator);
	}
}


using System;
using UnityEngine;

[Serializable]
public class BonePoseReference
{
	public Transform SourceTransform;

	public Quaternion RotationInRoot;

	public Vector3 PositionInRoot;

	public void SavePose(Transform transform, LegsAnimator animator)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)animator == (Object)null) && !((Object)(object)transform == (Object)null))
		{
			SourceTransform = transform;
			PositionInRoot = animator.BaseTransform.InverseTransformPoint(transform.position);
			RotationInRoot = animator.BaseTransform.rotation.QToLocal(transform.rotation);
		}
	}

	public void RestorePose(LegsAnimator animator)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)animator == (Object)null) && !((Object)(object)SourceTransform == (Object)null))
		{
			SourceTransform.position = animator.BaseTransform.TransformPoint(PositionInRoot);
			SourceTransform.rotation = animator.BaseTransform.rotation.QToWorld(RotationInRoot);
		}
	}
}


public enum ELegsScaleReference
{
	PelvisToGroundDistance,
	FirstLegLength,
	Custom,
	PelvisLegAverage
}


using UnityEngine;

public enum ECalibrateMode
{
	[Tooltip("No Extra overhead")]
	None,
	[Tooltip("Resetting bones local rotations to the initialized state")]
	Calibrate,
	[Tooltip("Resetting bones local rotations to the captured animator state (can fix trigger colliders detection when colliders added on legs)")]
	FixedCalibrate
}


public enum ERaycastPrecision
{
	Linecast,
	BoxcastPrecision
}


using UnityEngine;

public enum ERaycastStartHeight
{
	[Tooltip("Casting ray starting from current hips height position of the character. Can be bad for insect creatures!")]
	Hips,
	[Tooltip("Good for spiders! Casting raycast on defined height of the character")]
	StaticScaleReference,
	[Tooltip("Casting ray starting from first bone of the leg (it's affecting height + start raycast position).")]
	FirstBone
}


using UnityEngine;

public enum ERaycastStyle
{
	[Tooltip("Launching raycast from foot above origin point. Good for bipeds with whole body step down/up features.")]
	StraightDown,
	[Tooltip("Launching raycast from pelvis towards foot, good for spider like creatures to detect steep ground more effectively. Body step down/up will not work as precise with this option.")]
	OriginToFoot,
	[Tooltip("Doing raycast like OriginToFoot : but if no ground is found - using another raycast in StraightDown style to find ground below and allow to execute body step down/up feature.")]
	OriginToFoot_DownOnNeed,
	[Tooltip("Doing raycasts per bone : from start bone towards mid bone, mid bone towards end bone, then down. Best precision for insect creatures.")]
	AlongBones,
	[Tooltip("No Raycasting : provide raycast hits custom using code, or leave it custom for just gluing legs animation.")]
	NoRaycasting
}


public enum ERaycastMode
{
	Linecast,
	Spherecast
}


using UnityEngine;

public enum ENoRaycastBehviour
{
	[Tooltip("If ground raycast is lost, leg will detach and switch to ungrounded state")]
	Detach,
	[Tooltip("If no raycast hit detected, should character still animate leg steps in air on zero height floor level? (fake floor)")]
	ZeroFloorSteps,
	[Tooltip("If ground raycast is lost, leg will stick to lastest found raycast hit until leg get stretched")]
	KeepAttached
}


using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public abstract class LAM_FadeOnAnimatorStatusBase : LegsAnimatorControlModuleBase
{
	private enum ELayerSelectMode
	{
		ByIndex,
		Auto
	}

	private LegsAnimator.Variable _fadeSpeedV;

	private LegsAnimator.Variable _layerV;

	private float enabledMultiplier = 1f;

	private float sd_eneMul;

	private List<int> stateHashes;

	private List<int> tagHashes;

	private LegsAnimator.Variable _layerMode;

	private LegsAnimator.Variable _layerSkip;

	private List<int> layersToCheck;

	private int lastAutoWeightIndex;

	private bool InitLayerCheck(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if ((Object)(object)helper.Parent.Mecanim == (Object)null)
		{
			return false;
		}
		if (_layerMode.GetInt() == 0)
		{
			return false;
		}
		if (_layerMode == null || _layerSkip == null)
		{
			return false;
		}
		layersToCheck = new List<int>();
		string[] array = _layerSkip.GetString().Split(',');
		for (int i = 0; i < helper.Parent.Mecanim.layerCount; i++)
		{
			layersToCheck.Add(i);
		}
		for (int j = 0; j < array.Length; j++)
		{
			if (int.TryParse(array[j], out var result))
			{
				layersToCheck.Remove(result);
				continue;
			}
			int num = -1;
			for (int k = 0; k < helper.Parent.Mecanim.layerCount; k++)
			{
				if (helper.Parent.Mecanim.GetLayerName(k) == array[j])
				{
					num = k;
					break;
				}
			}
			if (num != -1)
			{
				layersToCheck.Remove(num);
			}
		}
		return true;
	}

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if ((Object)(object)base.LA.Mecanim == (Object)null)
		{
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: Not found animator reference in legs animator Extra/Control!");
			helper.Enabled = false;
			return;
		}
		_layerV = helper.RequestVariable("Animation Layer", 0);
		_fadeSpeedV = helper.RequestVariable("Fade Speed", 0.75f);
		LegsAnimator.Variable variable = helper.RequestVariable("Animation State Tag", "");
		string[] array = helper.RequestVariable("Animation State Name", "").GetString().Split(',');
		stateHashes = new List<int>();
		if (array.Length != 0)
		{
			for (int i = 0; i < array.Length; i++)
			{
				if (!string.IsNullOrWhiteSpace(array[i]))
				{
					stateHashes.Add(Animator.StringToHash(array[i]));
				}
			}
		}
		string[] array2 = variable.GetString().Split(',');
		tagHashes = new List<int>();
		if (array2.Length != 0)
		{
			for (int j = 0; j < array2.Length; j++)
			{
				if (!string.IsNullOrWhiteSpace(array2[j]))
				{
					tagHashes.Add(Animator.StringToHash(array2[j]));
				}
			}
		}
		if (stateHashes.Count == 0 && tagHashes.Count == 0)
		{
			helper.Enabled = false;
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: No assigned animation state names/tags to control module on!");
			return;
		}
		if (_layerV.GetInt() < 0)
		{
			_layerV.SetValue(0);
		}
		if (_layerV.GetInt() > base.LA.Mecanim.layerCount - 1)
		{
			_layerV.SetValue(base.LA.Mecanim.layerCount - 1);
		}
		_layerMode = helper.RequestVariable("Mode", 0);
		_layerSkip = helper.RequestVariable("Skip", "");
		if (_layerMode.GetInt() == 1 && !InitLayerCheck(helper))
		{
			_layerMode.SetValue(0);
		}
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		Animator mecanim = base.LA.Mecanim;
		if ((Object)(object)mecanim == (Object)null)
		{
			return;
		}
		int num = _layerV.GetInt();
		if (_layerMode.GetInt() == 1)
		{
			float num2 = 0f;
			int num3 = -1;
			for (int num4 = layersToCheck.Count - 1; num4 >= 0; num4--)
			{
				int num5 = layersToCheck[num4];
				float layerWeight = helper.Parent.Mecanim.GetLayerWeight(num5);
				if (layerWeight > 0.95f)
				{
					num3 = num5;
					break;
				}
				if (layerWeight > num2)
				{
					num2 = layerWeight;
					num3 = num5;
				}
			}
			num = (lastAutoWeightIndex = num3);
		}
		AnimatorStateInfo val = (mecanim.IsInTransition(num) ? mecanim.GetNextAnimatorStateInfo(num) : mecanim.GetCurrentAnimatorStateInfo(num));
		bool flag = false;
		for (int i = 0; i < stateHashes.Count; i++)
		{
			if (((AnimatorStateInfo)(ref val)).shortNameHash == stateHashes[i])
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			for (int j = 0; j < tagHashes.Count; j++)
			{
				if (((AnimatorStateInfo)(ref val)).tagHash == tagHashes[j])
				{
					flag = true;
					break;
				}
			}
		}
		float num6 = 0.3f - _fadeSpeedV.GetFloat() * 0.299f;
		if (flag)
		{
			enabledMultiplier = Mathf.SmoothDamp(enabledMultiplier, -0.001f, ref sd_eneMul, num6 * 0.9f, 100000f, base.LA.DeltaTime);
		}
		else
		{
			enabledMultiplier = Mathf.SmoothDamp(enabledMultiplier, 1.01f, ref sd_eneMul, num6, 100000f, base.LA.DeltaTime);
		}
		enabledMultiplier = Mathf.Clamp01(enabledMultiplier);
		OnFadeAction(helper, enabledMultiplier);
	}

	protected abstract void OnFadeAction(LegsAnimator.LegsAnimatorCustomModuleHelper helper, float fadeValue);
}


private enum ELayerSelectMode
{
	ByIndex,
	Auto
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public abstract class LegsAnimatorControlModuleBase : ScriptableObject
{
	protected Transform Transform => Owner.BaseTransform;

	protected LegsAnimator LA => Owner;

	protected LegsAnimator LegsAnim => Owner;

	protected LegsAnimator Owner { get; private set; }

	protected bool Initialized { get; private set; }

	public virtual bool AskForSpineBone => false;

	public virtual bool AskForChestBone => false;

	public float ModuleBlend { get; set; }

	public float EffectBlend => ModuleBlend * LA._MainBlend;

	public void Base_Init(LegsAnimator legs, LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		ModuleBlend = 1f;
		Owner = legs;
		OnInit(helper);
		Initialized = true;
	}

	public virtual void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnReInitialize(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnPostLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnValidateAfterManualChanges(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void Leg_LatePreRaycastingUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
	}

	public virtual void Leg_LateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
	}
}


using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_AnimationCurvesGlueCondition : LegsAnimatorControlModuleBase
{
	private LegsAnimator.LegsAnimatorCustomModuleHelper _useHelper;

	private LegsAnimator.Variable _play_FloorValueBelow;

	private LegsAnimator.Variable _play_IgnoreMidConditions;

	private LegsAnimator.Variable _play_AllowHeightGlueOnLevels;

	private List<int> animatorHashes;

	private bool initialized;

	private LegsAnimator.Variable FloorValueBelowVar => _useHelper.RequestVariable("Floor Value Below", 0.01f);

	private LegsAnimator.Variable IgnoreMidConditionsVar => _useHelper.RequestVariable("Ignore Mid Conditions", false);

	private LegsAnimator.Variable AllowHeightGlueOnLevelVar => _useHelper.RequestVariable("Allow Height Glue On Level", -1f);

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if (!((Object)(object)base.LA.Mecanim == (Object)null) && helper.customStringList != null)
		{
			_useHelper = helper;
			_play_FloorValueBelow = FloorValueBelowVar;
			_play_IgnoreMidConditions = IgnoreMidConditionsVar;
			_play_AllowHeightGlueOnLevels = AllowHeightGlueOnLevelVar;
			animatorHashes = new List<int>();
			for (int i = 0; i < base.LA.Legs.Count && i < helper.customStringList.Count; i++)
			{
				animatorHashes.Add(Animator.StringToHash(helper.customStringList[i]));
			}
			initialized = true;
		}
	}

	public override void Leg_LateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		if (!initialized || leg.G_CustomForceAttach)
		{
			return;
		}
		float num = base.LA.Mecanim.GetFloat(animatorHashes[leg.PlaymodeIndex]);
		if (num <= _play_AllowHeightGlueOnLevels.GetFloat() && leg.A_PreWasAligning)
		{
			num = _play_FloorValueBelow.GetFloat() - 0.01f;
		}
		if (num <= _play_FloorValueBelow.GetFloat())
		{
			leg.G_CustomForceAttach = base.LA.GroundedTime > 0.2f;
			if (_play_IgnoreMidConditions.GetBool())
			{
				leg.G_CustomForceNOTDetach = true;
			}
		}
		else
		{
			leg.G_CustomForceNOTAttach = true;
			if (_play_IgnoreMidConditions.GetBool())
			{
				leg.G_CustomForceDetach = true;
			}
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_AutoGroundAlignBodyMatrix : LegsAnimatorControlModuleBase
{
	private Vector3 averageNormal;

	private Vector3 animatedAverageNormal;

	private Quaternion lastOrientation;

	private LegsAnimator.Variable _blendV;

	private LegsAnimator.Variable _rotateV;

	private LegsAnimator.Variable _alignSpdV;

	private LegsAnimator.Variable _alignDownV;

	private LegsAnimator.Variable _AxisBlendV;

	private float _blend = 1f;

	public override bool AskForSpineBone => true;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		animatedAverageNormal = base.LA.Up;
		lastOrientation = base.LA.BaseTransform.rotation;
		_blendV = helper.RequestVariable("Matrix Blend", 1f);
		_rotateV = helper.RequestVariable("Rotate Hips", 1f);
		_alignSpdV = helper.RequestVariable("Aligning Speed", 0.7f);
		_alignDownV = helper.RequestVariable("Spine Restore", 0.5f);
		_AxisBlendV = helper.RequestVariable("Rotation Axis Blend", Vector3.one);
	}

	public override void Leg_LatePreRaycastingUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		_blend = base.EffectBlend;
		if (leg.RaycastHitted)
		{
			Vector3 val = averageNormal;
			RaycastHit lastGroundHit = leg.LastGroundHit;
			averageNormal = val + ((RaycastHit)(ref lastGroundHit)).normal;
		}
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = lastOrientation;
		float num = _blend * _blendV.GetFloat();
		if (num < 1f)
		{
			val = Quaternion.SlerpUnclamped(Quaternion.identity, lastOrientation, num);
		}
		Matrix4x4 mx = Matrix4x4.TRS(base.LA.BaseTransform.position, val * base.LA.BaseTransform.rotation, base.LA.BaseTransform.lossyScale);
		base.LA.User_OverwriteCastMatrix(mx);
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		float num = _blend * _rotateV.GetFloat();
		if (!(num < 0.001f))
		{
			Vector3 eulerAngles = ((Quaternion)(ref lastOrientation)).eulerAngles;
			eulerAngles.x = LAM_DirectionalMovement.FormatAngleToPM180(eulerAngles.x);
			eulerAngles.y = LAM_DirectionalMovement.FormatAngleToPM180(eulerAngles.y);
			eulerAngles.z = LAM_DirectionalMovement.FormatAngleToPM180(eulerAngles.z);
			Quaternion identity = Quaternion.identity;
			identity *= Quaternion.AngleAxis(eulerAngles.x * num, Vector3.right);
			identity *= Quaternion.AngleAxis(eulerAngles.y * num, Vector3.up);
			identity *= Quaternion.AngleAxis(eulerAngles.z * num, Vector3.forward);
			LegsAnimator lA = base.LA;
			lA._LastHipsRotationOffsetOutsideInfo *= identity;
			if (Object.op_Implicit((Object)(object)base.LA.SpineBone))
			{
				Quaternion rotation = base.LA.SpineBone.rotation;
				base.LA.HipsSetup.bone.rotation = identity * base.LA.HipsSetup.bone.rotation;
				base.LA.SpineBone.rotation = Quaternion.Slerp(base.LA.SpineBone.rotation, rotation, _alignDownV.GetFloat());
			}
			else
			{
				base.LA.HipsSetup.bone.rotation = identity * base.LA.HipsSetup.bone.rotation;
			}
		}
	}

	public override void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		if (averageNormal == Vector3.zero)
		{
			averageNormal = base.LA.Up;
		}
		else
		{
			((Vector3)(ref averageNormal)).Normalize();
		}
		if (_alignSpdV.GetFloat() < 0.999f)
		{
			float num = Mathf.LerpUnclamped(5f, 20f, _alignSpdV.GetFloat());
			animatedAverageNormal = Vector3.Slerp(animatedAverageNormal, averageNormal, base.LA.DeltaTime * num);
		}
		else
		{
			animatedAverageNormal = averageNormal;
		}
		lastOrientation = Quaternion.FromToRotation(Vector3.up, animatedAverageNormal);
		Vector3 vector = _AxisBlendV.GetVector3();
		if (vector != Vector3.one)
		{
			Vector3 eulerAngles = ((Quaternion)(ref lastOrientation)).eulerAngles;
			vector = helper.Parent.BaseTransform.TransformDirection(vector);
			lastOrientation = Quaternion.Euler(eulerAngles.x * vector.x, eulerAngles.y * vector.y, eulerAngles.z * vector.z);
		}
		averageNormal = Vector3.zero;
	}
}


using System;
using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_BasicPoseAdjust : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _AdjustPowerX;

	private LegsAnimator.Variable _AdjustPowerZ;

	[NonSerialized]
	private LegsAnimator.Leg[] legs;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_AdjustPowerX = helper.RequestVariable("Adjust X Positioning", 1f);
		_AdjustPowerZ = helper.RequestVariable("Adjust Z Positioning", 1f);
		List<LegsAnimator.Leg> list = new List<LegsAnimator.Leg>();
		if (helper.customStringList == null || helper.customStringList.Count == 0)
		{
			for (int i = 0; i < base.LA.Legs.Count; i++)
			{
				list.Add(base.LA.Legs[i]);
			}
		}
		else
		{
			for (int j = 0; j < helper.customStringList.Count; j++)
			{
				if (helper.customStringList[j] == "1")
				{
					list.Add(base.LA.Legs[j]);
				}
			}
		}
		if (list.Count == 0)
		{
			helper.Enabled = false;
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: No legs definition!");
		}
		else
		{
			legs = list.ToArray();
		}
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		if (legs == null)
		{
			return;
		}
		float effectBlend = base.EffectBlend;
		for (int i = 0; i < legs.Length; i++)
		{
			LegsAnimator.Leg leg = legs[i];
			Vector3 val = base.LA.ToRootLocalSpace(leg._AnimatorEndBonePos);
			Vector3 val2 = val;
			val2.x *= _AdjustPowerX.GetFloat();
			val2.z *= _AdjustPowerZ.GetFloat();
			if (effectBlend < 1f)
			{
				val2 = Vector3.LerpUnclamped(val, val2, effectBlend);
			}
			leg.OverrideAnimatorAnklePosition(base.LA.RootToWorldSpace(val2));
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_DesiredDirectionFromTransform : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _Reaction;

	private LegsAnimator.Variable _Thres;

	private LegsAnimator.Variable _IsMov;

	private Vector3 calculatedVelo = Vector3.zero;

	private Vector3 _sd_average = Vector3.zero;

	private Vector3 previousPosition = Vector3.zero;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		_Reaction = helper.RequestVariable("Reaction Speed", 0.8f);
		_IsMov = helper.RequestVariable("Control 'IsMoving'", false);
		_Thres = helper.RequestVariable("Not Moving Threshold", 0.2f);
		previousPosition = base.LA.BaseTransform.position;
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = base.LA.BaseTransform.position - previousPosition;
		previousPosition = base.LA.BaseTransform.position;
		Vector3 val2 = val / base.LA.DeltaTime;
		val2 = base.LA.ToRootLocalSpaceVec(val2);
		val2.y = 0f;
		val2 = base.LA.RootToWorldSpaceVec(val2);
		float magnitude = ((Vector3)(ref calculatedVelo)).magnitude;
		val2 = Vector3.Slerp(val2, ((Vector3)(ref val2)).normalized, Mathf.InverseLerp(0f, magnitude, base.LA.ScaleReference));
		calculatedVelo = Vector3.SmoothDamp(calculatedVelo, val2, ref _sd_average, 5E-05f + (1f - _Reaction.GetFloat()) * 0.15f, 100000f, base.LA.DeltaTime);
		if (_IsMov.GetBool())
		{
			base.LA.User_SetIsMoving(magnitude > base.LA.ScaleReference * _Thres.GetFloat());
		}
		base.LA.User_SetDesiredMovementDirection(calculatedVelo);
	}
}


using System;
using System.Collections.Generic;
using FIMSpace;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

[CreateAssetMenu(fileName = "LAM_DirectionalMovement", menuName = "FImpossible Creations/Legs Animator/Module - 360 Movement Animation", order = 2)]
public class LAM_DirectionalMovement : LegsAnimatorControlModuleBase
{
	[Serializable]
	public class AnglesSetup
	{
		public Vector3 AnglesOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Hips rotations on reaching 45 angle movement")]
		public Vector3 AnglesOn45 = new Vector3(-10f, 14f, -5f);

		[Tooltip(" Hips rotations on reaching 90 angle movement")]
		public Vector3 AnglesOn90 = new Vector3(-7f, 40f, -3f);

		[Tooltip(" Hips rotations on reaching 135 angle movement")]
		public Vector3 AnglesOn135 = new Vector3(-8f, -25f, -4f);

		[Tooltip(" Hips rotations on reaching 180 angle movement")]
		public Vector3 AnglesOn180 = new Vector3(-20f, 0f, 0f);

		[Space(8f)]
		public Vector3 HipsOffsetOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Hips position offset on reaching 45 angle movement")]
		public Vector3 HipsOffsetOn45 = new Vector3(-0.05f, 0f, -0.05f);

		[Tooltip(" Hips position offset on reaching 90 angle movement")]
		public Vector3 HipsOffsetOn90 = new Vector3(-0.1f, 0f, 0.05f);

		[Tooltip(" Hips position offset on reaching 135 angle movement")]
		public Vector3 HipsOffsetOn135 = new Vector3(-0.1f, 0f, 0.1f);

		[Tooltip(" Hips position offset on reaching 180 angle movement")]
		public Vector3 HipsOffsetOn180 = new Vector3(0f, 0.05f, 0.2f);

		[Space(8f)]
		public Vector3 IKsOffsetOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Foot IK position offset on reaching 45 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn45 = new Vector3(0f, 0f, -0.04f);

		[Tooltip(" Foot IK position offset on reaching 90 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn90 = new Vector3(0f, 0f, -0.08f);

		[Tooltip(" Foot IK position offset on reaching 135 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn135 = new Vector3(0f, 0f, 0.08f);

		[Tooltip(" Foot IK position offset on reaching 180 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn180 = new Vector3(0f, 0f, 0f);
	}

	private class LegRedirectHelper
	{
		private LAM_DirectionalMovement parent;

		private LegsAnimator.Leg leg;

		internal LegRedirectHelper oppositeHelper;

		private Vector3 computedPosLocal = Vector3.zero;

		private Quaternion _footRedirCache = Quaternion.identity;

		private LegsAnimator LA => parent.LA;

		public Vector3 LastComputedWorldSpaceLegPos { get; private set; }

		public LegRedirectHelper(LAM_DirectionalMovement parent, LegsAnimator.Leg leg)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			this.parent = parent;
			this.leg = leg;
			LastComputedWorldSpaceLegPos = leg.BoneEnd.position;
			computedPosLocal = leg.Owner.ToRootLocalSpace(LastComputedWorldSpaceLegPos);
		}

		public Vector3 ComputeIKOffset(Vector3 localPos, float smoother = 1f)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0133: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0172: Unknown result type (might be due to invalid IL or missing references)
			//IL_0188: Unknown result type (might be due to invalid IL or missing references)
			//IL_027a: Unknown result type (might be due to invalid IL or missing references)
			//IL_027f: Unknown result type (might be due to invalid IL or missing references)
			//IL_028a: Unknown result type (might be due to invalid IL or missing references)
			//IL_012b: Unknown result type (might be due to invalid IL or missing references)
			//IL_012c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			float @float = parent._play_TrDur.GetFloat();
			Vector3 val = parent._calc_LocalRotDir * localPos;
			float num = Vector3.Magnitude(val - computedPosLocal);
			float num2 = num / leg.Owner.ScaleReferenceNoScale;
			float num3 = 0f;
			if (num > 0.2f)
			{
				num3 = Mathf.InverseLerp(0.2f, 1f, num);
				num3 *= 0.1f;
				if (@float < 0.1f)
				{
					num3 *= @float / 0.1f;
				}
			}
			if (parent._calc_toNegativeXProgress > 0f)
			{
				Vector3 val2 = localPos;
				val2.x *= -1f;
				Vector3 val3 = parent._calc_LocalRotDir * val2;
				val = Vector3.Lerp(val, val3, parent._calc_toNegativeXProgress);
			}
			float num4 = 0f;
			if (!(smoother >= 3f))
			{
				if (smoother > 0f)
				{
					if (num2 < 0.1f / smoother)
					{
						computedPosLocal = val;
					}
					else
					{
						num4 = Mathf.InverseLerp(1.5f * smoother, 0.1f / smoother, num2) * 6f;
					}
					num4 = Mathf.Max(0f, num4);
				}
				else
				{
					computedPosLocal = val;
				}
			}
			computedPosLocal = Vector3.Lerp(computedPosLocal, val, LA.DeltaTime * (Mathf.Lerp(20f, 4f, (parent._calc_angleDiffFactor * @float + num3) * 1.5f) + num4));
			computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, val.y, 0.5f);
			if (parent._var_raiseLimit > 0f)
			{
				float c_AnimatedAnkleFlatHeight = leg.C_AnimatedAnkleFlatHeight;
				float num5 = 0f;
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorR);
				}
				else if (leg.Side == LegsAnimator.ELegSide.Right)
				{
					num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorL);
				}
				if (parent._calc_toNegativeXProgress > 0f)
				{
					num5 = Mathf.Lerp(num5, 1f, parent._calc_toNegativeXProgress);
				}
				computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, c_AnimatedAnkleFlatHeight, num5 * parent._var_raiseLimit);
			}
			LastComputedWorldSpaceLegPos = LA.RootToWorldSpace(computedPosLocal);
			return computedPosLocal;
		}

		internal Quaternion FootRedirectSmoother(Quaternion target)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			_footRedirCache = Quaternion.Lerp(_footRedirCache, target, parent._calc_deltaSpeedSlow);
			return _footRedirCache;
		}
	}

	private LegsAnimator.LegsAnimatorCustomModuleHelper _useHelper;

	private LegsAnimator.Variable _play_HipsRedir;

	private LegsAnimator.Variable _play_FeetRedir;

	private LegsAnimator.Variable _play_KneesRedir;

	private LegsAnimator.Variable _play_TrDur;

	private LegsAnimator.Variable _play_LimitRaise;

	private LegsAnimator.Variable _play_FixFeet;

	private LegsAnimator.Variable _play_AdjustStretch;

	private LegsAnimator.Variable _play_RestoreSpine;

	private LegsAnimator.Variable _play_Smoother;

	private LegsAnimator.Variable _play_reAdj;

	private LegsAnimator.Variable _play_offInAir;

	private int _hash_xDir = -1;

	private int _hash_zDir = -1;

	private Vector3 _calc_WorldDir = Vector3.zero;

	private Vector3 _calc_LocalDir = Vector3.zero;

	private Quaternion _calc_LocalRotDir = Quaternion.identity;

	private float _localTargetAngle;

	private float _wrappedAngle;

	private float _smoothedWrappedAngle;

	private float _calc_smoothedTargetAngle;

	private float _calc_angleDiffFactor;

	private float _calc_toNegativeXProgress;

	internal float _calc_backAngleOff;

	private float _calc_sideFactorL;

	private float _calc_sideFactorR;

	internal float _calc_sideFactor;

	private float _calc_deltaSpeed;

	private float _calc_deltaSpeedSlow;

	private float _var_raiseLimit;

	private float _var_fixFeet;

	private Vector3 _calc_hipsPositionOffsets = Vector3.zero;

	private Vector3 _calc_hipsRotationOffsets = Vector3.zero;

	private Vector3 _calc_hipsStretchOffset = Vector3.zero;

	private Vector3 _sd_hipsStretchOff = Vector3.zero;

	private Vector3 _calc_ikOff = Vector3.zero;

	private List<LegRedirectHelper> legRedirectHelpers;

	[NonSerialized]
	public Transform SpineBone;

	[NonSerialized]
	public Vector3 User_MultiplyHipsOffsets = Vector3.one;

	[FPD_Header("Angles setup to drive procedural animation", 6f, 4f, 2)]
	public AnglesSetup Animation360Angles;

	[NonSerialized]
	public float User_StretchRotatorAnglePower = 30f;

	[NonSerialized]
	public float User_StretchPositionMultiplier = 1f;

	private float _mainBlend = 1f;

	private bool _wasUpdated;

	private Vector3 overridingDirection = Vector3.zero;

	private bool useOverridingDirection;

	[NonSerialized]
	public float overrideDirectionFadeSpeed = 6f;

	private float overrideDirectionBlend;

	private float _calc_lStretch;

	private float _calc_rStretch;

	private LegsAnimator.Variable HipsRedirVar => _useHelper.RequestVariable("Redirect Hips", 0.8f);

	private LegsAnimator.Variable FeetRedirVar => _useHelper.RequestVariable("Redirect Feet", 0.8f);

	private LegsAnimator.Variable KneesRedirVar => _useHelper.RequestVariable("Redirect Knees", 0.4f);

	private LegsAnimator.Variable TrDurationVar => _useHelper.RequestVariable("Transitions Duration", 0.25f);

	private LegsAnimator.Variable LimitRaiseVar => _useHelper.RequestVariable("Limit Leg Raise", 0.1f);

	private LegsAnimator.Variable FixFeetVar => _useHelper.RequestVariable("Fix Backward Feet", 1f);

	private LegsAnimator.Variable AdjustStretchVar => _useHelper.RequestVariable("Adjust Stretched", 0.2f);

	private LegsAnimator.Variable RestoreSpineVar => _useHelper.RequestVariable("Restore Spine", 0.5f);

	private LegsAnimator.Variable ExtraSmootherVar => _useHelper.RequestVariable("Extra Smoother", 0f);

	private LegsAnimator.Variable ReAdjVar => _useHelper.RequestVariable("Re-adjust with hips offset", false);

	private LegsAnimator.Variable FadeOffInAirVar => _useHelper.RequestVariable("Disable When Jumping", false);

	private LegsAnimator.Variable XDirAnimVarVar => _useHelper.RequestVariable("Animator World X Dir", "");

	private LegsAnimator.Variable ZDirAnimVarVar => _useHelper.RequestVariable("Animator World Z Dir", "");

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_useHelper = helper;
		_play_HipsRedir = HipsRedirVar;
		_play_TrDur = TrDurationVar;
		_play_LimitRaise = LimitRaiseVar;
		_play_FeetRedir = FeetRedirVar;
		_play_KneesRedir = KneesRedirVar;
		_play_FixFeet = FixFeetVar;
		_play_AdjustStretch = AdjustStretchVar;
		_play_RestoreSpine = RestoreSpineVar;
		_play_Smoother = ExtraSmootherVar;
		_play_offInAir = FadeOffInAirVar;
		_play_reAdj = ReAdjVar;
		_wasUpdated = false;
		legRedirectHelpers = new List<LegRedirectHelper>();
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegRedirectHelper item = new LegRedirectHelper(this, base.LA.Legs[i]);
			legRedirectHelpers.Add(item);
		}
		for (int j = 0; j < base.LA.Legs.Count; j++)
		{
			if (base.LA.Legs[j].OppositeLegIndex >= 0)
			{
				legRedirectHelpers[j].oppositeHelper = legRedirectHelpers[base.LA.Legs[j].OppositeLegIndex];
			}
		}
		if ((Object)(object)SpineBone == (Object)null && base.LA.Hips.childCount > 0)
		{
			if (base.LA.Hips.childCount == 1)
			{
				SpineBone = base.LA.Hips.GetChild(0);
			}
			else
			{
				for (int k = 0; k < base.LA.Hips.childCount; k++)
				{
					if (((Object)base.LA.Hips.GetChild(k)).name.ToLower().Contains("spin"))
					{
						SpineBone = base.LA.Hips.GetChild(k);
						break;
					}
				}
				if ((Object)(object)SpineBone == (Object)null)
				{
					SpineBone = base.LA.Hips.GetChild(0);
				}
			}
		}
		if (Object.op_Implicit((Object)(object)base.LA.Mecanim))
		{
			LegsAnimator.Variable xDirAnimVarVar = XDirAnimVarVar;
			if (!string.IsNullOrWhiteSpace(xDirAnimVarVar.GetString()))
			{
				_hash_xDir = Animator.StringToHash(xDirAnimVarVar.GetString());
				LegsAnimator.Variable zDirAnimVarVar = ZDirAnimVarVar;
				_hash_zDir = Animator.StringToHash(zDirAnimVarVar.GetString());
			}
		}
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_049e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a3: Unknown result type (might be due to invalid IL or missing references)
		_mainBlend = base.LA._MainBlend * base.ModuleBlend;
		if (_play_offInAir.GetBool())
		{
			_mainBlend *= base.LA.IsGroundedBlend;
		}
		float @float = _play_TrDur.GetFloat();
		if (_mainBlend < 0.001f)
		{
			return;
		}
		if (useOverridingDirection)
		{
			if (overrideDirectionFadeSpeed < 0.0001f)
			{
				overrideDirectionBlend = 1f;
			}
			else
			{
				overrideDirectionBlend = Mathf.MoveTowards(overrideDirectionBlend, 1f, base.Owner.DeltaTime * overrideDirectionFadeSpeed);
			}
		}
		else if (overrideDirectionFadeSpeed < 0.0001f)
		{
			overrideDirectionBlend = 0f;
		}
		else
		{
			overrideDirectionBlend = Mathf.MoveTowards(overrideDirectionBlend, 0f, base.Owner.DeltaTime * overrideDirectionFadeSpeed);
		}
		Vector3 calc_WorldDir;
		if (_hash_zDir != -1)
		{
			Vector3 val = new Vector3(base.LA.Mecanim.GetFloat(_hash_xDir), 0f, base.LA.Mecanim.GetFloat(_hash_zDir));
			calc_WorldDir = ((Vector3)(ref val)).normalized;
		}
		else
		{
			calc_WorldDir = base.LA.DesiredMovementDirection;
			calc_WorldDir.y = 0f;
			if (((Vector3)(ref calc_WorldDir)).magnitude < 0.1f)
			{
				calc_WorldDir = Vector3.zero;
			}
		}
		_calc_WorldDir = calc_WorldDir;
		if (overrideDirectionBlend > 0.0001f)
		{
			if (overrideDirectionBlend >= 1f)
			{
				_calc_WorldDir = overridingDirection;
			}
			else
			{
				_calc_WorldDir = Vector3.Slerp(_calc_WorldDir, overridingDirection, overrideDirectionBlend);
			}
		}
		_calc_LocalDir = base.LA.ToRootLocalSpaceVec(_calc_WorldDir);
		_var_raiseLimit = _play_LimitRaise.GetFloat();
		_var_fixFeet = _play_FixFeet.GetFloat();
		if (((Vector3)(ref _calc_LocalDir)).sqrMagnitude < 1E-05f)
		{
			_localTargetAngle = 0f;
		}
		_localTargetAngle = FEngineering.GetAngleRad(_calc_LocalDir.x, _calc_LocalDir.z);
		float num = ((!(@float <= 0f)) ? (3f * Mathf.Lerp(5f, 0.5f, @float / 0.6f)) : 1000f);
		_calc_deltaSpeed = base.LA.DeltaTime * num;
		_calc_deltaSpeedSlow = base.LA.DeltaTime * (num * 0.6f);
		_calc_smoothedTargetAngle = Mathf.LerpAngle(_calc_smoothedTargetAngle, _localTargetAngle, _calc_deltaSpeedSlow);
		_calc_angleDiffFactor = Mathf.InverseLerp(0.0001f, 0.25f, Mathf.Abs((_localTargetAngle - _calc_smoothedTargetAngle) / MathF.PI));
		_localTargetAngle *= 57.29578f;
		_wrappedAngle = FormatAngleToPM180(_localTargetAngle);
		_smoothedWrappedAngle = Mathf.LerpAngle(_smoothedWrappedAngle, _wrappedAngle, _calc_deltaSpeed * 1.25f);
		_smoothedWrappedAngle = FormatAngleToPM180(_smoothedWrappedAngle);
		if (_smoothedWrappedAngle < -179.9f && _wrappedAngle > 0f)
		{
			_smoothedWrappedAngle = 0f - _smoothedWrappedAngle;
		}
		if (_smoothedWrappedAngle > 179.9f && _wrappedAngle < 0f)
		{
			_smoothedWrappedAngle = 0f - _smoothedWrappedAngle;
		}
		float wrappedAngle = _wrappedAngle;
		float num2 = ((!(_wrappedAngle < 90f)) ? Mathf.InverseLerp(180f, 90f, wrappedAngle) : Mathf.InverseLerp(0f, 90f, wrappedAngle));
		_calc_sideFactorR = Mathf.Lerp(_calc_sideFactorR, num2, _calc_deltaSpeed * 2f);
		num2 = ((!(_wrappedAngle > -90f)) ? Mathf.InverseLerp(-180f, -90f, wrappedAngle) : Mathf.InverseLerp(0f, -90f, wrappedAngle));
		_calc_sideFactorL = Mathf.Lerp(_calc_sideFactorL, num2, _calc_deltaSpeed * 2f);
		if (_wrappedAngle < 0f)
		{
			_calc_sideFactor = _calc_sideFactorL;
		}
		else
		{
			_calc_sideFactor = _calc_sideFactorR;
		}
		_calc_toNegativeXProgress = 0f;
		float wrappedAngle2 = _wrappedAngle;
		if (wrappedAngle2 < -90f)
		{
			_calc_toNegativeXProgress = Mathf.InverseLerp(-90f, -135f, wrappedAngle2);
		}
		else if (wrappedAngle2 > 90f)
		{
			_calc_toNegativeXProgress = Mathf.InverseLerp(90f, 135f, wrappedAngle2);
		}
		_calc_LocalRotDir = Quaternion.Euler(0f, _localTargetAngle, 0f);
		_wasUpdated = true;
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		if (!_wasUpdated)
		{
			return;
		}
		float smoother = _play_Smoother.GetFloat() + 1f;
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegsAnimator.Leg leg = base.LA.Legs[i];
			Vector3 animatorEndBonePos = leg._AnimatorEndBonePos;
			Vector3 localPos = base.LA.ToRootLocalSpace(animatorEndBonePos);
			LegRedirectHelper legRedirectHelper = legRedirectHelpers[leg.PlaymodeIndex];
			legRedirectHelper.ComputeIKOffset(localPos, smoother);
			Vector3 val = legRedirectHelper.LastComputedWorldSpaceLegPos;
			if (_mainBlend < 1f)
			{
				val = Vector3.LerpUnclamped(animatorEndBonePos, val, _mainBlend);
			}
			Vector3 calc_ikOff = _calc_ikOff;
			if (base.LA.Legs[i].Side == LegsAnimator.ELegSide.Left)
			{
				calc_ikOff.x = 0f - calc_ikOff.x;
			}
			else if (base.LA.Legs[i].Side == LegsAnimator.ELegSide.Right)
			{
				calc_ikOff.z = 0f - calc_ikOff.z;
			}
			calc_ikOff = base.LA.RootToWorldSpaceVec(calc_ikOff);
			val += calc_ikOff;
			leg.OverrideAnimatorAnklePosition(val);
		}
	}

	public void OverrideMoveDirection(Vector3? direction)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!direction.HasValue)
		{
			useOverridingDirection = false;
			return;
		}
		useOverridingDirection = true;
		overridingDirection = direction.Value;
	}

	public override void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0668: Unknown result type (might be due to invalid IL or missing references)
		//IL_0690: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06de: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_071f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0724: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_074c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0751: Unknown result type (might be due to invalid IL or missing references)
		//IL_0756: Unknown result type (might be due to invalid IL or missing references)
		//IL_0758: Unknown result type (might be due to invalid IL or missing references)
		//IL_0777: Unknown result type (might be due to invalid IL or missing references)
		//IL_077c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0781: Unknown result type (might be due to invalid IL or missing references)
		//IL_0786: Unknown result type (might be due to invalid IL or missing references)
		//IL_0788: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_0819: Unknown result type (might be due to invalid IL or missing references)
		//IL_0820: Unknown result type (might be due to invalid IL or missing references)
		//IL_0822: Unknown result type (might be due to invalid IL or missing references)
		//IL_0854: Unknown result type (might be due to invalid IL or missing references)
		//IL_0859: Unknown result type (might be due to invalid IL or missing references)
		//IL_0865: Unknown result type (might be due to invalid IL or missing references)
		//IL_086f: Unknown result type (might be due to invalid IL or missing references)
		//IL_087f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0884: Unknown result type (might be due to invalid IL or missing references)
		//IL_088f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0894: Unknown result type (might be due to invalid IL or missing references)
		//IL_089d: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_080d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_045c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0470: Unknown result type (might be due to invalid IL or missing references)
		//IL_0484: Unknown result type (might be due to invalid IL or missing references)
		//IL_0511: Unknown result type (might be due to invalid IL or missing references)
		//IL_0525: Unknown result type (might be due to invalid IL or missing references)
		//IL_0539: Unknown result type (might be due to invalid IL or missing references)
		//IL_058e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0591: Unknown result type (might be due to invalid IL or missing references)
		//IL_0596: Unknown result type (might be due to invalid IL or missing references)
		//IL_0598: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_0563: Unknown result type (might be due to invalid IL or missing references)
		//IL_0572: Unknown result type (might be due to invalid IL or missing references)
		//IL_0581: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0363: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0900: Unknown result type (might be due to invalid IL or missing references)
		//IL_0905: Unknown result type (might be due to invalid IL or missing references)
		//IL_0907: Unknown result type (might be due to invalid IL or missing references)
		if (!_wasUpdated)
		{
			return;
		}
		float @float = _play_HipsRedir.GetFloat();
		float float2 = _play_FeetRedir.GetFloat();
		float float3 = _play_KneesRedir.GetFloat();
		float float4 = _play_AdjustStretch.GetFloat();
		float num = Mathf.Abs(_wrappedAngle);
		float num2 = Mathf.InverseLerp(0f, 45f, num);
		float wrappedAngle = _wrappedAngle;
		float num3 = wrappedAngle;
		if (float2 > 0f)
		{
			if (wrappedAngle < -90f)
			{
				num3 = ((!(wrappedAngle > -135f)) ? Mathf.Lerp(40f, 0f, Mathf.InverseLerp(-135f, -180f, wrappedAngle)) : Mathf.Lerp(-90f, 40f, Mathf.InverseLerp(-90f, -135f, wrappedAngle)));
			}
			else if (wrappedAngle > 90f)
			{
				num3 = ((!(wrappedAngle < 135f)) ? Mathf.Lerp(-40f, 0f, Mathf.InverseLerp(135f, 180f, wrappedAngle)) : Mathf.Lerp(90f, -40f, Mathf.InverseLerp(90f, 135f, wrappedAngle)));
			}
		}
		Vector3 val = Vector3.zero;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 0f;
		num6 = ((!(num > 135f)) ? Mathf.InverseLerp(90f, 135f, num) : Mathf.InverseLerp(180f, 135f, num));
		num6 = Mathf.Lerp(1f, -0.5f, num6);
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegsAnimator.Leg leg = base.LA.Legs[i];
			if (float2 > 0f)
			{
				float num7 = num3;
				float num8 = 1f - float2;
				num8 = num8 * num8 * num8;
				Quaternion target = Quaternion.AngleAxis(num7 * (1f - num8) * 0.8f * _mainBlend, base.LA.BaseTransform.up);
				target = legRedirectHelpers[i].FootRedirectSmoother(target);
				leg.OverrideFinalIKRot(target * leg.GetFinalIKRot());
			}
			if (float3 > 0f)
			{
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					leg.IKProcessor.StartBoneRotationOffset = Quaternion.Euler(0f, (0f - _calc_sideFactorR) * Mathf.Min(35f, 50f * float3) * num6, 0f);
				}
				else if (leg.Side == LegsAnimator.ELegSide.Right)
				{
					leg.IKProcessor.StartBoneRotationOffset = Quaternion.Euler(0f, (0f - _calc_sideFactorL) * Mathf.Min(35f, 50f * float3) * num6, 0f);
				}
			}
			else
			{
				leg.IKProcessor.StartBoneRotationOffset = Quaternion.identity;
			}
			if (!(float4 > 0.01f))
			{
				continue;
			}
			float stretchValue = leg.IKProcessor.GetStretchValue(legRedirectHelpers[i].LastComputedWorldSpaceLegPos);
			if (stretchValue > 0.9f)
			{
				float num9 = Mathf.InverseLerp(0.9f, 1.125f, stretchValue);
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					num4 += num9;
				}
				else
				{
					num5 += num9;
				}
				Vector3 vec = leg._PreviousFinalIKPos - base.LA.BaseTransform.position;
				vec = base.LA.ToRootLocalSpaceVec(vec);
				vec.y *= -0.8f;
				vec = base.LA.RootToWorldSpaceVec(vec);
				val += vec * (num9 * 1f);
			}
		}
		Vector3 val2 = Animation360Angles.AnglesOn0;
		Vector3 val3 = Animation360Angles.HipsOffsetOn0;
		Vector3 val4 = Animation360Angles.IKsOffsetOn0;
		if (num > 0f)
		{
			if (num < 90f)
			{
				float t = InverseLerpDoubleSide(0f, 45f, num, 90f);
				LerpIt(ref val2, Animation360Angles.AnglesOn45, t);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn45, t);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn45, t);
			}
			if (num > 45f && num < 135f)
			{
				float t2 = InverseLerpDoubleSide(45f, 90f, num, 135f);
				LerpIt(ref val2, Animation360Angles.AnglesOn90, t2);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn90, t2);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn90, t2);
			}
			if (num > 90f)
			{
				float t3 = InverseLerpDoubleSide(90f, 135f, num, 180f);
				LerpIt(ref val2, Animation360Angles.AnglesOn135, t3);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn135, t3);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn135, t3);
			}
			if (num > 135f)
			{
				float t4 = Mathf.InverseLerp(135f, 180f, num);
				LerpIt(ref val2, Animation360Angles.AnglesOn180, t4);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn180, t4);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn180, t4);
			}
			if (_wrappedAngle < 0f)
			{
				val2.y = 0f - val2.y;
				val2.z = 0f - val2.z;
				val3.x = 0f - val3.x;
				val4.z = 0f - val4.z;
			}
			val2 *= @float;
			val3 *= 0.7f * @float;
			val2 = Vector3.Scale(val2, User_MultiplyHipsOffsets);
		}
		val4 *= @float * _mainBlend * base.LA.ScaleReference;
		_calc_ikOff = val4;
		float num10 = 0.25f + float4 * 0.75f;
		_calc_lStretch = Mathf.Lerp(_calc_lStretch, num4, _calc_deltaSpeed);
		_calc_rStretch = Mathf.Lerp(_calc_rStretch, num5, _calc_deltaSpeed);
		val2.y -= _calc_lStretch * User_StretchRotatorAnglePower * @float * num10;
		val2.y += _calc_rStretch * User_StretchRotatorAnglePower * @float * num10;
		_calc_hipsRotationOffsets.x = Mathf.LerpAngle(_calc_hipsRotationOffsets.x, val2.x, _calc_deltaSpeed);
		_calc_hipsRotationOffsets.y = Mathf.LerpAngle(_calc_hipsRotationOffsets.y, val2.y, _calc_deltaSpeed);
		_calc_hipsRotationOffsets.z = Mathf.LerpAngle(_calc_hipsRotationOffsets.z, val2.z, _calc_deltaSpeed);
		_calc_hipsPositionOffsets = Vector3.Lerp(_calc_hipsPositionOffsets, val3, _calc_deltaSpeed);
		val3 *= User_StretchPositionMultiplier;
		Quaternion val5 = Quaternion.identity;
		float num11 = _play_RestoreSpine.GetFloat();
		if ((Object)(object)SpineBone != (Object)null)
		{
			val5 = SpineBone.rotation;
		}
		else
		{
			num11 = 0f;
		}
		Quaternion val6 = Quaternion.AngleAxis(_calc_hipsRotationOffsets.y * _mainBlend, base.LA.BaseTransform.up);
		val6 *= Quaternion.AngleAxis(_calc_hipsRotationOffsets.z * _mainBlend, base.LA.BaseTransform.forward);
		val6 *= Quaternion.AngleAxis(_calc_hipsRotationOffsets.x * _mainBlend, base.LA.BaseTransform.right);
		base.LA.Hips.rotation = val6 * base.LA.Hips.rotation;
		if (num11 > 0f)
		{
			SpineBone.rotation = Quaternion.Slerp(SpineBone.rotation, val5, Mathf.Lerp(1f, num11, _mainBlend));
		}
		_calc_hipsStretchOffset = Vector3.SmoothDamp(_calc_hipsStretchOffset, num2 * val, ref _sd_hipsStretchOff, 0.2f + 0.3f * _play_TrDur.GetFloat(), 100000f, base.LA.DeltaTime);
		Vector3 val7 = base.LA.RootToWorldSpaceVec(_calc_hipsPositionOffsets * 0.5f * base.LA.ScaleReference) * _mainBlend;
		LegsAnimator lA = base.LA;
		lA._Hips_Modules_ExtraWOffset += val7 + _calc_hipsStretchOffset * float4 * _mainBlend;
		if (_play_reAdj.GetBool())
		{
			for (int j = 0; j < base.LA.Legs.Count; j++)
			{
				base.LA.Legs[j].OverrideFinalIKPos(base.LA.Legs[j].GetFinalIKPos() - val7);
			}
		}
	}

	public override void OnPostLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		if (!(_mainBlend < 0.001f) && _wasUpdated && _var_fixFeet > 0f)
		{
			for (int i = 0; i < base.LA.Legs.Count; i++)
			{
				LegsAnimator.Leg leg = base.LA.Legs[i];
				Quaternion rotation = leg.IKProcessor.EndIKBone.transform.rotation;
				Quaternion val = leg.IKProcessor.EndIKBone.transform.parent.rotation * leg.IKProcessor.EndIKBone.InitialLocalRotation;
				val = Quaternion.LerpUnclamped(rotation, val, (1f - leg.A_AligningHelperBlend) * _var_fixFeet * base.LA.IsMovingBlend * _calc_toNegativeXProgress);
				leg.IKProcessor.EndIKBone.transform.rotation = val;
			}
		}
	}

	public static float FormatAngleToPM180(float angle)
	{
		float num = angle % 360f;
		if (num > 180f)
		{
			num -= 360f;
		}
		if (num < -180f)
		{
			num += 360f;
		}
		return num;
	}

	private static float InverseLerpDoubleSide(float from, float to, float t, float toRange)
	{
		if (t > to)
		{
			return Mathf.InverseLerp(toRange, to, t);
		}
		return Mathf.InverseLerp(from, to, t);
	}

	private static void LerpIt(ref Vector3 val, Vector3 to, float t)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		val = Vector3.LerpUnclamped(val, to, t);
	}
}


using System;
using UnityEngine;

[Serializable]
public class AnglesSetup
{
	public Vector3 AnglesOn0 = new Vector3(0f, 0f, 0f);

	[Tooltip(" Hips rotations on reaching 45 angle movement")]
	public Vector3 AnglesOn45 = new Vector3(-10f, 14f, -5f);

	[Tooltip(" Hips rotations on reaching 90 angle movement")]
	public Vector3 AnglesOn90 = new Vector3(-7f, 40f, -3f);

	[Tooltip(" Hips rotations on reaching 135 angle movement")]
	public Vector3 AnglesOn135 = new Vector3(-8f, -25f, -4f);

	[Tooltip(" Hips rotations on reaching 180 angle movement")]
	public Vector3 AnglesOn180 = new Vector3(-20f, 0f, 0f);

	[Space(8f)]
	public Vector3 HipsOffsetOn0 = new Vector3(0f, 0f, 0f);

	[Tooltip(" Hips position offset on reaching 45 angle movement")]
	public Vector3 HipsOffsetOn45 = new Vector3(-0.05f, 0f, -0.05f);

	[Tooltip(" Hips position offset on reaching 90 angle movement")]
	public Vector3 HipsOffsetOn90 = new Vector3(-0.1f, 0f, 0.05f);

	[Tooltip(" Hips position offset on reaching 135 angle movement")]
	public Vector3 HipsOffsetOn135 = new Vector3(-0.1f, 0f, 0.1f);

	[Tooltip(" Hips position offset on reaching 180 angle movement")]
	public Vector3 HipsOffsetOn180 = new Vector3(0f, 0.05f, 0.2f);

	[Space(8f)]
	public Vector3 IKsOffsetOn0 = new Vector3(0f, 0f, 0f);

	[Tooltip(" Foot IK position offset on reaching 45 angle movement (x on left leg goes negative)")]
	public Vector3 IKsOffsetOn45 = new Vector3(0f, 0f, -0.04f);

	[Tooltip(" Foot IK position offset on reaching 90 angle movement (x on left leg goes negative)")]
	public Vector3 IKsOffsetOn90 = new Vector3(0f, 0f, -0.08f);

	[Tooltip(" Foot IK position offset on reaching 135 angle movement (x on left leg goes negative)")]
	public Vector3 IKsOffsetOn135 = new Vector3(0f, 0f, 0.08f);

	[Tooltip(" Foot IK position offset on reaching 180 angle movement (x on left leg goes negative)")]
	public Vector3 IKsOffsetOn180 = new Vector3(0f, 0f, 0f);
}


using UnityEngine;

private class LegRedirectHelper
{
	private LAM_DirectionalMovement parent;

	private LegsAnimator.Leg leg;

	internal LegRedirectHelper oppositeHelper;

	private Vector3 computedPosLocal = Vector3.zero;

	private Quaternion _footRedirCache = Quaternion.identity;

	private LegsAnimator LA => parent.LA;

	public Vector3 LastComputedWorldSpaceLegPos { get; private set; }

	public LegRedirectHelper(LAM_DirectionalMovement parent, LegsAnimator.Leg leg)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		this.parent = parent;
		this.leg = leg;
		LastComputedWorldSpaceLegPos = leg.BoneEnd.position;
		computedPosLocal = leg.Owner.ToRootLocalSpace(LastComputedWorldSpaceLegPos);
	}

	public Vector3 ComputeIKOffset(Vector3 localPos, float smoother = 1f)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		float @float = parent._play_TrDur.GetFloat();
		Vector3 val = parent._calc_LocalRotDir * localPos;
		float num = Vector3.Magnitude(val - computedPosLocal);
		float num2 = num / leg.Owner.ScaleReferenceNoScale;
		float num3 = 0f;
		if (num > 0.2f)
		{
			num3 = Mathf.InverseLerp(0.2f, 1f, num);
			num3 *= 0.1f;
			if (@float < 0.1f)
			{
				num3 *= @float / 0.1f;
			}
		}
		if (parent._calc_toNegativeXProgress > 0f)
		{
			Vector3 val2 = localPos;
			val2.x *= -1f;
			Vector3 val3 = parent._calc_LocalRotDir * val2;
			val = Vector3.Lerp(val, val3, parent._calc_toNegativeXProgress);
		}
		float num4 = 0f;
		if (!(smoother >= 3f))
		{
			if (smoother > 0f)
			{
				if (num2 < 0.1f / smoother)
				{
					computedPosLocal = val;
				}
				else
				{
					num4 = Mathf.InverseLerp(1.5f * smoother, 0.1f / smoother, num2) * 6f;
				}
				num4 = Mathf.Max(0f, num4);
			}
			else
			{
				computedPosLocal = val;
			}
		}
		computedPosLocal = Vector3.Lerp(computedPosLocal, val, LA.DeltaTime * (Mathf.Lerp(20f, 4f, (parent._calc_angleDiffFactor * @float + num3) * 1.5f) + num4));
		computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, val.y, 0.5f);
		if (parent._var_raiseLimit > 0f)
		{
			float c_AnimatedAnkleFlatHeight = leg.C_AnimatedAnkleFlatHeight;
			float num5 = 0f;
			if (leg.Side == LegsAnimator.ELegSide.Left)
			{
				num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorR);
			}
			else if (leg.Side == LegsAnimator.ELegSide.Right)
			{
				num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorL);
			}
			if (parent._calc_toNegativeXProgress > 0f)
			{
				num5 = Mathf.Lerp(num5, 1f, parent._calc_toNegativeXProgress);
			}
			computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, c_AnimatedAnkleFlatHeight, num5 * parent._var_raiseLimit);
		}
		LastComputedWorldSpaceLegPos = LA.RootToWorldSpace(computedPosLocal);
		return computedPosLocal;
	}

	internal Quaternion FootRedirectSmoother(Quaternion target)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		_footRedirCache = Quaternion.Lerp(_footRedirCache, target, parent._calc_deltaSpeedSlow);
		return _footRedirCache;
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_EdgeStepDetector : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable iterationsV;

	private float initTime;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		initTime = Time.time;
		iterationsV = helper.RequestVariable("Iterations", 5);
	}

	public override void OnReInitialize(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		initTime = Time.time;
	}

	public override void Leg_LatePreRaycastingUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		if (Time.time - initTime < 0.1f)
		{
			return;
		}
		if (leg.User_RaycastHittedSource)
		{
			leg.User_RestoreRaycasting();
			return;
		}
		Vector3 val = base.LegsAnim.ToRootLocalSpace(leg.ParentHub.LastKeyframePosition);
		Vector3 val2 = base.LegsAnim.ToRootLocalSpace(leg.lastRaycastingOrigin);
		val.y = val2.y;
		val.z = val2.z;
		RaycastHit hit = default(RaycastHit);
		float num = Vector3.Distance(leg.lastRaycastingOrigin, leg.lastRaycastingEndPoint);
		float num2 = iterationsV.GetInt();
		for (float num3 = 1f; num3 <= num2; num3 += 1f)
		{
			Vector3 localPos = Vector3.LerpUnclamped(val2, val, 0.1f + num3 / num2);
			localPos = base.LegsAnim.RootToWorldSpace(localPos);
			if (Physics.Raycast(localPos, -base.LegsAnim.Up, ref hit, num * 1.01f, LayerMask.op_Implicit(base.LegsAnim.GroundMask), (QueryTriggerInteraction)1))
			{
				break;
			}
		}
		if ((Object)(object)((RaycastHit)(ref hit)).transform == (Object)null)
		{
			leg.User_RestoreRaycasting();
		}
		else
		{
			leg.User_OverrideRaycastHit(hit, disableSourceRaycast: false);
		}
	}
}


using System;
using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_FadeLegOnAnimator : LegsAnimatorControlModuleBase
{
	private enum ELayerSelectMode
	{
		ByIndex,
		Auto
	}

	private LegsAnimator.Variable _fadeSpeedV;

	private LegsAnimator.Variable _layerV;

	private LegsAnimator.Variable _idleGlueV;

	private float enabledMultiplier = 1f;

	private float sd_eneMul;

	[NonSerialized]
	private LegsAnimator.Leg[] legs;

	private List<int> stateHashes;

	private List<int> tagHashes;

	private LegsAnimator.Variable _layerMode;

	private LegsAnimator.Variable _layerSkip;

	private List<int> layersToCheck;

	private int lastAutoWeightIndex;

	private bool InitLayerCheck(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if ((Object)(object)helper.Parent.Mecanim == (Object)null)
		{
			return false;
		}
		if (_layerMode.GetInt() == 0)
		{
			return false;
		}
		if (_layerMode == null || _layerSkip == null)
		{
			return false;
		}
		layersToCheck = new List<int>();
		string[] array = _layerSkip.GetString().Split(',');
		for (int i = 0; i < helper.Parent.Mecanim.layerCount; i++)
		{
			layersToCheck.Add(i);
		}
		for (int j = 0; j < array.Length; j++)
		{
			if (int.TryParse(array[j], out var result))
			{
				layersToCheck.Remove(result);
				continue;
			}
			int num = -1;
			for (int k = 0; k < helper.Parent.Mecanim.layerCount; k++)
			{
				if (helper.Parent.Mecanim.GetLayerName(k) == array[j])
				{
					num = k;
					break;
				}
			}
			if (num != -1)
			{
				layersToCheck.Remove(num);
			}
		}
		return true;
	}

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if ((Object)(object)base.LA.Mecanim == (Object)null)
		{
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: Not found animator reference in legs animator Extra/Control!");
			helper.Enabled = false;
			return;
		}
		_layerV = helper.RequestVariable("Animation Layer", 0);
		_fadeSpeedV = helper.RequestVariable("Fade Speed", 0.75f);
		_idleGlueV = helper.RequestVariable("Idle Glue During Fade", false);
		LegsAnimator.Variable variable = helper.RequestVariable("Animation State Tag", "");
		string[] array = helper.RequestVariable("Animation State Name", "").GetString().Split(',');
		if (array.Length != 0)
		{
			stateHashes = new List<int>();
			for (int i = 0; i < array.Length; i++)
			{
				if (!string.IsNullOrWhiteSpace(array[i]))
				{
					stateHashes.Add(Animator.StringToHash(array[i]));
				}
			}
		}
		string[] array2 = variable.GetString().Split(',');
		if (array2.Length != 0)
		{
			tagHashes = new List<int>();
			for (int j = 0; j < array2.Length; j++)
			{
				if (!string.IsNullOrWhiteSpace(array2[j]))
				{
					tagHashes.Add(Animator.StringToHash(array2[j]));
				}
			}
		}
		if (stateHashes.Count == 0 && tagHashes.Count == 0)
		{
			helper.Enabled = false;
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: No assigned animation state names/tags to control module on!");
			return;
		}
		if (helper.customStringList == null)
		{
			helper.Enabled = false;
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: No legs definition!");
			return;
		}
		List<LegsAnimator.Leg> list = new List<LegsAnimator.Leg>();
		for (int k = 0; k < helper.customStringList.Count; k++)
		{
			if (helper.customStringList[k] == "1")
			{
				list.Add(base.LA.Legs[k]);
			}
		}
		if (list.Count == 0)
		{
			helper.Enabled = false;
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: No legs definition!");
			return;
		}
		legs = list.ToArray();
		if (_layerV.GetInt() < 0)
		{
			_layerV.SetValue(0);
		}
		if (_layerV.GetInt() > base.LA.Mecanim.layerCount - 1)
		{
			_layerV.SetValue(base.LA.Mecanim.layerCount - 1);
		}
		_layerMode = helper.RequestVariable("Mode", 0);
		_layerSkip = helper.RequestVariable("Skip", "");
		if (_layerMode.GetInt() == 1 && !InitLayerCheck(helper))
		{
			_layerMode.SetValue(0);
		}
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		Animator mecanim = base.LA.Mecanim;
		if ((Object)(object)mecanim == (Object)null)
		{
			return;
		}
		int num = _layerV.GetInt();
		if (_layerMode.GetInt() == 1)
		{
			float num2 = 0f;
			int num3 = -1;
			for (int num4 = layersToCheck.Count - 1; num4 >= 0; num4--)
			{
				int num5 = layersToCheck[num4];
				float layerWeight = helper.Parent.Mecanim.GetLayerWeight(num5);
				if (layerWeight > 0.95f)
				{
					num3 = num5;
					break;
				}
				if (layerWeight > num2)
				{
					num2 = layerWeight;
					num3 = num5;
				}
			}
			num = (lastAutoWeightIndex = num3);
		}
		AnimatorStateInfo val = (mecanim.IsInTransition(num) ? mecanim.GetNextAnimatorStateInfo(num) : mecanim.GetCurrentAnimatorStateInfo(num));
		bool flag = false;
		for (int i = 0; i < stateHashes.Count; i++)
		{
			if (((AnimatorStateInfo)(ref val)).shortNameHash == stateHashes[i])
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			for (int j = 0; j < tagHashes.Count; j++)
			{
				if (((AnimatorStateInfo)(ref val)).tagHash == tagHashes[j])
				{
					flag = true;
					break;
				}
			}
		}
		float num6 = 0.3f - _fadeSpeedV.GetFloat() * 0.299f;
		if (flag)
		{
			enabledMultiplier = Mathf.SmoothDamp(enabledMultiplier, -0.001f, ref sd_eneMul, num6 * 0.9f, 100000f, base.LA.DeltaTime);
		}
		else
		{
			enabledMultiplier = Mathf.SmoothDamp(enabledMultiplier, 1.01f, ref sd_eneMul, num6, 100000f, base.LA.DeltaTime);
		}
		enabledMultiplier = Mathf.Clamp01(enabledMultiplier);
		for (int k = 0; k < legs.Length; k++)
		{
			legs[k].InternalModuleBlendWeight = enabledMultiplier;
			legs[k].IK_UpdateParamsBase();
		}
		if (_idleGlueV.GetBool() && enabledMultiplier < 0.5f)
		{
			base.LA._glueModeExecuted = LegsAnimator.EGlueMode.Idle;
		}
	}
}


private enum ELayerSelectMode
{
	ByIndex,
	Auto
}


using FIMSpace.FProceduralAnimation;

public class LAM_HardGlueOnStop : LegsAnimatorControlModuleBase
{
	public float FrontMargin = 0.3f;

	public float ForceForSeconds = 0.6f;

	private LegsAnimator.Variable _beforeV;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_beforeV = helper.RequestVariable("Hard Glue Before Move", 0f);
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		if (!base.LA.IsMoving && base.LA.IsGrounded && base.LA.StoppedTime < ForceForSeconds)
		{
			for (int i = 0; i < base.LA.Legs.Count; i++)
			{
				LegsAnimator.Leg leg = base.LA.Legs[i];
				if (leg.AnkleH.LastKeyframeRootPos.z > (0f - base.LA.ScaleReferenceNoScale) * FrontMargin)
				{
					leg.G_CustomForceAttach = true;
				}
			}
		}
		if (!(_beforeV.GetFloat() > 0f) || !base.LA.IsMoving || !base.LA.IsGrounded || !(base.LA.MovingTime < _beforeV.GetFloat()))
		{
			return;
		}
		for (int j = 0; j < base.LA.Legs.Count; j++)
		{
			LegsAnimator.Leg leg2 = base.LA.Legs[j];
			if (leg2.IKProcessor.GetStretchValue(leg2.IKProcessor.IKTargetPosition) < 1.01f)
			{
				leg2.G_CustomForceAttach = true;
			}
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_HeightStabilizer : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _powerV;

	private LegsAnimator.Variable _reactV;

	private LegsAnimator.Variable _thresV;

	private LegsAnimator.Variable _extrV;

	private Vector3 adjustement = Vector3.zero;

	private Vector3 sd_adjustement = Vector3.zero;

	public override bool AskForSpineBone => true;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		base.OnInit(helper);
		_powerV = helper.RequestVariable("Blend", 1f);
		_reactV = helper.RequestVariable("Reaction Speed", 0.7f);
		_thresV = helper.RequestVariable("Blend Y", 0.5f);
		_extrV = helper.RequestVariable("Extra Push Down Blend", 0.1f);
	}

	public override void OnReInitialize(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		adjustement = Vector3.zero;
		sd_adjustement = Vector3.zero;
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		Vector3 lastAppliedHipsFinalPosition = base.LA._LastAppliedHipsFinalPosition;
		Vector3 val = base.LA.ToRootLocalSpace(lastAppliedHipsFinalPosition);
		Vector3 lastKeyframeLocalPosition = base.LA.HipsSetup.LastKeyframeLocalPosition;
		val.y = 0f;
		lastKeyframeLocalPosition.y = 0f;
		Vector3 val2 = lastKeyframeLocalPosition - val;
		float magnitude = ((Vector3)(ref val2)).magnitude;
		val2.y -= magnitude * _thresV.GetFloat();
		val2 *= _powerV.GetFloat();
		val2.y -= Mathf.InverseLerp(base.LA.ScaleReferenceNoScale * 0.001f, base.LA.ScaleReferenceNoScale * (0.15f + _extrV.GetFloat() * 0.1f), magnitude) * _extrV.GetFloat() * 0.25f;
		val2 *= base.EffectBlend;
		adjustement = Vector3.SmoothDamp(adjustement, val2, ref sd_adjustement, Mathf.Lerp(0.4f, 0.005f, _reactV.GetFloat()), 1000000f, base.LA.DeltaTime);
		LegsAnimator lA = base.LA;
		lA._Hips_Modules_ExtraWOffset += base.LA.RootToWorldSpaceVec(adjustement);
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

[CreateAssetMenu(fileName = "Module Settings-Impulses On Stop And On Land", menuName = "FImpossible Creations/Legs Animator/Module - Impulses on Stop and Land Setup", order = 4)]
public class LAM_ImpulsesOnStopAndOnLand : LegsAnimatorControlModuleBase
{
	[FPD_Header("Triggering hips push impulses", 6f, 4f, 2)]
	public LegsAnimator.PelvisImpulseSettings OnStopImpulse;

	public LegsAnimator.PelvisImpulseSettings OnLandImpulse;

	[FPD_Header("Set Zero Power to Not Use", 6f, 4f, 2)]
	public LegsAnimator.PelvisImpulseSettings OnStartMoveImpulse;

	private readonly string powerMulStrN = "Power Multiplier";

	private readonly string durMulStrN = "Duration Multiplier";

	private readonly string spdLandPower = "Speed Affects Land";

	private bool lastGrounded = true;

	private bool lastMoving;

	private float lastMovingTime;

	private float lastUngroundedTime;

	private LegsAnimator.Variable _powerMulVar;

	private LegsAnimator.Variable _durMulVar;

	private LegsAnimator.Variable _spdAffectsLand;

	protected float customMul = 1f;

	private void Reset()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		OnStartMoveImpulse = new LegsAnimator.PelvisImpulseSettings();
		OnStartMoveImpulse.PowerMultiplier = 0f;
		OnStartMoveImpulse.LocalTranslation = new Vector3(0f, -0.05f, -0.001f);
	}

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		lastGrounded = true;
		lastMoving = false;
		_powerMulVar = helper.RequestVariable(powerMulStrN, 1f);
		_durMulVar = helper.RequestVariable(durMulStrN, 1f);
		_spdAffectsLand = helper.RequestVariable(spdLandPower, false);
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		LegsAnimator lA = base.LA;
		if (lA.IsInAir && lA.InAirTime > 0f)
		{
			lastUngroundedTime = lA.InAirTime;
		}
		if (lA.IsGrounded != lastGrounded && OnLandImpulse.PowerMultiplier != 0f && lA.IsGrounded && lastUngroundedTime > 0.1f)
		{
			Impact_OnLanding(lA);
		}
		if (lA.IsMoving && lA.MovingTime > 0f)
		{
			lastMovingTime = lA.MovingTime;
		}
		if (lA.IsMoving != lastMoving && OnStopImpulse.PowerMultiplier != 0f)
		{
			if (!lA.IsMoving)
			{
				if (lastMovingTime > 0.3f && lA.GroundedTime > 0.25f)
				{
					Impact_OnEndsMove(lA);
				}
			}
			else if (OnStartMoveImpulse.PowerMultiplier != 0f && lA.GroundedTime > 0.1f)
			{
				Impact_OnStartMove(lA);
			}
		}
		lastGrounded = lA.IsGrounded;
		lastMoving = lA.IsMoving;
	}

	protected virtual void Impact_OnStartMove(LegsAnimator l)
	{
		l.User_AddImpulse(OnStartMoveImpulse, _powerMulVar.GetFloat() * customMul, _durMulVar.GetFloat());
	}

	protected virtual void Impact_OnEndsMove(LegsAnimator l)
	{
		l.User_AddImpulse(OnStopImpulse, _powerMulVar.GetFloat() * customMul, _durMulVar.GetFloat());
	}

	protected virtual void Impact_OnLanding(LegsAnimator l)
	{
		if (_spdAffectsLand.GetBool())
		{
			l.User_AddImpulse(OnLandImpulse, _powerMulVar.GetFloat() * customMul, _durMulVar.GetFloat());
		}
		else
		{
			l.User_AddImpulse(OnLandImpulse, _powerMulVar.GetFloat() * ((customMul <= 0f) ? 1f : customMul), _durMulVar.GetFloat());
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_InsectBodyElevateHelper : LegsAnimatorControlModuleBase
{
	private float currentHeightAdjust;

	private float sd_currentHeightAdjust;

	private LegsAnimator.Variable _AdjustPowerV;

	private LegsAnimator.Variable _AdjustingSpeedV;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_AdjustPowerV = helper.RequestVariable("Adjust Power", 1f);
		_AdjustingSpeedV = helper.RequestVariable("Adjusting Speed", 1f);
	}

	public override void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		float hips_LastHipsOffset = base.LA.HipsSetup._Hips_LastHipsOffset;
		hips_LastHipsOffset = ((!(hips_LastHipsOffset < 0f)) ? 0f : (0f - hips_LastHipsOffset));
		if (_AdjustingSpeedV.GetFloat() >= 1f)
		{
			currentHeightAdjust = hips_LastHipsOffset;
		}
		else
		{
			currentHeightAdjust = Mathf.SmoothDamp(currentHeightAdjust, hips_LastHipsOffset, ref sd_currentHeightAdjust, Mathf.Lerp(0.16f, 0.005f, _AdjustingSpeedV.GetFloat()));
		}
		Transform hips = base.LA.Hips;
		hips.position += base.LA.Up * currentHeightAdjust * base.EffectBlend * _AdjustPowerV.GetFloat();
	}
}


using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_InsectLegsHelper : LegsAnimatorControlModuleBase
{
	private class LegHelper
	{
		public bool WasAttaching;

		public bool DetachTrigger;

		public float FullyAttachedAt = -1f;

		public LegsAnimator.Leg legRef { get; private set; }

		public LegHelper(LegsAnimator.Leg leg)
		{
			legRef = leg;
			WasAttaching = false;
			DetachTrigger = false;
			FullyAttachedAt = -1f;
		}
	}

	private LegsAnimator.Variable _onOneSideV;

	private LegsAnimator.Variable _onStepCulldownV;

	private LegsAnimator.Variable _legSideCulldownV;

	private LegsAnimator.Variable _afterFullCulldownV;

	private LegsAnimator.Variable _modeV;

	private readonly string minSideS = "Minimum Standing Legs On One Side";

	private readonly string stepculldS = "On Step Culldown";

	private readonly string sideculldV = "Leg Side Culldown";

	private readonly string waitV = "On Full Attach Culldown";

	private readonly string modeV = "Mode";

	private float mainCulldown;

	private float sideLCulldown;

	private float sideRCulldown;

	private List<LegHelper> legHelpers;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper hlp)
	{
		_onOneSideV = hlp.RequestVariable(minSideS, 2);
		_onStepCulldownV = hlp.RequestVariable(stepculldS, 0.025f);
		_legSideCulldownV = hlp.RequestVariable(sideculldV, 0.015f);
		_afterFullCulldownV = hlp.RequestVariable(waitV, 0f);
		_modeV = hlp.RequestVariable(modeV, 0);
		legHelpers = new List<LegHelper>();
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegHelper item = new LegHelper(base.LA.Legs[i]);
			legHelpers.Add(item);
		}
		if (_onOneSideV.GetInt() >= base.LA.Legs.Count)
		{
			_onOneSideV.SetValue(base.LA.Legs.Count / 2);
		}
	}

	private bool AllowDetach(LegHelper leg)
	{
		if (mainCulldown > 0f)
		{
			return false;
		}
		if (leg.legRef.Side == LegsAnimator.ELegSide.Left)
		{
			if (sideLCulldown > 0f)
			{
				return false;
			}
		}
		else if (leg.legRef.Side == LegsAnimator.ELegSide.Right && sideRCulldown > 0f)
		{
			return false;
		}
		if (_onOneSideV.GetFloat() > 0f)
		{
			int num = 0;
			for (int i = 0; i < legHelpers.Count; i++)
			{
				LegsAnimator.Leg legRef = legHelpers[i].legRef;
				if (legRef.Side == leg.legRef.Side && (!legRef.G_DuringAttaching || legRef.G_Attached))
				{
					num++;
				}
			}
			if ((float)num < _onOneSideV.GetFloat())
			{
				return false;
			}
		}
		if (Time.time - leg.FullyAttachedAt < _afterFullCulldownV.GetFloat())
		{
			return false;
		}
		return true;
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if (legHelpers != null)
		{
			mainCulldown -= base.LA.DeltaTime;
			sideLCulldown -= base.LA.DeltaTime;
			sideRCulldown -= base.LA.DeltaTime;
		}
	}

	public override void Leg_LateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper hlp, LegsAnimator.Leg leg)
	{
		if (_modeV.GetInt() == 2)
		{
			CheckConditionsV2(hlp, leg);
			return;
		}
		LegHelper legHelper = legHelpers[leg.PlaymodeIndex];
		if (leg.G_DuringAttaching && !legHelper.WasAttaching)
		{
			mainCulldown = _onStepCulldownV.GetFloat();
			if (leg.Side == LegsAnimator.ELegSide.Left)
			{
				sideRCulldown = _legSideCulldownV.GetFloat();
			}
			else if (leg.Side == LegsAnimator.ELegSide.Right)
			{
				sideLCulldown = _legSideCulldownV.GetFloat();
			}
		}
		if (leg.G_Attached)
		{
			if (legHelper.FullyAttachedAt == -1f)
			{
				legHelper.FullyAttachedAt = Time.time;
			}
		}
		else
		{
			legHelper.FullyAttachedAt = -1f;
		}
		legHelper.legRef.G_CustomForceNOTDetach = !AllowDetach(legHelper);
		legHelper.WasAttaching = leg.G_DuringAttaching;
	}

	private void CheckConditionsV2(LegsAnimator.LegsAnimatorCustomModuleHelper hlp, LegsAnimator.Leg leg)
	{
		LegHelper legHelper = legHelpers[leg.PlaymodeIndex];
		if (leg.G_Attached)
		{
			if (legHelper.FullyAttachedAt == -1f)
			{
				legHelper.FullyAttachedAt = Time.time;
				legHelper.DetachTrigger = false;
			}
		}
		else
		{
			legHelper.FullyAttachedAt = -1f;
		}
		bool g_CustomForceNOTDetach = leg.G_CustomForceNOTDetach;
		leg.G_CustomForceNOTDetach = false;
		bool flag = false;
		bool flag2 = false;
		if (leg.G_Attached && leg.Glue_CheckDetachement() && leg.Glue_CheckIdleDetachementConfirm())
		{
			flag2 = true;
		}
		if (flag2 && !legHelper.WasAttaching && !legHelper.DetachTrigger && AllowDetach(legHelper))
		{
			flag = true;
			g_CustomForceNOTDetach = false;
			legHelper.DetachTrigger = true;
			leg.G_CustomForceDetach = true;
			mainCulldown = _onStepCulldownV.GetFloat();
			if (leg.Side == LegsAnimator.ELegSide.Left)
			{
				sideRCulldown = _legSideCulldownV.GetFloat();
			}
			else if (leg.Side == LegsAnimator.ELegSide.Right)
			{
				sideLCulldown = _legSideCulldownV.GetFloat();
			}
		}
		leg.G_CustomForceNOTDetach = g_CustomForceNOTDetach;
		if (!flag)
		{
			legHelper.legRef.G_CustomForceNOTDetach = !AllowDetach(legHelper);
		}
		legHelper.WasAttaching = leg.G_DuringAttaching;
	}
}


private class LegHelper
{
	public bool WasAttaching;

	public bool DetachTrigger;

	public float FullyAttachedAt = -1f;

	public LegsAnimator.Leg legRef { get; private set; }

	public LegHelper(LegsAnimator.Leg leg)
	{
		legRef = leg;
		WasAttaching = false;
		DetachTrigger = false;
		FullyAttachedAt = -1f;
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_ParamChanger_UnglueOnAngle : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _UnglueAngleOnMoving;

	private float initialUnglueOn = 30f;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_UnglueAngleOnMoving = helper.RequestVariable("Unglue Angle On Moving", 70f);
		initialUnglueOn = base.LA.UnglueOn;
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		base.LA.UnglueOn = Mathf.Lerp(initialUnglueOn, _UnglueAngleOnMoving.GetFloat(), base.LA.IsMovingBlend);
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

[CreateAssetMenu(fileName = "LAM_RedirectRaycasting", menuName = "FImpossible Creations/Legs Animator/Control Module - Redirect Raycasting", order = 1)]
public class LAM_RedirectRaycasting : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _LocalDirection;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.OnInit(helper);
		_LocalDirection = helper.RequestVariable("Rotate Raycast", (object)new Vector3(75f, 0f, 0f));
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.Euler(_LocalDirection.GetVector3());
		Matrix4x4 mx = Matrix4x4.TRS(base.LA.BaseTransform.position, val * base.LA.BaseTransform.rotation, base.LA.BaseTransform.lossyScale);
		base.LA.User_OverwriteCastMatrix(mx);
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_RotationStability : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _powerV;

	private LegsAnimator.Variable _compenV;

	private LegsAnimator.Variable _sideV;

	private LegsAnimator.Variable _forwV;

	public override bool AskForSpineBone => true;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		base.OnInit(helper);
		_powerV = helper.RequestVariable("Rotation Power", 0.4f);
		_compenV = helper.RequestVariable("Compensate Spine", 0.5f);
		_sideV = helper.RequestVariable("Side Multiplier", -1f);
		_forwV = helper.RequestVariable("Forward Multiplier", 1f);
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		float num = _powerV.GetFloat() * base.EffectBlend;
		if (num == 0f)
		{
			return;
		}
		Vector3 zero = Vector3.zero;
		zero += base.LA._Get_Hips_StabilityLocalOffset;
		zero += base.LA._Get_Hips_StabilityLocalAdjustement;
		zero.x /= base.LA.ScaleReferenceNoScale;
		zero.z += zero.y * 0.4f;
		zero.z /= base.LA.ScaleReferenceNoScale;
		zero.x *= 60f;
		zero.z *= 60f;
		Quaternion identity = Quaternion.identity;
		float num2 = 1f / Mathf.Max(0.15f, base.LA.StabilizeCenterOfMass) * 0.5f;
		identity *= Quaternion.AngleAxis(zero.z * num * _forwV.GetFloat() * num2, base.LA.BaseTransform.right);
		identity *= Quaternion.AngleAxis(zero.x * num * _sideV.GetFloat() * num2, base.LA.BaseTransform.forward);
		LegsAnimator lA = base.LA;
		lA._LastHipsRotationOffsetOutsideInfo *= identity;
		for (int i = 0; i < base.LA.HipsHubs.Count; i++)
		{
			LegsAnimator.HipsReference hipsReference = base.LA.HipsHubs[i];
			hipsReference._LastHipsRotationOffsetOutsideInfo *= identity;
		}
		if ((Object)(object)base.LA.SpineBone != (Object)null)
		{
			Quaternion val = Quaternion.identity;
			if ((Object)(object)base.LA.SpineBone != (Object)null)
			{
				val = base.LA.SpineBone.rotation;
			}
			base.LA.Hips.rotation = identity * base.LA.Hips.rotation;
			base.LA.SpineBone.rotation = Quaternion.Lerp(base.LA.SpineBone.rotation, val, _compenV.GetFloat());
		}
		else
		{
			base.LA.Hips.rotation = identity * base.LA.Hips.rotation;
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_SlopePusher : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _powerV;

	private LegsAnimator.Variable _thresV;

	private LegsAnimator.Variable _rapidV;

	private LegsAnimator.Variable _pushBackV;

	private Vector3 offsetV = Vector3.zero;

	private Vector3 _Sd_offsetV = Vector3.zero;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_powerV = helper.RequestVariable("Offset Power", 0.6f);
		_thresV = helper.RequestVariable("Push Threshold", 0.5f);
		_rapidV = helper.RequestVariable("Offset Rapidity", 0.5f);
		_pushBackV = helper.RequestVariable("Push Back", 0f);
	}

	public override void Leg_LateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		if (leg.A_WasAligning)
		{
			float num = base.LA.ScaleReferenceNoScale * 0.25f * _thresV.GetFloat();
			if (leg.groundHitRootSpacePos.y > num)
			{
				float num2 = Mathf.InverseLerp(5f, 50f, leg.raycastSlopeAngle);
				float num3 = (leg.groundHitRootSpacePos.y - num) / (num * 1.5f);
				Vector2 val2 = new Vector2(leg.groundHitRootSpacePos.x, leg.groundHitRootSpacePos.z);
				Vector2 normalized = ((Vector2)(ref val2)).normalized;
				val -= new Vector3(normalized.x, -0.033f, normalized.y) * (num3 * num) * _powerV.GetFloat() * 2f * num2;
			}
			if (_pushBackV.GetFloat() > 0f && base.LA.DesiredMovementDirection != Vector3.zero)
			{
				float num4 = _powerV.GetFloat();
				if (num4 <= 0f)
				{
					num4 = 1f;
				}
				Vector3 normalized2 = ((Vector3)(ref val)).normalized;
				Vector3 desiredMovementDirection = base.LA.DesiredMovementDirection;
				float num5 = 0f - Vector3.Dot(normalized2, ((Vector3)(ref desiredMovementDirection)).normalized);
				if (num5 < 0f)
				{
					val *= Mathf.Max(-1f, num5 * 2f) * (_pushBackV.GetFloat() / num4);
				}
			}
		}
		offsetV = Vector3.SmoothDamp(offsetV, val, ref _Sd_offsetV, 0.2f - _rapidV.GetFloat() * 0.199f, 1000000f, base.LA.DeltaTime);
		LegsAnimator lA = base.LA;
		lA._Hips_Modules_ExtraWOffset += base.LA.RootToWorldSpaceVec(offsetV);
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_StabilizePoseOnIdle : LegsAnimatorControlModuleBase
{
	private Vector3 currentHeightAdjust = Vector3.zero;

	private Vector3 sd_currentHeightAdjust = Vector3.zero;

	private LegsAnimator.Variable _blendV;

	private LegsAnimator.Variable _adjSpeed;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_blendV = helper.RequestVariable("Blend", 1f);
		_adjSpeed = helper.RequestVariable("Adjusting Speed", 1f);
	}

	public override void OnReInitialize(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		currentHeightAdjust = Vector3.zero;
		sd_currentHeightAdjust = Vector3.zero;
	}

	public override void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		if (base.LA.Legs.Count < 2)
		{
			return;
		}
		bool flag = false;
		if (!base.LA.IsMoving)
		{
			flag = true;
			if (base.LA.UseGluing)
			{
				for (int i = 0; i < base.LA.Legs.Count; i++)
				{
					if (!base.LA.Legs[i].G_Attached)
					{
						flag = false;
						break;
					}
				}
			}
		}
		if (flag)
		{
			LegsAnimator.Leg leg = base.LA.Legs[0];
			Vector3 val = leg._PreviousFinalIKPos + leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd * 0.6f);
			for (int j = 1; j < base.LA.Legs.Count; j++)
			{
				leg = base.LA.Legs[j];
				Vector3 val2 = leg._PreviousFinalIKPos + leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd * 0.6f);
				val = Vector3.LerpUnclamped(val, val2, 0.5f);
			}
			val = base.LA.ToRootLocalSpace(val);
			val.y = 0f;
			Vector3 val3 = base.LA.ToRootLocalSpace(base.LA._LastAppliedHipsFinalPosition);
			val3.y = 0f;
			val -= val3;
			val = base.LA.RootToWorldSpaceVec(val);
			currentHeightAdjust = Vector3.SmoothDamp(currentHeightAdjust, val, ref sd_currentHeightAdjust, 0.05f + _adjSpeed.GetFloat() * 0.3f, 1000000f, base.LA.DeltaTime);
		}
		else
		{
			currentHeightAdjust = Vector3.SmoothDamp(currentHeightAdjust, Vector3.zero, ref sd_currentHeightAdjust, 0.05f + _adjSpeed.GetFloat() * 0.3f, 1000000f, base.LA.DeltaTime);
		}
		Transform hips = base.LA.Hips;
		hips.position += currentHeightAdjust * base.EffectBlend * _blendV.GetFloat() * base.LA._MainBlend;
		Vector3 val4 = base.LA.BaseTransform.position + currentHeightAdjust + Vector3.up * 2.4f;
		val4.y = base.LA._LastAppliedHipsFinalPosition.y + 2f;
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_StepFurther : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _hipsV;

	private LegsAnimator.Variable _powerV;

	private LegsAnimator.Variable _mulV;

	private Vector3 customVelo = Vector3.zero;

	private Vector3 velo = Vector3.zero;

	private Vector3 finalVelo = Vector3.zero;

	private Vector3 _sd_velo = Vector3.zero;

	private Vector3 lastPos;

	public bool UsingCustomVelo { get; set; }

	public void ProvideVelocity(Vector3 velocity)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		UsingCustomVelo = true;
		customVelo = velo;
	}

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		base.OnInit(helper);
		UsingCustomVelo = false;
		_powerV = helper.RequestVariable("Predict Forward Offset", 0.1f);
		_hipsV = helper.RequestVariable("Predict Forward Hips Offset", 0f);
		_mulV = helper.RequestVariable("Extra Multiplier", 1f);
		lastPos = ((Component)base.LA).transform.position;
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vec = (UsingCustomVelo ? base.LA.ToRootLocalSpaceVec(customVelo) : ((Object.op_Implicit((Object)(object)base.LA.Rigidbody) && !base.LA.Rigidbody.isKinematic) ? base.LA.ToRootLocalSpaceVec(base.LA.Rigidbody.velocity) : (base.LA.usingCustomDesiredMovementDirection ? base.LA.ToRootLocalSpaceVec(base.LA.DesiredMovementDirection * base.LA.IsMovingBlend) : ((!(base.LA.DeltaTime > 0f)) ? Vector3.zero : base.LA.ToRootLocalSpaceVec((base.LegsAnim.BaseTransform.position - lastPos) / base.LA.DeltaTime)))));
		lastPos = base.LegsAnim.BaseTransform.position;
		vec.y = 0f;
		vec = base.LA.RootToWorldSpaceVec(vec);
		velo = Vector3.SmoothDamp(velo, vec, ref _sd_velo, 0.1f, 1000000f, base.LA.DeltaTime);
		finalVelo = velo * (_powerV.GetFloat() * _mulV.GetFloat() * base.EffectBlend);
	}

	public override void Leg_LatePreRaycastingUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		if (_powerV.GetFloat() > 0f)
		{
			leg.OverrideFinalAndSourceIKPos(leg.GetFinalIKPos() + finalVelo);
			leg.OverrideControlPositionsWithCurrentIKState();
		}
		if (leg.PlaymodeIndex == 0 && _hipsV.GetFloat() > 0f)
		{
			LegsAnimator lA = base.LA;
			lA._Hips_Modules_ExtraWOffset += velo * (_hipsV.GetFloat() * base.EffectBlend);
		}
	}
}


using System;
using FIMSpace;
using FIMSpace.AnimationTools;
using FIMSpace.FProceduralAnimation;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public class AxisLockableIK : FimpIK_Limb
{
	public enum EIKAxisLock
	{
		None = 0,
		X = 2,
		Y = 4,
		Z = 8
	}

	public EIKAxisLock FirstBoneAxisLock;

	public override void Update()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Initialized)
		{
			return;
		}
		Refresh();
		float num = IKPositionWeight * IKWeight;
		IKBone startIKBone = base.StartIKBone;
		Vector3 val = base.MiddleIKBone.transform.position - base.StartIKBone.transform.position;
		startIKBone.sqrMagn = ((Vector3)(ref val)).sqrMagnitude;
		IKBone middleIKBone = base.MiddleIKBone;
		val = base.EndIKBone.transform.position - base.MiddleIKBone.transform.position;
		middleIKBone.sqrMagn = ((Vector3)(ref val)).sqrMagnitude;
		targetElbowNormal = GetDefaultFlexNormal();
		if (ExtraHintAdjustementOffset != Vector3.zero)
		{
			val = Vector3.Lerp(targetElbowNormal, CalculateElbowNormalToPosition(base.EndIKBone.transform.position + base.EndIKBone.transform.rotation * ExtraHintAdjustementOffset), ((Vector3)(ref ExtraHintAdjustementOffset)).magnitude);
			targetElbowNormal = ((Vector3)(ref val)).normalized;
		}
		Vector3 val2 = GetOrientationDirection(IKTargetPosition, InverseHint ? (-targetElbowNormal) : targetElbowNormal);
		if (val2 == Vector3.zero)
		{
			val2 = base.MiddleIKBone.transform.position - base.StartIKBone.transform.position;
		}
		if (num > 0f)
		{
			Quaternion targetRotation = base.StartIKBone.GetRotation(val2, targetElbowNormal) * base.StartBoneRotationOffset;
			if (num < 1f)
			{
				targetRotation = Quaternion.LerpUnclamped(base.StartIKBone.srcRotation, targetRotation, num);
			}
			if (FirstBoneAxisLock != 0)
			{
				ApplyAxisLock(FirstBoneAxisLock, base.StartIKBone, ref targetRotation);
			}
			base.StartIKBone.transform.rotation = targetRotation;
			Quaternion val3 = base.MiddleIKBone.GetRotation(IKTargetPosition - base.MiddleIKBone.transform.position, base.MiddleIKBone.GetCurrentOrientationNormal());
			if (num < 1f)
			{
				val3 = Quaternion.LerpUnclamped(base.MiddleIKBone.srcRotation, val3, num);
			}
			base.MiddleIKBone.transform.rotation = val3;
		}
		postIKAnimatorEndBoneRot = base.EndIKBone.transform.rotation;
		EndBoneRotation();
	}

	private void ApplyAxisLock(EIKAxisLock axisLock, IKBone ikBone, ref Quaternion targetRotation)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = ikBone.transform.parent.rotation.QToLocal(targetRotation);
		Vector3 eulerAngles = ((Quaternion)(ref val)).eulerAngles;
		if ((axisLock & EIKAxisLock.X) != 0)
		{
			eulerAngles.x = ((Quaternion)(ref ikBone.LastKeyLocalRotation)).eulerAngles.x;
		}
		if ((axisLock & EIKAxisLock.Y) != 0)
		{
			eulerAngles.y = ((Quaternion)(ref ikBone.LastKeyLocalRotation)).eulerAngles.y;
		}
		if ((axisLock & EIKAxisLock.Z) != 0)
		{
			eulerAngles.z = ((Quaternion)(ref ikBone.LastKeyLocalRotation)).eulerAngles.z;
		}
		targetRotation = ikBone.transform.parent.rotation.QToWorld(AnimationGenerateUtils.EnsureQuaternionContinuity(targetRotation, Quaternion.Euler(eulerAngles)));
	}
}


public enum EIKAxisLock
{
	None = 0,
	X = 2,
	Y = 4,
	Z = 8
}


using System;
using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;

public class LAM_IKAlgorithmSwitch : LegsAnimatorControlModuleBase
{
	public bool lockX = true;

	public bool lockY;

	public bool lockZ;

	[NonSerialized]
	private List<AxisLockableIK> playmodeIKProcessors;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		base.OnInit(helper);
		playmodeIKProcessors = new List<AxisLockableIK>();
		for (int i = 0; i < base.LegsAnim.Legs.Count; i++)
		{
			LegsAnimator.Leg leg = base.LegsAnim.Legs[i];
			AxisLockableIK axisLockableIK = new AxisLockableIK();
			playmodeIKProcessors.Add(axisLockableIK);
			leg.AssignCustomIKProcessor(axisLockableIK);
		}
		OnValidateAfterManualChanges(helper);
	}

	private AxisLockableIK.EIKAxisLock GetLock()
	{
		AxisLockableIK.EIKAxisLock eIKAxisLock = AxisLockableIK.EIKAxisLock.None;
		if (lockX)
		{
			eIKAxisLock |= AxisLockableIK.EIKAxisLock.X;
		}
		if (lockY)
		{
			eIKAxisLock |= AxisLockableIK.EIKAxisLock.Y;
		}
		if (lockZ)
		{
			eIKAxisLock |= AxisLockableIK.EIKAxisLock.Z;
		}
		return eIKAxisLock;
	}

	private void OnValidate()
	{
		OnValidateAfterManualChanges(null);
	}

	public override void OnValidateAfterManualChanges(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if (helper != null)
		{
			base.OnValidateAfterManualChanges(helper);
		}
		if (playmodeIKProcessors != null)
		{
			for (int i = 0; i < playmodeIKProcessors.Count; i++)
			{
				playmodeIKProcessors[i].FirstBoneAxisLock = GetLock();
			}
		}
	}
}


using FIMSpace.FProceduralAnimation;

public class LAM_FadeGluingOnAnimator : LAM_FadeOnAnimatorStatusBase
{
	protected override void OnFadeAction(LegsAnimator.LegsAnimatorCustomModuleHelper helper, float fadeValue)
	{
		helper.Parent.MainGlueBlend = fadeValue;
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_FadeGluingOnAnimatorParam : LegsAnimatorControlModuleBase
{
	private int _hash = -1;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		string @string = helper.RequestVariable("Disable Gluing On Bool Param", "Animator Param Name").GetString();
		_hash = Animator.StringToHash(@string);
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if (helper.Parent.Mecanim.GetBool(_hash))
		{
			helper.Parent.MainGlueBlend = Mathf.MoveTowards(helper.Parent.MainGlueBlend, 0.001f, Time.deltaTime * 7f);
		}
		else
		{
			helper.Parent.MainGlueBlend = Mathf.MoveTowards(helper.Parent.MainGlueBlend, 1f, Time.deltaTime * 7f);
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_FadeLegsSystemOnAnimator : LAM_FadeOnAnimatorStatusBase
{
	protected override void OnFadeAction(LegsAnimator.LegsAnimatorCustomModuleHelper helper, float fadeValue)
	{
		helper.Parent.LegsAnimatorBlend = Mathf.Max(0.001f, fadeValue);
	}
}


using System;
using UnityEngine;

[Serializable]
public class MotionInfluenceProcessor
{
	public bool AdvancedInfluence;

	public Vector3 AxisMotionInfluence = Vector3.one;

	public Vector3 AxisMotionInfluenceBackwards = Vector3.one;

	private float MultiplyBlend = 1f;

	[NonSerialized]
	public float ExtraBoost = 1f;

	private float _sd_mb;

	private Transform root;

	public Vector3 OutputInfluenceOffset { get; private set; }

	public Vector3 previousPosition { get; private set; }

	public Vector3 rootOffset { get; private set; }

	public Vector3 localOffset { get; private set; }

	public void TransitionBlend(float target, float duration, float delta)
	{
		MultiplyBlend = Mathf.SmoothDamp(MultiplyBlend, target, ref _sd_mb, duration, 10000000f, delta);
	}

	public void Reset()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		previousPosition = root.position;
		localOffset = Vector3.zero;
		rootOffset = Vector3.zero;
	}

	public void Init(Transform root)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		this.root = root;
		previousPosition = root.position;
		localOffset = Vector3.zero;
	}

	public void Update()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		rootOffset = root.position - previousPosition;
		previousPosition = root.position;
		localOffset = root.InverseTransformVector(rootOffset);
		float num = MultiplyBlend * ExtraBoost;
		if (num != 1f)
		{
			localOffset *= num;
		}
		Motion_MotionInfluence();
	}

	public void OverrideOffset(Vector3 offset)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		rootOffset = offset;
		localOffset = root.InverseTransformVector(rootOffset);
		Motion_MotionInfluence();
	}

	private void Motion_MotionInfluence()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (!AdvancedInfluence)
		{
			if (AxisMotionInfluence != Vector3.one)
			{
				OutputInfluenceOffset = root.TransformVector(ScaleMotionInfluence(localOffset, AxisMotionInfluence));
			}
		}
		else
		{
			OutputInfluenceOffset = root.TransformVector(ScaleMotionInfluence(localOffset, AxisMotionInfluence, AxisMotionInfluenceBackwards));
		}
	}

	private Vector3 ScaleMotionInfluence(Vector3 toScale, Vector3 influenceMul)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(toScale.x * (1f - influenceMul.x), toScale.y * (1f - influenceMul.y), toScale.z * (1f - influenceMul.z));
	}

	private Vector3 ScaleMotionInfluence(Vector3 toScale, Vector3 influenceMulForw, Vector3 influenceMulBack)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		if (toScale.x > 0f)
		{
			toScale.x *= 1f - influenceMulForw.x;
		}
		else
		{
			toScale.x *= 1f - influenceMulBack.x;
		}
		if (toScale.y > 0f)
		{
			toScale.y *= 1f - influenceMulForw.y;
		}
		else
		{
			toScale.y *= 1f - influenceMulBack.y;
		}
		if (toScale.z > 0f)
		{
			toScale.z *= 1f - influenceMulForw.z;
		}
		else
		{
			toScale.z *= 1f - influenceMulBack.z;
		}
		return toScale;
	}

	public Vector3 CalculateInversedInfluence()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (!AdvancedInfluence)
		{
			if (AxisMotionInfluence != Vector3.one)
			{
				return root.TransformVector(ScaleMotionInfluenceInverse(localOffset, AxisMotionInfluence));
			}
			return rootOffset;
		}
		return root.TransformVector(ScaleMotionInfluenceInverse(localOffset, AxisMotionInfluence, AxisMotionInfluenceBackwards));
	}

	private Vector3 ScaleMotionInfluenceInverse(Vector3 toScale, Vector3 influenceMul)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(toScale.x * influenceMul.x, toScale.y * influenceMul.y, toScale.z * influenceMul.z);
	}

	private Vector3 ScaleMotionInfluenceInverse(Vector3 toScale, Vector3 influenceMulForw, Vector3 influenceMulBack)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (toScale.x > 0f)
		{
			toScale.x *= influenceMulForw.x;
		}
		else
		{
			toScale.x *= influenceMulBack.x;
		}
		if (toScale.y > 0f)
		{
			toScale.y *= influenceMulForw.y;
		}
		else
		{
			toScale.y *= influenceMulBack.y;
		}
		if (toScale.z > 0f)
		{
			toScale.z *= influenceMulForw.z;
		}
		else
		{
			toScale.z *= influenceMulBack.z;
		}
		return toScale;
	}
}


using FIMSpace;
using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;
using UnityEngine.AI;

[RequireComponent(typeof(NavMeshAgent))]
public class FGroundFitter_Demo_NavMesh : MonoBehaviour
{
	public FGroundFitter_Base TargetGroundFitter;

	[Range(0.5f, 50f)]
	public float RotationSpeed = 3f;

	[Tooltip("Moving Accordingly to rotation after acceleration")]
	[Range(0f, 1f)]
	public float DirectMovement = 0.8f;

	public float AnimationSpeedScale = 1f;

	private NavMeshAgent agent;

	private FAnimationClips animationClips;

	private bool reachedDestination;

	private Vector3 lastAgentPosition;

	private string movementClip;

	private float dirMov;

	private float sd_dirMov;

	public bool moving { get; private set; }

	private void Reset()
	{
		TargetGroundFitter = ((Component)this).GetComponent<FGroundFitter_Base>();
		if (Object.op_Implicit((Object)(object)TargetGroundFitter))
		{
			TargetGroundFitter.GlueToGround = false;
		}
		agent = ((Component)this).GetComponent<NavMeshAgent>();
		if (Object.op_Implicit((Object)(object)agent))
		{
			agent.acceleration = 1000f;
			agent.angularSpeed = 100f;
		}
	}

	protected virtual void Start()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TargetGroundFitter == (Object)null)
		{
			TargetGroundFitter = ((Component)this).GetComponent<FGroundFitter_Base>();
		}
		if (Object.op_Implicit((Object)(object)TargetGroundFitter))
		{
			TargetGroundFitter.GlueToGround = false;
		}
		agent = ((Component)this).GetComponent<NavMeshAgent>();
		agent.Warp(((Component)this).transform.position);
		agent.SetDestination(((Component)this).transform.position);
		moving = false;
		lastAgentPosition = ((Component)this).transform.position;
		reachedDestination = true;
		animationClips = new FAnimationClips(((Component)this).GetComponentInChildren<Animator>());
		animationClips.AddClip("Idle");
		if (animationClips.Animator.StateExists("Move") || animationClips.Animator.StateExists("move"))
		{
			movementClip = "Move";
		}
		else
		{
			movementClip = "Walk";
		}
		animationClips.AddClip(movementClip);
	}

	protected virtual void Update()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		FAnimationClips fAnimationClips = animationClips;
		Vector3 val = agent.desiredVelocity;
		fAnimationClips.SetFloat("AnimationSpeed", ((Vector3)(ref val)).magnitude * AnimationSpeedScale, 8f);
		IsMovingCheck();
		Vector3 val2 = agent.nextPosition - lastAgentPosition;
		val = agent.velocity;
		float magnitude = ((Vector3)(ref val)).magnitude;
		_ = ((Vector3)(ref val2)).normalized;
		Vector3 val3 = agent.nextPosition;
		if (DirectMovement > 0f)
		{
			if (magnitude > 0f)
			{
				Vector3 val4 = lastAgentPosition + ((Component)this).transform.forward * magnitude * Time.deltaTime;
				float num = 0.25f;
				float num2 = 1f;
				if (agent.remainingDistance <= agent.stoppingDistance * 1.1f + 0.1f)
				{
					num = 0.1f;
					num2 = 0f;
				}
				dirMov = Mathf.SmoothDamp(dirMov, num2, ref sd_dirMov, num, 1000f, Time.deltaTime);
				val3 = Vector3.LerpUnclamped(val3, val4, dirMov);
			}
			else
			{
				dirMov = Mathf.SmoothDamp(dirMov, 0f, ref sd_dirMov, 0.1f, 1000f, Time.deltaTime);
			}
		}
		val3.y = agent.nextPosition.y;
		((Component)this).transform.position = val3;
		if (moving)
		{
			Vector3 val5 = agent.nextPosition + agent.desiredVelocity;
			Quaternion val6 = Quaternion.LookRotation(new Vector3(val5.x, 0f, val5.z) - ((Component)this).transform.position);
			float y = ((Quaternion)(ref val6)).eulerAngles.y;
			TargetGroundFitter.UpAxisRotation = Mathf.LerpAngle(TargetGroundFitter.UpAxisRotation, y, Time.deltaTime * RotationSpeed);
		}
		lastAgentPosition = val3;
	}

	private bool IsMovingCheck()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		bool num = moving;
		moving = true;
		if (!agent.pathPending && agent.remainingDistance <= agent.stoppingDistance)
		{
			if (agent.hasPath)
			{
				Vector3 velocity = agent.velocity;
				if (((Vector3)(ref velocity)).sqrMagnitude != 0f)
				{
					goto IL_006e;
				}
			}
			if (!reachedDestination)
			{
				OnReachDestination();
			}
			moving = false;
		}
		goto IL_006e;
		IL_006e:
		if (num != moving)
		{
			OnStartMoving();
		}
		return moving;
	}

	protected virtual void OnReachDestination()
	{
		reachedDestination = true;
		animationClips.CrossFadeInFixedTime("Idle");
	}

	protected virtual void OnStartMoving()
	{
		reachedDestination = false;
		animationClips.CrossFadeInFixedTime(movementClip);
	}
}


using UnityEngine;
using UnityEngine.AI;

public class FGroundFitter_Demo_NavMeshInput : MonoBehaviour
{
	public NavMeshAgent TargetAgent;

	private void Update()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (Input.GetMouseButtonDown(0) && Object.op_Implicit((Object)(object)TargetAgent))
		{
			Ray val = Camera.main.ScreenPointToRay(Input.mousePosition);
			RaycastHit val2 = default(RaycastHit);
			NavMeshHit val3 = default(NavMeshHit);
			if (Physics.Raycast(((Ray)(ref val)).origin, ((Ray)(ref val)).direction, ref val2) && NavMesh.SamplePosition(((RaycastHit)(ref val2)).point, ref val3, 1f, 1))
			{
				TargetAgent.SetDestination(((NavMeshHit)(ref val3)).position);
			}
		}
	}
}


using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_Demo_Patrolling : MonoBehaviour
{
	public Vector4 MovementRandomPointRange = new Vector4(25f, -25f, 25f, -25f);

	public float speed = 1f;

	private Transform bodyTransform;

	private float bodyRotateSpeed = 5f;

	private Animator animator;

	private FGroundFitter fitter;

	private float timer;

	private Vector3 targetPoint;

	private bool onDestination;

	private FAnimationClips clips;

	private void Start()
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		fitter = ((Component)this).GetComponent<FGroundFitter>();
		animator = ((Component)this).GetComponentInChildren<Animator>();
		timer = Random.Range(1f, 5f);
		if (((Object)this).name.Contains("Fpider"))
		{
			bodyTransform = ((Component)this).transform.GetChild(0).Find("BSkeleton").GetChild(0)
				.Find("Body_Shield");
		}
		((Component)this).transform.rotation = Quaternion.Euler(0f, Random.Range(-180f, 180f), 0f);
		FGroundFitter fGroundFitter = fitter;
		Quaternion rotation = ((Component)this).transform.rotation;
		fGroundFitter.UpAxisRotation = ((Quaternion)(ref rotation)).eulerAngles.y;
		onDestination = true;
		((Component)this).transform.localScale = Vector3.one * Random.Range(0.5f, 1f);
		clips = new FAnimationClips(animator);
		clips.AddClip("Idle");
		clips.AddClip("Move");
	}

	private void Update()
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		if (onDestination)
		{
			timer -= Time.deltaTime;
			if (timer < 0f)
			{
				ChooseNewDestination();
			}
			bodyRotateSpeed = Mathf.Lerp(bodyRotateSpeed, 50f, Time.deltaTime * 2f);
		}
		else
		{
			RaycastHit lastRaycast = fitter.LastRaycast;
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastRaycast)).transform))
			{
				Transform transform = ((Component)this).transform;
				lastRaycast = fitter.LastRaycast;
				transform.position = ((RaycastHit)(ref lastRaycast)).point;
			}
			Transform transform2 = ((Component)this).transform;
			transform2.position += ((Component)this).transform.forward * speed * Time.deltaTime;
			if (Vector3.Distance(((Component)this).transform.position, targetPoint) < 2f)
			{
				ReachDestination();
			}
			Quaternion val = Quaternion.LookRotation(targetPoint - ((Component)this).transform.position);
			fitter.UpAxisRotation = Mathf.LerpAngle(fitter.UpAxisRotation, ((Quaternion)(ref val)).eulerAngles.y, Time.deltaTime * 7f);
			bodyRotateSpeed = Mathf.Lerp(bodyRotateSpeed, -250f, Time.deltaTime * 3f);
		}
		if (Object.op_Implicit((Object)(object)bodyTransform))
		{
			bodyTransform.Rotate(0f, 0f, Time.deltaTime * bodyRotateSpeed);
		}
	}

	private void ChooseNewDestination()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		targetPoint = new Vector3(Random.Range(MovementRandomPointRange.x, MovementRandomPointRange.y), 0f, Random.Range(MovementRandomPointRange.z, MovementRandomPointRange.w));
		RaycastHit val = default(RaycastHit);
		Physics.Raycast(targetPoint + Vector3.up * 1000f, Vector3.down, ref val, float.PositiveInfinity, LayerMask.op_Implicit(fitter.GroundLayerMask), (QueryTriggerInteraction)1);
		if (Object.op_Implicit((Object)(object)((RaycastHit)(ref val)).transform))
		{
			targetPoint = ((RaycastHit)(ref val)).point;
		}
		animator.CrossFadeInFixedTime(clips["Move"], 0.25f);
		onDestination = false;
	}

	private void ReachDestination()
	{
		timer = Random.Range(1f, 5f);
		onDestination = true;
		animator.CrossFadeInFixedTime(clips["Idle"], 0.15f);
	}
}


using FIMSpace;
using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_Demo_RootMotionExample : FGroundFitter_Movement
{
	protected override void Start()
	{
		base.Start();
		clips.AddClip("RotateL");
		clips.AddClip("RotateR");
	}

	protected override void HandleAnimations()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (Input.GetKey((KeyCode)97))
		{
			CrossfadeTo("RotateL");
			MoveVector = Vector3.zero;
		}
		else if (Input.GetKey((KeyCode)100))
		{
			CrossfadeTo("RotateR");
			MoveVector = Vector3.zero;
		}
		else if (ActiveSpeed > 0.15f)
		{
			if (Sprint)
			{
				CrossfadeTo("Run");
			}
			else
			{
				CrossfadeTo("Walk");
			}
		}
		else
		{
			CrossfadeTo("Idle");
		}
		if (animatorHaveAnimationSpeedProp)
		{
			if (inAir)
			{
				animator.LerpFloatValue("AnimationSpeed");
			}
			else
			{
				animator.LerpFloatValue("AnimationSpeed", MultiplySprintAnimation ? (ActiveSpeed / BaseSpeed) : Mathf.Min(1f, ActiveSpeed / BaseSpeed));
			}
		}
	}
}


using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter : FGroundFitter_Base_RootMotion
{
	[Header("< Specific Parameters >")]
	public EFUpdateClock UpdateClock;

	protected override void Reset()
	{
		base.Reset();
		RelativeLookUp = true;
		RelativeLookUpBias = 0.25f;
	}

	private void Update()
	{
		if (UpdateClock == EFUpdateClock.Update)
		{
			deltaTime = Time.deltaTime;
			FitToGround();
		}
	}

	private void FixedUpdate()
	{
		if (UpdateClock == EFUpdateClock.FixedUpdate)
		{
			deltaTime = Time.fixedDeltaTime;
			FitToGround();
		}
	}

	private void LateUpdate()
	{
		if (UpdateClock == EFUpdateClock.LateUpdate)
		{
			deltaTime = Time.deltaTime;
			FitToGround();
		}
	}

	public void RefreshDelta()
	{
		switch (UpdateClock)
		{
		case EFUpdateClock.Update:
			deltaTime = Time.deltaTime;
			break;
		case EFUpdateClock.LateUpdate:
			deltaTime = Time.deltaTime;
			break;
		case EFUpdateClock.FixedUpdate:
			deltaTime = Time.fixedDeltaTime;
			break;
		}
	}

	protected override void FitToGround()
	{
		HandleRootMotionSupport();
		base.FitToGround();
	}

	protected override void HandleRootMotionSupport()
	{
		base.HandleRootMotionSupport();
		if (HandleRootMotion)
		{
			UpdateClock = EFUpdateClock.LateUpdate;
		}
	}
}


using System;
using FIMSpace;
using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;

[RequireComponent(typeof(FGroundFitter))]
public class FGroundFitter_Movement : MonoBehaviour
{
	[Header("> Main Tweak Variables <")]
	public float BaseSpeed = 3f;

	public float RotateToTargetSpeed = 6f;

	public float SprintingSpeed = 10f;

	protected float ActiveSpeed;

	public float AccelerationSpeed = 10f;

	public float DecelerationSpeed = 10f;

	[Header("> Additional Options <")]
	public float JumpPower = 7f;

	public float gravity = 15f;

	public bool MultiplySprintAnimation;

	[Range(0f, 20f)]
	public float RotateBackInAir;

	[Tooltip("Protecting from going through walls when slope is very big and ground fitter is jumping into it")]
	public bool NotFallingThrough;

	[Tooltip("You need collider and rigidbody on object to make it work right - ALSO CHANGE YOUR CAMERA UPDATE CLOCK TO FIXED UPDATE AND USE TIME.fixedDeltaTime - ! For now it can cause errors when jumping, character can go through floor sometimes ! - Will be upgraded in future versions")]
	[Header("(experimental)")]
	public bool UsePhysics;

	[Tooltip("Disabling translating object from code and running animation without need to hold minimum movement speed")]
	public bool UseRootMotionTranslation;

	public bool UseRootMotionRotation;

	internal float YVelocity;

	protected bool inAir;

	protected float gravitUpOffset;

	internal Vector3 lastNotZeroMoveVector = Vector3.zero;

	internal Vector3 MoveVector = Vector3.zero;

	internal bool Sprint;

	internal float RotationOffset;

	protected string lastAnim = "";

	protected Animator animator;

	protected FGroundFitter fitter;

	protected Rigidbody rigb;

	protected bool animatorHaveAnimationSpeedProp;

	protected float initialUpOffset;

	protected Vector3 holdJumpPosition;

	protected float freezeJumpYPosition;

	protected float delta;

	protected Vector3 lastVelocity;

	protected Collider itsCollider;

	protected FAnimationClips clips;

	internal static int _hash_animSp = Animator.StringToHash("AnimationSpeed");

	private int _hash_IsGrounded = -1;

	private int _hash_IsMov = -1;

	private bool slidingAssigned;

	private float? yAdjustPos;

	[HideInInspector]
	[Tooltip("If you want to set some animator parameter during being grounded")]
	public string SetIsGroundedParam = "";

	[HideInInspector]
	[Tooltip("If you want to set some animator parameter during accelerating moving")]
	public string SetIsMovingParam = "";

	[HideInInspector]
	[Tooltip("If using physical move with collider, assigning to the collider sliding material")]
	public bool UseSlidingMat = true;

	private static PhysicMaterial pm_Sliding = null;

	private void Reset()
	{
		if (!Object.op_Implicit((Object)(object)((Component)this).gameObject.GetComponent<FGroundFitter_Input>()))
		{
			((Component)this).gameObject.AddComponent<FGroundFitter_Input>();
		}
	}

	protected virtual void Start()
	{
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		fitter = ((Component)this).GetComponent<FGroundFitter>();
		animator = ((Component)this).GetComponentInChildren<Animator>();
		rigb = ((Component)this).GetComponent<Rigidbody>();
		itsCollider = ((Component)this).GetComponentInChildren<Collider>();
		if (!string.IsNullOrEmpty(SetIsGroundedParam))
		{
			_hash_IsGrounded = Animator.StringToHash(SetIsGroundedParam);
		}
		if (!string.IsNullOrEmpty(SetIsMovingParam))
		{
			_hash_IsMov = Animator.StringToHash(SetIsMovingParam);
		}
		if (Object.op_Implicit((Object)(object)animator))
		{
			if (HasParameter(animator, "AnimationSpeed"))
			{
				animatorHaveAnimationSpeedProp = true;
			}
			animator.applyRootMotion = false;
		}
		FGroundFitter fGroundFitter = fitter;
		Quaternion rotation = ((Component)this).transform.rotation;
		fGroundFitter.UpAxisRotation = ((Quaternion)(ref rotation)).eulerAngles.y;
		initialUpOffset = fitter.UpOffset;
		fitter.RefreshLastRaycast();
		clips = new FAnimationClips(animator);
		clips.AddClip("Idle");
		clips.AddClip("Walk");
		clips.AddClip("Run");
	}

	protected virtual void Update()
	{
		HandleBaseVariables();
		HandleGravity();
		HandleAnimations();
		HandleTransforming();
		if (!UsePhysics)
		{
			ApplyTransforming();
		}
	}

	protected virtual void FixedUpdate()
	{
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Expected O, but got Unknown
		if (Object.op_Implicit((Object)(object)rigb))
		{
			if (UsePhysics)
			{
				rigb.useGravity = false;
				rigb.isKinematic = false;
				if (!slidingAssigned)
				{
					Collider componentInChildren = ((Component)this).GetComponentInChildren<Collider>();
					if (Object.op_Implicit((Object)(object)componentInChildren))
					{
						if ((Object)(object)pm_Sliding == (Object)null)
						{
							pm_Sliding = new PhysicMaterial("Sliding");
							pm_Sliding.bounciness = 0f;
							pm_Sliding.frictionCombine = (PhysicMaterialCombine)2;
							pm_Sliding.dynamicFriction = 0f;
							pm_Sliding.staticFriction = 0f;
						}
						componentInChildren.material = pm_Sliding;
						slidingAssigned = true;
					}
				}
			}
			else
			{
				rigb.isKinematic = true;
			}
		}
		if (!UsePhysics)
		{
			fitter.ApplyRotation = true;
			return;
		}
		ApplyTransforming();
		rigb.angularVelocity = Vector3.zero;
		rigb.freezeRotation = true;
		fitter.ApplyRotation = false;
		rigb.rotation = fitter.targetRotationToApply;
	}

	protected virtual void HandleBaseVariables()
	{
		delta = Time.deltaTime;
		if (UseRootMotionTranslation)
		{
			fitter.HandleRootMotion = false;
			if ((Object)(object)((Component)animator).gameObject != (Object)(object)((Component)this).gameObject && !animator.applyRootMotion && !Object.op_Implicit((Object)(object)((Component)animator).GetComponent<FGroundFitter_RootMotionHelper>()))
			{
				((Component)animator).gameObject.AddComponent<FGroundFitter_RootMotionHelper>().MovementController = this;
			}
			fitter.UpdateClock = EFUpdateClock.LateUpdate;
			animator.applyRootMotion = true;
		}
		else
		{
			animator.applyRootMotion = false;
		}
	}

	protected virtual void HandleGravity()
	{
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		if (((Behaviour)fitter).enabled)
		{
			if (fitter.UpOffset > initialUpOffset)
			{
				fitter.UpOffset += YVelocity * delta;
			}
			else
			{
				fitter.UpOffset = initialUpOffset;
			}
		}
		else
		{
			fitter.UpOffset += YVelocity * delta;
		}
		if (inAir)
		{
			YVelocity -= gravity * delta;
			fitter.RefreshDelta();
			fitter.RotateBack(RotateBackInAir);
		}
		if (((Behaviour)fitter).enabled)
		{
			RaycastHit lastRaycast = fitter.LastRaycast;
			if (!Object.op_Implicit((Object)(object)((RaycastHit)(ref lastRaycast)).transform))
			{
				if (!inAir)
				{
					inAir = true;
					holdJumpPosition = ((Component)this).transform.position;
					freezeJumpYPosition = holdJumpPosition.y;
					YVelocity = -1f;
					((Behaviour)fitter).enabled = false;
				}
			}
			else if (YVelocity > 0f)
			{
				inAir = true;
			}
		}
		if (!inAir)
		{
			return;
		}
		if (((Behaviour)fitter).enabled)
		{
			((Behaviour)fitter).enabled = false;
		}
		if (YVelocity < 0f)
		{
			RaycastHit val = fitter.CastRay();
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref val)).transform) && ((Component)this).transform.position.y + YVelocity * delta <= ((RaycastHit)(ref val)).point.y + initialUpOffset + 0.05f)
			{
				fitter.UpOffset -= ((RaycastHit)(ref val)).point.y - freezeJumpYPosition;
				HitGround();
			}
		}
		else
		{
			RaycastHit val2 = fitter.CastRay();
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref val2)).transform) && ((RaycastHit)(ref val2)).point.y - 0.1f > ((Component)this).transform.position.y)
			{
				fitter.UpOffset = initialUpOffset;
				YVelocity = -1f;
				HitGround();
			}
		}
		if (NotFallingThrough && inAir)
		{
			Vector3 forward = ((Component)fitter).transform.forward;
			float raycastCheckRange = fitter.RaycastCheckRange;
			if (Physics.Raycast(fitter.GetRaycastOrigin() - forward * raycastCheckRange * 0.1f, forward, raycastCheckRange * 1.11f, LayerMask.op_Implicit(fitter.GroundLayerMask), (QueryTriggerInteraction)1))
			{
				float raycastCheckRange2 = fitter.RaycastCheckRange;
				fitter.RaycastCheckRange *= 100f;
				fitter.UpOffset = initialUpOffset;
				YVelocity = -1f;
				HitGround();
				fitter.RaycastCheckRange = raycastCheckRange2;
			}
		}
	}

	protected virtual void HandleAnimations()
	{
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		float value = 1f;
		if (ActiveSpeed > 0.15f)
		{
			if (ActiveSpeed > (BaseSpeed + SprintingSpeed) * 0.25f)
			{
				value = ActiveSpeed / SprintingSpeed;
				CrossfadeTo("Run");
			}
			else
			{
				value = ActiveSpeed / BaseSpeed;
				CrossfadeTo("Walk");
			}
		}
		else
		{
			CrossfadeTo("Idle");
		}
		if (animatorHaveAnimationSpeedProp)
		{
			if (inAir)
			{
				animator.LerpFloatValue("AnimationSpeed");
			}
			else
			{
				animator.LerpFloatValue("AnimationSpeed", value);
			}
		}
		if (Object.op_Implicit((Object)(object)animator))
		{
			if (_hash_IsGrounded != -1)
			{
				animator.SetBool(_hash_IsGrounded, !inAir);
			}
			if (_hash_IsMov != -1)
			{
				animator.SetBool(_hash_IsMov, MoveVector != Vector3.zero);
			}
		}
	}

	protected void RefreshHitGroundVars(RaycastHit hit)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		holdJumpPosition = ((RaycastHit)(ref hit)).point;
		freezeJumpYPosition = ((RaycastHit)(ref hit)).point.y;
		fitter.UpOffset = Mathf.Abs(((RaycastHit)(ref hit)).point.y - ((Component)this).transform.position.y);
	}

	protected virtual void HandleTransforming()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		if (!UseRootMotionTranslation)
		{
			lastVelocity = ((Component)this).transform.TransformDirection(lastNotZeroMoveVector) * ActiveSpeed;
		}
		if (((Behaviour)fitter).enabled)
		{
			RaycastHit lastRaycast = fitter.LastRaycast;
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastRaycast)).transform))
			{
				lastRaycast = fitter.LastRaycast;
				Vector3 val = ((RaycastHit)(ref lastRaycast)).point + fitter.UpOffset * Vector3.up;
				if (!UsePhysics)
				{
					((Component)this).transform.position = val;
				}
				else if (Object.op_Implicit((Object)(object)rigb))
				{
					yAdjustPos = val.y;
				}
				holdJumpPosition = ((Component)this).transform.position;
				freezeJumpYPosition = holdJumpPosition.y;
			}
			else
			{
				inAir = true;
			}
		}
		else
		{
			holdJumpPosition.y = freezeJumpYPosition + fitter.UpOffset;
		}
		if (MoveVector != Vector3.zero)
		{
			if (!UseRootMotionRotation)
			{
				if (!((Behaviour)fitter).enabled)
				{
					fitter.UpAxisRotation = Mathf.LerpAngle(fitter.UpAxisRotation, ((Component)Camera.main).transform.eulerAngles.y + RotationOffset, delta * RotateToTargetSpeed * 0.15f);
					fitter.RotationCalculations();
				}
				else
				{
					fitter.UpAxisRotation = Mathf.LerpAngle(fitter.UpAxisRotation, ((Component)Camera.main).transform.eulerAngles.y + RotationOffset, delta * RotateToTargetSpeed);
				}
			}
			if (!Sprint)
			{
				ActiveSpeed = Mathf.Lerp(ActiveSpeed, BaseSpeed, delta * AccelerationSpeed);
			}
			else
			{
				ActiveSpeed = Mathf.Lerp(ActiveSpeed, SprintingSpeed, delta * AccelerationSpeed);
			}
		}
		else if (ActiveSpeed > 0f)
		{
			ActiveSpeed = Mathf.Lerp(ActiveSpeed, -0.01f, delta * DecelerationSpeed);
		}
		else
		{
			ActiveSpeed = 0f;
		}
		holdJumpPosition += lastVelocity * delta;
		if (MoveVector != Vector3.zero)
		{
			lastNotZeroMoveVector = MoveVector;
		}
	}

	private void ApplyTransforming()
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (UsePhysics && Object.op_Implicit((Object)(object)rigb))
		{
			float num = YVelocity;
			if (!inAir && yAdjustPos.HasValue)
			{
				num = (yAdjustPos.Value - rigb.position.y) / Time.fixedDeltaTime;
			}
			rigb.velocity = new Vector3(lastVelocity.x, num, lastVelocity.z);
		}
		else
		{
			((Component)this).transform.position = holdJumpPosition;
		}
	}

	internal virtual void OnAnimatorMove()
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (UseRootMotionTranslation)
		{
			if (!inAir)
			{
				lastVelocity = animator.velocity;
			}
			animator.rootPosition = ((Component)this).transform.position;
			animator.rootRotation = fitter.LastRotation;
		}
		if (UseRootMotionRotation)
		{
			animator.rootRotation = fitter.LastRotation;
			Quaternion deltaRotation = animator.deltaRotation;
			float num = default(float);
			Vector3 val = default(Vector3);
			((Quaternion)(ref deltaRotation)).ToAngleAxis(ref num, ref val);
			float y = (val * num * (MathF.PI / 180f)).y;
			fitter.UpAxisRotation += y / Time.deltaTime;
		}
	}

	protected virtual void HitGround()
	{
		fitter.RefreshLastRaycast();
		((Behaviour)fitter).enabled = true;
		inAir = false;
		freezeJumpYPosition = 0f;
	}

	public virtual void Jump()
	{
		YVelocity = JumpPower;
		fitter.UpOffset += JumpPower * Time.deltaTime / 2f;
	}

	protected virtual void CrossfadeTo(string animation, float transitionTime = 0.25f)
	{
		if (!clips.ContainsKey(animation))
		{
			if (!(animation == "Run"))
			{
				return;
			}
			animation = "Walk";
		}
		if (lastAnim != animation)
		{
			animator.CrossFadeInFixedTime(clips[animation], transitionTime);
			lastAnim = animation;
		}
	}

	public static bool HasParameter(Animator animator, string paramName)
	{
		AnimatorControllerParameter[] parameters = animator.parameters;
		for (int i = 0; i < parameters.Length; i++)
		{
			if (parameters[i].name == paramName)
			{
				return true;
			}
		}
		return false;
	}
}


using FIMSpace;
using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundRotator : FGroundFitter_Base
{
	[Tooltip("Root transform should be first object in the hierarchy of your movement game object")]
	public Transform RootTransform;

	public EFUpdateClock UpdateClock;

	private Quaternion initLocalRotation;

	private Vector3 mappingRight;

	private Vector3 mappingUp;

	private Vector3 mappingForward;

	protected override void Reset()
	{
		base.Reset();
		RelativeLookUp = false;
		RelativeLookUpBias = 0f;
		GlueToGround = false;
	}

	protected override void Start()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		base.Start();
		initLocalRotation = TransformToRotate.localRotation;
		mappingForward = ((Component)this).transform.InverseTransformDirection(RootTransform.forward);
		mappingUp = ((Component)this).transform.InverseTransformDirection(RootTransform.up);
		mappingRight = ((Component)this).transform.InverseTransformDirection(RootTransform.right);
	}

	private void Update()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		if (UpdateClock != EFUpdateClock.FixedUpdate)
		{
			TransformToRotate.localRotation = initLocalRotation;
		}
	}

	private void FixedUpdate()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		if (UpdateClock == EFUpdateClock.FixedUpdate)
		{
			TransformToRotate.localRotation = initLocalRotation;
		}
	}

	private void LateUpdate()
	{
		deltaTime = Time.deltaTime;
		FitToGround();
	}

	internal override void RotationCalculations()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		targetRotationToApply = helperRotation;
		targetRotationToApply *= RootTransform.rotation;
		Vector3 eulerAngles = ((Quaternion)(ref targetRotationToApply)).eulerAngles;
		targetRotationToApply = Quaternion.Euler(Mathf.Clamp(FLogicMethods.WrapAngle(eulerAngles.x), 0f - MaxForwardRotation, MaxForwardRotation) * (1f - MildForwardValue), eulerAngles.y, Mathf.Clamp(FLogicMethods.WrapAngle(eulerAngles.z), 0f - MaxHorizontalRotation, MaxHorizontalRotation) * (1f - MildHorizontalValue));
		eulerAngles = ((Quaternion)(ref targetRotationToApply)).eulerAngles;
		Quaternion val = RootTransform.rotation.QToLocal(Quaternion.Euler(eulerAngles));
		eulerAngles = ((Quaternion)(ref val)).eulerAngles;
		Quaternion val2 = TransformToRotate.rotation;
		if (eulerAngles.x != 0f)
		{
			val2 *= Quaternion.AngleAxis(eulerAngles.x, mappingRight);
		}
		if (eulerAngles.y != 0f)
		{
			val2 *= Quaternion.AngleAxis(eulerAngles.y, mappingUp);
		}
		if (eulerAngles.z != 0f)
		{
			val2 *= Quaternion.AngleAxis(eulerAngles.z, mappingForward);
		}
		TransformToRotate.rotation = val2;
	}
}


using FIMSpace.GroundFitter;
using UnityEngine;

public class FSimpleFitter : FGroundFitter_Base_RootMotion
{
	protected override void Reset()
	{
		base.Reset();
		RelativeLookUp = false;
		RelativeLookUpBias = 0f;
	}

	private void LateUpdate()
	{
		deltaTime = Time.deltaTime;
		FitToGround();
	}

	protected override void FitToGround()
	{
		HandleRootMotionSupport();
		base.FitToGround();
	}

	protected override void HandleRootMotionSupport()
	{
		base.HandleRootMotionSupport();
	}
}


using System;
using System.Collections.Generic;
using FIMSpace;
using UnityEngine;

public abstract class FGroundFitter_Base : MonoBehaviour
{
	[Header("> Main Variables <", order = 0)]
	[Space(4f, order = 1)]
	[Tooltip("How quick rotation should be corrected to target")]
	[Range(1f, 30f)]
	public float FittingSpeed = 6f;

	[Range(0f, 1f)]
	[Tooltip("Smoothing whole rotation motion")]
	public float TotalSmoother;

	[Space(3f)]
	[Tooltip("Transform which will be rotated by script, usually it can be the same transform as component's")]
	[HideInInspector]
	public Transform TransformToRotate;

	[Space(3f)]
	[Tooltip("If you want this script only to change your object's rotation and do nothing with position, untoggle this")]
	public bool GlueToGround;

	[Header("> Tweaking Settings <", order = 0)]
	[Space(4f, order = 1)]
	[Range(0f, 1f)]
	[Tooltip("If forward/pitch rotation value should go in lighter value than real normal hit direction")]
	public float MildForwardValue;

	[Tooltip("Maximum rotation angle in rotation of x/pitch axis, so rotating forward - degrees value of maximum rotation")]
	[Range(0f, 90f)]
	public float MaxForwardRotation = 90f;

	[Space(5f)]
	[Range(0f, 1f)]
	[Tooltip("If side rotation value/roll should go in lighter value than real normal hit direction")]
	public float MildHorizontalValue;

	[Tooltip("Max roll rotation. If rotation should work on also on x axis - good for spiders, can look wrong on quadropeds etc.")]
	[Range(0f, 90f)]
	public float MaxHorizontalRotation = 90f;

	[Tooltip("We should cast raycast from position little higher than foots of your game object")]
	[Space(4f, order = 1)]
	[Header("> Advanced settings <", order = 0)]
	public float RaycastHeightOffset = 0.5f;

	[Tooltip("How far ray should cast to check if ground is under feet")]
	public float RaycastCheckRange = 5f;

	[Tooltip("If value is not equal 0 there will be casted second ray in front or back of gameObject")]
	public float LookAheadRaycast;

	[Tooltip("Blending with predicted forward raycast rotation")]
	public float AheadBlend = 0.5f;

	[Tooltip("Offset over ground")]
	[HideInInspector]
	public float UpOffset;

	[Space(8f)]
	[Tooltip("What collision layers should be included by algorithm")]
	public LayerMask GroundLayerMask = LayerMask.op_Implicit(1);

	[Tooltip("When casting down vector should adjust with transform's rotation")]
	public bool RelativeLookUp;

	[Range(0f, 1f)]
	public float RelativeLookUpBias;

	internal Vector3 WorldUp = Vector3.up;

	[Space(8f)]
	[Tooltip("Casting more raycsts under object to detect ground more precisely, then we use average from all casts to set new rotation")]
	public bool ZoneCast;

	public Vector2 ZoneCastDimensions = new Vector2(0.3f, 0.5f);

	public Vector3 ZoneCastOffset = Vector3.zero;

	[Range(0f, 10f)]
	public float ZoneCastBias;

	[Range(0f, 1f)]
	[Tooltip("More precision = more raycasts = lower performance")]
	public float ZoneCastPrecision = 0.25f;

	[NonSerialized]
	public float UpAxisRotation;

	protected Quaternion helperRotation = Quaternion.identity;

	protected Collider selfCollider;

	protected Vector3 castOffset = Vector3.zero;

	protected float deltaTime;

	internal bool ApplyRotation = true;

	internal Quaternion targetRotationToApply = Quaternion.identity;

	public RaycastHit LastRaycast { get; protected set; }

	public Vector3 LastRaycastOrigin { get; protected set; }

	public RaycastHit LastTransformRaycast { get; protected set; }

	public Quaternion LastRotation { get; protected set; }

	protected virtual void Start()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		selfCollider = ((Component)this).GetComponent<Collider>();
		if ((Object)(object)TransformToRotate == (Object)null)
		{
			TransformToRotate = ((Component)this).transform;
		}
		UpAxisRotation = ((Component)this).transform.localEulerAngles.y;
	}

	protected virtual void Reset()
	{
		TransformToRotate = ((Component)this).transform;
	}

	protected virtual void FitToGround()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)selfCollider))
		{
			selfCollider.enabled = false;
		}
		RaycastHit val = default(RaycastHit);
		if (LookAheadRaycast != 0f)
		{
			Physics.Raycast(TransformToRotate.position + GetUpVector(RaycastHeightOffset) + TransformToRotate.forward * LookAheadRaycast, -GetUpVector(), ref val, RaycastCheckRange, LayerMask.op_Implicit(GroundLayerMask), (QueryTriggerInteraction)1);
		}
		RefreshLastRaycast();
		RaycastHit lastRaycast = LastRaycast;
		if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastRaycast)).transform))
		{
			Vector3 up = Vector3.up;
			lastRaycast = LastRaycast;
			Quaternion val2 = Quaternion.FromToRotation(up, ((RaycastHit)(ref lastRaycast)).normal);
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref val)).transform))
			{
				Quaternion val3 = Quaternion.FromToRotation(Vector3.up, ((RaycastHit)(ref val)).normal);
				val2 = Quaternion.Lerp(val2, val3, AheadBlend);
			}
			helperRotation = Quaternion.Slerp(helperRotation, val2, deltaTime * FittingSpeed);
		}
		else
		{
			helperRotation = Quaternion.Slerp(helperRotation, Quaternion.identity, deltaTime * FittingSpeed);
		}
		RotationCalculations();
		if (GlueToGround)
		{
			lastRaycast = LastRaycast;
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastRaycast)).transform))
			{
				Transform transformToRotate = TransformToRotate;
				lastRaycast = LastRaycast;
				transformToRotate.position = ((RaycastHit)(ref lastRaycast)).point + Vector3.up * UpOffset;
			}
		}
		if (Object.op_Implicit((Object)(object)selfCollider))
		{
			selfCollider.enabled = true;
		}
	}

	internal virtual void RotationCalculations()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = helperRotation;
		val = Quaternion.Euler(Mathf.Clamp(FLogicMethods.WrapAngle(((Quaternion)(ref val)).eulerAngles.x), 0f - MaxForwardRotation, MaxForwardRotation) * (1f - MildForwardValue), ((Quaternion)(ref val)).eulerAngles.y, Mathf.Clamp(FLogicMethods.WrapAngle(((Quaternion)(ref val)).eulerAngles.z), 0f - MaxHorizontalRotation, MaxHorizontalRotation) * (1f - MildHorizontalValue));
		if (TotalSmoother == 0f)
		{
			targetRotationToApply = val * Quaternion.AngleAxis(UpAxisRotation, Vector3.up);
		}
		else
		{
			Quaternion val2 = Quaternion.AngleAxis(UpAxisRotation, Vector3.up);
			targetRotationToApply *= Quaternion.Inverse(val2);
			targetRotationToApply = Quaternion.Slerp(targetRotationToApply, val, deltaTime * Mathf.Lerp(50f, 1f, TotalSmoother));
			targetRotationToApply *= val2;
		}
		if (ApplyRotation)
		{
			TransformToRotate.rotation = targetRotationToApply;
		}
		LastRotation = TransformToRotate.rotation;
	}

	internal virtual RaycastHit CastRay()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		LastRaycastOrigin = GetRaycastOrigin() + castOffset;
		RaycastHit val = default(RaycastHit);
		Physics.Raycast(LastRaycastOrigin, -GetUpVector(), ref val, RaycastCheckRange + Mathf.Abs(UpOffset), LayerMask.op_Implicit(GroundLayerMask), (QueryTriggerInteraction)1);
		if (ZoneCast)
		{
			Vector3 val2 = TransformToRotate.position + GetRotation() * ZoneCastOffset + GetUpVector(RaycastHeightOffset);
			Vector3 val3 = TransformToRotate.right * ZoneCastDimensions.x;
			Vector3 val4 = TransformToRotate.forward * ZoneCastDimensions.y;
			List<RaycastHit> list = new List<RaycastHit>();
			list.Add(val);
			int num = 0;
			float num2 = 1f;
			RaycastHit item = default(RaycastHit);
			for (int i = 0; (float)i < Mathf.Lerp(4f, 24f, ZoneCastPrecision); i++)
			{
				Vector3 val5 = Vector3.zero;
				switch (num)
				{
				case 0:
					val5 = val3 - val4;
					break;
				case 1:
					val5 = val3 + val4;
					break;
				case 2:
					val5 = -val3 + val4;
					break;
				case 3:
					val5 = -val3 - val4;
					num2 += 0.75f;
					num = -1;
					break;
				}
				Physics.Raycast(val2 + val5 / num2, -GetUpVector() + val5 * ZoneCastBias + castOffset, ref item, RaycastCheckRange + Mathf.Abs(UpOffset), LayerMask.op_Implicit(GroundLayerMask), (QueryTriggerInteraction)1);
				if (Object.op_Implicit((Object)(object)((RaycastHit)(ref item)).transform))
				{
					list.Add(item);
				}
				num++;
			}
			Vector3 val6 = Vector3.zero;
			Vector3 val7 = Vector3.zero;
			for (int j = 0; j < list.Count; j++)
			{
				Vector3 val8 = val7;
				RaycastHit val9 = list[j];
				val7 = val8 + ((RaycastHit)(ref val9)).normal;
				Vector3 val10 = val6;
				val9 = list[j];
				val6 = val10 + ((RaycastHit)(ref val9)).point;
			}
			val6 /= (float)list.Count;
			val7 /= (float)list.Count;
			((RaycastHit)(ref val)).normal = val7;
			if (!Object.op_Implicit((Object)(object)((RaycastHit)(ref val)).transform))
			{
				((RaycastHit)(ref val)).point = new Vector3(val6.x, TransformToRotate.position.y, val6.z);
			}
		}
		return val;
	}

	internal Vector3 GetRaycastOrigin()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return TransformToRotate.position + GetUpVector() * RaycastHeightOffset;
	}

	protected virtual Quaternion GetRotation()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return TransformToRotate.rotation;
	}

	protected virtual Vector3 GetUpVector(float mulRange = 1f)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (RelativeLookUp)
		{
			Vector3 worldUp = WorldUp;
			Vector3 val = TransformToRotate.TransformDirection(Vector3.up);
			return Vector3.Lerp(worldUp, ((Vector3)(ref val)).normalized, RelativeLookUpBias) * mulRange;
		}
		return WorldUp * mulRange;
	}

	internal void RotateBack(float speed = 5f)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (!(speed <= 0f))
		{
			helperRotation = Quaternion.Slerp(helperRotation, Quaternion.identity, deltaTime * speed);
		}
	}

	internal void RefreshLastRaycast()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		LastRaycast = CastRay();
		RaycastHit lastRaycast = LastRaycast;
		if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastRaycast)).transform))
		{
			LastTransformRaycast = LastRaycast;
		}
	}

	internal void BackRaycast()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		LastRaycast = LastTransformRaycast;
	}
}


using System;
using FIMSpace.GroundFitter;
using UnityEngine;

public abstract class FGroundFitter_Base_RootMotion : FGroundFitter_Base
{
	[HideInInspector]
	[Tooltip("Making ground fitter translate with root motion")]
	public bool HandleRootMotion;

	[SerializeField]
	[HideInInspector]
	protected Transform parentTransform;

	[SerializeField]
	[HideInInspector]
	protected CharacterController optionalCharContr;

	[HideInInspector]
	[SerializeField]
	protected bool rootMotionRotation = true;

	protected Animator rootMAnimator;

	protected override void Reset()
	{
		base.Reset();
		parentTransform = ((Component)this).transform;
	}

	protected override void Start()
	{
		base.Start();
	}

	protected virtual void HandleRootMotionSupport()
	{
		if (HandleRootMotion)
		{
			if (!Object.op_Implicit((Object)(object)rootMAnimator))
			{
				rootMAnimator = ((Component)this).GetComponentInChildren<Animator>();
			}
			if ((Object)(object)((Component)rootMAnimator).gameObject != (Object)(object)((Component)this).gameObject && !rootMAnimator.applyRootMotion && !Object.op_Implicit((Object)(object)((Component)rootMAnimator).GetComponent<FGroundFitter_RootMotionHelper>()))
			{
				((Component)rootMAnimator).gameObject.AddComponent<FGroundFitter_RootMotionHelper>().OptionalFitter = this;
			}
			rootMAnimator.applyRootMotion = true;
		}
	}

	internal virtual void OnAnimatorMove()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)rootMAnimator))
		{
			return;
		}
		if (Object.op_Implicit((Object)(object)optionalCharContr))
		{
			if (rootMAnimator.deltaPosition != Vector3.zero)
			{
				if ((Object)(object)TransformToRotate != (Object)(object)((Component)this).transform)
				{
					optionalCharContr.Move(TransformToRotate.rotation * rootMAnimator.deltaPosition);
				}
				else
				{
					optionalCharContr.Move(rootMAnimator.deltaPosition);
				}
			}
			rootMAnimator.rootPosition = TransformToRotate.position;
		}
		else if ((Object)(object)TransformToRotate != (Object)(object)((Component)this).transform)
		{
			Transform obj = parentTransform;
			obj.position += TransformToRotate.rotation * rootMAnimator.deltaPosition;
		}
		else
		{
			Transform obj2 = parentTransform;
			obj2.position += rootMAnimator.deltaPosition;
		}
		rootMAnimator.rootPosition = TransformToRotate.position;
		rootMAnimator.rootRotation = base.LastRotation;
		if (rootMotionRotation)
		{
			rootMAnimator.rootRotation = base.LastRotation;
			Quaternion deltaRotation = rootMAnimator.deltaRotation;
			float num = default(float);
			Vector3 val = default(Vector3);
			((Quaternion)(ref deltaRotation)).ToAngleAxis(ref num, ref val);
			float y = (val * num * (MathF.PI / 180f)).y;
			UpAxisRotation += y * 57.290154f;
		}
	}
}


using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_Input : FGroundFitter_InputBase
{
	protected virtual void Update()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		if (Input.GetKeyDown((KeyCode)32))
		{
			TriggerJump();
		}
		Vector3 zero = Vector3.zero;
		if (Input.GetKey((KeyCode)119) || Input.GetKey((KeyCode)97) || Input.GetKey((KeyCode)115) || Input.GetKey((KeyCode)100))
		{
			if (Input.GetKey((KeyCode)304))
			{
				base.Sprint = true;
			}
			else
			{
				base.Sprint = false;
			}
			if (Input.GetKey((KeyCode)119))
			{
				zero.z += 1f;
			}
			if (Input.GetKey((KeyCode)97))
			{
				zero.x -= 1f;
			}
			if (Input.GetKey((KeyCode)100))
			{
				zero.x += 1f;
			}
			if (Input.GetKey((KeyCode)115))
			{
				zero.z -= 1f;
			}
			((Vector3)(ref zero)).Normalize();
			Quaternion val = Quaternion.LookRotation(zero);
			base.RotationOffset = ((Quaternion)(ref val)).eulerAngles.y;
			base.MoveVector = Vector3.forward;
		}
		else
		{
			base.Sprint = false;
			base.MoveVector = Vector3.zero;
		}
		if (Input.GetKey((KeyCode)120))
		{
			base.MoveVector -= Vector3.forward;
		}
		if (Input.GetKey((KeyCode)113))
		{
			base.MoveVector += Vector3.left;
		}
		if (Input.GetKey((KeyCode)101))
		{
			base.MoveVector += Vector3.right;
		}
		Vector3 moveVector = base.MoveVector;
		((Vector3)(ref moveVector)).Normalize();
		controller.Sprint = base.Sprint;
		controller.MoveVector = base.MoveVector;
		controller.RotationOffset = base.RotationOffset;
	}
}


using FIMSpace.GroundFitter;
using UnityEngine;

[RequireComponent(typeof(FGroundFitter_Movement))]
public abstract class FGroundFitter_InputBase : MonoBehaviour
{
	protected FGroundFitter fitter;

	protected FGroundFitter_Movement controller;

	public float RotationOffset { get; protected set; }

	public bool Sprint { get; protected set; }

	public Vector3 MoveVector { get; protected set; }

	public virtual void Start()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		fitter = ((Component)this).GetComponent<FGroundFitter>();
		controller = ((Component)this).GetComponent<FGroundFitter_Movement>();
		RotationOffset = 0f;
		Sprint = false;
		MoveVector = Vector3.zero;
	}

	protected virtual void TriggerJump()
	{
		controller.Jump();
	}
}


using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_MovementLook : FGroundFitter_Movement
{
	[Header("Movement Look Options")]
	public Transform targetOfLook;

	[Range(0f, 1f)]
	public float FollowSpeed = 1f;

	public bool localOffset;

	private Vector3 targetPos;

	protected override void HandleTransforming()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		base.HandleTransforming();
		if (MoveVector != Vector3.zero)
		{
			SetLookAtPosition(((Component)this).transform.position + Quaternion.Euler(0f, ((Component)Camera.main).transform.eulerAngles.y + RotationOffset, 0f) * Vector3.forward * 10f);
		}
		if (Object.op_Implicit((Object)(object)targetOfLook))
		{
			Vector3 val = targetPos;
			if (localOffset)
			{
				val = ((Component)this).transform.TransformPoint(targetPos);
			}
			if (FollowSpeed >= 1f)
			{
				targetOfLook.position = val;
			}
			else
			{
				targetOfLook.position = Vector3.Lerp(targetOfLook.position, val, Mathf.Lerp(1f, 30f, FollowSpeed) * Time.deltaTime);
			}
		}
	}

	private void SetLookAtPosition(Vector3 tPos)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!localOffset)
		{
			targetPos = tPos + Vector3.up;
		}
		else
		{
			targetPos = ((Component)this).transform.InverseTransformPoint(tPos + Vector3.up);
		}
	}
}


using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_RootMotionHelper : MonoBehaviour
{
	public FGroundFitter_Movement MovementController;

	public FGroundFitter_Base_RootMotion OptionalFitter;

	private void OnAnimatorMove()
	{
		if (Object.op_Implicit((Object)(object)MovementController))
		{
			MovementController.OnAnimatorMove();
		}
		else if (Object.op_Implicit((Object)(object)OptionalFitter))
		{
			OptionalFitter.OnAnimatorMove();
		}
		else
		{
			Object.Destroy((Object)(object)this);
		}
	}
}


using System;
using AmplifyOcclusion;
using UnityEngine;

[Serializable]
public class VersionInfo
{
	public const byte Major = 2;

	public const byte Minor = 0;

	public const byte Release = 0;

	private static string StageSuffix = "_dev002";

	[SerializeField]
	private int m_major;

	[SerializeField]
	private int m_minor;

	[SerializeField]
	private int m_release;

	public int Number => m_major * 100 + m_minor * 10 + m_release;

	public static string StaticToString()
	{
		return $"{(byte)2}.{(byte)0}.{(byte)0}" + StageSuffix;
	}

	public override string ToString()
	{
		return $"{m_major}.{m_minor}.{m_release}" + StageSuffix;
	}

	private VersionInfo()
	{
		m_major = 2;
		m_minor = 0;
		m_release = 0;
	}

	private VersionInfo(byte major, byte minor, byte release)
	{
		m_major = major;
		m_minor = minor;
		m_release = release;
	}

	public static VersionInfo Current()
	{
		return new VersionInfo(2, 0, 0);
	}

	public static bool Matches(VersionInfo version)
	{
		if (2 == version.m_major && version.m_minor == 0)
		{
			return version.m_release == 0;
		}
		return false;
	}
}


using System;
using System.IO;
using System.Text;
using TinyJSON;

public sealed class Decoder : IDisposable
{
	private enum Token
	{
		None,
		OpenBrace,
		CloseBrace,
		OpenBracket,
		CloseBracket,
		Colon,
		Comma,
		String,
		Number,
		True,
		False,
		Null
	}

	private const string whiteSpace = " \t\n\r";

	private const string wordBreak = " \t\n\r{}[],:\"";

	private StringReader json;

	private char PeekChar
	{
		get
		{
			int num = json.Peek();
			if (num != -1)
			{
				return Convert.ToChar(num);
			}
			return '\0';
		}
	}

	private char NextChar => Convert.ToChar(json.Read());

	private string NextWord
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			while (" \t\n\r{}[],:\"".IndexOf(PeekChar) == -1)
			{
				stringBuilder.Append(NextChar);
				if (json.Peek() == -1)
				{
					break;
				}
			}
			return stringBuilder.ToString();
		}
	}

	private Token NextToken
	{
		get
		{
			ConsumeWhiteSpace();
			if (json.Peek() == -1)
			{
				return Token.None;
			}
			switch (PeekChar)
			{
			case '{':
				return Token.OpenBrace;
			case '}':
				json.Read();
				return Token.CloseBrace;
			case '[':
				return Token.OpenBracket;
			case ']':
				json.Read();
				return Token.CloseBracket;
			case ',':
				json.Read();
				return Token.Comma;
			case '"':
				return Token.String;
			case ':':
				return Token.Colon;
			case '-':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				return Token.Number;
			default:
				return NextWord switch
				{
					"false" => Token.False, 
					"true" => Token.True, 
					"null" => Token.Null, 
					_ => Token.None, 
				};
			}
		}
	}

	private Decoder(string jsonString)
	{
		json = new StringReader(jsonString);
	}

	public static Variant Decode(string jsonString)
	{
		using TinyJSON.Decoder decoder = new TinyJSON.Decoder(jsonString);
		return decoder.DecodeValue();
	}

	public void Dispose()
	{
		json.Dispose();
		json = null;
	}

	private ProxyObject DecodeObject()
	{
		ProxyObject proxyObject = new ProxyObject();
		json.Read();
		while (true)
		{
			switch (NextToken)
			{
			case Token.Comma:
				continue;
			case Token.None:
				return null;
			case Token.CloseBrace:
				return proxyObject;
			}
			string text = DecodeString();
			if (text == null)
			{
				return null;
			}
			if (NextToken != Token.Colon)
			{
				return null;
			}
			json.Read();
			proxyObject.Add(text, DecodeValue());
		}
	}

	private ProxyArray DecodeArray()
	{
		ProxyArray proxyArray = new ProxyArray();
		json.Read();
		bool flag = true;
		while (flag)
		{
			Token nextToken = NextToken;
			switch (nextToken)
			{
			case Token.None:
				return null;
			case Token.CloseBracket:
				flag = false;
				break;
			default:
				proxyArray.Add(DecodeByToken(nextToken));
				break;
			case Token.Comma:
				break;
			}
		}
		return proxyArray;
	}

	private Variant DecodeValue()
	{
		Token nextToken = NextToken;
		return DecodeByToken(nextToken);
	}

	private Variant DecodeByToken(Token token)
	{
		return token switch
		{
			Token.String => DecodeString(), 
			Token.Number => DecodeNumber(), 
			Token.OpenBrace => DecodeObject(), 
			Token.OpenBracket => DecodeArray(), 
			Token.True => new ProxyBoolean(value: true), 
			Token.False => new ProxyBoolean(value: false), 
			Token.Null => null, 
			_ => null, 
		};
	}

	private Variant DecodeString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		json.Read();
		bool flag = true;
		while (flag)
		{
			if (json.Peek() == -1)
			{
				flag = false;
				break;
			}
			char nextChar = NextChar;
			switch (nextChar)
			{
			case '"':
				flag = false;
				break;
			case '\\':
				if (json.Peek() == -1)
				{
					flag = false;
					break;
				}
				nextChar = NextChar;
				switch (nextChar)
				{
				case '"':
				case '/':
				case '\\':
					stringBuilder.Append(nextChar);
					break;
				case 'b':
					stringBuilder.Append('\b');
					break;
				case 'f':
					stringBuilder.Append('\f');
					break;
				case 'n':
					stringBuilder.Append('\n');
					break;
				case 'r':
					stringBuilder.Append('\r');
					break;
				case 't':
					stringBuilder.Append('\t');
					break;
				case 'u':
				{
					StringBuilder stringBuilder2 = new StringBuilder();
					for (int i = 0; i < 4; i++)
					{
						stringBuilder2.Append(NextChar);
					}
					stringBuilder.Append((char)Convert.ToInt32(stringBuilder2.ToString(), 16));
					break;
				}
				}
				break;
			default:
				stringBuilder.Append(nextChar);
				break;
			}
		}
		return new ProxyString(stringBuilder.ToString());
	}

	private Variant DecodeNumber()
	{
		return new ProxyNumber(NextWord);
	}

	private void ConsumeWhiteSpace()
	{
		while (" \t\n\r".IndexOf(PeekChar) != -1)
		{
			json.Read();
			if (json.Peek() == -1)
			{
				break;
			}
		}
	}
}


private enum Token
{
	None,
	OpenBrace,
	CloseBrace,
	OpenBracket,
	CloseBracket,
	Colon,
	Comma,
	String,
	Number,
	True,
	False,
	Null
}


using System;

[Flags]
public enum EncodeOptions
{
	None = 0,
	PrettyPrint = 1,
	NoTypeHints = 2,
	IncludePublicProperties = 4,
	EnforceHierarchyOrder = 8,
	[Obsolete("Use EncodeOptions.EnforceHierarchyOrder instead.")]
	EnforceHeirarchyOrder = 8
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Text;
using TinyJSON;

public sealed class Encoder
{
	private static readonly Type includeAttrType = typeof(Include);

	private static readonly Type excludeAttrType = typeof(Exclude);

	private static readonly Type typeHintAttrType = typeof(TypeHint);

	private readonly StringBuilder builder;

	private readonly EncodeOptions options;

	private int indent;

	private bool PrettyPrintEnabled => (options & EncodeOptions.PrettyPrint) == EncodeOptions.PrettyPrint;

	private bool TypeHintsEnabled => (options & EncodeOptions.NoTypeHints) != EncodeOptions.NoTypeHints;

	private bool IncludePublicPropertiesEnabled => (options & EncodeOptions.IncludePublicProperties) == EncodeOptions.IncludePublicProperties;

	private bool EnforceHierarchyOrderEnabled => (options & EncodeOptions.EnforceHierarchyOrder) == EncodeOptions.EnforceHierarchyOrder;

	private Encoder(EncodeOptions options)
	{
		this.options = options;
		builder = new StringBuilder();
		indent = 0;
	}

	public static string Encode(object obj)
	{
		return Encode(obj, EncodeOptions.None);
	}

	public static string Encode(object obj, EncodeOptions options)
	{
		TinyJSON.Encoder encoder = new TinyJSON.Encoder(options);
		encoder.EncodeValue(obj, forceTypeHint: false);
		return encoder.builder.ToString();
	}

	private void EncodeValue(object value, bool forceTypeHint)
	{
		if (value == null)
		{
			builder.Append("null");
		}
		else if (value is string)
		{
			EncodeString((string)value);
		}
		else if (value is ProxyString)
		{
			EncodeString(((ProxyString)value).ToString(CultureInfo.InvariantCulture));
		}
		else if (value is char)
		{
			EncodeString(value.ToString());
		}
		else if (value is bool)
		{
			builder.Append(((bool)value) ? "true" : "false");
		}
		else if (value is Enum)
		{
			EncodeString(value.ToString());
		}
		else if (value is Array)
		{
			EncodeArray((Array)value, forceTypeHint);
		}
		else if (value is IList)
		{
			EncodeList((IList)value, forceTypeHint);
		}
		else if (value is IDictionary)
		{
			EncodeDictionary((IDictionary)value, forceTypeHint);
		}
		else if (value is Guid)
		{
			EncodeString(value.ToString());
		}
		else if (value is ProxyArray)
		{
			EncodeProxyArray((ProxyArray)value);
		}
		else if (value is ProxyObject)
		{
			EncodeProxyObject((ProxyObject)value);
		}
		else if (value is float || value is double || value is int || value is uint || value is long || value is sbyte || value is byte || value is short || value is ushort || value is ulong || value is decimal || value is ProxyBoolean || value is ProxyNumber)
		{
			builder.Append(Convert.ToString(value, CultureInfo.InvariantCulture));
		}
		else
		{
			EncodeObject(value, forceTypeHint);
		}
	}

	private IEnumerable<FieldInfo> GetFieldsForType(Type type)
	{
		if (EnforceHierarchyOrderEnabled)
		{
			Stack<Type> stack = new Stack<Type>();
			while (type != null)
			{
				stack.Push(type);
				type = type.BaseType;
			}
			List<FieldInfo> list = new List<FieldInfo>();
			while (stack.Count > 0)
			{
				list.AddRange(stack.Pop().GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
			}
			return list;
		}
		return type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
	}

	private IEnumerable<PropertyInfo> GetPropertiesForType(Type type)
	{
		if (EnforceHierarchyOrderEnabled)
		{
			Stack<Type> stack = new Stack<Type>();
			while (type != null)
			{
				stack.Push(type);
				type = type.BaseType;
			}
			List<PropertyInfo> list = new List<PropertyInfo>();
			while (stack.Count > 0)
			{
				list.AddRange(stack.Pop().GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
			}
			return list;
		}
		return type.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
	}

	private void EncodeObject(object value, bool forceTypeHint)
	{
		Type type = value.GetType();
		AppendOpenBrace();
		forceTypeHint = forceTypeHint || TypeHintsEnabled;
		bool includePublicPropertiesEnabled = IncludePublicPropertiesEnabled;
		bool firstItem = !forceTypeHint;
		if (forceTypeHint)
		{
			if (PrettyPrintEnabled)
			{
				AppendIndent();
			}
			EncodeString("@type");
			AppendColon();
			EncodeString(type.FullName);
			firstItem = false;
		}
		foreach (FieldInfo item in GetFieldsForType(type))
		{
			bool forceTypeHint2 = false;
			bool flag = item.IsPublic;
			object[] customAttributes = item.GetCustomAttributes(inherit: true);
			foreach (object o in customAttributes)
			{
				if (excludeAttrType.IsInstanceOfType(o))
				{
					flag = false;
				}
				if (includeAttrType.IsInstanceOfType(o))
				{
					flag = true;
				}
				if (typeHintAttrType.IsInstanceOfType(o))
				{
					forceTypeHint2 = true;
				}
			}
			if (flag)
			{
				AppendComma(firstItem);
				EncodeString(item.Name);
				AppendColon();
				EncodeValue(item.GetValue(value), forceTypeHint2);
				firstItem = false;
			}
		}
		foreach (PropertyInfo item2 in GetPropertiesForType(type))
		{
			if (!item2.CanRead)
			{
				continue;
			}
			bool forceTypeHint3 = false;
			bool flag2 = includePublicPropertiesEnabled;
			object[] customAttributes = item2.GetCustomAttributes(inherit: true);
			foreach (object o2 in customAttributes)
			{
				if (excludeAttrType.IsInstanceOfType(o2))
				{
					flag2 = false;
				}
				if (includeAttrType.IsInstanceOfType(o2))
				{
					flag2 = true;
				}
				if (typeHintAttrType.IsInstanceOfType(o2))
				{
					forceTypeHint3 = true;
				}
			}
			if (flag2)
			{
				AppendComma(firstItem);
				EncodeString(item2.Name);
				AppendColon();
				EncodeValue(item2.GetValue(value, null), forceTypeHint3);
				firstItem = false;
			}
		}
		AppendCloseBrace();
	}

	private void EncodeProxyArray(ProxyArray value)
	{
		if (value.Count == 0)
		{
			builder.Append("[]");
			return;
		}
		AppendOpenBracket();
		bool firstItem = true;
		foreach (Variant item in (IEnumerable<Variant>)value)
		{
			AppendComma(firstItem);
			EncodeValue(item, forceTypeHint: false);
			firstItem = false;
		}
		AppendCloseBracket();
	}

	private void EncodeProxyObject(ProxyObject value)
	{
		if (value.Count == 0)
		{
			builder.Append("{}");
			return;
		}
		AppendOpenBrace();
		bool firstItem = true;
		foreach (string key in value.Keys)
		{
			AppendComma(firstItem);
			EncodeString(key);
			AppendColon();
			EncodeValue(value[key], forceTypeHint: false);
			firstItem = false;
		}
		AppendCloseBrace();
	}

	private void EncodeDictionary(IDictionary value, bool forceTypeHint)
	{
		if (value.Count == 0)
		{
			builder.Append("{}");
			return;
		}
		AppendOpenBrace();
		bool firstItem = true;
		foreach (object key in value.Keys)
		{
			AppendComma(firstItem);
			EncodeString(key.ToString());
			AppendColon();
			EncodeValue(value[key], forceTypeHint);
			firstItem = false;
		}
		AppendCloseBrace();
	}

	private void EncodeList(IList value, bool forceTypeHint)
	{
		if (value.Count == 0)
		{
			builder.Append("[]");
			return;
		}
		AppendOpenBracket();
		bool firstItem = true;
		foreach (object item in value)
		{
			AppendComma(firstItem);
			EncodeValue(item, forceTypeHint);
			firstItem = false;
		}
		AppendCloseBracket();
	}

	private void EncodeArray(Array value, bool forceTypeHint)
	{
		if (value.Rank == 1)
		{
			EncodeList(value, forceTypeHint);
			return;
		}
		int[] indices = new int[value.Rank];
		EncodeArrayRank(value, 0, indices, forceTypeHint);
	}

	private void EncodeArrayRank(Array value, int rank, int[] indices, bool forceTypeHint)
	{
		AppendOpenBracket();
		int lowerBound = value.GetLowerBound(rank);
		int upperBound = value.GetUpperBound(rank);
		if (rank == value.Rank - 1)
		{
			for (int i = lowerBound; i <= upperBound; i++)
			{
				indices[rank] = i;
				AppendComma(i == lowerBound);
				EncodeValue(value.GetValue(indices), forceTypeHint);
			}
		}
		else
		{
			for (int j = lowerBound; j <= upperBound; j++)
			{
				indices[rank] = j;
				AppendComma(j == lowerBound);
				EncodeArrayRank(value, rank + 1, indices, forceTypeHint);
			}
		}
		AppendCloseBracket();
	}

	private void EncodeString(string value)
	{
		builder.Append('"');
		char[] array = value.ToCharArray();
		foreach (char c in array)
		{
			switch (c)
			{
			case '"':
				builder.Append("\\\"");
				continue;
			case '\\':
				builder.Append("\\\\");
				continue;
			case '\b':
				builder.Append("\\b");
				continue;
			case '\f':
				builder.Append("\\f");
				continue;
			case '\n':
				builder.Append("\\n");
				continue;
			case '\r':
				builder.Append("\\r");
				continue;
			case '\t':
				builder.Append("\\t");
				continue;
			}
			int num = Convert.ToInt32(c);
			if (num >= 32 && num <= 126)
			{
				builder.Append(c);
			}
			else
			{
				builder.Append("\\u" + Convert.ToString(num, 16).PadLeft(4, '0'));
			}
		}
		builder.Append('"');
	}

	private void AppendIndent()
	{
		for (int i = 0; i < indent; i++)
		{
			builder.Append('\t');
		}
	}

	private void AppendOpenBrace()
	{
		builder.Append('{');
		if (PrettyPrintEnabled)
		{
			builder.Append('\n');
			indent++;
		}
	}

	private void AppendCloseBrace()
	{
		if (PrettyPrintEnabled)
		{
			builder.Append('\n');
			indent--;
			AppendIndent();
		}
		builder.Append('}');
	}

	private void AppendOpenBracket()
	{
		builder.Append('[');
		if (PrettyPrintEnabled)
		{
			builder.Append('\n');
			indent++;
		}
	}

	private void AppendCloseBracket()
	{
		if (PrettyPrintEnabled)
		{
			builder.Append('\n');
			indent--;
			AppendIndent();
		}
		builder.Append(']');
	}

	private void AppendComma(bool firstItem)
	{
		if (!firstItem)
		{
			builder.Append(',');
			if (PrettyPrintEnabled)
			{
				builder.Append('\n');
			}
		}
		if (PrettyPrintEnabled)
		{
			AppendIndent();
		}
	}

	private void AppendColon()
	{
		builder.Append(':');
		if (PrettyPrintEnabled)
		{
			builder.Append(' ');
		}
	}
}


using System;
using System.Collections.Generic;

public static class Extensions
{
	public static bool AnyOfType<TSource>(this IEnumerable<TSource> source, Type expectedType)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		if (expectedType == null)
		{
			throw new ArgumentNullException("expectedType");
		}
		foreach (TSource item in source)
		{
			if (expectedType.IsInstanceOfType(item))
			{
				return true;
			}
		}
		return false;
	}
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public sealed class Include : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public class Exclude : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class AfterDecode : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class BeforeEncode : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public class TypeHint : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true)]
public class DecodeAlias : Attribute
{
	public string[] Names { get; private set; }

	public DecodeAlias(params string[] names)
	{
		Names = names;
	}

	public bool Contains(string name)
	{
		return Array.IndexOf(Names, name) > -1;
	}
}


using System;
using TinyJSON;

[Obsolete("Use the Exclude attribute instead.")]
public sealed class Skip : Exclude
{
}


using System;
using TinyJSON;

[Obsolete("Use the AfterDecode attribute instead.")]
public sealed class Load : AfterDecode
{
}


using System;

public sealed class DecodeException : Exception
{
	public DecodeException(string message)
		: base(message)
	{
	}

	public DecodeException(string message, Exception innerException)
		: base(message, innerException)
	{
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using TinyJSON;

public static class JSON
{
	private static readonly Type includeAttrType = typeof(Include);

	private static readonly Type excludeAttrType = typeof(Exclude);

	private static readonly Type decodeAliasAttrType = typeof(DecodeAlias);

	private static readonly Dictionary<string, Type> typeCache = new Dictionary<string, Type>();

	private const BindingFlags instanceBindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;

	private const BindingFlags staticBindingFlags = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;

	private static readonly MethodInfo decodeTypeMethod = typeof(JSON).GetMethod("DecodeType", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

	private static readonly MethodInfo decodeListMethod = typeof(JSON).GetMethod("DecodeList", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

	private static readonly MethodInfo decodeDictionaryMethod = typeof(JSON).GetMethod("DecodeDictionary", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

	private static readonly MethodInfo decodeArrayMethod = typeof(JSON).GetMethod("DecodeArray", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

	private static readonly MethodInfo decodeMultiRankArrayMethod = typeof(JSON).GetMethod("DecodeMultiRankArray", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

	public static Variant Load(string json)
	{
		if (json == null)
		{
			throw new ArgumentNullException("json");
		}
		return Decoder.Decode(json);
	}

	public static string Dump(object data)
	{
		return Dump(data, EncodeOptions.None);
	}

	public static string Dump(object data, EncodeOptions options)
	{
		if (data != null)
		{
			Type type = data.GetType();
			if (!type.IsEnum && !type.IsPrimitive && !type.IsArray)
			{
				MethodInfo[] methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (MethodInfo methodInfo in methods)
				{
					if (methodInfo.GetCustomAttributes(inherit: false).AnyOfType(typeof(BeforeEncode)) && methodInfo.GetParameters().Length == 0)
					{
						methodInfo.Invoke(data, null);
					}
				}
			}
		}
		return Encoder.Encode(data, options);
	}

	public static void MakeInto<T>(Variant data, out T item)
	{
		item = DecodeType<T>(data);
	}

	private static Type FindType(string fullName)
	{
		if (fullName == null)
		{
			return null;
		}
		if (typeCache.TryGetValue(fullName, out var value))
		{
			return value;
		}
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
		for (int i = 0; i < assemblies.Length; i++)
		{
			value = assemblies[i].GetType(fullName);
			if (value != null)
			{
				typeCache.Add(fullName, value);
				return value;
			}
		}
		return null;
	}

	private static T DecodeType<T>(Variant data)
	{
		if (data == null)
		{
			return default(T);
		}
		Type type = typeof(T);
		if (type.IsEnum)
		{
			return (T)Enum.Parse(type, data.ToString(CultureInfo.InvariantCulture));
		}
		if (type.IsPrimitive || type == typeof(string) || type == typeof(decimal))
		{
			return (T)Convert.ChangeType(data, type);
		}
		if (type == typeof(Guid))
		{
			return (T)(object)new Guid(data.ToString(CultureInfo.InvariantCulture));
		}
		if (type.IsArray)
		{
			if (type.GetArrayRank() == 1)
			{
				return (T)decodeArrayMethod.MakeGenericMethod(type.GetElementType()).Invoke(null, new object[1] { data });
			}
			if (!(data is ProxyArray proxyArray))
			{
				throw new DecodeException("Variant is expected to be a ProxyArray here, but it is not.");
			}
			int[] array = new int[type.GetArrayRank()];
			if (proxyArray.CanBeMultiRankArray(array))
			{
				Type elementType = type.GetElementType();
				if (elementType == null)
				{
					throw new DecodeException("Array element type is expected to be not null, but it is.");
				}
				Array array2 = Array.CreateInstance(elementType, array);
				MethodInfo methodInfo = decodeMultiRankArrayMethod.MakeGenericMethod(elementType);
				try
				{
					methodInfo.Invoke(null, new object[4] { proxyArray, array2, 1, array });
				}
				catch (Exception innerException)
				{
					throw new DecodeException("Error decoding multidimensional array. Did you try to decode into an array of incompatible rank or element type?", innerException);
				}
				return (T)Convert.ChangeType(array2, typeof(T));
			}
			throw new DecodeException("Error decoding multidimensional array; JSON data doesn't seem fit this structure.");
		}
		if (typeof(IList).IsAssignableFrom(type))
		{
			return (T)decodeListMethod.MakeGenericMethod(type.GetGenericArguments()).Invoke(null, new object[1] { data });
		}
		if (typeof(IDictionary).IsAssignableFrom(type))
		{
			return (T)decodeDictionaryMethod.MakeGenericMethod(type.GetGenericArguments()).Invoke(null, new object[1] { data });
		}
		string typeHint = ((data as ProxyObject) ?? throw new InvalidCastException("ProxyObject expected when decoding into '" + type.FullName + "'.")).TypeHint;
		T val;
		if (typeHint != null && typeHint != type.FullName)
		{
			Type type2 = FindType(typeHint);
			if (type2 == null)
			{
				throw new TypeLoadException("Could not load type '" + typeHint + "'.");
			}
			if (!type.IsAssignableFrom(type2))
			{
				throw new InvalidCastException("Cannot assign type '" + typeHint + "' to type '" + type.FullName + "'.");
			}
			val = (T)Activator.CreateInstance(type2);
			type = type2;
		}
		else
		{
			val = Activator.CreateInstance<T>();
		}
		foreach (KeyValuePair<string, Variant> item in (IEnumerable<KeyValuePair<string, Variant>>)(ProxyObject)data)
		{
			FieldInfo fieldInfo = type.GetField(item.Key, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			if (fieldInfo == null)
			{
				FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (FieldInfo fieldInfo2 in fields)
				{
					object[] customAttributes = fieldInfo2.GetCustomAttributes(inherit: true);
					foreach (object obj in customAttributes)
					{
						if (decodeAliasAttrType.IsInstanceOfType(obj) && ((DecodeAlias)obj).Contains(item.Key))
						{
							fieldInfo = fieldInfo2;
							break;
						}
					}
				}
			}
			if (fieldInfo != null)
			{
				bool flag = fieldInfo.IsPublic;
				object[] customAttributes = fieldInfo.GetCustomAttributes(inherit: true);
				foreach (object o in customAttributes)
				{
					if (excludeAttrType.IsInstanceOfType(o))
					{
						flag = false;
					}
					if (includeAttrType.IsInstanceOfType(o))
					{
						flag = true;
					}
				}
				if (flag)
				{
					MethodInfo methodInfo2 = decodeTypeMethod.MakeGenericMethod(fieldInfo.FieldType);
					if (type.IsValueType)
					{
						object obj2 = val;
						fieldInfo.SetValue(obj2, methodInfo2.Invoke(null, new object[1] { item.Value }));
						val = (T)obj2;
					}
					else
					{
						fieldInfo.SetValue(val, methodInfo2.Invoke(null, new object[1] { item.Value }));
					}
				}
			}
			PropertyInfo propertyInfo = type.GetProperty(item.Key, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			if (propertyInfo == null)
			{
				PropertyInfo[] properties = type.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (PropertyInfo propertyInfo2 in properties)
				{
					object[] customAttributes = propertyInfo2.GetCustomAttributes(inherit: false);
					foreach (object obj3 in customAttributes)
					{
						if (decodeAliasAttrType.IsInstanceOfType(obj3) && ((DecodeAlias)obj3).Contains(item.Key))
						{
							propertyInfo = propertyInfo2;
							break;
						}
					}
				}
			}
			if (propertyInfo != null && propertyInfo.CanWrite && propertyInfo.GetCustomAttributes(inherit: false).AnyOfType(includeAttrType))
			{
				MethodInfo methodInfo3 = decodeTypeMethod.MakeGenericMethod(propertyInfo.PropertyType);
				if (type.IsValueType)
				{
					object obj4 = val;
					propertyInfo.SetValue(obj4, methodInfo3.Invoke(null, new object[1] { item.Value }), null);
					val = (T)obj4;
				}
				else
				{
					propertyInfo.SetValue(val, methodInfo3.Invoke(null, new object[1] { item.Value }), null);
				}
			}
		}
		MethodInfo[] methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		foreach (MethodInfo methodInfo4 in methods)
		{
			if (methodInfo4.GetCustomAttributes(inherit: false).AnyOfType(typeof(AfterDecode)))
			{
				methodInfo4.Invoke(val, (methodInfo4.GetParameters().Length == 0) ? null : new object[1] { data });
			}
		}
		return val;
	}

	private static List<T> DecodeList<T>(Variant data)
	{
		List<T> list = new List<T>();
		foreach (Variant item in (IEnumerable<Variant>)((data as ProxyArray) ?? throw new DecodeException("Variant is expected to be a ProxyArray here, but it is not.")))
		{
			list.Add(DecodeType<T>(item));
		}
		return list;
	}

	private static Dictionary<TKey, TValue> DecodeDictionary<TKey, TValue>(Variant data)
	{
		Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>();
		Type typeFromHandle = typeof(TKey);
		foreach (KeyValuePair<string, Variant> item in (IEnumerable<KeyValuePair<string, Variant>>)((data as ProxyObject) ?? throw new DecodeException("Variant is expected to be a ProxyObject here, but it is not.")))
		{
			TKey key = (TKey)(typeFromHandle.IsEnum ? Enum.Parse(typeFromHandle, item.Key) : Convert.ChangeType(item.Key, typeFromHandle));
			TValue value = DecodeType<TValue>(item.Value);
			dictionary.Add(key, value);
		}
		return dictionary;
	}

	private static T[] DecodeArray<T>(Variant data)
	{
		ProxyArray obj = (data as ProxyArray) ?? throw new DecodeException("Variant is expected to be a ProxyArray here, but it is not.");
		T[] array = new T[obj.Count];
		int num = 0;
		foreach (Variant item in (IEnumerable<Variant>)obj)
		{
			array[num++] = DecodeType<T>(item);
		}
		return array;
	}

	private static void DecodeMultiRankArray<T>(ProxyArray arrayData, Array array, int arrayRank, int[] indices)
	{
		int count = arrayData.Count;
		for (int i = 0; i < count; i++)
		{
			indices[arrayRank - 1] = i;
			if (arrayRank < array.Rank)
			{
				DecodeMultiRankArray<T>(arrayData[i] as ProxyArray, array, arrayRank + 1, indices);
			}
			else
			{
				array.SetValue(DecodeType<T>(arrayData[i]), indices);
			}
		}
	}

	public static void SupportTypeForAOT<T>()
	{
		DecodeType<T>(null);
		DecodeList<T>(null);
		DecodeArray<T>(null);
		DecodeDictionary<short, T>(null);
		DecodeDictionary<ushort, T>(null);
		DecodeDictionary<int, T>(null);
		DecodeDictionary<uint, T>(null);
		DecodeDictionary<long, T>(null);
		DecodeDictionary<ulong, T>(null);
		DecodeDictionary<float, T>(null);
		DecodeDictionary<double, T>(null);
		DecodeDictionary<decimal, T>(null);
		DecodeDictionary<bool, T>(null);
		DecodeDictionary<string, T>(null);
	}

	private static void SupportValueTypesForAOT()
	{
		SupportTypeForAOT<short>();
		SupportTypeForAOT<ushort>();
		SupportTypeForAOT<int>();
		SupportTypeForAOT<uint>();
		SupportTypeForAOT<long>();
		SupportTypeForAOT<ulong>();
		SupportTypeForAOT<float>();
		SupportTypeForAOT<double>();
		SupportTypeForAOT<decimal>();
		SupportTypeForAOT<bool>();
		SupportTypeForAOT<string>();
	}
}


using System.Collections;
using System.Collections.Generic;
using TinyJSON;

public sealed class ProxyArray : Variant, IEnumerable<Variant>, IEnumerable
{
	private readonly List<Variant> list;

	public override Variant this[int index]
	{
		get
		{
			return list[index];
		}
		set
		{
			list[index] = value;
		}
	}

	public int Count => list.Count;

	public ProxyArray()
	{
		list = new List<Variant>();
	}

	IEnumerator<Variant> IEnumerable<Variant>.GetEnumerator()
	{
		return list.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return list.GetEnumerator();
	}

	public void Add(Variant item)
	{
		list.Add(item);
	}

	internal bool CanBeMultiRankArray(int[] rankLengths)
	{
		return CanBeMultiRankArray(0, rankLengths);
	}

	private bool CanBeMultiRankArray(int rank, int[] rankLengths)
	{
		int num = (rankLengths[rank] = list.Count);
		if (rank == rankLengths.Length - 1)
		{
			return true;
		}
		if (!(list[0] is ProxyArray { Count: var count }))
		{
			return false;
		}
		for (int i = 1; i < num; i++)
		{
			if (!(list[i] is ProxyArray proxyArray2))
			{
				return false;
			}
			if (proxyArray2.Count != count)
			{
				return false;
			}
			if (!proxyArray2.CanBeMultiRankArray(rank + 1, rankLengths))
			{
				return false;
			}
		}
		return true;
	}
}


using System;
using TinyJSON;

public sealed class ProxyBoolean : Variant
{
	private readonly bool value;

	public ProxyBoolean(bool value)
	{
		this.value = value;
	}

	public override bool ToBoolean(IFormatProvider provider)
	{
		return value;
	}

	public override string ToString(IFormatProvider provider)
	{
		if (!value)
		{
			return "false";
		}
		return "true";
	}
}


using System;
using System.Globalization;
using TinyJSON;

public sealed class ProxyNumber : Variant
{
	private static readonly char[] floatingPointCharacters = new char[2] { '.', 'e' };

	private readonly IConvertible value;

	public ProxyNumber(IConvertible value)
	{
		string text = value as string;
		this.value = ((text != null) ? Parse(text) : value);
	}

	private static IConvertible Parse(string value)
	{
		if (value.IndexOfAny(floatingPointCharacters) == -1)
		{
			ulong result2;
			if (value[0] == '-')
			{
				if (long.TryParse(value, NumberStyles.Float, NumberFormatInfo.InvariantInfo, out var result))
				{
					return result;
				}
			}
			else if (ulong.TryParse(value, NumberStyles.Float, NumberFormatInfo.InvariantInfo, out result2))
			{
				return result2;
			}
		}
		if (decimal.TryParse(value, NumberStyles.Float, NumberFormatInfo.InvariantInfo, out var result3))
		{
			if (result3 == 0m && double.TryParse(value, NumberStyles.Float, NumberFormatInfo.InvariantInfo, out var result4) && Math.Abs(result4) > double.Epsilon)
			{
				return result4;
			}
			return result3;
		}
		if (double.TryParse(value, NumberStyles.Float, NumberFormatInfo.InvariantInfo, out var result5))
		{
			return result5;
		}
		return 0;
	}

	public override bool ToBoolean(IFormatProvider provider)
	{
		return value.ToBoolean(provider);
	}

	public override byte ToByte(IFormatProvider provider)
	{
		return value.ToByte(provider);
	}

	public override char ToChar(IFormatProvider provider)
	{
		return value.ToChar(provider);
	}

	public override decimal ToDecimal(IFormatProvider provider)
	{
		return value.ToDecimal(provider);
	}

	public override double ToDouble(IFormatProvider provider)
	{
		return value.ToDouble(provider);
	}

	public override short ToInt16(IFormatProvider provider)
	{
		return value.ToInt16(provider);
	}

	public override int ToInt32(IFormatProvider provider)
	{
		return value.ToInt32(provider);
	}

	public override long ToInt64(IFormatProvider provider)
	{
		return value.ToInt64(provider);
	}

	public override sbyte ToSByte(IFormatProvider provider)
	{
		return value.ToSByte(provider);
	}

	public override float ToSingle(IFormatProvider provider)
	{
		return value.ToSingle(provider);
	}

	public override string ToString(IFormatProvider provider)
	{
		return value.ToString(provider);
	}

	public override ushort ToUInt16(IFormatProvider provider)
	{
		return value.ToUInt16(provider);
	}

	public override uint ToUInt32(IFormatProvider provider)
	{
		return value.ToUInt32(provider);
	}

	public override ulong ToUInt64(IFormatProvider provider)
	{
		return value.ToUInt64(provider);
	}
}


using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using TinyJSON;

public sealed class ProxyObject : Variant, IEnumerable<KeyValuePair<string, Variant>>, IEnumerable
{
	public const string TypeHintKey = "@type";

	private readonly Dictionary<string, Variant> dict;

	public string TypeHint
	{
		get
		{
			if (TryGetValue("@type", out var item))
			{
				return item.ToString(CultureInfo.InvariantCulture);
			}
			return null;
		}
	}

	public override Variant this[string key]
	{
		get
		{
			return dict[key];
		}
		set
		{
			dict[key] = value;
		}
	}

	public int Count => dict.Count;

	public Dictionary<string, Variant>.KeyCollection Keys => dict.Keys;

	public Dictionary<string, Variant>.ValueCollection Values => dict.Values;

	public ProxyObject()
	{
		dict = new Dictionary<string, Variant>();
	}

	IEnumerator<KeyValuePair<string, Variant>> IEnumerable<KeyValuePair<string, Variant>>.GetEnumerator()
	{
		return dict.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return dict.GetEnumerator();
	}

	public void Add(string key, Variant item)
	{
		dict.Add(key, item);
	}

	public bool TryGetValue(string key, out Variant item)
	{
		return dict.TryGetValue(key, out item);
	}
}


using System;
using TinyJSON;

public sealed class ProxyString : Variant
{
	private readonly string value;

	public ProxyString(string value)
	{
		this.value = value;
	}

	public override string ToString(IFormatProvider provider)
	{
		return value;
	}
}


using System;
using System.Globalization;
using TinyJSON;

public abstract class Variant : IConvertible
{
	protected static readonly IFormatProvider FormatProvider = new NumberFormatInfo();

	public virtual Variant this[string key]
	{
		get
		{
			throw new NotSupportedException();
		}
		set
		{
			throw new NotSupportedException();
		}
	}

	public virtual Variant this[int index]
	{
		get
		{
			throw new NotSupportedException();
		}
		set
		{
			throw new NotSupportedException();
		}
	}

	public void Make<T>(out T item)
	{
		JSON.MakeInto<T>(this, out item);
	}

	public T Make<T>()
	{
		JSON.MakeInto<T>(this, out var item);
		return item;
	}

	public string ToJSON()
	{
		return JSON.Dump(this);
	}

	public virtual TypeCode GetTypeCode()
	{
		return TypeCode.Object;
	}

	public virtual object ToType(Type conversionType, IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to " + conversionType.Name);
	}

	public virtual DateTime ToDateTime(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to DateTime");
	}

	public virtual bool ToBoolean(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Boolean");
	}

	public virtual byte ToByte(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Byte");
	}

	public virtual char ToChar(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Char");
	}

	public virtual decimal ToDecimal(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Decimal");
	}

	public virtual double ToDouble(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Double");
	}

	public virtual short ToInt16(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Int16");
	}

	public virtual int ToInt32(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Int32");
	}

	public virtual long ToInt64(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Int64");
	}

	public virtual sbyte ToSByte(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to SByte");
	}

	public virtual float ToSingle(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Single");
	}

	public virtual string ToString(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to String");
	}

	public virtual ushort ToUInt16(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to UInt16");
	}

	public virtual uint ToUInt32(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to UInt32");
	}

	public virtual ulong ToUInt64(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to UInt64");
	}

	public override string ToString()
	{
		return ToString(FormatProvider);
	}

	public static implicit operator bool(Variant variant)
	{
		return variant.ToBoolean(FormatProvider);
	}

	public static implicit operator float(Variant variant)
	{
		return variant.ToSingle(FormatProvider);
	}

	public static implicit operator double(Variant variant)
	{
		return variant.ToDouble(FormatProvider);
	}

	public static implicit operator ushort(Variant variant)
	{
		return variant.ToUInt16(FormatProvider);
	}

	public static implicit operator short(Variant variant)
	{
		return variant.ToInt16(FormatProvider);
	}

	public static implicit operator uint(Variant variant)
	{
		return variant.ToUInt32(FormatProvider);
	}

	public static implicit operator int(Variant variant)
	{
		return variant.ToInt32(FormatProvider);
	}

	public static implicit operator ulong(Variant variant)
	{
		return variant.ToUInt64(FormatProvider);
	}

	public static implicit operator long(Variant variant)
	{
		return variant.ToInt64(FormatProvider);
	}

	public static implicit operator decimal(Variant variant)
	{
		return variant.ToDecimal(FormatProvider);
	}

	public static implicit operator string(Variant variant)
	{
		return variant.ToString(FormatProvider);
	}

	public static implicit operator Guid(Variant variant)
	{
		return new Guid(variant.ToString(FormatProvider));
	}
}


using UnityEngine;

public class TerrainFormer : MonoBehaviour
{
	private void Awake()
	{
		Object.Destroy((Object)(object)this);
	}
}


using UnityEngine;

public class TerrainSetNeighbours : MonoBehaviour
{
	[SerializeField]
	private Terrain leftTerrain;

	[SerializeField]
	private Terrain topTerrain;

	[SerializeField]
	private Terrain rightTerrain;

	[SerializeField]
	private Terrain bottomTerrain;

	private void Awake()
	{
		((Component)this).GetComponent<Terrain>().SetNeighbors(leftTerrain, topTerrain, rightTerrain, bottomTerrain);
		Object.Destroy((Object)(object)this);
	}

	public void SetNeighbours(Terrain leftTerrain, Terrain topTerrain, Terrain rightTerrain, Terrain bottomTerrain)
	{
		this.leftTerrain = leftTerrain;
		this.topTerrain = topTerrain;
		this.rightTerrain = rightTerrain;
		this.bottomTerrain = bottomTerrain;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct FillJob<T> : IJob where T : unmanaged
{
	[WriteOnly]
	public NativeArray<T> Values;

	[ReadOnly]
	public T Value;

	public void Execute()
	{
		for (int i = 0; i < Values.Length; i++)
		{
			Values[i] = Value;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct GenerateAscSeqListJob : IJob
{
	[WriteOnly]
	public NativeList<int> Values;

	[ReadOnly]
	public int Start;

	[ReadOnly]
	public int Step;

	[ReadOnly]
	public int Count;

	public void Execute()
	{
		int num = Start;
		for (int i = 0; i < Count; i++)
		{
			Values.AddNoResize(num);
			num += Step;
		}
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct InvertIndexListJob : IJob
{
	public NativeList<int> Indices;

	public NativeArray<bool> WorkBuffer;

	public void Execute()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < WorkBuffer.Length; i++)
		{
			WorkBuffer[i] = false;
		}
		Enumerator<int> enumerator = Indices.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				int current = enumerator.Current;
				WorkBuffer[current] = true;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Indices.Clear();
		for (int j = 0; j < WorkBuffer.Length; j++)
		{
			if (!WorkBuffer[j])
			{
				Indices.AddNoResize(j);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct GatherJob<T> : IJob where T : unmanaged
{
	[WriteOnly]
	public NativeArray<T> Results;

	[ReadOnly]
	public ReadOnly<T> Source;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		for (int i = 0; i < Indices.Length; i++)
		{
			Results[i] = Source[Indices[i]];
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class Brush
{
	public float spacing;

	public Vector2 brushSize;

	public Texture2D texture;

	public Color color;

	public bool erase;
}


public abstract class BaseTip
{
	public abstract bool ShouldShow { get; }

	public string Type => GetType().Name;

	public virtual bool CanShowInTutorial => false;

	protected bool PlayerIsInTutorial => false;

	public abstract Phrase GetPhrase();
}


using UnityEngine;

public class EnableCanvasOnClientConnect : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;

public class BanList<TKey>
{
	private readonly Dictionary<TKey, double> _bans;

	public BanList()
	{
		_bans = new Dictionary<TKey, double>();
	}

	public void Ban(TKey key, double timeInSeconds)
	{
		lock (_bans)
		{
			double num = TimeEx.realtimeSinceStartup + timeInSeconds;
			if (_bans.TryGetValue(key, out var value))
			{
				num = Math.Max(num, value);
			}
			_bans[key] = num;
		}
	}

	public bool IsBanned(TKey key)
	{
		lock (_bans)
		{
			if (!_bans.TryGetValue(key, out var value))
			{
				return false;
			}
			if (TimeEx.realtimeSinceStartup < value)
			{
				return true;
			}
			_bans.Remove(key);
			return false;
		}
	}

	public void Cleanup()
	{
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		List<TKey> list = Pool.Get<List<TKey>>();
		lock (_bans)
		{
			foreach (KeyValuePair<TKey, double> ban in _bans)
			{
				if (realtimeSinceStartup >= ban.Value)
				{
					list.Add(ban.Key);
				}
			}
			foreach (TKey item in list)
			{
				_bans.Remove(item);
			}
		}
		Pool.FreeUnmanaged<TKey>(ref list);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using CompanionServer;
using CompanionServer.Cameras;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;

public class CameraRendererManager : SingletonComponent<CameraRendererManager>
{
	private readonly Stack<CameraRenderTask> _taskPool = new Stack<CameraRenderTask>();

	private int _tasksTaken;

	private int _tasksReturned;

	private int _tasksCreated;

	private readonly Stopwatch _stopwatch = new Stopwatch();

	private readonly List<CameraRenderer> _renderers = new List<CameraRenderer>();

	private int _renderIndex;

	private int _completeIndex;

	protected override void OnDestroy()
	{
		((SingletonComponent)this).OnDestroy();
		foreach (CameraRenderer renderer in _renderers)
		{
			renderer.Reset();
		}
		_renderers.Clear();
		CameraRenderTask.FreeCachedSamplePositions();
		while (_taskPool.Count > 0)
		{
			_taskPool.Pop().Dispose();
		}
	}

	public void StartRendering(IRemoteControllable rc)
	{
		if (rc == null || rc.IsUnityNull())
		{
			throw new ArgumentNullException("rc");
		}
		if (List.FindWith<CameraRenderer, IRemoteControllable>((IReadOnlyCollection<CameraRenderer>)_renderers, (Func<CameraRenderer, IRemoteControllable>)((CameraRenderer r) => r.rc), rc, (IEqualityComparer<IRemoteControllable>)null) == null)
		{
			CameraRenderer cameraRenderer = Pool.Get<CameraRenderer>();
			_renderers.Add(cameraRenderer);
			cameraRenderer.Init(rc);
		}
	}

	public void Tick()
	{
		if (CameraRenderer.enabled)
		{
			DispatchRenderers();
			CompleteRenderers();
			CleanupRenderers();
		}
	}

	public CameraRenderTask BorrowTask()
	{
		if (_taskPool.Count > 0)
		{
			_tasksTaken++;
			return _taskPool.Pop();
		}
		_tasksCreated++;
		return new CameraRenderTask();
	}

	public void ReturnTask(ref CameraRenderTask task)
	{
		if (task != null)
		{
			task.Reset();
			_tasksReturned++;
			_taskPool.Push(task);
			task = null;
		}
	}

	[ServerVar]
	public static void pool_stats(Arg arg)
	{
		CameraRendererManager instance = SingletonComponent<CameraRendererManager>.Instance;
		if ((Object)(object)instance == (Object)null)
		{
			arg.ReplyWith("Camera renderer manager is null!");
			return;
		}
		arg.ReplyWith($"Active renderers: {instance._renderers.Count}\nTasks in pool: {instance._taskPool.Count}\nTasks taken: {instance._tasksTaken}\nTasks returned: {instance._tasksReturned}\nTasks created: {instance._tasksCreated}");
	}

	private void DispatchRenderers()
	{
		List<CameraRenderer> list = Pool.Get<List<CameraRenderer>>();
		int count = _renderers.Count;
		for (int i = 0; i < count; i++)
		{
			if (_renderIndex >= count)
			{
				_renderIndex = 0;
			}
			CameraRenderer cameraRenderer = _renderers[_renderIndex++];
			if (cameraRenderer.CanRender())
			{
				list.Add(cameraRenderer);
				if (list.Count >= CameraRenderer.maxRendersPerFrame)
				{
					break;
				}
			}
		}
		if (list.Count > 0)
		{
			int maxSampleCount = CameraRenderer.maxRaysPerFrame / list.Count;
			foreach (CameraRenderer item in list)
			{
				item.Render(maxSampleCount);
			}
		}
		Pool.Free<CameraRenderer>(ref list, false);
	}

	private void CompleteRenderers()
	{
		_stopwatch.Restart();
		int count = _renderers.Count;
		for (int i = 0; i < count; i++)
		{
			if (_completeIndex >= count)
			{
				_completeIndex = 0;
			}
			CameraRenderer cameraRenderer = _renderers[_completeIndex++];
			if (cameraRenderer.state == CameraRendererState.Rendering)
			{
				cameraRenderer.CompleteRender();
				if (_stopwatch.Elapsed.TotalMilliseconds >= (double)CameraRenderer.completionFrameBudgetMs)
				{
					break;
				}
			}
		}
	}

	private void CleanupRenderers()
	{
		List<CameraRenderer> list = Pool.Get<List<CameraRenderer>>();
		foreach (CameraRenderer renderer in _renderers)
		{
			if (renderer.state == CameraRendererState.Invalid)
			{
				list.Add(renderer);
			}
		}
		_renderers.RemoveAll((CameraRenderer r) => r.state == CameraRendererState.Invalid);
		foreach (CameraRenderer item in list)
		{
			CameraRenderer current2 = item;
			Pool.Free<CameraRenderer>(ref current2);
		}
		Pool.Free<CameraRenderer>(ref list, false);
	}
}


using System;
using CompanionServer;

public readonly struct CameraTarget : IEquatable<CameraTarget>
{
	public NetworkableId EntityId { get; }

	public CameraTarget(NetworkableId entityId)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		EntityId = entityId;
	}

	public bool Equals(CameraTarget other)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return EntityId == other.EntityId;
	}

	public override bool Equals(object obj)
	{
		if (obj is CameraTarget other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityId = EntityId;
		return ((object)(NetworkableId)(ref entityId)/*cast due to .constrained prefix*/).GetHashCode();
	}

	public static bool operator ==(CameraTarget left, CameraTarget right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(CameraTarget left, CameraTarget right)
	{
		return !left.Equals(right);
	}
}


using System.Collections.Generic;
using CompanionServer;
using Facepunch;

public class ChatLog
{
	public struct Entry
	{
		public ulong SteamId;

		public string Name;

		public string Message;

		public string Color;

		public uint Time;
	}

	private class ChatState : IPooled
	{
		public List<Entry> History;

		public void EnterPool()
		{
			if (History != null)
			{
				Pool.FreeUnmanaged<Entry>(ref History);
			}
		}

		public void LeavePool()
		{
		}
	}

	private const int MaxBacklog = 20;

	private readonly Dictionary<ulong, ChatState> States = new Dictionary<ulong, ChatState>();

	public void Record(ulong teamId, ulong steamId, string name, string message, string color, uint time)
	{
		if (!States.TryGetValue(teamId, out var value))
		{
			value = Pool.Get<ChatState>();
			value.History = Pool.Get<List<Entry>>();
			States.Add(teamId, value);
		}
		while (value.History.Count >= 20)
		{
			value.History.RemoveAt(0);
		}
		value.History.Add(new Entry
		{
			SteamId = steamId,
			Name = name,
			Message = message,
			Color = color,
			Time = time
		});
	}

	public void Remove(ulong teamId)
	{
		if (States.TryGetValue(teamId, out var value))
		{
			States.Remove(teamId);
			Pool.Free<ChatState>(ref value);
		}
	}

	public IReadOnlyList<Entry> GetHistory(ulong teamId)
	{
		if (!States.TryGetValue(teamId, out var value))
		{
			return null;
		}
		return value.History;
	}
}


public struct Entry
{
	public ulong SteamId;

	public string Name;

	public string Message;

	public string Color;

	public uint Time;
}


using System.Collections.Generic;
using Facepunch;

private class ChatState : IPooled
{
	public List<Entry> History;

	public void EnterPool()
	{
		if (History != null)
		{
			Pool.FreeUnmanaged<Entry>(ref History);
		}
	}

	public void LeavePool()
	{
	}
}


using System;
using CompanionServer;

public struct ClanTarget : IEquatable<ClanTarget>
{
	public long ClanId { get; }

	public ClanTarget(long clanId)
	{
		ClanId = clanId;
	}

	public bool Equals(ClanTarget other)
	{
		return ClanId == other.ClanId;
	}

	public override bool Equals(object obj)
	{
		if (obj is ClanTarget other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (int)ClanId;
	}

	public static bool operator ==(ClanTarget left, ClanTarget right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(ClanTarget left, ClanTarget right)
	{
		return !left.Equals(right);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using CompanionServer;
using ConVar;
using Facepunch;
using Fleck;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Connection : IConnection
{
	private static readonly MemoryStream MessageStream = new MemoryStream(1048576);

	private readonly Listener _listener;

	private readonly IWebSocketConnection _connection;

	private PlayerTarget? _subscribedPlayer;

	private readonly HashSet<EntityTarget> _subscribedEntities;

	private readonly HashSet<ClanTarget> _subscribedClans;

	private IRemoteControllable _currentCamera;

	private ulong _cameraViewerSteamId;

	private bool _isControllingCamera;

	public long ConnectionId { get; private set; }

	public IPAddress Address => _connection.ConnectionInfo.ClientIpAddress;

	public IRemoteControllable CurrentCamera => _currentCamera;

	public bool IsControllingCamera => _isControllingCamera;

	public ulong ControllingSteamId => _cameraViewerSteamId;

	public InputState InputState { get; set; }

	public Connection(long connectionId, Listener listener, IWebSocketConnection connection)
	{
		ConnectionId = connectionId;
		_listener = listener;
		_connection = connection;
		_subscribedEntities = new HashSet<EntityTarget>();
		_subscribedClans = new HashSet<ClanTarget>();
	}

	public void OnClose()
	{
		if (_subscribedPlayer.HasValue)
		{
			_listener.PlayerSubscribers.Remove(_subscribedPlayer.Value, this);
			_subscribedPlayer = null;
		}
		foreach (EntityTarget subscribedEntity in _subscribedEntities)
		{
			_listener.EntitySubscribers.Remove(subscribedEntity, this);
		}
		_subscribedEntities.Clear();
		foreach (ClanTarget subscribedClan in _subscribedClans)
		{
			_listener.ClanSubscribers.Remove(subscribedClan, this);
		}
		_subscribedClans.Clear();
		_currentCamera?.StopControl(new CameraViewerId(_cameraViewerSteamId, ConnectionId));
		if (TryGetCameraTarget(_currentCamera, out var target))
		{
			_listener.CameraSubscribers.Remove(target, this);
		}
		_currentCamera = null;
		_cameraViewerSteamId = 0uL;
		_isControllingCamera = false;
	}

	public void OnMessage(Span<byte> data)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (App.update && App.queuelimit > 0 && data.Length <= App.maxmessagesize)
		{
			MemoryBuffer val = default(MemoryBuffer);
			((MemoryBuffer)(ref val))..ctor(data.Length);
			data.CopyTo(MemoryBuffer.op_Implicit(val));
			_listener.Enqueue(this, ((MemoryBuffer)(ref val)).Slice(data.Length));
		}
	}

	public void Close()
	{
		IWebSocketConnection connection = _connection;
		if (connection != null)
		{
			connection.Close();
		}
	}

	public void Send(AppResponse response)
	{
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		AppMessage val = Pool.Get<AppMessage>();
		val.response = response;
		MessageStream.Position = 0L;
		ProtoStreamExtensions.WriteToStream((IProto)(object)val, (Stream)MessageStream, false, 2097152);
		int num = (int)MessageStream.Position;
		MessageStream.Position = 0L;
		MemoryBuffer val2 = default(MemoryBuffer);
		((MemoryBuffer)(ref val2))..ctor(num);
		MessageStream.Read(((MemoryBuffer)(ref val2)).Data, 0, num);
		if (val.ShouldPool)
		{
			val.Dispose();
		}
		SendRaw(((MemoryBuffer)(ref val2)).Slice(num));
	}

	public void Subscribe(PlayerTarget target)
	{
		if (!(_subscribedPlayer == target))
		{
			EndViewing();
			if (_subscribedPlayer.HasValue)
			{
				_listener.PlayerSubscribers.Remove(_subscribedPlayer.Value, this);
				_subscribedPlayer = null;
			}
			_listener.PlayerSubscribers.Add(target, this);
			_subscribedPlayer = target;
		}
	}

	public void Subscribe(EntityTarget target)
	{
		if (_subscribedEntities.Add(target))
		{
			_listener.EntitySubscribers.Add(target, this);
		}
	}

	public bool BeginViewing(IRemoteControllable camera)
	{
		if (!_subscribedPlayer.HasValue)
		{
			return false;
		}
		if (!TryGetCameraTarget(camera, out var target))
		{
			if (_currentCamera == camera)
			{
				_currentCamera?.StopControl(new CameraViewerId(_cameraViewerSteamId, ConnectionId));
				_currentCamera = null;
				_isControllingCamera = false;
				_cameraViewerSteamId = 0uL;
			}
			return false;
		}
		if (_currentCamera == camera)
		{
			_listener.CameraSubscribers.Add(target, this);
			return true;
		}
		if (TryGetCameraTarget(_currentCamera, out var target2))
		{
			_listener.CameraSubscribers.Remove(target2, this);
			_currentCamera.StopControl(new CameraViewerId(_cameraViewerSteamId, ConnectionId));
			_currentCamera = null;
			_isControllingCamera = false;
			_cameraViewerSteamId = 0uL;
		}
		ulong steamId = _subscribedPlayer.Value.SteamId;
		if (!camera.CanControl(steamId))
		{
			return false;
		}
		_listener.CameraSubscribers.Add(target, this);
		_currentCamera = camera;
		_isControllingCamera = _currentCamera.InitializeControl(new CameraViewerId(steamId, ConnectionId));
		_cameraViewerSteamId = steamId;
		InputState?.Clear();
		return true;
	}

	public void EndViewing()
	{
		if (TryGetCameraTarget(_currentCamera, out var target))
		{
			_listener.CameraSubscribers.Remove(target, this);
		}
		_currentCamera?.StopControl(new CameraViewerId(_cameraViewerSteamId, ConnectionId));
		_currentCamera = null;
		_isControllingCamera = false;
		_cameraViewerSteamId = 0uL;
	}

	public void Subscribe(ClanTarget target)
	{
		if (_subscribedClans.Contains(target))
		{
			return;
		}
		foreach (ClanTarget subscribedClan in _subscribedClans)
		{
			_listener.ClanSubscribers.Remove(subscribedClan, this);
		}
		_subscribedClans.Clear();
		if (_subscribedClans.Add(target))
		{
			_listener.ClanSubscribers.Add(target, this);
		}
	}

	public void Unsubscribe(ClanTarget target)
	{
		if (_subscribedClans.Remove(target))
		{
			_listener.ClanSubscribers.Remove(target, this);
		}
	}

	public void SendRaw(MemoryBuffer data)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		if (((MemoryBuffer)(ref data)).Length == 0)
		{
			return;
		}
		if (_connection == null || !_connection.IsAvailable)
		{
			DebugEx.LogWarning((object)$"Ignoring Rust+ message send to disconnected client (connectionID={ConnectionId} steamID={_subscribedPlayer?.SteamId})", (StackTraceLogType)0);
			((MemoryBuffer)(ref data)).Dispose();
			return;
		}
		try
		{
			_connection.Send(data);
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"Failed to send message to app client {_connection.ConnectionInfo.ClientIpAddress}: {arg}");
		}
	}

	private static bool TryGetCameraTarget(IRemoteControllable camera, out CameraTarget target)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = camera?.GetEnt();
		if (camera.IsUnityNull() || (Object)(object)baseEntity == (Object)null || !baseEntity.IsValid())
		{
			target = default(CameraTarget);
			return false;
		}
		target = new CameraTarget(baseEntity.net.ID);
		return true;
	}
}


using System.Collections.Generic;
using System.Linq;
using System.Net;
using ConVar;

public class ConnectionLimiter
{
	private readonly object _sync;

	private readonly Dictionary<IPAddress, int> _addressCounts;

	private int _overallCount;

	public ConnectionLimiter()
	{
		_sync = new object();
		_addressCounts = new Dictionary<IPAddress, int>();
		_overallCount = 0;
	}

	public bool TryAdd(IPAddress address)
	{
		if (address == null)
		{
			return false;
		}
		lock (_sync)
		{
			if (_overallCount >= App.maxconnections)
			{
				return false;
			}
			if (_addressCounts.TryGetValue(address, out var value))
			{
				if (value >= App.maxconnectionsperip)
				{
					return false;
				}
				_addressCounts[address] = value + 1;
			}
			else
			{
				_addressCounts.Add(address, 1);
			}
			_overallCount++;
			return true;
		}
	}

	public void Remove(IPAddress address)
	{
		if (address == null)
		{
			return;
		}
		lock (_sync)
		{
			if (_addressCounts.TryGetValue(address, out var value))
			{
				if (value <= 1)
				{
					_addressCounts.Remove(address);
				}
				else
				{
					_addressCounts[address] = value - 1;
				}
				_overallCount--;
			}
		}
	}

	public void Clear()
	{
		lock (_sync)
		{
			_addressCounts.Clear();
			_overallCount = 0;
		}
	}

	public override string ToString()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		TextTable val = new TextTable();
		val.AddColumns(new string[2] { "IP", "connections" });
		lock (_sync)
		{
			foreach (KeyValuePair<IPAddress, int> item in _addressCounts.OrderByDescending((KeyValuePair<IPAddress, int> t) => t.Value))
			{
				val.AddRow(new string[2]
				{
					item.Key.ToString(),
					item.Value.ToString()
				});
			}
			return $"{val}\n{_overallCount} total";
		}
	}
}


using System;
using CompanionServer;

public readonly struct EntityTarget : IEquatable<EntityTarget>
{
	public NetworkableId EntityId { get; }

	public EntityTarget(NetworkableId entityId)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		EntityId = entityId;
	}

	public bool Equals(EntityTarget other)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return EntityId == other.EntityId;
	}

	public override bool Equals(object obj)
	{
		if (obj is EntityTarget other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityId = EntityId;
		return ((object)(NetworkableId)(ref entityId)/*cast due to .constrained prefix*/).GetHashCode();
	}

	public static bool operator ==(EntityTarget left, EntityTarget right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(EntityTarget left, EntityTarget right)
	{
		return !left.Equals(right);
	}
}


using CompanionServer;
using ProtoBuf;

public interface IConnection
{
	long ConnectionId { get; }

	IRemoteControllable CurrentCamera { get; }

	bool IsControllingCamera { get; }

	ulong ControllingSteamId { get; }

	InputState InputState { get; set; }

	void Send(AppResponse response);

	void Subscribe(PlayerTarget target);

	void Subscribe(EntityTarget target);

	void Subscribe(ClanTarget target);

	void Unsubscribe(ClanTarget target);

	bool BeginViewing(IRemoteControllable camera);

	void EndViewing();
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Threading;
using CompanionServer;
using CompanionServer.Handlers;
using ConVar;
using Facepunch;
using Fleck;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Listener : IDisposable, IBroadcastSender<AppBroadcast>
{
	private struct Message
	{
		public readonly Connection Connection;

		public readonly MemoryBuffer Buffer;

		public Message(Connection connection, MemoryBuffer buffer)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			Connection = connection;
			Buffer = buffer;
		}
	}

	private static readonly ByteArrayStream Stream = new ByteArrayStream();

	private readonly TokenBucketList<IPAddress> _ipTokenBuckets;

	private readonly BanList<IPAddress> _ipBans;

	private readonly TokenBucketList<ulong> _playerTokenBuckets;

	private readonly TokenBucketList<ulong> _pairingTokenBuckets;

	private readonly Queue<Message> _messageQueue;

	private readonly WebSocketServer _server;

	private readonly Stopwatch _stopwatch;

	private RealTimeSince _lastCleanup;

	private long _nextConnectionId;

	public readonly IPAddress Address;

	public readonly int Port;

	public readonly ConnectionLimiter Limiter;

	public readonly SubscriberList<PlayerTarget, AppBroadcast> PlayerSubscribers;

	public readonly SubscriberList<EntityTarget, AppBroadcast> EntitySubscribers;

	public readonly SubscriberList<ClanTarget, AppBroadcast> ClanSubscribers;

	public readonly SubscriberList<CameraTarget, AppBroadcast> CameraSubscribers;

	public Listener(IPAddress ipAddress, int port)
	{
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Expected O, but got Unknown
		Listener listener = this;
		Address = ipAddress;
		Port = port;
		Limiter = new ConnectionLimiter();
		_ipTokenBuckets = new TokenBucketList<IPAddress>(50.0, 15.0);
		_ipBans = new BanList<IPAddress>();
		_playerTokenBuckets = new TokenBucketList<ulong>(25.0, 3.0);
		_pairingTokenBuckets = new TokenBucketList<ulong>(5.0, 0.1);
		_messageQueue = new Queue<Message>();
		SynchronizationContext syncContext = SynchronizationContext.Current;
		_server = new WebSocketServer($"ws://{Address}:{Port}/", true);
		_server.Start((Action<IWebSocketConnection>)delegate(IWebSocketConnection socket)
		{
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Expected O, but got Unknown
			IPAddress address = socket.ConnectionInfo.ClientIpAddress;
			if (!listener.Limiter.TryAdd(address) || listener._ipBans.IsBanned(address))
			{
				socket.Close();
			}
			else
			{
				long connectionId = Interlocked.Increment(ref listener._nextConnectionId);
				Connection conn = new Connection(connectionId, listener, socket);
				socket.OnClose = delegate
				{
					listener.Limiter.Remove(address);
					syncContext.Post(delegate(object c)
					{
						((Connection)c).OnClose();
					}, conn);
				};
				socket.OnBinary = new BinaryDataHandler(conn.OnMessage);
				socket.OnError = Debug.LogError;
			}
		});
		_stopwatch = new Stopwatch();
		PlayerSubscribers = new SubscriberList<PlayerTarget, AppBroadcast>(this, null);
		EntitySubscribers = new SubscriberList<EntityTarget, AppBroadcast>(this, null);
		ClanSubscribers = new SubscriberList<ClanTarget, AppBroadcast>(this, null);
		CameraSubscribers = new SubscriberList<CameraTarget, AppBroadcast>(this, 30.0);
	}

	public void Dispose()
	{
		WebSocketServer server = _server;
		if (server != null)
		{
			server.Dispose();
		}
	}

	internal void Enqueue(Connection connection, MemoryBuffer data)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		lock (_messageQueue)
		{
			if (!App.update || _messageQueue.Count >= App.queuelimit)
			{
				((MemoryBuffer)(ref data)).Dispose();
				return;
			}
			Message item = new Message(connection, data);
			_messageQueue.Enqueue(item);
		}
	}

	public bool Update()
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		if (!App.update)
		{
			return false;
		}
		bool result = false;
		TimeWarning val = TimeWarning.New("CompanionServer.MessageQueue", 0);
		try
		{
			lock (_messageQueue)
			{
				_stopwatch.Restart();
				while (_messageQueue.Count > 0 && _stopwatch.Elapsed.TotalMilliseconds < 5.0)
				{
					Message message = _messageQueue.Dequeue();
					Dispatch(message);
					result = true;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		if (RealTimeSince.op_Implicit(_lastCleanup) >= 3f)
		{
			_lastCleanup = RealTimeSince.op_Implicit(0f);
			_ipTokenBuckets.Cleanup();
			_ipBans.Cleanup();
			_playerTokenBuckets.Cleanup();
			_pairingTokenBuckets.Cleanup();
		}
		return result;
	}

	private void Dispatch(Message message)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		MemoryBuffer buffer = message.Buffer;
		AppRequest val;
		try
		{
			ByteArrayStream stream = Stream;
			MemoryBuffer buffer2 = message.Buffer;
			byte[] data = ((MemoryBuffer)(ref buffer2)).Data;
			buffer2 = message.Buffer;
			stream.SetData(data, 0, ((MemoryBuffer)(ref buffer2)).Length);
			val = Pool.Get<AppRequest>();
			ProtoStreamExtensions.ReadFromStream((IProto)(object)val, (Stream)(object)Stream, false, 1048576);
		}
		catch
		{
			DebugEx.LogWarning((object)$"Malformed companion packet from {message.Connection.Address}", (StackTraceLogType)0);
			message.Connection.Close();
			throw;
		}
		finally
		{
			((MemoryBuffer)(ref buffer)).Dispose();
		}
		if (!Handle<AppEmpty, Info>(val.getInfo, message.Connection, val) && !Handle<AppEmpty, CompanionServer.Handlers.Time>(val.getTime, message.Connection, val) && !Handle<AppEmpty, Map>(val.getMap, message.Connection, val) && !Handle<AppEmpty, TeamInfo>(val.getTeamInfo, message.Connection, val) && !Handle<AppEmpty, TeamChat>(val.getTeamChat, message.Connection, val) && !Handle<AppSendMessage, SendTeamChat>(val.sendTeamMessage, message.Connection, val) && !Handle<AppEmpty, EntityInfo>(val.getEntityInfo, message.Connection, val) && !Handle<AppSetEntityValue, SetEntityValue>(val.setEntityValue, message.Connection, val) && !Handle<AppEmpty, CheckSubscription>(val.checkSubscription, message.Connection, val) && !Handle<AppFlag, SetSubscription>(val.setSubscription, message.Connection, val) && !Handle<AppEmpty, MapMarkers>(val.getMapMarkers, message.Connection, val) && !Handle<AppPromoteToLeader, PromoteToLeader>(val.promoteToLeader, message.Connection, val) && !Handle<AppEmpty, ClanInfo>(val.getClanInfo, message.Connection, val) && !Handle<AppEmpty, ClanChat>(val.getClanChat, message.Connection, val) && !Handle<AppSendMessage, SetClanMotd>(val.setClanMotd, message.Connection, val) && !Handle<AppSendMessage, SendClanChat>(val.sendClanMessage, message.Connection, val) && !Handle<AppGetNexusAuth, NexusAuth>(val.getNexusAuth, message.Connection, val) && !Handle<AppCameraSubscribe, CameraSubscribe>(val.cameraSubscribe, message.Connection, val) && !Handle<AppEmpty, CameraUnsubscribe>(val.cameraUnsubscribe, message.Connection, val) && !Handle<AppCameraInput, CameraInput>(val.cameraInput, message.Connection, val))
		{
			AppResponse val2 = Pool.Get<AppResponse>();
			val2.seq = val.seq;
			val2.error = Pool.Get<AppError>();
			val2.error.error = "unhandled";
			message.Connection.Send(val2);
			val.Dispose();
		}
	}

	private bool Handle<TProto, THandler>(TProto protocol, Connection connection, AppRequest request) where TProto : class, IProto where THandler : BaseHandler<TProto>, new()
	{
		if (protocol == null)
		{
			return false;
		}
		THandler val = Pool.Get<THandler>();
		val.Initialize(_playerTokenBuckets, connection, request, protocol);
		try
		{
			ValidationResult validationResult = val.Validate();
			switch (validationResult)
			{
			case ValidationResult.Rejected:
				connection.Close();
				break;
			default:
				val.SendError(validationResult.ToErrorCode());
				break;
			case ValidationResult.Success:
				val.Execute();
				break;
			}
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"AppRequest threw an exception: {arg}");
			val.SendError("server_error");
		}
		Pool.Free<THandler>(ref val);
		return true;
	}

	public void BroadcastTo(List<Connection> targets, AppBroadcast broadcast)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		MemoryBuffer broadcastBuffer = GetBroadcastBuffer(broadcast);
		foreach (Connection target in targets)
		{
			target.SendRaw(((MemoryBuffer)(ref broadcastBuffer)).DontDispose());
		}
		((MemoryBuffer)(ref broadcastBuffer)).Dispose();
	}

	private static MemoryBuffer GetBroadcastBuffer(AppBroadcast broadcast)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		MemoryBuffer val = default(MemoryBuffer);
		((MemoryBuffer)(ref val))..ctor(65536);
		Stream.SetData(((MemoryBuffer)(ref val)).Data, 0, ((MemoryBuffer)(ref val)).Length);
		AppMessage val2 = Pool.Get<AppMessage>();
		val2.broadcast = broadcast;
		ProtoStreamExtensions.WriteToStream((IProto)(object)val2, (Stream)(object)Stream, false, 2097152);
		if (val2.ShouldPool)
		{
			val2.Dispose();
		}
		return ((MemoryBuffer)(ref val)).Slice((int)((Stream)(object)Stream).Position);
	}

	public bool CanSendPairingNotification(ulong playerId)
	{
		return _pairingTokenBuckets.Get(playerId).TryTake(1.0);
	}
}


using Fleck;

private struct Message
{
	public readonly Connection Connection;

	public readonly MemoryBuffer Buffer;

	public Message(Connection connection, MemoryBuffer buffer)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		Connection = connection;
		Buffer = buffer;
	}
}


public enum NotificationChannel
{
	Pairing = 1001,
	PlayerLoggedIn,
	PlayerDied,
	SmartAlarm,
	ClanAnnouncement
}


public enum NotificationSendResult
{
	Failed,
	Sent,
	Empty,
	Disabled,
	RateLimited,
	ServerError,
	NoTargetsFound,
	TooManySubscribers
}


using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using CompanionServer;
using ConVar;
using Facepunch;
using Network;
using Newtonsoft.Json;
using ProtoBuf;
using UnityEngine;

public class NotificationList
{
	private const string ApiEndpoint = "https://companion-rust.facepunch.com/api/push/send";

	private static readonly HttpClient Http = new HttpClient();

	private readonly HashSet<ulong> _subscriptions = new HashSet<ulong>();

	private double _lastSend;

	public bool AddSubscription(ulong steamId)
	{
		if (steamId == 0L)
		{
			return false;
		}
		if (_subscriptions.Count >= 50)
		{
			return false;
		}
		return _subscriptions.Add(steamId);
	}

	public bool RemoveSubscription(ulong steamId)
	{
		return _subscriptions.Remove(steamId);
	}

	public bool HasSubscription(ulong steamId)
	{
		return _subscriptions.Contains(steamId);
	}

	public List<ulong> ToList()
	{
		List<ulong> list = Pool.Get<List<ulong>>();
		foreach (ulong subscription in _subscriptions)
		{
			list.Add(subscription);
		}
		return list;
	}

	public void LoadFrom(List<ulong> steamIds)
	{
		_subscriptions.Clear();
		if (steamIds == null)
		{
			return;
		}
		foreach (ulong steamId in steamIds)
		{
			_subscriptions.Add(steamId);
		}
	}

	public void IntersectWith(HashSet<PlayerNameID> players)
	{
		List<ulong> list = Pool.Get<List<ulong>>();
		foreach (PlayerNameID player in players)
		{
			list.Add(player.userid);
		}
		_subscriptions.IntersectWith(list);
		Pool.FreeUnmanaged<ulong>(ref list);
	}

	public Task<NotificationSendResult> SendNotification(NotificationChannel channel, string title, string body, string type)
	{
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		if (realtimeSinceStartup - _lastSend < 15.0)
		{
			return Task.FromResult(NotificationSendResult.RateLimited);
		}
		Dictionary<string, string> dictionary = Util.TryGetServerPairingData();
		if (dictionary == null)
		{
			return Task.FromResult(NotificationSendResult.Failed);
		}
		if (!string.IsNullOrWhiteSpace(type))
		{
			dictionary["type"] = type;
		}
		_lastSend = realtimeSinceStartup;
		return SendNotificationImpl(_subscriptions, channel, title, body, dictionary);
	}

	public static async Task<NotificationSendResult> SendNotificationTo(ICollection<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary<string, string> data)
	{
		NotificationSendResult notificationSendResult = await SendNotificationImpl(steamIds, channel, title, body, data);
		if (notificationSendResult == NotificationSendResult.NoTargetsFound)
		{
			notificationSendResult = NotificationSendResult.Sent;
		}
		return notificationSendResult;
	}

	public static async Task<NotificationSendResult> SendNotificationTo(ulong steamId, NotificationChannel channel, string title, string body, Dictionary<string, string> data)
	{
		HashSet<ulong> set = Pool.Get<HashSet<ulong>>();
		set.Clear();
		set.Add(steamId);
		NotificationSendResult result = await SendNotificationImpl(set, channel, title, body, data);
		set.Clear();
		Pool.FreeUnmanaged<ulong>(ref set);
		return result;
	}

	private static async Task<NotificationSendResult> SendNotificationImpl(ICollection<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary<string, string> data)
	{
		if (!CompanionServer.Server.IsEnabled || !App.notifications)
		{
			return NotificationSendResult.Disabled;
		}
		if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(body))
		{
			return NotificationSendResult.Empty;
		}
		if (steamIds.Count == 0)
		{
			return NotificationSendResult.Sent;
		}
		List<List<ulong>> batches = Pool.Get<List<List<ulong>>>();
		List<ulong> list = null;
		foreach (ulong steamId in steamIds)
		{
			if (list == null)
			{
				list = Pool.Get<List<ulong>>();
			}
			list.Add(steamId);
			if (list.Count >= 100)
			{
				batches.Add(list);
				list = null;
			}
		}
		if (list != null && list.Count > 0)
		{
			batches.Add(list);
		}
		NotificationSendResult? errorResult = null;
		bool anySent = false;
		foreach (List<ulong> item in batches)
		{
			List<ulong> batchCopy = item;
			NotificationSendResult notificationSendResult = await SendNotificationBatchImpl(batchCopy, channel, title, body, data);
			Pool.FreeUnmanaged<ulong>(ref batchCopy);
			switch (notificationSendResult)
			{
			case NotificationSendResult.Failed:
				errorResult = NotificationSendResult.Failed;
				break;
			case NotificationSendResult.ServerError:
				if (errorResult != NotificationSendResult.Failed)
				{
					errorResult = NotificationSendResult.ServerError;
				}
				break;
			}
			if (notificationSendResult == NotificationSendResult.Sent)
			{
				anySent = true;
			}
		}
		Pool.FreeUnmanaged<List<ulong>>(ref batches);
		if (data != null)
		{
			data.Clear();
			Pool.FreeUnmanaged<string, string>(ref data);
		}
		if (errorResult.HasValue)
		{
			return errorResult.Value;
		}
		return anySent ? NotificationSendResult.Sent : NotificationSendResult.NoTargetsFound;
	}

	private static async Task<NotificationSendResult> SendNotificationBatchImpl(IEnumerable<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary<string, string> data)
	{
		PushRequest pushRequest = Pool.Get<PushRequest>();
		pushRequest.ServerToken = CompanionServer.Server.Token;
		pushRequest.Channel = channel;
		pushRequest.Title = title;
		pushRequest.Body = body;
		pushRequest.Data = data;
		pushRequest.SteamIds = Pool.Get<List<ulong>>();
		foreach (ulong steamId in steamIds)
		{
			pushRequest.SteamIds.Add(steamId);
		}
		string text = JsonConvert.SerializeObject((object)pushRequest);
		Pool.Free<PushRequest>(ref pushRequest);
		try
		{
			StringContent val = new StringContent(text, Encoding.UTF8, "application/json");
			HttpResponseMessage val2 = await Http.PostAsync("https://companion-rust.facepunch.com/api/push/send", (HttpContent)(object)val);
			if (!val2.IsSuccessStatusCode)
			{
				DebugEx.LogWarning((object)$"Failed to send notification: {val2.StatusCode}", (StackTraceLogType)0);
				return NotificationSendResult.ServerError;
			}
			if (val2.StatusCode == HttpStatusCode.Accepted)
			{
				return NotificationSendResult.NoTargetsFound;
			}
			return NotificationSendResult.Sent;
		}
		catch (Exception arg)
		{
			DebugEx.LogWarning((object)$"Exception thrown when sending notification: {arg}", (StackTraceLogType)0);
			return NotificationSendResult.Failed;
		}
	}
}


using System;
using CompanionServer;

public readonly struct PlayerTarget : IEquatable<PlayerTarget>
{
	public ulong SteamId { get; }

	public PlayerTarget(ulong steamId)
	{
		SteamId = steamId;
	}

	public bool Equals(PlayerTarget other)
	{
		return SteamId == other.SteamId;
	}

	public override bool Equals(object obj)
	{
		if (obj is PlayerTarget other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return SteamId.GetHashCode();
	}

	public static bool operator ==(PlayerTarget left, PlayerTarget right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(PlayerTarget left, PlayerTarget right)
	{
		return !left.Equals(right);
	}
}


using System.Collections.Generic;
using CompanionServer;
using Facepunch;

public class PushRequest : IPooled
{
	public string ServerToken;

	public List<ulong> SteamIds;

	public NotificationChannel Channel;

	public string Title;

	public string Body;

	public Dictionary<string, string> Data;

	public void EnterPool()
	{
		Pool.FreeUnmanaged<ulong>(ref SteamIds);
		Channel = (NotificationChannel)0;
		Title = null;
		Body = null;
		Data = null;
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using CompanionServer;
using CompanionServer.Handlers;
using ConVar;
using Facepunch;
using Newtonsoft.Json;
using ProtoBuf;
using UnityEngine;

public static class Server
{
	private class RegisterResponse
	{
		public string ServerId;

		public string ServerToken;
	}

	private class TestConnectionResponse
	{
		public List<string> Messages;
	}

	private const string ApiEndpoint = "https://companion-rust.facepunch.com/api/server";

	private static readonly HttpClient Http = new HttpClient();

	public static readonly ChatLog TeamChat = new ChatLog();

	internal static string Token;

	public static Listener Listener { get; private set; }

	public static bool IsEnabled
	{
		get
		{
			if (App.port >= 0 && !string.IsNullOrWhiteSpace(App.serverid))
			{
				return Listener != null;
			}
			return false;
		}
	}

	public static void Initialize(bool minimal = false)
	{
		if (App.port < 0)
		{
			return;
		}
		if (IsEnabled)
		{
			Debug.LogWarning((object)"Rust+ is already started up! Skipping second startup");
			return;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (!((Object)(object)activeGameMode != (Object)null) || activeGameMode.rustPlus)
		{
			Shutdown();
			Map.PopulateCache();
			if (App.port == 0)
			{
				App.port = Math.Max(ConVar.Server.port, RCon.Port) + 67;
			}
			try
			{
				Listener = new Listener(App.GetListenIP(), App.port);
			}
			catch (Exception arg)
			{
				Debug.LogError((object)$"Companion server failed to start: {arg}");
			}
			if (!minimal)
			{
				PostInitializeServer();
			}
		}
	}

	public static void Shutdown()
	{
		SetServerId(null);
		Listener?.Dispose();
		Listener = null;
	}

	public static bool Update()
	{
		return Listener?.Update() ?? false;
	}

	public static void Broadcast(PlayerTarget target, AppBroadcast broadcast)
	{
		Listener?.PlayerSubscribers?.Send(target, broadcast);
	}

	public static void Broadcast(EntityTarget target, AppBroadcast broadcast)
	{
		Listener?.EntitySubscribers?.Send(target, broadcast);
	}

	public static void Broadcast(ClanTarget target, AppBroadcast broadcast)
	{
		Listener?.ClanSubscribers?.Send(target, broadcast);
	}

	public static void Broadcast(CameraTarget target, AppBroadcast broadcast)
	{
		Listener?.CameraSubscribers?.Send(target, broadcast);
	}

	public static bool HasAnySubscribers(CameraTarget target)
	{
		return Listener?.CameraSubscribers?.HasAnySubscribers(target) == true;
	}

	public static bool CanSendPairingNotification(ulong playerId)
	{
		return Listener?.CanSendPairingNotification(playerId) ?? false;
	}

	private static async void PostInitializeServer()
	{
		await SetupServerRegistration();
		await CheckConnectivity();
	}

	private static async Task SetupServerRegistration()
	{
		_ = 3;
		try
		{
			if (TryLoadServerRegistration(out var _, out var serverToken))
			{
				StringContent refreshContent = new StringContent(serverToken, Encoding.UTF8, "text/plain");
				HttpResponseMessage val = await AutoRetry(() => Http.PostAsync("https://companion-rust.facepunch.com/api/server/refresh", (HttpContent)(object)refreshContent));
				if (val.IsSuccessStatusCode)
				{
					SetServerRegistration(await val.Content.ReadAsStringAsync());
					return;
				}
				Debug.LogWarning((object)"Failed to refresh server ID - registering a new one");
			}
			HttpResponseMessage obj = await AutoRetry(() => Http.GetAsync("https://companion-rust.facepunch.com/api/server/register"));
			obj.EnsureSuccessStatusCode();
			SetServerRegistration(await obj.Content.ReadAsStringAsync());
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"Failed to setup companion server registration: {arg}");
		}
	}

	private static bool TryLoadServerRegistration(out string serverId, out string serverToken)
	{
		serverId = null;
		serverToken = null;
		string serverIdPath = GetServerIdPath();
		if (!File.Exists(serverIdPath))
		{
			return false;
		}
		try
		{
			RegisterResponse registerResponse = JsonConvert.DeserializeObject<RegisterResponse>(File.ReadAllText(serverIdPath));
			serverId = registerResponse.ServerId;
			serverToken = registerResponse.ServerToken;
			return true;
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"Failed to load companion server registration: {arg}");
			return false;
		}
	}

	private static void SetServerRegistration(string responseJson)
	{
		RegisterResponse registerResponse = null;
		try
		{
			registerResponse = JsonConvert.DeserializeObject<RegisterResponse>(responseJson);
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"Failed to parse registration response JSON: {responseJson}\n\n{arg}");
		}
		SetServerId(registerResponse?.ServerId);
		Token = registerResponse?.ServerToken;
		if (registerResponse == null)
		{
			return;
		}
		try
		{
			File.WriteAllText(GetServerIdPath(), responseJson);
		}
		catch (Exception arg2)
		{
			Debug.LogError((object)$"Unable to save companion app server registration - server ID may be different after restart: {arg2}");
		}
	}

	private static async Task CheckConnectivity()
	{
		if (!IsEnabled)
		{
			Shutdown();
			return;
		}
		try
		{
			string publicIp = await App.GetPublicIPAsync();
			if (string.IsNullOrEmpty(publicIp))
			{
				Debug.LogError((object)"Failed to determine public IP address for Rust+ while running the connectivity test. Disabling Rust+ features because we wouldn't know what IP to tell Rust+ to connect to.");
				SetServerId(null);
			}
			StringContent testContent = new StringContent("", Encoding.UTF8, "text/plain");
			HttpResponseMessage testResponse = await AutoRetry(() => Http.PostAsync("https://companion-rust.facepunch.com/api/server" + $"/test_connection?address={publicIp}&port={App.port}", (HttpContent)(object)testContent));
			string text = await testResponse.Content.ReadAsStringAsync();
			TestConnectionResponse testConnectionResponse = null;
			try
			{
				testConnectionResponse = JsonConvert.DeserializeObject<TestConnectionResponse>(text);
			}
			catch (Exception arg)
			{
				Debug.LogError((object)$"Failed to parse connectivity test response JSON: {text}\n\n{arg}");
			}
			if (testConnectionResponse == null)
			{
				return;
			}
			IEnumerable<string> messages = testConnectionResponse.Messages;
			string text2 = string.Join("\n", messages ?? Enumerable.Empty<string>());
			if (testResponse.StatusCode == (HttpStatusCode)555)
			{
				Debug.LogError((object)("Rust+ companion server connectivity test failed! Disabling Rust+ features.\n\n" + text2));
				SetServerId(null);
				return;
			}
			testResponse.EnsureSuccessStatusCode();
			if (!string.IsNullOrWhiteSpace(text2))
			{
				Debug.LogWarning((object)("Rust+ companion server connectivity test has warnings:\n" + text2));
			}
		}
		catch (Exception arg2)
		{
			Debug.LogError((object)$"Failed to check connectivity to the companion server: {arg2}");
		}
	}

	private static async Task<HttpResponseMessage> AutoRetry(Func<Task<HttpResponseMessage>> action)
	{
		Exception lastException = null;
		for (int i = 0; i < 5; i++)
		{
			try
			{
				HttpResponseMessage val = await action();
				int statusCode = (int)val.StatusCode;
				if (statusCode != 555 && statusCode >= 500 && statusCode <= 599 && i < 4)
				{
					val.EnsureSuccessStatusCode();
				}
				return val;
			}
			catch (Exception ex)
			{
				lastException = ex;
			}
			await Task.Delay(30000);
		}
		throw lastException ?? new Exception("Exceeded maximum number of retries");
	}

	private static void SetServerId(string serverId)
	{
		Command obj = Server.Find("app.serverid");
		if (obj != null)
		{
			obj.Set(serverId ?? "");
		}
	}

	private static string GetServerIdPath()
	{
		return Path.Combine(ConVar.Server.rootFolder, "companion.id");
	}
}


private class RegisterResponse
{
	public string ServerId;

	public string ServerToken;
}


using System.Collections.Generic;

private class TestConnectionResponse
{
	public List<string> Messages;
}


using System.Collections.Generic;
using CompanionServer;

public interface IBroadcastSender<TMessage>
{
	void BroadcastTo(List<Connection> targets, TMessage message);
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using CompanionServer;
using Facepunch;
using Network;

public class SubscriberList<TKey, TMessage> where TKey : IEquatable<TKey>
{
	private readonly object _syncRoot;

	private readonly Dictionary<TKey, Dictionary<Connection, double>> _subscriptions;

	private readonly IBroadcastSender<TMessage> _sender;

	private readonly double? _timeoutSeconds;

	private readonly Stopwatch _lastCleanup;

	public SubscriberList(IBroadcastSender<TMessage> sender, double? timeoutSeconds = null)
	{
		_syncRoot = new object();
		_subscriptions = new Dictionary<TKey, Dictionary<Connection, double>>();
		_sender = sender;
		_timeoutSeconds = timeoutSeconds;
		_lastCleanup = Stopwatch.StartNew();
	}

	public void Add(TKey key, Connection value)
	{
		lock (_syncRoot)
		{
			if (!_subscriptions.TryGetValue(key, out var value2))
			{
				value2 = new Dictionary<Connection, double>();
				_subscriptions.Add(key, value2);
			}
			value2[value] = TimeEx.realtimeSinceStartup;
		}
		CleanupExpired();
	}

	public void Remove(TKey key, Connection value)
	{
		lock (_syncRoot)
		{
			if (_subscriptions.TryGetValue(key, out var value2))
			{
				value2.Remove(value);
				if (value2.Count == 0)
				{
					_subscriptions.Remove(key);
				}
			}
		}
		CleanupExpired();
	}

	public void Clear(TKey key)
	{
		lock (_syncRoot)
		{
			if (_subscriptions.TryGetValue(key, out var value))
			{
				value.Clear();
			}
		}
	}

	public void Send(TKey key, TMessage message)
	{
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		List<Connection> list;
		lock (_syncRoot)
		{
			if (!_subscriptions.TryGetValue(key, out var value))
			{
				return;
			}
			list = Pool.Get<List<Connection>>();
			foreach (KeyValuePair<Connection, double> item in value)
			{
				if (!_timeoutSeconds.HasValue || realtimeSinceStartup - item.Value < _timeoutSeconds.Value)
				{
					list.Add(item.Key);
				}
			}
		}
		_sender.BroadcastTo(list, message);
		Pool.FreeUnmanaged<Connection>(ref list);
	}

	public bool HasAnySubscribers(TKey key)
	{
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		lock (_syncRoot)
		{
			if (!_subscriptions.TryGetValue(key, out var value))
			{
				return false;
			}
			foreach (KeyValuePair<Connection, double> item in value)
			{
				if (!_timeoutSeconds.HasValue || realtimeSinceStartup - item.Value < _timeoutSeconds.Value)
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool HasSubscriber(TKey key, Connection target)
	{
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		lock (_syncRoot)
		{
			if (!_subscriptions.TryGetValue(key, out var value) || !value.TryGetValue(target, out var value2))
			{
				return false;
			}
			if (!_timeoutSeconds.HasValue || realtimeSinceStartup - value2 < _timeoutSeconds.Value)
			{
				return true;
			}
		}
		return false;
	}

	private void CleanupExpired()
	{
		if (!_timeoutSeconds.HasValue || _lastCleanup.Elapsed.TotalMinutes < 2.0)
		{
			return;
		}
		_lastCleanup.Restart();
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		List<(TKey, Connection)> list = Pool.Get<List<(TKey, Connection)>>();
		lock (_syncRoot)
		{
			foreach (KeyValuePair<TKey, Dictionary<Connection, double>> subscription in _subscriptions)
			{
				foreach (KeyValuePair<Connection, double> item in subscription.Value)
				{
					if (realtimeSinceStartup - item.Value >= _timeoutSeconds.Value)
					{
						list.Add((subscription.Key, item.Key));
					}
				}
			}
			foreach (var (key, value) in list)
			{
				Remove(key, value);
			}
		}
		Pool.FreeUnmanaged<(TKey, Connection)>(ref list);
	}
}


using System.Collections.Generic;
using CompanionServer;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public static class AppPlayerExtensions
{
	public static AppTeamInfo GetAppTeamInfo(this BasePlayer player, ulong steamId)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		AppTeamInfo obj = Pool.Get<AppTeamInfo>();
		obj.members = Pool.Get<List<Member>>();
		Member val = Pool.Get<Member>();
		if ((Object)(object)player != (Object)null)
		{
			Vector2 val2 = Util.WorldToMap(((Component)player).transform.position);
			val.steamId = player.userID;
			val.name = player.displayName ?? "";
			val.x = val2.x;
			val.y = val2.y;
			val.isOnline = player.IsConnected;
			val.spawnTime = player.lifeStory?.timeBorn ?? 0;
			val.isAlive = player.IsAlive();
			val.deathTime = player.previousLifeStory?.timeDied ?? 0;
		}
		else
		{
			val.steamId = steamId;
			val.name = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(steamId) ?? "";
			val.x = 0f;
			val.y = 0f;
			val.isOnline = false;
			val.spawnTime = 0u;
			val.isAlive = false;
			val.deathTime = 0u;
		}
		obj.members.Add(val);
		obj.leaderSteamId = 0uL;
		obj.mapNotes = GetMapNotes(val.steamId, personalNotes: true);
		obj.leaderMapNotes = Pool.Get<List<Note>>();
		return obj;
	}

	public static AppTeamInfo GetAppTeamInfo(this RelationshipManager.PlayerTeam team, ulong requesterSteamId)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		AppTeamInfo val = Pool.Get<AppTeamInfo>();
		val.members = Pool.Get<List<Member>>();
		for (int i = 0; i < team.members.Count; i++)
		{
			ulong num = team.members[i];
			BasePlayer basePlayer = RelationshipManager.FindByID(num);
			if (!Object.op_Implicit((Object)(object)basePlayer))
			{
				basePlayer = null;
			}
			Vector2 val2 = Util.WorldToMap((basePlayer != null) ? ((Component)basePlayer).transform.position : Vector3.zero);
			Member val3 = Pool.Get<Member>();
			val3.steamId = num;
			val3.name = basePlayer?.displayName ?? SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(num) ?? "";
			val3.x = val2.x;
			val3.y = val2.y;
			val3.isOnline = basePlayer?.IsConnected ?? false;
			val3.spawnTime = (basePlayer?.lifeStory?.timeBorn).GetValueOrDefault();
			val3.isAlive = basePlayer?.IsAlive() ?? false;
			val3.deathTime = (basePlayer?.previousLifeStory?.timeDied).GetValueOrDefault();
			val.members.Add(val3);
		}
		val.leaderSteamId = team.teamLeader;
		val.mapNotes = GetMapNotes(requesterSteamId, personalNotes: true);
		if (requesterSteamId != team.teamLeader)
		{
			val.leaderMapNotes = GetMapNotes(team.teamLeader, personalNotes: false);
		}
		else
		{
			val.leaderMapNotes = Pool.Get<List<Note>>();
		}
		return val;
	}

	private static List<Note> GetMapNotes(ulong playerId, bool personalNotes)
	{
		List<Note> result = Pool.Get<List<Note>>();
		PlayerState val = SingletonComponent<ServerMgr>.Instance.playerStateManager.Get(playerId);
		if (val != null)
		{
			if (personalNotes && val.deathMarker != null)
			{
				AddMapNote(result, val.deathMarker, BasePlayer.MapNoteType.Death);
			}
			if (val.pointsOfInterest != null)
			{
				foreach (MapNote item in val.pointsOfInterest)
				{
					AddMapNote(result, item, BasePlayer.MapNoteType.PointOfInterest);
				}
			}
		}
		return result;
	}

	private static void AddMapNote(List<Note> result, MapNote note, BasePlayer.MapNoteType type)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = Util.WorldToMap(note.worldPosition);
		Note val2 = Pool.Get<Note>();
		val2.type = (int)type;
		val2.x = val.x;
		val2.y = val.y;
		val2.icon = note.icon;
		val2.colourIndex = note.colourIndex;
		val2.label = note.label;
		result.Add(val2);
	}
}


using System;
using CompanionServer;
using Facepunch;
using Network;

public class TokenBucket : IPooled
{
	private double _lastUpdate;

	private double _tokens;

	public ITokenBucketSettings Settings;

	public bool IsFull
	{
		get
		{
			Update();
			return _tokens >= Settings.MaxTokens;
		}
	}

	public bool IsNaughty
	{
		get
		{
			Update();
			return _tokens <= -10.0;
		}
	}

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		Settings = null;
		_lastUpdate = 0.0;
		_tokens = 0.0;
	}

	public void Reset()
	{
		_lastUpdate = TimeEx.realtimeSinceStartup;
		_tokens = Settings?.MaxTokens ?? 0.0;
	}

	public bool TryTake(double requestedTokens)
	{
		Update();
		if (requestedTokens > _tokens)
		{
			_tokens -= 1.0;
			return false;
		}
		_tokens -= requestedTokens;
		return true;
	}

	private void Update()
	{
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		double num = realtimeSinceStartup - _lastUpdate;
		_lastUpdate = realtimeSinceStartup;
		double num2 = num * Settings.TokensPerSec;
		_tokens = Math.Min(_tokens + num2, Settings.MaxTokens);
	}
}


public interface ITokenBucketSettings
{
	double MaxTokens { get; }

	double TokensPerSec { get; }
}


using System.Collections.Generic;
using CompanionServer;
using Facepunch;

public class TokenBucketList<TKey> : ITokenBucketSettings
{
	private readonly Dictionary<TKey, TokenBucket> _buckets;

	public double MaxTokens { get; }

	public double TokensPerSec { get; }

	public TokenBucketList(double maxTokens, double tokensPerSec)
	{
		_buckets = new Dictionary<TKey, TokenBucket>();
		MaxTokens = maxTokens;
		TokensPerSec = tokensPerSec;
	}

	public TokenBucket Get(TKey key)
	{
		if (_buckets.TryGetValue(key, out var value))
		{
			return value;
		}
		TokenBucket tokenBucket = Pool.Get<TokenBucket>();
		tokenBucket.Settings = this;
		tokenBucket.Reset();
		_buckets.Add(key, tokenBucket);
		return tokenBucket;
	}

	public void Cleanup()
	{
		List<TKey> list = Pool.Get<List<TKey>>();
		foreach (KeyValuePair<TKey, TokenBucket> bucket in _buckets)
		{
			if (bucket.Value.IsFull)
			{
				list.Add(bucket.Key);
			}
		}
		foreach (TKey item in list)
		{
			if (_buckets.TryGetValue(item, out var value))
			{
				Pool.Free<TokenBucket>(ref value);
				_buckets.Remove(item);
			}
		}
		Pool.FreeUnmanaged<TKey>(ref list);
	}
}


using System.Collections.Generic;
using System.Globalization;
using System.Threading.Tasks;
using CompanionServer;
using CompanionServer.Handlers;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Math;
using Network;
using ProtoBuf;
using UnityEngine;

public static class Util
{
	public const int OceanMargin = 500;

	public static readonly Phrase NotificationEmpty = new Phrase("app.error.empty", "Notification was not sent because it was missing some content.");

	public static readonly Phrase NotificationDisabled = new Phrase("app.error.disabled", "Rust+ features are disabled on this server.");

	public static readonly Phrase NotificationRateLimit = new Phrase("app.error.ratelimit", "You are sending too many notifications at a time. Please wait and then try again.");

	public static readonly Phrase NotificationServerError = new Phrase("app.error.servererror", "The companion server failed to send the notification.");

	public static readonly Phrase NotificationNoTargets = new Phrase("app.error.notargets", "Open the Rust+ menu in-game to pair your phone with this server.");

	public static readonly Phrase NotificationTooManySubscribers = new Phrase("app.error.toomanysubs", "There are too many players subscribed to these notifications.");

	public static readonly Phrase NotificationUnknown = new Phrase("app.error.unknown", "An unknown error occurred sending the notification.");

	public static Vector2 WorldToMap(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(worldPos.x - TerrainMeta.Position.x, worldPos.z - TerrainMeta.Position.z);
	}

	public static void SendSignedInNotification(BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null) && player.currentTeam != 0L)
		{
			Dictionary<string, string> dictionary = TryGetServerPairingData();
			if (dictionary != null)
			{
				dictionary.Add("type", "login");
				dictionary.Add("targetId", player.UserIDString);
				dictionary.Add("targetName", StringExtensions.Truncate(player.displayName, 128, (string)null));
				RelationshipManager.ServerInstance.FindTeam(player.currentTeam)?.SendNotification(NotificationChannel.PlayerLoggedIn, player.displayName + " is now online", ConVar.Server.hostname, dictionary, player.userID);
			}
		}
	}

	public static void SendDeathNotification(BasePlayer player, BaseEntity killer)
	{
		string value;
		string text;
		PrefabInformation result;
		if (killer is BasePlayer basePlayer && ((object)basePlayer).GetType() == typeof(BasePlayer))
		{
			value = basePlayer.UserIDString;
			text = basePlayer.displayName;
		}
		else if (PrefabAttribute.server.Find(killer.prefabID, out result) && !string.IsNullOrEmpty(result.title?.english))
		{
			value = "";
			text = result.title.english;
		}
		else
		{
			value = "";
			text = killer.ShortPrefabName;
		}
		if (!((Object)(object)player == (Object)null) && !string.IsNullOrEmpty(text))
		{
			Dictionary<string, string> dictionary = TryGetServerPairingData();
			if (dictionary != null)
			{
				dictionary.Add("type", "death");
				dictionary.Add("targetId", value);
				dictionary.Add("targetName", StringExtensions.Truncate(text, 128, (string)null));
				NotificationList.SendNotificationTo(player.userID, NotificationChannel.PlayerDied, "You were killed by " + text, ConVar.Server.hostname, dictionary);
			}
		}
	}

	public static Task<NotificationSendResult> SendPairNotification(string type, BasePlayer player, string title, string message, Dictionary<string, string> data)
	{
		if (!CompanionServer.Server.IsEnabled)
		{
			return Task.FromResult(NotificationSendResult.Disabled);
		}
		if (!CompanionServer.Server.CanSendPairingNotification(player.userID))
		{
			return Task.FromResult(NotificationSendResult.RateLimited);
		}
		if (data == null)
		{
			data = TryGetPlayerPairingData(player);
			if (data == null)
			{
				return Task.FromResult(NotificationSendResult.Failed);
			}
		}
		data.Add("type", type);
		return NotificationList.SendNotificationTo(player.userID, NotificationChannel.Pairing, title, message, data);
	}

	public static Dictionary<string, string> TryGetServerPairingData()
	{
		string value = App.GetPublicIP() ?? "";
		if (string.IsNullOrWhiteSpace(value) || string.IsNullOrWhiteSpace(App.serverid))
		{
			return null;
		}
		Dictionary<string, string> dictionary = Pool.Get<Dictionary<string, string>>();
		dictionary.Clear();
		dictionary.Add("id", App.serverid);
		dictionary.Add("name", StringExtensions.Truncate(ConVar.Server.hostname, 128, (string)null));
		dictionary.Add("desc", StringExtensions.Truncate(ConVar.Server.description, 512, (string)null));
		dictionary.Add("img", StringExtensions.Truncate(ConVar.Server.headerimage, 128, (string)null));
		dictionary.Add("logo", StringExtensions.Truncate(ConVar.Server.logoimage, 128, (string)null));
		dictionary.Add("url", StringExtensions.Truncate(ConVar.Server.url, 128, (string)null));
		dictionary.Add("ip", value);
		dictionary.Add("port", App.port.ToString("G", CultureInfo.InvariantCulture));
		if (NexusServer.Started)
		{
			int? nexusId = NexusServer.NexusId;
			string zoneKey = NexusServer.ZoneKey;
			if (nexusId.HasValue && zoneKey != null)
			{
				dictionary.Add("nexus", Nexus.endpoint);
				dictionary.Add("nexusId", nexusId.Value.ToString("G"));
				dictionary.Add("nexusZone", zoneKey);
			}
		}
		return dictionary;
	}

	public static Dictionary<string, string> TryGetPlayerPairingData(BasePlayer player)
	{
		Dictionary<string, string> dictionary = TryGetServerPairingData();
		if (dictionary == null)
		{
			return null;
		}
		bool locked;
		int orGenerateAppToken = SingletonComponent<ServerMgr>.Instance.persistance.GetOrGenerateAppToken(player.userID, out locked);
		dictionary.Add("playerId", player.UserIDString);
		dictionary.Add("playerToken", orGenerateAppToken.ToString("G", CultureInfo.InvariantCulture));
		return dictionary;
	}

	public static void BroadcastAppTeamRemoval(this BasePlayer player)
	{
		AppBroadcast val = Pool.Get<AppBroadcast>();
		val.teamChanged = Pool.Get<AppTeamChanged>();
		val.teamChanged.playerId = player.userID;
		val.teamChanged.teamInfo = player.GetAppTeamInfo(player.userID);
		CompanionServer.Server.Broadcast(new PlayerTarget(player.userID), val);
	}

	public static void BroadcastAppTeamUpdate(this RelationshipManager.PlayerTeam team)
	{
		AppBroadcast val = Pool.Get<AppBroadcast>();
		val.teamChanged = Pool.Get<AppTeamChanged>();
		val.ShouldPool = false;
		foreach (ulong member in team.members)
		{
			val.teamChanged.playerId = member;
			val.teamChanged.teamInfo = team.GetAppTeamInfo(member);
			CompanionServer.Server.Broadcast(new PlayerTarget(member), val);
		}
		val.ShouldPool = true;
		val.Dispose();
	}

	public static void BroadcastTeamChat(this RelationshipManager.PlayerTeam team, ulong steamId, string name, string message, string color)
	{
		uint current = (uint)Epoch.Current;
		CompanionServer.Server.TeamChat.Record(team.teamID, steamId, name, message, color, current);
		AppBroadcast val = Pool.Get<AppBroadcast>();
		val.teamMessage = Pool.Get<AppNewTeamMessage>();
		val.teamMessage.message = Pool.Get<AppTeamMessage>();
		val.ShouldPool = false;
		AppTeamMessage message2 = val.teamMessage.message;
		message2.steamId = steamId;
		message2.name = name;
		message2.message = message;
		message2.color = color;
		message2.time = current;
		foreach (ulong member in team.members)
		{
			CompanionServer.Server.Broadcast(new PlayerTarget(member), val);
		}
		val.ShouldPool = true;
		val.Dispose();
	}

	public static async void SendNotification(this RelationshipManager.PlayerTeam team, NotificationChannel channel, string title, string body, Dictionary<string, string> data, ulong ignorePlayer = 0uL)
	{
		List<ulong> steamIds = Pool.Get<List<ulong>>();
		foreach (ulong member in team.members)
		{
			if (member == ignorePlayer)
			{
				continue;
			}
			BasePlayer basePlayer = RelationshipManager.FindByID(member);
			if (!((Object)(object)basePlayer == (Object)null))
			{
				Networkable net = basePlayer.net;
				if (((net != null) ? net.connection : null) != null)
				{
					continue;
				}
			}
			steamIds.Add(member);
		}
		await NotificationList.SendNotificationTo(steamIds, channel, title, body, data);
		Pool.FreeUnmanaged<ulong>(ref steamIds);
	}

	public static string ToErrorCode(this ValidationResult result)
	{
		return result switch
		{
			ValidationResult.NotFound => "not_found", 
			ValidationResult.RateLimit => "rate_limit", 
			ValidationResult.Banned => "banned", 
			_ => "unknown", 
		};
	}

	public static Phrase ToErrorMessage(this NotificationSendResult result)
	{
		return (Phrase)(result switch
		{
			NotificationSendResult.Sent => null, 
			NotificationSendResult.Empty => NotificationEmpty, 
			NotificationSendResult.Disabled => NotificationDisabled, 
			NotificationSendResult.RateLimited => NotificationRateLimit, 
			NotificationSendResult.ServerError => NotificationServerError, 
			NotificationSendResult.NoTargetsFound => NotificationNoTargets, 
			NotificationSendResult.TooManySubscribers => NotificationTooManySubscribers, 
			_ => NotificationUnknown, 
		});
	}
}


using System;
using System.Threading.Tasks;
using CompanionServer;
using CompanionServer.Handlers;
using UnityEngine;

public abstract class BaseClanHandler<T> : BasePlayerHandler<T> where T : class
{
	protected IClanBackend ClanBackend { get; private set; }

	protected async ValueTask<IClan> GetClan()
	{
		if (ClanBackend == null)
		{
			return null;
		}
		ClanValueResult<IClan> val = ((!((Object)(object)base.Player != (Object)null) || base.Player.clanId == 0L) ? (await ClanBackend.GetByMember(base.UserId)) : (await ClanBackend.Get(base.Player.clanId)));
		ClanValueResult<IClan> val2 = val;
		if ((int)val2.Result != 3 && (int)val2.Result != 4)
		{
			IClan value = val2.Value;
			base.Client.Subscribe(new ClanTarget(value.ClanId));
			return value;
		}
		return null;
	}

	public override void EnterPool()
	{
		base.EnterPool();
		ClanBackend = null;
	}

	public override ValidationResult Validate()
	{
		ValidationResult num = base.Validate();
		if (num == ValidationResult.Success && (Object)(object)ClanManager.ServerInstance != (Object)null)
		{
			ClanBackend = ClanManager.ServerInstance.Backend;
		}
		return num;
	}

	protected void SendError(ClanResult result)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		base.SendError(GetErrorString(result));
	}

	private static string GetErrorString(ClanResult result)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Expected I4, but got Unknown
		return (int)result switch
		{
			1 => throw new ArgumentException("ClanResult.Success is not an error"), 
			2 => "clan_timeout", 
			3 => "clan_no_clan", 
			4 => "clan_not_found", 
			5 => "clan_no_permission", 
			6 => "clan_invalid_text", 
			7 => "clan_invalid_logo", 
			8 => "clan_invalid_color", 
			9 => "clan_duplicate_name", 
			10 => "clan_role_not_empty", 
			11 => "clan_cannot_swap_leader", 
			12 => "clan_cannot_delete_leader", 
			13 => "clan_cannot_kick_leader", 
			14 => "clan_cannot_demote_leader", 
			15 => "clan_already_in_clan", 
			_ => "clan_fail", 
		};
	}
}


using CompanionServer;
using CompanionServer.Handlers;
using UnityEngine;

public abstract class BaseEntityHandler<T> : BasePlayerHandler<T> where T : class
{
	protected AppIOEntity Entity { get; private set; }

	public override void EnterPool()
	{
		base.EnterPool();
		Entity = null;
	}

	public override ValidationResult Validate()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		ValidationResult validationResult = base.Validate();
		if (validationResult != 0)
		{
			return validationResult;
		}
		AppIOEntity appIOEntity = BaseNetworkable.serverEntities.Find(base.Request.entityId) as AppIOEntity;
		if ((Object)(object)appIOEntity == (Object)null)
		{
			return ValidationResult.NotFound;
		}
		BuildingPrivlidge buildingPrivilege = appIOEntity.GetBuildingPrivilege();
		if ((Object)(object)buildingPrivilege != (Object)null && !buildingPrivilege.IsAuthed(base.UserId))
		{
			return ValidationResult.NotFound;
		}
		Entity = appIOEntity;
		base.Client.Subscribe(new EntityTarget(base.Request.entityId));
		return ValidationResult.Success;
	}
}


using CompanionServer;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public abstract class BaseHandler<T> : IHandler, IPooled where T : class
{
	protected TokenBucketList<ulong> PlayerBuckets { get; private set; }

	protected virtual double TokenCost => 1.0;

	public IConnection Client { get; private set; }

	public AppRequest Request { get; private set; }

	public T Proto { get; private set; }

	public void Initialize(TokenBucketList<ulong> playerBuckets, IConnection client, AppRequest request, T proto)
	{
		PlayerBuckets = playerBuckets;
		Client = client;
		Request = request;
		Proto = proto;
	}

	public virtual void EnterPool()
	{
		PlayerBuckets = null;
		Client = null;
		if (Request != null)
		{
			Request.Dispose();
			Request = null;
		}
		Proto = null;
	}

	public void LeavePool()
	{
	}

	public virtual ValidationResult Validate()
	{
		return ValidationResult.Success;
	}

	public abstract void Execute();

	protected void SendSuccess()
	{
		AppSuccess success = Pool.Get<AppSuccess>();
		AppResponse val = Pool.Get<AppResponse>();
		val.success = success;
		Send(val);
	}

	public void SendError(string code)
	{
		AppError val = Pool.Get<AppError>();
		val.error = code;
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.error = val;
		Send(val2);
	}

	public void SendFlag(bool value)
	{
		AppFlag val = Pool.Get<AppFlag>();
		val.value = value;
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.flag = val;
		Send(val2);
	}

	protected void Send(AppResponse response)
	{
		response.seq = Request.seq;
		Client.Send(response);
	}
}


using CompanionServer;
using CompanionServer.Handlers;

public abstract class BasePlayerHandler<T> : BaseHandler<T> where T : class
{
	protected ulong UserId { get; private set; }

	protected BasePlayer Player { get; private set; }

	public override void EnterPool()
	{
		UserId = 0uL;
		Player = null;
	}

	public override ValidationResult Validate()
	{
		ValidationResult validationResult = base.Validate();
		if (validationResult != 0)
		{
			return validationResult;
		}
		bool locked;
		int orGenerateAppToken = SingletonComponent<ServerMgr>.Instance.persistance.GetOrGenerateAppToken(base.Request.playerId, out locked);
		if (base.Request.playerId == 0L || base.Request.playerToken != orGenerateAppToken)
		{
			return ValidationResult.NotFound;
		}
		if (locked)
		{
			return ValidationResult.Banned;
		}
		if ((ServerUsers.Get(base.Request.playerId)?.group ?? ServerUsers.UserGroup.None) == ServerUsers.UserGroup.Banned)
		{
			return ValidationResult.Banned;
		}
		TokenBucket tokenBucket = base.PlayerBuckets?.Get(base.Request.playerId);
		if (tokenBucket == null || !tokenBucket.TryTake(TokenCost))
		{
			if (tokenBucket == null || !tokenBucket.IsNaughty)
			{
				return ValidationResult.RateLimit;
			}
			return ValidationResult.Rejected;
		}
		UserId = base.Request.playerId;
		Player = BasePlayer.FindByID(UserId) ?? BasePlayer.FindSleeping(UserId);
		base.Client.Subscribe(new PlayerTarget(UserId));
		return ValidationResult.Success;
	}
}


using CompanionServer.Cameras;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class CameraInput : BaseHandler<AppCameraInput>
{
	protected override double TokenCost => 0.01;

	public override void Execute()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (!CameraRenderer.enabled)
		{
			SendError("not_enabled");
			return;
		}
		if (base.Client.CurrentCamera == null || !base.Client.IsControllingCamera)
		{
			SendError("no_camera");
			return;
		}
		InputState inputState = base.Client.InputState;
		if (inputState == null)
		{
			inputState = new InputState();
			base.Client.InputState = inputState;
		}
		InputMessage val = Pool.Get<InputMessage>();
		val.buttons = base.Proto.buttons;
		val.mouseDelta = Sanitize(Vector2.op_Implicit(base.Proto.mouseDelta));
		val.aimAngles = Vector3.zero;
		inputState.Flip(val);
		Pool.Free<InputMessage>(ref val);
		base.Client.CurrentCamera.UserInput(inputState, new CameraViewerId(base.Client.ControllingSteamId, base.Client.ConnectionId));
		SendSuccess();
	}

	private static Vector3 Sanitize(Vector3 value)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(Sanitize(value.x), Sanitize(value.y), Sanitize(value.z));
	}

	private static float Sanitize(float value)
	{
		if (float.IsNaN(value) || float.IsInfinity(value))
		{
			return 0f;
		}
		return Mathf.Clamp(value, -100f, 100f);
	}
}


using CompanionServer;
using CompanionServer.Cameras;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class CameraSubscribe : BasePlayerHandler<AppCameraSubscribe>
{
	public override void Execute()
	{
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		if (!CameraRenderer.enabled)
		{
			SendError("not_enabled");
			return;
		}
		CameraRendererManager instance = SingletonComponent<CameraRendererManager>.Instance;
		if ((Object)(object)instance == (Object)null)
		{
			SendError("server_error");
			return;
		}
		if (string.IsNullOrEmpty(base.Proto.cameraId))
		{
			base.Client.EndViewing();
			SendError("invalid_id");
			return;
		}
		if (!base.Player.IsValid())
		{
			base.Client.EndViewing();
			SendError("no_player");
			return;
		}
		if (base.Player.IsConnected)
		{
			base.Client.EndViewing();
			SendError("player_online");
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(base.Proto.cameraId);
		if (remoteControllable == null || !remoteControllable.CanControl(base.UserId))
		{
			base.Client.EndViewing();
			SendError("not_found");
			return;
		}
		if (remoteControllable is CCTV_RC cCTV_RC && cCTV_RC.IsStatic())
		{
			base.Client.EndViewing();
			SendError("access_denied");
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (!ent.IsValid())
		{
			base.Client.EndViewing();
			SendError("not_found");
			return;
		}
		if (Vector3.Distance(((Component)base.Player).transform.position, ((Component)ent).transform.position) >= remoteControllable.MaxRange)
		{
			base.Client.EndViewing();
			SendError("not_found");
			return;
		}
		if (!base.Client.BeginViewing(remoteControllable))
		{
			base.Client.EndViewing();
			SendError("not_found");
			return;
		}
		instance.StartRendering(remoteControllable);
		AppResponse val = Pool.Get<AppResponse>();
		AppCameraInfo val2 = Pool.Get<AppCameraInfo>();
		val2.width = CameraRenderer.width;
		val2.height = CameraRenderer.height;
		val2.nearPlane = CameraRenderer.nearPlane;
		val2.farPlane = CameraRenderer.farPlane;
		val2.controlFlags = (int)(base.Client.IsControllingCamera ? remoteControllable.RequiredControls : RemoteControllableControls.None);
		val.cameraSubscribeInfo = val2;
		Send(val);
	}
}


using CompanionServer.Cameras;
using CompanionServer.Handlers;
using ProtoBuf;

public class CameraUnsubscribe : BaseHandler<AppEmpty>
{
	public override void Execute()
	{
		if (!CameraRenderer.enabled)
		{
			SendError("not_enabled");
			return;
		}
		base.Client.EndViewing();
		SendSuccess();
	}
}


using CompanionServer.Handlers;
using ProtoBuf;

public class CheckSubscription : BaseEntityHandler<AppEmpty>
{
	public override void Execute()
	{
		if (base.Entity is ISubscribable subscribable)
		{
			bool value = subscribable.HasSubscription(base.UserId);
			SendFlag(value);
		}
		else
		{
			SendError("wrong_type");
		}
	}
}


using System.Collections.Generic;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public class ClanChat : BaseClanHandler<AppEmpty>
{
	public override async void Execute()
	{
		IClan val = await GetClan();
		if (val == null)
		{
			((BaseHandler<AppEmpty>)this).SendError("no_clan");
			return;
		}
		ClanValueResult<ClanChatScrollback> val2 = await val.GetChatScrollback();
		if (!val2.IsSuccess)
		{
			SendError(val2.Result);
			return;
		}
		AppResponse val3 = Pool.Get<AppResponse>();
		val3.clanChat = Pool.Get<AppClanChat>();
		val3.clanChat.messages = Pool.Get<List<AppClanMessage>>();
		foreach (ClanChatEntry entry in val2.Value.Entries)
		{
			AppClanMessage val4 = Pool.Get<AppClanMessage>();
			val4.steamId = entry.SteamId;
			val4.name = entry.Name;
			val4.message = entry.Message;
			val4.time = entry.Time;
			val3.clanChat.messages.Add(val4);
		}
		Send(val3);
	}
}


using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public class ClanInfo : BaseClanHandler<AppEmpty>
{
	public override async void Execute()
	{
		IClan clan = await GetClan();
		if (clan == null)
		{
			((BaseHandler<AppEmpty>)this).SendError("no_clan");
			return;
		}
		await clan.RefreshIfStale();
		AppClanInfo val = Pool.Get<AppClanInfo>();
		val.clanInfo = clan.ToProto();
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.clanInfo = val;
		Send(val2);
	}
}


using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public class EntityInfo : BaseEntityHandler<AppEmpty>
{
	public override void Execute()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		AppEntityInfo val = Pool.Get<AppEntityInfo>();
		val.type = base.Entity.Type;
		val.payload = Pool.Get<AppEntityPayload>();
		base.Entity.FillEntityPayload(val.payload);
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.entityInfo = val;
		Send(val2);
	}
}


public enum ValidationResult
{
	Success,
	NotFound,
	RateLimit,
	Banned,
	Rejected
}


using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public interface IHandler : IPooled
{
	AppRequest Request { get; }

	ValidationResult Validate();

	void Execute();

	void SendError(string code);
}


using CompanionServer.Cameras;
using CompanionServer.Handlers;
using ConVar;
using Facepunch;
using Facepunch.Math;
using ProtoBuf;

public class Info : BasePlayerHandler<AppEmpty>
{
	public override void Execute()
	{
		AppInfo val = Pool.Get<AppInfo>();
		val.name = Server.hostname;
		val.headerImage = Server.headerimage;
		val.logoImage = Server.logoimage;
		val.url = Server.url;
		val.map = World.Name;
		val.mapSize = World.Size;
		val.wipeTime = (uint)Epoch.FromDateTime(SaveRestore.SaveCreatedTime.ToUniversalTime());
		val.players = (uint)BasePlayer.activePlayerList.Count;
		val.maxPlayers = (uint)Server.maxplayers;
		val.queuedPlayers = (uint)SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued;
		val.seed = World.Seed;
		val.camerasEnabled = CameraRenderer.enabled;
		if (NexusServer.Started)
		{
			int? nexusId = NexusServer.NexusId;
			string zoneKey = NexusServer.ZoneKey;
			if (nexusId.HasValue && zoneKey != null)
			{
				val.nexus = Nexus.endpoint;
				val.nexusId = nexusId.Value;
				val.nexusZone = zoneKey;
			}
		}
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.info = val;
		Send(val2);
	}
}


using System;
using System.Collections.Generic;
using CompanionServer;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class Map : BasePlayerHandler<AppEmpty>
{
	private static int _width;

	private static int _height;

	private static byte[] _imageData;

	private static string _background;

	public static byte[] ImageData => _imageData;

	protected override double TokenCost => 5.0;

	public override void Execute()
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (_imageData == null)
		{
			SendError("no_map");
			return;
		}
		AppMap val = Pool.Get<AppMap>();
		val.width = (uint)_width;
		val.height = (uint)_height;
		val.oceanMargin = 500;
		val.jpgImage = _imageData;
		val.background = _background;
		val.monuments = Pool.Get<List<Monument>>();
		if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Landmarks != null)
		{
			foreach (LandmarkInfo landmark in TerrainMeta.Path.Landmarks)
			{
				if (landmark.shouldDisplayOnMap)
				{
					Vector2 val2 = Util.WorldToMap(((Component)landmark).transform.position);
					Monument val3 = Pool.Get<Monument>();
					val3.token = (landmark.displayPhrase.IsValid() ? landmark.displayPhrase.token : ((Object)((Component)landmark).transform.root).name);
					val3.x = val2.x;
					val3.y = val2.y;
					val.monuments.Add(val3);
				}
			}
		}
		AppResponse val4 = Pool.Get<AppResponse>();
		val4.map = val;
		Send(val4);
	}

	public static void PopulateCache()
	{
		RenderToCache();
	}

	private static void RenderToCache()
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		_imageData = null;
		_width = 0;
		_height = 0;
		try
		{
			_imageData = MapImageRenderer.Render(out _width, out _height, out var background);
			_background = "#" + ColorUtility.ToHtmlStringRGB(background);
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"Exception thrown when rendering map for the app: {arg}");
		}
		if (_imageData == null)
		{
			Debug.LogError((object)"Map image is null! App users will not be able to see the map.");
		}
	}
}


using System.Collections.Generic;
using CompanionServer;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class MapMarkers : BasePlayerHandler<AppEmpty>
{
	public override void Execute()
	{
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		AppMapMarkers val = Pool.Get<AppMapMarkers>();
		val.markers = Pool.Get<List<AppMarker>>();
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(base.UserId);
		if (playerTeam != null)
		{
			foreach (ulong member in playerTeam.members)
			{
				BasePlayer basePlayer = RelationshipManager.FindByID(member);
				if (!((Object)(object)basePlayer == (Object)null))
				{
					val.markers.Add(GetPlayerMarker(basePlayer));
				}
			}
		}
		else if ((Object)(object)base.Player != (Object)null)
		{
			val.markers.Add(GetPlayerMarker(base.Player));
		}
		foreach (MapMarker serverMapMarker in MapMarker.serverMapMarkers)
		{
			if ((int)serverMapMarker.appType != 0)
			{
				val.markers.Add(serverMapMarker.GetAppMarkerData());
			}
		}
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.mapMarkers = val;
		Send(val2);
	}

	private static AppMarker GetPlayerMarker(BasePlayer player)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		AppMarker obj = Pool.Get<AppMarker>();
		Vector2 val = Util.WorldToMap(((Component)player).transform.position);
		obj.id = player.net.ID;
		obj.type = (AppMarkerType)1;
		obj.x = val.x;
		obj.y = val.y;
		obj.steamId = player.userID;
		return obj;
	}
}


using System.Globalization;
using CompanionServer.Handlers;
using ConVar;
using Facepunch;
using Facepunch.Nexus;
using ProtoBuf;

public class NexusAuth : BaseHandler<AppGetNexusAuth>
{
	public override ValidationResult Validate()
	{
		if (!NexusServer.Started)
		{
			return ValidationResult.NotFound;
		}
		return base.Validate();
	}

	public override async void Execute()
	{
		if (base.Request.playerId == 0L)
		{
			SendError("invalid_playerid");
			return;
		}
		string text = base.Request.playerId.ToString("G", CultureInfo.InvariantCulture);
		NexusPlayer val = await NexusServer.ZoneClient.GetPlayer(text);
		Variable val2 = default(Variable);
		if (val == null || !val.TryGetVariable("appKey", ref val2) || (int)val2.Type != 1 || base.Proto.appKey != val2.GetAsString())
		{
			SendError("access_denied");
			return;
		}
		AppResponse val3 = Pool.Get<AppResponse>();
		val3.nexusAuth = Pool.Get<AppNexusAuth>();
		val3.nexusAuth.serverId = App.serverid;
		val3.nexusAuth.playerToken = SingletonComponent<ServerMgr>.Instance.persistance.GetOrGenerateAppToken(base.Request.playerId, out var _);
		Send(val3);
	}
}


using CompanionServer.Handlers;
using ProtoBuf;

public class PromoteToLeader : BasePlayerHandler<AppPromoteToLeader>
{
	public override void Execute()
	{
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(base.UserId);
		if (playerTeam == null)
		{
			SendError("no_team");
			return;
		}
		if (playerTeam.teamLeader != base.UserId)
		{
			SendError("access_denied");
			return;
		}
		if (playerTeam.teamLeader == base.Proto.steamId)
		{
			SendSuccess();
			return;
		}
		if (!playerTeam.members.Contains(base.Proto.steamId))
		{
			SendError("not_found");
			return;
		}
		playerTeam.SetTeamLeader(base.Proto.steamId);
		SendSuccess();
	}
}


using CompanionServer.Handlers;
using ConVar;
using Facepunch.Extend;
using ProtoBuf;

public class SendClanChat : BaseClanHandler<AppSendMessage>
{
	protected override double TokenCost => 2.0;

	public override async void Execute()
	{
		if (await GetClan() == null)
		{
			((BaseHandler<AppSendMessage>)this).SendError("no_clan");
			return;
		}
		string text = base.Proto.message?.Trim();
		if (string.IsNullOrWhiteSpace(text))
		{
			SendSuccess();
			return;
		}
		text = StringExtensions.Truncate(text, 256, "…");
		string username = base.Player?.displayName ?? SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(base.UserId) ?? "[unknown]";
		if (await Chat.sayAs(Chat.ChatChannel.Clan, base.UserId, username, text, base.Player))
		{
			SendSuccess();
		}
		else
		{
			((BaseHandler<AppSendMessage>)this).SendError("message_not_sent");
		}
	}
}


using CompanionServer.Handlers;
using ConVar;
using Facepunch.Extend;
using ProtoBuf;

public class SendTeamChat : BasePlayerHandler<AppSendMessage>
{
	protected override double TokenCost => 2.0;

	public override async void Execute()
	{
		string text = base.Proto.message?.Trim();
		if (string.IsNullOrWhiteSpace(text))
		{
			SendSuccess();
			return;
		}
		text = StringExtensions.Truncate(text, 256, "…");
		string username = base.Player?.displayName ?? SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(base.UserId) ?? "[unknown]";
		if (await Chat.sayAs(Chat.ChatChannel.Team, base.UserId, username, text, base.Player))
		{
			SendSuccess();
		}
		else
		{
			SendError("message_not_sent");
		}
	}
}


using CompanionServer.Handlers;
using ProtoBuf;

public class SetClanMotd : BaseClanHandler<AppSendMessage>
{
	public override async void Execute()
	{
		string motd = default(string);
		if (!ClanValidator.ValidateMotd(base.Proto.message, ref motd))
		{
			((BaseHandler<AppSendMessage>)this).SendError("invalid_motd");
			return;
		}
		IClan clan = await GetClan();
		if (clan == null)
		{
			((BaseHandler<AppSendMessage>)this).SendError("no_clan");
			return;
		}
		long previousTimestamp = clan.MotdTimestamp;
		ClanResult val = await clan.SetMotd(motd, base.UserId);
		if ((int)val == 1)
		{
			SendSuccess();
			ClanPushNotifications.SendClanAnnouncement(clan, previousTimestamp, base.UserId);
		}
		else
		{
			SendError(val);
		}
	}
}


using CompanionServer.Handlers;
using ProtoBuf;

public class SetEntityValue : BaseEntityHandler<AppSetEntityValue>
{
	public override void Execute()
	{
		if (base.Entity is SmartSwitch smartSwitch)
		{
			smartSwitch.Value = base.Proto.value;
			SendSuccess();
		}
		else
		{
			SendError("wrong_type");
		}
	}
}


using CompanionServer.Handlers;
using ProtoBuf;

public class SetSubscription : BaseEntityHandler<AppFlag>
{
	public override void Execute()
	{
		if (base.Entity is ISubscribable subscribable)
		{
			if (base.Proto.value)
			{
				if (subscribable.AddSubscription(base.UserId))
				{
					SendSuccess();
				}
				else
				{
					SendError("too_many_subscribers");
				}
			}
			else
			{
				subscribable.RemoveSubscription(base.UserId);
			}
			SendSuccess();
		}
		else
		{
			SendError("wrong_type");
		}
	}
}


using System.Collections.Generic;
using CompanionServer;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public class TeamChat : BasePlayerHandler<AppEmpty>
{
	public override void Execute()
	{
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(base.UserId);
		if (playerTeam == null)
		{
			SendError("no_team");
			return;
		}
		AppResponse val = Pool.Get<AppResponse>();
		val.teamChat = Pool.Get<AppTeamChat>();
		val.teamChat.messages = Pool.Get<List<AppTeamMessage>>();
		IReadOnlyList<ChatLog.Entry> history = Server.TeamChat.GetHistory(playerTeam.teamID);
		if (history != null)
		{
			foreach (ChatLog.Entry item in history)
			{
				AppTeamMessage val2 = Pool.Get<AppTeamMessage>();
				val2.steamId = item.SteamId;
				val2.name = item.Name;
				val2.message = item.Message;
				val2.color = item.Color;
				val2.time = item.Time;
				val.teamChat.messages.Add(val2);
			}
		}
		Send(val);
	}
}


using CompanionServer;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public class TeamInfo : BasePlayerHandler<AppEmpty>
{
	public override void Execute()
	{
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(base.UserId);
		AppTeamInfo teamInfo = ((playerTeam == null) ? base.Player.GetAppTeamInfo(base.UserId) : playerTeam.GetAppTeamInfo(base.UserId));
		AppResponse val = Pool.Get<AppResponse>();
		val.teamInfo = teamInfo;
		Send(val);
	}
}


using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class Time : BasePlayerHandler<AppEmpty>
{
	public override void Execute()
	{
		TOD_Sky instance = TOD_Sky.Instance;
		TOD_Time time = instance.Components.Time;
		AppTime val = Pool.Get<AppTime>();
		val.dayLengthMinutes = time.DayLengthInMinutes;
		val.timeScale = (time.ProgressTime ? Time.timeScale : 0f);
		val.sunrise = instance.SunriseTime;
		val.sunset = instance.SunsetTime;
		val.time = instance.Cycle.Hour;
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.time = val;
		Send(val2);
	}
}


public enum CameraRendererState
{
	Invalid,
	WaitingToRender,
	Rendering
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using CompanionServer;
using CompanionServer.Cameras;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;

public class CameraRenderer : IPooled
{
	[ServerVar]
	public static bool enabled = true;

	[ServerVar]
	public static float completionFrameBudgetMs = 5f;

	[ServerVar]
	public static int maxRendersPerFrame = 25;

	[ServerVar]
	public static int maxRaysPerFrame = 100000;

	[ServerVar]
	public static int width = 160;

	[ServerVar]
	public static int height = 90;

	[ServerVar]
	public static float verticalFov = 65f;

	[ServerVar]
	public static float nearPlane = 0f;

	[ServerVar]
	public static float farPlane = 250f;

	[ServerVar]
	public static int layerMask = 1218656529;

	[ServerVar]
	public static float renderInterval = 0.05f;

	[ServerVar]
	public static int samplesPerRender = 3000;

	[ServerVar]
	public static int entityMaxAge = 5;

	[ServerVar]
	public static int entityMaxDistance = 100;

	[ServerVar]
	public static int playerMaxDistance = 30;

	[ServerVar]
	public static int playerNameMaxDistance = 10;

	private static readonly Dictionary<NetworkableId, NetworkableId> _entityIdMap = new Dictionary<NetworkableId, NetworkableId>();

	private readonly Dictionary<int, (byte MaterialIndex, int Age)> _knownColliders = new Dictionary<int, (byte, int)>();

	private readonly Dictionary<int, BaseEntity> _colliderToEntity = new Dictionary<int, BaseEntity>();

	private double _lastRenderTimestamp;

	private float _fieldOfView;

	private int _sampleOffset;

	private int _nextSampleOffset;

	private int _sampleCount;

	private CameraRenderTask _task;

	private ulong? _cachedViewerSteamId;

	private BasePlayer _cachedViewer;

	public CameraRendererState state;

	public IRemoteControllable rc;

	public BaseEntity entity;

	public CameraRenderer()
	{
		Reset();
	}

	public void EnterPool()
	{
		Reset();
	}

	public void LeavePool()
	{
	}

	public void Reset()
	{
		_knownColliders.Clear();
		_colliderToEntity.Clear();
		_lastRenderTimestamp = 0.0;
		_fieldOfView = 0f;
		_sampleOffset = 0;
		_nextSampleOffset = 0;
		_sampleCount = 0;
		if (_task != null)
		{
			CameraRendererManager instance = SingletonComponent<CameraRendererManager>.Instance;
			if ((Object)(object)instance != (Object)null)
			{
				instance.ReturnTask(ref _task);
			}
		}
		_cachedViewerSteamId = null;
		_cachedViewer = null;
		state = CameraRendererState.Invalid;
		rc = null;
		entity = null;
	}

	public void Init(IRemoteControllable remoteControllable)
	{
		if (remoteControllable == null)
		{
			throw new ArgumentNullException("remoteControllable");
		}
		rc = remoteControllable;
		entity = remoteControllable.GetEnt();
		if ((Object)(object)entity == (Object)null || !entity.IsValid())
		{
			throw new ArgumentException("RemoteControllable's entity is null or invalid", "rc");
		}
		state = CameraRendererState.WaitingToRender;
	}

	public bool CanRender()
	{
		if (state != CameraRendererState.WaitingToRender)
		{
			return false;
		}
		if (TimeEx.realtimeSinceStartup - _lastRenderTimestamp < (double)renderInterval)
		{
			return false;
		}
		return true;
	}

	public void Render(int maxSampleCount)
	{
		CameraRendererManager instance = SingletonComponent<CameraRendererManager>.Instance;
		if ((Object)(object)instance == (Object)null)
		{
			state = CameraRendererState.Invalid;
			return;
		}
		if (state != CameraRendererState.WaitingToRender)
		{
			throw new InvalidOperationException($"CameraRenderer cannot render in state {state}");
		}
		if (rc.IsUnityNull() || !entity.IsValid())
		{
			state = CameraRendererState.Invalid;
			return;
		}
		Transform eyes = rc.GetEyes();
		if ((Object)(object)eyes == (Object)null)
		{
			state = CameraRendererState.Invalid;
			return;
		}
		if (_task != null)
		{
			Debug.LogError((object)"CameraRenderer: Trying to render but a task is already allocated?", (Object)(object)entity);
			instance.ReturnTask(ref _task);
		}
		_fieldOfView = verticalFov / Mathf.Clamp(rc.GetFovScale(), 1f, 8f);
		_sampleCount = Mathf.Clamp(samplesPerRender, 1, Mathf.Min(width * height, maxSampleCount));
		_task = instance.BorrowTask();
		_nextSampleOffset = _task.Start(width, height, _fieldOfView, nearPlane, farPlane, layerMask, eyes, _sampleCount, _sampleOffset, _knownColliders);
		state = CameraRendererState.Rendering;
	}

	public void CompleteRender()
	{
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0432: Unknown result type (might be due to invalid IL or missing references)
		//IL_044c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036a: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0382: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_0389: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03af: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c5: Unknown result type (might be due to invalid IL or missing references)
		CameraRendererManager instance = SingletonComponent<CameraRendererManager>.Instance;
		if ((Object)(object)instance == (Object)null)
		{
			state = CameraRendererState.Invalid;
			return;
		}
		if (state != CameraRendererState.Rendering)
		{
			throw new InvalidOperationException($"CameraRenderer cannot complete render in state {state}");
		}
		if (_task == null)
		{
			Debug.LogError((object)"CameraRenderer: Trying to complete render but no task is allocated?", (Object)(object)entity);
			state = CameraRendererState.Invalid;
		}
		else
		{
			if (((CustomYieldInstruction)_task).keepWaiting)
			{
				return;
			}
			if (rc.IsUnityNull() || !entity.IsValid())
			{
				instance.ReturnTask(ref _task);
				state = CameraRendererState.Invalid;
				return;
			}
			Transform eyes = rc.GetEyes();
			if ((Object)(object)eyes == (Object)null)
			{
				instance.ReturnTask(ref _task);
				state = CameraRendererState.Invalid;
				return;
			}
			int num = _sampleCount * 4;
			byte[] array = Shared.ArrayPool.Rent(num);
			List<int> hitColliderIds = Pool.Get<List<int>>();
			List<int> foundColliderIds = Pool.Get<List<int>>();
			int count = _task.ExtractRayData(array, hitColliderIds, foundColliderIds);
			instance.ReturnTask(ref _task);
			UpdateCollidersMap(foundColliderIds);
			Pool.FreeUnmanaged<int>(ref hitColliderIds);
			Pool.FreeUnmanaged<int>(ref foundColliderIds);
			ulong num2 = rc.ControllingViewerId?.SteamId ?? 0;
			if (num2 == 0L)
			{
				_cachedViewerSteamId = null;
				_cachedViewer = null;
			}
			else if (num2 != _cachedViewerSteamId)
			{
				_cachedViewerSteamId = num2;
				_cachedViewer = BasePlayer.FindByID(num2) ?? BasePlayer.FindSleeping(num2);
			}
			float distance = (_cachedViewer.IsValid() ? Mathf.Clamp01(Vector3.Distance(((Component)_cachedViewer).transform.position, ((Component)entity).transform.position) / rc.MaxRange) : 0f);
			Vector3 position = eyes.position;
			Quaternion rotation = eyes.rotation;
			Matrix4x4 worldToLocalMatrix = eyes.worldToLocalMatrix;
			NetworkableId iD = entity.net.ID;
			_entityIdMap.Clear();
			AppBroadcast val = Pool.Get<AppBroadcast>();
			val.cameraRays = Pool.Get<AppCameraRays>();
			val.cameraRays.verticalFov = _fieldOfView;
			val.cameraRays.sampleOffset = _sampleOffset;
			val.cameraRays.rayData = new ArraySegment<byte>(array, 0, count);
			val.cameraRays.distance = distance;
			val.cameraRays.entities = Pool.Get<List<Entity>>();
			val.cameraRays.timeOfDay = (((Object)(object)TOD_Sky.Instance != (Object)null) ? TOD_Sky.Instance.LerpValue : 1f);
			foreach (BaseEntity value in _colliderToEntity.Values)
			{
				if (!value.IsValid())
				{
					continue;
				}
				Vector3 position2 = ((Component)value).transform.position;
				float num3 = Vector3.Distance(position2, position);
				if (num3 > (float)entityMaxDistance)
				{
					continue;
				}
				string name = null;
				if (value is BasePlayer basePlayer)
				{
					if (num3 > (float)playerMaxDistance)
					{
						continue;
					}
					if (num3 <= (float)playerNameMaxDistance)
					{
						name = basePlayer.displayName;
					}
				}
				Entity val2 = Pool.Get<Entity>();
				val2.entityId = RandomizeEntityId(value.net.ID);
				val2.type = (EntityType)((value is TreeEntity) ? 1 : 2);
				val2.position = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint3x4(position2);
				Quaternion val3 = Quaternion.Inverse(((Component)value).transform.rotation) * rotation;
				val2.rotation = ((Quaternion)(ref val3)).eulerAngles * (MathF.PI / 180f);
				val2.size = Vector3.Scale(((Bounds)(ref value.bounds)).size, ((Component)value).transform.localScale);
				val2.name = name;
				val.cameraRays.entities.Add(val2);
			}
			val.cameraRays.entities.Sort((Entity x, Entity y) => x.entityId.Value.CompareTo(y.entityId.Value));
			Server.Broadcast(new CameraTarget(iD), val);
			_sampleOffset = _nextSampleOffset;
			if (!Server.HasAnySubscribers(new CameraTarget(iD)))
			{
				state = CameraRendererState.Invalid;
				return;
			}
			_lastRenderTimestamp = TimeEx.realtimeSinceStartup;
			state = CameraRendererState.WaitingToRender;
		}
	}

	private void UpdateCollidersMap(List<int> foundColliderIds)
	{
		List<int> list = Pool.Get<List<int>>();
		foreach (int key in _knownColliders.Keys)
		{
			list.Add(key);
		}
		List<int> list2 = Pool.Get<List<int>>();
		foreach (int item2 in list)
		{
			if (_knownColliders.TryGetValue(item2, out (byte, int) value))
			{
				if (value.Item2 > entityMaxAge)
				{
					list2.Add(item2);
				}
				else
				{
					_knownColliders[item2] = (value.Item1, value.Item2 + 1);
				}
			}
		}
		Pool.FreeUnmanaged<int>(ref list);
		foreach (int item3 in list2)
		{
			_knownColliders.Remove(item3);
			_colliderToEntity.Remove(item3);
		}
		Pool.FreeUnmanaged<int>(ref list2);
		foreach (int foundColliderId in foundColliderIds)
		{
			if (_knownColliders.Count >= 512)
			{
				break;
			}
			Collider collider = CameraBurstUtil.GetCollider(foundColliderId);
			if ((Object)(object)collider == (Object)null)
			{
				continue;
			}
			byte item;
			if (collider is TerrainCollider)
			{
				item = 1;
			}
			else
			{
				BaseEntity baseEntity = collider.ToBaseEntity();
				item = GetMaterialIndex(collider.sharedMaterial, baseEntity);
				if (baseEntity is TreeEntity || baseEntity is BasePlayer)
				{
					_colliderToEntity[foundColliderId] = baseEntity;
				}
			}
			_knownColliders[foundColliderId] = (item, 0);
		}
	}

	private static NetworkableId RandomizeEntityId(NetworkableId realId)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (_entityIdMap.TryGetValue(realId, out var value))
		{
			return value;
		}
		NetworkableId val = default(NetworkableId);
		do
		{
			((NetworkableId)(ref val))..ctor((ulong)Random.Range(0, 2500));
		}
		while (_entityIdMap.ContainsKey(val));
		_entityIdMap.Add(realId, val);
		return val;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static byte GetMaterialIndex(PhysicMaterial material, BaseEntity entity)
	{
		switch (material.GetName())
		{
		case "Water":
			return 2;
		case "Rock":
			return 3;
		case "Stones":
			return 4;
		case "Wood":
			return 5;
		case "Metal":
			return 6;
		default:
			if ((Object)(object)entity != (Object)null && entity is BasePlayer)
			{
				return 7;
			}
			return 0;
		}
	}
}


using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

public struct RaycastSamplePositionsJob : IJob
{
	public int2 res;

	public Random random;

	public NativeArray<int2> positions;

	public void Execute()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < res.y; i++)
		{
			for (int j = 0; j < res.x; j++)
			{
				positions[num++] = new int2(j, i);
			}
		}
		for (num = res.x * res.y - 1; num >= 1; num--)
		{
			int num2 = ((Random)(ref random)).NextInt(num + 1);
			ref NativeArray<int2> reference = ref positions;
			int num3 = num;
			ref NativeArray<int2> reference2 = ref positions;
			int num4 = num2;
			int2 val = positions[num2];
			int2 val2 = positions[num];
			int2 val4 = (reference[num3] = val);
			val4 = (reference2[num4] = val2);
		}
	}
}


using Unity.Collections;
using Unity.Jobs;

public struct RaycastBufferSetupJob : IJob
{
	public NativeArray<int> colliderIds;

	public NativeArray<byte> colliderMaterials;

	[WriteOnly]
	public NativeArray<int> colliderHits;

	public void Execute()
	{
		if (colliderIds.Length > 1)
		{
			SortByAscending(ref colliderIds, ref colliderMaterials, 0, colliderIds.Length - 1);
		}
		for (int i = 0; i < colliderHits.Length; i++)
		{
			colliderHits[i] = 0;
		}
	}

	private static void SortByAscending(ref NativeArray<int> colliderIds, ref NativeArray<byte> colliderMaterials, int leftIndex, int rightIndex)
	{
		int i = leftIndex;
		int num = rightIndex;
		int num2 = colliderIds[leftIndex];
		while (i <= num)
		{
			for (; colliderIds[i] < num2; i++)
			{
			}
			while (colliderIds[num] > num2)
			{
				num--;
			}
			if (i <= num)
			{
				int num3 = i;
				int num4 = num;
				int num5 = colliderIds[num];
				int num6 = colliderIds[i];
				int num8 = (colliderIds[num3] = num5);
				num8 = (colliderIds[num4] = num6);
				num4 = i;
				num3 = num;
				byte b = colliderMaterials[num];
				byte b2 = colliderMaterials[i];
				byte b4 = (colliderMaterials[num4] = b);
				b4 = (colliderMaterials[num3] = b2);
				i++;
				num--;
			}
		}
		if (leftIndex < num)
		{
			SortByAscending(ref colliderIds, ref colliderMaterials, leftIndex, num);
		}
		if (i < rightIndex)
		{
			SortByAscending(ref colliderIds, ref colliderMaterials, i, rightIndex);
		}
	}
}


using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public struct RaycastRaySetupJob : IJobParallelFor
{
	public float2 res;

	public float2 halfRes;

	public float aspectRatio;

	public float worldHeight;

	public float3 cameraPos;

	public quaternion cameraRot;

	public float nearPlane;

	public float farPlane;

	public int layerMask;

	public int sampleOffset;

	[ReadOnly]
	public NativeArray<int2> samplePositions;

	[NativeMatchesParallelForLength]
	[WriteOnly]
	public NativeArray<RaycastCommand> raycastCommands;

	public void Execute(int index)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		int num;
		for (num = sampleOffset + index; num >= samplePositions.Length; num -= samplePositions.Length)
		{
		}
		float2 val = (float2.op_Implicit(samplePositions[num]) - halfRes) / res;
		float3 val2 = default(float3);
		((float3)(ref val2))..ctor(val.x * worldHeight * aspectRatio, val.y * worldHeight, 1f);
		float3 val3 = math.mul(cameraRot, val2);
		float3 val4 = cameraPos + val3 * nearPlane;
		raycastCommands[index] = new RaycastCommand(float3.op_Implicit(val4), float3.op_Implicit(val3), farPlane, layerMask, 1);
	}
}


using System.Threading;
using CompanionServer.Cameras;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public struct RaycastRayProcessingJob : IJobParallelFor
{
	public float3 cameraForward;

	public float farPlane;

	[ReadOnly]
	public NativeArray<RaycastHit> raycastHits;

	[ReadOnly]
	public NativeArray<int> colliderIds;

	[ReadOnly]
	public NativeArray<byte> colliderMaterials;

	[WriteOnly]
	[NativeDisableParallelForRestriction]
	public NativeArray<int> colliderHits;

	[WriteOnly]
	[NativeMatchesParallelForLength]
	public NativeArray<int> outputs;

	[NativeDisableParallelForRestriction]
	public NativeArray<int> foundCollidersIndex;

	[NativeDisableParallelForRestriction]
	public NativeArray<int> foundColliders;

	public void Execute(int index)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		ref RaycastHit @readonly = BurstUtil.GetReadonly<RaycastHit>(ref raycastHits, index);
		int colliderId = @readonly.GetColliderId();
		bool num = colliderId != 0;
		byte b = 0;
		if (num)
		{
			int num2 = Interlocked.Increment(ref BurstUtil.Get<int>(ref foundCollidersIndex, 0));
			if (num2 <= foundColliders.Length)
			{
				foundColliders[num2 - 1] = colliderId;
			}
			int num3 = BinarySearch(colliderIds, colliderId);
			if (num3 >= 0)
			{
				b = colliderMaterials[num3];
				Interlocked.Increment(ref BurstUtil.Get<int>(ref colliderHits, num3));
			}
		}
		float distance;
		RaycastHit val;
		if (!num)
		{
			distance = farPlane;
		}
		else
		{
			val = @readonly;
			distance = ((RaycastHit)(ref val)).distance;
		}
		float num4 = distance;
		if (b == 7)
		{
			b = 0;
			num4 *= 1.1f;
		}
		float num5 = math.clamp(num4 / farPlane, 0f, 1f);
		float3 val2 = cameraForward;
		val = @readonly;
		float num6 = math.max(math.dot(val2, float3.op_Implicit(((RaycastHit)(ref val)).normal)), 0f);
		ushort num7 = (ushort)(num5 * 1023f);
		byte b2 = (byte)(num6 * 63f);
		outputs[index] = (num7 >> 8 << 24) | ((num7 & 0xFF) << 16) | (b2 << 8) | b;
	}

	private static int BinarySearch(NativeArray<int> haystack, int needle)
	{
		int num = 0;
		int num2 = haystack.Length - 1;
		while (num <= num2)
		{
			int num3 = num + (num2 - num / 2);
			int num4 = Compare(haystack[num3], needle);
			if (num4 == 0)
			{
				return num3;
			}
			if (num4 < 0)
			{
				num = num3 + 1;
			}
			else
			{
				num2 = num3 - 1;
			}
		}
		return ~num;
	}

	private static int Compare(int x, int y)
	{
		if (x < y)
		{
			return -1;
		}
		if (x > y)
		{
			return 1;
		}
		return 0;
	}
}


using System;
using System.Runtime.CompilerServices;
using Unity.Collections;
using Unity.Jobs;

public struct RaycastOutputCompressJob : IJob
{
	[ReadOnly]
	public NativeArray<int> rayOutputs;

	[WriteOnly]
	public NativeArray<int> dataLength;

	[WriteOnly]
	public NativeArray<byte> data;

	public void Execute()
	{
		int num = rayOutputs.Length * 4;
		if (data.Length < num)
		{
			throw new InvalidOperationException("Not enough data buffer available to compress rays");
		}
		NativeArray<int> val = default(NativeArray<int>);
		val..ctor(64, (Allocator)2, (NativeArrayOptions)1);
		int num2 = 0;
		for (int i = 0; i < rayOutputs.Length; i++)
		{
			int num3 = rayOutputs[i];
			ushort num4 = RayDistance(num3);
			byte b = RayAlignment(num3);
			byte b2 = RayMaterial(num3);
			int num5 = (num4 / 128 * 3 + b / 16 * 5 + b2 * 7) & 0x3F;
			int num6 = val[num5];
			if (num6 == num3)
			{
				data[num2++] = (byte)(0 | num5);
				continue;
			}
			int num7 = num4 - RayDistance(num6);
			int num8 = b - RayAlignment(num6);
			if (b2 == RayMaterial(num6) && num7 >= -15 && num7 <= 16 && num8 >= -3 && num8 <= 4)
			{
				data[num2++] = (byte)(0x40 | num5);
				data[num2++] = (byte)((num7 + 15 << 3) | (num8 + 3));
			}
			else if (b2 == RayMaterial(num6) && num8 == 0 && num7 >= -127 && num7 <= 128)
			{
				data[num2++] = (byte)(0x80 | num5);
				data[num2++] = (byte)(num7 + 127);
			}
			else if (b2 < 63)
			{
				val[num5] = num3;
				data[num2++] = (byte)(0xC0 | b2);
				data[num2++] = (byte)(num4 >> 2);
				data[num2++] = (byte)(((num4 & 3) << 6) | b);
			}
			else
			{
				val[num5] = num3;
				data[num2++] = byte.MaxValue;
				data[num2++] = (byte)(num4 >> 2);
				data[num2++] = (byte)(((num4 & 3) << 6) | b);
				data[num2++] = b2;
			}
		}
		val.Dispose();
		dataLength[0] = num2;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static ushort RayDistance(int ray)
	{
		return (ushort)(ray >> 16);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static byte RayAlignment(int ray)
	{
		return (byte)(ray >> 8);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static byte RayMaterial(int ray)
	{
		return (byte)ray;
	}
}


using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

public struct RaycastColliderProcessingJob : IJob
{
	public NativeArray<int> foundCollidersLength;

	public NativeArray<int> foundColliders;

	public void Execute()
	{
		int num = math.min(foundCollidersLength[0], foundColliders.Length);
		if (num <= 1)
		{
			return;
		}
		SortAscending(ref foundColliders, 0, num - 1);
		NativeArray<int> counts = default(NativeArray<int>);
		counts..ctor(num, (Allocator)2, (NativeArrayOptions)0);
		int num2 = 0;
		int i = 0;
		while (i < num)
		{
			int num3 = foundColliders[i];
			int num4 = 1;
			for (; i < num && foundColliders[i] == num3; i++)
			{
				num4++;
			}
			foundColliders[num2] = num3;
			counts[num2] = num4;
			num2++;
		}
		SortByDescending(ref foundColliders, ref counts, 0, num2 - 1);
		counts.Dispose();
		int num5 = math.min(num2, 512);
		foundCollidersLength[0] = num5;
	}

	private static void SortByDescending(ref NativeArray<int> colliders, ref NativeArray<int> counts, int leftIndex, int rightIndex)
	{
		int i = leftIndex;
		int num = rightIndex;
		int num2 = counts[leftIndex];
		while (i <= num)
		{
			for (; counts[i] > num2; i++)
			{
			}
			while (counts[num] < num2)
			{
				num--;
			}
			if (i <= num)
			{
				int num3 = i;
				ref NativeArray<int> reference = ref colliders;
				int num4 = num;
				int num5 = colliders[num];
				int num6 = colliders[i];
				int num8 = (colliders[num3] = num5);
				num8 = (reference[num4] = num6);
				num4 = i;
				reference = ref counts;
				num3 = num;
				num6 = counts[num];
				num5 = counts[i];
				num8 = (counts[num4] = num6);
				num8 = (reference[num3] = num5);
				i++;
				num--;
			}
		}
		if (leftIndex < num)
		{
			SortByDescending(ref colliders, ref counts, leftIndex, num);
		}
		if (i < rightIndex)
		{
			SortByDescending(ref colliders, ref counts, i, rightIndex);
		}
	}

	private static void SortAscending(ref NativeArray<int> array, int leftIndex, int rightIndex)
	{
		int i = leftIndex;
		int num = rightIndex;
		int num2 = array[leftIndex];
		while (i <= num)
		{
			for (; array[i] < num2; i++)
			{
			}
			while (array[num] > num2)
			{
				num--;
			}
			if (i <= num)
			{
				int num3 = i;
				int num4 = num;
				int num5 = array[num];
				int num6 = array[i];
				int num8 = (array[num3] = num5);
				num8 = (array[num4] = num6);
				i++;
				num--;
			}
		}
		if (leftIndex < num)
		{
			SortAscending(ref array, leftIndex, num);
		}
		if (i < rightIndex)
		{
			SortAscending(ref array, i, rightIndex);
		}
	}
}


using System.Runtime.CompilerServices;
using CompanionServer.Cameras;
using UnityEngine;

internal static class CameraBurstUtil
{
	private struct RaycastHitPublic
	{
		public Vector3 m_Point;

		public Vector3 m_Normal;

		public uint m_FaceID;

		public float m_Distance;

		public Vector2 m_UV;

		public int m_Collider;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int GetColliderId(this RaycastHit hit)
	{
		return ((RaycastHit)(ref hit)).colliderInstanceID;
	}

	public unsafe static Collider GetCollider(int colliderInstanceId)
	{
		RaycastHitPublic raycastHitPublic = default(RaycastHitPublic);
		raycastHitPublic.m_Collider = colliderInstanceId;
		RaycastHitPublic raycastHitPublic2 = raycastHitPublic;
		return ((RaycastHit)(&raycastHitPublic2)).collider;
	}
}


using UnityEngine;

private struct RaycastHitPublic
{
	public Vector3 m_Point;

	public Vector3 m_Normal;

	public uint m_FaceID;

	public float m_Distance;

	public Vector2 m_UV;

	public int m_Collider;
}


using System;
using System.Collections.Generic;
using CompanionServer.Cameras;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public class CameraRenderTask : CustomYieldInstruction, IDisposable
{
	public const int MaxSamplesPerRender = 10000;

	public const int MaxColliders = 512;

	private static readonly Dictionary<(int, int), NativeArray<int2>> _samplePositions = new Dictionary<(int, int), NativeArray<int2>>();

	private NativeArray<RaycastCommand> _raycastCommands;

	private NativeArray<RaycastHit> _raycastHits;

	private NativeArray<int> _colliderIds;

	private NativeArray<byte> _colliderMaterials;

	private NativeArray<int> _colliderHits;

	private NativeArray<int> _raycastOutput;

	private NativeArray<int> _foundCollidersLength;

	private NativeArray<int> _foundColliders;

	private NativeArray<int> _outputDataLength;

	private NativeArray<byte> _outputData;

	private JobHandle? _pendingJob;

	private int _sampleCount;

	private int _colliderLength;

	public override bool keepWaiting
	{
		get
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (_pendingJob.HasValue)
			{
				JobHandle value = _pendingJob.Value;
				return !((JobHandle)(ref value)).IsCompleted;
			}
			return false;
		}
	}

	public CameraRenderTask()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		_raycastCommands = new NativeArray<RaycastCommand>(10000, (Allocator)4, (NativeArrayOptions)1);
		_raycastHits = new NativeArray<RaycastHit>(10000, (Allocator)4, (NativeArrayOptions)0);
		_colliderIds = new NativeArray<int>(512, (Allocator)4, (NativeArrayOptions)0);
		_colliderMaterials = new NativeArray<byte>(512, (Allocator)4, (NativeArrayOptions)0);
		_colliderHits = new NativeArray<int>(512, (Allocator)4, (NativeArrayOptions)0);
		_raycastOutput = new NativeArray<int>(10000, (Allocator)4, (NativeArrayOptions)0);
		_foundCollidersLength = new NativeArray<int>(1, (Allocator)4, (NativeArrayOptions)0);
		_foundColliders = new NativeArray<int>(10000, (Allocator)4, (NativeArrayOptions)0);
		_outputDataLength = new NativeArray<int>(1, (Allocator)4, (NativeArrayOptions)0);
		_outputData = new NativeArray<byte>(40000, (Allocator)4, (NativeArrayOptions)0);
	}

	~CameraRenderTask()
	{
		try
		{
			Dispose();
		}
		finally
		{
			((object)this).Finalize();
		}
	}

	public void Dispose()
	{
		_raycastCommands.Dispose();
		_raycastHits.Dispose();
		_colliderIds.Dispose();
		_colliderMaterials.Dispose();
		_colliderHits.Dispose();
		_raycastOutput.Dispose();
		_foundCollidersLength.Dispose();
		_foundColliders.Dispose();
		_outputDataLength.Dispose();
		_outputData.Dispose();
	}

	public void Reset()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (_pendingJob.HasValue)
		{
			JobHandle value = _pendingJob.Value;
			if (!((JobHandle)(ref value)).IsCompleted)
			{
				Debug.LogWarning((object)"CameraRenderTask is resetting before completion! This will cause it to synchronously block for completion.");
			}
			value = _pendingJob.Value;
			((JobHandle)(ref value)).Complete();
		}
		_pendingJob = null;
		_sampleCount = 0;
	}

	public int Start(int width, int height, float verticalFov, float nearPlane, float farPlane, int layerMask, Transform cameraTransform, int sampleCount, int sampleOffset, Dictionary<int, (byte MaterialIndex, int Age)> knownColliders)
	{
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_034a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_039e: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c5: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cameraTransform == (Object)null)
		{
			throw new ArgumentNullException("cameraTransform");
		}
		if (sampleCount <= 0 || sampleCount > 10000)
		{
			throw new ArgumentOutOfRangeException("sampleCount");
		}
		if (sampleOffset < 0)
		{
			throw new ArgumentOutOfRangeException("sampleOffset");
		}
		if (knownColliders == null)
		{
			throw new ArgumentNullException("knownColliders");
		}
		if (knownColliders.Count > 512)
		{
			throw new ArgumentException("Too many colliders", "knownColliders");
		}
		if (_pendingJob.HasValue)
		{
			throw new InvalidOperationException("A render job was already started for this instance.");
		}
		_sampleCount = sampleCount;
		_colliderLength = knownColliders.Count;
		int num = 0;
		foreach (KeyValuePair<int, (byte, int)> knownCollider in knownColliders)
		{
			_colliderIds[num] = knownCollider.Key;
			_colliderMaterials[num] = knownCollider.Value.Item1;
			num++;
		}
		NativeArray<int2> samplePositions = GetSamplePositions(width, height);
		_foundCollidersLength[0] = 0;
		RaycastBufferSetupJob raycastBufferSetupJob = default(RaycastBufferSetupJob);
		raycastBufferSetupJob.colliderIds = _colliderIds.GetSubArray(0, _colliderLength);
		raycastBufferSetupJob.colliderMaterials = _colliderMaterials.GetSubArray(0, _colliderLength);
		raycastBufferSetupJob.colliderHits = _colliderHits.GetSubArray(0, _colliderLength);
		RaycastBufferSetupJob raycastBufferSetupJob2 = raycastBufferSetupJob;
		RaycastRaySetupJob raycastRaySetupJob = default(RaycastRaySetupJob);
		raycastRaySetupJob.res = new float2((float)width, (float)height);
		raycastRaySetupJob.halfRes = new float2((float)width / 2f, (float)height / 2f);
		raycastRaySetupJob.aspectRatio = (float)width / (float)height;
		raycastRaySetupJob.worldHeight = 2f * Mathf.Tan(MathF.PI / 360f * verticalFov);
		raycastRaySetupJob.cameraPos = float3.op_Implicit(cameraTransform.position);
		raycastRaySetupJob.cameraRot = quaternion.op_Implicit(cameraTransform.rotation);
		raycastRaySetupJob.nearPlane = nearPlane;
		raycastRaySetupJob.farPlane = farPlane;
		raycastRaySetupJob.layerMask = layerMask;
		raycastRaySetupJob.samplePositions = samplePositions;
		raycastRaySetupJob.sampleOffset = sampleOffset % samplePositions.Length;
		raycastRaySetupJob.raycastCommands = _raycastCommands.GetSubArray(0, sampleCount);
		RaycastRaySetupJob raycastRaySetupJob2 = raycastRaySetupJob;
		RaycastRayProcessingJob raycastRayProcessingJob = default(RaycastRayProcessingJob);
		raycastRayProcessingJob.cameraForward = float3.op_Implicit(-cameraTransform.forward);
		raycastRayProcessingJob.farPlane = farPlane;
		raycastRayProcessingJob.raycastHits = _raycastHits.GetSubArray(0, sampleCount);
		raycastRayProcessingJob.colliderIds = _colliderIds.GetSubArray(0, _colliderLength);
		raycastRayProcessingJob.colliderMaterials = _colliderMaterials.GetSubArray(0, _colliderLength);
		raycastRayProcessingJob.colliderHits = _colliderHits.GetSubArray(0, _colliderLength);
		raycastRayProcessingJob.outputs = _raycastOutput.GetSubArray(0, sampleCount);
		raycastRayProcessingJob.foundCollidersIndex = _foundCollidersLength;
		raycastRayProcessingJob.foundColliders = _foundColliders;
		RaycastRayProcessingJob raycastRayProcessingJob2 = raycastRayProcessingJob;
		RaycastColliderProcessingJob raycastColliderProcessingJob = default(RaycastColliderProcessingJob);
		raycastColliderProcessingJob.foundCollidersLength = _foundCollidersLength;
		raycastColliderProcessingJob.foundColliders = _foundColliders;
		RaycastColliderProcessingJob raycastColliderProcessingJob2 = raycastColliderProcessingJob;
		RaycastOutputCompressJob raycastOutputCompressJob = default(RaycastOutputCompressJob);
		raycastOutputCompressJob.rayOutputs = _raycastOutput.GetSubArray(0, sampleCount);
		raycastOutputCompressJob.dataLength = _outputDataLength;
		raycastOutputCompressJob.data = _outputData;
		RaycastOutputCompressJob raycastOutputCompressJob2 = raycastOutputCompressJob;
		JobHandle val = IJobExtensions.Schedule<RaycastBufferSetupJob>(raycastBufferSetupJob2, default(JobHandle));
		JobHandle val2 = IJobParallelForExtensions.Schedule<RaycastRaySetupJob>(raycastRaySetupJob2, sampleCount, 100, default(JobHandle));
		JobHandle val3 = RaycastCommand.ScheduleBatch(_raycastCommands.GetSubArray(0, sampleCount), _raycastHits.GetSubArray(0, sampleCount), 100, val2);
		JobHandle val4 = IJobParallelForExtensions.Schedule<RaycastRayProcessingJob>(raycastRayProcessingJob2, sampleCount, 100, JobHandle.CombineDependencies(val, val3));
		JobHandle val5 = IJobExtensions.Schedule<RaycastColliderProcessingJob>(raycastColliderProcessingJob2, val4);
		JobHandle val6 = IJobExtensions.Schedule<RaycastOutputCompressJob>(raycastOutputCompressJob2, val4);
		_pendingJob = JobHandle.CombineDependencies(val6, val5);
		return sampleOffset + sampleCount;
	}

	public int ExtractRayData(byte[] buffer, List<int> hitColliderIds = null, List<int> foundColliderIds = null)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		if (buffer == null)
		{
			throw new ArgumentNullException("buffer");
		}
		int num = _sampleCount * 4;
		if (buffer.Length < num)
		{
			throw new ArgumentException("Output buffer is not large enough to hold all the ray data", "buffer");
		}
		if (!_pendingJob.HasValue)
		{
			throw new InvalidOperationException("Job was not started for this CameraRenderTask");
		}
		JobHandle value = _pendingJob.Value;
		if (!((JobHandle)(ref value)).IsCompleted)
		{
			Debug.LogWarning((object)"Trying to extract ray data from CameraRenderTask before completion! This will cause it to synchronously block for completion.");
		}
		value = _pendingJob.Value;
		((JobHandle)(ref value)).Complete();
		int num2 = _outputDataLength[0];
		NativeArray<byte>.Copy(_outputData.GetSubArray(0, num2), buffer, num2);
		if (hitColliderIds != null)
		{
			hitColliderIds.Clear();
			for (int i = 0; i < _colliderLength; i++)
			{
				if (_colliderHits[i] > 0)
				{
					hitColliderIds.Add(_colliderIds[i]);
				}
			}
		}
		if (foundColliderIds != null)
		{
			foundColliderIds.Clear();
			int num3 = _foundCollidersLength[0];
			for (int j = 0; j < num3; j++)
			{
				foundColliderIds.Add(_foundColliders[j]);
			}
		}
		return num2;
	}

	private static NativeArray<int2> GetSamplePositions(int width, int height)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (width <= 0)
		{
			throw new ArgumentOutOfRangeException("width");
		}
		if (height <= 0)
		{
			throw new ArgumentOutOfRangeException("height");
		}
		(int, int) key = (width, height);
		if (_samplePositions.TryGetValue(key, out var value))
		{
			return value;
		}
		value..ctor(width * height, (Allocator)4, (NativeArrayOptions)0);
		RaycastSamplePositionsJob raycastSamplePositionsJob = default(RaycastSamplePositionsJob);
		raycastSamplePositionsJob.res = new int2(width, height);
		raycastSamplePositionsJob.random = new Random(1337u);
		raycastSamplePositionsJob.positions = value;
		IJobExtensions.Run<RaycastSamplePositionsJob>(raycastSamplePositionsJob);
		_samplePositions.Add(key, value);
		return value;
	}

	public static void FreeCachedSamplePositions()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		foreach (KeyValuePair<(int, int), NativeArray<int2>> samplePosition in _samplePositions)
		{
			samplePosition.Value.Dispose();
		}
		_samplePositions.Clear();
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct GatherPlayersWithTicksJob : IJob
{
	[WriteOnly]
	public NativeList<int> ValidIndices;

	[ReadOnly]
	public TickInterpolatorCache.ReadOnlyState TickCache;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<int> enumerator = Indices.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				int current = enumerator.Current;
				if (TickCache.Infos[current].Count > 0)
				{
					ValidIndices.AddNoResize(current);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct BuildLayerMasksJob : IJob
{
	[WriteOnly]
	public NativeList<int> LayerMasks;

	[ReadOnly]
	internal ReadOnly<AntiHack.Batch> Batches;

	[ReadOnly]
	public int DefaultMask;

	[ReadOnly]
	public int NoVehiclesMask;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<AntiHack.Batch> enumerator = Batches.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				AntiHack.Batch current = enumerator.Current;
				int num = (current.ExcludeVehicleLayer ? NoVehiclesMask : DefaultMask);
				for (int i = 0; i < current.Count; i++)
				{
					LayerMasks.AddNoResize(num);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct GatherHitIndicesJob : IJob
{
	[WriteOnly]
	public NativeList<int> Results;

	[ReadOnly]
	public ReadOnly<bool> Hits;

	public void Execute()
	{
		for (int i = 0; i < Hits.Length; i++)
		{
			if (Hits[i])
			{
				Results.AddNoResize(i);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct BuildBatchLookupMapJob : IJob
{
	[WriteOnly]
	public NativeArray<int> Lookup;

	[ReadOnly]
	internal ReadOnly<AntiHack.Batch> Batches;

	public void Execute()
	{
		int num = 0;
		for (int i = 0; i < Batches.Length; i++)
		{
			AntiHack.Batch batch = Batches[i];
			for (int j = 0; j < batch.Count; j++)
			{
				int num2 = num + j;
				Lookup[num2] = i;
			}
			num += batch.Count;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GatherNoClipBatchesJob : IJob
{
	[WriteOnly]
	public NativeList<Vector3> From;

	[WriteOnly]
	public NativeList<Vector3> To;

	internal NativeArray<AntiHack.Batch> Batches;

	[ReadOnly]
	public TickInterpolatorCache.ReadOnlyState TickCache;

	[ReadOnly]
	public ReadOnly<Matrix4x4> Matrices;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<float> DeltaTimes;

	[ReadOnly]
	public int MaxSteps;

	[ReadOnly]
	public float DefaultStepSize;

	[ReadOnly]
	public float LagThreshold;

	[ReadOnly]
	public bool TickBufferPrevention;

	[ReadOnly]
	public float MaxTickCount;

	[ReadOnly]
	public int DefaultProtection;

	public void Execute()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = BasePlayer.NoClipOffset();
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			TickInterpolatorCache.PlayerTickIterator playerTickIterator = TickInterpolatorCache.GetPlayerTickIterator(TickCache, num);
			Matrix4x4 val2 = Matrices[i];
			bool flag = ((Matrix4x4)(ref val2))[15] == 0f;
			Vector3 val3 = (flag ? playerTickIterator.StartPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(playerTickIterator.StartPoint));
			Vector3 val4 = (flag ? playerTickIterator.EndPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(playerTickIterator.EndPoint));
			AntiHack.Batch batch = Batches[i];
			bool num2 = DeltaTimes[num] < LagThreshold && TickBufferPrevention;
			int count = batch.Count;
			int num3 = DefaultProtection;
			if (num2 && (float)count >= MaxTickCount)
			{
				num3 = Mathf.Min(2, num3);
			}
			if (num3 >= 3)
			{
				float distance = Mathf.Max(playerTickIterator.Length / (float)MaxSteps, DefaultStepSize);
				int num4 = 0;
				while (playerTickIterator.MoveNext(distance))
				{
					num4++;
					val4 = (flag ? playerTickIterator.CurrentPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(playerTickIterator.CurrentPoint));
					From.AddNoResize(val3 + val);
					To.AddNoResize(val4 + val);
					val3 = val4;
				}
				batch.Count = num4;
			}
			else
			{
				From.AddNoResize(val3 + val);
				To.AddNoResize(val4 + val);
				batch.Count = 1;
			}
			Batches[i] = batch;
		}
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct FindValidIndicesJob : IJob
{
	[WriteOnly]
	public NativeList<int> ValidIndices;

	public NativeArray<bool> WorkBuffer;

	[ReadOnly]
	public ReadOnly<int> InvalidIndices;

	[ReadOnly]
	public ReadOnly<int> AllIndices;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<int> enumerator = AllIndices.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				int current = enumerator.Current;
				WorkBuffer[current] = true;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = InvalidIndices.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				int current2 = enumerator.Current;
				WorkBuffer[current2] = false;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = AllIndices.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				int current3 = enumerator.Current;
				if (WorkBuffer[current3])
				{
					ValidIndices.AddNoResize(current3);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


using Unity.Collections;
using UnityEngine;

public static class NativeArrayEx
{
	public static void Add<T>(this ref NativeArray<T> array, T item, ref int size) where T : unmanaged
	{
		if (size >= array.Length)
		{
			Expand(ref array, array.Length * 2, (NativeArrayOptions)1);
		}
		array[size] = item;
		size++;
	}

	public static void RemoveUnordered<T>(this ref NativeArray<T> array, int index, ref int count) where T : unmanaged
	{
		int num = count - 1;
		if (index != num)
		{
			array[index] = array[num];
		}
		count--;
	}

	public static void Expand<T>(this ref NativeArray<T> array, int newCapacity, NativeArrayOptions options = 1, bool copyContents = true, bool usePowerOfTwo = false) where T : unmanaged
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (newCapacity <= array.Length)
		{
			return;
		}
		NativeArray<T> val = default(NativeArray<T>);
		val..ctor(usePowerOfTwo ? Mathf.NextPowerOfTwo(newCapacity) : newCapacity, (Allocator)4, options);
		if (array.IsCreated)
		{
			if (copyContents)
			{
				array.CopyTo(val.GetSubArray(0, array.Length));
			}
			array.Dispose();
		}
		array = val;
	}

	public static void SafeDispose<T>(this ref NativeArray<T> array) where T : unmanaged
	{
		if (array.IsCreated)
		{
			array.Dispose();
		}
	}
}


using Unity.Collections;

public static class NativeReferenceEx
{
	public static void SafeDispose<T>(this ref NativeReference<T> reference) where T : unmanaged
	{
		if (reference.IsCreated)
		{
			reference.Dispose();
		}
	}
}


using Unity.Collections;

public static class NativeListEx
{
	public static void Expand<T>(this ref NativeList<T> list, int newCapacity, bool copyContents = true) where T : unmanaged
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (!list.IsCreated || newCapacity > list.Capacity)
		{
			if (list.IsCreated)
			{
				if (copyContents)
				{
					list.Capacity = newCapacity;
				}
				else
				{
					list.Dispose();
					list = new NativeList<T>(newCapacity, AllocatorHandle.op_Implicit((Allocator)4));
				}
			}
			else
			{
				list = new NativeList<T>(newCapacity, AllocatorHandle.op_Implicit((Allocator)4));
			}
		}
		if (!copyContents)
		{
			list.Clear();
		}
	}

	public static void SafeDispose<T>(this ref NativeList<T> list) where T : unmanaged
	{
		if (list.IsCreated)
		{
			list.Dispose();
		}
	}

	public static void CopyFrom<T>(this ref NativeList<T> list, in ReadOnly<T> from) where T : unmanaged
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		list.Resize(from.Length, (NativeArrayOptions)0);
		from.CopyTo(list.AsArray());
	}
}


using System.Collections.Generic;
using Instancing;

public class BuildingBlockConfig
{
	public uint PrefabId;

	public List<BuildingBlockSkin> Skins = new List<BuildingBlockSkin>();
}


using UnityEngine;

public class BuildingBlockSkin
{
	public uint SkinPrefabId;

	public int Grade;

	public ulong Skin;

	public Matrix4x4 LocalToWorld;
}


using System.Collections.Generic;
using Instancing;

public class BuildingSkinConfig
{
	public uint PrefabId;

	public List<ConditionalModelConfig> Conditionals = new List<ConditionalModelConfig>();
}


using UnityEngine;

public class ConditionalModelConfig
{
	public ulong ModelStateMask;

	public uint TargetPrefabId;

	public Matrix4x4 LocalToWorld;
}


public class InstancedEntityConfig
{
	public uint PrefabId;

	public bool HideInsideNetworkRange;
}


using System;
using Instancing;
using UnityEngine;
using UnityEngine.Rendering;

[Serializable]
public class InstancedLODState
{
	public Mesh Mesh;

	public Material[] Materials;

	public Matrix4x4 LocalToWorld;

	public ShadowCastingMode CastShadows;

	public bool RecieveShadows;

	public LightProbeUsage LightProbes;

	public int LodLevel;

	public int TotalLodLevels;

	public InstancedMeshCategory MeshCategory;

	public float MinimumDistance;

	public float MaximumDistance;

	public InstancedLODState(Matrix4x4 localToWorld, MeshRenderer renderer, float minDistance, float maxDistance, int lodLevel, int lodLevels, InstancedMeshCategory category)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		MeshCull component = ((Component)renderer).GetComponent<MeshCull>();
		MeshFilter component2 = ((Component)renderer).GetComponent<MeshFilter>();
		Mesh = component2.sharedMesh;
		Materials = ((Renderer)renderer).sharedMaterials;
		LocalToWorld = localToWorld;
		CastShadows = ((Renderer)renderer).shadowCastingMode;
		RecieveShadows = ((Renderer)renderer).receiveShadows;
		LightProbes = ((Renderer)renderer).lightProbeUsage;
		MinimumDistance = minDistance;
		MaximumDistance = component?.Distance ?? maxDistance;
		MeshCategory = category;
		LodLevel = lodLevel;
		TotalLodLevels = lodLevels;
	}
}


public enum InstancedMeshCategory
{
	BuildingBlock,
	Cliff,
	Other
}


using System;
using System.Collections.Generic;
using Instancing;

[Serializable]
public class InstancedPrefabConfig
{
	public uint PrefabId;

	public List<InstancedMeshConfig> Meshes = new List<InstancedMeshConfig>();

	public InstancedPrefabConfig(uint prefabId)
	{
		PrefabId = prefabId;
	}
}


using System;
using System.Collections.Generic;
using Instancing;

[Serializable]
public class InstancedMeshConfig
{
	public List<InstancedLODState> states;
}


using System;
using Instancing;
using UnityEngine;
using UnityEngine.Rendering;

public struct MeshRenderKey : IEquatable<MeshRenderKey>
{
	public Mesh Mesh;

	public Material[] Materials;

	public ShadowCastingMode CastShadows;

	public bool RecieveShadows;

	public LightProbeUsage LightProbeUsages;

	public MeshRenderKey(Mesh mesh, Material[] materials, ShadowCastingMode castShadows, bool recieveShadows, LightProbeUsage lightProbes)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		Mesh = mesh;
		Materials = materials;
		CastShadows = castShadows;
		RecieveShadows = recieveShadows;
		LightProbeUsages = lightProbes;
	}

	public bool Equals(MeshRenderKey other)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Mesh != (Object)(object)other.Mesh || CastShadows != other.CastShadows || RecieveShadows != other.RecieveShadows || LightProbeUsages != other.LightProbeUsages)
		{
			return false;
		}
		if (Materials == null || other.Materials == null)
		{
			return Materials == other.Materials;
		}
		for (int i = 0; i < Materials.Length; i++)
		{
			if ((Object)(object)Materials[i] != (Object)(object)other.Materials[i])
			{
				return false;
			}
		}
		return true;
	}

	public override bool Equals(object obj)
	{
		if (obj is MeshRenderKey other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (17 * 31 + ((object)Mesh)?.GetHashCode()).GetValueOrDefault();
	}
}


using System;
using Instancing;

public struct PrefabRenderKey : IEquatable<PrefabRenderKey>
{
	public uint PrefabId;

	public int Grade;

	public ulong Skin;

	public PrefabRenderKey(uint prefabId, int grade, ulong skin)
	{
		PrefabId = prefabId;
		Grade = grade;
		Skin = skin;
	}

	public bool Equals(PrefabRenderKey other)
	{
		if (PrefabId == other.PrefabId && Grade == other.Grade)
		{
			return Skin == other.Skin;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is PrefabRenderKey other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (int)(((PrefabId * 397) ^ (uint)Grade) * 397) ^ Skin.GetHashCode();
	}
}


public struct GridAllocation
{
	public int StartIndex;

	public int Capacity;
}


using Unity.Mathematics;

public struct GridJobData
{
	public int GridId;

	public int StartIndex;

	public int Count;

	public int Capacity;

	public float3 MinBounds;

	public float3 MaxBounds;

	public bool CanBeFrustumCulled;

	public bool CanBeDistanceCulled;
}


using System;
using System.Runtime.InteropServices;
using Instancing;
using Unity.Mathematics;

[StructLayout(LayoutKind.Explicit)]
public struct InstancedCullData
{
	[Flags]
	public enum BitFlags : uint
	{
		Visible = 1u,
		HasShadow = 2u,
		HasMesh = 4u,
		LastLOD = 8u
	}

	[FieldOffset(0)]
	public float3 CullPosition;

	[FieldOffset(12)]
	public float3 BoundsMin;

	[FieldOffset(24)]
	public float3 BoundsMax;

	[FieldOffset(36)]
	public float MinDistance;

	[FieldOffset(40)]
	public float MaxDistance;

	[FieldOffset(44)]
	public int RendererId;

	[FieldOffset(48)]
	public int SliceIndex;

	[FieldOffset(52)]
	public BitFlags Flags;

	[FieldOffset(56)]
	public long VirtualMeshId;

	public bool IsVisible
	{
		get
		{
			return (Flags & BitFlags.Visible) == BitFlags.Visible;
		}
		set
		{
			if (value)
			{
				Flags |= BitFlags.Visible;
			}
			else
			{
				Flags &= ~BitFlags.Visible;
			}
		}
	}

	public bool HasShadow
	{
		get
		{
			return (Flags & BitFlags.HasShadow) == BitFlags.HasShadow;
		}
		set
		{
			if (value)
			{
				Flags |= BitFlags.HasShadow;
			}
			else
			{
				Flags &= ~BitFlags.HasShadow;
			}
		}
	}

	public bool HasMesh
	{
		get
		{
			return (Flags & BitFlags.HasMesh) == BitFlags.HasMesh;
		}
		set
		{
			if (value)
			{
				Flags |= BitFlags.HasMesh;
			}
			else
			{
				Flags &= ~BitFlags.HasMesh;
			}
		}
	}

	public bool LastLOD
	{
		get
		{
			return (Flags & BitFlags.LastLOD) == BitFlags.LastLOD;
		}
		set
		{
			if (value)
			{
				Flags |= BitFlags.LastLOD;
			}
			else
			{
				Flags &= ~BitFlags.LastLOD;
			}
		}
	}
}


using System;

[Flags]
public enum BitFlags : uint
{
	Visible = 1u,
	HasShadow = 2u,
	HasMesh = 4u,
	LastLOD = 8u
}


using UnityEngine.Rendering;

public struct InstancedRendererJobData
{
	public int Id;

	public int DrawCallCount;

	public float MinDistance;

	public float MaxDistance;

	public ShadowCastingMode ShadowMode;

	public bool HasMesh => (int)ShadowMode != 3;

	public bool HasShadow => (int)ShadowMode > 0;
}


using System;
using Instancing;
using Unity.Mathematics;

public struct MeshOverrideData : IEquatable<MeshOverrideData>
{
	public float4 Color;

	public bool Equals(MeshOverrideData other)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (Color.x == other.Color.x && Color.y == other.Color.y && Color.z == other.Color.z)
		{
			return Color.w == other.Color.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is MeshOverrideData other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return ((object)(float4)(ref Color)/*cast due to .constrained prefix*/).GetHashCode();
	}

	public static bool operator ==(MeshOverrideData left, MeshOverrideData right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(MeshOverrideData left, MeshOverrideData right)
	{
		return !left.Equals(right);
	}
}


using Instancing;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct PreCullingJob : IJob
{
	[ReadOnly]
	public NativeArray<InstancedRendererJobData> Meshes;

	[ReadOnly]
	public int RendererCount;

	[ReadOnly]
	public NativeArray<uint> CountPerMesh;

	[ReadOnly]
	public NativeArray<DrawCallJobData> DrawCalls;

	[ReadOnly]
	public int DrawCallCount;

	[WriteOnly]
	public NativeArray<RenderSlice> RenderSlices;

	public void Execute()
	{
		CalculateRenderSlices();
	}

	private void CalculateRenderSlices()
	{
		uint num = 0u;
		for (int i = 0; i < RendererCount; i++)
		{
			uint num2 = CountPerMesh[i];
			uint num3 = num2;
			if (num3 != 0)
			{
				RenderSlices[i] = new RenderSlice
				{
					StartIndex = num,
					Length = num2
				};
				num += num3;
			}
			else
			{
				RenderSlices[i] = default(RenderSlice);
			}
		}
	}
}


using Instancing;
using UnityEngine;

public static class ComputeBufferEx
{
	public static void SetBuffer<T>(this ComputeShader shader, int kernel, int name, GPUBuffer<T> buffer) where T : unmanaged
	{
		shader.SetBuffer(kernel, name, buffer.Buffer);
	}
}


public class GPUBuffer
{
	public enum Target
	{
		Structured,
		IndirectArgs,
		Vertex,
		Index,
		Raw
	}
}


public enum Target
{
	Structured,
	IndirectArgs,
	Vertex,
	Index,
	Raw
}


using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Instancing;
using Unity.Collections;
using UnityEngine;

public class GPUBuffer<T> : GPUBuffer, IDisposable where T : unmanaged
{
	private Target _type;

	public int BufferVersion { get; private set; }

	public GraphicsBuffer Buffer { get; private set; }

	public Target Type { get; private set; }

	public int count { get; private set; }

	public int stride { get; private set; }

	public int ByteLength => count * stride;

	public GPUBuffer(int length, Target target)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Expected O, but got Unknown
		count = length;
		stride = Marshal.SizeOf<T>();
		Type = target;
		switch (target)
		{
		case Target.Structured:
			_type = (Target)16;
			break;
		case Target.IndirectArgs:
			_type = (Target)256;
			break;
		case Target.Vertex:
			_type = (Target)1;
			break;
		case Target.Index:
			_type = (Target)2;
			break;
		case Target.Raw:
			_type = (Target)32;
			break;
		default:
			throw new NotImplementedException($"GPUBuffer Target '{target}'");
		}
		Buffer = new GraphicsBuffer(_type, length, stride);
		ClearData();
	}

	public void SetData(List<T> data)
	{
		Buffer.SetData<T>(data);
	}

	public void SetData(List<int> data, int nativeArrayIndex, int computeBufferIndex, int length)
	{
		Buffer.SetData<int>(data, nativeArrayIndex, computeBufferIndex, length);
	}

	public void SetData(T[] data)
	{
		Buffer.SetData((Array)data);
	}

	public void SetData(T[] data, int nativeArrayIndex, int computeBufferIndex, int length)
	{
		Buffer.SetData((Array)data, nativeArrayIndex, computeBufferIndex, length);
	}

	public void SetData(NativeArray<T> data)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Buffer.SetData<T>(data);
	}

	public void SetData(NativeArray<T> data, int nativeArrayIndex, int computeBufferIndex, int length)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Buffer.SetData<T>(data, nativeArrayIndex, computeBufferIndex, length);
	}

	public void ClearData()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<T> data = default(NativeArray<T>);
		data..ctor(count, (Allocator)2, (NativeArrayOptions)1);
		try
		{
			Buffer.SetData<T>(data);
		}
		finally
		{
			((IDisposable)data/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public void Expand(int newCapacity, bool preserveData = false)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		GraphicsBuffer val = new GraphicsBuffer(_type, newCapacity, stride);
		BufferVersion++;
		if (preserveData)
		{
			T[] array = new T[newCapacity];
			Buffer.GetData((Array)array, 0, 0, count);
			val.SetData((Array)array);
		}
		Dispose();
		Buffer = val;
		count = newCapacity;
		if (!preserveData)
		{
			ClearData();
		}
	}

	public void EnsureCapacity(int size, bool preserveData = false, float expandRatio = 2f)
	{
		if (Buffer.count < size)
		{
			int newCapacity = (int)((float)size * expandRatio);
			Expand(newCapacity, preserveData);
		}
	}

	public void Dispose()
	{
		GraphicsBuffer buffer = Buffer;
		if (buffer != null)
		{
			buffer.Dispose();
		}
		Buffer = null;
	}
}


using System.Collections.Generic;
using System.Linq;
using Instancing;
using UnityEngine;

public static class InstancedPrefabConverter
{
	private static InstancedMeshCategory GetMeshCategory(string prefabPath)
	{
		if (prefabPath.StartsWith("assets/prefabs/building core"))
		{
			return InstancedMeshCategory.BuildingBlock;
		}
		if (prefabPath.StartsWith("assets/bundled/prefabs/autospawn/"))
		{
			return InstancedMeshCategory.Cliff;
		}
		return InstancedMeshCategory.Other;
	}

	public static InstancedPrefabConfig ExtractInstancedRenderers(GameObject prefab, uint prefabId, IEnumerable<InstancedMeshFilter> instancedFilters)
	{
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		InstancedPrefabConfig instancedPrefabConfig = new InstancedPrefabConfig(prefabId);
		string text = StringPool.Get(prefabId);
		(from x in instancedFilters
			select x.RendererLOD into x
			where (Object)(object)x != (Object)null
			select x).ToArray();
		(from x in instancedFilters
			select x.MeshRenderer into x
			where (Object)(object)x != (Object)null
			select x).ToArray();
		(from x in instancedFilters
			select x.MeshLOD into x
			where (Object)(object)x != (Object)null
			select x).ToArray();
		foreach (Transform allChild in prefab.transform.GetAllChildren())
		{
			if (((Object)allChild).name == "reflection" && !((Component)allChild).gameObject.activeSelf)
			{
				Debug.Log((object)("Reflection probe in " + text));
			}
		}
		InstancedMeshCategory meshCategory = GetMeshCategory(text);
		foreach (InstancedMeshFilter instancedFilter in instancedFilters)
		{
			InstancedMeshConfig instancedMeshConfig = new InstancedMeshConfig
			{
				states = new List<InstancedLODState>()
			};
			instancedPrefabConfig.Meshes.Add(instancedMeshConfig);
			instancedFilter.Config = instancedMeshConfig;
			float num = 2500f;
			InstancedLODState instancedLODState = null;
			if ((Object)(object)instancedFilter.MeshRenderer != (Object)null)
			{
				MeshRenderer meshRenderer = instancedFilter.MeshRenderer;
				if (!((Object)(object)meshRenderer == (Object)null))
				{
					instancedLODState = new InstancedLODState(((Component)meshRenderer).transform.localToWorldMatrix, meshRenderer, 0f, num, 0, 1, meshCategory);
					instancedMeshConfig.states.Add(instancedLODState);
				}
			}
			else if ((Object)(object)instancedFilter.MeshLOD != (Object)null)
			{
				MeshLOD.State[] array = instancedFilter.MeshLOD.States.OrderBy((MeshLOD.State x) => x.distance).ToArray();
				for (int i = 0; i < array.Length; i++)
				{
					MeshLOD.State state = array[i];
					MeshRenderer component = ((Component)instancedFilter.MeshLOD).GetComponent<MeshRenderer>();
					if (!((Object)(object)component == (Object)null))
					{
						Matrix4x4 localToWorldMatrix = ((Component)component).transform.localToWorldMatrix;
						MeshLOD.State? state2 = array.ElementAtOrDefault(i + 1);
						float minDistance = ((i == 0) ? 0f : state.distance);
						float maxDistance = state2?.distance ?? num;
						instancedLODState = new InstancedLODState(localToWorldMatrix, component, minDistance, maxDistance, i, array.Length, meshCategory);
						instancedMeshConfig.states.Add(instancedLODState);
					}
				}
			}
			else
			{
				if (!((Object)(object)instancedFilter.RendererLOD != (Object)null))
				{
					continue;
				}
				RendererLOD.State[] array2 = instancedFilter.RendererLOD.States.OrderBy((RendererLOD.State x) => x.distance).ToArray();
				for (int j = 0; j < array2.Length; j++)
				{
					RendererLOD.State state3 = array2[j];
					Renderer renderer = state3.renderer;
					MeshRenderer val = (MeshRenderer)(object)((renderer is MeshRenderer) ? renderer : null);
					if (!((Object)(object)val == (Object)null))
					{
						Matrix4x4 localToWorldMatrix2 = ((Component)val).transform.localToWorldMatrix;
						RendererLOD.State? state4 = array2.ElementAtOrDefault(j + 1);
						float minDistance2 = ((j == 0) ? 0f : state3.distance);
						float maxDistance2 = state4?.distance ?? num;
						instancedLODState = new InstancedLODState(localToWorldMatrix2, val, minDistance2, maxDistance2, j, array2.Length, meshCategory);
						instancedMeshConfig.states.Add(instancedLODState);
					}
				}
			}
		}
		return instancedPrefabConfig;
	}
}


public static class InstancedPrefabPreProcess
{
}


using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

internal static class InstancingUtil
{
	public static readonly int PositionBufferProperty = Shader.PropertyToID("_PositionBuffer");

	public static readonly int RenderBufferProperty = Shader.PropertyToID("_PostCullBuffer");

	public static readonly int IndirectExtraArgProperty = Shader.PropertyToID("_IndirectExtraArgsBuffer");

	public static readonly int Param_MeshOverrideBuffer = Shader.PropertyToID("_MeshOverrideBuffer");

	public static readonly int Param_RenderSliceIndexes = Shader.PropertyToID("_RenderSliceIndexes");

	public static readonly int DrawCallIndexProperty = Shader.PropertyToID("_DrawCallIndex");

	public static readonly int Param_RendererIndex = Shader.PropertyToID("_RendererIndex");

	public static readonly int Param_Verticies = Shader.PropertyToID("_Verticies");

	public static readonly int Param_Triangles = Shader.PropertyToID("_Triangles");

	public static readonly GlobalKeyword Keyword_Rust_Procedural_Rendering = GlobalKeyword.Create("RUST_PROCEDURAL_INSTANCING");

	public const int CullingGPUThreads = 1024;

	public static float MB(int bytes)
	{
		return (float)Math.Round((float)(bytes / 100000) / 10f, 1);
	}

	public static StringBuilder MemoryUsage(this StringBuilder builder, string name, ComputeBuffer buffer)
	{
		builder.AppendLine($"[ComputeBuffer] {name} {buffer.count} | {MB(buffer.count * buffer.stride)}MB");
		return builder;
	}

	public static StringBuilder MemoryUsage(this StringBuilder builder, string name, GraphicsBuffer buffer)
	{
		builder.AppendLine($"[ComputeBuffer] {name} {buffer.count} | {MB(buffer.count * buffer.stride)}MB");
		return builder;
	}

	public static StringBuilder MemoryUsage<T>(this StringBuilder builder, string name, NativeArray<T> array, int count = -1) where T : unmanaged
	{
		int num = Marshal.SizeOf<T>();
		builder.AppendLine(string.Format("[NativeArray] {0}{1} Capacity: {2} | {3}MB", name, (count >= 0) ? (" Count: " + count) : "", array.Length, MB(array.Length * num)));
		return builder;
	}

	public static StringBuilder MemoryUsage<T>(this StringBuilder builder, string name, ICollection<T> array)
	{
		Type type = (array.GetType().IsGenericType ? array.GetType() : array.GetType().GetGenericTypeDefinition());
		string arg = "Collection";
		if (type == typeof(Dictionary<, >))
		{
			arg = "Dictionary";
		}
		else if (type == typeof(List<>))
		{
			arg = "List";
		}
		else if (type == typeof(HashSet<>))
		{
			arg = "HashSet";
		}
		else if (type == typeof(Array))
		{
			arg = "Array";
		}
		int count = array.Count;
		builder.AppendLine($"[{arg}] {name} Size: {count}");
		return builder;
	}

	public static int GetIterationCount(int count, int threads)
	{
		return count / threads + ((count % threads != 0) ? 1 : 0);
	}
}


using System;
using Instancing;
using Unity.Collections;

public struct JobInt
{
	private NativeArray<int> Array;

	public int Value
	{
		get
		{
			if (!Array.IsCreated)
			{
				throw new InvalidOperationException("You must call 'JobInt.Create()' before using this in a job");
			}
			return Array[0];
		}
		set
		{
			if (!Array.IsCreated)
			{
				throw new InvalidOperationException("You must call 'JobInt.Create()' before using this in a job");
			}
			Array[0] = value;
		}
	}

	public static JobInt Create()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		JobInt result = default(JobInt);
		result.Array = new NativeArray<int>(1, (Allocator)4, (NativeArrayOptions)1);
		return result;
	}

	public static void Destroy(JobInt instance)
	{
		NativeArrayEx.SafeDispose(ref instance.Array);
	}
}


using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using Instancing;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Rendering;

public class GeometryBuffers
{
	[StructLayout(LayoutKind.Explicit, Size = 96)]
	public struct VertexData
	{
		[FieldOffset(0)]
		public float4 Position;

		[FieldOffset(16)]
		public float4 UV01;

		[FieldOffset(32)]
		public float4 UV23;

		[FieldOffset(48)]
		public float4 Normal;

		[FieldOffset(64)]
		public float4 Tangent;

		[FieldOffset(80)]
		public float4 Color;
	}

	private int _meshCopyMode;

	public GPUBuffer<VertexData> VertexBuffer;

	public GPUBuffer<int> TriangleBuffer;

	private int VertexIndex;

	private int TriangleIndex;

	private Dictionary<Mesh, MultidrawMeshInfo[]> _meshes = new Dictionary<Mesh, MultidrawMeshInfo[]>();

	public bool IsDirty { get; set; }

	public void Initialize(int meshCopyMode)
	{
		_meshCopyMode = meshCopyMode;
		AllocateNativeMemory();
		ResetStreamPosition();
	}

	private void ResetStreamPosition()
	{
		TriangleIndex = 0;
		VertexIndex = 0;
	}

	public void Destroy()
	{
		FreeNativeMemory();
		_meshes.Clear();
	}

	private void AllocateNativeMemory()
	{
		VertexBuffer = new GPUBuffer<VertexData>(800000, GPUBuffer.Target.Structured);
		TriangleBuffer = new GPUBuffer<int>(3000000, GPUBuffer.Target.Structured);
	}

	private void FreeNativeMemory()
	{
		VertexBuffer?.Dispose();
		VertexBuffer = null;
		TriangleBuffer?.Dispose();
		TriangleBuffer = null;
	}

	public MultidrawMeshInfo[] CopyMesh(Mesh mesh)
	{
		if (_meshes.TryGetValue(mesh, out var value))
		{
			return value;
		}
		value = CalculateSubmeshInfo(mesh);
		_meshes.Add(mesh, value);
		if (_meshCopyMode == 0)
		{
			CopyMeshViaCPU(mesh);
		}
		else
		{
			CopyMeshViaShader(mesh);
		}
		IsDirty = true;
		return value;
	}

	private void CopyMeshViaShader(Mesh mesh)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		mesh.vertexBufferTarget = (Target)(mesh.vertexBufferTarget | 0x20);
		mesh.indexBufferTarget = (Target)(mesh.indexBufferTarget | 0x20);
		int num = 0;
		GraphicsBuffer vertexBuffer = mesh.GetVertexBuffer(num);
		GraphicsBuffer indexBuffer = mesh.GetIndexBuffer();
		ComputeShader copyMeshShader = SingletonComponent<InstancedScheduler>.Instance.CopyMeshShader;
		int num2 = copyMeshShader.FindKernel("CopyMeshKernel");
		int vertexCount = mesh.vertexCount;
		int num3 = 0;
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			num3 += (int)mesh.GetIndexCount(i);
		}
		copyMeshShader.SetInt("_Offset_Vertex", mesh.GetVertexAttributeOffset((VertexAttribute)0));
		copyMeshShader.SetInt("_Offset_UV0", mesh.GetVertexAttributeOffset((VertexAttribute)4));
		copyMeshShader.SetInt("_Offset_UV1", mesh.GetVertexAttributeOffset((VertexAttribute)5));
		copyMeshShader.SetInt("_Offset_UV2", mesh.GetVertexAttributeOffset((VertexAttribute)6));
		copyMeshShader.SetInt("_Offset_UV3", mesh.GetVertexAttributeOffset((VertexAttribute)7));
		copyMeshShader.SetInt("_Offset_Normal", mesh.GetVertexAttributeOffset((VertexAttribute)1));
		copyMeshShader.SetInt("_Offset_Tangent", mesh.GetVertexAttributeOffset((VertexAttribute)2));
		copyMeshShader.SetInt("_Offset_Color", mesh.GetVertexAttributeOffset((VertexAttribute)3));
		copyMeshShader.SetBuffer(num2, "_Verts", mesh.GetVertexBuffer(num));
		copyMeshShader.SetBuffer(num2, "_Triangles", mesh.GetIndexBuffer());
		copyMeshShader.SetInt("_TriangleCount", num3);
		copyMeshShader.SetInt("_VertexCount", vertexCount);
		copyMeshShader.SetInt("_VertexStride", mesh.GetVertexBufferStride(0));
		copyMeshShader.SetInt("_TriangleStride", ((int)mesh.indexFormat == 0) ? 2 : 4);
		copyMeshShader.SetInt("_OutputVertexIndex", VertexIndex);
		copyMeshShader.SetInt("_OutputTriangleIndex", TriangleIndex);
		copyMeshShader.SetBuffer(num2, "_Output", VertexBuffer.Buffer);
		copyMeshShader.SetBuffer(num2, "_OutputTriangles", TriangleBuffer.Buffer);
		VertexIndex += vertexCount;
		TriangleIndex += num3;
		if (VertexBuffer.count < VertexIndex + 1 || TriangleBuffer.count < TriangleIndex + 1)
		{
			Debug.Log((object)"Resizing multidraw geometry buffer");
			VertexBuffer.EnsureCapacity(VertexIndex + 1, preserveData: true);
			TriangleBuffer.EnsureCapacity(TriangleIndex + 1, preserveData: true);
			IsDirty = true;
		}
		int iterationCount = InstancingUtil.GetIterationCount(Mathf.Max(num3, vertexCount), 1024);
		copyMeshShader.Dispatch(num2, iterationCount, 1, 1);
		vertexBuffer.Dispose();
		indexBuffer.Dispose();
	}

	public void Rebuild()
	{
		ResetStreamPosition();
		foreach (Mesh key in _meshes.Keys)
		{
			CopyMeshViaShader(key);
		}
	}

	private MultidrawMeshInfo[] CalculateSubmeshInfo(Mesh mesh)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		MultidrawMeshInfo[] array = new MultidrawMeshInfo[mesh.subMeshCount];
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			SubMeshDescriptor subMesh = mesh.GetSubMesh(i);
			MultidrawMeshInfo multidrawMeshInfo = default(MultidrawMeshInfo);
			multidrawMeshInfo.IndexStart = TriangleIndex + ((SubMeshDescriptor)(ref subMesh)).indexStart;
			multidrawMeshInfo.VertexStart = VertexIndex + ((SubMeshDescriptor)(ref subMesh)).baseVertex;
			multidrawMeshInfo.VertexCount = ((SubMeshDescriptor)(ref subMesh)).vertexCount;
			MultidrawMeshInfo multidrawMeshInfo2 = multidrawMeshInfo;
			array[i] = multidrawMeshInfo2;
		}
		return array;
	}

	private void CopyMeshViaCPU(Mesh mesh)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		MeshCache.Data data = MeshCache.Get(mesh);
		NativeArray<VertexData> data2 = default(NativeArray<VertexData>);
		data2..ctor(data.vertices.Length, (Allocator)2, (NativeArrayOptions)1);
		for (int i = 0; i < data2.Length; i++)
		{
			VertexData vertexData = default(VertexData);
			Vector3 val = data.vertices[i];
			Vector2 val2 = (mesh.HasVertexAttribute((VertexAttribute)4) ? data.uv[i] : Vector2.zero);
			Vector2 val3 = (mesh.HasVertexAttribute((VertexAttribute)5) ? data.uv2[i] : Vector2.zero);
			Vector2 val4 = (mesh.HasVertexAttribute((VertexAttribute)6) ? data.uv3[i] : Vector2.zero);
			Vector2 val5 = (mesh.HasVertexAttribute((VertexAttribute)7) ? data.uv4[i] : Vector2.zero);
			Vector3 val6 = (mesh.HasVertexAttribute((VertexAttribute)1) ? data.normals[i] : Vector3.zero);
			Vector4 val7 = (mesh.HasVertexAttribute((VertexAttribute)2) ? data.tangents[i] : Vector4.zero);
			Color32 val8 = (Color32)(mesh.HasVertexAttribute((VertexAttribute)3) ? data.colors32[i] : new Color32((byte)0, (byte)0, (byte)0, (byte)0));
			vertexData.Position = new float4(val.x, val.y, val.z, 1f);
			vertexData.UV01 = new float4(val2.x, val2.y, val3.x, val3.y);
			vertexData.UV23 = new float4(val4.x, val4.y, val5.x, val5.y);
			vertexData.Normal = new float4(val6.x, val6.y, val6.z, 1f);
			vertexData.Tangent = new float4(val7.x, val7.y, val7.z, val7.w);
			vertexData.Color = new float4((float)(int)val8.r / 255f, (float)(int)val8.g / 255f, (float)(int)val8.b / 255f, (float)(int)val8.a / 255f);
			data2[i] = vertexData;
		}
		VertexBuffer.EnsureCapacity(VertexIndex + data2.Length + 1);
		VertexBuffer.SetData(data2, 0, VertexIndex, data2.Length);
		VertexIndex += data2.Length;
		int[] triangles = data.triangles;
		TriangleBuffer.EnsureCapacity(TriangleIndex + triangles.Length + 1);
		TriangleBuffer.SetData(triangles, 0, TriangleIndex, triangles.Length);
		TriangleIndex += triangles.Length;
		data2.Dispose();
		IsDirty = true;
	}

	public void PrintMemoryUsage(StringBuilder builder)
	{
		builder.AppendLine($"Vertex Buffer: {VertexIndex} / {VertexBuffer.count}");
		builder.AppendLine($"Triangle Buffer: {TriangleIndex} / {TriangleBuffer.count}");
		builder.AppendLine($"Meshes: {_meshes.Count}");
	}
}


using System.Runtime.InteropServices;
using Unity.Mathematics;

[StructLayout(LayoutKind.Explicit, Size = 96)]
public struct VertexData
{
	[FieldOffset(0)]
	public float4 Position;

	[FieldOffset(16)]
	public float4 UV01;

	[FieldOffset(32)]
	public float4 UV23;

	[FieldOffset(48)]
	public float4 Normal;

	[FieldOffset(64)]
	public float4 Tangent;

	[FieldOffset(80)]
	public float4 Color;
}


public struct MultidrawMeshInfo
{
	public int VertexStart;

	public int VertexCount;

	public int IndexStart;
}


using Instancing;
using UnityEngine;
using UnityEngine.Rendering;

public class InstancedMeshRenderer
{
	public int RendererId { get; }

	public int DrawCallIndex { get; }

	public int DrawCallCount { get; }

	public string MeshName => ((Object)Mesh).name;

	public Mesh Mesh { get; }

	public Material[] Materials { get; private set; }

	public Material[] MultidrawMaterials { get; private set; }

	public ShadowCastingMode CastShadows { get; }

	public bool RecieveShadows { get; }

	public LightProbeUsage LightProbes { get; }

	public int Verticies { get; }

	public int Triangles { get; }

	public int VertexStart { get; private set; }

	public int IndexStart { get; private set; }

	public int LodLevel { get; }

	public int TotalLodLevels { get; }

	public bool IsLastLod { get; }

	public InstancedMeshCategory MeshCategory { get; }

	public MultidrawMeshInfo[] MultidrawSubmeshes { get; }

	public bool HasShadow => (int)CastShadows > 0;

	public bool HasMesh => (int)CastShadows != 3;

	public Vector3[] BoundsPoints { get; }

	public InstancedMeshRenderer(int rendererIndex, int drawCallIndex, MeshRenderKey key, Material[] multidrawMaterials, int lodLevel, int lodLevels, InstancedMeshCategory meshCategory, GeometryBuffers buffers)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		RendererId = rendererIndex;
		DrawCallIndex = drawCallIndex;
		Mesh = key.Mesh;
		Materials = key.Materials;
		MultidrawMaterials = multidrawMaterials;
		CastShadows = key.CastShadows;
		RecieveShadows = key.RecieveShadows;
		LightProbes = key.LightProbeUsages;
		Verticies = Mesh.vertexCount;
		LodLevel = lodLevel;
		TotalLodLevels = lodLevels;
		IsLastLod = lodLevel == lodLevels - 1;
		MeshCategory = meshCategory;
		DrawCallCount = Mathf.Min(Mesh.subMeshCount, Materials.Length);
		if (Materials.Length > Mesh.subMeshCount)
		{
			string name = ((Object)Mesh).name;
			Debug.LogError((object)("More submesh than material for mesh " + name));
		}
		if (Mesh.subMeshCount > Materials.Length)
		{
			string name2 = ((Object)Mesh).name;
			Debug.LogWarning((object)("More materials than submesh for mesh " + name2));
		}
		for (int i = 0; i < Mesh.subMeshCount; i++)
		{
			Triangles += (int)Mesh.GetIndexCount(i) / 3;
		}
		Bounds bounds = Mesh.bounds;
		BoundsPoints = (Vector3[])(object)new Vector3[8]
		{
			((Bounds)(ref bounds)).min,
			((Bounds)(ref bounds)).max,
			new Vector3(((Bounds)(ref bounds)).max.x, ((Bounds)(ref bounds)).min.y, ((Bounds)(ref bounds)).min.z),
			new Vector3(((Bounds)(ref bounds)).min.x, ((Bounds)(ref bounds)).max.y, ((Bounds)(ref bounds)).min.z),
			new Vector3(((Bounds)(ref bounds)).min.x, ((Bounds)(ref bounds)).min.y, ((Bounds)(ref bounds)).max.z),
			new Vector3(((Bounds)(ref bounds)).max.x, ((Bounds)(ref bounds)).max.y, ((Bounds)(ref bounds)).min.z),
			new Vector3(((Bounds)(ref bounds)).min.x, ((Bounds)(ref bounds)).max.y, ((Bounds)(ref bounds)).max.z),
			new Vector3(((Bounds)(ref bounds)).max.x, ((Bounds)(ref bounds)).min.y, ((Bounds)(ref bounds)).max.z)
		};
		MultidrawSubmeshes = buffers.CopyMesh(Mesh);
	}

	public void SetMaterials(Material[] materials)
	{
		Materials = materials;
	}

	public void SetPlaceholderMaterials(Material[] materials)
	{
		Materials = materials;
	}

	public int GetDrawCallIndex(int submesh)
	{
		return DrawCallIndex + submesh;
	}

	public int GetIndirectArgIndex(int submesh)
	{
		return GetDrawCallIndex(submesh) * 5;
	}

	public int GetIndirectArgByteIndex(int submesh)
	{
		return GetIndirectArgIndex(submesh) * 4;
	}
}


using UnityEngine;

public struct RenderUpdate
{
	public uint PrefabId;

	public NetworkableId NetworkId;

	public int Grade;

	public ulong Skin;

	public ulong ModelState;

	public Vector3 Position;

	public Quaternion Rotation;

	public Color CustomColor;

	public int CustomColorIndex;

	public bool IsGlobalUpdate;

	public bool InsideNetworkRange;
}


public struct CellId
{
	public int Index;

	public CellId(int index)
	{
		Index = index;
	}

	public override string ToString()
	{
		return Index.ToString();
	}
}


public struct CellHeader
{
	public int StartIndex;

	public int Count;

	public int PartitionKey;
}


using Instancing;
using Unity.Mathematics;

public struct InstancedMeshData
{
	public InstancedCullData CullData;

	public float4x4 LocalToWorld;
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Instancing;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;

public class CellMeshAllocator
{
	private class CellPartition : IPooled
	{
		public List<CellId> PackedCells;

		public List<CellId> CellsWithSpace;

		public bool IsEmpty()
		{
			if (PackedCells.IsNullOrEmpty())
			{
				return CellsWithSpace.IsNullOrEmpty();
			}
			return false;
		}

		public void AddPackedCell(CellId cell)
		{
			if (PackedCells == null)
			{
				PackedCells = Pool.Get<List<CellId>>();
			}
			PackedCells.Add(cell);
		}

		public void RemovePackedCell(CellId cell)
		{
			if (PackedCells != null)
			{
				PackedCells.Remove(cell);
				if (PackedCells.Count == 0)
				{
					Pool.FreeUnmanaged<CellId>(ref PackedCells);
				}
			}
		}

		public void AddCellWithSpace(CellId cell)
		{
			if (CellsWithSpace == null)
			{
				CellsWithSpace = Pool.Get<List<CellId>>();
			}
			CellsWithSpace.Add(cell);
		}

		public void RemoveCellWithSpace(CellId cell)
		{
			if (CellsWithSpace != null)
			{
				CellsWithSpace.Remove(cell);
				if (CellsWithSpace.Count == 0)
				{
					Pool.FreeUnmanaged<CellId>(ref CellsWithSpace);
				}
			}
		}

		public void EnterPool()
		{
			if (PackedCells != null)
			{
				Pool.FreeUnmanaged<CellId>(ref PackedCells);
			}
			if (CellsWithSpace != null)
			{
				Pool.FreeUnmanaged<CellId>(ref CellsWithSpace);
			}
		}

		public void LeavePool()
		{
		}
	}

	public const int CellCapacity = 32;

	private const int initialCellCount = 8192;

	public const int InitialCapacity = 262144;

	private Dictionary<int, CellPartition> partitions = new Dictionary<int, CellPartition>();

	private List<CellId> recycledCells = new List<CellId>();

	private Dictionary<long, int> meshLookup = new Dictionary<long, int>();

	public Dictionary<long, int> sliceIndexLookup = new Dictionary<long, int>();

	private Dictionary<int, List<long>> sliceLists = new Dictionary<int, List<long>>();

	public NativeArray<CellHeader> Cells;

	public NativeArray<InstancedCullData> CullData;

	public NativeArray<float4x4> PositionData;

	public NativeArray<MeshOverrideData> OverrideArray;

	public GPUBuffer<float4x4> PositionBuffer;

	public GPUBuffer<InstancedCullData> CullingDataBuffer;

	public GPUBuffer<MeshOverrideData> OverrideBuffer;

	private bool dirty;

	public int CellCount { get; private set; }

	public void Initialize()
	{
		AllocateNativeMemory();
		meshLookup = new Dictionary<long, int>();
		sliceIndexLookup = new Dictionary<long, int>();
		sliceLists = new Dictionary<int, List<long>>();
		partitions = new Dictionary<int, CellPartition>();
		recycledCells = new List<CellId>();
		CellCount = 0;
	}

	public void OnDestroy()
	{
		FreeNativeMemory();
		dirty = false;
	}

	private void AllocateNativeMemory()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		Cells = new NativeArray<CellHeader>(8192, (Allocator)4, (NativeArrayOptions)1);
		int num = Cells.Length * 32;
		CullData = new NativeArray<InstancedCullData>(num, (Allocator)4, (NativeArrayOptions)1);
		PositionData = new NativeArray<float4x4>(num, (Allocator)4, (NativeArrayOptions)1);
		OverrideArray = new NativeArray<MeshOverrideData>(num, (Allocator)4, (NativeArrayOptions)1);
		PositionBuffer = new GPUBuffer<float4x4>(num, GPUBuffer.Target.Structured);
		CullingDataBuffer = new GPUBuffer<InstancedCullData>(num, GPUBuffer.Target.Structured);
		OverrideBuffer = new GPUBuffer<MeshOverrideData>(num, GPUBuffer.Target.Structured);
	}

	private void FreeNativeMemory()
	{
		NativeArrayEx.SafeDispose(ref Cells);
		NativeArrayEx.SafeDispose(ref CullData);
		PositionData.SafeDispose<float4x4>();
		PositionBuffer?.Dispose();
		PositionBuffer = null;
		CullingDataBuffer?.Dispose();
		CullingDataBuffer = null;
	}

	public CellId AddMesh(InstancedCullData data, int partitionKey, float4x4 localToWorld)
	{
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		if (!partitions.TryGetValue(partitionKey, out var value))
		{
			value = Pool.Get<CellPartition>();
			partitions[partitionKey] = value;
		}
		if (value.CellsWithSpace.IsNullOrEmpty())
		{
			value.AddCellWithSpace(CreateCell(partitionKey));
		}
		CellId cellId = value.CellsWithSpace[value.CellsWithSpace.Count - 1];
		CellHeader cellHeader = Cells[cellId.Index];
		int num = cellHeader.StartIndex + cellHeader.Count;
		cellHeader.Count++;
		int count = cellHeader.Count;
		Cells[cellId.Index] = cellHeader;
		if (!sliceLists.TryGetValue(data.RendererId, out var value2))
		{
			value2 = new List<long>();
			sliceLists[data.RendererId] = value2;
		}
		data.SliceIndex = value2.Count;
		value2.Add(data.VirtualMeshId);
		CullData[num] = data;
		PositionData[num] = localToWorld;
		OverrideArray[num] = default(MeshOverrideData);
		if (Render.computebuffer_setdata_immediate)
		{
			CullingDataBuffer.SetData(CullData, num, num, 1);
			PositionBuffer.SetData(PositionData, num, num, 1);
			OverrideBuffer.SetData(OverrideArray, num, num, 1);
		}
		else
		{
			dirty = true;
		}
		meshLookup.Add(data.VirtualMeshId, num);
		if (count == 32)
		{
			value.RemoveCellWithSpace(cellId);
			value.AddPackedCell(cellId);
		}
		else if (count > 32)
		{
			Debug.LogError((object)$"AddMesh() fucked up: >{32} elements in cell {cellId}");
		}
		return cellId;
	}

	public bool TryRemoveMesh(long virtualMeshId, out InstancedCullData removedData)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		if (!meshLookup.TryGetValue(virtualMeshId, out var value))
		{
			removedData = default(InstancedCullData);
			return false;
		}
		removedData = CullData[value];
		CellId cellId = GetCellId(value);
		CellHeader cellHeader = Cells[cellId.Index];
		int num = cellHeader.StartIndex + cellHeader.Count - 1;
		int count = cellHeader.Count;
		int partitionKey = cellHeader.PartitionKey;
		int num2 = --cellHeader.Count;
		Cells[cellId.Index] = cellHeader;
		if (value != num)
		{
			InstancedCullData instancedCullData = CullData[num];
			CullData[value] = instancedCullData;
			PositionData[value] = PositionData[num];
			OverrideArray[value] = OverrideArray[num];
			meshLookup[instancedCullData.VirtualMeshId] = value;
			if (Render.computebuffer_setdata_immediate)
			{
				CullingDataBuffer.SetData(CullData, value, value, 1);
				PositionBuffer.SetData(PositionData, value, value, 1);
				OverrideBuffer.SetData(OverrideArray, value, value, 1);
			}
			else
			{
				dirty = true;
			}
		}
		CullData[num] = default(InstancedCullData);
		if (Render.computebuffer_setdata_immediate)
		{
			CullingDataBuffer.SetData(CullData, num, num, 1);
		}
		else
		{
			dirty = true;
		}
		List<long> list = sliceLists[removedData.RendererId];
		long num3 = list[list.Count - 1];
		if (removedData.VirtualMeshId != num3)
		{
			int num4 = meshLookup[num3];
			InstancedCullData instancedCullData2 = CullData[num4];
			instancedCullData2.SliceIndex = removedData.SliceIndex;
			CullData[num4] = instancedCullData2;
			if (Render.computebuffer_setdata_immediate)
			{
				CullingDataBuffer.SetData(CullData, num4, num4, 1);
			}
			else
			{
				dirty = true;
			}
			list[removedData.SliceIndex] = num3;
		}
		list.RemoveAt(list.Count - 1);
		CellPartition cellPartition = partitions[partitionKey];
		if (count == 32)
		{
			cellPartition.RemovePackedCell(cellId);
			cellPartition.AddCellWithSpace(cellId);
		}
		else if (num2 == 0)
		{
			cellPartition.RemoveCellWithSpace(cellId);
			if (cellPartition.IsEmpty())
			{
				partitions.Remove(partitionKey);
				Pool.Free<CellPartition>(ref cellPartition);
			}
			RecycleCell(cellId);
		}
		meshLookup.Remove(virtualMeshId);
		return true;
	}

	public InstancedMeshData? TryGetMeshData(long virtualMeshId)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (!meshLookup.TryGetValue(virtualMeshId, out var value))
		{
			return null;
		}
		InstancedMeshData value2 = default(InstancedMeshData);
		value2.CullData = CullData[value];
		value2.LocalToWorld = PositionData[value];
		return value2;
	}

	public void SetMeshVisible(long virtualMeshId, bool visible)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (!meshLookup.TryGetValue(virtualMeshId, out var value))
		{
			Debug.LogError((object)$"Trying to remove mesh {virtualMeshId} that doesn't exist");
			return;
		}
		InstancedCullData instancedCullData = CullData[value];
		if (instancedCullData.IsVisible != visible)
		{
			instancedCullData.IsVisible = visible;
			CullData[value] = instancedCullData;
			if (Render.computebuffer_setdata_immediate)
			{
				CullingDataBuffer.SetData(CullData, value, value, 1);
			}
			else
			{
				dirty = true;
			}
		}
	}

	public void SetOverride(long virtualMeshId, MeshOverrideData newData)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (!meshLookup.TryGetValue(virtualMeshId, out var value))
		{
			Debug.LogError((object)$"Trying to set override of mesh {virtualMeshId} that doesn't exist");
		}
		else if (OverrideArray[value] != newData)
		{
			OverrideArray[value] = newData;
			if (Render.computebuffer_setdata_immediate)
			{
				OverrideBuffer.SetData(OverrideArray, value, value, 1);
			}
			else
			{
				dirty = true;
			}
		}
	}

	private CellId CreateCell(int sortingKey)
	{
		CellId result;
		if (recycledCells.Count > 0)
		{
			result = recycledCells[recycledCells.Count - 1];
			recycledCells.RemoveAt(recycledCells.Count - 1);
		}
		else
		{
			result = new CellId(CellCount);
			CellCount++;
		}
		if (Cells.Length <= CellCount)
		{
			ExpandData();
		}
		Cells[result.Index] = new CellHeader
		{
			Count = 0,
			PartitionKey = sortingKey,
			StartIndex = result.Index * 32
		};
		return result;
	}

	public void ExpandData()
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		NativeArrayEx.Expand(ref Cells, Cells.Length * 2, (NativeArrayOptions)1);
		int newCapacity = Cells.Length * 32;
		NativeArrayEx.Expand(ref CullData, newCapacity, (NativeArrayOptions)1);
		PositionData.Expand<float4x4>(newCapacity, (NativeArrayOptions)1, copyContents: true, usePowerOfTwo: false);
		NativeArrayEx.Expand(ref OverrideArray, newCapacity, (NativeArrayOptions)1);
		CullingDataBuffer.Expand(newCapacity);
		CullingDataBuffer.SetData(CullData);
		PositionBuffer.Expand(newCapacity);
		PositionBuffer.SetData(PositionData);
		OverrideBuffer.Expand(newCapacity);
		OverrideBuffer.SetData(OverrideArray);
	}

	private void RecycleCell(CellId cellId)
	{
		recycledCells.Add(cellId);
	}

	private CellId GetCellId(int index)
	{
		return new CellId(index / 32);
	}

	public void PrintMemoryUsage(StringBuilder builder)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		int num = ((IEnumerable<CellHeader>)(object)Cells).Take(CellCount).Sum((CellHeader x) => 32 - x.Count);
		int num2 = CellCount * 32;
		builder.AppendLine("### CellAllocator ###");
		builder.AppendLine($"Cells: {CellCount}");
		builder.AppendLine($"Empty Space In Cells: {num} / {num2} ({Math.Round((double)num / (double)num2, 1)}%)");
		builder.MemoryUsage<CellHeader>("Cell Headers", Cells);
		builder.MemoryUsage<InstancedCullData>("Data Array", CullData);
		builder.MemoryUsage("MeshLookup", (ICollection<KeyValuePair<long, int>>)meshLookup);
		builder.MemoryUsage("Recycled Cells", (ICollection<CellId>)recycledCells);
		builder.MemoryUsage("Partitions", (ICollection<KeyValuePair<int, CellPartition>>)partitions);
		builder.AppendLine("# Allocation Summary #");
		var array = (from x in ((IEnumerable<CellHeader>)(object)Cells).Take(CellCount)
			group x by x.Count into x
			select new
			{
				amountInCell = x.Key,
				count = x.Count()
			} into x
			orderby x.amountInCell
			select x).ToArray();
		foreach (var anon in array)
		{
			builder.AppendLine($"{anon.amountInCell}/{32} Cells: {anon.count}");
		}
	}

	public void FlushComputeBuffers()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (dirty)
		{
			dirty = false;
			CullingDataBuffer.SetData(CullData);
			PositionBuffer.SetData(PositionData);
			OverrideBuffer.SetData(OverrideArray);
		}
	}
}


using System.Collections.Generic;
using Facepunch;

private class CellPartition : IPooled
{
	public List<CellId> PackedCells;

	public List<CellId> CellsWithSpace;

	public bool IsEmpty()
	{
		if (PackedCells.IsNullOrEmpty())
		{
			return CellsWithSpace.IsNullOrEmpty();
		}
		return false;
	}

	public void AddPackedCell(CellId cell)
	{
		if (PackedCells == null)
		{
			PackedCells = Pool.Get<List<CellId>>();
		}
		PackedCells.Add(cell);
	}

	public void RemovePackedCell(CellId cell)
	{
		if (PackedCells != null)
		{
			PackedCells.Remove(cell);
			if (PackedCells.Count == 0)
			{
				Pool.FreeUnmanaged<CellId>(ref PackedCells);
			}
		}
	}

	public void AddCellWithSpace(CellId cell)
	{
		if (CellsWithSpace == null)
		{
			CellsWithSpace = Pool.Get<List<CellId>>();
		}
		CellsWithSpace.Add(cell);
	}

	public void RemoveCellWithSpace(CellId cell)
	{
		if (CellsWithSpace != null)
		{
			CellsWithSpace.Remove(cell);
			if (CellsWithSpace.Count == 0)
			{
				Pool.FreeUnmanaged<CellId>(ref CellsWithSpace);
			}
		}
	}

	public void EnterPool()
	{
		if (PackedCells != null)
		{
			Pool.FreeUnmanaged<CellId>(ref PackedCells);
		}
		if (CellsWithSpace != null)
		{
			Pool.FreeUnmanaged<CellId>(ref CellsWithSpace);
		}
	}

	public void LeavePool()
	{
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct RenderSlice
{
	[FieldOffset(0)]
	public uint StartIndex;

	[FieldOffset(4)]
	public uint Length;
}


using System.Text;
using Instancing;
using Unity.Collections;
using UnityEngine;

public class CullingManager
{
	public NativeArray<RenderSlice> RenderSlicesArray;

	public GPUBuffer<RenderSlice> RenderSlicesBuffer;

	public void Initialize()
	{
		AllocateNativeMemory();
	}

	public void OnDestroy()
	{
		FreeNativeMemory();
	}

	private void AllocateNativeMemory()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		int num = 512;
		RenderSlicesArray = new NativeArray<RenderSlice>(num, (Allocator)4, (NativeArrayOptions)1);
		RenderSlicesBuffer = new GPUBuffer<RenderSlice>(num, GPUBuffer.Target.Structured);
	}

	private void FreeNativeMemory()
	{
		NativeArrayEx.SafeDispose(ref RenderSlicesArray);
		RenderSlicesBuffer?.Dispose();
		RenderSlicesBuffer = null;
	}

	public void EnsureCapacity(int rendererCount)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (RenderSlicesArray.Length < rendererCount + 1)
		{
			int newCapacity = Mathf.ClosestPowerOfTwo(rendererCount) * 2;
			NativeArrayEx.Expand(ref RenderSlicesArray, newCapacity, (NativeArrayOptions)1);
			RenderSlicesBuffer.Expand(newCapacity);
			RenderSlicesBuffer.SetData(RenderSlicesArray);
		}
	}

	public void PrintMemoryUsage(StringBuilder builder)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		builder.AppendLine("### CullingManager ###");
		builder.MemoryUsage<RenderSlice>("PostCullInstanceCounts", RenderSlicesArray);
	}

	public void UpdateComputeBuffers()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		RenderSlicesBuffer.SetData(RenderSlicesArray);
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct DrawCallJobData
{
	[FieldOffset(0)]
	public int DrawCallIndex;

	[FieldOffset(4)]
	public int RendererIndex;

	[FieldOffset(8)]
	public uint IndexCount;

	[FieldOffset(12)]
	public uint IndexStart;

	[FieldOffset(16)]
	public uint VertexStart;

	[FieldOffset(20)]
	public uint MultidrawIndexStart;

	[FieldOffset(24)]
	public uint MultidrawVertexStart;

	[FieldOffset(28)]
	public int Padding1;
}


using System;
using Instancing;
using UnityEngine;
using UnityEngine.Rendering;

public struct DrawCallKey : IEquatable<DrawCallKey>, IComparable<DrawCallKey>, IComparable
{
	public Material Material;

	public ShadowCastingMode ShadowMode;

	public bool ReceiveShadows;

	public LightProbeUsage LightProbes;

	public DrawCallKey(Material material, ShadowCastingMode shadowMode, bool receiveShadows, LightProbeUsage lightProbes)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Material = material;
		ShadowMode = shadowMode;
		ReceiveShadows = receiveShadows;
		LightProbes = lightProbes;
	}

	public int CompareTo(DrawCallKey other)
	{
		return GetHashCode().CompareTo(other.GetHashCode());
	}

	public int CompareTo(object obj)
	{
		if (obj == null)
		{
			return 1;
		}
		if (obj is DrawCallKey other)
		{
			return CompareTo(other);
		}
		throw new ArgumentException("Object must be 'DrawCallKey'");
	}

	public bool Equals(DrawCallKey other)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Material == (Object)(object)other.Material && ShadowMode == other.ShadowMode && ReceiveShadows == other.ReceiveShadows)
		{
			return LightProbes == other.LightProbes;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is DrawCallKey other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return HashCode.Combine<int, ShadowCastingMode, bool, LightProbeUsage>(((object)Material)?.GetHashCode() ?? 0, ShadowMode, ReceiveShadows, LightProbes);
	}

	public static bool operator ==(DrawCallKey a, DrawCallKey b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(DrawCallKey a, DrawCallKey b)
	{
		return !(a == b);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Instancing;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

public class DrawCallManager
{
	private class DrawCall
	{
		public int DrawCallIndex;

		public int RendererId;

		public Mesh Mesh;

		public int SubmeshIndex;

		public Material Material;

		public Material MultidrawMaterial;

		public ShadowCastingMode ShadowMode;

		public bool ReceiveShadows;

		public LightProbeUsage LightProbes;

		public InstancedMeshCategory MeshCategory;

		public int MultiDrawExtraCount;

		private DrawCallKey _key;

		public DrawCallJobData JobData;

		public MaterialPropertyBlock MaterialBlock = new MaterialPropertyBlock();

		public DrawCallKey CalculateKey()
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			if (_key == default(DrawCallKey))
			{
				_key = new DrawCallKey(Material, ShadowMode, ReceiveShadows, LightProbes);
			}
			return _key;
		}
	}

	private readonly CellMeshAllocator cellAllocator;

	private readonly GeometryBuffers GeometryBuffers;

	public NativeArray<DrawCallJobData> DrawCallArray;

	public GPUBuffer<DrawCallJobData> DrawCallBuffer;

	public GPUBuffer<uint> IndirectArgsBuffer;

	public GPUBuffer<uint> IndirectExtraArgBuffer;

	public GPUBuffer<uint> RenderBuffer;

	private int _overrideBufferVersion;

	private int _positionBufferVersion;

	private List<DrawCall> DrawCalls = new List<DrawCall>();

	private bool _needsDrawCallRebuild;

	private int IndirectArgCapacity;

	private const int renderLayer = 2097152;

	private const int initialCapacity = 1024;

	private Bounds cullingBounds = new Bounds(Vector3.zero, Vector3.one * 30000f);

	public int DrawCallsLastFrame { get; private set; }

	public int DrawCallCount => DrawCalls.Count;

	public DrawCallManager(CellMeshAllocator cellAllocator, GeometryBuffers geometryBuffers)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		this.cellAllocator = cellAllocator;
		GeometryBuffers = geometryBuffers;
	}

	public void Initialize()
	{
		DrawCalls = new List<DrawCall>();
		AllocateNativeMemory();
	}

	public void OnDestroy()
	{
		FreeNativeMemory();
	}

	private void AllocateNativeMemory()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		IndirectArgCapacity = 1024;
		DrawCallArray = new NativeArray<DrawCallJobData>(IndirectArgCapacity, (Allocator)4, (NativeArrayOptions)1);
		DrawCallBuffer = new GPUBuffer<DrawCallJobData>(IndirectArgCapacity, GPUBuffer.Target.Structured);
		IndirectArgsBuffer = new GPUBuffer<uint>(IndirectArgCapacity * 5, GPUBuffer.Target.IndirectArgs);
		IndirectExtraArgBuffer = new GPUBuffer<uint>(IndirectArgCapacity, GPUBuffer.Target.Structured);
		RenderBuffer = new GPUBuffer<uint>(32000, GPUBuffer.Target.Structured);
	}

	private void FreeNativeMemory()
	{
		NativeArrayEx.SafeDispose(ref DrawCallArray);
		DrawCallBuffer?.Dispose();
		DrawCallBuffer = null;
		IndirectArgsBuffer?.Dispose();
		IndirectArgsBuffer = null;
		IndirectExtraArgBuffer?.Dispose();
		IndirectExtraArgBuffer = null;
		RenderBuffer?.Dispose();
		RenderBuffer = null;
	}

	public void AddDrawCall(InstancedMeshRenderer renderer, int submeshIndex, uint indicies, uint indiciesIndex, uint vertexIndex, MultidrawMeshInfo multidraw)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		int count = DrawCalls.Count;
		int num = Math.Min(renderer.Materials.Length - 1, submeshIndex);
		DrawCall drawCall = new DrawCall
		{
			DrawCallIndex = count,
			LightProbes = renderer.LightProbes,
			Material = renderer.Materials[num],
			MultidrawMaterial = renderer.MultidrawMaterials[num],
			Mesh = renderer.Mesh,
			ReceiveShadows = renderer.RecieveShadows,
			RendererId = renderer.RendererId,
			ShadowMode = renderer.CastShadows,
			MeshCategory = renderer.MeshCategory,
			SubmeshIndex = submeshIndex
		};
		drawCall.JobData = new DrawCallJobData
		{
			IndexCount = indicies,
			IndexStart = indiciesIndex,
			VertexStart = vertexIndex,
			MultidrawIndexStart = (uint)multidraw.IndexStart,
			MultidrawVertexStart = (uint)multidraw.VertexStart,
			DrawCallIndex = count,
			RendererIndex = renderer.RendererId
		};
		DrawCalls.Add(drawCall);
		_needsDrawCallRebuild = true;
		EnsureDrawCallCapcity();
		DrawCallArray[count] = drawCall.JobData;
		if (!NeedsToRebuildMaterialBlocks())
		{
			RebuildAllMaterialBlocks();
		}
		else
		{
			UpdateMaterialBlock(drawCall);
		}
	}

	private bool NeedsToRebuildMaterialBlocks()
	{
		if (cellAllocator.PositionBuffer.BufferVersion == _positionBufferVersion)
		{
			return cellAllocator.OverrideBuffer.BufferVersion != _overrideBufferVersion;
		}
		return true;
	}

	private void RebuildAllMaterialBlocks()
	{
		_overrideBufferVersion = cellAllocator.OverrideBuffer.BufferVersion;
		_positionBufferVersion = cellAllocator.PositionBuffer.BufferVersion;
		for (int i = 0; i < DrawCalls.Count; i++)
		{
			UpdateMaterialBlock(DrawCalls[i]);
		}
	}

	private void UpdateMaterialBlock(DrawCall drawCall)
	{
		MaterialPropertyBlock materialBlock = drawCall.MaterialBlock;
		materialBlock.SetBuffer(InstancingUtil.PositionBufferProperty, cellAllocator.PositionBuffer.Buffer);
		materialBlock.SetBuffer(InstancingUtil.RenderBufferProperty, RenderBuffer.Buffer);
		materialBlock.SetBuffer(InstancingUtil.IndirectExtraArgProperty, IndirectExtraArgBuffer.Buffer);
		materialBlock.SetBuffer(InstancingUtil.Param_MeshOverrideBuffer, cellAllocator.OverrideBuffer.Buffer);
		materialBlock.SetBuffer(InstancingUtil.Param_Verticies, GeometryBuffers.VertexBuffer.Buffer);
		materialBlock.SetBuffer(InstancingUtil.Param_Triangles, GeometryBuffers.TriangleBuffer.Buffer);
		materialBlock.SetInt(InstancingUtil.DrawCallIndexProperty, drawCall.DrawCallIndex);
	}

	public void EnsureCapacity(int totalMeshCount)
	{
		bool flag = false;
		if (totalMeshCount > RenderBuffer.count)
		{
			int newCapacity = Mathf.ClosestPowerOfTwo(totalMeshCount) * 2;
			RenderBuffer.Expand(newCapacity);
			flag = true;
		}
		if (NeedsToRebuildMaterialBlocks())
		{
			flag = true;
		}
		if (GeometryBuffers.IsDirty)
		{
			flag = true;
			GeometryBuffers.IsDirty = false;
		}
		if (_needsDrawCallRebuild)
		{
			SortAndBatchDrawCalls();
			_needsDrawCallRebuild = false;
		}
		if (flag)
		{
			RebuildAllMaterialBlocks();
		}
	}

	private void EnsureDrawCallCapcity()
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (DrawCalls.Count > IndirectArgCapacity)
		{
			IndirectArgCapacity = Mathf.ClosestPowerOfTwo(DrawCalls.Count) * 2;
			NativeArrayEx.Expand(ref DrawCallArray, IndirectArgCapacity, (NativeArrayOptions)1);
			DrawCallBuffer.Expand(IndirectArgCapacity);
			DrawCallBuffer.SetData(DrawCallArray);
			IndirectArgsBuffer.Expand(IndirectArgCapacity * 5);
			IndirectExtraArgBuffer.Expand(IndirectArgCapacity);
		}
	}

	public void UpdateComputeBuffers()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		DrawCallBuffer.SetData(DrawCallArray);
	}

	private void SortAndBatchDrawCalls()
	{
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		DrawCalls = DrawCalls.OrderBy((DrawCall x) => x.CalculateKey().GetHashCode()).ToList();
		foreach (DrawCall drawCall3 in DrawCalls)
		{
			drawCall3.MultiDrawExtraCount = 0;
		}
		int num;
		for (num = 0; num < DrawCalls.Count; num++)
		{
			DrawCall drawCall = DrawCalls[num];
			for (int i = num + 1; i < DrawCalls.Count && DrawCalls[i].CalculateKey() == drawCall.CalculateKey(); i++)
			{
				drawCall.MultiDrawExtraCount++;
			}
			num += drawCall.MultiDrawExtraCount;
		}
		for (int j = 0; j < DrawCalls.Count; j++)
		{
			DrawCall drawCall2 = DrawCalls[j];
			drawCall2.DrawCallIndex = j;
			drawCall2.JobData.DrawCallIndex = drawCall2.DrawCallIndex;
			DrawCallArray[j] = drawCall2.JobData;
		}
		DrawCallBuffer.SetData(DrawCallArray);
	}

	public void SubmitDrawCalls()
	{
		DrawCallsLastFrame = 0;
		SubmitDrawCallsInternal(MainCamera.mainCamera);
	}

	private void SubmitDrawCallsInternal(Camera camera)
	{
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Invalid comparison between Unknown and I4
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Invalid comparison between Unknown and I4
		if ((Object)(object)camera == (Object)null || !((Behaviour)camera).enabled)
		{
			return;
		}
		if (Render.IsMultidrawEnabled)
		{
			Shader.EnableKeyword(ref InstancingUtil.Keyword_Rust_Procedural_Rendering);
		}
		for (int i = 0; i < DrawCalls.Count; i++)
		{
			DrawCall drawCall = DrawCalls[i];
			switch (drawCall.MeshCategory)
			{
			case InstancedMeshCategory.BuildingBlock:
				if (!Render.instanced_toggle_buildings)
				{
					continue;
				}
				break;
			case InstancedMeshCategory.Cliff:
				if (!Render.instanced_toggle_cliffs)
				{
					continue;
				}
				break;
			case InstancedMeshCategory.Other:
				if (!Render.instanced_toggle_other)
				{
					continue;
				}
				break;
			}
			DrawCallsLastFrame++;
			if (Render.IsMultidrawEnabled)
			{
				RenderParams val = default(RenderParams);
				((RenderParams)(ref val)).camera = camera;
				((RenderParams)(ref val)).layer = 2097152;
				((RenderParams)(ref val)).lightProbeUsage = drawCall.LightProbes;
				((RenderParams)(ref val)).material = drawCall.MultidrawMaterial;
				((RenderParams)(ref val)).worldBounds = cullingBounds;
				((RenderParams)(ref val)).shadowCastingMode = drawCall.ShadowMode;
				((RenderParams)(ref val)).receiveShadows = drawCall.ReceiveShadows;
				((RenderParams)(ref val)).matProps = drawCall.MaterialBlock;
				RenderParams val2 = val;
				if (((int)((RenderParams)(ref val2)).shadowCastingMode != 1 && (int)((RenderParams)(ref val2)).shadowCastingMode != 3) || Render.render_shadows)
				{
					Graphics.RenderPrimitivesIndexedIndirect(ref val2, (MeshTopology)0, GeometryBuffers.TriangleBuffer.Buffer, IndirectArgsBuffer.Buffer, 1 + drawCall.MultiDrawExtraCount, i);
				}
				i += drawCall.MultiDrawExtraCount;
			}
			else
			{
				int num = drawCall.DrawCallIndex * 5 * 4;
				Graphics.DrawMeshInstancedIndirect(drawCall.Mesh, drawCall.SubmeshIndex, drawCall.Material, cullingBounds, IndirectArgsBuffer.Buffer, num, drawCall.MaterialBlock, drawCall.ShadowMode, drawCall.ReceiveShadows, 2097152, camera, drawCall.LightProbes);
			}
		}
		Shader.DisableKeyword(ref InstancingUtil.Keyword_Rust_Procedural_Rendering);
	}

	public void PrintMemoryUsage(StringBuilder builder)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		builder.AppendLine("### DrawCallManager ###");
		builder.MemoryUsage("RenderBuffer", RenderBuffer.Buffer);
		builder.MemoryUsage("IndirectArgsBuffer", IndirectArgsBuffer.Buffer);
		builder.MemoryUsage("IndirectExtraArgsBuffer", IndirectExtraArgBuffer.Buffer);
		builder.MemoryUsage<DrawCallJobData>("DrawCallArray", DrawCallArray, DrawCalls.Count);
		builder.MemoryUsage("DrawCalls", (ICollection<DrawCall>)DrawCalls);
	}
}


using UnityEngine;
using UnityEngine.Rendering;

private class DrawCall
{
	public int DrawCallIndex;

	public int RendererId;

	public Mesh Mesh;

	public int SubmeshIndex;

	public Material Material;

	public Material MultidrawMaterial;

	public ShadowCastingMode ShadowMode;

	public bool ReceiveShadows;

	public LightProbeUsage LightProbes;

	public InstancedMeshCategory MeshCategory;

	public int MultiDrawExtraCount;

	private DrawCallKey _key;

	public DrawCallJobData JobData;

	public MaterialPropertyBlock MaterialBlock = new MaterialPropertyBlock();

	public DrawCallKey CalculateKey()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (_key == default(DrawCallKey))
		{
			_key = new DrawCallKey(Material, ShadowMode, ReceiveShadows, LightProbes);
		}
		return _key;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

public class InstancedCommandBufferManager
{
	private CommandBuffer normalCommandBuffer;

	private CommandBuffer shadowCommandBuffer;

	public void OnCameraEnabled(Camera camera)
	{
	}

	public void OnCameraDisabled(Camera camera)
	{
	}

	public void UpdateCameraHook()
	{
	}
}


using Unity.Collections;

public class InstancedCullingManager
{
	public NativeArray<int> RenderSliceIndexes;

	public NativeArray<int> PostCullingMeshCounts;
}


using System.Collections.Generic;
using UnityEngine;

public class MaterialCache
{
	public Dictionary<Material, Material> modifiedMaterials = new Dictionary<Material, Material>();

	public Material EnableProceduralInstancing(Material material)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		if (modifiedMaterials.TryGetValue(material, out var value))
		{
			return value;
		}
		value = new Material(material);
		value.enableInstancing = true;
		value.EnableKeyword("PROCEDURAL_INSTANCING_ON");
		modifiedMaterials.Add(material, value);
		RequestTextureStreaming(material);
		return value;
	}

	private void RequestTextureStreaming(Material material)
	{
		RequestMipmap(material, "_MainTex");
		RequestMipmap(material, "_MetallicGlossMap");
		RequestMipmap(material, "_SpecGlossMap");
		RequestMipmap(material, "_BumpMap");
		RequestMipmap(material, "_OcclusionMap");
		RequestMipmap(material, "_EmissionMap");
		RequestMipmap(material, "_TransmissionMap");
		RequestMipmap(material, "_SubsurfaceMaskMap");
		RequestMipmap(material, "_TransmissionMaskMap");
		RequestMipmap(material, "_DetailMask");
		RequestMipmap(material, "_DetailOcclusionMap");
		RequestMipmap(material, "_BiomeLayer_TintMask");
		RequestMipmap(material, "_WetnessLayer_Mask");
		RequestMipmap(material, "_DetailAlbedoMap");
		RequestMipmap(material, "_DetailMetallicGlossMap");
		RequestMipmap(material, "_DetailNormalMap");
		RequestMipmap(material, "_DetailTintMap");
		RequestMipmap(material, "_DetailBlendMaskMap");
	}

	private void RequestMipmap(Material material, string textureName)
	{
		if (material.HasTexture(textureName))
		{
			Texture texture = material.GetTexture(textureName);
			Texture2D val = (Texture2D)(object)((texture is Texture2D) ? texture : null);
			if ((Object)(object)val != (Object)null)
			{
				val.requestedMipmapLevel = 0;
			}
		}
	}

	public void FreeMemory()
	{
		foreach (Material value in modifiedMaterials.Values)
		{
			Object.DestroyImmediate((Object)(object)value);
		}
		modifiedMaterials = new Dictionary<Material, Material>();
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;
using Instancing;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;

public class MeshGridManager
{
	private struct MeshGridKey
	{
		public int SpatialId;

		public bool IsShadow;
	}

	private class GridAllocationInfo
	{
		public List<int> Cells = new List<int>();
	}

	public NativeArray<GridJobData> Grids;

	private float HalfWorldSize;

	private float GridSize;

	private const int GridCount = 32;

	private const int normalGridCount = 1024;

	private const int shadowGridCount = 1024;

	private const int outOfBoundsGrid = 2048;

	private const int lastGridId = 2048;

	public void Initialize()
	{
		AllocateNativeMemory();
	}

	public void OnDestroy()
	{
		FreeNativeMemory();
	}

	private void AllocateNativeMemory()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Grids = new NativeArray<GridJobData>(2049, (Allocator)4, (NativeArrayOptions)1);
	}

	private void FreeNativeMemory()
	{
		NativeArrayEx.SafeDispose(ref Grids);
	}

	public int GetPartitionKey(float3 position, bool hasShadow)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		int num = GetGridId(position);
		if (hasShadow && num != 2048)
		{
			num += 1024;
		}
		return num;
	}

	public void SetWorldSize(float worldSize)
	{
		GridSize = worldSize / 32f;
		HalfWorldSize = worldSize / 2f;
		UpdateGridBounds();
	}

	private void UpdateGridBounds()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Grids.Length; i++)
		{
			GridJobData gridJobData = Grids[i];
			gridJobData.GridId = i;
			if (i < 1024)
			{
				gridJobData.CanBeFrustumCulled = true;
			}
			if (i < 2048)
			{
				Bounds gridBounds = GetGridBounds(i);
				gridJobData.CanBeDistanceCulled = true;
				gridJobData.MinBounds = float3.op_Implicit(((Bounds)(ref gridBounds)).min);
				gridJobData.MaxBounds = float3.op_Implicit(((Bounds)(ref gridBounds)).max);
			}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private int GetGridId(float3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		int num = (int)((point.x + HalfWorldSize) / GridSize);
		int num2 = (int)((point.z + HalfWorldSize) / GridSize);
		if (num < 0 || num2 < 0 || num >= 32 || num2 >= 32)
		{
			return 2048;
		}
		return num + num2 * 32;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private float3 GetGridCenter(int gridId)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (gridId >= 1024 && gridId < 2048)
		{
			gridId -= 1024;
		}
		float num = (float)(gridId % 32) * GridSize - HalfWorldSize;
		float num2 = (float)(gridId / 32) * GridSize - HalfWorldSize;
		return new float3(num + GridSize / 2f, 0f, num2 + GridSize / 2f);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private Bounds GetGridBounds(int gridId)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float3 gridCenter = GetGridCenter(gridId);
		return new Bounds(float3.op_Implicit(gridCenter), new Vector3(GridSize, 1000f, GridSize));
	}

	public void PrintMemoryUsage(StringBuilder builder)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		builder.AppendLine("### GridManager ###");
		builder.MemoryUsage<GridJobData>("Grids", Grids, Grids.Length);
	}
}


private struct MeshGridKey
{
	public int SpatialId;

	public bool IsShadow;
}


using System.Collections.Generic;

private class GridAllocationInfo
{
	public List<int> Cells = new List<int>();
}


using System.Collections.Generic;
using System.Linq;
using System.Text;
using Instancing;
using Unity.Collections;
using UnityEngine;

public class RenderManager
{
	public NativeArray<InstancedRendererJobData> RendererArray;

	public NativeArray<uint> MeshCountArray;

	private Dictionary<MeshRenderKey, InstancedMeshRenderer> rendererLookup = new Dictionary<MeshRenderKey, InstancedMeshRenderer>();

	public List<InstancedMeshRenderer> Renderers = new List<InstancedMeshRenderer>();

	public GeometryBuffers GeometryBuffers;

	private const int initialRendererCapacity = 512;

	private readonly DrawCallManager drawCallManager;

	private readonly MaterialCache _materialCache;

	public int TotalMeshCount { get; private set; }

	public int TotalDrawCallCount { get; private set; }

	public int RendererCount => Renderers.Count;

	public RenderManager(DrawCallManager drawCalls, GeometryBuffers geometryBuffers, MaterialCache materialCache)
	{
		drawCallManager = drawCalls;
		GeometryBuffers = geometryBuffers;
		_materialCache = materialCache;
	}

	public void Initialize()
	{
		Renderers = new List<InstancedMeshRenderer>();
		rendererLookup = new Dictionary<MeshRenderKey, InstancedMeshRenderer>();
		TotalMeshCount = 0;
		TotalDrawCallCount = 0;
		AllocateNativeMemory();
	}

	public void OnDestroy()
	{
		FreeNativeMemory();
	}

	private void AllocateNativeMemory()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		RendererArray = new NativeArray<InstancedRendererJobData>(512, (Allocator)4, (NativeArrayOptions)1);
		MeshCountArray = new NativeArray<uint>(512, (Allocator)4, (NativeArrayOptions)1);
	}

	private void FreeNativeMemory()
	{
		NativeArrayEx.SafeDispose(ref RendererArray);
		NativeArrayEx.SafeDispose(ref MeshCountArray);
	}

	public void OnMeshAdded(int rendererId)
	{
		MeshCountArray[rendererId] += 1;
		TotalMeshCount++;
	}

	public void OnMeshRemoved(int rendererId)
	{
		MeshCountArray[rendererId] -= 1;
		TotalMeshCount--;
	}

	public Bounds CalculateMeshBounds(int meshId, Matrix4x4 localToWorld)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return GeometryUtility.CalculateBounds(Renderers[meshId].BoundsPoints, localToWorld);
	}

	public bool DoesRendererHaveShadow(int meshId)
	{
		return Renderers[meshId].HasShadow;
	}

	public bool DoesRendererHaveMesh(int rendererId)
	{
		return Renderers[rendererId].HasMesh;
	}

	public bool IsLastLOD(int rendererId)
	{
		return Renderers[rendererId].IsLastLod;
	}

	public int GetRendererId(InstancedLODState lod)
	{
		InstancedMeshRenderer instancedMeshRenderer = GetRenderer(lod);
		if (instancedMeshRenderer == null)
		{
			instancedMeshRenderer = RegisterRenderer(lod);
		}
		return instancedMeshRenderer.RendererId;
	}

	public float GetMinDistance(int rendererId)
	{
		return RendererArray[rendererId].MinDistance;
	}

	public float GetMaxDistance(int rendererId)
	{
		return RendererArray[rendererId].MaxDistance;
	}

	public Mesh GetMeshForRenderer(int rendererId)
	{
		return Renderers[rendererId].Mesh;
	}

	private InstancedMeshRenderer GetRenderer(InstancedLODState lod)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		MeshRenderKey key = new MeshRenderKey(lod.Mesh, lod.Materials, lod.CastShadows, lod.RecieveShadows, lod.LightProbes);
		rendererLookup.TryGetValue(key, out var value);
		return value;
	}

	private InstancedMeshRenderer RegisterRenderer(InstancedLODState lod)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		MeshRenderKey key = new MeshRenderKey(lod.Mesh, lod.Materials, lod.CastShadows, lod.RecieveShadows, lod.LightProbes);
		if (rendererLookup.TryGetValue(key, out var value))
		{
			Debug.LogWarning((object)"Tried to register a renderer that already exists: skipping");
			return value;
		}
		int count = Renderers.Count;
		int drawCallCount = drawCallManager.DrawCallCount;
		Material[] multidrawMaterials = key.Materials.Select((Material x) => _materialCache.EnableProceduralInstancing(x)).ToArray();
		InstancedMeshRenderer instancedMeshRenderer = new InstancedMeshRenderer(count, drawCallCount, key, multidrawMaterials, lod.LodLevel, lod.TotalLodLevels, lod.MeshCategory, GeometryBuffers);
		for (int i = 0; i < instancedMeshRenderer.DrawCallCount; i++)
		{
			Mesh mesh = instancedMeshRenderer.Mesh;
			drawCallManager.AddDrawCall(instancedMeshRenderer, i, mesh.GetIndexCount(i), mesh.GetIndexStart(i), mesh.GetBaseVertex(i), instancedMeshRenderer.MultidrawSubmeshes[i]);
		}
		rendererLookup[key] = instancedMeshRenderer;
		Renderers.Add(instancedMeshRenderer);
		InstancedRendererJobData instancedRendererJobData = default(InstancedRendererJobData);
		instancedRendererJobData.Id = count;
		instancedRendererJobData.MinDistance = lod.MinimumDistance;
		instancedRendererJobData.MaxDistance = lod.MaximumDistance;
		instancedRendererJobData.ShadowMode = instancedMeshRenderer.CastShadows;
		instancedRendererJobData.DrawCallCount = instancedMeshRenderer.DrawCallCount;
		InstancedRendererJobData instancedRendererJobData2 = instancedRendererJobData;
		EnsureJobDataCapacity();
		RendererArray[count] = instancedRendererJobData2;
		TotalDrawCallCount += instancedMeshRenderer.DrawCallCount;
		return instancedMeshRenderer;
	}

	private void EnsureJobDataCapacity()
	{
		if (RendererArray.Length <= Renderers.Count)
		{
			int newCapacity = Mathf.ClosestPowerOfTwo(Renderers.Count) * 2;
			NativeArrayEx.Expand(ref RendererArray, newCapacity, (NativeArrayOptions)1);
			NativeArrayEx.Expand(ref MeshCountArray, newCapacity, (NativeArrayOptions)1);
		}
	}

	public void PrintMemoryUsage(StringBuilder builder)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		builder.AppendLine("### RenderManager ###");
		builder.MemoryUsage("Renderers", (ICollection<InstancedMeshRenderer>)Renderers);
		builder.MemoryUsage<InstancedRendererJobData>("RendererArray", RendererArray);
		builder.MemoryUsage<uint>("MeshCountArray", MeshCountArray);
	}
}


using System;
using System.Collections.Generic;
using Instancing;
using UnityEngine;

public class TextureAtlasScheduler
{
	private class TextureAtlas
	{
		public int Resolution;

		public Texture2DArray TextureArray;

		public List<TextureAtlasItem> Textures = new List<TextureAtlasItem>();
	}

	private class TextureAtlasItem
	{
		public Texture Texture;

		public bool Occupied;
	}

	public static readonly TextureAtlasScheduler Instanced = new TextureAtlasScheduler();

	private Dictionary<int, TextureAtlas> textureAtlases = new Dictionary<int, TextureAtlas>();

	private int AddTexture(TextureAtlas atlas, Texture texture)
	{
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Expected O, but got Unknown
		int num = atlas.Textures.FindIndex((TextureAtlasItem x) => !x.Occupied);
		if (num == -1)
		{
			atlas.Textures.Add(new TextureAtlasItem());
			num = atlas.Textures.Count - 1;
		}
		TextureAtlasItem textureAtlasItem = atlas.Textures[num];
		textureAtlasItem.Occupied = false;
		if (atlas.TextureArray.depth < atlas.Textures.Count)
		{
			Texture2DArray val = new Texture2DArray(atlas.Resolution, atlas.Resolution, atlas.TextureArray.depth * 2, atlas.TextureArray.format, false);
			Graphics.CopyTexture((Texture)(object)atlas.TextureArray, (Texture)(object)val);
			Object.Destroy((Object)(object)atlas.TextureArray);
			atlas.TextureArray = val;
		}
		textureAtlasItem.Texture = texture;
		textureAtlasItem.Occupied = true;
		return num;
	}

	private void UpdateTexture(TextureAtlas atlas, Texture texture, int index)
	{
		atlas.Textures[index].Texture = texture;
		Graphics.CopyTexture(texture, (Texture)(object)atlas.TextureArray);
	}

	public int AddTextureToAtlas(Texture texture)
	{
		TextureAtlas orCreateAtlas = GetOrCreateAtlas(texture.width, texture.height);
		return AddTexture(orCreateAtlas, texture);
	}

	public void ReplaceTextureInAtlas(Texture texture, int index)
	{
		GetOrCreateAtlas(texture.width, texture.height);
	}

	private TextureAtlas GetOrCreateAtlas(int width, int height)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Expected O, but got Unknown
		if (width != height)
		{
			throw new NotSupportedException("Textures must be the same width and height");
		}
		if (!textureAtlases.TryGetValue(width, out var value))
		{
			value = new TextureAtlas
			{
				Resolution = width,
				TextureArray = new Texture2DArray(width, height, 8, (TextureFormat)5, false)
			};
			textureAtlases[width] = value;
		}
		return value;
	}

	private int GetResolutionKey(int xSize, int ySize)
	{
		return xSize * 10000 + ySize;
	}
}


using System.Collections.Generic;
using UnityEngine;

private class TextureAtlas
{
	public int Resolution;

	public Texture2DArray TextureArray;

	public List<TextureAtlasItem> Textures = new List<TextureAtlasItem>();
}


using UnityEngine;

private class TextureAtlasItem
{
	public Texture Texture;

	public bool Occupied;
}


using Instancing;

public class VirtualMeshScheduler
{
	public static readonly VirtualMeshScheduler Instance = new VirtualMeshScheduler();
}


public class VirtualPrefabScheduler
{
}


using System;
using System.Collections.Generic;
using Instancing;
using Rust.Workshop;
using UnityEngine;

public class WorkshopSkinScheduler
{
	private class SkinnableData
	{
		public List<DefaultSkinTexture> DefaultTextures = new List<DefaultSkinTexture>();
	}

	private class SkinData
	{
		public ulong SkinId;

		public SkinTexture[] Textures;
	}

	public struct DefaultSkinTexture
	{
		public int Resolution;

		public string Path;

		public Texture Texture;
	}

	public struct SkinTexture
	{
		public int Resolution;

		public int TextureIndex;

		public SkinTexture(int resolution, int textureIndex)
		{
			Resolution = resolution;
			TextureIndex = textureIndex;
		}
	}

	private Dictionary<ulong, SkinData> skinLookup = new Dictionary<ulong, SkinData>();

	private Dictionary<ulong, Skinnable> skinnableLookup = new Dictionary<ulong, Skinnable>();

	public SkinTexture[] GetTextures(Skin skinDef, ulong skinId)
	{
		if (!skinLookup.TryGetValue(skinId, out var value))
		{
			value = InitializeSkin(skinDef, skinId);
		}
		return value.Textures;
	}

	private SkinnableData GetOrCreateSkinnable(Skin skinDef)
	{
		new SkinnableData();
		throw new NotImplementedException();
	}

	private SkinData InitializeSkin(Skin skinDef, ulong skinId)
	{
		SkinData skinData = new SkinData
		{
			SkinId = skinId
		};
		skinLookup.Add(skinId, skinData);
		SkinnableData orCreateSkinnable = GetOrCreateSkinnable(skinDef);
		List<SkinTexture> list = new List<SkinTexture>();
		foreach (DefaultSkinTexture defaultTexture in orCreateSkinnable.DefaultTextures)
		{
			int textureIndex = TextureAtlasScheduler.Instanced.AddTextureToAtlas(defaultTexture.Texture);
			list.Add(new SkinTexture(defaultTexture.Resolution, textureIndex));
			string path = FindSkinTexturePath(skinId);
			LoadTextureAsync(path, defaultTexture.Resolution, textureIndex);
		}
		return skinData;
	}

	private string FindSkinTexturePath(ulong workshopSkin)
	{
		throw new NotImplementedException();
	}

	private void LoadTextureAsync(string path, int resolution, int textureIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Expected O, but got Unknown
		Texture texture = (Texture)new Texture2D(resolution, resolution);
		TextureAtlasScheduler.Instanced.ReplaceTextureInAtlas(texture, textureIndex);
	}
}


using System.Collections.Generic;

private class SkinnableData
{
	public List<DefaultSkinTexture> DefaultTextures = new List<DefaultSkinTexture>();
}


private class SkinData
{
	public ulong SkinId;

	public SkinTexture[] Textures;
}


using UnityEngine;

public struct DefaultSkinTexture
{
	public int Resolution;

	public string Path;

	public Texture Texture;
}


public struct SkinTexture
{
	public int Resolution;

	public int TextureIndex;

	public SkinTexture(int resolution, int textureIndex)
	{
		Resolution = resolution;
		TextureIndex = textureIndex;
	}
}


using System;
using ConVar;
using Instancing;
using Unity.Mathematics;
using UnityEngine;

public class GPUInstancedCulling
{
	public struct CullingParameters
	{
		public ComputeShader cullShader;

		public ComputeShader postCullShader;

		public int shadowCameras;

		public Vector3 cameraPosition;

		public float maxDistance;

		public float distanceScale;

		public GPUBuffer<float4> frustumPlanes;

		public bool frustumCulling;

		public GPUBuffer<InstancedCullData> inputBuffer;

		public int inputLength;

		public GPUBuffer<DrawCallJobData> drawCalls;

		public int drawCallCount;

		public GPUBuffer<RenderSlice> renderSlices;

		public int sliceCount;

		public GPUBuffer<uint> renderBuffer;

		public GPUBuffer<uint> indirectArgs;

		public GPUBuffer<uint> indirectExtraArgs;
	}

	private static readonly int Param_InputBuffer = Shader.PropertyToID("_InputBuffer");

	private static readonly int Param_OutputBuffer = Shader.PropertyToID("_OutputBuffer");

	private static readonly int Param_ComputeBuffer = Shader.PropertyToID("_ComputeBuffer");

	private static readonly int Param_IndirectArgs = Shader.PropertyToID("_IndirectArgs");

	private static readonly int Param_IndirectExtraArgs = Shader.PropertyToID("_IndirectExtraArgs");

	private static readonly int Param_RenderSlices = Shader.PropertyToID("_RenderSlices");

	private static readonly int Param_SliceCounts = Shader.PropertyToID("_SliceCounts");

	private static readonly int Param_FrustumPlanes = Shader.PropertyToID("_FrustumPlanes");

	private static readonly int Param_ShadowFrustumCount = Shader.PropertyToID("_ShadowFrustumCount");

	private static readonly int Param_CameraPosition = Shader.PropertyToID("_CameraPosition");

	private static readonly int Param_MaxDistance = Shader.PropertyToID("_MaxDistance");

	private static readonly int Param_DistanceScale = Shader.PropertyToID("_DistanceScale");

	private static readonly int Param_SliceCount = Shader.PropertyToID("_SliceCount");

	private static readonly int Param_Length = Shader.PropertyToID("_Length");

	private static readonly int Param_DrawCalls = Shader.PropertyToID("_DrawCalls");

	private static readonly int Param_DrawCallCount = Shader.PropertyToID("_DrawCallCount");

	private static readonly int Param_Multidraw_Enabled = Shader.PropertyToID("_Multidraw_Enabled");

	private static readonly int Param_FrustumCullingEnabled = Shader.PropertyToID("_FrustumCullingEnabled");

	private GPUBuffer<uint> tempBuffer;

	private GPUBuffer<uint> postCullMeshCounts;

	public void Initialize()
	{
		AllocateNativeMemory();
	}

	public void OnDestroy()
	{
		FreeNativeMemory();
	}

	private void AllocateNativeMemory()
	{
		tempBuffer = new GPUBuffer<uint>(1024, GPUBuffer.Target.Structured);
		postCullMeshCounts = new GPUBuffer<uint>(1024, GPUBuffer.Target.Structured);
	}

	private void FreeNativeMemory()
	{
		tempBuffer?.Dispose();
		tempBuffer = null;
		postCullMeshCounts?.Dispose();
		postCullMeshCounts = null;
	}

	public void SimpleCulling(CullingParameters options)
	{
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		if (options.renderSlices.count < options.sliceCount + 1)
		{
			throw new ArgumentException("SliceIndexes must be at least as large as slice count + 1!");
		}
		if (tempBuffer.count < options.inputBuffer.count)
		{
			tempBuffer.Expand(options.inputBuffer.count);
		}
		if (postCullMeshCounts.count < options.renderSlices.count)
		{
			postCullMeshCounts.Expand(options.renderSlices.count);
		}
		ClearBuffer(SingletonComponent<InstancedScheduler>.Instance.ClearBufferShader, tempBuffer);
		ClearBuffer(SingletonComponent<InstancedScheduler>.Instance.ClearBufferShader, postCullMeshCounts);
		ClearBuffer(SingletonComponent<InstancedScheduler>.Instance.ClearBufferShader, options.renderBuffer);
		ClearBuffer(SingletonComponent<InstancedScheduler>.Instance.ClearBufferShader, options.indirectArgs);
		ClearBuffer(SingletonComponent<InstancedScheduler>.Instance.ClearBufferShader, options.indirectExtraArgs);
		CullingShader(options.cullShader, options.inputBuffer, options.inputLength, tempBuffer, options.renderSlices, options.frustumPlanes, options.shadowCameras, options.cameraPosition, options.maxDistance, options.distanceScale, options.frustumCulling);
		SimplePostCull(options.postCullShader, tempBuffer, options.renderBuffer, options.renderSlices, options.sliceCount, postCullMeshCounts);
		WriteIndirectArgs(SingletonComponent<InstancedScheduler>.Instance.WriteIndirectArgsShader, postCullMeshCounts, options.renderSlices, options.drawCalls, options.drawCallCount, options.indirectArgs, options.indirectExtraArgs);
	}

	private static void CullingShader(ComputeShader shader, GPUBuffer<InstancedCullData> inputBuffer, int inputLength, GPUBuffer<uint> outputBuffer, GPUBuffer<RenderSlice> renderSlices, GPUBuffer<float4> frustumPlanes, int shadowCameras, Vector3 cameraPosition, float maxDistance, float distanceScale, bool frustumCulling)
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		if (outputBuffer.stride != 4)
		{
			throw new ArgumentException($"Cull output buffer must have a stride of 4 ({outputBuffer.stride})!");
		}
		int iterationCount = GetIterationCount(inputLength, 1024);
		if (iterationCount != 0)
		{
			int num = shader.FindKernel("CullingKernel");
			shader.SetBuffer(num, Param_InputBuffer, inputBuffer);
			shader.SetBuffer(num, Param_OutputBuffer, outputBuffer);
			shader.SetBuffer(num, Param_RenderSlices, renderSlices);
			shader.SetBuffer<float4>(num, Param_FrustumPlanes, frustumPlanes);
			shader.SetVector(Param_CameraPosition, Vector4.op_Implicit(cameraPosition));
			shader.SetFloat(Param_MaxDistance, maxDistance);
			shader.SetFloat(Param_DistanceScale, distanceScale);
			shader.SetFloat(Param_FrustumCullingEnabled, frustumCulling ? 1f : 0f);
			shader.SetInt(Param_ShadowFrustumCount, shadowCameras);
			shader.Dispatch(num, iterationCount, 1, 1);
		}
	}

	private static void SimplePostCull(ComputeShader shader, GPUBuffer<uint> inputBuffer, GPUBuffer<uint> outputBuffer, GPUBuffer<RenderSlice> renderSlices, int sliceCount, GPUBuffer<uint> sliceCounts)
	{
		int iterationCount = GetIterationCount(sliceCount, 1024);
		if (iterationCount != 0)
		{
			int num = shader.FindKernel("SimplePostCull");
			shader.SetBuffer(num, Param_InputBuffer, inputBuffer);
			shader.SetBuffer(num, Param_OutputBuffer, outputBuffer);
			shader.SetBuffer(num, Param_RenderSlices, renderSlices);
			shader.SetBuffer(num, Param_SliceCounts, sliceCounts);
			shader.SetInt(Param_SliceCount, (Render.max_renderers > 0) ? Render.max_renderers : sliceCount);
			shader.Dispatch(num, iterationCount, 1, 1);
		}
	}

	private static void WriteIndirectArgs(ComputeShader shader, GPUBuffer<uint> sliceCounts, GPUBuffer<RenderSlice> renderSlices, GPUBuffer<DrawCallJobData> drawCalls, int drawCallCount, GPUBuffer<uint> indirectArgs, GPUBuffer<uint> indirectExtraArgs)
	{
		int iterationCount = GetIterationCount(drawCallCount, 1024);
		if (iterationCount != 0)
		{
			int num = shader.FindKernel("WriteIndirectArgs");
			shader.SetBuffer(num, Param_SliceCounts, sliceCounts);
			shader.SetBuffer(num, Param_RenderSlices, renderSlices);
			shader.SetBuffer(num, Param_DrawCalls, drawCalls);
			shader.SetInt(Param_DrawCallCount, drawCallCount);
			shader.SetBuffer(num, Param_IndirectArgs, indirectArgs);
			shader.SetBuffer(num, Param_IndirectExtraArgs, indirectExtraArgs);
			shader.SetInt(Param_Multidraw_Enabled, Render.IsMultidrawEnabled ? 1 : 0);
			shader.Dispatch(num, iterationCount, 1, 1);
		}
	}

	private static void ClearBuffer(ComputeShader shader, GPUBuffer<uint> buffer)
	{
		int count = buffer.count;
		int iterationCount = GetIterationCount(count, 1024);
		int num = shader.FindKernel("ClearBufferKernel");
		shader.SetBuffer(num, Param_ComputeBuffer, buffer);
		shader.SetInt(Param_Length, count);
		shader.Dispatch(num, iterationCount, 1, 1);
	}

	private static int GetIterationCount(int count, int threads)
	{
		return count / threads + ((count % threads != 0) ? 1 : 0);
	}
}


using Unity.Mathematics;
using UnityEngine;

public struct CullingParameters
{
	public ComputeShader cullShader;

	public ComputeShader postCullShader;

	public int shadowCameras;

	public Vector3 cameraPosition;

	public float maxDistance;

	public float distanceScale;

	public GPUBuffer<float4> frustumPlanes;

	public bool frustumCulling;

	public GPUBuffer<InstancedCullData> inputBuffer;

	public int inputLength;

	public GPUBuffer<DrawCallJobData> drawCalls;

	public int drawCallCount;

	public GPUBuffer<RenderSlice> renderSlices;

	public int sliceCount;

	public GPUBuffer<uint> renderBuffer;

	public GPUBuffer<uint> indirectArgs;

	public GPUBuffer<uint> indirectExtraArgs;
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct FillFalseJobDefer : IJobParallelForDefer
{
	[ReadOnly]
	public NativeList<Ray> rays;

	public NativeArray<bool> HitResults;

	public void Execute(int index)
	{
		HitResults[index] = false;
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct AdjustByTopologyJob : IJobParallelForDefer
{
	[ReadOnly]
	public NativeList<Ray> rays;

	public NativeArray<bool> hitResults;

	public NativeArray<Vector3> hitNormals;

	public ReadOnly<Vector3> hitPositions;

	[ReadOnly]
	public NativeArray<int> TopologyData;

	[ReadOnly]
	public int TopologyRes;

	[ReadOnly]
	public Vector2 DataOrigin;

	[ReadOnly]
	public Vector2 DataScale;

	public void Execute(int index)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (hitResults[index])
		{
			hitNormals[index] = Vector3.up;
			float num = (hitPositions[index].x - DataOrigin.x) * DataScale.x;
			float num2 = (hitPositions[index].z - DataOrigin.y) * DataScale.y;
			int num3 = Math.Clamp((int)(num * (float)TopologyRes), 0, TopologyRes - 1);
			int num4 = Math.Clamp((int)(num2 * (float)TopologyRes), 0, TopologyRes - 1) * TopologyRes + num3;
			hitResults[index] = ((TopologyData[num4] & 0x80) | 0x100) != 0;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct SmallDisplacementPlaneTraceJob : IJobParallelForDefer
{
	public Plane SeaPlane;

	[ReadOnly]
	public NativeList<Ray> Rays;

	public ReadOnly<float> MaxDists;

	[WriteOnly]
	public NativeArray<bool> HitResults;

	[WriteOnly]
	public NativeArray<Vector3> HitPositions;

	public void Execute(int index)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		Ray val = Rays[index];
		float num = MaxDists[index];
		bool flag = false;
		Vector3 val2 = Vector3.zero;
		float num2 = default(float);
		if (((Plane)(ref SeaPlane)).Raycast(val, ref num2) && num2 < num)
		{
			flag = true;
			val2 = ((Ray)(ref val)).GetPoint(num2);
		}
		HitResults[index] = flag;
		HitPositions[index] = val2;
	}
}


using Rust.Water5;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct OceanTraceJob : IJobParallelForDefer
{
	public const int maxSteps = 16;

	public const int maxBinarySteps = 16;

	public const float intersectionThreshold = 0.1f;

	public const float seaLevel = 0f;

	public float MaxDisplacement;

	[ReadOnly]
	public NativeList<Ray> Rays;

	public ReadOnly<float> MaxDists;

	[WriteOnly]
	public NativeArray<bool> HitResults;

	[WriteOnly]
	public NativeArray<Vector3> HitPositions;

	public float OneOverOctave0Scale;

	[ReadOnly]
	[NativeDisableParallelForRestriction]
	public NativeOceanDisplacementShort3 SimData;

	public int Spectrum0;

	public int Spectrum1;

	public int Frame0;

	public int Frame1;

	public float spectrumBlend;

	public float frameBlend;

	public TerrainHeightMap.HeightMapQueryStructure HeightMapQueryStructure;

	public TerrainTexturing.ShoreVectorQueryStructure ShoreVectorQueryStructure;

	public float distanceAttenuationFactor;

	public float depthAttenuationFactor;

	public void Execute(int index)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		Ray ray = Rays[index];
		float maxDist = MaxDists[index];
		Vector3 result;
		bool flag = Trace(in ray, maxDist, out result);
		HitResults[index] = flag;
		HitPositions[index] = result;
	}

	private bool Trace(in Ray ray, float maxDist, out Vector3 result)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f - MaxDisplacement;
		Ray val = ray;
		Vector3 point = ((Ray)(ref val)).GetPoint(maxDist);
		val = ray;
		if (((Ray)(ref val)).origin.y > MaxDisplacement && point.y > MaxDisplacement)
		{
			result = Vector3.zero;
			return false;
		}
		val = ray;
		if (((Ray)(ref val)).origin.y < num && point.y < num)
		{
			result = Vector3.zero;
			return false;
		}
		val = ray;
		Vector3 val2 = ((Ray)(ref val)).origin;
		val = ray;
		Vector3 direction = ((Ray)(ref val)).direction;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 2f / (math.abs(direction.y) + 1f);
		result = val2;
		if (direction.y <= -0.99f)
		{
			result.y = GetHeight(val2);
			return math.lengthsq(float3.op_Implicit(result - val2)) < maxDist * maxDist;
		}
		if (val2.y >= MaxDisplacement + 0f)
		{
			num3 = (num2 = (0f - (val2.y - MaxDisplacement - 0f)) / direction.y);
			val2 += num2 * direction;
			if (num3 >= maxDist)
			{
				result = Vector3.zero;
				return false;
			}
		}
		int num5 = 0;
		while (true)
		{
			float height = GetHeight(val2);
			num2 = num4 * Mathf.Abs(val2.y - height - 0f);
			val2 += num2 * direction;
			num3 += num2;
			if (num5 >= 16 || num2 < 0.1f)
			{
				break;
			}
			if (num3 >= maxDist)
			{
				return false;
			}
			num5++;
		}
		if (num2 < 0.1f && num3 >= 0f)
		{
			result = val2;
			return true;
		}
		if (direction.y < 0f)
		{
			num2 = (0f - (val2.y + MaxDisplacement - 0f)) / direction.y;
			Vector3 val3 = val2;
			Vector3 val4 = val2;
			float num6 = num2;
			val = ray;
			Vector3 val5 = val4 + num6 * ((Ray)(ref val)).direction;
			for (int i = 0; i < 16; i++)
			{
				val2 = (val3 + val5) * 0.5f;
				float height2 = GetHeight(val2);
				if (val2.y - height2 - 0f > 0f)
				{
					val3 = val2;
				}
				else
				{
					val5 = val2;
				}
				if (math.abs(val2.y - height2) < 0.1f)
				{
					val2.y = height2;
					break;
				}
			}
			result = val2;
			return true;
		}
		return false;
	}

	private float GetHeight(Vector3 point)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return GetHeightRaw(point) * GetHeightAttenuation(point);
	}

	public float GetHeightAttenuation(Vector3 position)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		float x = HeightMapQueryStructure.TerrainPosition.x;
		float z = HeightMapQueryStructure.TerrainPosition.z;
		float x2 = HeightMapQueryStructure.TerrainOneOverSize.x;
		float z2 = HeightMapQueryStructure.TerrainOneOverSize.z;
		float num = (position.x - x) * x2;
		float num2 = (position.z - z) * z2;
		Vector2 uv = default(Vector2);
		((Vector2)(ref uv))..ctor(num, num2);
		float coarseDistanceToShore = ShoreVectorQueryStructure.GetCoarseDistanceToShore(uv);
		float heightFast = HeightMapQueryStructure.GetHeightFast(uv);
		float num3 = Mathf.Clamp01(coarseDistanceToShore / distanceAttenuationFactor);
		float num4 = Mathf.Clamp01(Mathf.Abs(heightFast) / depthAttenuationFactor);
		return num3 * num4;
	}

	private float GetHeightRaw(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		zero = GetDisplacement(position);
		zero = GetDisplacement(position - zero);
		zero = GetDisplacement(position - zero);
		return GetDisplacement(position - zero).y;
	}

	private Vector3 GetDisplacement(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float normX = position.x * OneOverOctave0Scale;
		float normZ = position.z * OneOverOctave0Scale;
		return GetDisplacement(normX, normZ);
	}

	private Vector3 GetDisplacement(float normX, float normZ)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		normX -= math.floor(normX);
		normZ -= math.floor(normZ);
		float num = normX * 256f - 0.5f;
		float num2 = normZ * 256f - 0.5f;
		int num3 = (int)math.floor(num);
		int num4 = (int)math.floor(num2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		int num7 = num3 % 256;
		int num8 = num4 % 256;
		int x = (num7 + 256) % 256;
		int z = (num8 + 256) % 256;
		int x2 = (num7 + 1 + 256) % 256;
		int z2 = (num8 + 1 + 256) % 256;
		Vector3 displacementFromSimData = GetDisplacementFromSimData(x, z);
		Vector3 displacementFromSimData2 = GetDisplacementFromSimData(x2, z);
		Vector3 displacementFromSimData3 = GetDisplacementFromSimData(x, z2);
		Vector3 displacementFromSimData4 = GetDisplacementFromSimData(x2, z2);
		float3 val = math.lerp(float3.op_Implicit(displacementFromSimData), float3.op_Implicit(displacementFromSimData2), num5);
		float3 val2 = math.lerp(float3.op_Implicit(displacementFromSimData3), float3.op_Implicit(displacementFromSimData4), num5);
		return float3.op_Implicit(math.lerp(val, val2, num6));
	}

	private Vector3 GetDisplacementFromSimData(int x, int z)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		int z2 = x * 256 + z;
		float3 val = math.lerp((float3)SimData[Spectrum0, Frame0, z2], (float3)SimData[Spectrum1, Frame0, z2], spectrumBlend);
		float3 val2 = math.lerp((float3)SimData[Spectrum0, Frame1, z2], (float3)SimData[Spectrum1, Frame1, z2], spectrumBlend);
		return float3.op_Implicit(math.lerp(val, val2, frameBlend));
	}
}


using TerrainTopologyMapJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct PaintSplatJob : IJobFor
{
	[NativeDisableParallelForRestriction]
	public ReadOnly<float> HeightMapDelta;

	public int HeightMapRes;

	[NativeDisableParallelForRestriction]
	public ReadOnly<float> AngleMapDeg;

	[NativeDisableParallelForRestriction]
	public ReadOnly<int> TopologyMap;

	public int TopologyMapRes;

	[NativeDisableParallelForRestriction]
	public NativeArray<byte> SplatMap;

	public int SplatMapRes;

	public int SplatNum;

	[NativeDisableParallelForRestriction]
	public ReadOnly<int, int> SplatType2Index;

	public float TerrainOneOverSizeX;

	public void Execute(int index)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		int num = index % HeightMapRes;
		int num2 = index / HeightMapRes;
		float num3 = ((float)num - 0.5f) / (float)HeightMapRes;
		float num4 = ((float)num2 - 0.5f) / (float)HeightMapRes;
		if ((TerrainTopologyMapJobUtil.GetTopologyRadius(TopologyMap, TopologyMapRes, TerrainOneOverSizeX, 0f, num3, num4) & 0xB4990) != 0 || (TerrainTopologyMapJobUtil.GetTopologyRadius(TopologyMap, TopologyMapRes, TerrainOneOverSizeX, 8f, num3, num4) & 2) != 0 || AngleMapDeg[num2 * HeightMapRes + num] < 3f)
		{
			return;
		}
		float grad;
		float num5 = ConcavityFactor(HeightMapDelta, HeightMapRes, num, num2, out grad);
		if (!(num5 < 3.5762787E-07f))
		{
			int x = Index(num3, SplatMapRes);
			int z = Index(num4, SplatMapRes);
			float splat = GetSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, num3, num4, 2);
			float splat2 = GetSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, num3, num4, 4);
			if (splat > 0.25f || splat2 > 0.25f)
			{
				num5 = math.saturate(num5 * 3f);
				grad = math.pow(grad, 2f);
				AddSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, x, z, 64, math.pow(num5, 0.8f) * grad);
				AddSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, x, z, 128, math.pow(num5, 1.5f) * grad);
			}
			else
			{
				num5 = math.saturate(num5 * 3f);
				AddSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, x, z, 1, math.pow(num5, 4f) * math.pow(grad, 1.5f));
				grad = math.pow(grad, 2f);
				AddSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, x, z, 64, math.pow(num5, 0.8f) * grad);
				AddSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, x, z, 128, math.pow(num5, 1.4f) * grad);
			}
		}
		static int Index(float normalized, int res)
		{
			int num6 = (int)(normalized * (float)res);
			if (num6 >= 0)
			{
				if (num6 <= res - 1)
				{
					return num6;
				}
				return res - 1;
			}
			return 0;
		}
	}

	private static void AddSplat(NativeArray<byte> src, int res, int splatNum, ReadOnly<int, int> type2Index, int x, int z, int id, float d)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		float splat = GetSplat(src, res, splatNum, type2Index, x, z, id);
		float num = math.saturate(splat + d);
		int num2 = type2Index[id];
		if (splat >= 1f)
		{
			return;
		}
		float num3 = (1f - num) / (1f - splat);
		for (int i = 0; i < splatNum; i++)
		{
			if (i == num2)
			{
				src[(i * res + z) * res + x] = BitUtility.Float2Byte(num);
			}
			else
			{
				src[(i * res + z) * res + x] = BitUtility.Float2Byte(num3 * BitUtility.Byte2Float((int)src[(i * res + z) * res + x]));
			}
		}
	}

	private static float GetSplat(NativeArray<byte> src, int res, int splatNum, ReadOnly<int, int> type2Index, float xn, float zn, int mask)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		float num2 = xn * (float)num;
		float num3 = zn * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetSplat(src, res, splatNum, type2Index, num4, num5, mask), GetSplat(src, res, splatNum, type2Index, x, num5, mask), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetSplat(src, res, splatNum, type2Index, num4, z, mask), GetSplat(src, res, splatNum, type2Index, x, z, mask), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	private static float GetSplat(NativeArray<byte> src, int res, int splatNum, ReadOnly<int, int> type2Index, int x, int z, int mask)
	{
		if (Mathf.IsPowerOfTwo(mask))
		{
			return BitUtility.Byte2Float((int)src[(type2Index[mask] * res + z) * res + x]);
		}
		int num = 0;
		for (int i = 0; i < splatNum; i++)
		{
			if ((TerrainSplat.IndexToType(i) & mask) != 0)
			{
				num += src[(i * res + z) * res + x];
			}
		}
		return Mathf.Clamp01(BitUtility.Byte2Float(num));
	}

	private static float ConcavityFactor(ReadOnly<float> data, int res, int x, int z, out float grad)
	{
		int num = x - 1;
		int num2 = x + 1;
		int num3 = z - 1;
		int num4 = z + 1;
		float num5 = data[z * res + x];
		float num6 = data[z * res + num];
		float num7 = data[z * res + num2];
		float num8 = data[num4 * res + x];
		float num9 = data[num3 * res + x];
		float num10 = num6 + num7 + num8 + num9;
		float num11 = data[num3 * res + num] + data[num3 * res + num2] + data[num4 * res + num] + data[num4 * res + num2];
		float num12 = num7 - num6;
		float num13 = num8 - num9;
		grad = math.sqrt(num12 * num12 + num13 * num13);
		return math.max(num10 / 4f + num11 / 4f - num5, 0f);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct PopulateDeltaHeightJob : IJobParallelFor
{
	public ReadOnly<float> HeightMapOriginal;

	public ReadOnly<float> HeightMap;

	[WriteOnly]
	public NativeArray<float> DeltaHeightMap;

	public void Execute(int index)
	{
		DeltaHeightMap[index] = HeightMapOriginal[index] - HeightMap[index];
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct CopyBackFloatHeightToShortHeightJob : IJobParallelFor
{
	public ReadOnly<float> HeightMapAsFloat;

	[WriteOnly]
	public NativeArray<short> HeightMapAsShort;

	public float TerrainOneOverSizeY;

	public float TerrainPositionY;

	public void Execute(int index)
	{
		HeightMapAsShort[index] = BitUtility.Float2Short(TerrainOneOverSizeY * (HeightMapAsFloat[index] - TerrainPositionY));
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct EvaporationJob : IJobParallelFor
{
	public NativeArray<float> WaterMap;

	public float DT;

	public float EvaporationRate;

	public void Execute(int index)
	{
		ref NativeArray<float> waterMap = ref WaterMap;
		waterMap[index] *= 1f - EvaporationRate * DT;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct CopyArrayJob<T> : IJob where T : unmanaged
{
	[WriteOnly]
	public NativeArray<T> CopyTarget;

	[ReadOnly]
	public NativeArray<T> CopySource;

	public void Execute()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		CopyTarget.CopyFrom(CopySource);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct PrepareMapJob : IJobParallelForBatch
{
	public ReadOnly<short> HeightMapAsShort;

	[WriteOnly]
	public NativeArray<float> HeightMapAsFloat;

	public ParallelWriter<int> OceanIndicesWriter;

	public float TerrainPositionY;

	public float TerrainSizeY;

	public float OceanLevel;

	public void Execute(int startIndex, int count)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		NativeList<int> val = default(NativeList<int>);
		val..ctor(count, AllocatorHandle.op_Implicit((Allocator)2));
		for (int i = startIndex; i < startIndex + count; i++)
		{
			float num2 = (HeightMapAsFloat[i] = TerrainPositionY + BitUtility.Short2Float((int)HeightMapAsShort[i]) * TerrainSizeY);
			if (num2 <= OceanLevel)
			{
				val.Add(ref i);
			}
		}
		OceanIndicesWriter.AddRangeNoResize(val);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct TransportSedimentJob : IJobParallelFor
{
	public NativeArray<float> SedimentMap;

	public ReadOnly<float> SedimentReadOnlyMap;

	public ReadOnly<float2> VelocityMap;

	public int Res;

	public float DT;

	public void Execute(int index)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		int num = index % Res;
		int num2 = index / Res;
		float2 val = VelocityMap[index];
		int num3 = (int)((float)num - DT * val.x);
		int num4 = (int)((float)num2 - DT * val.y);
		num3 = math.clamp(num3, 0, Res - 1);
		num4 = math.clamp(num4, 0, Res - 1);
		SedimentMap[index] = SedimentReadOnlyMap[num4 * Res + num3];
	}
}


using TerrainTopologyMapJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct CalcMinHeightMapJob : IJobParallelFor
{
	public ReadOnly<float> TerrainHeightMap;

	public int HeightMapRes;

	[WriteOnly]
	public NativeArray<float> MinTerrainHeightMap;

	public ReadOnly<int> TopologyMap;

	public int TopologyMapRes;

	public float OceanHeight;

	public float TerrainOneOverSizeX;

	public void Execute(int index)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainHeightMap[index];
		if (!(num < OceanHeight))
		{
			int num2 = index % HeightMapRes;
			int num3 = index / HeightMapRes;
			float normX = ((float)num2 - 0.5f) / (float)HeightMapRes;
			float normZ = ((float)num3 - 0.5f) / (float)HeightMapRes;
			bool flag = (TerrainTopologyMapJobUtil.GetTopologyRadius(TopologyMap, TopologyMapRes, TerrainOneOverSizeX, 0f, normX, normZ) & 0x14080) != 0;
			float num4 = 8f;
			float num5 = 8f;
			while (num5 > 0f && !flag && (TerrainTopologyMapJobUtil.GetTopologyRadius(TopologyMap, TopologyMapRes, TerrainOneOverSizeX, num5, normX, normZ) & 0x3C198) != 0)
			{
				num4 = num5;
				num5 -= 0.25f;
			}
			float num6 = (flag ? 0f : math.unlerp(0f, 8f, num4));
			num = math.max(OceanHeight, num - 1f * num6);
		}
		MinTerrainHeightMap[index] = num;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct ErosionAndDepositionJob : IJobParallelFor
{
	public NativeArray<float> SedimentMap;

	public ReadOnly<float> MinTerrainHeightMap;

	public ReadOnly<float> TerrainHeightMapSrcFloat;

	public NativeArray<float> TerrainHeightMapDstFloat;

	public NativeArray<float> WaterMap;

	public ReadOnly<float2> VelocityMap;

	public ReadOnly<float> AngleMap;

	public float DT;

	private const float SedimentCapacityConst = 0.0015f;

	private const float DissolveRateConstant = 0.15f;

	public void Execute(int index)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		float num = math.max(0.01047198f, AngleMap[index]);
		float2 val = VelocityMap[index];
		float num2 = 0.0015f * math.sin(num) * math.length(val);
		ref float reference = ref BurstUtil.Get<float>(ref WaterMap, index);
		float num3 = 1f - math.smoothstep(0f, 10f, reference);
		ref float reference2 = ref BurstUtil.Get<float>(ref SedimentMap, index);
		float num4 = DT * 0.15f * (num2 - reference2) * num3;
		float num5 = math.select(-1f, 1f, num2 > reference2) * num4;
		num5 = math.max(num5, 0f);
		float num6 = TerrainHeightMapSrcFloat[index];
		float num7 = num6 - num5;
		num7 = math.max(num7, MinTerrainHeightMap[index]);
		num5 = num7 - (num6 - num5);
		TerrainHeightMapDstFloat[index] = num7;
		reference2 += num5;
		reference += num5;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct TileCalculateAngleMap : IJobParallelFor
{
	[NativeDisableParallelForRestriction]
	[WriteOnly]
	public NativeArray<float> AngleMap;

	[ReadOnly]
	public ReadOnly<float> TerrainHeightMapSrcFloat;

	public float NormY;

	public int Res;

	public int NumXTiles;

	public int TileSizeX;

	public int TileSizeZ;

	public void Execute(int index)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		int num = index % NumXTiles;
		int num2 = index / NumXTiles;
		int num3 = math.max(num * TileSizeX, 1);
		int num4 = math.max(num2 * TileSizeZ, 1);
		int num5 = math.min(num3 + TileSizeX, Res - 1);
		int num6 = math.min(num4 + TileSizeZ, Res - 1);
		int4 val = default(int4);
		((int4)(ref val))..ctor(Res);
		int2 val2 = default(int2);
		((int2)(ref val2))..ctor(1, -1);
		for (int i = num4; i < num6; i++)
		{
			int2 val3 = new int2(i) + val2;
			int4 val4 = ((int2)(ref val3)).yyxy * val;
			for (int j = num3; j < num5; j++)
			{
				float4 val5 = float4.op_Implicit(val4 + new int4(j + 1, j - 1, j - 1, j - 1));
				float num7 = (TerrainHeightMapSrcFloat[(int)val5.x] - TerrainHeightMapSrcFloat[(int)val5.y]) * -0.5f;
				float num8 = (TerrainHeightMapSrcFloat[(int)val5.z] - TerrainHeightMapSrcFloat[(int)val5.w]) * -0.5f;
				float3 val6 = math.normalize(new float3(num7, NormY, num8));
				float num9 = math.dot(val6, val6);
				AngleMap[i * Res + j] = math.acos(math.clamp(math.dot(math.up(), math.normalize(val6)) / num9, -1f, 1f));
			}
		}
	}
}


using System.Runtime.CompilerServices;
using Unity.Burst;
using Unity.Burst.CompilerServices;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct AdjustWaterHeightByFluxJob : IJobParallelFor
{
	public NativeArray<float> WaterMap;

	public NativeArray<float2> VelocityMap;

	public ReadOnly<float4> FluxMap;

	public int Res;

	public float DT;

	public float InvGridCellSquareSize;

	public void Execute(int index)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		int num = index % Res;
		int num2 = index / Res;
		ref float2 reference = ref BurstUtil.Get<float2>(ref VelocityMap, index);
		if (num == 0 || num2 == 0 || num == Res - 1 || num2 == Res - 1)
		{
			reference = float2.zero;
			return;
		}
		float4 val = FluxMap[index];
		float num3 = math.csum(val);
		int4x2 val2 = default(int4x2);
		((int4x2)(ref val2))..ctor(new int4(num - 1, num + 1, num, num), new int4(num2, num2, num2 + 1, num2 - 1));
		val2.c0 = val2.c1 * Res + val2.c0;
		float y = FluxMap[val2.c0.x].y;
		float x = FluxMap[val2.c0.y].x;
		float w = FluxMap[val2.c0.z].w;
		float z = FluxMap[val2.c0.w].z;
		float num4 = y + x + w + z;
		float num5 = DT * (num4 - num3);
		BurstUtil.Get<float>(ref WaterMap, index) += num5 * InvGridCellSquareSize;
		float2 val3 = default(float2);
		val3.x = y - val.x + val.y - x;
		val3.y = w - val.z + val.w - z;
		float2 val4 = val3;
		val4 *= 0.5f;
		reference += val4 * DT;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int ToIndex([AssumeRange(0L, 2147483647L)] int x, [AssumeRange(0L, 2147483647L)] int y, [AssumeRange(0L, 2147483647L)] int res)
	{
		return y * res + x;
	}
}


using Unity.Burst;
using Unity.Burst.CompilerServices;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct CalculateOutputFluxJob : IJobParallelFor
{
	public ReadOnly<float> TerrainHeightMapFloatVal;

	public ReadOnly<float> WaterMap;

	public NativeArray<float4> FluxMap;

	public int Res;

	public float DT;

	public float GridCellSquareSize;

	public float PipeLength;

	public float PipeArea;

	private const float Gravity = 10f;

	[SkipLocalsInit]
	public unsafe void Execute(int index)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		ref float4 reference = ref BurstUtil.Get<float4>(ref FluxMap, index);
		int num = index % Res;
		int num2 = index / Res;
		if (num == 0 || num2 == 0 || num == Res - 1 || num2 == Res - 1)
		{
			reference = float4.zero;
			return;
		}
		float num3 = TerrainHeightMapFloatVal[index];
		float num4 = WaterMap[index];
		float num5 = num3 + num4;
		int4x2 val = default(int4x2);
		((int4x2)(ref val))..ctor(new int4(num - 1, num + 1, num, num), new int4(num2, num2, num2 + 1, num2 - 1));
		int4 val2 = math.mad(val.c1, int4.op_Implicit(Res), val.c0);
		float4 val3 = default(float4);
		val3.x = *(float*)BurstUtil.GetReadonly<float>(ref TerrainHeightMapFloatVal, val2.x) + *(float*)BurstUtil.GetReadonly<float>(ref WaterMap, val2.x);
		val3.y = *(float*)BurstUtil.GetReadonly<float>(ref TerrainHeightMapFloatVal, val2.y) + *(float*)BurstUtil.GetReadonly<float>(ref WaterMap, val2.y);
		val3.z = *(float*)BurstUtil.GetReadonly<float>(ref TerrainHeightMapFloatVal, val2.z) + *(float*)BurstUtil.GetReadonly<float>(ref WaterMap, val2.z);
		val3.w = *(float*)BurstUtil.GetReadonly<float>(ref TerrainHeightMapFloatVal, val2.w) + *(float*)BurstUtil.GetReadonly<float>(ref WaterMap, val2.w);
		reference = math.max(float4.zero, reference + DT * PipeArea * (10f * (num5 - val3) / PipeLength));
		float num6 = math.min(1f, num4 * GridCellSquareSize / (math.csum(reference) * DT));
		reference *= num6;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct RefillOceanJob : IJobParallelFor
{
	public ReadOnly<int> OceanIndices;

	public ReadOnly<float> HeightMap;

	[WriteOnly]
	[NativeDisableParallelForRestriction]
	public NativeArray<float> WaterMap;

	public float OceanLevel;

	public void Execute(int index)
	{
		int num = OceanIndices[index];
		float num2 = HeightMap[num];
		WaterMap[num] = OceanLevel - num2;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct WaterIncrementationJob : IJobParallelFor
{
	public NativeArray<float> WaterMap;

	public float WaterFillRate;

	public float DT;

	public void Execute(int index)
	{
		ref NativeArray<float> waterMap = ref WaterMap;
		waterMap[index] += WaterFillRate * DT;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetCoarseDistsToShoreJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> Dists;

	[ReadOnly]
	public ReadOnly<Vector2> UVs;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<float> Data;

	[ReadOnly]
	public int ShoreMapSize;

	[ReadOnly]
	public float ShoreDistanceScale;

	public void Execute()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		int shoreMapSize = ShoreMapSize;
		int num = shoreMapSize - 1;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num2 = Indices[i];
			Vector2 val = UVs[num2];
			float num3 = val.x * (float)num;
			float num4 = val.y * (float)num;
			int num5 = (int)num3;
			int num6 = (int)num4;
			float num7 = num3 - (float)num5;
			float num8 = num4 - (float)num6;
			num5 = ((num5 >= 0) ? num5 : 0);
			num6 = ((num6 >= 0) ? num6 : 0);
			num5 = ((num5 <= num) ? num5 : num);
			num6 = ((num6 <= num) ? num6 : num);
			int num9 = ((num3 < (float)num) ? 1 : 0);
			int num10 = ((num4 < (float)num) ? shoreMapSize : 0);
			int num11 = num6 * shoreMapSize + num5;
			int num12 = num11 + num9;
			int num13 = num11 + num10;
			int num14 = num13 + num9;
			float num15 = Data[num11];
			float num16 = Data[num12];
			float num17 = Data[num13];
			float num18 = Data[num14];
			float num19 = (num16 - num15) * num7 + num15;
			float num20 = (num18 - num17) * num7 + num17;
			Dists[num2] = ((num20 - num19) * num8 + num19) * ShoreDistanceScale;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightByPosJob : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public NativeArray<Vector3> Pos;

	[ReadOnly]
	public NativeArray<short> Data;

	[ReadOnly]
	public int Res;

	[ReadOnly]
	public float Offset;

	[ReadOnly]
	public float Scale;

	[ReadOnly]
	public Vector2 DataOrigin;

	[ReadOnly]
	public Vector2 DataScale;

	public void Execute()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		for (int i = 0; i < Pos.Length; i++)
		{
			float num2 = (Pos[i].x - DataOrigin.x) * DataScale.x;
			float num3 = (Pos[i].z - DataOrigin.y) * DataScale.y;
			float num4 = num2 * (float)num;
			float num5 = num3 * (float)num;
			int num6 = Mathf.Clamp((int)num4, 0, num);
			int num7 = Mathf.Clamp((int)num5, 0, num);
			int num8 = Mathf.Min(num6 + 1, num);
			int num9 = Mathf.Min(num7 + 1, num);
			float num10 = BitUtility.Short2Float((int)Data[num7 * Res + num6]);
			float num11 = BitUtility.Short2Float((int)Data[num7 * Res + num8]);
			float num12 = BitUtility.Short2Float((int)Data[num9 * Res + num6]);
			float num13 = BitUtility.Short2Float((int)Data[num9 * Res + num8]);
			float num14 = Mathf.Lerp(num10, num11, num4 - (float)num6);
			float num15 = Mathf.Lerp(num12, num13, num4 - (float)num6);
			Heights[i] = Offset + Mathf.Lerp(num14, num15, num5 - (float)num7) * Scale;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightByUVJob : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public NativeArray<Vector2> UV;

	[ReadOnly]
	public NativeArray<short> Data;

	[ReadOnly]
	public int Res;

	[ReadOnly]
	public float Offset;

	[ReadOnly]
	public float Scale;

	public void Execute()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		for (int i = 0; i < UV.Length; i++)
		{
			float num2 = UV[i].x * (float)num;
			float num3 = UV[i].y * (float)num;
			int num4 = Mathf.Clamp((int)num2, 0, num);
			int num5 = Mathf.Clamp((int)num3, 0, num);
			int num6 = Mathf.Min(num4 + 1, num);
			int num7 = Mathf.Min(num5 + 1, num);
			float num8 = BitUtility.Short2Float((int)Data[num5 * Res + num4]);
			float num9 = BitUtility.Short2Float((int)Data[num5 * Res + num6]);
			float num10 = BitUtility.Short2Float((int)Data[num7 * Res + num4]);
			float num11 = BitUtility.Short2Float((int)Data[num7 * Res + num6]);
			float num12 = Mathf.Lerp(num8, num9, num2 - (float)num4);
			float num13 = Mathf.Lerp(num10, num11, num2 - (float)num4);
			Heights[i] = Offset + Mathf.Lerp(num12, num13, num3 - (float)num5) * Scale;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightByUVJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public ReadOnly<Vector2> UV;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<short> Data;

	[ReadOnly]
	public int Res;

	[ReadOnly]
	public float Offset;

	[ReadOnly]
	public float Scale;

	public void Execute()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num2 = Indices[i];
			float num3 = UV[num2].x * (float)num;
			float num4 = UV[num2].y * (float)num;
			int num5 = Mathf.Clamp((int)num3, 0, num);
			int num6 = Mathf.Clamp((int)num4, 0, num);
			int num7 = Mathf.Min(num5 + 1, num);
			int num8 = Mathf.Min(num6 + 1, num);
			float num9 = BitUtility.Short2Float((int)Data[num6 * Res + num5]);
			float num10 = BitUtility.Short2Float((int)Data[num6 * Res + num7]);
			float num11 = BitUtility.Short2Float((int)Data[num8 * Res + num5]);
			float num12 = BitUtility.Short2Float((int)Data[num8 * Res + num7]);
			float num13 = Mathf.Lerp(num9, num10, num3 - (float)num5);
			float num14 = Mathf.Lerp(num11, num12, num3 - (float)num5);
			Heights[num2] = Offset + Mathf.Lerp(num13, num14, num4 - (float)num6) * Scale;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightByIndexJob : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public NativeArray<Vector2i> Indices;

	[ReadOnly]
	public NativeArray<short> Data;

	[ReadOnly]
	public int Res;

	[ReadOnly]
	public float Offset;

	[ReadOnly]
	public float Scale;

	public void Execute()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i].y * Res + Indices[i].x;
			Heights[i] = Offset + BitUtility.Short2Float((int)Data[num]) * Scale;
		}
	}
}


using Unity.Collections;

public static class TerrainTopologyMapJobUtil
{
	public static int GetTopologyRadius(ReadOnly<int> src, int res, float terrainOneOverSizeX, float radius, float normX, float normZ)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		float num = terrainOneOverSizeX * radius;
		int x_mid = Index(normX, res);
		int z_mid = Index(normZ, res);
		int x_min = Index(normX - num, res);
		int x_max = Index(normX + num, res);
		int z_min = Index(normZ - num, res);
		int z_max = Index(normZ + num, res);
		return GetTopologyRadius(src, res, radius, x_min, x_mid, x_max, z_min, z_mid, z_max);
	}

	private static int Index(float normalized, int res)
	{
		int num = (int)(normalized * (float)res);
		if (num >= 0)
		{
			if (num <= res - 1)
			{
				return num;
			}
			return res - 1;
		}
		return 0;
	}

	internal static int GetTopologyRadius(ReadOnly<int> src, int res, float radius, int x_min, int x_mid, int x_max, int z_min, int z_mid, int z_max)
	{
		int num = 0;
		float num2 = radius * radius;
		for (int i = z_min; i <= z_max; i++)
		{
			int num3 = i - z_mid;
			int num4 = num3 * num3;
			for (int j = x_min; j <= x_max; j++)
			{
				int num5 = j - x_mid;
				if (!((float)(num5 * num5 + num4) > num2))
				{
					num |= src[i * res + j];
				}
			}
		}
		return num;
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetTopologyByPosJob : IJob
{
	[WriteOnly]
	public NativeArray<int> Topologies;

	[ReadOnly]
	public NativeArray<Vector3> Pos;

	[ReadOnly]
	public NativeArray<int> Data;

	[ReadOnly]
	public int Res;

	[ReadOnly]
	public Vector2 DataOrigin;

	[ReadOnly]
	public Vector2 DataScale;

	public void Execute()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		int max = Res - 1;
		for (int i = 0; i < Pos.Length; i++)
		{
			float num = (Pos[i].x - DataOrigin.x) * DataScale.x;
			float num2 = (Pos[i].z - DataOrigin.y) * DataScale.y;
			int num3 = Math.Clamp((int)(num * (float)Res), 0, max);
			int num4 = Math.Clamp((int)(num2 * (float)Res), 0, max) * Res + num3;
			Topologies[i] = Data[num4];
		}
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetTopologyByUVJob : IJob
{
	[WriteOnly]
	public NativeArray<int> Topologies;

	[ReadOnly]
	public NativeArray<Vector2> UV;

	[ReadOnly]
	public NativeArray<int> Data;

	[ReadOnly]
	public int Res;

	public void Execute()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		int max = Res - 1;
		for (int i = 0; i < UV.Length; i++)
		{
			int num = Math.Clamp((int)(UV[i].x * (float)Res), 0, max);
			int num2 = Math.Clamp((int)(UV[i].y * (float)Res), 0, max) * Res + num;
			Topologies[i] = Data[num2];
		}
	}
}


using TerrainTopologyMapJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
internal struct GetTopologyRadiusJob : IJob
{
	public int Res;

	public ReadOnly<int> Src;

	public NativeReference<int> Topo;

	public int x_mid;

	public int z_mid;

	public int x_min;

	public int x_max;

	public int z_min;

	public int z_max;

	public float radius;

	public void Execute()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Topo.Value = TerrainTopologyMapJobUtil.GetTopologyRadius(Src, Res, radius, x_min, x_mid, x_max, z_min, z_mid, z_max);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct GetTopologyByIndexJob : IJob
{
	[WriteOnly]
	public NativeArray<int> Topologies;

	[ReadOnly]
	public NativeArray<Vector2i> Indices;

	[ReadOnly]
	public NativeArray<int> Data;

	[ReadOnly]
	public int Res;

	public void Execute()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i].y * Res + Indices[i].x;
			Topologies[i] = Data[num];
		}
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetTopologyByUVJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<int> Topologies;

	[ReadOnly]
	public ReadOnly<Vector2> UV;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<int> Data;

	[ReadOnly]
	public int Res;

	public void Execute()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		int max = Res - 1;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			int num2 = Math.Clamp((int)(UV[num].x * (float)Res), 0, max);
			int num3 = Math.Clamp((int)(UV[num].y * (float)Res), 0, max) * Res + num2;
			Topologies[num] = Data[num3];
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightsFastJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public ReadOnly<Vector2> UVs;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<short> Data;

	[ReadOnly]
	public int Res;

	[ReadOnly]
	public float TerrainPos;

	[ReadOnly]
	public float TerrainScale;

	public void Execute()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num2 = Indices[i];
			float num3 = UVs[num2].x * (float)num;
			float num4 = UVs[num2].y * (float)num;
			int num5 = (int)num3;
			int num6 = (int)num4;
			float num7 = num3 - (float)num5;
			float num8 = num4 - (float)num6;
			num5 = ((num5 >= 0) ? num5 : 0);
			num6 = ((num6 >= 0) ? num6 : 0);
			num5 = ((num5 <= num) ? num5 : num);
			num6 = ((num6 <= num) ? num6 : num);
			int num9 = ((num3 < (float)num) ? 1 : 0);
			int num10 = ((num4 < (float)num) ? Res : 0);
			int num11 = num6 * Res + num5;
			int num12 = num11 + num9;
			int num13 = num11 + num10;
			int num14 = num13 + num9;
			float num15 = BitUtility.Short2Float((int)Data[num11]);
			float num16 = BitUtility.Short2Float((int)Data[num12]);
			float num17 = BitUtility.Short2Float((int)Data[num13]);
			float num18 = BitUtility.Short2Float((int)Data[num14]);
			float num19 = (num16 - num15) * num7 + num15;
			float num20 = ((num18 - num17) * num7 + num17 - num19) * num8 + num19;
			Heights[num2] = TerrainPos + num20 * TerrainScale;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightsJob : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public NativeArray<Vector3> Pos;

	[ReadOnly]
	public NativeArray<short> Data;

	[ReadOnly]
	public Vector3 TerrainPos;

	[ReadOnly]
	public float TerrainScale;

	[ReadOnly]
	public Vector2 TerrainOneOverSize;

	[ReadOnly]
	public int Res;

	public void Execute()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		for (int i = 0; i < Pos.Length; i++)
		{
			float num2 = (Pos[i].x - TerrainPos.x) * TerrainOneOverSize.x;
			float num3 = (Pos[i].z - TerrainPos.z) * TerrainOneOverSize.y;
			float num4 = num2 * (float)num;
			float num5 = num3 * (float)num;
			int num6 = (int)num4;
			int num7 = (int)num5;
			float num8 = num4 - (float)num6;
			float num9 = num5 - (float)num7;
			num6 = ((num6 >= 0) ? num6 : 0);
			num7 = ((num7 >= 0) ? num7 : 0);
			num6 = ((num6 <= num) ? num6 : num);
			num7 = ((num7 <= num) ? num7 : num);
			int num10 = ((num4 < (float)num) ? 1 : 0);
			int num11 = ((num5 < (float)num) ? Res : 0);
			int num12 = num7 * Res + num6;
			int num13 = num12 + num10;
			int num14 = num12 + num11;
			int num15 = num14 + num10;
			float num16 = BitUtility.Short2Float((int)Data[num12]);
			float num17 = BitUtility.Short2Float((int)Data[num13]);
			float num18 = BitUtility.Short2Float((int)Data[num14]);
			float num19 = BitUtility.Short2Float((int)Data[num15]);
			float num20 = (num17 - num16) * num8 + num16;
			float num21 = ((num19 - num18) * num8 + num18 - num20) * num9 + num20;
			Heights[i] = TerrainPos.y + num21 * TerrainScale;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightsJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<short> Data;

	[ReadOnly]
	public Vector3 TerrainPos;

	[ReadOnly]
	public float TerrainScale;

	[ReadOnly]
	public Vector2 TerrainOneOverSize;

	[ReadOnly]
	public int Res;

	public void Execute()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num2 = Indices[i];
			float num3 = (Pos[num2].x - TerrainPos.x) * TerrainOneOverSize.x;
			float num4 = (Pos[num2].z - TerrainPos.z) * TerrainOneOverSize.y;
			float num5 = num3 * (float)num;
			float num6 = num4 * (float)num;
			int num7 = (int)num5;
			int num8 = (int)num6;
			float num9 = num5 - (float)num7;
			float num10 = num6 - (float)num8;
			num7 = ((num7 >= 0) ? num7 : 0);
			num8 = ((num8 >= 0) ? num8 : 0);
			num7 = ((num7 <= num) ? num7 : num);
			num8 = ((num8 <= num) ? num8 : num);
			int num11 = ((num5 < (float)num) ? 1 : 0);
			int num12 = ((num6 < (float)num) ? Res : 0);
			int num13 = num8 * Res + num7;
			int num14 = num13 + num11;
			int num15 = num13 + num12;
			int num16 = num15 + num11;
			float num17 = BitUtility.Short2Float((int)Data[num13]);
			float num18 = BitUtility.Short2Float((int)Data[num14]);
			float num19 = BitUtility.Short2Float((int)Data[num15]);
			float num20 = BitUtility.Short2Float((int)Data[num16]);
			float num21 = (num18 - num17) * num9 + num17;
			float num22 = ((num20 - num19) * num9 + num19 - num21) * num10 + num21;
			Heights[num2] = TerrainPos.y + num22 * TerrainScale;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckPosRadJob : IJob
{
	public NativeReference<bool> Result;

	[NativeDisableContainerSafetyRestriction]
	public CoarseQueryGrid Grid;

	public Vector3 CheckPos;

	public float CheckRad;

	public void Execute()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Result.Value = Grid.Check(CheckPos, CheckRad);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckPosRadBatchJob : IJob
{
	[WriteOnly]
	public NativeList<int> OverlapIndices;

	[NativeDisableContainerSafetyRestriction]
	public CoarseQueryGrid Grid;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<float> Radii;

	public void Execute()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Pos.Length; i++)
		{
			if (Grid.Check(Pos[i], Radii[i]))
			{
				OverlapIndices.AddNoResize(i);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckPosRadBatchJobIndirect : IJob
{
	[WriteOnly]
	public NativeList<int> OverlapIndices;

	[NativeDisableContainerSafetyRestriction]
	public CoarseQueryGrid Grid;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<float> Radii;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			if (Grid.Check(Pos[num], Radii[num]))
			{
				OverlapIndices.AddNoResize(num);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckBoundsJob : IJob
{
	public NativeReference<bool> Result;

	[NativeDisableContainerSafetyRestriction]
	public CoarseQueryGrid Grid;

	public Bounds CheckBounds;

	public void Execute()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Result.Value = Grid.Check(CheckBounds);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckBoundsJobIndirect : IJob
{
	[WriteOnly]
	public NativeList<int> OverlapIndices;

	[ReadOnly]
	[NativeDisableContainerSafetyRestriction]
	public CoarseQueryGrid Grid;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<Vector3> Ends;

	[ReadOnly]
	public ReadOnly<float> Radii;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		Bounds checkBounds = default(Bounds);
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Vector3 val = Starts[num];
			Vector3 val2 = Ends[num];
			float num2 = Radii[num];
			Vector3 val3 = Vector3.one * num2;
			Vector3 val4 = Vector3.Min(val, val2) - val3;
			Vector3 val5 = Vector3.Max(val, val2) + val3;
			((Bounds)(ref checkBounds))..ctor((val5 + val4) * 0.5f, val5 - val4);
			if (Grid.Check(checkBounds))
			{
				OverlapIndices.AddNoResize(num);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckRayJob : IJob
{
	public NativeReference<bool> Result;

	[NativeDisableContainerSafetyRestriction]
	public CoarseQueryGrid Grid;

	public Vector3 Start;

	public Vector3 End;

	public float CheckRad;

	public void Execute()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		Result.Value = Grid.Check(Start, End, CheckRad);
	}
}


public static class Client
{
	public const byte Default = 0;

	public const byte Tick = 1;
}


public static class Server
{
	public const byte Default = 0;

	public const byte Positions = 14;
}


using UnityEngine;

public static class ImageEffectHelper
{
	public static bool supportsDX11
	{
		get
		{
			if (SystemInfo.graphicsShaderLevel >= 50)
			{
				return SystemInfo.supportsComputeShaders;
			}
			return false;
		}
	}

	public static bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
	{
		if ((Object)(object)s == (Object)null || !s.isSupported)
		{
			Debug.LogWarningFormat("Missing shader for image effect {0}", new object[1] { effect });
			return false;
		}
		if (!SystemInfo.supportsImageEffects || !SystemInfo.supportsRenderTextures)
		{
			Debug.LogWarningFormat("Image effects aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		if (needDepth && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)1))
		{
			Debug.LogWarningFormat("Depth textures aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		if (needHdr && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)2))
		{
			Debug.LogWarningFormat("Floating point textures aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		return true;
	}

	public static Material CheckShaderAndCreateMaterial(Shader s)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected O, but got Unknown
		if ((Object)(object)s == (Object)null || !s.isSupported)
		{
			return null;
		}
		return new Material(s)
		{
			hideFlags = (HideFlags)52
		};
	}
}


using UnityEngine;

public sealed class MinAttribute : PropertyAttribute
{
	public readonly float min;

	public MinAttribute(float min)
	{
		this.min = min;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class RenderTextureUtility
{
	private List<RenderTexture> m_TemporaryRTs = new List<RenderTexture>();

	public RenderTexture GetTemporaryRenderTexture(int width, int height, int depthBuffer = 0, RenderTextureFormat format = 2, FilterMode filterMode = 1)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		RenderTexture temporary = RenderTexture.GetTemporary(width, height, depthBuffer, format);
		((Texture)temporary).filterMode = filterMode;
		((Texture)temporary).wrapMode = (TextureWrapMode)1;
		((Object)temporary).name = "RenderTextureUtilityTempTexture";
		m_TemporaryRTs.Add(temporary);
		return temporary;
	}

	public void ReleaseTemporaryRenderTexture(RenderTexture rt)
	{
		if (!((Object)(object)rt == (Object)null))
		{
			if (!m_TemporaryRTs.Contains(rt))
			{
				Debug.LogErrorFormat("Attempting to remove texture that was not allocated: {0}", new object[1] { rt });
			}
			else
			{
				m_TemporaryRTs.Remove(rt);
				RenderTexture.ReleaseTemporary(rt);
			}
		}
	}

	public void ReleaseAllTemporaryRenderTextures()
	{
		for (int i = 0; i < m_TemporaryRTs.Count; i++)
		{
			RenderTexture.ReleaseTemporary(m_TemporaryRTs[i]);
		}
		m_TemporaryRTs.Clear();
	}
}


using System;
using UnityEngine;
using UnityStandardAssets.CinematicEffects;

[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Cinematic/Tonemapping and Color Grading")]
[ImageEffectAllowedInSceneView]
public class TonemappingColorGrading : MonoBehaviour
{
	[AttributeUsage(AttributeTargets.Field)]
	public class SettingsGroup : Attribute
	{
	}

	public class IndentedGroup : PropertyAttribute
	{
	}

	public class ChannelMixer : PropertyAttribute
	{
	}

	public class ColorWheelGroup : PropertyAttribute
	{
		public int minSizePerWheel = 60;

		public int maxSizePerWheel = 150;

		public ColorWheelGroup()
		{
		}

		public ColorWheelGroup(int minSizePerWheel, int maxSizePerWheel)
		{
			this.minSizePerWheel = minSizePerWheel;
			this.maxSizePerWheel = maxSizePerWheel;
		}
	}

	public class Curve : PropertyAttribute
	{
		public Color color = Color.white;

		public Curve()
		{
		}//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)


		public Curve(float r, float g, float b, float a)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			color = new Color(r, g, b, a);
		}
	}

	[Serializable]
	public struct EyeAdaptationSettings
	{
		public bool enabled;

		[Min(0f)]
		[Tooltip("Midpoint Adjustment.")]
		public float middleGrey;

		[Tooltip("The lowest possible exposure value; adjust this value to modify the brightest areas of your level.")]
		public float min;

		[Tooltip("The highest possible exposure value; adjust this value to modify the darkest areas of your level.")]
		public float max;

		[Min(0f)]
		[Tooltip("Speed of linear adaptation. Higher is faster.")]
		public float speed;

		[Tooltip("Displays a luminosity helper in the GameView.")]
		public bool showDebug;

		public static EyeAdaptationSettings defaultSettings
		{
			get
			{
				EyeAdaptationSettings result = default(EyeAdaptationSettings);
				result.enabled = false;
				result.showDebug = false;
				result.middleGrey = 0.5f;
				result.min = -3f;
				result.max = 3f;
				result.speed = 1.5f;
				return result;
			}
		}
	}

	public enum Tonemapper
	{
		ACES,
		Curve,
		Hable,
		HejlDawson,
		Photographic,
		Reinhard,
		Neutral
	}

	[Serializable]
	public struct TonemappingSettings
	{
		public bool enabled;

		[Tooltip("Tonemapping technique to use. ACES is the recommended one.")]
		public Tonemapper tonemapper;

		[Min(0f)]
		[Tooltip("Adjusts the overall exposure of the scene.")]
		public float exposure;

		[Tooltip("Custom tonemapping curve.")]
		public AnimationCurve curve;

		[Range(-0.1f, 0.1f)]
		public float neutralBlackIn;

		[Range(1f, 20f)]
		public float neutralWhiteIn;

		[Range(-0.09f, 0.1f)]
		public float neutralBlackOut;

		[Range(1f, 19f)]
		public float neutralWhiteOut;

		[Range(0.1f, 20f)]
		public float neutralWhiteLevel;

		[Range(1f, 10f)]
		public float neutralWhiteClip;

		public static TonemappingSettings defaultSettings
		{
			get
			{
				TonemappingSettings result = default(TonemappingSettings);
				result.enabled = false;
				result.tonemapper = Tonemapper.Neutral;
				result.exposure = 1f;
				result.curve = CurvesSettings.defaultCurve;
				result.neutralBlackIn = 0.02f;
				result.neutralWhiteIn = 10f;
				result.neutralBlackOut = 0f;
				result.neutralWhiteOut = 10f;
				result.neutralWhiteLevel = 5.3f;
				result.neutralWhiteClip = 10f;
				return result;
			}
		}
	}

	[Serializable]
	public struct LUTSettings
	{
		public bool enabled;

		[Tooltip("Custom lookup texture (strip format, e.g. 256x16).")]
		public Texture texture;

		[Tooltip("Blending factor.")]
		[Range(0f, 1f)]
		public float contribution;

		public static LUTSettings defaultSettings
		{
			get
			{
				LUTSettings result = default(LUTSettings);
				result.enabled = false;
				result.texture = null;
				result.contribution = 1f;
				return result;
			}
		}
	}

	[Serializable]
	public struct ColorWheelsSettings
	{
		[ColorUsage(false)]
		public Color shadows;

		[ColorUsage(false)]
		public Color midtones;

		[ColorUsage(false)]
		public Color highlights;

		public static ColorWheelsSettings defaultSettings
		{
			get
			{
				//IL_000a: Unknown result type (might be due to invalid IL or missing references)
				//IL_000f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0016: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0022: Unknown result type (might be due to invalid IL or missing references)
				//IL_0027: Unknown result type (might be due to invalid IL or missing references)
				ColorWheelsSettings result = default(ColorWheelsSettings);
				result.shadows = Color.white;
				result.midtones = Color.white;
				result.highlights = Color.white;
				return result;
			}
		}
	}

	[Serializable]
	public struct BasicsSettings
	{
		[Tooltip("Sets the white balance to a custom color temperature.")]
		[Range(-2f, 2f)]
		public float temperatureShift;

		[Tooltip("Sets the white balance to compensate for a green or magenta tint.")]
		[Range(-2f, 2f)]
		public float tint;

		[Range(-0.5f, 0.5f)]
		[Tooltip("Shift the hue of all colors.")]
		[Space]
		public float hue;

		[Range(0f, 2f)]
		[Tooltip("Pushes the intensity of all colors.")]
		public float saturation;

		[Range(-1f, 1f)]
		[Tooltip("Adjusts the saturation so that clipping is minimized as colors approach full saturation.")]
		public float vibrance;

		[Range(0f, 10f)]
		[Tooltip("Brightens or darkens all colors.")]
		public float value;

		[Tooltip("Expands or shrinks the overall range of tonal values.")]
		[Range(0f, 2f)]
		[Space]
		public float contrast;

		[Tooltip("Contrast gain curve. Controls the steepness of the curve.")]
		[Range(0.01f, 5f)]
		public float gain;

		[Tooltip("Applies a pow function to the source.")]
		[Range(0.01f, 5f)]
		public float gamma;

		public static BasicsSettings defaultSettings
		{
			get
			{
				BasicsSettings result = default(BasicsSettings);
				result.temperatureShift = 0f;
				result.tint = 0f;
				result.contrast = 1f;
				result.hue = 0f;
				result.saturation = 1f;
				result.value = 1f;
				result.vibrance = 0f;
				result.gain = 1f;
				result.gamma = 1f;
				return result;
			}
		}
	}

	[Serializable]
	public struct ChannelMixerSettings
	{
		public int currentChannel;

		public Vector3[] channels;

		public static ChannelMixerSettings defaultSettings
		{
			get
			{
				//IL_0029: Unknown result type (might be due to invalid IL or missing references)
				//IL_002e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				//IL_0049: Unknown result type (might be due to invalid IL or missing references)
				//IL_005f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0064: Unknown result type (might be due to invalid IL or missing references)
				ChannelMixerSettings result = default(ChannelMixerSettings);
				result.currentChannel = 0;
				result.channels = (Vector3[])(object)new Vector3[3]
				{
					new Vector3(1f, 0f, 0f),
					new Vector3(0f, 1f, 0f),
					new Vector3(0f, 0f, 1f)
				};
				return result;
			}
		}
	}

	[Serializable]
	public struct CurvesSettings
	{
		[Curve]
		public AnimationCurve master;

		[Curve(1f, 0f, 0f, 1f)]
		public AnimationCurve red;

		[Curve(0f, 1f, 0f, 1f)]
		public AnimationCurve green;

		[Curve(0f, 1f, 1f, 1f)]
		public AnimationCurve blue;

		public static CurvesSettings defaultSettings
		{
			get
			{
				CurvesSettings result = default(CurvesSettings);
				result.master = defaultCurve;
				result.red = defaultCurve;
				result.green = defaultCurve;
				result.blue = defaultCurve;
				return result;
			}
		}

		public static AnimationCurve defaultCurve => new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f, 1f, 1f),
			new Keyframe(1f, 1f, 1f, 1f)
		});
	}

	public enum ColorGradingPrecision
	{
		Normal = 0x10,
		High = 0x20
	}

	[Serializable]
	public struct ColorGradingSettings
	{
		public bool enabled;

		[Tooltip("Internal LUT precision. \"Normal\" is 256x16, \"High\" is 1024x32. Prefer \"Normal\" on mobile devices.")]
		public ColorGradingPrecision precision;

		[ColorWheelGroup]
		[Space]
		public ColorWheelsSettings colorWheels;

		[IndentedGroup]
		[Space]
		public BasicsSettings basics;

		[ChannelMixer]
		[Space]
		public ChannelMixerSettings channelMixer;

		[Space]
		[IndentedGroup]
		public CurvesSettings curves;

		[Tooltip("Use dithering to try and minimize color banding in dark areas.")]
		[Space]
		public bool useDithering;

		[Tooltip("Displays the generated LUT in the top left corner of the GameView.")]
		public bool showDebug;

		public static ColorGradingSettings defaultSettings
		{
			get
			{
				ColorGradingSettings result = default(ColorGradingSettings);
				result.enabled = false;
				result.useDithering = false;
				result.showDebug = false;
				result.precision = ColorGradingPrecision.Normal;
				result.colorWheels = ColorWheelsSettings.defaultSettings;
				result.basics = BasicsSettings.defaultSettings;
				result.channelMixer = ChannelMixerSettings.defaultSettings;
				result.curves = CurvesSettings.defaultSettings;
				return result;
			}
		}

		internal void Reset()
		{
			curves = CurvesSettings.defaultSettings;
		}
	}

	[SettingsGroup]
	[SerializeField]
	private EyeAdaptationSettings m_EyeAdaptation = EyeAdaptationSettings.defaultSettings;

	[SettingsGroup]
	[SerializeField]
	private TonemappingSettings m_Tonemapping = TonemappingSettings.defaultSettings;

	[SettingsGroup]
	[SerializeField]
	private ColorGradingSettings m_ColorGrading = ColorGradingSettings.defaultSettings;

	[SettingsGroup]
	[SerializeField]
	private LUTSettings m_Lut = LUTSettings.defaultSettings;

	[SerializeField]
	private Shader m_Shader;
}


using System;

[AttributeUsage(AttributeTargets.Field)]
public class SettingsGroup : Attribute
{
}


using UnityEngine;

public class IndentedGroup : PropertyAttribute
{
}


using UnityEngine;

public class ChannelMixer : PropertyAttribute
{
}


using UnityEngine;

public class ColorWheelGroup : PropertyAttribute
{
	public int minSizePerWheel = 60;

	public int maxSizePerWheel = 150;

	public ColorWheelGroup()
	{
	}

	public ColorWheelGroup(int minSizePerWheel, int maxSizePerWheel)
	{
		this.minSizePerWheel = minSizePerWheel;
		this.maxSizePerWheel = maxSizePerWheel;
	}
}


using UnityEngine;

public class Curve : PropertyAttribute
{
	public Color color = Color.white;

	public Curve()
	{
	}//IL_0001: Unknown result type (might be due to invalid IL or missing references)
	//IL_0006: Unknown result type (might be due to invalid IL or missing references)


	public Curve(float r, float g, float b, float a)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		color = new Color(r, g, b, a);
	}
}


using System;
using UnityEngine;

[Serializable]
public struct EyeAdaptationSettings
{
	public bool enabled;

	[Min(0f)]
	[Tooltip("Midpoint Adjustment.")]
	public float middleGrey;

	[Tooltip("The lowest possible exposure value; adjust this value to modify the brightest areas of your level.")]
	public float min;

	[Tooltip("The highest possible exposure value; adjust this value to modify the darkest areas of your level.")]
	public float max;

	[Min(0f)]
	[Tooltip("Speed of linear adaptation. Higher is faster.")]
	public float speed;

	[Tooltip("Displays a luminosity helper in the GameView.")]
	public bool showDebug;

	public static EyeAdaptationSettings defaultSettings
	{
		get
		{
			EyeAdaptationSettings result = default(EyeAdaptationSettings);
			result.enabled = false;
			result.showDebug = false;
			result.middleGrey = 0.5f;
			result.min = -3f;
			result.max = 3f;
			result.speed = 1.5f;
			return result;
		}
	}
}


public enum Tonemapper
{
	ACES,
	Curve,
	Hable,
	HejlDawson,
	Photographic,
	Reinhard,
	Neutral
}


using System;
using UnityEngine;

[Serializable]
public struct TonemappingSettings
{
	public bool enabled;

	[Tooltip("Tonemapping technique to use. ACES is the recommended one.")]
	public Tonemapper tonemapper;

	[Min(0f)]
	[Tooltip("Adjusts the overall exposure of the scene.")]
	public float exposure;

	[Tooltip("Custom tonemapping curve.")]
	public AnimationCurve curve;

	[Range(-0.1f, 0.1f)]
	public float neutralBlackIn;

	[Range(1f, 20f)]
	public float neutralWhiteIn;

	[Range(-0.09f, 0.1f)]
	public float neutralBlackOut;

	[Range(1f, 19f)]
	public float neutralWhiteOut;

	[Range(0.1f, 20f)]
	public float neutralWhiteLevel;

	[Range(1f, 10f)]
	public float neutralWhiteClip;

	public static TonemappingSettings defaultSettings
	{
		get
		{
			TonemappingSettings result = default(TonemappingSettings);
			result.enabled = false;
			result.tonemapper = Tonemapper.Neutral;
			result.exposure = 1f;
			result.curve = CurvesSettings.defaultCurve;
			result.neutralBlackIn = 0.02f;
			result.neutralWhiteIn = 10f;
			result.neutralBlackOut = 0f;
			result.neutralWhiteOut = 10f;
			result.neutralWhiteLevel = 5.3f;
			result.neutralWhiteClip = 10f;
			return result;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct LUTSettings
{
	public bool enabled;

	[Tooltip("Custom lookup texture (strip format, e.g. 256x16).")]
	public Texture texture;

	[Tooltip("Blending factor.")]
	[Range(0f, 1f)]
	public float contribution;

	public static LUTSettings defaultSettings
	{
		get
		{
			LUTSettings result = default(LUTSettings);
			result.enabled = false;
			result.texture = null;
			result.contribution = 1f;
			return result;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ColorWheelsSettings
{
	[ColorUsage(false)]
	public Color shadows;

	[ColorUsage(false)]
	public Color midtones;

	[ColorUsage(false)]
	public Color highlights;

	public static ColorWheelsSettings defaultSettings
	{
		get
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			ColorWheelsSettings result = default(ColorWheelsSettings);
			result.shadows = Color.white;
			result.midtones = Color.white;
			result.highlights = Color.white;
			return result;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct BasicsSettings
{
	[Tooltip("Sets the white balance to a custom color temperature.")]
	[Range(-2f, 2f)]
	public float temperatureShift;

	[Tooltip("Sets the white balance to compensate for a green or magenta tint.")]
	[Range(-2f, 2f)]
	public float tint;

	[Range(-0.5f, 0.5f)]
	[Tooltip("Shift the hue of all colors.")]
	[Space]
	public float hue;

	[Range(0f, 2f)]
	[Tooltip("Pushes the intensity of all colors.")]
	public float saturation;

	[Range(-1f, 1f)]
	[Tooltip("Adjusts the saturation so that clipping is minimized as colors approach full saturation.")]
	public float vibrance;

	[Range(0f, 10f)]
	[Tooltip("Brightens or darkens all colors.")]
	public float value;

	[Tooltip("Expands or shrinks the overall range of tonal values.")]
	[Range(0f, 2f)]
	[Space]
	public float contrast;

	[Tooltip("Contrast gain curve. Controls the steepness of the curve.")]
	[Range(0.01f, 5f)]
	public float gain;

	[Tooltip("Applies a pow function to the source.")]
	[Range(0.01f, 5f)]
	public float gamma;

	public static BasicsSettings defaultSettings
	{
		get
		{
			BasicsSettings result = default(BasicsSettings);
			result.temperatureShift = 0f;
			result.tint = 0f;
			result.contrast = 1f;
			result.hue = 0f;
			result.saturation = 1f;
			result.value = 1f;
			result.vibrance = 0f;
			result.gain = 1f;
			result.gamma = 1f;
			return result;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ChannelMixerSettings
{
	public int currentChannel;

	public Vector3[] channels;

	public static ChannelMixerSettings defaultSettings
	{
		get
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			ChannelMixerSettings result = default(ChannelMixerSettings);
			result.currentChannel = 0;
			result.channels = (Vector3[])(object)new Vector3[3]
			{
				new Vector3(1f, 0f, 0f),
				new Vector3(0f, 1f, 0f),
				new Vector3(0f, 0f, 1f)
			};
			return result;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct CurvesSettings
{
	[Curve]
	public AnimationCurve master;

	[Curve(1f, 0f, 0f, 1f)]
	public AnimationCurve red;

	[Curve(0f, 1f, 0f, 1f)]
	public AnimationCurve green;

	[Curve(0f, 1f, 1f, 1f)]
	public AnimationCurve blue;

	public static CurvesSettings defaultSettings
	{
		get
		{
			CurvesSettings result = default(CurvesSettings);
			result.master = defaultCurve;
			result.red = defaultCurve;
			result.green = defaultCurve;
			result.blue = defaultCurve;
			return result;
		}
	}

	public static AnimationCurve defaultCurve => new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 0f, 1f, 1f),
		new Keyframe(1f, 1f, 1f, 1f)
	});
}


public enum ColorGradingPrecision
{
	Normal = 0x10,
	High = 0x20
}


using System;
using UnityEngine;

[Serializable]
public struct ColorGradingSettings
{
	public bool enabled;

	[Tooltip("Internal LUT precision. \"Normal\" is 256x16, \"High\" is 1024x32. Prefer \"Normal\" on mobile devices.")]
	public ColorGradingPrecision precision;

	[ColorWheelGroup]
	[Space]
	public ColorWheelsSettings colorWheels;

	[IndentedGroup]
	[Space]
	public BasicsSettings basics;

	[ChannelMixer]
	[Space]
	public ChannelMixerSettings channelMixer;

	[Space]
	[IndentedGroup]
	public CurvesSettings curves;

	[Tooltip("Use dithering to try and minimize color banding in dark areas.")]
	[Space]
	public bool useDithering;

	[Tooltip("Displays the generated LUT in the top left corner of the GameView.")]
	public bool showDebug;

	public static ColorGradingSettings defaultSettings
	{
		get
		{
			ColorGradingSettings result = default(ColorGradingSettings);
			result.enabled = false;
			result.useDithering = false;
			result.showDebug = false;
			result.precision = ColorGradingPrecision.Normal;
			result.colorWheels = ColorWheelsSettings.defaultSettings;
			result.basics = BasicsSettings.defaultSettings;
			result.channelMixer = ChannelMixerSettings.defaultSettings;
			result.curves = CurvesSettings.defaultSettings;
			return result;
		}
	}

	internal void Reset()
	{
		curves = CurvesSettings.defaultSettings;
	}
}


using UnityEngine;
using UnityStandardAssets.ImageEffects;

[AddComponentMenu("Image Effects/Other/Scope Overlay")]
[ExecuteInEditMode]
public class ScopeEffect : PostEffectsBase, IImageEffect
{
	public Material overlayMaterial;

	public override bool CheckResources()
	{
		return true;
	}

	public bool IsActive()
	{
		if (((Behaviour)this).enabled)
		{
			return ((PostEffectsBase)this).CheckResources();
		}
		return false;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		overlayMaterial.SetVector("_Screen", Vector4.op_Implicit(new Vector2((float)Screen.width, (float)Screen.height)));
		Graphics.Blit((Texture)(object)source, destination, overlayMaterial);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct ToUVJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<Vector2> UV;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public Vector2 TerrainPos;

	[ReadOnly]
	public Vector2 TerrainOneOverSize;

	public void Execute()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val2 = default(Vector2);
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Vector3 val = Pos[num];
			((Vector2)(ref val2))..ctor(val.x, val.z);
			UV[num] = (val2 - TerrainPos) * TerrainOneOverSize;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GatherWavesIndicesJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<int> WaveIndices;

	[WriteOnly]
	public NativeReference<int> WaveIndexCount;

	[ReadOnly]
	public ReadOnly<int> Topologies;

	[ReadOnly]
	public ReadOnly<float> Heights;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public float WaterLevel;

	public void Execute()
	{
		int value = 0;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			bool num2 = Heights[num] < WaterLevel;
			bool flag = (Topologies[num] & 0x180) != 0;
			if (num2 && flag)
			{
				WaveIndices[value++] = num;
			}
		}
		WaveIndexCount.Value = value;
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct ApplyMaxHeightsJobIndirect : IJob
{
	public NativeArray<float> Heights;

	[ReadOnly]
	public ReadOnly<int> Topologies;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public float WaterLevel;

	[ReadOnly]
	public float OceanLevel;

	public void Execute()
	{
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			bool num2 = Heights[num] < WaterLevel;
			bool flag = (Topologies[num] & 0x180) != 0;
			if (num2 && flag)
			{
				Heights[num] = Math.Max(Heights[num], OceanLevel);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct SelectMaxWaterLevelJobIndirect : IJob
{
	public NativeArray<float> Heights;

	[ReadOnly]
	public ReadOnly<float> DynamicHeights;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public float OceanLevel;

	public void Execute()
	{
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			float num2 = Heights[num];
			float num3 = OceanLevel + DynamicHeights[num];
			Heights[num] = Mathf.Max(num2, num3);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct CalcCenterJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<Vector3> Results;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<Vector3> Ends;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Results[num] = (Starts[num] + Ends[num]) * 0.5f;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct InitialValidateInfoJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<WaterLevel.WaterInfo> Results;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<Vector3> Ends;

	[ReadOnly]
	public ReadOnly<float> Radii;

	[ReadOnly]
	public ReadOnly<float> WaterHeights;

	[ReadOnly]
	public ReadOnly<float> TerrainHeights;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Results[num] = WaterLevel.InitialValidate(Starts[num], Ends[num], Radii[num], WaterHeights[num], TerrainHeights[num]);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GatherValidInfosJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<int> ValidIndices;

	[WriteOnly]
	public NativeReference<int> ValidIndexCount;

	[ReadOnly]
	public ReadOnly<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		int value = 0;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			if (Infos[num].isValid)
			{
				ValidIndices[value++] = num;
			}
		}
		ValidIndexCount.Value = value;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GatherInvalidInfosJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<int> InvalidIndices;

	[WriteOnly]
	public NativeReference<int> InvalidIndexCount;

	[ReadOnly]
	public ReadOnly<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		int value = 0;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			if (!Infos[num].isValid)
			{
				InvalidIndices[value++] = num;
			}
		}
		InvalidIndexCount.Value = value;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct UpdateWaterHeightsJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> WaterHeights;

	[ReadOnly]
	public NativeArray<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public NativeArray<int> Indices;

	public void Execute()
	{
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			if (Infos[num].isValid)
			{
				WaterHeights[num] = Infos[num].surfaceLevel;
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct SetupHeadQueryJobIndirect : IJob
{
	public NativeArray<int> Indices;

	[WriteOnly]
	public NativeReference<int> QueryIndexCount;

	[WriteOnly]
	public NativeArray<Vector3> QueryStarts;

	[WriteOnly]
	public NativeArray<float> QueryRadii;

	[ReadOnly]
	public ReadOnly<bool> ValidInfos;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<Vector3> Ends;

	[ReadOnly]
	public ReadOnly<float> Radii;

	public void Execute()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		int value = 0;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			if (ValidInfos[num])
			{
				Vector3 val = Starts[num];
				Vector3 val2 = Ends[num];
				float num2 = Radii[num];
				float num3 = Mathf.Min(val.y, val2.y) - num2;
				float num4 = Mathf.Max(val.y, val2.y) + num2;
				Vector3 val3 = Vector3Ex.WithY((val + val2) * 0.5f, Mathf.Lerp(num3, num4, 0.75f));
				Indices[value++] = num;
				QueryStarts[num] = val3;
				QueryRadii[num] = 0.01f;
			}
		}
		QueryIndexCount.Value = value;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct ApplyHeadQueryResultsJobIndirect : IJob
{
	public NativeArray<float> WaterHeights;

	[WriteOnly]
	public NativeArray<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public ReadOnly<bool> ValidInfos;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public unsafe void Execute()
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			float num2 = WaterHeights[num];
			if (ValidInfos[num])
			{
				UnsafeUtility.ArrayElementAsRef<WaterLevel.WaterInfo>(NativeArrayUnsafeUtility.GetUnsafePtr<WaterLevel.WaterInfo>(Infos), num).isValid = false;
				num2 = -1000f;
			}
			else
			{
				num2 = Mathf.Min(num2, Starts[num].y);
			}
			WaterHeights[num] = num2;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct ResolveWaterInfosJobIndirect : IJob
{
	public NativeArray<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<Vector3> Ends;

	[ReadOnly]
	public ReadOnly<float> Radii;

	[ReadOnly]
	public ReadOnly<float> WaterHeights;

	[ReadOnly]
	public ReadOnly<float> TerrainHeights;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public unsafe void Execute()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Vector3 val = Starts[num];
			Vector3 val2 = Ends[num];
			float num2 = Radii[num];
			float num3 = Mathf.Min(val.y, val2.y) - num2;
			float num4 = WaterHeights[num];
			float num5 = TerrainHeights[num];
			ref WaterLevel.WaterInfo reference = ref UnsafeUtility.ArrayElementAsRef<WaterLevel.WaterInfo>(NativeArrayUnsafeUtility.GetUnsafePtr<WaterLevel.WaterInfo>(Infos), num);
			reference.currentDepth = Mathf.Max(0f, num4 - num3);
			reference.overallDepth = Mathf.Max(0f, num4 - num5);
			reference.surfaceLevel = num4;
			reference.terrainHeight = num5;
		}
	}
}


using Sonar;
using UnityEngine;

public class SonarObject : MonoBehaviour, IClientComponent
{
	public enum SType
	{
		MoonPool,
		Sub
	}

	[SerializeField]
	private SType sonarType;
}


public enum SType
{
	MoonPool,
	Sub
}


using Sonar;
using UnityEngine;

public class SonarSystem : FacepunchBehaviour
{
	[SerializeField]
	private float range = 100f;

	[SerializeField]
	private float maxDepth = float.PositiveInfinity;

	[SerializeField]
	private ParticleSystem sonarPS;

	[SerializeField]
	private ParticleSystem blipPS;

	[SerializeField]
	private SonarObject us;

	[SerializeField]
	private Color greenBlip;

	[SerializeField]
	private Color redBlip;

	[SerializeField]
	private Color whiteBlip;

	[SerializeField]
	private SoundDefinition sonarBlipSound;

	[SerializeField]
	private GameObject sonarSoundParent;
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct UpdateWaterCache : IJob
{
	[WriteOnly]
	public NativeArray<BasePlayer.CachedState> States;

	[ReadOnly]
	public ReadOnly<float> Factors;

	[ReadOnly]
	public ReadOnly<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			BasePlayer.CachedState cachedState = default(BasePlayer.CachedState);
			cachedState.IsValid = true;
			cachedState.WaterFactor = Factors[num];
			cachedState.WaterInfo = Infos[num];
			cachedState.IsSwimming = BasePlayer.IsSwimming(cachedState.WaterFactor);
			States[num] = cachedState;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
internal struct GatherPosToValidateJob : IJob
{
	[WriteOnly]
	public NativeArray<BasePlayer.PositionChange> Changes;

	[WriteOnly]
	public NativeList<int> ToValidate;

	[ReadOnly]
	public TickInterpolatorCache.ReadOnlyState TickCache;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Vector3 startPoint = TickInterpolatorCache.GetStartPoint(TickCache, num);
			Vector3 endPoint = TickInterpolatorCache.GetEndPoint(TickCache, num);
			bool num2 = startPoint != endPoint;
			Changes[num] = BasePlayer.PositionChange.Same;
			if (num2)
			{
				ToValidate.AddNoResize(num);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Jobs;

[BurstCompile]
public struct RecacheTransforms : IJobParallelForTransform
{
	[WriteOnly]
	public NativeArray<Vector3> LocalPos;

	[WriteOnly]
	public NativeArray<Quaternion> LocalRots;

	public void Execute(int index, TransformAccess transf)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (((TransformAccess)(ref transf)).isValid)
		{
			LocalPos[index] = ((TransformAccess)(ref transf)).localPosition;
			LocalRots[index] = ((TransformAccess)(ref transf)).localRotation;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct CalcWaterFactorsJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> Factors;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<Vector3> Ends;

	[ReadOnly]
	public ReadOnly<float> Radii;

	public void Execute()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Factors[num] = WaterLevel.Factor(Infos[num], Starts[num], Ends[num], Radii[num]);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetWaterFactorsParamsJobIndirect : IJob
{
	public NativeArray<Vector3> Starts;

	public NativeArray<Vector3> Ends;

	[WriteOnly]
	public NativeArray<float> Radii;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<Quaternion> Rots;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Vector2 val = Vector2.op_Implicit(Ends[num]);
			float x = val.x;
			float num2 = val.y * 0.5f;
			Vector3 val2 = Starts[num];
			Vector3 val3 = Pos[num];
			Quaternion val4 = Rots[num];
			Vector3 val5 = val3 + val4 * (val2 - Vector3.up * (num2 - x));
			Vector3 val6 = val3 + val4 * (val2 + Vector3.up * (num2 - x));
			Starts[num] = val5;
			Ends[num] = val6;
			Radii[num] = x;
		}
	}
}


using System;
using UnityEngine;

public class ConsoleInput
{
	public string inputString = "";

	public string[] statusText = new string[3] { "", "", "" };

	internal float nextUpdate;

	public bool valid => Console.BufferWidth > 0;

	public int lineWidth => Console.BufferWidth;

	public event Action<string> OnInputText;

	public void ClearLine(int numLines)
	{
		Console.CursorLeft = 0;
		Console.Write(new string(' ', lineWidth * numLines));
		Console.CursorTop -= numLines;
		Console.CursorLeft = 0;
	}

	public void RedrawInputLine()
	{
		ConsoleColor backgroundColor = Console.BackgroundColor;
		ConsoleColor foregroundColor = Console.ForegroundColor;
		try
		{
			Console.ForegroundColor = ConsoleColor.White;
			Console.CursorTop++;
			for (int i = 0; i < statusText.Length; i++)
			{
				Console.CursorLeft = 0;
				Console.Write(statusText[i].PadRight(lineWidth));
			}
			Console.CursorTop -= statusText.Length + 1;
			Console.CursorLeft = 0;
			Console.BackgroundColor = ConsoleColor.Black;
			Console.ForegroundColor = ConsoleColor.Green;
			ClearLine(1);
			if (inputString.Length == 0)
			{
				Console.BackgroundColor = backgroundColor;
				Console.ForegroundColor = foregroundColor;
				return;
			}
			if (inputString.Length < lineWidth - 2)
			{
				Console.Write(inputString);
			}
			else
			{
				Console.Write(inputString.Substring(inputString.Length - (lineWidth - 2)));
			}
		}
		catch (Exception)
		{
		}
		Console.BackgroundColor = backgroundColor;
		Console.ForegroundColor = foregroundColor;
	}

	internal void OnBackspace()
	{
		if (inputString.Length >= 1)
		{
			inputString = inputString.Substring(0, inputString.Length - 1);
			RedrawInputLine();
		}
	}

	internal void OnEscape()
	{
		inputString = "";
		RedrawInputLine();
	}

	internal void OnEnter()
	{
		ClearLine(statusText.Length);
		Console.ForegroundColor = ConsoleColor.Green;
		Console.WriteLine("> " + inputString);
		string obj = inputString;
		inputString = "";
		if (this.OnInputText != null)
		{
			this.OnInputText(obj);
		}
		RedrawInputLine();
	}

	public void Update()
	{
		if (!valid)
		{
			return;
		}
		if (nextUpdate < Time.realtimeSinceStartup)
		{
			RedrawInputLine();
			nextUpdate = Time.realtimeSinceStartup + 0.5f;
		}
		try
		{
			if (!Console.KeyAvailable)
			{
				return;
			}
		}
		catch (Exception)
		{
			return;
		}
		ConsoleKeyInfo consoleKeyInfo = Console.ReadKey();
		if (consoleKeyInfo.Key == ConsoleKey.Enter)
		{
			OnEnter();
		}
		else if (consoleKeyInfo.Key == ConsoleKey.Backspace)
		{
			OnBackspace();
		}
		else if (consoleKeyInfo.Key == ConsoleKey.Escape)
		{
			OnEscape();
		}
		else if (consoleKeyInfo.KeyChar != 0)
		{
			inputString += consoleKeyInfo.KeyChar;
			RedrawInputLine();
		}
	}
}


using System;

public class ResetStaticFieldsAttribute : Attribute
{
}


using Rust.Rendering.IndirectInstancing;
using UnityEngine;

[DisallowMultipleComponent]
[RequireComponent(typeof(Camera))]
public class InstancedDebugDraw : SingletonComponent<InstancedDebugDraw>, IClientComponent, IRebindBuffer<GraphicsBuffer>, IRebindBuffer<ComputeBuffer>
{
	public Material overlayMaterial;

	public Material depthTestedMaterial;
}


using UnityEngine;

public class DDraw : MonoBehaviour
{
}


using UnityEngine;

public class CachedMonumentComponent : MonoBehaviour
{
	public MonumentInfo Monument;

	public Vector3 LastPosition;

	public void UpdateMonument(MonumentInfo info, Collider collider)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		Monument = info;
		LastPosition = ((Component)collider).transform.position;
	}
}


using UnityEngine;

public static class AniamtorEx
{
	public static void SetFloatFixed(this Animator animator, int id, float value, float dampTime, float deltaTime)
	{
		if (value == 0f)
		{
			float @float = animator.GetFloat(id);
			if (@float == 0f)
			{
				return;
			}
			if (@float < float.Epsilon)
			{
				animator.SetFloat(id, 0f);
				return;
			}
		}
		animator.SetFloat(id, value, dampTime, deltaTime);
	}

	public static void SetBoolChecked(this Animator animator, int id, bool value)
	{
		if (animator.GetBool(id) != value)
		{
			animator.SetBool(id, value);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public static class ArgEx
{
	public static BasePlayer Player(this Arg arg)
	{
		if (arg == null || arg.Connection == null)
		{
			return null;
		}
		return arg.Connection.player as BasePlayer;
	}

	public static BasePlayer GetPlayer(this Arg arg, int iArgNum)
	{
		string @string = arg.GetString(iArgNum, (string)null);
		if (@string == null)
		{
			return null;
		}
		return BasePlayer.Find(@string);
	}

	public static List<BasePlayer> GetPlayerArgs(this Arg arg, int startArgIndex)
	{
		List<BasePlayer> list = new List<BasePlayer>();
		int num = arg.Args.Length - startArgIndex;
		if (num <= 0)
		{
			return list;
		}
		for (int i = 0; i < num; i++)
		{
			BasePlayer player = arg.GetPlayer(startArgIndex + i);
			if ((Object)(object)player != (Object)null)
			{
				list.Add(player);
				Debug.Log((object)("Added player " + player.displayName));
			}
		}
		return list;
	}

	public static BasePlayer GetSleeper(this Arg arg, int iArgNum)
	{
		string @string = arg.GetString(iArgNum, "");
		if (@string == null)
		{
			return null;
		}
		return BasePlayer.FindSleeping(@string);
	}

	public static BasePlayer GetPlayerOrSleeper(this Arg arg, int iArgNum)
	{
		string @string = arg.GetString(iArgNum, "");
		if (@string == null)
		{
			return null;
		}
		return BasePlayer.FindAwakeOrSleeping(@string);
	}

	public static BasePlayer GetPlayerOrSleeperOrBot(this Arg arg, int iArgNum)
	{
		uint num = default(uint);
		if (arg.TryGetUInt(iArgNum, ref num))
		{
			return BasePlayer.FindBot(num);
		}
		return arg.GetPlayerOrSleeper(iArgNum);
	}

	public static NetworkableId GetEntityID(this Arg arg, int iArg, NetworkableId def = default(NetworkableId))
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return new NetworkableId(arg.GetUInt64(iArg, def.Value));
	}

	public static ItemId GetItemID(this Arg arg, int iArg, ItemId def = default(ItemId))
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return new ItemId(arg.GetUInt64(iArg, def.Value));
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;
using VLB;

public static class ColliderEx
{
	public static PhysicMaterial GetMaterialAt(this Collider obj, Vector3 pos)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)obj == (Object)null)
		{
			return TerrainMeta.Config.WaterMaterial;
		}
		if (obj is TerrainCollider)
		{
			return TerrainMeta.Physics.GetMaterial(pos);
		}
		return obj.sharedMaterial;
	}

	public static float EstimateVolume(this Collider collider)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		Vector3 lossyScale = ((Component)collider).transform.lossyScale;
		SphereCollider val = (SphereCollider)(object)((collider is SphereCollider) ? collider : null);
		if (val != null)
		{
			return val.radius * lossyScale.x * val.radius * lossyScale.y * val.radius * lossyScale.z * 4.1887903f;
		}
		BoxCollider val2 = (BoxCollider)(object)((collider is BoxCollider) ? collider : null);
		if (val2 != null)
		{
			return val2.size.x * lossyScale.x * val2.size.y * lossyScale.y * val2.size.z * lossyScale.z;
		}
		MeshCollider val3 = (MeshCollider)(object)((collider is MeshCollider) ? collider : null);
		if (val3 != null)
		{
			Bounds bounds = ((Collider)val3).bounds;
			Vector3 size = ((Bounds)(ref bounds)).size;
			return size.x * lossyScale.x * size.y * lossyScale.y * size.z * lossyScale.z;
		}
		CapsuleCollider val4 = (CapsuleCollider)(object)((collider is CapsuleCollider) ? collider : null);
		if (val4 != null)
		{
			float num = val4.radius * Mathf.Max(lossyScale.x, lossyScale.z);
			float num2 = (val4.height - num * 2f) * lossyScale.y;
			return MathF.PI * num * num * num2 + 4.1887903f * num * num * num;
		}
		return 0f;
	}

	public static bool IsOnLayer(this Collider col, Layer rustLayer)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)col != (Object)null)
		{
			return ((Component)col).gameObject.IsOnLayer(rustLayer);
		}
		return false;
	}

	public static bool IsOnLayer(this Collider col, int layer)
	{
		if ((Object)(object)col != (Object)null)
		{
			return ((Component)col).gameObject.IsOnLayer(layer);
		}
		return false;
	}

	public static float GetRadius(this Collider col, Vector3 transformScale)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		float result = 1f;
		SphereCollider val = (SphereCollider)(object)((col is SphereCollider) ? col : null);
		if (val != null)
		{
			result = val.radius * Vector3Ex.Max(transformScale);
		}
		else
		{
			BoxCollider val2 = (BoxCollider)(object)((col is BoxCollider) ? col : null);
			if (val2 != null)
			{
				result = Vector3Ex.Max(Vector3.Scale(val2.size, transformScale)) * 0.5f;
			}
			else
			{
				CapsuleCollider val3 = (CapsuleCollider)(object)((col is CapsuleCollider) ? col : null);
				if (val3 != null)
				{
					float num = val3.direction switch
					{
						0 => transformScale.y, 
						1 => transformScale.x, 
						_ => transformScale.x, 
					};
					result = val3.radius * num;
				}
				else
				{
					MeshCollider val4 = (MeshCollider)(object)((col is MeshCollider) ? col : null);
					if (val4 != null)
					{
						Bounds bounds = ((Collider)val4).bounds;
						result = Vector3Ex.Max(Vector3.Scale(((Bounds)(ref bounds)).size, transformScale)) * 0.5f;
					}
				}
			}
		}
		return result;
	}

	public static MonumentInfo GetMonument(this Collider collider, bool ignoreEntity = true)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)collider == (Object)null)
		{
			return null;
		}
		if (ignoreEntity && (Object)(object)collider.ToBaseEntity() != (Object)null)
		{
			return null;
		}
		CachedMonumentComponent cachedMonumentComponent = ((Component)collider).GetComponent<CachedMonumentComponent>();
		if ((Object)(object)cachedMonumentComponent == (Object)null || cachedMonumentComponent.LastPosition != ((Component)collider).transform.position)
		{
			cachedMonumentComponent = ((Component)collider).gameObject.GetOrAddComponent<CachedMonumentComponent>();
			PreventBuildingMonumentTag component = ((Component)collider).GetComponent<PreventBuildingMonumentTag>();
			if ((Object)(object)component != (Object)null)
			{
				cachedMonumentComponent.UpdateMonument(component.GetAttachedMonument(), collider);
				return cachedMonumentComponent.Monument;
			}
			List<Collider> list = Pool.Get<List<Collider>>();
			GamePhysics.OverlapBounds(collider.bounds, list, 536870912, (QueryTriggerInteraction)2);
			foreach (Collider item in list)
			{
				component = ((Component)item).GetComponent<PreventBuildingMonumentTag>();
				if ((Object)(object)component != (Object)null)
				{
					cachedMonumentComponent.UpdateMonument(component.GetAttachedMonument(), collider);
				}
			}
			Pool.FreeUnmanaged<Collider>(ref list);
		}
		return cachedMonumentComponent?.Monument;
	}
}


using UnityEngine;

public static class CollisionEx
{
	public static BaseEntity GetEntity(this Collision col)
	{
		return col.collider.ToBaseEntity();
	}
}


using Facepunch;
using UnityEngine;

public static class ComponentEx
{
	public static T Instantiate<T>(this T component) where T : Component
	{
		return Instantiate.GameObject(((Component)component).gameObject, (Transform)null).GetComponent<T>();
	}

	public static bool HasComponent<T>(this Component component) where T : Component
	{
		return (Object)(object)component.GetComponent<T>() != (Object)null;
	}

	public static bool? IsEnabled(this Component component)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		Behaviour val = (Behaviour)(object)((component is Behaviour) ? component : null);
		if (val != null)
		{
			return val.enabled;
		}
		Collider val2 = (Collider)(object)((component is Collider) ? component : null);
		if (val2 != null)
		{
			return val2.enabled;
		}
		Renderer val3 = (Renderer)(object)((component is Renderer) ? component : null);
		if (val3 != null)
		{
			return val3.enabled;
		}
		ParticleSystem val4 = (ParticleSystem)(object)((component is ParticleSystem) ? component : null);
		if (val4 != null)
		{
			EmissionModule emission = val4.emission;
			return ((EmissionModule)(ref emission)).enabled;
		}
		LODGroup val5 = (LODGroup)(object)((component is LODGroup) ? component : null);
		if (val5 != null)
		{
			return val5.enabled;
		}
		return null;
	}
}


using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using Facepunch;
using Rust;
using UnityEngine;

public static class CoroutineEx
{
	public static WaitForEndOfFrame waitForEndOfFrame = new WaitForEndOfFrame();

	public static WaitForFixedUpdate waitForFixedUpdate = new WaitForFixedUpdate();

	private static Dictionary<float, WaitForSeconds> waitForSecondsBuffer = new Dictionary<float, WaitForSeconds>();

	public static WaitForSeconds waitForSeconds(float seconds)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Expected O, but got Unknown
		if (!waitForSecondsBuffer.TryGetValue(seconds, out var value))
		{
			value = new WaitForSeconds(seconds);
			waitForSecondsBuffer.Add(seconds, value);
		}
		return value;
	}

	public static WaitForSecondsRealtimeEx waitForSecondsRealtime(float seconds)
	{
		WaitForSecondsRealtimeEx obj = Pool.Get<WaitForSecondsRealtimeEx>();
		obj.WaitTime = seconds;
		return obj;
	}

	public static IEnumerator Combine(params IEnumerator[] coroutines)
	{
		while (true)
		{
			bool flag = true;
			foreach (IEnumerator enumerator in coroutines)
			{
				if (enumerator != null && enumerator.MoveNext())
				{
					flag = false;
				}
			}
			if (flag)
			{
				break;
			}
			yield return waitForEndOfFrame;
		}
	}

	public static Task AsTask(this IEnumerator coroutine)
	{
		if (coroutine == null)
		{
			return Task.CompletedTask;
		}
		TaskCompletionSource<object> tcs = new TaskCompletionSource<object>();
		((MonoBehaviour)Global.Runner).StartCoroutine(RunImpl());
		return tcs.Task;
		IEnumerator RunImpl()
		{
			yield return coroutine;
			tcs.SetResult(null);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using Rust;
using Rust.Registry;
using UnityEngine;

public static class GameObjectEx
{
	public static BaseEntity ToBaseEntity(this GameObject go, bool allowDestroyed = false)
	{
		return go.transform.ToBaseEntity(allowDestroyed);
	}

	public static BaseEntity ToBaseEntity(this Collider collider, bool allowDestroyed = false)
	{
		return ((Component)collider).transform.ToBaseEntity(allowDestroyed);
	}

	public static BaseEntity ToBaseEntity(this Transform transform, bool allowDestroyed = false)
	{
		IEntity val = GetEntityFromRegistry(transform, allowDestroyed);
		if (val == null && !((Component)transform).gameObject.activeInHierarchy)
		{
			val = GetEntityFromComponent(transform);
		}
		return val as BaseEntity;
	}

	public static bool IsOnLayer(this GameObject go, Layer rustLayer)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected I4, but got Unknown
		return go.IsOnLayer((int)rustLayer);
	}

	public static bool IsOnLayer(this GameObject go, int layer)
	{
		if ((Object)(object)go != (Object)null)
		{
			return go.layer == layer;
		}
		return false;
	}

	private static IEntity GetEntityFromRegistry(Transform transform, bool allowDestroyed = false)
	{
		Transform val = transform;
		IEntity val2 = Entity.Get(val);
		while (val2 == null && (Object)(object)val.parent != (Object)null)
		{
			val = val.parent;
			val2 = Entity.Get(val);
		}
		if (val2 == null || (val2.IsDestroyed && !allowDestroyed))
		{
			return null;
		}
		return val2;
	}

	private static IEntity GetEntityFromComponent(Transform transform)
	{
		Transform val = transform;
		IEntity component = ((Component)val).GetComponent<IEntity>();
		while (component == null && (Object)(object)val.parent != (Object)null)
		{
			val = val.parent;
			component = ((Component)val).GetComponent<IEntity>();
		}
		if (component != null && !component.IsDestroyed)
		{
			return component;
		}
		return null;
	}

	public static void SetHierarchyGroup(this GameObject obj, string strRoot, bool groupActive = true, bool persistant = false)
	{
		obj.transform.SetParent(HierarchyUtil.GetRoot(strRoot, groupActive, persistant).transform, true);
	}

	public static bool HasComponent<T>(this GameObject obj) where T : Component
	{
		return (Object)(object)obj.GetComponent<T>() != (Object)null;
	}

	public static bool HasComponentInParent<T>(this GameObject obj) where T : Component
	{
		return (Object)(object)obj.GetComponentInParent<T>() != (Object)null;
	}

	public static void SetChildComponentsEnabled<T>(this GameObject gameObject, bool enabled) where T : MonoBehaviour
	{
		List<T> list = Pool.Get<List<T>>();
		gameObject.GetComponentsInChildren<T>(true, list);
		foreach (T item in list)
		{
			((Behaviour)(object)item).enabled = enabled;
		}
		Pool.FreeUnmanaged<T>(ref list);
	}

	public static GameObject FindInChildren(this GameObject parent, string name)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (((Object)parent).name == name)
		{
			return parent;
		}
		foreach (Transform item in parent.transform)
		{
			GameObject val = ((Component)item).gameObject.FindInChildren(name);
			if ((Object)(object)val != (Object)null)
			{
				return val;
			}
		}
		return null;
	}
}


public static class NetworkNetworkable
{
}


using Network;

public static class NetworkPacketEx
{
	public static BasePlayer Player(this Message v)
	{
		if (v.connection == null)
		{
			return null;
		}
		return v.connection.player as BasePlayer;
	}
}


public static class ObjectEffectsEx
{
}


using UnityEngine;

public static class QuaternionEx
{
	public static Quaternion AlignToNormal(this Quaternion rot, Vector3 normal)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.FromToRotation(Vector3.up, normal) * rot;
	}

	public static Quaternion LookRotationWithOffset(Vector3 offset, Vector3 forward, Vector3 up)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.LookRotation(forward, Vector3.up) * Quaternion.Inverse(Quaternion.LookRotation(offset, Vector3.up));
	}

	public static Quaternion LookRotationForcedUp(Vector3 forward, Vector3 up)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		if (forward == up)
		{
			return Quaternion.LookRotation(up);
		}
		Vector3 val = Vector3.Cross(forward, up);
		forward = Vector3.Cross(up, val);
		return Quaternion.LookRotation(forward, up);
	}

	public static Quaternion LookRotationGradient(Vector3 normal, Vector3 up)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((normal == Vector3.up) ? Vector3.forward : Vector3.Cross(normal, Vector3.up));
		return LookRotationForcedUp(Vector3.Cross(normal, val), up);
	}

	public static Quaternion LookRotationNormal(Vector3 normal, Vector3 up = default(Vector3))
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (up != Vector3.zero)
		{
			return LookRotationForcedUp(up, normal);
		}
		if (normal == Vector3.up)
		{
			return LookRotationForcedUp(Vector3.forward, normal);
		}
		if (normal == Vector3.down)
		{
			return LookRotationForcedUp(Vector3.back, normal);
		}
		if (normal.y == 0f)
		{
			return LookRotationForcedUp(Vector3.up, normal);
		}
		Vector3 val = Vector3.Cross(normal, Vector3.up);
		return LookRotationForcedUp(-Vector3.Cross(normal, val), normal);
	}

	public static Quaternion EnsureValid(this Quaternion rot, float epsilon = float.Epsilon)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		if (!(Quaternion.Dot(rot, rot) >= epsilon))
		{
			return Quaternion.identity;
		}
		return rot;
	}
}


using UnityEngine;

public static class RayEx
{
	public static Vector3 ClosestPoint(this Ray ray, Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		return ((Ray)(ref ray)).origin + Vector3.Dot(pos - ((Ray)(ref ray)).origin, ((Ray)(ref ray)).direction) * ((Ray)(ref ray)).direction;
	}

	public static float Distance(this Ray ray, Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(((Ray)(ref ray)).direction, pos - ((Ray)(ref ray)).origin);
		return ((Vector3)(ref val)).magnitude;
	}

	public static float SqrDistance(this Ray ray, Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(((Ray)(ref ray)).direction, pos - ((Ray)(ref ray)).origin);
		return ((Vector3)(ref val)).sqrMagnitude;
	}

	public static bool IsNaNOrInfinity(this Ray r)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!Vector3Ex.IsNaNOrInfinity(((Ray)(ref r)).origin))
		{
			return Vector3Ex.IsNaNOrInfinity(((Ray)(ref r)).direction);
		}
		return true;
	}
}


using UnityEngine;

public static class SkinnedMeshRendererEx
{
	public static Transform FindRig(this SkinnedMeshRenderer renderer)
	{
		Transform parent = ((Component)renderer).transform.parent;
		Transform val = renderer.rootBone;
		while ((Object)(object)val != (Object)null && (Object)(object)val.parent != (Object)null && (Object)(object)val.parent != (Object)(object)parent)
		{
			val = val.parent;
		}
		return val;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public static class TransformEx
{
	public static string GetRecursiveName(this Transform transform, string strEndName = "")
	{
		string text = ((Object)transform).name;
		if (!string.IsNullOrEmpty(strEndName))
		{
			text = text + "/" + strEndName;
		}
		if ((Object)(object)transform.parent != (Object)null)
		{
			text = transform.parent.GetRecursiveName(text);
		}
		return text;
	}

	public static void RemoveComponent<T>(this Transform transform) where T : Component
	{
		T component = ((Component)transform).GetComponent<T>();
		if (!((Object)(object)component == (Object)null))
		{
			GameManager.Destroy((Component)(object)component);
		}
	}

	public static void RetireAllChildren(this Transform transform, GameManager gameManager)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Expected O, but got Unknown
		List<GameObject> list = Pool.Get<List<GameObject>>();
		foreach (Transform item in transform)
		{
			Transform val = item;
			if (!((Component)val).CompareTag("persist"))
			{
				list.Add(((Component)val).gameObject);
			}
		}
		foreach (GameObject item2 in list)
		{
			gameManager.Retire(item2);
		}
		Pool.FreeUnmanaged<GameObject>(ref list);
	}

	public static List<Transform> GetChildren(this Transform transform)
	{
		return ((IEnumerable)transform).Cast<Transform>().ToList();
	}

	public static void OrderChildren(this Transform tx, Func<Transform, object> selector)
	{
		foreach (Transform item in ((IEnumerable)tx).Cast<Transform>().OrderBy(selector))
		{
			item.SetAsLastSibling();
		}
	}

	public static List<Transform> GetAllChildren(this Transform transform)
	{
		List<Transform> list = new List<Transform>();
		if ((Object)(object)transform != (Object)null)
		{
			transform.AddAllChildren(list);
		}
		return list;
	}

	public static void AddAllChildren(this Transform transform, List<Transform> list)
	{
		list.Add(transform);
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			if (!((Object)(object)child == (Object)null))
			{
				child.AddAllChildren(list);
			}
		}
	}

	public static Transform[] GetChildrenWithTag(this Transform transform, string strTag)
	{
		return (from x in transform.GetAllChildren()
			where ((Component)x).CompareTag(strTag)
			select x).ToArray();
	}

	public static Matrix4x4 LocalToPrefabRoot(this Transform transform)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 val = Matrix4x4.identity;
		while ((Object)(object)transform.parent != (Object)null)
		{
			val *= Matrix4x4.TRS(transform.localPosition, transform.localRotation, transform.localScale);
			transform = transform.parent;
		}
		return val;
	}

	public static void Identity(this GameObject go)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		go.transform.localPosition = Vector3.zero;
		go.transform.localRotation = Quaternion.identity;
		go.transform.localScale = Vector3.one;
	}

	public static GameObject CreateChild(this GameObject go)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Expected O, but got Unknown
		//IL_001d: Expected O, but got Unknown
		GameObject val = new GameObject();
		val.transform.parent = go.transform;
		Identity(val);
		return val;
	}

	public static GameObject InstantiateChild(this GameObject go, GameObject prefab)
	{
		GameObject obj = Instantiate.GameObject(prefab, (Transform)null);
		obj.transform.SetParent(go.transform, false);
		obj.Identity();
		return obj;
	}

	public static void SetLayerRecursive(this GameObject go, int Layer)
	{
		if (go.layer != Layer)
		{
			go.layer = Layer;
		}
		for (int i = 0; i < go.transform.childCount; i++)
		{
			((Component)go.transform.GetChild(i)).gameObject.SetLayerRecursive(Layer);
		}
	}

	public static bool DropToGround(this Transform transform, bool alignToNormal = false, float fRange = 100f)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (transform.GetGroundInfo(out var pos, out var normal, fRange))
		{
			transform.position = pos;
			if (alignToNormal)
			{
				transform.rotation = Quaternion.LookRotation(transform.forward, normal);
			}
			return true;
		}
		return false;
	}

	public static bool GetGroundInfo(this Transform transform, out Vector3 pos, out Vector3 normal, float range = 100f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return TransformUtil.GetGroundInfo(transform.position, out pos, out normal, range, transform);
	}

	public static bool GetGroundInfoTerrainOnly(this Transform transform, out Vector3 pos, out Vector3 normal, float range = 100f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return TransformUtil.GetGroundInfoTerrainOnly(transform.position, out pos, out normal, range);
	}

	public static Bounds WorkoutRenderBounds(this Transform tx)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = default(Bounds);
		((Bounds)(ref bounds))..ctor(Vector3.zero, Vector3.zero);
		Renderer[] componentsInChildren = ((Component)tx).GetComponentsInChildren<Renderer>();
		foreach (Renderer val in componentsInChildren)
		{
			if (!(val is ParticleSystemRenderer))
			{
				if (((Bounds)(ref bounds)).center == Vector3.zero)
				{
					bounds = val.bounds;
				}
				else
				{
					((Bounds)(ref bounds)).Encapsulate(val.bounds);
				}
			}
		}
		return bounds;
	}

	public static List<T> GetSiblings<T>(this Transform transform, bool includeSelf = false)
	{
		List<T> list = new List<T>();
		if ((Object)(object)transform.parent == (Object)null)
		{
			return list;
		}
		for (int i = 0; i < transform.parent.childCount; i++)
		{
			Transform child = transform.parent.GetChild(i);
			if (includeSelf || !((Object)(object)child == (Object)(object)transform))
			{
				T component = ((Component)child).GetComponent<T>();
				if (component != null)
				{
					list.Add(component);
				}
			}
		}
		return list;
	}

	public static void DestroyChildren(this Transform transform)
	{
		for (int i = 0; i < transform.childCount; i++)
		{
			GameManager.Destroy(((Component)transform.GetChild(i)).gameObject);
		}
	}

	public static void SetChildrenActive(this Transform transform, bool b)
	{
		for (int i = 0; i < transform.childCount; i++)
		{
			((Component)transform.GetChild(i)).gameObject.SetActive(b);
		}
	}

	public static Transform ActiveChild(this Transform transform, string name, bool bDisableOthers)
	{
		Transform result = null;
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			if (((Object)child).name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
			{
				result = child;
				((Component)child).gameObject.SetActive(true);
			}
			else if (bDisableOthers)
			{
				((Component)child).gameObject.SetActive(false);
			}
		}
		return result;
	}

	public static T GetComponentInChildrenIncludeDisabled<T>(this Transform transform) where T : Component
	{
		List<T> list = Pool.Get<List<T>>();
		((Component)transform).GetComponentsInChildren<T>(true, list);
		T result = ((list.Count > 0) ? list[0] : default(T));
		Pool.FreeUnmanaged<T>(ref list);
		return result;
	}

	public static bool HasComponentInChildrenIncludeDisabled<T>(this Transform transform) where T : Component
	{
		List<T> list = Pool.Get<List<T>>();
		((Component)transform).GetComponentsInChildren<T>(true, list);
		bool result = list.Count > 0;
		Pool.FreeUnmanaged<T>(ref list);
		return result;
	}

	public static void SetHierarchyGroup(this Transform transform, string strRoot, bool groupActive = true, bool persistant = false)
	{
		transform.SetParent(HierarchyUtil.GetRoot(strRoot, groupActive, persistant).transform, true);
	}

	public static Bounds GetBounds(this Transform transform, bool includeRenderers = true, bool includeColliders = true, bool includeInactive = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		Bounds result = default(Bounds);
		((Bounds)(ref result))..ctor(Vector3.zero, Vector3.zero);
		if (includeRenderers)
		{
			MeshLOD[] componentsInChildren = ((Component)transform).GetComponentsInChildren<MeshLOD>(includeInactive);
			foreach (MeshLOD meshLOD in componentsInChildren)
			{
				Mesh highestDetailMesh = meshLOD.GetHighestDetailMesh();
				if ((Object)(object)highestDetailMesh != (Object)null)
				{
					Matrix4x4 matrix = transform.worldToLocalMatrix * ((Component)meshLOD).transform.localToWorldMatrix;
					Bounds bounds = highestDetailMesh.bounds;
					((Bounds)(ref result)).Encapsulate(bounds.Transform(matrix));
				}
			}
			MeshFilter[] componentsInChildren2 = ((Component)transform).GetComponentsInChildren<MeshFilter>(includeInactive);
			foreach (MeshFilter val in componentsInChildren2)
			{
				if (Object.op_Implicit((Object)(object)val.sharedMesh))
				{
					Matrix4x4 matrix2 = transform.worldToLocalMatrix * ((Component)val).transform.localToWorldMatrix;
					Bounds bounds2 = val.sharedMesh.bounds;
					((Bounds)(ref result)).Encapsulate(bounds2.Transform(matrix2));
				}
			}
			SkinnedMeshRenderer[] componentsInChildren3 = ((Component)transform).GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive);
			foreach (SkinnedMeshRenderer val2 in componentsInChildren3)
			{
				if (Object.op_Implicit((Object)(object)val2.sharedMesh))
				{
					Matrix4x4 matrix3 = transform.worldToLocalMatrix * ((Component)val2).transform.localToWorldMatrix;
					Bounds bounds3 = val2.sharedMesh.bounds;
					((Bounds)(ref result)).Encapsulate(bounds3.Transform(matrix3));
				}
			}
		}
		if (includeColliders)
		{
			MeshCollider[] componentsInChildren4 = ((Component)transform).GetComponentsInChildren<MeshCollider>(includeInactive);
			foreach (MeshCollider val3 in componentsInChildren4)
			{
				if (Object.op_Implicit((Object)(object)val3.sharedMesh) && !((Collider)val3).isTrigger)
				{
					Matrix4x4 matrix4 = transform.worldToLocalMatrix * ((Component)val3).transform.localToWorldMatrix;
					Bounds bounds4 = val3.sharedMesh.bounds;
					((Bounds)(ref result)).Encapsulate(bounds4.Transform(matrix4));
				}
			}
		}
		return result;
	}
}


using UnityEngine;
using UnityEngine.UI;

public static class UIEx
{
	public static Vector2 Unpivot(this RectTransform rect, Vector2 localPos)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		ref float x = ref localPos.x;
		float num = x;
		float x2 = rect.pivot.x;
		Rect rect2 = rect.rect;
		x = num + x2 * ((Rect)(ref rect2)).width;
		ref float y = ref localPos.y;
		float num2 = y;
		float y2 = rect.pivot.y;
		rect2 = rect.rect;
		y = num2 + y2 * ((Rect)(ref rect2)).height;
		return localPos;
	}

	public static void CenterOnPosition(this ScrollRect scrollrect, Vector2 pos)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)scrollrect).transform;
		RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
		Vector2 val2 = default(Vector2);
		((Vector2)(ref val2))..ctor(((Transform)scrollrect.content).localScale.x, ((Transform)scrollrect.content).localScale.y);
		pos.x *= val2.x;
		pos.y *= val2.y;
		Rect rect = scrollrect.content.rect;
		float num = ((Rect)(ref rect)).width * val2.x;
		rect = val.rect;
		float num2 = num - ((Rect)(ref rect)).width;
		rect = scrollrect.content.rect;
		float num3 = ((Rect)(ref rect)).height * val2.y;
		rect = val.rect;
		Vector2 val3 = default(Vector2);
		((Vector2)(ref val3))..ctor(num2, num3 - ((Rect)(ref rect)).height);
		pos.x = pos.x / val3.x + scrollrect.content.pivot.x;
		pos.y = pos.y / val3.y + scrollrect.content.pivot.y;
		if ((int)scrollrect.movementType != 0)
		{
			pos.x = Mathf.Clamp(pos.x, 0f, 1f);
			pos.y = Mathf.Clamp(pos.y, 0f, 1f);
		}
		scrollrect.normalizedPosition = pos;
	}

	public static void RebuildHackUnity2019(this Image image)
	{
		Sprite sprite = image.sprite;
		image.sprite = null;
		image.sprite = sprite;
	}
}


using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using UnityEngine;
using UnityEngine.Jobs;

public static class JobEx
{
	public static int GetBatchSize(int length)
	{
		return Mathf.Max(length / JobsUtility.JobWorkerCount, 64);
	}

	public static JobHandle ScheduleParallel<T>(this ref T jobData, int arrayLength, JobHandle dependsOn) where T : struct, IJobFor
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return IJobForExtensions.ScheduleParallel<T>(jobData, arrayLength, GetBatchSize(arrayLength), dependsOn);
	}

	public static JobHandle ScheduleParallelByRef<T>(this ref T jobData, int arrayLength, JobHandle dependsOn) where T : struct, IJobFor
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return IJobForExtensions.ScheduleParallelByRef<T>(ref jobData, arrayLength, GetBatchSize(arrayLength), dependsOn);
	}

	public static JobHandle ScheduleParallelReadOnly<T>(this ref T jobData, TransformAccessArray transforms, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForTransform
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		return IJobParallelForTransformExtensions.ScheduleReadOnly<T>(jobData, transforms, GetBatchSize(((TransformAccessArray)(ref transforms)).length), dependsOn);
	}

	public static JobHandle ScheduleParallelReadOnlyByRef<T>(this ref T jobData, TransformAccessArray transforms, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForTransform
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		return IJobParallelForTransformExtensions.ScheduleReadOnlyByRef<T>(ref jobData, transforms, GetBatchSize(((TransformAccessArray)(ref transforms)).length), dependsOn);
	}
}


using Unity.Jobs;
using UnityEngine.Jobs;

public static class ParallelJobEx
{
	public static JobHandle ScheduleParallel<T>(this ref T jobData, int arrayLength, JobHandle dependsOn) where T : struct, IJobParallelFor
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return IJobParallelForExtensions.Schedule<T>(jobData, arrayLength, JobEx.GetBatchSize(arrayLength), dependsOn);
	}

	public static JobHandle ScheduleParallelByRef<T>(this ref T jobData, int arrayLength, JobHandle dependsOn) where T : struct, IJobParallelFor
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return IJobParallelForExtensions.ScheduleByRef<T>(ref jobData, arrayLength, JobEx.GetBatchSize(arrayLength), dependsOn);
	}
}


using System;
using Rust;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[ExecuteInEditMode]
[SelectionBase]
[AddComponentMenu("UI/Scroll Rect Ex", 37)]
[RequireComponent(typeof(RectTransform))]
public class ScrollRectEx : UIBehaviour, IInitializePotentialDragHandler, IEventSystemHandler, IBeginDragHandler, IEndDragHandler, IDragHandler, IScrollHandler, ICanvasElement, ILayoutGroup, ILayoutController
{
	public enum MovementType
	{
		Unrestricted,
		Elastic,
		Clamped
	}

	public enum ScrollbarVisibility
	{
		Permanent,
		AutoHide,
		AutoHideAndExpandViewport
	}

	[Serializable]
	public class ScrollRectEvent : UnityEvent<Vector2>
	{
	}

	public InputButton scrollButton;

	public InputButton altScrollButton;

	[SerializeField]
	private RectTransform m_Content;

	[SerializeField]
	private bool m_Horizontal = true;

	[SerializeField]
	private bool m_Vertical = true;

	[SerializeField]
	private MovementType m_MovementType = MovementType.Elastic;

	[SerializeField]
	private float m_Elasticity = 0.1f;

	[SerializeField]
	private bool m_Inertia = true;

	[SerializeField]
	private float m_DecelerationRate = 0.135f;

	[SerializeField]
	private float m_ScrollSensitivity = 1f;

	[SerializeField]
	private RectTransform m_Viewport;

	[SerializeField]
	private Scrollbar m_HorizontalScrollbar;

	[SerializeField]
	private Scrollbar m_VerticalScrollbar;

	[SerializeField]
	private ScrollbarVisibility m_HorizontalScrollbarVisibility;

	[SerializeField]
	private ScrollbarVisibility m_VerticalScrollbarVisibility;

	[SerializeField]
	private float m_HorizontalScrollbarSpacing;

	[SerializeField]
	private float m_VerticalScrollbarSpacing;

	[SerializeField]
	private ScrollRectEvent m_OnValueChanged = new ScrollRectEvent();

	private Vector2 m_PointerStartLocalCursor = Vector2.zero;

	private Vector2 m_ContentStartPosition = Vector2.zero;

	private RectTransform m_ViewRect;

	private Bounds m_ContentBounds;

	private Bounds m_ViewBounds;

	private Vector2 m_Velocity;

	private bool m_Dragging;

	private Vector2 m_PrevPosition = Vector2.zero;

	private Bounds m_PrevContentBounds;

	private Bounds m_PrevViewBounds;

	[NonSerialized]
	private bool m_HasRebuiltLayout;

	private bool m_HSliderExpand;

	private bool m_VSliderExpand;

	private float m_HSliderHeight;

	private float m_VSliderWidth;

	[NonSerialized]
	private RectTransform m_Rect;

	private RectTransform m_HorizontalScrollbarRect;

	private RectTransform m_VerticalScrollbarRect;

	private DrivenRectTransformTracker m_Tracker;

	private readonly Vector3[] m_Corners = (Vector3[])(object)new Vector3[4];

	public RectTransform content
	{
		get
		{
			return m_Content;
		}
		set
		{
			m_Content = value;
		}
	}

	public bool horizontal
	{
		get
		{
			return m_Horizontal;
		}
		set
		{
			m_Horizontal = value;
		}
	}

	public bool vertical
	{
		get
		{
			return m_Vertical;
		}
		set
		{
			m_Vertical = value;
		}
	}

	public MovementType movementType
	{
		get
		{
			return m_MovementType;
		}
		set
		{
			m_MovementType = value;
		}
	}

	public float elasticity
	{
		get
		{
			return m_Elasticity;
		}
		set
		{
			m_Elasticity = value;
		}
	}

	public bool inertia
	{
		get
		{
			return m_Inertia;
		}
		set
		{
			m_Inertia = value;
		}
	}

	public float decelerationRate
	{
		get
		{
			return m_DecelerationRate;
		}
		set
		{
			m_DecelerationRate = value;
		}
	}

	public float scrollSensitivity
	{
		get
		{
			return m_ScrollSensitivity;
		}
		set
		{
			m_ScrollSensitivity = value;
		}
	}

	public RectTransform viewport
	{
		get
		{
			return m_Viewport;
		}
		set
		{
			m_Viewport = value;
			SetDirtyCaching();
		}
	}

	public Scrollbar horizontalScrollbar
	{
		get
		{
			return m_HorizontalScrollbar;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)m_HorizontalScrollbar))
			{
				((UnityEvent<float>)(object)m_HorizontalScrollbar.onValueChanged).RemoveListener((UnityAction<float>)SetHorizontalNormalizedPosition);
			}
			m_HorizontalScrollbar = value;
			if (Object.op_Implicit((Object)(object)m_HorizontalScrollbar))
			{
				((UnityEvent<float>)(object)m_HorizontalScrollbar.onValueChanged).AddListener((UnityAction<float>)SetHorizontalNormalizedPosition);
			}
			SetDirtyCaching();
		}
	}

	public Scrollbar verticalScrollbar
	{
		get
		{
			return m_VerticalScrollbar;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)m_VerticalScrollbar))
			{
				((UnityEvent<float>)(object)m_VerticalScrollbar.onValueChanged).RemoveListener((UnityAction<float>)SetVerticalNormalizedPosition);
			}
			m_VerticalScrollbar = value;
			if (Object.op_Implicit((Object)(object)m_VerticalScrollbar))
			{
				((UnityEvent<float>)(object)m_VerticalScrollbar.onValueChanged).AddListener((UnityAction<float>)SetVerticalNormalizedPosition);
			}
			SetDirtyCaching();
		}
	}

	public ScrollbarVisibility horizontalScrollbarVisibility
	{
		get
		{
			return m_HorizontalScrollbarVisibility;
		}
		set
		{
			m_HorizontalScrollbarVisibility = value;
			SetDirtyCaching();
		}
	}

	public ScrollbarVisibility verticalScrollbarVisibility
	{
		get
		{
			return m_VerticalScrollbarVisibility;
		}
		set
		{
			m_VerticalScrollbarVisibility = value;
			SetDirtyCaching();
		}
	}

	public float horizontalScrollbarSpacing
	{
		get
		{
			return m_HorizontalScrollbarSpacing;
		}
		set
		{
			m_HorizontalScrollbarSpacing = value;
			SetDirty();
		}
	}

	public float verticalScrollbarSpacing
	{
		get
		{
			return m_VerticalScrollbarSpacing;
		}
		set
		{
			m_VerticalScrollbarSpacing = value;
			SetDirty();
		}
	}

	public ScrollRectEvent onValueChanged
	{
		get
		{
			return m_OnValueChanged;
		}
		set
		{
			m_OnValueChanged = value;
		}
	}

	protected RectTransform viewRect
	{
		get
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Expected O, but got Unknown
			if ((Object)(object)m_ViewRect == (Object)null)
			{
				m_ViewRect = m_Viewport;
			}
			if ((Object)(object)m_ViewRect == (Object)null)
			{
				m_ViewRect = (RectTransform)((Component)this).transform;
			}
			return m_ViewRect;
		}
	}

	public Vector2 velocity
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_Velocity;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_Velocity = value;
		}
	}

	private RectTransform rectTransform
	{
		get
		{
			if ((Object)(object)m_Rect == (Object)null)
			{
				m_Rect = ((Component)this).GetComponent<RectTransform>();
			}
			return m_Rect;
		}
	}

	public Vector2 normalizedPosition
	{
		get
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return new Vector2(horizontalNormalizedPosition, verticalNormalizedPosition);
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			SetNormalizedPosition(value.x, 0);
			SetNormalizedPosition(value.y, 1);
		}
	}

	public float horizontalNormalizedPosition
	{
		get
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			UpdateBounds();
			if (((Bounds)(ref m_ContentBounds)).size.x <= ((Bounds)(ref m_ViewBounds)).size.x)
			{
				return (((Bounds)(ref m_ViewBounds)).min.x > ((Bounds)(ref m_ContentBounds)).min.x) ? 1 : 0;
			}
			return (((Bounds)(ref m_ViewBounds)).min.x - ((Bounds)(ref m_ContentBounds)).min.x) / (((Bounds)(ref m_ContentBounds)).size.x - ((Bounds)(ref m_ViewBounds)).size.x);
		}
		set
		{
			SetNormalizedPosition(value, 0);
		}
	}

	public float verticalNormalizedPosition
	{
		get
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			UpdateBounds();
			if (((Bounds)(ref m_ContentBounds)).size.y <= ((Bounds)(ref m_ViewBounds)).size.y)
			{
				return (((Bounds)(ref m_ViewBounds)).min.y > ((Bounds)(ref m_ContentBounds)).min.y) ? 1 : 0;
			}
			return (((Bounds)(ref m_ViewBounds)).min.y - ((Bounds)(ref m_ContentBounds)).min.y) / (((Bounds)(ref m_ContentBounds)).size.y - ((Bounds)(ref m_ViewBounds)).size.y);
		}
		set
		{
			SetNormalizedPosition(value, 1);
		}
	}

	private bool hScrollingNeeded
	{
		get
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			if (Application.isPlaying)
			{
				return ((Bounds)(ref m_ContentBounds)).size.x > ((Bounds)(ref m_ViewBounds)).size.x + 0.01f;
			}
			return true;
		}
	}

	private bool vScrollingNeeded
	{
		get
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			if (Application.isPlaying)
			{
				return ((Bounds)(ref m_ContentBounds)).size.y > ((Bounds)(ref m_ViewBounds)).size.y + 0.01f;
			}
			return true;
		}
	}

	public Rect normalizedViewRect
	{
		get
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			UpdateBounds();
			Vector3 val = Vector3Ex.Inverse(((Bounds)(ref m_ContentBounds)).size);
			Vector3 val2 = Vector3.Scale(Vector3Ex.Abs(((Bounds)(ref m_ContentBounds)).center - ((Bounds)(ref m_ContentBounds)).extents) + new Vector3(0f - ((Bounds)(ref m_ViewBounds)).extents.x, ((Bounds)(ref m_ViewBounds)).extents.y), val);
			Vector3 val3 = Vector3.Scale(((Bounds)(ref m_ViewBounds)).size, val);
			return new Rect(Vector2.op_Implicit(val2), Vector2.op_Implicit(val3));
		}
	}

	protected ScrollRectEx()
	{
	}//IL_0049: Unknown result type (might be due to invalid IL or missing references)
	//IL_004e: Unknown result type (might be due to invalid IL or missing references)
	//IL_0054: Unknown result type (might be due to invalid IL or missing references)
	//IL_0059: Unknown result type (might be due to invalid IL or missing references)
	//IL_005f: Unknown result type (might be due to invalid IL or missing references)
	//IL_0064: Unknown result type (might be due to invalid IL or missing references)


	public virtual void Rebuild(CanvasUpdate executing)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Invalid comparison between Unknown and I4
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((int)executing == 0)
		{
			UpdateCachedData();
		}
		if ((int)executing == 2)
		{
			UpdateBounds();
			UpdateScrollbars(Vector2.zero);
			UpdatePrevData();
			m_HasRebuiltLayout = true;
		}
	}

	private void UpdateCachedData()
	{
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		m_HorizontalScrollbarRect = (RectTransform)(((Object)(object)m_HorizontalScrollbar == (Object)null) ? null : /*isinst with value type is only supported in some contexts*/);
		m_VerticalScrollbarRect = (RectTransform)(((Object)(object)m_VerticalScrollbar == (Object)null) ? null : /*isinst with value type is only supported in some contexts*/);
		bool num = (Object)(object)((Transform)viewRect).parent == (Object)(object)transform;
		bool flag = !Object.op_Implicit((Object)(object)m_HorizontalScrollbarRect) || (Object)(object)((Transform)m_HorizontalScrollbarRect).parent == (Object)(object)transform;
		bool flag2 = !Object.op_Implicit((Object)(object)m_VerticalScrollbarRect) || (Object)(object)((Transform)m_VerticalScrollbarRect).parent == (Object)(object)transform;
		bool flag3 = num && flag && flag2;
		m_HSliderExpand = flag3 && Object.op_Implicit((Object)(object)m_HorizontalScrollbarRect) && horizontalScrollbarVisibility == ScrollbarVisibility.AutoHideAndExpandViewport;
		m_VSliderExpand = flag3 && Object.op_Implicit((Object)(object)m_VerticalScrollbarRect) && verticalScrollbarVisibility == ScrollbarVisibility.AutoHideAndExpandViewport;
		Rect rect;
		float hSliderHeight;
		if (!((Object)(object)m_HorizontalScrollbarRect == (Object)null))
		{
			rect = m_HorizontalScrollbarRect.rect;
			hSliderHeight = ((Rect)(ref rect)).height;
		}
		else
		{
			hSliderHeight = 0f;
		}
		m_HSliderHeight = hSliderHeight;
		float vSliderWidth;
		if (!((Object)(object)m_VerticalScrollbarRect == (Object)null))
		{
			rect = m_VerticalScrollbarRect.rect;
			vSliderWidth = ((Rect)(ref rect)).width;
		}
		else
		{
			vSliderWidth = 0f;
		}
		m_VSliderWidth = vSliderWidth;
	}

	protected override void OnEnable()
	{
		((UIBehaviour)this).OnEnable();
		if (Object.op_Implicit((Object)(object)m_HorizontalScrollbar))
		{
			((UnityEvent<float>)(object)m_HorizontalScrollbar.onValueChanged).AddListener((UnityAction<float>)SetHorizontalNormalizedPosition);
		}
		if (Object.op_Implicit((Object)(object)m_VerticalScrollbar))
		{
			((UnityEvent<float>)(object)m_VerticalScrollbar.onValueChanged).AddListener((UnityAction<float>)SetVerticalNormalizedPosition);
		}
		CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild((ICanvasElement)(object)this);
	}

	protected override void OnDisable()
	{
		if (!Application.isQuitting)
		{
			CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild((ICanvasElement)(object)this);
			if (Object.op_Implicit((Object)(object)m_HorizontalScrollbar))
			{
				((UnityEvent<float>)(object)m_HorizontalScrollbar.onValueChanged).RemoveListener((UnityAction<float>)SetHorizontalNormalizedPosition);
			}
			if (Object.op_Implicit((Object)(object)m_VerticalScrollbar))
			{
				((UnityEvent<float>)(object)m_VerticalScrollbar.onValueChanged).RemoveListener((UnityAction<float>)SetVerticalNormalizedPosition);
			}
			m_HasRebuiltLayout = false;
			((DrivenRectTransformTracker)(ref m_Tracker)).Clear();
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
			((UIBehaviour)this).OnDisable();
		}
	}

	public override bool IsActive()
	{
		if (((UIBehaviour)this).IsActive())
		{
			return (Object)(object)m_Content != (Object)null;
		}
		return false;
	}

	private void EnsureLayoutHasRebuilt()
	{
		if (!m_HasRebuiltLayout && !CanvasUpdateRegistry.IsRebuildingLayout())
		{
			Canvas.ForceUpdateCanvases();
		}
	}

	public virtual void StopMovement()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		m_Velocity = Vector2.zero;
	}

	public virtual void OnScroll(PointerEventData data)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (!((UIBehaviour)this).IsActive())
		{
			return;
		}
		EnsureLayoutHasRebuilt();
		UpdateBounds();
		Vector2 scrollDelta = data.scrollDelta;
		scrollDelta.y *= -1f;
		if (vertical && !horizontal)
		{
			if (Mathf.Abs(scrollDelta.x) > Mathf.Abs(scrollDelta.y))
			{
				scrollDelta.y = scrollDelta.x;
			}
			scrollDelta.x = 0f;
		}
		if (horizontal && !vertical)
		{
			if (Mathf.Abs(scrollDelta.y) > Mathf.Abs(scrollDelta.x))
			{
				scrollDelta.x = scrollDelta.y;
			}
			scrollDelta.y = 0f;
		}
		Vector2 anchoredPosition = m_Content.anchoredPosition;
		anchoredPosition += scrollDelta * m_ScrollSensitivity;
		if (m_MovementType == MovementType.Clamped)
		{
			anchoredPosition += CalculateOffset(anchoredPosition - m_Content.anchoredPosition);
		}
		SetContentAnchoredPosition(anchoredPosition);
		UpdateBounds();
	}

	public virtual void OnInitializePotentialDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (eventData.button == scrollButton || eventData.button == altScrollButton)
		{
			m_Velocity = Vector2.zero;
		}
	}

	public virtual void OnBeginDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if ((eventData.button == scrollButton || eventData.button == altScrollButton) && ((UIBehaviour)this).IsActive())
		{
			UpdateBounds();
			m_PointerStartLocalCursor = Vector2.zero;
			RectTransformUtility.ScreenPointToLocalPointInRectangle(viewRect, eventData.position, eventData.pressEventCamera, ref m_PointerStartLocalCursor);
			m_ContentStartPosition = m_Content.anchoredPosition;
			m_Dragging = true;
		}
	}

	public virtual void OnEndDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (eventData.button == scrollButton || eventData.button == altScrollButton)
		{
			m_Dragging = false;
		}
	}

	public virtual void OnDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		if ((eventData.button != scrollButton && eventData.button != altScrollButton) || !((UIBehaviour)this).IsActive() || !RectTransformUtility.ScreenPointToLocalPointInRectangle(viewRect, eventData.position, eventData.pressEventCamera, ref val))
		{
			return;
		}
		UpdateBounds();
		Vector2 val2 = val - m_PointerStartLocalCursor;
		Vector2 val3 = m_ContentStartPosition + val2;
		Vector2 val4 = CalculateOffset(val3 - m_Content.anchoredPosition);
		val3 += val4;
		if (m_MovementType == MovementType.Elastic)
		{
			if (val4.x != 0f)
			{
				val3.x -= RubberDelta(val4.x, ((Bounds)(ref m_ViewBounds)).size.x);
			}
			if (val4.y != 0f)
			{
				val3.y -= RubberDelta(val4.y, ((Bounds)(ref m_ViewBounds)).size.y);
			}
		}
		SetContentAnchoredPosition(val3);
	}

	protected virtual void SetContentAnchoredPosition(Vector2 position)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (!m_Horizontal)
		{
			position.x = m_Content.anchoredPosition.x;
		}
		if (!m_Vertical)
		{
			position.y = m_Content.anchoredPosition.y;
		}
		if (position != m_Content.anchoredPosition)
		{
			m_Content.anchoredPosition = position;
			UpdateBounds();
		}
	}

	protected virtual void LateUpdate()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)m_Content))
		{
			return;
		}
		EnsureLayoutHasRebuilt();
		UpdateScrollbarVisibility();
		UpdateBounds();
		float unscaledDeltaTime = Time.unscaledDeltaTime;
		Vector2 val = CalculateOffset(Vector2.zero);
		if (!m_Dragging && (val != Vector2.zero || m_Velocity != Vector2.zero))
		{
			Vector2 val2 = m_Content.anchoredPosition;
			for (int i = 0; i < 2; i++)
			{
				if (m_MovementType == MovementType.Elastic && ((Vector2)(ref val))[i] != 0f)
				{
					float num = ((Vector2)(ref m_Velocity))[i];
					int num2 = i;
					Vector2 anchoredPosition = m_Content.anchoredPosition;
					float num3 = ((Vector2)(ref anchoredPosition))[i];
					anchoredPosition = m_Content.anchoredPosition;
					((Vector2)(ref val2))[num2] = Mathf.SmoothDamp(num3, ((Vector2)(ref anchoredPosition))[i] + ((Vector2)(ref val))[i], ref num, m_Elasticity, float.PositiveInfinity, unscaledDeltaTime);
					((Vector2)(ref m_Velocity))[i] = num;
				}
				else if (m_Inertia)
				{
					ref Vector2 reference = ref m_Velocity;
					int num4 = i;
					((Vector2)(ref reference))[num4] = ((Vector2)(ref reference))[num4] * Mathf.Pow(m_DecelerationRate, unscaledDeltaTime);
					if (Mathf.Abs(((Vector2)(ref m_Velocity))[i]) < 1f)
					{
						((Vector2)(ref m_Velocity))[i] = 0f;
					}
					reference = ref val2;
					num4 = i;
					((Vector2)(ref reference))[num4] = ((Vector2)(ref reference))[num4] + ((Vector2)(ref m_Velocity))[i] * unscaledDeltaTime;
				}
				else
				{
					((Vector2)(ref m_Velocity))[i] = 0f;
				}
			}
			if (m_Velocity != Vector2.zero)
			{
				if (m_MovementType == MovementType.Clamped)
				{
					val = CalculateOffset(val2 - m_Content.anchoredPosition);
					val2 += val;
				}
				SetContentAnchoredPosition(val2);
			}
		}
		if (m_Dragging && m_Inertia)
		{
			Vector3 val3 = Vector2.op_Implicit((m_Content.anchoredPosition - m_PrevPosition) / unscaledDeltaTime);
			m_Velocity = Vector2.op_Implicit(Vector3.Lerp(Vector2.op_Implicit(m_Velocity), val3, unscaledDeltaTime * 10f));
		}
		if (m_ViewBounds != m_PrevViewBounds || m_ContentBounds != m_PrevContentBounds || m_Content.anchoredPosition != m_PrevPosition)
		{
			UpdateScrollbars(val);
			((UnityEvent<Vector2>)m_OnValueChanged).Invoke(normalizedPosition);
			UpdatePrevData();
		}
	}

	private void UpdatePrevData()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)m_Content == (Object)null)
		{
			m_PrevPosition = Vector2.zero;
		}
		else
		{
			m_PrevPosition = m_Content.anchoredPosition;
		}
		m_PrevViewBounds = m_ViewBounds;
		m_PrevContentBounds = m_ContentBounds;
	}

	private void UpdateScrollbars(Vector2 offset)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)m_HorizontalScrollbar))
		{
			if (((Bounds)(ref m_ContentBounds)).size.x > 0f)
			{
				m_HorizontalScrollbar.size = Mathf.Clamp01((((Bounds)(ref m_ViewBounds)).size.x - Mathf.Abs(offset.x)) / ((Bounds)(ref m_ContentBounds)).size.x);
			}
			else
			{
				m_HorizontalScrollbar.size = 1f;
			}
			m_HorizontalScrollbar.value = horizontalNormalizedPosition;
		}
		if (Object.op_Implicit((Object)(object)m_VerticalScrollbar))
		{
			if (((Bounds)(ref m_ContentBounds)).size.y > 0f)
			{
				m_VerticalScrollbar.size = Mathf.Clamp01((((Bounds)(ref m_ViewBounds)).size.y - Mathf.Abs(offset.y)) / ((Bounds)(ref m_ContentBounds)).size.y);
			}
			else
			{
				m_VerticalScrollbar.size = 1f;
			}
			m_VerticalScrollbar.value = verticalNormalizedPosition;
		}
	}

	private void SetHorizontalNormalizedPosition(float value)
	{
		SetNormalizedPosition(value, 0);
	}

	private void SetVerticalNormalizedPosition(float value)
	{
		SetNormalizedPosition(value, 1);
	}

	private void SetNormalizedPosition(float value, int axis)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		EnsureLayoutHasRebuilt();
		UpdateBounds();
		Vector3 val = ((Bounds)(ref m_ContentBounds)).size;
		float num = ((Vector3)(ref val))[axis];
		val = ((Bounds)(ref m_ViewBounds)).size;
		float num2 = num - ((Vector3)(ref val))[axis];
		val = ((Bounds)(ref m_ViewBounds)).min;
		float num3 = ((Vector3)(ref val))[axis] - value * num2;
		val = ((Transform)m_Content).localPosition;
		float num4 = ((Vector3)(ref val))[axis] + num3;
		val = ((Bounds)(ref m_ContentBounds)).min;
		float num5 = num4 - ((Vector3)(ref val))[axis];
		Vector3 localPosition = ((Transform)m_Content).localPosition;
		if (Mathf.Abs(((Vector3)(ref localPosition))[axis] - num5) > 0.01f)
		{
			((Vector3)(ref localPosition))[axis] = num5;
			((Transform)m_Content).localPosition = localPosition;
			((Vector2)(ref m_Velocity))[axis] = 0f;
			UpdateBounds();
		}
	}

	private static float RubberDelta(float overStretching, float viewSize)
	{
		return (1f - 1f / (Mathf.Abs(overStretching) * 0.55f / viewSize + 1f)) * viewSize * Mathf.Sign(overStretching);
	}

	protected override void OnRectTransformDimensionsChange()
	{
		SetDirty();
	}

	public virtual void SetLayoutHorizontal()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		((DrivenRectTransformTracker)(ref m_Tracker)).Clear();
		Rect rect;
		if (m_HSliderExpand || m_VSliderExpand)
		{
			((DrivenRectTransformTracker)(ref m_Tracker)).Add((Object)(object)this, viewRect, (DrivenTransformProperties)16134);
			viewRect.anchorMin = Vector2.zero;
			viewRect.anchorMax = Vector2.one;
			viewRect.sizeDelta = Vector2.zero;
			viewRect.anchoredPosition = Vector2.zero;
			LayoutRebuilder.ForceRebuildLayoutImmediate(content);
			rect = viewRect.rect;
			Vector3 val = Vector2.op_Implicit(((Rect)(ref rect)).center);
			rect = viewRect.rect;
			m_ViewBounds = new Bounds(val, Vector2.op_Implicit(((Rect)(ref rect)).size));
			m_ContentBounds = GetBounds();
		}
		if (m_VSliderExpand && vScrollingNeeded)
		{
			viewRect.sizeDelta = new Vector2(0f - (m_VSliderWidth + m_VerticalScrollbarSpacing), viewRect.sizeDelta.y);
			LayoutRebuilder.ForceRebuildLayoutImmediate(content);
			rect = viewRect.rect;
			Vector3 val2 = Vector2.op_Implicit(((Rect)(ref rect)).center);
			rect = viewRect.rect;
			m_ViewBounds = new Bounds(val2, Vector2.op_Implicit(((Rect)(ref rect)).size));
			m_ContentBounds = GetBounds();
		}
		if (m_HSliderExpand && hScrollingNeeded)
		{
			viewRect.sizeDelta = new Vector2(viewRect.sizeDelta.x, 0f - (m_HSliderHeight + m_HorizontalScrollbarSpacing));
			rect = viewRect.rect;
			Vector3 val3 = Vector2.op_Implicit(((Rect)(ref rect)).center);
			rect = viewRect.rect;
			m_ViewBounds = new Bounds(val3, Vector2.op_Implicit(((Rect)(ref rect)).size));
			m_ContentBounds = GetBounds();
		}
		if (m_VSliderExpand && vScrollingNeeded && viewRect.sizeDelta.x == 0f && viewRect.sizeDelta.y < 0f)
		{
			viewRect.sizeDelta = new Vector2(0f - (m_VSliderWidth + m_VerticalScrollbarSpacing), viewRect.sizeDelta.y);
		}
	}

	public virtual void SetLayoutVertical()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		UpdateScrollbarLayout();
		Rect rect = viewRect.rect;
		Vector3 val = Vector2.op_Implicit(((Rect)(ref rect)).center);
		rect = viewRect.rect;
		m_ViewBounds = new Bounds(val, Vector2.op_Implicit(((Rect)(ref rect)).size));
		m_ContentBounds = GetBounds();
	}

	private void UpdateScrollbarVisibility()
	{
		if (Object.op_Implicit((Object)(object)m_VerticalScrollbar) && m_VerticalScrollbarVisibility != 0 && ((Component)m_VerticalScrollbar).gameObject.activeSelf != vScrollingNeeded)
		{
			((Component)m_VerticalScrollbar).gameObject.SetActive(vScrollingNeeded);
		}
		if (Object.op_Implicit((Object)(object)m_HorizontalScrollbar) && m_HorizontalScrollbarVisibility != 0 && ((Component)m_HorizontalScrollbar).gameObject.activeSelf != hScrollingNeeded)
		{
			((Component)m_HorizontalScrollbar).gameObject.SetActive(hScrollingNeeded);
		}
	}

	private void UpdateScrollbarLayout()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		if (m_VSliderExpand && Object.op_Implicit((Object)(object)m_HorizontalScrollbar))
		{
			((DrivenRectTransformTracker)(ref m_Tracker)).Add((Object)(object)this, m_HorizontalScrollbarRect, (DrivenTransformProperties)5378);
			m_HorizontalScrollbarRect.anchorMin = new Vector2(0f, m_HorizontalScrollbarRect.anchorMin.y);
			m_HorizontalScrollbarRect.anchorMax = new Vector2(1f, m_HorizontalScrollbarRect.anchorMax.y);
			m_HorizontalScrollbarRect.anchoredPosition = new Vector2(0f, m_HorizontalScrollbarRect.anchoredPosition.y);
			if (vScrollingNeeded)
			{
				m_HorizontalScrollbarRect.sizeDelta = new Vector2(0f - (m_VSliderWidth + m_VerticalScrollbarSpacing), m_HorizontalScrollbarRect.sizeDelta.y);
			}
			else
			{
				m_HorizontalScrollbarRect.sizeDelta = new Vector2(0f, m_HorizontalScrollbarRect.sizeDelta.y);
			}
		}
		if (m_HSliderExpand && Object.op_Implicit((Object)(object)m_VerticalScrollbar))
		{
			((DrivenRectTransformTracker)(ref m_Tracker)).Add((Object)(object)this, m_VerticalScrollbarRect, (DrivenTransformProperties)10756);
			m_VerticalScrollbarRect.anchorMin = new Vector2(m_VerticalScrollbarRect.anchorMin.x, 0f);
			m_VerticalScrollbarRect.anchorMax = new Vector2(m_VerticalScrollbarRect.anchorMax.x, 1f);
			m_VerticalScrollbarRect.anchoredPosition = new Vector2(m_VerticalScrollbarRect.anchoredPosition.x, 0f);
			if (hScrollingNeeded)
			{
				m_VerticalScrollbarRect.sizeDelta = new Vector2(m_VerticalScrollbarRect.sizeDelta.x, 0f - (m_HSliderHeight + m_HorizontalScrollbarSpacing));
			}
			else
			{
				m_VerticalScrollbarRect.sizeDelta = new Vector2(m_VerticalScrollbarRect.sizeDelta.x, 0f);
			}
		}
	}

	private void UpdateBounds()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = viewRect.rect;
		Vector3 val = Vector2.op_Implicit(((Rect)(ref rect)).center);
		rect = viewRect.rect;
		m_ViewBounds = new Bounds(val, Vector2.op_Implicit(((Rect)(ref rect)).size));
		m_ContentBounds = GetBounds();
		if (!((Object)(object)m_Content == (Object)null))
		{
			Vector3 size = ((Bounds)(ref m_ContentBounds)).size;
			Vector3 center = ((Bounds)(ref m_ContentBounds)).center;
			Vector3 val2 = ((Bounds)(ref m_ViewBounds)).size - size;
			if (val2.x > 0f)
			{
				center.x -= val2.x * (m_Content.pivot.x - 0.5f);
				size.x = ((Bounds)(ref m_ViewBounds)).size.x;
			}
			if (val2.y > 0f)
			{
				center.y -= val2.y * (m_Content.pivot.y - 0.5f);
				size.y = ((Bounds)(ref m_ViewBounds)).size.y;
			}
			((Bounds)(ref m_ContentBounds)).size = size;
			((Bounds)(ref m_ContentBounds)).center = center;
		}
	}

	private Bounds GetBounds()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)m_Content == (Object)null)
		{
			return default(Bounds);
		}
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(float.MaxValue, float.MaxValue, float.MaxValue);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(float.MinValue, float.MinValue, float.MinValue);
		Matrix4x4 worldToLocalMatrix = ((Transform)viewRect).worldToLocalMatrix;
		m_Content.GetWorldCorners(m_Corners);
		for (int i = 0; i < 4; i++)
		{
			Vector3 val3 = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint3x4(m_Corners[i]);
			val = Vector3.Min(val3, val);
			val2 = Vector3.Max(val3, val2);
		}
		Bounds result = default(Bounds);
		((Bounds)(ref result))..ctor(val, Vector3.zero);
		((Bounds)(ref result)).Encapsulate(val2);
		return result;
	}

	private Vector2 CalculateOffset(Vector2 delta)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		Vector2 zero = Vector2.zero;
		if (m_MovementType == MovementType.Unrestricted)
		{
			return zero;
		}
		Vector2 val = Vector2.op_Implicit(((Bounds)(ref m_ContentBounds)).min);
		Vector2 val2 = Vector2.op_Implicit(((Bounds)(ref m_ContentBounds)).max);
		if (m_Horizontal)
		{
			val.x += delta.x;
			val2.x += delta.x;
			if (val.x > ((Bounds)(ref m_ViewBounds)).min.x)
			{
				zero.x = ((Bounds)(ref m_ViewBounds)).min.x - val.x;
			}
			else if (val2.x < ((Bounds)(ref m_ViewBounds)).max.x)
			{
				zero.x = ((Bounds)(ref m_ViewBounds)).max.x - val2.x;
			}
		}
		if (m_Vertical)
		{
			val.y += delta.y;
			val2.y += delta.y;
			if (val2.y < ((Bounds)(ref m_ViewBounds)).max.y)
			{
				zero.y = ((Bounds)(ref m_ViewBounds)).max.y - val2.y;
			}
			else if (val.y > ((Bounds)(ref m_ViewBounds)).min.y)
			{
				zero.y = ((Bounds)(ref m_ViewBounds)).min.y - val.y;
			}
		}
		return zero;
	}

	protected void SetDirty()
	{
		if (((UIBehaviour)this).IsActive())
		{
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
		}
	}

	protected void SetDirtyCaching()
	{
		if (((UIBehaviour)this).IsActive())
		{
			CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild((ICanvasElement)(object)this);
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
		}
	}

	public void CenterOnPosition(Vector2 pos)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
		Vector2 val2 = default(Vector2);
		((Vector2)(ref val2))..ctor(((Transform)content).localScale.x, ((Transform)content).localScale.y);
		pos.x *= val2.x;
		pos.y *= val2.y;
		Rect rect = content.rect;
		float num = ((Rect)(ref rect)).width * val2.x;
		rect = val.rect;
		float num2 = num - ((Rect)(ref rect)).width;
		rect = content.rect;
		float num3 = ((Rect)(ref rect)).height * val2.y;
		rect = val.rect;
		Vector2 val3 = default(Vector2);
		((Vector2)(ref val3))..ctor(num2, num3 - ((Rect)(ref rect)).height);
		pos.x = pos.x / val3.x + content.pivot.x;
		pos.y = pos.y / val3.y + content.pivot.y;
		if (movementType != 0)
		{
			pos.x = Mathf.Clamp(pos.x, 0f, 1f);
			pos.y = Mathf.Clamp(pos.y, 0f, 1f);
		}
		normalizedPosition = pos;
	}

	public void LayoutComplete()
	{
	}

	public void GraphicUpdateComplete()
	{
	}

	Transform ICanvasElement.get_transform()
	{
		return ((Component)this).transform;
	}
}


public enum MovementType
{
	Unrestricted,
	Elastic,
	Clamped
}


public enum ScrollbarVisibility
{
	Permanent,
	AutoHide,
	AutoHideAndExpandViewport
}


using System;
using UnityEngine.Events;

[Serializable]
public class ScrollRectEvent : UnityEvent<Vector2>
{
}


using UnityEngine.UI;

public class ScrollRectSettable : ScrollRect
{
	public void SetHorizNormalizedPosition(float value)
	{
		((ScrollRect)this).SetNormalizedPosition(value, 0);
	}

	public void SetVertNormalizedPosition(float value)
	{
		((ScrollRect)this).SetNormalizedPosition(value, 1);
	}
}


using System;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/Diamond Graph")]
public class DiamondGraph : UIPrimitiveBase
{
	[SerializeField]
	private float m_a = 1f;

	[SerializeField]
	private float m_b = 1f;

	[SerializeField]
	private float m_c = 1f;

	[SerializeField]
	private float m_d = 1f;

	public float A
	{
		get
		{
			return m_a;
		}
		set
		{
			m_a = value;
		}
	}

	public float B
	{
		get
		{
			return m_b;
		}
		set
		{
			m_b = value;
		}
	}

	public float C
	{
		get
		{
			return m_c;
		}
		set
		{
			m_c = value;
		}
	}

	public float D
	{
		get
		{
			return m_d;
		}
		set
		{
			m_d = value;
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		vh.Clear();
		Rect rect = ((Graphic)this).rectTransform.rect;
		float num = ((Rect)(ref rect)).width / 2f;
		m_a = Math.Min(1f, Math.Max(0f, m_a));
		m_b = Math.Min(1f, Math.Max(0f, m_b));
		m_c = Math.Min(1f, Math.Max(0f, m_c));
		m_d = Math.Min(1f, Math.Max(0f, m_d));
		Color32 val = Color32.op_Implicit(((Graphic)this).color);
		vh.AddVert(new Vector3((0f - num) * m_a, 0f), val, new Vector2(0f, 0f));
		vh.AddVert(new Vector3(0f, num * m_b), val, new Vector2(0f, 1f));
		vh.AddVert(new Vector3(num * m_c, 0f), val, new Vector2(1f, 1f));
		vh.AddVert(new Vector3(0f, (0f - num) * m_d), val, new Vector2(1f, 0f));
		vh.AddTriangle(0, 1, 2);
		vh.AddTriangle(2, 3, 0);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UI Circle")]
public class UICircle : UIPrimitiveBase
{
	[Tooltip("The Arc Invert property will invert the construction of the Arc.")]
	public bool ArcInvert = true;

	[Tooltip("The Arc property is a percentage of the entire circumference of the circle.")]
	[Range(0f, 1f)]
	public float Arc = 1f;

	[Range(0f, 1000f)]
	[Tooltip("The Arc Steps property defines the number of segments that the Arc will be divided into.")]
	public int ArcSteps = 100;

	[Tooltip("The Arc Rotation property permits adjusting the geometry orientation around the Z axis.")]
	[Range(0f, 360f)]
	public int ArcRotation;

	[Tooltip("The Progress property allows the primitive to be used as a progression indicator.")]
	[Range(0f, 1f)]
	public float Progress;

	private float _progress;

	public Color ProgressColor = new Color(255f, 255f, 255f, 255f);

	public bool Fill = true;

	public float Thickness = 5f;

	public int Padding;

	private List<int> indices = new List<int>();

	private List<UIVertex> vertices = new List<UIVertex>();

	private Vector2 uvCenter = new Vector2(0.5f, 0.5f);

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0407: Unknown result type (might be due to invalid IL or missing references)
		//IL_0409: Unknown result type (might be due to invalid IL or missing references)
		//IL_040e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0416: Unknown result type (might be due to invalid IL or missing references)
		//IL_041b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0420: Unknown result type (might be due to invalid IL or missing references)
		//IL_0428: Unknown result type (might be due to invalid IL or missing references)
		//IL_042d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0432: Unknown result type (might be due to invalid IL or missing references)
		//IL_043d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		int num = ((!ArcInvert) ? 1 : (-1));
		Rect rect = ((Graphic)this).rectTransform.rect;
		float width = ((Rect)(ref rect)).width;
		rect = ((Graphic)this).rectTransform.rect;
		float num2;
		if (!(width < ((Rect)(ref rect)).height))
		{
			rect = ((Graphic)this).rectTransform.rect;
			num2 = ((Rect)(ref rect)).height;
		}
		else
		{
			rect = ((Graphic)this).rectTransform.rect;
			num2 = ((Rect)(ref rect)).width;
		}
		float num3 = num2 - (float)Padding;
		float num4 = (0f - ((Graphic)this).rectTransform.pivot.x) * num3;
		float num5 = (0f - ((Graphic)this).rectTransform.pivot.x) * num3 + Thickness;
		vh.Clear();
		indices.Clear();
		vertices.Clear();
		int item = 0;
		int num6 = 1;
		int num7 = 0;
		float num8 = Arc * 360f / (float)ArcSteps;
		_progress = (float)ArcSteps * Progress;
		float num9 = (float)num * (MathF.PI / 180f) * (float)ArcRotation;
		float num10 = Mathf.Cos(num9);
		float num11 = Mathf.Sin(num9);
		UIVertex simpleVert = UIVertex.simpleVert;
		simpleVert.color = Color32.op_Implicit((_progress > 0f) ? ProgressColor : ((Graphic)this).color);
		simpleVert.position = Vector2.op_Implicit(new Vector2(num4 * num10, num4 * num11));
		simpleVert.uv0 = Vector4.op_Implicit(new Vector2(simpleVert.position.x / num3 + 0.5f, simpleVert.position.y / num3 + 0.5f));
		vertices.Add(simpleVert);
		Vector2 zero = default(Vector2);
		((Vector2)(ref zero))..ctor(num5 * num10, num5 * num11);
		if (Fill)
		{
			zero = Vector2.zero;
		}
		simpleVert.position = Vector2.op_Implicit(zero);
		simpleVert.uv0 = Vector4.op_Implicit((Vector2)(Fill ? uvCenter : new Vector2(simpleVert.position.x / num3 + 0.5f, simpleVert.position.y / num3 + 0.5f)));
		vertices.Add(simpleVert);
		for (int i = 1; i <= ArcSteps; i++)
		{
			float num12 = (float)num * (MathF.PI / 180f) * ((float)i * num8 + (float)ArcRotation);
			num10 = Mathf.Cos(num12);
			num11 = Mathf.Sin(num12);
			simpleVert.color = Color32.op_Implicit(((float)i > _progress) ? ((Graphic)this).color : ProgressColor);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num4 * num10, num4 * num11));
			simpleVert.uv0 = Vector4.op_Implicit(new Vector2(simpleVert.position.x / num3 + 0.5f, simpleVert.position.y / num3 + 0.5f));
			vertices.Add(simpleVert);
			if (!Fill)
			{
				simpleVert.position = Vector2.op_Implicit(new Vector2(num5 * num10, num5 * num11));
				simpleVert.uv0 = Vector4.op_Implicit(new Vector2(simpleVert.position.x / num3 + 0.5f, simpleVert.position.y / num3 + 0.5f));
				vertices.Add(simpleVert);
				num7 = num6;
				indices.Add(item);
				indices.Add(num6 + 1);
				indices.Add(num6);
				num6++;
				item = num6;
				num6++;
				indices.Add(item);
				indices.Add(num6);
				indices.Add(num7);
			}
			else
			{
				indices.Add(item);
				indices.Add(num6 + 1);
				if ((float)i > _progress)
				{
					indices.Add(ArcSteps + 2);
				}
				else
				{
					indices.Add(1);
				}
				num6++;
				item = num6;
			}
		}
		if (Fill)
		{
			simpleVert.position = Vector2.op_Implicit(zero);
			simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
			simpleVert.uv0 = Vector4.op_Implicit(uvCenter);
			vertices.Add(simpleVert);
		}
		vh.AddUIVertexStream(vertices, indices);
	}

	public void SetProgress(float progress)
	{
		Progress = progress;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetArcSteps(int steps)
	{
		ArcSteps = steps;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetInvertArc(bool invert)
	{
		ArcInvert = invert;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetArcRotation(int rotation)
	{
		ArcRotation = rotation;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetFill(bool fill)
	{
		Fill = fill;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetBaseColor(Color color)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		((Graphic)this).color = color;
		((Graphic)this).SetVerticesDirty();
	}

	public void UpdateBaseAlpha(float value)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Color color = ((Graphic)this).color;
		color.a = value;
		((Graphic)this).color = color;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetProgressColor(Color color)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		ProgressColor = color;
		((Graphic)this).SetVerticesDirty();
	}

	public void UpdateProgressAlpha(float value)
	{
		ProgressColor.a = value;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetPadding(int padding)
	{
		Padding = padding;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetThickness(int thickness)
	{
		Thickness = thickness;
		((Graphic)this).SetVerticesDirty();
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UI Circle Simple")]
public class UICircleSimple : UIPrimitiveBase
{
	[Tooltip("The Arc Steps property defines the number of segments that the Arc will be divided into.")]
	[Range(0f, 1000f)]
	public int ArcSteps = 100;

	public bool Fill = true;

	public float Thickness = 5f;

	public bool ThicknessIsOutside;

	private List<int> indices = new List<int>();

	private List<UIVertex> vertices = new List<UIVertex>();

	private Vector2 uvCenter = new Vector2(0.5f, 0.5f);

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = ((Graphic)this).rectTransform.rect;
		float width = ((Rect)(ref rect)).width;
		rect = ((Graphic)this).rectTransform.rect;
		float num;
		if (!(width < ((Rect)(ref rect)).height))
		{
			rect = ((Graphic)this).rectTransform.rect;
			num = ((Rect)(ref rect)).height;
		}
		else
		{
			rect = ((Graphic)this).rectTransform.rect;
			num = ((Rect)(ref rect)).width;
		}
		float num2 = num;
		float num3 = (ThicknessIsOutside ? ((0f - ((Graphic)this).rectTransform.pivot.x) * num2 - Thickness) : ((0f - ((Graphic)this).rectTransform.pivot.x) * num2));
		float num4 = (ThicknessIsOutside ? ((0f - ((Graphic)this).rectTransform.pivot.x) * num2) : ((0f - ((Graphic)this).rectTransform.pivot.x) * num2 + Thickness));
		vh.Clear();
		indices.Clear();
		vertices.Clear();
		int item = 0;
		int num5 = 1;
		int num6 = 0;
		float num7 = 360f / (float)ArcSteps;
		float num8 = Mathf.Cos(0f);
		float num9 = Mathf.Sin(0f);
		UIVertex simpleVert = UIVertex.simpleVert;
		simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
		simpleVert.position = Vector2.op_Implicit(new Vector2(num3 * num8, num3 * num9));
		simpleVert.uv0 = Vector4.op_Implicit(new Vector2(simpleVert.position.x / num2 + 0.5f, simpleVert.position.y / num2 + 0.5f));
		vertices.Add(simpleVert);
		Vector2 zero = default(Vector2);
		((Vector2)(ref zero))..ctor(num4 * num8, num4 * num9);
		if (Fill)
		{
			zero = Vector2.zero;
		}
		simpleVert.position = Vector2.op_Implicit(zero);
		simpleVert.uv0 = Vector4.op_Implicit((Vector2)(Fill ? uvCenter : new Vector2(simpleVert.position.x / num2 + 0.5f, simpleVert.position.y / num2 + 0.5f)));
		vertices.Add(simpleVert);
		for (int i = 1; i <= ArcSteps; i++)
		{
			float num10 = MathF.PI / 180f * ((float)i * num7);
			num8 = Mathf.Cos(num10);
			num9 = Mathf.Sin(num10);
			simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num3 * num8, num3 * num9));
			simpleVert.uv0 = Vector4.op_Implicit(new Vector2(simpleVert.position.x / num2 + 0.5f, simpleVert.position.y / num2 + 0.5f));
			vertices.Add(simpleVert);
			if (!Fill)
			{
				simpleVert.position = Vector2.op_Implicit(new Vector2(num4 * num8, num4 * num9));
				simpleVert.uv0 = Vector4.op_Implicit(new Vector2(simpleVert.position.x / num2 + 0.5f, simpleVert.position.y / num2 + 0.5f));
				vertices.Add(simpleVert);
				num6 = num5;
				indices.Add(item);
				indices.Add(num5 + 1);
				indices.Add(num5);
				num5++;
				item = num5;
				num5++;
				indices.Add(item);
				indices.Add(num5);
				indices.Add(num6);
			}
			else
			{
				indices.Add(item);
				indices.Add(num5 + 1);
				indices.Add(1);
				num5++;
				item = num5;
			}
		}
		if (Fill)
		{
			simpleVert.position = Vector2.op_Implicit(zero);
			simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
			simpleVert.uv0 = Vector4.op_Implicit(uvCenter);
			vertices.Add(simpleVert);
		}
		vh.AddUIVertexStream(vertices, indices);
	}

	public void SetArcSteps(int steps)
	{
		ArcSteps = steps;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetFill(bool fill)
	{
		Fill = fill;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetBaseColor(Color color)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		((Graphic)this).color = color;
		((Graphic)this).SetVerticesDirty();
	}

	public void UpdateBaseAlpha(float value)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Color color = ((Graphic)this).color;
		color.a = value;
		((Graphic)this).color = color;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetThickness(int thickness)
	{
		Thickness = thickness;
		((Graphic)this).SetVerticesDirty();
	}
}


using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/Cut Corners")]
public class UICornerCut : UIPrimitiveBase
{
	public Vector2 cornerSize = new Vector2(16f, 16f);

	[SerializeField]
	[Header("Corners to cut")]
	private bool m_cutUL = true;

	[SerializeField]
	private bool m_cutUR;

	[SerializeField]
	private bool m_cutLL;

	[SerializeField]
	private bool m_cutLR;

	[Tooltip("Up-Down colors become Left-Right colors")]
	[SerializeField]
	private bool m_makeColumns;

	[SerializeField]
	[Header("Color the cut bars differently")]
	private bool m_useColorUp;

	[SerializeField]
	private Color32 m_colorUp;

	[SerializeField]
	private bool m_useColorDown;

	[SerializeField]
	private Color32 m_colorDown;

	public bool CutUL
	{
		get
		{
			return m_cutUL;
		}
		set
		{
			m_cutUL = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool CutUR
	{
		get
		{
			return m_cutUR;
		}
		set
		{
			m_cutUR = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool CutLL
	{
		get
		{
			return m_cutLL;
		}
		set
		{
			m_cutLL = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool CutLR
	{
		get
		{
			return m_cutLR;
		}
		set
		{
			m_cutLR = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool MakeColumns
	{
		get
		{
			return m_makeColumns;
		}
		set
		{
			m_makeColumns = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool UseColorUp
	{
		get
		{
			return m_useColorUp;
		}
		set
		{
			m_useColorUp = value;
		}
	}

	public Color32 ColorUp
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_colorUp;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_colorUp = value;
		}
	}

	public bool UseColorDown
	{
		get
		{
			return m_useColorDown;
		}
		set
		{
			m_useColorDown = value;
		}
	}

	public Color32 ColorDown
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_colorDown;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_colorDown = value;
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0306: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_039a: Unknown result type (might be due to invalid IL or missing references)
		//IL_036a: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0370: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = ((Graphic)this).rectTransform.rect;
		Rect val = rect;
		Color32 val2 = Color32.op_Implicit(((Graphic)this).color);
		bool flag = m_cutUL | m_cutUR;
		bool flag2 = m_cutLL | m_cutLR;
		bool flag3 = m_cutLL | m_cutUL;
		bool flag4 = m_cutLR | m_cutUR;
		if (!(flag || flag2) || !(((Vector2)(ref cornerSize)).sqrMagnitude > 0f))
		{
			return;
		}
		vh.Clear();
		if (flag3)
		{
			((Rect)(ref val)).xMin = ((Rect)(ref val)).xMin + cornerSize.x;
		}
		if (flag2)
		{
			((Rect)(ref val)).yMin = ((Rect)(ref val)).yMin + cornerSize.y;
		}
		if (flag)
		{
			((Rect)(ref val)).yMax = ((Rect)(ref val)).yMax - cornerSize.y;
		}
		if (flag4)
		{
			((Rect)(ref val)).xMax = ((Rect)(ref val)).xMax - cornerSize.x;
		}
		Vector2 val3 = default(Vector2);
		Vector2 val4 = default(Vector2);
		Vector2 val5 = default(Vector2);
		Vector2 val6 = default(Vector2);
		if (m_makeColumns)
		{
			((Vector2)(ref val3))..ctor(((Rect)(ref rect)).xMin, m_cutUL ? ((Rect)(ref val)).yMax : ((Rect)(ref rect)).yMax);
			((Vector2)(ref val4))..ctor(((Rect)(ref rect)).xMax, m_cutUR ? ((Rect)(ref val)).yMax : ((Rect)(ref rect)).yMax);
			((Vector2)(ref val5))..ctor(((Rect)(ref rect)).xMin, m_cutLL ? ((Rect)(ref val)).yMin : ((Rect)(ref rect)).yMin);
			((Vector2)(ref val6))..ctor(((Rect)(ref rect)).xMax, m_cutLR ? ((Rect)(ref val)).yMin : ((Rect)(ref rect)).yMin);
			if (flag3)
			{
				AddSquare(val5, val3, new Vector2(((Rect)(ref val)).xMin, ((Rect)(ref rect)).yMax), new Vector2(((Rect)(ref val)).xMin, ((Rect)(ref rect)).yMin), rect, m_useColorUp ? m_colorUp : val2, vh);
			}
			if (flag4)
			{
				AddSquare(val4, val6, new Vector2(((Rect)(ref val)).xMax, ((Rect)(ref rect)).yMin), new Vector2(((Rect)(ref val)).xMax, ((Rect)(ref rect)).yMax), rect, m_useColorDown ? m_colorDown : val2, vh);
			}
		}
		else
		{
			((Vector2)(ref val3))..ctor(m_cutUL ? ((Rect)(ref val)).xMin : ((Rect)(ref rect)).xMin, ((Rect)(ref rect)).yMax);
			((Vector2)(ref val4))..ctor(m_cutUR ? ((Rect)(ref val)).xMax : ((Rect)(ref rect)).xMax, ((Rect)(ref rect)).yMax);
			((Vector2)(ref val5))..ctor(m_cutLL ? ((Rect)(ref val)).xMin : ((Rect)(ref rect)).xMin, ((Rect)(ref rect)).yMin);
			((Vector2)(ref val6))..ctor(m_cutLR ? ((Rect)(ref val)).xMax : ((Rect)(ref rect)).xMax, ((Rect)(ref rect)).yMin);
			if (flag2)
			{
				AddSquare(val6, val5, new Vector2(((Rect)(ref rect)).xMin, ((Rect)(ref val)).yMin), new Vector2(((Rect)(ref rect)).xMax, ((Rect)(ref val)).yMin), rect, m_useColorDown ? m_colorDown : val2, vh);
			}
			if (flag)
			{
				AddSquare(val3, val4, new Vector2(((Rect)(ref rect)).xMax, ((Rect)(ref val)).yMax), new Vector2(((Rect)(ref rect)).xMin, ((Rect)(ref val)).yMax), rect, m_useColorUp ? m_colorUp : val2, vh);
			}
		}
		if (m_makeColumns)
		{
			AddSquare(new Rect(((Rect)(ref val)).xMin, ((Rect)(ref rect)).yMin, ((Rect)(ref val)).width, ((Rect)(ref rect)).height), rect, val2, vh);
		}
		else
		{
			AddSquare(new Rect(((Rect)(ref rect)).xMin, ((Rect)(ref val)).yMin, ((Rect)(ref rect)).width, ((Rect)(ref val)).height), rect, val2, vh);
		}
	}

	private static void AddSquare(Rect rect, Rect rectUV, Color32 color32, VertexHelper vh)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		int num = AddVert(((Rect)(ref rect)).xMin, ((Rect)(ref rect)).yMin, rectUV, color32, vh);
		int num2 = AddVert(((Rect)(ref rect)).xMin, ((Rect)(ref rect)).yMax, rectUV, color32, vh);
		int num3 = AddVert(((Rect)(ref rect)).xMax, ((Rect)(ref rect)).yMax, rectUV, color32, vh);
		int num4 = AddVert(((Rect)(ref rect)).xMax, ((Rect)(ref rect)).yMin, rectUV, color32, vh);
		vh.AddTriangle(num, num2, num3);
		vh.AddTriangle(num3, num4, num);
	}

	private static void AddSquare(Vector2 a, Vector2 b, Vector2 c, Vector2 d, Rect rectUV, Color32 color32, VertexHelper vh)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		int num = AddVert(a.x, a.y, rectUV, color32, vh);
		int num2 = AddVert(b.x, b.y, rectUV, color32, vh);
		int num3 = AddVert(c.x, c.y, rectUV, color32, vh);
		int num4 = AddVert(d.x, d.y, rectUV, color32, vh);
		vh.AddTriangle(num, num2, num3);
		vh.AddTriangle(num3, num4, num);
	}

	private static int AddVert(float x, float y, Rect area, Color32 color32, VertexHelper vh)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(Mathf.InverseLerp(((Rect)(ref area)).xMin, ((Rect)(ref area)).xMax, x), Mathf.InverseLerp(((Rect)(ref area)).yMin, ((Rect)(ref area)).yMax, y));
		vh.AddVert(new Vector3(x, y), color32, val);
		return vh.currentVertCount - 1;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

public class UIGoldenRatioRenderer : UILineRenderer
{
	private enum Orientations
	{
		Left,
		Top,
		Right,
		Bottom
	}

	private readonly List<Vector2> _points = new List<Vector2>();

	private readonly List<Rect> _rects = new List<Rect>();

	private int canvasWidth;

	private int canvasHeight;

	public float lineThickness2 = 1f;

	private void DrawSpiral(VertexHelper vh)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		_points.Clear();
		_rects.Clear();
		float num = (1f + Mathf.Sqrt(5f)) / 2f;
		Rect pixelRect = ((Graphic)this).canvas.pixelRect;
		canvasWidth = (int)((Rect)(ref pixelRect)).width;
		pixelRect = ((Graphic)this).canvas.pixelRect;
		canvasHeight = (int)((Rect)(ref pixelRect)).height;
		Orientations orientation;
		float num2;
		float num3;
		if (canvasWidth > canvasHeight)
		{
			orientation = Orientations.Left;
			if ((float)canvasWidth / (float)canvasHeight > num)
			{
				num2 = canvasHeight;
				num3 = num2 * num;
			}
			else
			{
				num3 = canvasWidth;
				num2 = num3 / num;
			}
		}
		else
		{
			orientation = Orientations.Top;
			if ((float)canvasHeight / (float)canvasWidth > num)
			{
				num3 = canvasWidth;
				num2 = num3 * num;
			}
			else
			{
				num2 = canvasHeight;
				num3 = num2 / num;
			}
		}
		float num4 = -canvasWidth / 2;
		float num5 = canvasHeight / 2;
		num4 += ((float)canvasWidth - num3) / 2f;
		num5 += ((float)canvasHeight - num2) / 2f;
		List<Vector2> list = new List<Vector2>();
		DrawPhiRectangles(vh, list, num4, num5, num3, num2, orientation);
		if (list.Count > 1)
		{
			Vector2 val = list[0];
			Vector2 val2 = list[list.Count - 1];
			float num6 = val.x - val2.x;
			float num7 = val.y - val2.y;
			float num8 = Mathf.Sqrt(num6 * num6 + num7 * num7);
			float num9 = Mathf.Atan2(num7, num6);
			float num10 = MathF.PI / 50f;
			float num11 = 1f - 1f / num / 25f * 0.78f;
			Vector2 item = default(Vector2);
			while (num8 > 32f)
			{
				((Vector2)(ref item))..ctor(val2.x + num8 * Mathf.Cos(num9), (float)canvasHeight - (val2.y + num8 * Mathf.Sin(num9)));
				_points.Add(item);
				num9 += num10;
				num8 *= num11;
			}
		}
	}

	private void DrawPhiRectangles(VertexHelper vh, List<Vector2> points, float x, float y, float width, float height, Orientations orientation)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (!(width < 1f) && !(height < 1f))
		{
			if (width >= 10f && height >= 10f)
			{
				_rects.Add(new Rect(x, y, width, height));
			}
			switch (orientation)
			{
			case Orientations.Left:
				points.Add(new Vector2(x, y + height));
				x += height;
				width -= height;
				orientation = Orientations.Top;
				break;
			case Orientations.Top:
				points.Add(new Vector2(x, y));
				y += width;
				height -= width;
				orientation = Orientations.Right;
				break;
			case Orientations.Right:
				points.Add(new Vector2(x + width, y));
				width -= height;
				orientation = Orientations.Bottom;
				break;
			case Orientations.Bottom:
				points.Add(new Vector2(x + width, y + height));
				height -= width;
				orientation = Orientations.Left;
				break;
			}
			DrawPhiRectangles(vh, points, x, y, width, height, orientation);
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)((Graphic)this).canvas == (Object)null)
		{
			return;
		}
		relativeSize = false;
		DrawSpiral(vh);
		m_points = _points.ToArray();
		base.OnPopulateMesh(vh);
		foreach (Rect rect in _rects)
		{
			Rect current = rect;
			DrawRect(vh, new Rect(((Rect)(ref current)).x, ((Rect)(ref current)).y - lineThickness2 * 0.5f, ((Rect)(ref current)).width, lineThickness2));
			DrawRect(vh, new Rect(((Rect)(ref current)).x - lineThickness2 * 0.5f, ((Rect)(ref current)).y, lineThickness2, ((Rect)(ref current)).height));
			DrawRect(vh, new Rect(((Rect)(ref current)).x, ((Rect)(ref current)).y + ((Rect)(ref current)).height - lineThickness2 * 0.5f, ((Rect)(ref current)).width, lineThickness2));
			DrawRect(vh, new Rect(((Rect)(ref current)).x + ((Rect)(ref current)).width - lineThickness2 * 0.5f, ((Rect)(ref current)).y, lineThickness2, ((Rect)(ref current)).height));
		}
	}

	private void DrawRect(VertexHelper vh, Rect rect)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		Vector2[] array = (Vector2[])(object)new Vector2[4]
		{
			new Vector2(((Rect)(ref rect)).x, ((Rect)(ref rect)).y),
			new Vector2(((Rect)(ref rect)).x + ((Rect)(ref rect)).width, ((Rect)(ref rect)).y),
			new Vector2(((Rect)(ref rect)).x + ((Rect)(ref rect)).width, ((Rect)(ref rect)).y + ((Rect)(ref rect)).height),
			new Vector2(((Rect)(ref rect)).x, ((Rect)(ref rect)).y + ((Rect)(ref rect)).height)
		};
		UIVertex[] array2 = (UIVertex[])(object)new UIVertex[4];
		for (int i = 0; i < array2.Length; i++)
		{
			UIVertex simpleVert = UIVertex.simpleVert;
			simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
			Vector2 val = array[i];
			Rect pixelRect = ((Graphic)this).canvas.pixelRect;
			simpleVert.position = Vector2.op_Implicit(Vector2Ex.WithY(val, ((Rect)(ref pixelRect)).height - array[i].y));
			array2[i] = simpleVert;
		}
		vh.AddUIVertexQuad(array2);
	}
}


private enum Orientations
{
	Left,
	Top,
	Right,
	Bottom
}


using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UIGridRenderer")]
public class UIGridRenderer : UILineRenderer
{
	[SerializeField]
	private int m_GridColumns = 10;

	[SerializeField]
	private int m_GridRows = 10;

	public int GridColumns
	{
		get
		{
			return m_GridColumns;
		}
		set
		{
			if (m_GridColumns != value)
			{
				m_GridColumns = value;
				((Graphic)this).SetAllDirty();
			}
		}
	}

	public int GridRows
	{
		get
		{
			return m_GridRows;
		}
		set
		{
			if (m_GridRows != value)
			{
				m_GridRows = value;
				((Graphic)this).SetAllDirty();
			}
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		relativeSize = true;
		int num = GridRows * 3 + 1;
		if (GridRows % 2 == 0)
		{
			num++;
		}
		num += GridColumns * 3 + 1;
		m_points = (Vector2[])(object)new Vector2[num];
		int num2 = 0;
		for (int i = 0; i < GridRows; i++)
		{
			float x = 1f;
			float x2 = 0f;
			if (i % 2 == 0)
			{
				x = 0f;
				x2 = 1f;
			}
			float y = (float)i / (float)GridRows;
			m_points[num2].x = x;
			m_points[num2].y = y;
			num2++;
			m_points[num2].x = x2;
			m_points[num2].y = y;
			num2++;
			m_points[num2].x = x2;
			m_points[num2].y = (float)(i + 1) / (float)GridRows;
			num2++;
		}
		if (GridRows % 2 == 0)
		{
			m_points[num2].x = 1f;
			m_points[num2].y = 1f;
			num2++;
		}
		m_points[num2].x = 0f;
		m_points[num2].y = 1f;
		num2++;
		for (int j = 0; j < GridColumns; j++)
		{
			float y2 = 1f;
			float y3 = 0f;
			if (j % 2 == 0)
			{
				y2 = 0f;
				y3 = 1f;
			}
			float x3 = (float)j / (float)GridColumns;
			m_points[num2].x = x3;
			m_points[num2].y = y2;
			num2++;
			m_points[num2].x = x3;
			m_points[num2].y = y3;
			num2++;
			m_points[num2].x = (float)(j + 1) / (float)GridColumns;
			m_points[num2].y = y3;
			num2++;
		}
		if (GridColumns % 2 == 0)
		{
			m_points[num2].x = 1f;
			m_points[num2].y = 1f;
		}
		else
		{
			m_points[num2].x = 1f;
			m_points[num2].y = 0f;
		}
		base.OnPopulateMesh(vh);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Sprites;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[RequireComponent(typeof(RectTransform))]
[AddComponentMenu("UI/Extensions/Primitives/UILineRenderer")]
public class UILineRenderer : UIPrimitiveBase
{
	private enum SegmentType
	{
		Start,
		Middle,
		End,
		Full
	}

	public enum JoinType
	{
		Bevel,
		Miter
	}

	public enum BezierType
	{
		None,
		Quick,
		Basic,
		Improved,
		Catenary
	}

	private const float MIN_MITER_JOIN = MathF.PI / 12f;

	private const float MIN_BEVEL_NICE_JOIN = MathF.PI / 6f;

	private static Vector2 UV_TOP_LEFT;

	private static Vector2 UV_BOTTOM_LEFT;

	private static Vector2 UV_TOP_CENTER_LEFT;

	private static Vector2 UV_TOP_CENTER_RIGHT;

	private static Vector2 UV_BOTTOM_CENTER_LEFT;

	private static Vector2 UV_BOTTOM_CENTER_RIGHT;

	private static Vector2 UV_TOP_RIGHT;

	private static Vector2 UV_BOTTOM_RIGHT;

	private static Vector2[] startUvs;

	private static Vector2[] middleUvs;

	private static Vector2[] endUvs;

	private static Vector2[] fullUvs;

	[Tooltip("Points to draw lines between\n Can be improved using the Resolution Option")]
	[SerializeField]
	internal Vector2[] m_points;

	[Tooltip("Segments to be drawn\n This is a list of arrays of points")]
	[SerializeField]
	internal List<Vector2[]> m_segments;

	[Tooltip("Thickness of the line")]
	[SerializeField]
	internal float lineThickness = 2f;

	[SerializeField]
	[Tooltip("Use the relative bounds of the Rect Transform (0,0 -> 0,1) or screen space coordinates")]
	internal bool relativeSize;

	[SerializeField]
	[Tooltip("Do the points identify a single line or split pairs of lines")]
	internal bool lineList;

	[SerializeField]
	[Tooltip("Add end caps to each line\nMultiple caps when used with Line List")]
	internal bool lineCaps;

	[SerializeField]
	[Tooltip("Resolution of the Bezier curve, different to line Resolution")]
	internal int bezierSegmentsPerCurve = 10;

	[Tooltip("The type of Join used between lines, Square/Mitre or Curved/Bevel")]
	public JoinType LineJoins;

	[Tooltip("Bezier method to apply to line, see docs for options\nCan't be used in conjunction with Resolution as Bezier already changes the resolution")]
	public BezierType BezierMode;

	[HideInInspector]
	public bool drivenExternally;

	public float LineThickness
	{
		get
		{
			return lineThickness;
		}
		set
		{
			lineThickness = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool RelativeSize
	{
		get
		{
			return relativeSize;
		}
		set
		{
			relativeSize = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool LineList
	{
		get
		{
			return lineList;
		}
		set
		{
			lineList = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool LineCaps
	{
		get
		{
			return lineCaps;
		}
		set
		{
			lineCaps = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public int BezierSegmentsPerCurve
	{
		get
		{
			return bezierSegmentsPerCurve;
		}
		set
		{
			bezierSegmentsPerCurve = value;
		}
	}

	public Vector2[] Points
	{
		get
		{
			return m_points;
		}
		set
		{
			if (m_points != value)
			{
				m_points = value;
				((Graphic)this).SetAllDirty();
			}
		}
	}

	public List<Vector2[]> Segments
	{
		get
		{
			return m_segments;
		}
		set
		{
			m_segments = value;
			((Graphic)this).SetAllDirty();
		}
	}

	private void PopulateMesh(VertexHelper vh, Vector2[] pointsToDraw)
	{
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_034a: Unknown result type (might be due to invalid IL or missing references)
		//IL_034f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0548: Unknown result type (might be due to invalid IL or missing references)
		//IL_054d: Unknown result type (might be due to invalid IL or missing references)
		//IL_055e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0563: Unknown result type (might be due to invalid IL or missing references)
		//IL_0576: Unknown result type (might be due to invalid IL or missing references)
		//IL_057b: Unknown result type (might be due to invalid IL or missing references)
		//IL_058e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0593: Unknown result type (might be due to invalid IL or missing references)
		//IL_0448: Unknown result type (might be due to invalid IL or missing references)
		//IL_044a: Unknown result type (might be due to invalid IL or missing references)
		//IL_045e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0460: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_0478: Unknown result type (might be due to invalid IL or missing references)
		//IL_048e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0490: Unknown result type (might be due to invalid IL or missing references)
		//IL_0517: Unknown result type (might be due to invalid IL or missing references)
		//IL_0519: Unknown result type (might be due to invalid IL or missing references)
		//IL_052f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0531: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0501: Unknown result type (might be due to invalid IL or missing references)
		if (BezierMode != 0 && BezierMode != BezierType.Catenary && pointsToDraw.Length > 3)
		{
			BezierPath bezierPath = new BezierPath();
			bezierPath.SetControlPoints(pointsToDraw);
			bezierPath.SegmentsPerCurve = bezierSegmentsPerCurve;
			pointsToDraw = (BezierMode switch
			{
				BezierType.Basic => bezierPath.GetDrawingPoints0(), 
				BezierType.Improved => bezierPath.GetDrawingPoints1(), 
				_ => bezierPath.GetDrawingPoints2(), 
			}).ToArray();
		}
		if (BezierMode == BezierType.Catenary && pointsToDraw.Length == 2)
		{
			pointsToDraw = new CableCurve(pointsToDraw)
			{
				slack = base.Resoloution,
				steps = BezierSegmentsPerCurve
			}.Points();
		}
		if (base.ImproveResolution != 0)
		{
			pointsToDraw = IncreaseResolution(pointsToDraw);
		}
		Rect rect;
		float num;
		if (relativeSize)
		{
			rect = ((Graphic)this).rectTransform.rect;
			num = ((Rect)(ref rect)).width;
		}
		else
		{
			num = 1f;
		}
		float num2 = num;
		float num3;
		if (relativeSize)
		{
			rect = ((Graphic)this).rectTransform.rect;
			num3 = ((Rect)(ref rect)).height;
		}
		else
		{
			num3 = 1f;
		}
		float num4 = num3;
		float num5 = (0f - ((Graphic)this).rectTransform.pivot.x) * num2;
		float num6 = (0f - ((Graphic)this).rectTransform.pivot.y) * num4;
		List<UIVertex[]> list = new List<UIVertex[]>();
		if (lineList)
		{
			for (int i = 1; i < pointsToDraw.Length; i += 2)
			{
				Vector2 val = pointsToDraw[i - 1];
				Vector2 val2 = pointsToDraw[i];
				((Vector2)(ref val))..ctor(val.x * num2 + num5, val.y * num4 + num6);
				((Vector2)(ref val2))..ctor(val2.x * num2 + num5, val2.y * num4 + num6);
				if (lineCaps)
				{
					list.Add(CreateLineCap(val, val2, SegmentType.Start));
				}
				list.Add(CreateLineSegment(val, val2, SegmentType.Middle, (list.Count > 1) ? list[list.Count - 2] : null));
				if (lineCaps)
				{
					list.Add(CreateLineCap(val, val2, SegmentType.End));
				}
			}
		}
		else
		{
			for (int j = 1; j < pointsToDraw.Length; j++)
			{
				Vector2 val3 = pointsToDraw[j - 1];
				Vector2 val4 = pointsToDraw[j];
				((Vector2)(ref val3))..ctor(val3.x * num2 + num5, val3.y * num4 + num6);
				((Vector2)(ref val4))..ctor(val4.x * num2 + num5, val4.y * num4 + num6);
				if (lineCaps && j == 1)
				{
					list.Add(CreateLineCap(val3, val4, SegmentType.Start));
				}
				list.Add(CreateLineSegment(val3, val4, SegmentType.Middle));
				if (lineCaps && j == pointsToDraw.Length - 1)
				{
					list.Add(CreateLineCap(val3, val4, SegmentType.End));
				}
			}
		}
		for (int k = 0; k < list.Count; k++)
		{
			if (!lineList && k < list.Count - 1)
			{
				Vector3 val5 = list[k][1].position - list[k][2].position;
				Vector3 val6 = list[k + 1][2].position - list[k + 1][1].position;
				float num7 = Vector2.Angle(Vector2.op_Implicit(val5), Vector2.op_Implicit(val6)) * (MathF.PI / 180f);
				float num8 = Mathf.Sign(Vector3.Cross(((Vector3)(ref val5)).normalized, ((Vector3)(ref val6)).normalized).z);
				float num9 = lineThickness / (2f * Mathf.Tan(num7 / 2f));
				Vector3 position = list[k][2].position - ((Vector3)(ref val5)).normalized * num9 * num8;
				Vector3 position2 = list[k][3].position + ((Vector3)(ref val5)).normalized * num9 * num8;
				JoinType joinType = LineJoins;
				if (joinType == JoinType.Miter)
				{
					if (num9 < ((Vector3)(ref val5)).magnitude / 2f && num9 < ((Vector3)(ref val6)).magnitude / 2f && num7 > MathF.PI / 12f)
					{
						list[k][2].position = position;
						list[k][3].position = position2;
						list[k + 1][0].position = position2;
						list[k + 1][1].position = position;
					}
					else
					{
						joinType = JoinType.Bevel;
					}
				}
				if (joinType == JoinType.Bevel)
				{
					if (num9 < ((Vector3)(ref val5)).magnitude / 2f && num9 < ((Vector3)(ref val6)).magnitude / 2f && num7 > MathF.PI / 6f)
					{
						if (num8 < 0f)
						{
							list[k][2].position = position;
							list[k + 1][1].position = position;
						}
						else
						{
							list[k][3].position = position2;
							list[k + 1][0].position = position2;
						}
					}
					UIVertex[] array = (UIVertex[])(object)new UIVertex[4]
					{
						list[k][2],
						list[k][3],
						list[k + 1][0],
						list[k + 1][1]
					};
					vh.AddUIVertexQuad(array);
				}
			}
			vh.AddUIVertexQuad(list[k]);
		}
		if (vh.currentVertCount > 64000)
		{
			Debug.LogError((object)("Max Verticies size is 64000, current mesh vertcies count is [" + vh.currentVertCount + "] - Cannot Draw"));
			vh.Clear();
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		if (m_points != null && m_points.Length != 0)
		{
			GeneratedUVs();
			vh.Clear();
			PopulateMesh(vh, m_points);
		}
		else if (m_segments != null && m_segments.Count > 0)
		{
			GeneratedUVs();
			vh.Clear();
			for (int i = 0; i < m_segments.Count; i++)
			{
				Vector2[] pointsToDraw = m_segments[i];
				PopulateMesh(vh, pointsToDraw);
			}
		}
	}

	private UIVertex[] CreateLineCap(Vector2 start, Vector2 end, SegmentType type)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val;
		switch (type)
		{
		case SegmentType.Start:
		{
			val = end - start;
			Vector2 start2 = start - ((Vector2)(ref val)).normalized * lineThickness / 2f;
			return CreateLineSegment(start2, start, SegmentType.Start);
		}
		case SegmentType.End:
		{
			val = end - start;
			Vector2 end2 = end + ((Vector2)(ref val)).normalized * lineThickness / 2f;
			return CreateLineSegment(end, end2, SegmentType.End);
		}
		default:
			Debug.LogError((object)"Bad SegmentType passed in to CreateLineCap. Must be SegmentType.Start or SegmentType.End");
			return null;
		}
	}

	private UIVertex[] CreateLineSegment(Vector2 start, Vector2 end, SegmentType type, UIVertex[] previousVert = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = new Vector2(start.y - end.y, end.x - start.x);
		Vector2 val2 = ((Vector2)(ref val)).normalized * lineThickness / 2f;
		Vector2 val3 = Vector2.zero;
		Vector2 val4 = Vector2.zero;
		if (previousVert != null)
		{
			((Vector2)(ref val3))..ctor(previousVert[3].position.x, previousVert[3].position.y);
			((Vector2)(ref val4))..ctor(previousVert[2].position.x, previousVert[2].position.y);
		}
		else
		{
			val3 = start - val2;
			val4 = start + val2;
		}
		Vector2 val5 = end + val2;
		Vector2 val6 = end - val2;
		return type switch
		{
			SegmentType.Start => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, startUvs), 
			SegmentType.End => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, endUvs), 
			SegmentType.Full => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, fullUvs), 
			_ => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, middleUvs), 
		};
	}

	protected override void GeneratedUVs()
	{
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)base.activeSprite != (Object)null)
		{
			Vector4 outerUV = DataUtility.GetOuterUV(base.activeSprite);
			Vector4 innerUV = DataUtility.GetInnerUV(base.activeSprite);
			UV_TOP_LEFT = new Vector2(outerUV.x, outerUV.y);
			UV_BOTTOM_LEFT = new Vector2(outerUV.x, outerUV.w);
			UV_TOP_CENTER_LEFT = new Vector2(innerUV.x, innerUV.y);
			UV_TOP_CENTER_RIGHT = new Vector2(innerUV.z, innerUV.y);
			UV_BOTTOM_CENTER_LEFT = new Vector2(innerUV.x, innerUV.w);
			UV_BOTTOM_CENTER_RIGHT = new Vector2(innerUV.z, innerUV.w);
			UV_TOP_RIGHT = new Vector2(outerUV.z, outerUV.y);
			UV_BOTTOM_RIGHT = new Vector2(outerUV.z, outerUV.w);
		}
		else
		{
			UV_TOP_LEFT = Vector2.zero;
			UV_BOTTOM_LEFT = new Vector2(0f, 1f);
			UV_TOP_CENTER_LEFT = new Vector2(0.5f, 0f);
			UV_TOP_CENTER_RIGHT = new Vector2(0.5f, 0f);
			UV_BOTTOM_CENTER_LEFT = new Vector2(0.5f, 1f);
			UV_BOTTOM_CENTER_RIGHT = new Vector2(0.5f, 1f);
			UV_TOP_RIGHT = new Vector2(1f, 0f);
			UV_BOTTOM_RIGHT = Vector2.one;
		}
		startUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_LEFT, UV_BOTTOM_LEFT, UV_BOTTOM_CENTER_LEFT, UV_TOP_CENTER_LEFT };
		middleUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_CENTER_LEFT, UV_BOTTOM_CENTER_LEFT, UV_BOTTOM_CENTER_RIGHT, UV_TOP_CENTER_RIGHT };
		endUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_CENTER_RIGHT, UV_BOTTOM_CENTER_RIGHT, UV_BOTTOM_RIGHT, UV_TOP_RIGHT };
		fullUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_LEFT, UV_BOTTOM_LEFT, UV_BOTTOM_RIGHT, UV_TOP_RIGHT };
	}

	protected override void ResolutionToNativeSize(float distance)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (base.UseNativeSize)
		{
			Rect rect = base.activeSprite.rect;
			m_Resolution = distance / (((Rect)(ref rect)).width / base.pixelsPerUnit);
			rect = base.activeSprite.rect;
			lineThickness = ((Rect)(ref rect)).height / base.pixelsPerUnit;
		}
	}

	private int GetSegmentPointCount()
	{
		List<Vector2[]> segments = Segments;
		if (segments != null && segments.Count > 0)
		{
			int num = 0;
			{
				foreach (Vector2[] segment in Segments)
				{
					num += segment.Length;
				}
				return num;
			}
		}
		return Points.Length;
	}

	public Vector2 GetPosition(int index, int segmentIndex = 0)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (segmentIndex > 0)
		{
			return Segments[segmentIndex - 1][index - 1];
		}
		if (Segments.Count > 0)
		{
			int num = 0;
			int num2 = index;
			foreach (Vector2[] segment in Segments)
			{
				if (num2 - segment.Length > 0)
				{
					num2 -= segment.Length;
					num++;
					continue;
				}
				break;
			}
			return Segments[num][num2 - 1];
		}
		return Points[index - 1];
	}

	public Vector2 GetPositionBySegment(int index, int segment)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		return Segments[segment][index - 1];
	}

	public Vector2 GetClosestPoint(Vector2 p1, Vector2 p2, Vector2 p3)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = p3 - p1;
		Vector2 val2 = p2 - p1;
		float num = Mathf.Clamp01(Vector2.Dot(val, ((Vector2)(ref val2)).normalized) / ((Vector2)(ref val2)).magnitude);
		return p1 + val2 * num;
	}
}


private enum SegmentType
{
	Start,
	Middle,
	End,
	Full
}


public enum JoinType
{
	Bevel,
	Miter
}


public enum BezierType
{
	None,
	Quick,
	Basic,
	Improved,
	Catenary
}


