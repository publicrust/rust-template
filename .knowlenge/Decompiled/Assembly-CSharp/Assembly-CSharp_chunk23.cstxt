using System;
using Network;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class TigerFSM : FSMComponent
{
	public State_PlayRandomAnimation randomIdle = new State_PlayRandomAnimation();

	public State_Roam roam = new State_Roam();

	public State_CircleDynamic approach = new State_CircleDynamic();

	public State_FastSneak fastSneak = new State_FastSneak();

	public State_Roar roar = new State_Roar();

	public State_Growl growlFire = new State_Growl();

	public State_MoveToTarget charge = new State_MoveToTarget();

	public State_Observe observe = new State_Observe();

	public State_DeadlyAttack attack = new State_DeadlyAttack();

	public State_Circle comboCircle = new State_Circle();

	public State_HurtWithAdditive hurt = new State_HurtWithAdditive();

	public State_FleeToHide flee = new State_FleeToHide();

	public State_Flee permaFlee = new State_Flee();

	public State_Dead dead = new State_Dead();

	public State_ApproachFood approachFood = new State_ApproachFood();

	public State_EatFood eatFood = new State_EatFood();

	public State_PlayAnimLoop sleep = new State_PlayAnimLoop();

	public State_AttackUnreachableWarped attackUnreachable = new State_AttackUnreachableWarped();

	public State_DragCorpse dragCorpse = new State_DragCorpse();

	private Trans_Triggerable_HitInfo HurtTrans;

	private Trans_Triggerable_HitInfo StaggerTrans;

	private Trans_Triggerable_HitInfo DeathTrans;

	[ServerVar(Help = "The range at which the tiger will charge instead of fleeing if aimed at")]
	public static float chargeRange = 20f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TigerFSM.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Expected O, but got Unknown
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Expected O, but got Unknown
		if (base.baseEntity.isServer)
		{
			State_Nothing state_Nothing = new State_Nothing
			{
				Name = "WaitForNavMesh"
			};
			new State_MoveToTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Walk,
				decelerationOverride = 6f,
				Name = "Step forward"
			};
			State_MoveToLastReachablePointNearTarget state_MoveToLastReachablePointNearTarget = new State_MoveToLastReachablePointNearTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Jog,
				succeedWhenDestinationIsReached = true,
				Name = "Go to last destination slow"
			};
			State_MoveToLastReachablePointNearTarget state_MoveToLastReachablePointNearTarget2 = new State_MoveToLastReachablePointNearTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Sprint,
				succeedWhenDestinationIsReached = true,
				Name = "Go to last destination"
			};
			DeathTrans = new Trans_Triggerable_HitInfo();
			HurtTrans = new Trans_Triggerable_HitInfo();
			StaggerTrans = new Trans_Triggerable_HitInfo();
			Trans_Triggerable FireMeleeTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<SenseComponent>().onFireMelee.AddListener((UnityAction)delegate
			{
				FireMeleeTrans.Trigger();
			});
			Trans_Triggerable EncounterEndTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<NPCEncounterTimer>().onShouldGiveUp.AddListener((UnityAction)delegate
			{
				EncounterEndTrans.Trigger();
			});
			State_Nothing obj = new State_Nothing
			{
				Name = "Root"
			};
			State_Nothing state_Nothing2 = new State_Nothing
			{
				Name = "Alive"
			};
			State_Nothing state_Nothing3 = new State_Nothing
			{
				Name = "OnNavmesh"
			};
			State_Nothing state_Nothing4 = new State_Nothing
			{
				Name = "Food"
			};
			State_Nothing state_Nothing5 = new State_Nothing
			{
				Name = "Roaming"
			};
			State_Nothing state_Nothing6 = new State_Nothing
			{
				Name = "Has target"
			};
			State_Nothing state_Nothing7 = new State_Nothing
			{
				Name = "Ready to strike"
			};
			State_Nothing state_Nothing8 = new State_Nothing
			{
				Name = "Not hurt"
			};
			State_Nothing state_Nothing9 = new State_Nothing
			{
				Name = "Random post idle wait"
			};
			Trans_And transition = new Trans_And
			{
				~new Trans_BlackboardCounterGte
				{
					Key = "AlreadyGrowled",
					MinValue = 2
				},
				new Trans_Cooldown
				{
					cooldown = 6f
				},
				new Trans_TargetIsNearFire
				{
					onlySeeFireWhenClose = true
				}
			};
			Trans_Or trans_Or = HurtTrans | new Trans_IsWatchedByTarget
			{
				requireAiming = true,
				minTime = 3f
			};
			Trans_Or trans_Or2 = HurtTrans | new Trans_IsWatchedByTarget
			{
				requireAiming = true,
				minTime = 0.5f
			};
			_ = obj + (state_Nothing2.AddTickTransition(dead, DeathTrans) + state_Nothing.AddTickTransition(roam, new Trans_IsNavmeshReady()) + (state_Nothing3.AddTickTransition(state_Nothing, ~new Trans_IsNavmeshReady()) + (state_Nothing8.AddTickTransition(hurt, StaggerTrans) + (state_Nothing5.AddTickTransition(approach, new Trans_HasTarget()).AddTickTransition(approachFood, new Trans_SeesFood()) + roam.AddEndTransition(sleep, new Trans_RandomChance
			{
				Chance = 0.25f
			}).AddFailureTransition(dead).AddEndTransition(randomIdle) + sleep.AddEndTransition(roam) + randomIdle.AddEndTransition(state_Nothing9) + state_Nothing9.AddTickTransition(roam, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 0.0,
				MaxDuration = 3.0
			})) + (state_Nothing6.AddTickTransition(roam, new Trans_HasTarget
			{
				Inverted = true
			}).AddTickTransition(permaFlee, EncounterEndTrans).AddTickTransition(permaFlee, new Trans_TargetIsInSafeZone())
				.AddTickTransition(permaFlee, new Trans_IsInWaterSlow() | new Trans_IsTargetInWater()) + (state_Nothing7.AddTickTransition(growlFire, transition).AddTickTransition(approachFood, new Trans_SeesFood() & ~new Trans_HasBlackboardBool
			{
				Key = "TriedToApproachUnreachableFood"
			}).AddTickTransition(charge, new Trans_TargetInRange
			{
				Range = 10f
			})
				.AddTickTransition(charge, new Trans_TargetInRange
				{
					Range = chargeRange
				} & trans_Or)
				.AddTickTransition(flee, ~new Trans_TargetInRange
				{
					Range = chargeRange
				} & trans_Or2) + approach.AddTickTransition(observe, new Trans_And
			{
				~new Trans_HasBlackboardBool
				{
					Key = "AlreadyGrowled"
				},
				new Trans_IsWatchedByTarget
				{
					requireAiming = false
				},
				~new Trans_TargetInRange
				{
					Range = 15f
				}
			}).AddTickTransition(fastSneak, ~new Trans_IsInTargetViewCone
			{
				angle = 70f
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget) + fastSneak.AddTickTransition(approach, new Trans_IsInTargetViewCone
			{
				angle = 60f
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget) + observe.AddTickTransition(approach, new Trans_IsWatchedByTarget
			{
				wantsWatched = false,
				requireAiming = false
			}).AddTickTransition(charge, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 8.0,
				MaxDuration = 12.0
			} & new Trans_TargetInRange
			{
				Range = chargeRange
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget)) + charge.AddTickTransition(attack, new Trans_TargetInRange
			{
				Range = attack.range
			}).AddTickTransition(approach, new Trans_ElapsedTime
			{
				Duration = 5.0
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget2) + attack.AddEndTransition(comboCircle, new Trans_IsTargetDown()).AddEndTransition(flee) + comboCircle.AddTickTransition(charge, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 0.75,
				MaxDuration = 1.5
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget2).AddEndTransition(charge) + growlFire.AddTickTransition(attack, new Trans_TargetInRange
			{
				Range = 2f
			}).AddEndTransition(approach) + state_MoveToLastReachablePointNearTarget.AddTickBranchingTrans(permaFlee, trans_Or2, state_MoveToLastReachablePointNearTarget2, new Trans_TargetInRange
			{
				Range = chargeRange
			}).AddTickTransition(permaFlee, FireMeleeTrans).AddTickTransition(approach, new Trans_CanReachTarget_Slow())
				.AddFailureTransition(permaFlee)
				.AddEndTransition(attackUnreachable) + state_MoveToLastReachablePointNearTarget2.AddTickTransition(permaFlee, FireMeleeTrans).AddTickTransition(charge, new Trans_CanReachTarget_Slow()).AddFailureTransition(permaFlee)
				.AddEndTransition(attackUnreachable) + flee.AddFailureTransition(dead).AddEndTransition(approach)) + (state_Nothing4.AddTickTransition(growlFire, transition).AddTickTransition(flee, trans_Or2) + approachFood.AddTickTransition(roam, ~new Trans_SeesFood()).AddTickTransition(charge, new Trans_TargetInRange
			{
				Range = 10f
			}).AddFailureTransition(roam)
				.AddEndTransition(eatFood) + eatFood.AddTickTransition(roam, ~new Trans_SeesFood()).AddTickTransition(dragCorpse, new Trans_TargetInRange
			{
				Range = 20f
			}).AddFailureTransition(roam)
				.AddEndTransition(roam) + dragCorpse.AddTickTransition(attack, new Trans_TargetInRange
			{
				Range = 3f
			}).AddTickTransition(permaFlee, new Trans_ElapsedTime
			{
				Duration = 1.0
			} & new Trans_TargetInRange
			{
				Range = 12f
			}).AddTickTransition(eatFood, ~new Trans_TargetInRange
			{
				Range = 30f
			})
				.AddFailureTransition(permaFlee)
				.AddEndTransition(permaFlee)) + permaFlee.AddFailureTransition(dead).AddEndTransition(roam)) + hurt.AddEndTransition(flee)) + attackUnreachable.AddFailureTransition(permaFlee).AddEndTransition(permaFlee, new Trans_HasBlackboardBool
			{
				Key = "HitDuringCharge"
			}).AddEndTransition(flee)) + dead;
			SetState(state_Nothing);
			Run();
		}
	}

	public override void Hurt(HitInfo hitInfo)
	{
		if (!((Component)this).GetComponent<SenseComponent>().CanTarget(hitInfo.Initiator))
		{
			return;
		}
		((Component)this).GetComponent<RootMotionPlayer>().PlayServerAdditive(hurt.WeakHitAdditive);
		if (base.CurrentState == roar || base.CurrentState == charge || base.CurrentState == attack || base.CurrentState == attackUnreachable)
		{
			((Component)this).GetComponent<BlackboardComponent>().Add("HitDuringCharge");
		}
		HurtTrans.Trigger(hitInfo);
		if (hurt.ShouldStagger(base.baseEntity, hitInfo))
		{
			StaggerTrans.Trigger(hitInfo);
			if (base.CurrentState != hurt && base.CurrentState != dead)
			{
				ForceTickOnTheNextUpdate();
			}
		}
	}

	public override bool OnDied(HitInfo hitInfo)
	{
		DeathTrans.Trigger(hitInfo);
		return false;
	}
}


using System;
using Network;
using Rust.Ai.Gen2;
using UnityEngine;

public class TigerSneakTelegraphGrowl : EntityComponent<BaseEntity>
{
	[SerializeField]
	private SoundDefinition growlSound;

	[ServerVar(Help = "Minimum angle for the tiger to growl when stalking a player")]
	public static float minAngle = 60f;

	[ServerVar(Help = "Time between growls when stalking a player")]
	public static float minTimeBetweenGrowls = 5f;

	private static readonly float[] growlDistances = new float[3] { 50f, 30f, 20f };

	private SenseComponent _senses;

	private double? lastGrowlTime;

	private BasePlayer targetPlayer;

	private int numGrowlsForCurrentPlayer;

	private SenseComponent Senses => _senses ?? (_senses = ((Component)this).GetComponent<SenseComponent>());

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TigerSneakTelegraphGrowl.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		if (base.baseEntity.isServer)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)Tick, 0f, 0.5f);
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.baseEntity.isServer)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)Tick);
			UpdateTarget(null);
		}
	}

	private void Tick()
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		Senses.FindTarget(out var target);
		UpdateTarget(target);
		if (!((Object)(object)targetPlayer == (Object)null) && (!lastGrowlTime.HasValue || !((double)Time.time - lastGrowlTime.Value < (double)minTimeBetweenGrowls)) && Senses.GetVisibilityStatus(target, out var status) && numGrowlsForCurrentPlayer < growlDistances.Length)
		{
			float num = growlDistances[numGrowlsForCurrentPlayer];
			if (!(Vector3.Distance(((Component)target).transform.position, ((Component)this).transform.position) > num) && !(status.timeNotWatched <= 0f) && !Trans_IsInTargetViewCone.IsInTargetViewCone(Senses, minAngle))
			{
				base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayTigerSneakTelegraphGrowl"));
				lastGrowlTime = Time.timeAsDouble;
				numGrowlsForCurrentPlayer++;
			}
		}
	}

	private void UpdateTarget(BaseEntity newTarget)
	{
		BasePlayer basePlayer = targetPlayer;
		targetPlayer = newTarget as BasePlayer;
		if ((Object)(object)basePlayer != (Object)(object)targetPlayer)
		{
			if (basePlayer.IsValid())
			{
				basePlayer.ClientRPC(RpcTarget.Player("CL_AddPredatorHuntingPlayer", basePlayer), arg1: false);
			}
			if (targetPlayer.IsValid())
			{
				targetPlayer.ClientRPC(RpcTarget.Player("CL_AddPredatorHuntingPlayer", targetPlayer), arg1: true);
			}
			lastGrowlTime = null;
			numGrowlsForCurrentPlayer = 0;
		}
	}
}


using Rust.Ai.Gen2;

public class Crocodile : BaseNPC2
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 1f;

	public override string Categorize()
	{
		return "Crocodile";
	}
}


using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class CrocodileFSM : FSMComponent
{
	public State_PlayRandomAnimation randomIdle = new State_PlayRandomAnimation();

	public State_Roam roam = new State_Roam();

	public State_CircleDynamic approach = new State_CircleDynamic();

	public State_CrocCharge charge = new State_CrocCharge();

	public State_CrocIntimidate intimidate = new State_CrocIntimidate();

	public State_CrocTurn intimidateTurn = new State_CrocTurn();

	public State_AttackWithTracking staticAttack = new State_AttackWithTracking();

	public State_AttackWithTracking bellyFlop = new State_AttackWithTracking();

	public State_AttackWithTracking intimidateSnap = new State_AttackWithTracking();

	public State_AttackWithTracking swimAttack = new State_AttackWithTracking();

	public State_GoBackToWater flee = new State_GoBackToWater();

	public State_HurtWithAdditive hurt = new State_HurtWithAdditive();

	public State_Dead dead = new State_Dead();

	public State_ApproachFood approachFood = new State_ApproachFood();

	public State_BringFoodBackToWater bringFoodBackToWater = new State_BringFoodBackToWater();

	public State_TryAmbushUnderwater diveRoam = new State_TryAmbushUnderwater();

	private Trans_Triggerable_HitInfo HurtTrans;

	private Trans_Triggerable_HitInfo DeathTrans;

	public override void InitShared()
	{
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Expected O, but got Unknown
		if (base.baseEntity.isServer)
		{
			State_Nothing state_Nothing = new State_Nothing
			{
				Name = "WaitForNavMesh"
			};
			State_MoveToBreakFoundation state_MoveToBreakFoundation = new State_MoveToBreakFoundation
			{
				Name = "MoveToFoundation",
				speed = LimitedTurnNavAgent.Speeds.Run,
				accelerationOverride = charge.accelerationOverride,
				decelerationOverride = charge.decelerationOverride,
				stopAtDestination = true,
				succeedWhenDestinationIsReached = true
			};
			State_CrocBreakFoundation state_CrocBreakFoundation = new State_CrocBreakFoundation
			{
				Name = "BreakFoundation",
				Animation = bellyFlop.Animation,
				DamageType = bellyFlop.DamageType,
				damageDelay = bellyFlop.damageDelay,
				damage = bellyFlop.damage,
				radius = 3f,
				trackingDuration = bellyFlop.trackingDuration,
				trackingSpeed = 360f,
				forceScale = bellyFlop.forceScale,
				doesStrafeDodge = false
			};
			DeathTrans = new Trans_Triggerable_HitInfo();
			HurtTrans = new Trans_Triggerable_HitInfo();
			Trans_Triggerable EncounterEndTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<NPCEncounterTimer>().onShouldGiveUp.AddListener((UnityAction)delegate
			{
				EncounterEndTrans.Trigger();
			});
			Trans_IsSwimming trans_IsSwimming = new Trans_IsSwimming();
			FSMTransitionBase fSMTransitionBase = ~new Trans_IsSwimming();
			FSMTransitionBase dstState2Trans = ~(new Trans_TargetInRange
			{
				Range = 30f
			} | trans_IsSwimming | new Trans_IsTargetInWater());
			Trans_CrocHasStraightPathToTarget trans_CrocHasStraightPathToTarget = new Trans_CrocHasStraightPathToTarget();
			State_Nothing obj = new State_Nothing
			{
				Name = "Root"
			};
			State_Nothing state_Nothing2 = new State_Nothing
			{
				Name = "Alive"
			};
			State_Nothing state_Nothing3 = new State_Nothing
			{
				Name = "Reachable"
			};
			State_Nothing state_Nothing4 = new State_Nothing
			{
				Name = "OnNavmesh"
			};
			new State_Nothing().Name = "Food";
			State_Nothing state_Nothing5 = new State_Nothing
			{
				Name = "Roaming"
			};
			State_Nothing state_Nothing6 = new State_Nothing
			{
				Name = "Has target"
			};
			State_Nothing state_Nothing7 = new State_Nothing
			{
				Name = "Random post idle wait"
			};
			_ = obj + (state_Nothing2.AddTickTransition(dead, DeathTrans) + state_Nothing.AddTickTransition(roam, new Trans_IsNavmeshReady()) + state_Nothing4.AddTickTransition(state_Nothing, ~new Trans_IsNavmeshReady()) + (state_Nothing5.AddTickBranchingTrans(charge, new Trans_HasTarget(), flee, dstState2Trans).AddTickTransition(approachFood, new Trans_SeesFood()) + roam.AddFailureTransition(dead).AddEndTransition(randomIdle, fSMTransitionBase).AddEndTransition(state_Nothing7) + randomIdle.AddEndTransition(state_Nothing7) + state_Nothing7.AddTickTransition(roam, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 7.0,
				MaxDuration = 14.0
			})) + (state_Nothing6.AddTickTransition(roam, ~new Trans_HasTarget()).AddTickTransition(flee, EncounterEndTrans).AddTickTransition(flee, new Trans_TargetIsInSafeZone())
				.AddTickTransition(flee, new Trans_IsTargetProtectedByMount()) + (state_Nothing3.AddTickTransition(flee, new Trans_Cooldown
			{
				cooldown = 30f
			} & new Trans_IsTargetTooFarFromWater()) + charge.AddTickTransition(flee, fSMTransitionBase & new Trans_ElapsedTime
			{
				Duration = 15.0
			} & ~new Trans_TargetInRange
			{
				Range = 15f
			}).AddTickTransition(bellyFlop, fSMTransitionBase & new Trans_Cooldown
			{
				cooldown = 6f
			} & new Trans_TargetInFront
			{
				Angle = 45f
			} & new Trans_TargetInRange
			{
				Range = 5f,
				TimeToPredict = 0.46f
			} & trans_CrocHasStraightPathToTarget).AddTickTransition(intimidateTurn, fSMTransitionBase & new Trans_Cooldown
			{
				cooldown = 5f
			} & ~new Trans_TargetInFront
			{
				Angle = 80f
			} & new Trans_TargetInRange
			{
				Range = 5f
			} & trans_CrocHasStraightPathToTarget)
				.AddTickTransition(staticAttack, fSMTransitionBase & new Trans_TargetInRange
				{
					Range = 2f,
					TimeToPredict = 0.5f
				} & trans_CrocHasStraightPathToTarget)
				.AddTickTransition(swimAttack, trans_IsSwimming & new Trans_TargetInRange
				{
					Range = 5.65f,
					TimeToPredict = 0.85f
				} & trans_CrocHasStraightPathToTarget)
				.AddFailureTransition(state_MoveToBreakFoundation) + intimidate.AddTickTransition(charge, HurtTrans).AddTickTransition(charge, new Trans_ElapsedTime
			{
				Duration = 0.25
			} & new Trans_TargetInRange
			{
				Range = 4f
			}).AddTickTransition(charge, new Trans_ElapsedTime
			{
				Duration = 1.5
			} & new Trans_TargetInRange
			{
				Range = 6f
			})
				.AddTickBranchingTrans(charge, ~new Trans_TargetInFront
				{
					Angle = 70f
				}, intimidateTurn, new Trans_Cooldown
				{
					cooldown = 5f
				})
				.AddEndTransition(charge)) + state_MoveToBreakFoundation.AddTickTransition(charge, new Trans_CanReachTarget_Slow()).AddFailureTransition(flee).AddEndTransition(state_CrocBreakFoundation)) + approachFood.AddTickBranchingTrans(charge, HurtTrans, flee, dstState2Trans).AddTickTransition(charge, new Trans_TargetInRange
			{
				Range = 8f
			}).AddTickTransition(roam, ~new Trans_SeesFood())
				.AddFailureTransition(roam)
				.AddEndTransition(bringFoodBackToWater) + bringFoodBackToWater.AddTickBranchingTrans(charge, HurtTrans, flee, dstState2Trans).AddTickTransition(charge, new Trans_TargetInRange
			{
				Range = 8f
			}).AddFailureTransition(roam)
				.AddEndTransition(roam) + bellyFlop.AddEndTransition(intimidateTurn, fSMTransitionBase & ~new Trans_TargetInFront
			{
				Angle = 30f
			}).AddEndTransition(intimidateSnap, fSMTransitionBase).AddEndTransition(charge) + state_CrocBreakFoundation.AddEndTransition(charge) + swimAttack.AddEndTransition(charge) + staticAttack.AddEndTransition(intimidateSnap) + intimidateSnap.AddEndTransition(intimidate) + intimidateTurn.AddEndTransition(intimidateSnap, new Trans_TargetInRange
			{
				Range = 6f
			}).AddEndTransition(charge) + flee.AddTickTransition(intimidate, fSMTransitionBase & new Trans_ElapsedTime
			{
				Duration = 3.0
			} & new Trans_TargetInRange
			{
				Range = 8f
			}).AddTickTransition(diveRoam, trans_IsSwimming).AddFailureTransition(dead)
				.AddEndTransition(diveRoam) + diveRoam.AddTickTransition(charge, ~new Trans_IsTargetProtectedByMount() & (new Trans_IsTargetInWater() | (new Trans_TargetInRange
			{
				Range = 8f
			} & new Trans_IsTargetOnNavmesh_Slow()))).AddTickTransition(roam, ~new Trans_TargetInRange
			{
				Range = 50f
			}).AddFailureTransition(dead) + dead);
			SetState(state_Nothing);
			Run();
		}
	}

	public override void Hurt(HitInfo hitInfo)
	{
		if (((Component)this).GetComponent<SenseComponent>().CanTarget(hitInfo.Initiator))
		{
			((Component)this).GetComponent<RootMotionPlayer>().PlayServerAdditive(hurt.WeakHitAdditive);
			HurtTrans.Trigger(hitInfo);
			if (base.CurrentState == approach || base.CurrentState == approachFood || base.CurrentState == bringFoodBackToWater || base.CurrentState == intimidate)
			{
				ForceTickOnTheNextUpdate();
			}
		}
	}

	public override bool OnDied(HitInfo hitInfo)
	{
		DeathTrans.Trigger(hitInfo);
		return false;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_LandOrSwimAttack : State_Attack
{
	public RootMotionData swimAttack;

	protected override RootMotionData GetAnimation()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (WaterLevel.GetWaterDepth(((Component)Owner).transform.position, waves: false, volumes: false) > 0f)
		{
			return swimAttack;
		}
		return Animation;
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_CrocIntimidate : FSMStateBase
{
	private float remainingDuration;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		if (Owner is BaseCombatEntity baseCombatEntity)
		{
			remainingDuration = Mathx.RemapValClamped(baseCombatEntity.healthFraction, 1f, 0.3f, 5f, 0f);
			if (remainingDuration == 0f)
			{
				return EFSMStateStatus.Success;
			}
			return result;
		}
		return EFSMStateStatus.Failure;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (remainingDuration > 0f)
		{
			remainingDuration -= deltaTime;
			if (remainingDuration <= 0f)
			{
				return EFSMStateStatus.Success;
			}
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_CrocTurn : State_PlayAnimationRM
{
	[SerializeField]
	public RootMotionData turn90L;

	[SerializeField]
	public RootMotionData turn90R;

	[SerializeField]
	public RootMotionData turn180;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 val = targetPosition - ((Component)Owner).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		float num = Vector3.SignedAngle(((Component)Owner).transform.forward, normalized, Vector3.up);
		if (Mathf.Abs(num) > 130f)
		{
			Animation = turn180;
		}
		else if (num > 0f)
		{
			Animation = turn90R;
		}
		else
		{
			Animation = turn90L;
		}
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_CrocCharge : State_MoveToTarget
{
	private const float maxChargeDuration = 6f;

	private float remainingChargeDuration;

	private Action _reallowChargingAction;

	private Action _surpriseAction;

	private Action _resetSurpriseAction;

	private double nextSurpriseTime;

	private Action ReallowChargingAction => ResetStamina;

	private Action SurpriseAction => Surprise;

	private Action ResetSurpriseAction => ResetSurprise;

	public override EFSMStateStatus OnStateEnter()
	{
		ResetStamina();
		ResetSurprise();
		return base.OnStateEnter();
	}

	private void ResetStamina()
	{
		remainingChargeDuration = 6f;
	}

	private void ResetSurprise()
	{
		float num = Random.Range(3f, 6f);
		((FacepunchBehaviour)Owner).Invoke(SurpriseAction, num);
		((FacepunchBehaviour)Owner).Invoke(ResetSurpriseAction, num + Random.Range(3f, 6f));
	}

	private void Surprise()
	{
		nextSurpriseTime = Time.timeAsDouble + (double)Random.Range(3f, 6f);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		if (Owner is BaseCombatEntity baseCombatEntity)
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return EFSMStateStatus.Success;
			}
			base.Agent.acceleration.Value = accelerationOverride;
			float num = Mathx.RemapValClamped(baseCombatEntity.healthFraction, 1f, 0.3f, 0f, 1f);
			bool flag = false;
			BasePlayer player;
			if (base.Agent.IsSwimming)
			{
				flag = true;
				base.Agent.acceleration.Value = 2.5f;
				num = 1f;
			}
			else if (baseCombatEntity.lastAttackedTime > 0f && Time.time < baseCombatEntity.lastAttackedTime + 0.5f)
			{
				flag = true;
				num = 1f;
			}
			else if (Time.timeAsDouble > nextSurpriseTime && Time.timeAsDouble < nextSurpriseTime + 0.5)
			{
				num = 1f;
			}
			else if (base.Agent.RemainingDistance < 4f)
			{
				flag = true;
				num = 1f;
			}
			else if (target.ToNonNpcPlayer(out player) && player.modelState.sprinting)
			{
				Vector3 estimatedVelocity = player.estimatedVelocity;
				if (Vector3.Dot(((Vector3)(ref estimatedVelocity)).normalized, ((Component)Owner).transform.forward) > 0.5f)
				{
					base.Agent.acceleration.Value = 2f;
					num = 1f;
				}
			}
			if (!flag && num >= 1f)
			{
				float num2 = remainingChargeDuration;
				remainingChargeDuration -= deltaTime;
				if (num2 > 0f && remainingChargeDuration <= 0f)
				{
					((FacepunchBehaviour)Owner).Invoke(ReallowChargingAction, 6f);
				}
			}
			if (!flag && remainingChargeDuration <= 0f)
			{
				num = Mathf.Min(num, 0.3f);
			}
			base.Agent.SetSpeedRatio(num, speed, LimitedTurnNavAgent.Speeds.FullSprint);
			if (base.Senses.GetVisibilityStatus(target, out var status) && status.isInWaterCached)
			{
				base.Agent.desiredSwimDepth.Value = Mathf.Max(base.Agent.desiredSwimDepth.DefaultValue, status.lastWaterInfo.Value.currentDepth + 1f);
			}
		}
		return base.OnStateUpdate(deltaTime);
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		destination = default(Vector3);
		if (!base.Senses.FindTarget(out var target))
		{
			return false;
		}
		if (target.IsNonNpcPlayer() && base.Agent.canSwim && base.Senses.GetVisibilityStatus(target, out var status) && status.isInWaterCached)
		{
			destination = Vector3Ex.WithY(((Component)target).transform.position, status.lastWaterInfo.Value.terrainHeight);
			return true;
		}
		return base.GetMoveDestination(out destination);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_GoBackToWater : State_MoveToTarget
{
	private Vector3 nearestWaterPoint;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		if (base.Agent.IsSwimming)
		{
			return EFSMStateStatus.Success;
		}
		TimeWarning val = TimeWarning.New("State_GoBackToWater GetCoarseVectorToShore and GetHeight", 0);
		try
		{
			(Vector3 shoreDir, float shoreDist) coarseVectorToShore = TerrainTexturing.Instance.GetCoarseVectorToShore(((Component)Owner).transform.position);
			Vector3 item = coarseVectorToShore.shoreDir;
			float item2 = coarseVectorToShore.shoreDist;
			Vector3 val2 = item * item2;
			Vector3 val3 = ((Component)Owner).transform.position + ((Vector3)(ref val2)).normalized * (((Vector3)(ref val2)).magnitude + 10f);
			val3.y = TerrainMeta.HeightMap.GetHeight(val3);
			PooledList<Vector3> val4 = Pool.Get<PooledList<Vector3>>();
			try
			{
				Eqs.SamplePositionsInDonutShape(val3, (List<Vector3>)(object)val4);
				ListEx.Shuffle<Vector3>((List<Vector3>)(object)val4, (uint)Environment.TickCount);
				nearestWaterPoint = val3;
				foreach (Vector3 item3 in (List<Vector3>)(object)val4)
				{
					if (base.Agent.SamplePosition(item3, out var sample, 10f) && base.Agent.IsInWater(sample))
					{
						nearestWaterPoint = sample;
						break;
					}
				}
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnStateEnter();
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		destination = nearestWaterPoint;
		return true;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_BringFoodBackToWater : State_GoBackToWater
{
	private BaseCorpse corpse;

	private Action _updateCorpsePositionAction;

	private Action UpdateCorpsePositionAction => OnStateFixedUpdate;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (!(food is BaseCorpse baseCorpse))
		{
			return EFSMStateStatus.Failure;
		}
		if (!SingletonComponent<NpcFoodManager>.Instance.Remove(baseCorpse))
		{
			return EFSMStateStatus.Failure;
		}
		((Component)Owner).transform.forward = Vector3Ex.NormalizeXZ(((Component)baseCorpse).transform.position - ((Component)Owner).transform.position);
		corpse = baseCorpse;
		corpse.SetFlag(BaseEntity.Flags.Reserved3, b: true);
		((FacepunchBehaviour)Owner).InvokeRepeatingFixedTime(UpdateCorpsePositionAction);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!corpse.IsValid() || corpse.IsDead())
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}

	private void OnStateFixedUpdate()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (corpse.IsValid() && !corpse.IsDead())
		{
			Rigidbody component = ((Component)corpse).GetComponent<Rigidbody>();
			if (component != null)
			{
				component.MovePosition(((Component)Owner).transform.position + ((Component)Owner).transform.forward * 1.6f + ((Component)Owner).transform.up * 0.6f);
				component.velocity = Vector3.zero;
				component.angularVelocity = Vector3.zero;
			}
		}
	}

	public override void OnStateExit()
	{
		base.OnStateExit();
		if (corpse.IsValid())
		{
			corpse.SetFlag(BaseEntity.Flags.Reserved3, b: false);
		}
		((FacepunchBehaviour)Owner).CancelInvokeFixedTime(UpdateCorpsePositionAction);
		corpse = null;
	}
}


using System;
using ConVar;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_AttackWithTracking : State_PlayAnimationRM
{
	public DamageType DamageType = DamageType.Bite;

	public float damageDelay = 0.5f;

	public float damage = 30f;

	public float forceScale = 1f;

	public float trackingSpeed = 90f;

	public float trackingDuration = 9999f;

	public float radius = 4f;

	public bool doesStrafeDodge;

	private Action _doDamageAction;

	private static readonly Vector3 force = new Vector3(15f, 3f, 15f);

	private double startTime;

	private Action DoDamageAction => _doDamageAction ?? (_doDamageAction = DoDamage);

	public override EFSMStateStatus OnStateEnter()
	{
		FaceTarget = false;
		startTime = Time.timeAsDouble;
		((FacepunchBehaviour)Owner).Invoke(DoDamageAction, damageDelay + AI.defaultInterpolationDelay);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (trackingDuration > 0f && trackingSpeed > 0f && Time.timeAsDouble - startTime < (double)(trackingDuration + AI.defaultInterpolationDelay) && base.Senses.FindTarget(out var target))
		{
			base.AnimPlayer.Track(((Component)target).transform.position, trackingSpeed, null);
		}
		return base.OnStateUpdate(deltaTime);
	}

	protected virtual void DoDamage()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !(target is BaseCombatEntity baseCombatEntity))
		{
			return;
		}
		if (baseCombatEntity.ToNonNpcPlayer(out var player) && doesStrafeDodge)
		{
			Vector3 estimatedVelocity = player.estimatedVelocity;
			if (Mathf.Abs(Vector3.Dot(((Vector3)(ref estimatedVelocity)).normalized, ((Component)Owner).transform.right)) > 0.7f)
			{
				return;
			}
		}
		if (base.Senses.GetVisibilityStatus(target, out var status) && status.timeNotVisible < 1f && Vector3.Distance(((Component)Owner).transform.position, ((Component)baseCombatEntity).transform.position) < radius)
		{
			baseCombatEntity.OnAttacked(damage, DamageType, Owner, ignoreShield: false);
			if (forceScale > 0f && (Object)(object)player != (Object)null)
			{
				Vector3 val = ((Vector3.Dot(((Component)Owner).transform.right, Vector3Ex.NormalizeXZ(((Component)player).transform.position - ((Component)Owner).transform.position)) > 0f) ? ((Component)Owner).transform.right : (-((Component)Owner).transform.right));
				player.DoPush((((Component)Owner).transform.forward * force.z + val * force.x + Vector3.up * force.y) * forceScale);
			}
		}
	}

	public override void OnStateExit()
	{
		((FacepunchBehaviour)Owner).CancelInvoke(DoDamageAction);
		base.OnStateExit();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_MoveToBreakFoundation : State_CrocCharge
{
	private const float maxHorizontalDist = 10f;

	private Vector3 attackLocation;

	private bool FindReachableLocation(out Vector3 location)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		location = default(Vector3);
		if (!base.Senses.FindTarget(out var target) || !target.ToNonNpcPlayer(out var player))
		{
			return false;
		}
		Vector3 position = ((Component)target).transform.position;
		if (Vector3.Distance(((Component)Owner).transform.position, position) > 50f)
		{
			return false;
		}
		if (((Object)(object)State_CrocBreakFoundation.FindNearestTwigFoundationOnTargetBuilding(base.Agent, player, null)).Is<BuildingBlock>(out BuildingBlock entAsT) && base.Agent.SamplePosition(entAsT.ClosestPoint(((Component)Owner).transform.position), out var sample, 10f))
		{
			location = sample;
			return true;
		}
		if (base.Agent.SamplePosition(position, out var sample2, 3f))
		{
			location = sample2;
			return true;
		}
		return false;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !target.ToNonNpcPlayer(out var _))
		{
			return EFSMStateStatus.Failure;
		}
		if (!FindReachableLocation(out attackLocation))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 val = attackLocation + ((Bounds)(ref Owner.bounds)).extents.y * Vector3.up;
		Vector3 val2 = target.CenterPoint() - val;
		if (GamePhysics.Trace(new Ray(val, val2), 0f, out var _, ((Vector3)(ref val2)).magnitude, 1503731969, (QueryTriggerInteraction)0))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		destination = attackLocation;
		return true;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_CrocBreakFoundation : State_AttackWithTracking
{
	public const float attackRange = 3f;

	private static bool FindBuildingBlockNearby(LimitedTurnNavAgent agent, Vector3 position, out BuildingBlock buildingBlock)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (agent.SampleGroundPositionWithPhysics(position, out var hitInfo, 2f, BasePlayer.GetRadius(), 2097152) && hitInfo.GetEntity() is BuildingBlock buildingBlock2)
		{
			buildingBlock = buildingBlock2;
			return true;
		}
		PooledList<BuildingBlock> val = Pool.Get<PooledList<BuildingBlock>>();
		try
		{
			Vis.Entities(position, 4f, (List<BuildingBlock>)(object)val, 2097152, (QueryTriggerInteraction)2);
			if (((List<BuildingBlock>)(object)val).Count > 0)
			{
				buildingBlock = ((List<BuildingBlock>)(object)val)[0];
				return true;
			}
			buildingBlock = null;
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static BuildingBlock FindNearestTwigFoundationOnTargetBuilding(LimitedTurnNavAgent agent, BasePlayer targetPlayer, float? maxDistance = null)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (!FindBuildingBlockNearby(agent, ((Component)targetPlayer).transform.position, out var buildingBlock))
		{
			return null;
		}
		BuildingManager.Building building = BuildingManager.server.GetBuilding(buildingBlock.buildingID);
		BuildingBlock result = null;
		float num = float.MaxValue;
		Enumerator<BuildingBlock> enumerator = building.buildingBlocks.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BuildingBlock current = enumerator.Current;
				if (current.grade == BuildingGrade.Enum.Twigs && (Object)(object)current.parentEntity.Get(serverside: true) == (Object)null && (current.ShortPrefabName == "foundation" || current.ShortPrefabName == "foundation.triangle"))
				{
					float num2 = current.Distance(((Component)agent).transform.position);
					if ((!maxDistance.HasValue || !(num2 > maxDistance.Value)) && num2 < num)
					{
						result = current;
						num = num2;
					}
				}
			}
			return result;
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	protected override void DoDamage()
	{
		if (base.Senses.FindTarget(out var target) && target.ToNonNpcPlayer(out var player))
		{
			BuildingBlock buildingBlock = FindNearestTwigFoundationOnTargetBuilding(base.Agent, player, null);
			if ((Object)(object)buildingBlock == (Object)null)
			{
				base.DoDamage();
			}
			else
			{
				buildingBlock.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_TryAmbushUnderwater : FSMStateBase
{
	[SerializeField]
	private Vector2 distanceRange = new Vector2(10f, 20f);

	[SerializeField]
	private float maxDistFromDivingPoint = 50f;

	private const float desiredDepth = 3f;

	private Vector3 divePosition;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		base.Agent.desiredSwimDepth.Value = 3f;
		divePosition = ((Component)Owner).transform.position;
		return FindNewUnderwaterWaitingPosition();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Agent.IsFollowingPath)
		{
			return FindNewUnderwaterWaitingPosition();
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.Agent.desiredSwimDepth.Reset();
		base.OnStateExit();
	}

	private EFSMStateStatus FindNewUnderwaterWaitingPosition()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			float radius = Random.Range(distanceRange.x, distanceRange.y);
			Eqs.SamplePositionsInDonutShape(base.Agent.NavPosition, (List<Vector3>)(object)val, radius);
			if (Vector3.Distance(divePosition, ((Component)Owner).transform.position) > maxDistFromDivingPoint)
			{
				Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
				try
				{
					Vector3 val2 = divePosition - ((Component)Owner).transform.position;
					Vector3 normalized = ((Vector3)(ref val2)).normalized;
					foreach (Vector3 item2 in (List<Vector3>)(object)val)
					{
						val2 = item2 - ((Component)Owner).transform.position;
						float item = Vector3.Dot(normalized, ((Vector3)(ref val2)).normalized);
						((List<(Vector3, float)>)(object)pooledScoreList).Add((item2, item));
					}
					pooledScoreList.SortByScoreDesc(Owner);
					pooledScoreList.Reorder((List<Vector3>)(object)val);
				}
				finally
				{
					((IDisposable)(object)pooledScoreList)?.Dispose();
				}
			}
			else
			{
				ListEx.Shuffle<Vector3>((List<Vector3>)(object)val, (uint)Environment.TickCount);
			}
			foreach (Vector3 item3 in (List<Vector3>)(object)val)
			{
				if (base.Agent.SamplePosition(item3, out var sample, 10f) && base.Agent.IsInWater(sample) && base.Agent.SetDestination(sample))
				{
					base.Agent.SetSpeed((!base.Agent.IsSwimming) ? LimitedTurnNavAgent.Speeds.Run : LimitedTurnNavAgent.Speeds.Sneak);
					return EFSMStateStatus.None;
				}
			}
			return EFSMStateStatus.Failure;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_TooFarFromWater : FSMTransitionBase
{
	public float maxDistance = 20f;

	protected override bool EvaluateInternal()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TooFarFromWater", 0);
		try
		{
			return TerrainTexturing.Instance.GetCoarseDistanceToShore(((Component)Owner).transform.position) < 0f - maxDistance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_IsTargetTooFarFromWater : FSMTransitionBase
{
	public float maxDistance = 30f;

	protected override bool EvaluateInternal()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_IsTargetTooFarFromWater", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			return TerrainTexturing.Instance.GetCoarseDistanceToShore(targetPosition) < 0f - maxDistance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
internal class Trans_CrocHasStraightPathToTarget : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_CrocHasStraightPathToTarget", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			Vector3 targetPosition = ((Component)target).transform.position;
			if (target.IsNonNpcPlayer() && base.Agent.canSwim && base.Senses.GetVisibilityStatus(target, out var status) && status.isInWaterCached)
			{
				targetPosition = Vector3Ex.WithY(((Component)target).transform.position, status.lastWaterInfo.Value.terrainHeight);
			}
			NavMeshHit hitInfo;
			return !base.Agent.Raycast(targetPosition, out hitInfo);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsTargetProtectedByMount : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsTargetProtectedByMount", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target) || !target.ToNonNpcPlayer(out var player))
			{
				return false;
			}
			BaseMountable entAsT;
			return ((Object)(object)player.GetMounted()).Is<BaseMountable>(out entAsT) && entAsT.ProtectsFromAnimals;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

public class ClawMarkSpawner : EntityComponent<BaseEntity>, IServerComponent
{
	public GameObjectRef clawDecal;

	public float radius = 130f;

	public float height = 1.8f;

	public float minTreeRadius = 1.4f;

	[Range(0f, 1f)]
	public float ratioOfTreesMarked = 0.5f;

	private static bool showClawMarks;

	private List<ClawMark> clawMarks = new List<ClawMark>();

	[ServerVar]
	public static void ShowClawMarks(Arg arg)
	{
		bool @bool = arg.GetBool(0, !showClawMarks);
		if (@bool == showClawMarks)
		{
			arg.ReplyWith("Claw marks are already " + (showClawMarks ? "visible" : "hidden") + ".");
			return;
		}
		showClawMarks = @bool;
		BaseNPC2[] array;
		if (showClawMarks)
		{
			array = BaseEntity.Util.FindAll<BaseNPC2>();
			for (int i = 0; i < array.Length; i++)
			{
				ClawMarkSpawner component = ((Component)array[i]).GetComponent<ClawMarkSpawner>();
				if ((Object)(object)component != (Object)null)
				{
					component.SpawnClawMarks();
				}
			}
			arg.ReplyWith("Claw marks are now visible.");
			return;
		}
		array = BaseEntity.Util.FindAll<BaseNPC2>();
		for (int i = 0; i < array.Length; i++)
		{
			ClawMarkSpawner component2 = ((Component)array[i]).GetComponent<ClawMarkSpawner>();
			if ((Object)(object)component2 != (Object)null)
			{
				component2.ClearClawMarks();
			}
		}
		arg.ReplyWith("Claw marks are now hidden.");
	}

	public override void InitShared()
	{
		UpdateBaseEntity();
		if (showClawMarks)
		{
			SpawnClawMarks();
		}
	}

	public override void DestroyShared()
	{
		ClearClawMarks();
	}

	private void SpawnClawMarks()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		if (!base.baseEntity.isServer)
		{
			return;
		}
		if (AI.logIssues && clawMarks.Count > 0)
		{
			Debug.LogWarning((object)$"Claw marks already spawned for {base.baseEntity}.");
			return;
		}
		PooledList<TreeEntity> val = Pool.Get<PooledList<TreeEntity>>();
		try
		{
			BaseEntity.Query.Server.GetInSphere(((Component)base.baseEntity).transform.position, radius, (List<TreeEntity>)(object)val);
			clawMarks.Capacity = ((List<TreeEntity>)(object)val).Count;
			RaycastHit val3 = default(RaycastHit);
			foreach (TreeEntity item in (List<TreeEntity>)(object)val)
			{
				if (Random.value > ratioOfTreesMarked || (Object)(object)item.serverCollider == (Object)null)
				{
					continue;
				}
				float num = Mathf.Min(((Bounds)(ref item.bounds)).extents.x, ((Bounds)(ref item.bounds)).extents.z);
				if (num < minTreeRadius)
				{
					continue;
				}
				Vector3 val2 = ((Component)item).transform.position + Vector3.up * height;
				Vector3 forward = ((Component)item).transform.forward;
				if (!item.serverCollider.Raycast(new Ray(val2 - forward * num, forward), ref val3, num))
				{
					continue;
				}
				ClawMark clawMark = GameManager.server.CreateEntity(clawDecal.resourcePath, ((RaycastHit)(ref val3)).point, Quaternion.LookRotation(-((RaycastHit)(ref val3)).normal)) as ClawMark;
				if ((Object)(object)clawMark == (Object)null)
				{
					if (AI.logIssues)
					{
						Debug.LogWarning((object)$"Failed to create claw mark for {base.baseEntity}.");
					}
				}
				else
				{
					clawMarks.Add(clawMark);
					clawMark.SetParent(item, worldPositionStays: true);
					clawMark.Spawn();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ClearClawMarks()
	{
		if (!base.baseEntity.isServer)
		{
			return;
		}
		foreach (ClawMark clawMark in clawMarks)
		{
			clawMark.Kill();
		}
		clawMarks.Clear();
	}
}


using Rust.Ai.Gen2;

[SoftRequireComponent(typeof(TigerFSM))]
public class Panther : BaseNPC2
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 0.5f;

	public override string Categorize()
	{
		return "Panther";
	}
}


using Rust.Ai.Gen2;

[SoftRequireComponent(typeof(TigerFSM))]
public class Tiger : BaseNPC2
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 0.5f;

	public override string Categorize()
	{
		return "Tiger";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_HurtWithAdditive : State_Hurt
{
	public AnimationClip WeakHitAdditive;
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_Roar : State_PlayAnimation
{
	public const string AlreadyRoared = "AlreadyRoared";

	public override EFSMStateStatus OnStateEnter()
	{
		if (!base.Senses.FindTarget(out var _))
		{
			return EFSMStateStatus.Failure;
		}
		base.Blackboard.Add("AlreadyRoared");
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_DeadlyAttack : State_Attack
{
	public float range = 4f;

	public SoundDefinition impactSound;

	private static readonly Vector3 force = new Vector3(15f, 3f, 15f);

	protected override void DoDamage()
	{
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !(target is BaseCombatEntity baseCombatEntity))
		{
			return;
		}
		float amount = Damage;
		if (target.IsNonNpcPlayer())
		{
			float num = baseCombatEntity.baseProtection.Get(DamageType);
			float num2 = (1f - num) * 1.2f;
			float num3 = Damage * num2;
			if (num == 0f && baseCombatEntity.health >= 30f && num3 > baseCombatEntity.health)
			{
				amount = (baseCombatEntity.health - 1f) * (1f / num2);
			}
		}
		baseCombatEntity.OnAttacked(amount, DamageType, Owner, ignoreShield: false);
		Owner.ClientRPC(RpcTarget.NetworkGroup("RPC_PlayNPCAttackImpactSound"));
		if (baseCombatEntity.ToNonNpcPlayer(out var player))
		{
			Vector3 val = ((Vector3.Dot(((Component)Owner).transform.right, Vector3Ex.NormalizeXZ(((Component)player).transform.position - ((Component)Owner).transform.position)) > 0f) ? ((Component)Owner).transform.right : (-((Component)Owner).transform.right));
			player.DoPush(((Component)Owner).transform.forward * force.z + val * force.x + Vector3.up * force.y);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_FleeToHide : State_Flee
{
	public const string HitDuringChargeKey = "HitDuringCharge";

	private bool clockWise;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		base.Blackboard.Remove("HitDuringCharge");
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		Vector3 val = Vector3Ex.NormalizeXZ(targetPosition - ((Component)Owner).transform.position);
		clockWise = Vector3.Dot(((Component)Owner).transform.right, val) > 0f;
		return base.OnStateEnter();
	}

	protected override EFSMStateStatus MoveAwayFromTarget()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		Vector3 val = ((Component)Owner).transform.position - targetPosition;
		float magnitude = ((Vector3)(ref val)).magnitude;
		Vector3 val2 = ((Component)Owner).transform.forward;
		float num = 15f;
		if (magnitude > 6f)
		{
			val2 = Vector3Ex.NormalizeXZ(((Component)Owner).transform.position - targetPosition);
			num = 55f;
		}
		val2 = Quaternion.AngleAxis(num * (clockWise ? 1f : (-1f)), Vector3.up) * val2;
		PooledList<Vector3> val3 = Pool.Get<PooledList<Vector3>>();
		try
		{
			Eqs.SamplePositionsInDonutShape(base.Agent.NavPosition, (List<Vector3>)(object)val3, distance);
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				foreach (Vector3 item3 in (List<Vector3>)(object)val3)
				{
					Vector3 val4 = val2;
					Vector3 val5 = item3 - ((Component)Owner).transform.position;
					float item = Vector3.Dot(val4, ((Vector3)(ref val5)).normalized);
					((List<(Vector3, float)>)(object)pooledScoreList).Add((item3, item));
				}
				pooledScoreList.SortByScoreDesc(Owner);
				foreach (var item4 in (List<(Vector3, float)>)(object)pooledScoreList)
				{
					Vector3 item2 = item4.Item1;
					if (base.Agent.SamplePosition(item2, out var sample, 10f) && (base.Agent.canSwim || !base.Agent.IsInWater(sample)) && base.Agent.SetDestination(sample))
					{
						return EFSMStateStatus.None;
					}
				}
				return EFSMStateStatus.Failure;
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val3)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Observe : State_MoveToTarget
{
	private double startTime;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus eFSMStateStatus = base.OnStateEnter();
		if (eFSMStateStatus == EFSMStateStatus.Failure)
		{
			return eFSMStateStatus;
		}
		succeedWhenDestinationIsReached = false;
		stopAtDestination = false;
		base.Agent.deceleration.Value = 0.1f;
		base.Agent.SetSpeed(0f);
		startTime = Time.timeAsDouble;
		base.Agent.currentDeviation = 2f;
		return eFSMStateStatus;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (Time.timeAsDouble - startTime > 6.0)
		{
			base.Agent.SetSpeed(0.2f);
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_AttackUnreachableWarped : FSMStateBase
{
	private enum Phase
	{
		PreJump,
		Jump,
		Attack,
		JumpBack,
		PostJumpBack
	}

	public float jumpOnStart = 1.03f;

	public float jumpOnEnd = 1.63f;

	public float jumpOffStart = 2.9f;

	public float jumpOffEnd = 3.47f;

	public float totalDuration = 3.6f;

	private const float groundCheckDistance = 2f;

	private const float damage = 35f;

	private const float meleeAttackRange = 1.7f;

	private const DamageType damageType = DamageType.Bite;

	public RootMotionData animClip;

	private float elapsedTime;

	private LockState.LockHandle targetLock;

	private LockState.LockHandle movementLock;

	private Phase phase;

	private RootMotionPlayer.Warp[] warps = new RootMotionPlayer.Warp[2];

	private RootMotionPlayer.PlayServerState animState;

	private Vector3 destination;

	private bool didHit;

	public static bool SampleGroundPositionUnderTarget(LimitedTurnNavAgent agent, BasePlayer targetAsPlayer, out Vector3 projectedLocation)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (targetAsPlayer.IsOnGround() && !targetAsPlayer.OnLadder())
		{
			projectedLocation = ((Component)targetAsPlayer).transform.position;
			return true;
		}
		float radius = BasePlayer.GetRadius();
		RaycastHit hitInfo;
		bool result = agent.SampleGroundPositionWithPhysics(((Component)targetAsPlayer).transform.position, out hitInfo, 2f, radius * 0.5f);
		projectedLocation = ((RaycastHit)(ref hitInfo)).point;
		return result;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer targetAsPlayer))
		{
			return EFSMStateStatus.Failure;
		}
		destination = ((Component)target).transform.position;
		if (!SampleGroundPositionUnderTarget(base.Agent, targetAsPlayer, out destination))
		{
			return EFSMStateStatus.Failure;
		}
		if (!State_MoveToLastReachablePointNearTarget.CanJumpFromPosToPos(Owner, ((Component)Owner).transform.position, destination))
		{
			return EFSMStateStatus.Failure;
		}
		movementLock = base.Agent.Pause();
		didHit = false;
		elapsedTime = 0f;
		targetLock = base.Senses.LockCurrentTarget();
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = false;
		animState = RootMotionPlayer.PlayServerState.TakeFromPool(animClip, ((Component)Owner).transform);
		animState.warps = warps;
		animState.constrainToNavmesh = false;
		base.AnimPlayer.PlayServer(animState);
		SetPhase(Phase.PreJump);
		return base.OnStateEnter();
	}

	private EFSMStateStatus SetPhase(Phase newPhase)
	{
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_032a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		phase = newPhase;
		if (phase == Phase.Jump)
		{
			if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer targetAsPlayer))
			{
				return EFSMStateStatus.Failure;
			}
			if (SampleGroundPositionUnderTarget(base.Agent, targetAsPlayer, out var projectedLocation))
			{
				destination = projectedLocation;
			}
			Vector3 position = ((Component)Owner).transform.position;
			animState.initialRotation = Quaternion.LookRotation(Vector3Ex.WithY(destination - ((Component)Owner).transform.position, 0f));
			((Component)Owner).transform.rotation = animState.initialRotation;
			float num = animClip.zMotionCurve.Evaluate(jumpOnEnd) - animClip.zMotionCurve.Evaluate(jumpOnStart);
			float num2 = animClip.yMotionCurve.Evaluate(jumpOnEnd) - animClip.yMotionCurve.Evaluate(jumpOnStart);
			RootMotionPlayer.Warp warp = new RootMotionPlayer.Warp(jumpOnStart, jumpOnEnd, Vector3.one);
			warp.translationScale.z = Vector3.Distance(Vector3Ex.WithY(destination, 0f), Vector3Ex.WithY(position, 0f)) / num;
			warp.translationScale.y = (destination.y - position.y) / num2;
			warps[0] = warp;
			float num3 = animClip.zMotionCurve.Evaluate(jumpOffStart) - animClip.zMotionCurve.Evaluate(jumpOffEnd);
			float num4 = animClip.yMotionCurve.Evaluate(jumpOffStart) - animClip.yMotionCurve.Evaluate(jumpOffEnd);
			RootMotionPlayer.Warp warp2 = new RootMotionPlayer.Warp(jumpOffStart, jumpOffEnd, Vector3.one);
			warp2.translationScale.z = Vector3.Distance(Vector3Ex.WithY(destination, 0f), Vector3Ex.WithY(position, 0f)) / num3;
			warp2.translationScale.y = (destination.y - position.y) / num4;
			warps[1] = warp2;
			base.Agent.IsJumping = true;
		}
		else if (phase == Phase.Attack)
		{
			if (base.Senses.FindTarget(out var target2))
			{
				if (target2 is BaseCombatEntity baseCombatEntity && Vector3.Distance(((Component)Owner).transform.position, ((Component)baseCombatEntity).transform.position) <= 1.7f)
				{
					didHit = true;
					baseCombatEntity.OnAttacked(35f, DamageType.Bite, Owner, ignoreShield: false);
				}
				if (target2 is BasePlayer basePlayer && Vector3.Distance(((Component)Owner).transform.position, ((Component)basePlayer).transform.position) <= 1f)
				{
					basePlayer.DoPush(((Component)Owner).transform.forward * 10f + Vector3.up * 3f);
				}
			}
		}
		else if (phase == Phase.PostJumpBack)
		{
			base.Agent.IsJumping = false;
		}
		return EFSMStateStatus.None;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		elapsedTime += deltaTime;
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		if (phase == Phase.PreJump)
		{
			Quaternion val = Quaternion.LookRotation(Vector3Ex.WithY(targetPosition - ((Component)Owner).transform.position, 0f));
			animState.initialRotation = Quaternion.RotateTowards(animState.initialRotation, val, Time.deltaTime * 60f);
			((Component)Owner).transform.rotation = animState.initialRotation;
			if (elapsedTime >= jumpOnStart && SetPhase(Phase.Jump) == EFSMStateStatus.Failure)
			{
				return EFSMStateStatus.Failure;
			}
		}
		if (phase == Phase.Jump && elapsedTime >= jumpOnEnd)
		{
			SetPhase(Phase.Attack);
		}
		if (phase == Phase.Attack && elapsedTime > jumpOffStart)
		{
			SetPhase(Phase.JumpBack);
		}
		if (phase == Phase.JumpBack && elapsedTime >= jumpOffEnd)
		{
			SetPhase(Phase.PostJumpBack);
		}
		if (elapsedTime >= animClip.inPlaceAnimation.length - 0.25f)
		{
			if (!didHit)
			{
				return EFSMStateStatus.Failure;
			}
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = true;
		base.Senses.UnlockTarget(ref targetLock);
		base.Agent.Unpause(ref movementLock);
		if (phase != Phase.PostJumpBack)
		{
			base.Agent.IsJumping = false;
		}
		base.OnStateExit();
	}
}


private enum Phase
{
	PreJump,
	Jump,
	Attack,
	JumpBack,
	PostJumpBack
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_DragCorpse : FSMStateBase
{
	[SerializeField]
	protected RootMotionData Animation;

	private const int numLoops = 6;

	private int currentLoop;

	private BaseCorpse corpse;

	private RootMotionPlayer.PlayServerState animState;

	private Action _updateCorpsePositionAction;

	private Action UpdateCorpsePositionAction => OnStateFixedUpdate;

	public override EFSMStateStatus OnStateEnter()
	{
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (!(food is BaseCorpse food2))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Senses.FindTarget(out var _))
		{
			return EFSMStateStatus.Failure;
		}
		if (!SingletonComponent<NpcFoodManager>.Instance.Remove(food2))
		{
			return EFSMStateStatus.Failure;
		}
		corpse = food2;
		corpse.SetFlag(BaseEntity.Flags.Reserved3, b: true);
		((FacepunchBehaviour)Owner).InvokeRepeatingFixedTime(UpdateCorpsePositionAction);
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (!corpse.IsValid() || corpse.IsDead())
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		if (animState != null)
		{
			Quaternion val = Quaternion.LookRotation(Vector3Ex.WithY(targetPosition - ((Component)Owner).transform.position, 0f));
			animState.initialRotation = Quaternion.RotateTowards(animState.initialRotation, val, Time.deltaTime * 60f);
			((Component)Owner).transform.rotation = animState.initialRotation;
		}
		if (!animState.isPlaying)
		{
			currentLoop++;
			if (currentLoop >= 6)
			{
				return EFSMStateStatus.Success;
			}
			base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
			animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
		}
		return base.OnStateUpdate(deltaTime);
	}

	private void OnStateFixedUpdate()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (corpse.IsValid() && !corpse.IsDead())
		{
			Rigidbody component = ((Component)corpse).GetComponent<Rigidbody>();
			if (component != null)
			{
				component.MovePosition(((Component)Owner).transform.position + ((Component)Owner).transform.forward * 1.6f + ((Component)Owner).transform.up * 0.6f);
				component.velocity = Vector3.zero;
				component.angularVelocity = Vector3.zero;
			}
		}
	}

	public override void OnStateExit()
	{
		base.OnStateExit();
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
		currentLoop = 0;
		if (corpse.IsValid())
		{
			SingletonComponent<NpcFoodManager>.Instance.Add(corpse);
			corpse.SetFlag(BaseEntity.Flags.Reserved3, b: false);
		}
		corpse = null;
		((FacepunchBehaviour)Owner).CancelInvokeFixedTime(UpdateCorpsePositionAction);
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_FastSneak : State_CircleDynamic
{
	public override EFSMStateStatus OnStateEnter()
	{
		base.Agent.deceleration.Value = 10f;
		return base.OnStateEnter();
	}

	protected override void SetSpeed(BaseEntity target, float distToTarget, float normalizedDist)
	{
		if (!target.ToNonNpcPlayer(out var player))
		{
			base.SetSpeed(target, distToTarget, normalizedDist);
		}
		else if (distToTarget > 50f)
		{
			base.Agent.SetSpeed(8.25f);
		}
		else if (player.modelState.sprinting && distToTarget < 20f)
		{
			base.Agent.SetSpeed(6.875f);
		}
		else if (player.modelState.sprinting)
		{
			base.Agent.SetSpeed(8.25f);
		}
		else if (player.modelState.ducked || player.estimatedSpeed < 0.1f)
		{
			base.Agent.SetSpeed(1.7f);
		}
		else
		{
			base.Agent.SetSpeed(3.5f);
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_IsTargetDown : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		if (!base.Senses.FindTarget(out var target))
		{
			return false;
		}
		if (!target.ToNonNpcPlayer(out var player))
		{
			return false;
		}
		return player.IsWounded();
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_IsWatchedByTarget : FSMTransitionBase
{
	public float minTime = 1.5f;

	public bool requireAiming = true;

	public bool wantsWatched = true;

	protected override bool EvaluateInternal()
	{
		if (!base.Senses.FindTarget(out var target))
		{
			return false;
		}
		if (!base.Senses.GetVisibilityStatus(target, out var status))
		{
			return false;
		}
		return ((!wantsWatched) ? (requireAiming ? status.timeNotAimedAt : status.timeNotWatched) : (requireAiming ? status.timeAimedAt : status.timeWatched)) > minTime;
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_IsTargetVisible : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		if (!base.Senses.FindTarget(out var target))
		{
			return false;
		}
		if (!base.Senses.GetVisibilityStatus(target, out var status))
		{
			return false;
		}
		return status.isVisible;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_IsInTargetViewCone : FSMTransitionBase
{
	public float angle = 90f;

	protected override bool EvaluateInternal()
	{
		return IsInTargetViewCone(base.Senses, angle);
	}

	public static bool IsInTargetViewCone(SenseComponent senses, float testAngle)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (!senses.FindTarget(out var target))
		{
			return false;
		}
		Vector3 val = ((Component)senses.GetBaseEntity()).transform.position - ((Component)target).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = (target.ToNonNpcPlayer(out var player) ? player.eyes.BodyForward() : ((Component)target).transform.forward);
		return Vector3.Dot(((Vector3)(ref val)).normalized, normalized) > Mathf.Cos(testAngle * (MathF.PI / 180f));
	}

	public override string ToString()
	{
		if (!Inverted)
		{
			return $"We are in target view cone of {angle} degrees";
		}
		return $"We are not in target view cone of {angle} degrees";
	}
}


using Rust.Ai.Gen2;

[SoftRequireComponent(typeof(Wolf2FSM))]
public class Wolf2 : BaseNPC2
{
	public override string Categorize()
	{
		return "Wolf";
	}
}


public static class NPCRangeConstants
{
	public const float MeleeRange = 2f;

	public const float CloseRange = 10f;

	public const float MediumRange = 16f;

	public const float LongRange = 50f;
}


public static class FireConstants
{
	public const float fireCirclingRadius = 16f;

	public const string HitByFire = "HitByFire";
}


using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class Wolf2FSM : FSMComponent
{
	public State_PlayRandomAnimation randomIdle = new State_PlayRandomAnimation();

	public State_Roam roam = new State_Roam();

	public State_Howl howl = new State_Howl();

	public State_CircleDynamic approach = new State_CircleDynamic();

	public State_Bark bark = new State_Bark();

	public State_Growl growlFire = new State_Growl();

	public State_ApproachFire approachFire = new State_ApproachFire();

	public State_FleeFire fleeFire = new State_FleeFire();

	public State_MoveToTarget charge = new State_MoveToTarget();

	public State_Attack attack = new State_Attack();

	public State_PlayAnimationRM leapAway = new State_PlayAnimationRM();

	public State_Circle reacCircle = new State_Circle();

	public State_CircleDynamic fastApproach = new State_CircleDynamic();

	public State_WolfHurt hurt = new State_WolfHurt();

	public State_Intimidated intimidated = new State_Intimidated();

	public State_Flee flee = new State_Flee();

	public State_Flee fleeForHowl = new State_Flee();

	public State_Dead dead = new State_Dead();

	public State_ApproachFood approachFood = new State_ApproachFood();

	public State_EatFood eatFood = new State_EatFood();

	public State_PlayAnimationRM growlFood = new State_PlayAnimationRM();

	public State_PlayAnimLoop sleep = new State_PlayAnimLoop();

	public State_AttackUnreachable attackUnreachable = new State_AttackUnreachable();

	private Trans_Triggerable_HitInfo HurtTrans;

	private Trans_Triggerable_HitInfo DeathTrans;

	private Trans_Triggerable<BaseEntity> AllyGotHurtNearby;

	private Trans_Triggerable<BaseEntity> HowlTrans;

	private Trans_Triggerable<BaseEntity> BarkTrans;

	public override void InitShared()
	{
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Expected O, but got Unknown
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Expected O, but got Unknown
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Expected O, but got Unknown
		if (base.baseEntity.isServer)
		{
			State_Nothing state_Nothing = new State_Nothing
			{
				Name = "WaitForNavMesh"
			};
			State_Circle state_Circle = new State_Circle
			{
				radius = 2f,
				speed = LimitedTurnNavAgent.Speeds.Sprint,
				Name = "Combo circle"
			};
			State_MoveToTarget state_MoveToTarget = new State_MoveToTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Walk,
				decelerationOverride = 6f,
				Name = "Step forward"
			};
			State_MoveToLastReachablePointNearTarget state_MoveToLastReachablePointNearTarget = new State_MoveToLastReachablePointNearTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Sprint,
				succeedWhenDestinationIsReached = true,
				Name = "Go to last destination"
			};
			FSMStateBase fSMStateBase = leapAway.Clone();
			fSMStateBase.Name = "Leap away unreachable";
			State_Flee state_Flee = new State_Flee
			{
				distance = 8f,
				desiredDistance = 16f,
				Name = "Flee fire after attack"
			};
			FSMStateBase fSMStateBase2 = state_Circle.Clone();
			fSMStateBase2.Name = "Circle short fire";
			FSMStateBase fSMStateBase3 = charge.Clone();
			fSMStateBase3.Name = "Charge fire";
			FSMStateBase fSMStateBase4 = attack.Clone();
			fSMStateBase4.Name = "Attack fire";
			DeathTrans = new Trans_Triggerable_HitInfo();
			HurtTrans = new Trans_Triggerable_HitInfo();
			Trans_Triggerable PathFailedTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>().onPathFailed.AddListener((UnityAction)delegate
			{
				PathFailedTrans.Trigger();
			});
			Trans_Triggerable FireMeleeTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<SenseComponent>().onFireMelee.AddListener((UnityAction)delegate
			{
				FireMeleeTrans.Trigger();
			});
			Trans_Triggerable EncounterEndTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<NPCEncounterTimer>().onShouldGiveUp.AddListener((UnityAction)delegate
			{
				EncounterEndTrans.Trigger();
			});
			BarkTrans = new Trans_Triggerable<BaseEntity>();
			AllyGotHurtNearby = new Trans_Triggerable<BaseEntity>();
			HowlTrans = new Trans_Triggerable<BaseEntity>();
			State_Nothing state_Nothing2 = new State_Nothing();
			state_Nothing2.Name = "Root";
			State_Nothing state_Nothing3 = new State_Nothing
			{
				Name = "Alive"
			};
			State_Nothing state_Nothing4 = new State_Nothing
			{
				Name = "OnNavmesh"
			};
			State_Nothing state_Nothing5 = new State_Nothing
			{
				Name = "Food"
			};
			State_Nothing state_Nothing6 = new State_Nothing
			{
				Name = "Roaming"
			};
			State_Nothing state_Nothing7 = new State_Nothing
			{
				Name = "Has target"
			};
			State_Nothing state_Nothing8 = new State_Nothing
			{
				Name = "Not hurt"
			};
			State_Nothing state_Nothing9 = new State_Nothing
			{
				Name = "No fire"
			};
			State_Nothing state_Nothing10 = new State_Nothing
			{
				Name = "Reachable"
			};
			State_Nothing state_Nothing11 = new State_Nothing
			{
				Name = "Unreachable"
			};
			State_Nothing state_Nothing12 = new State_Nothing
			{
				Name = "Fire"
			};
			State_Nothing state_Nothing13 = new State_Nothing
			{
				Name = "Fire melee reac"
			};
			State_Nothing state_Nothing14 = new State_Nothing
			{
				Name = "Ready to help"
			};
			State_Nothing state_Nothing15 = new State_Nothing
			{
				Name = "Fire entry"
			};
			State_Nothing state_Nothing16 = new State_Nothing
			{
				Name = "Combat entry"
			};
			State_Nothing state_Nothing17 = new State_Nothing
			{
				Name = "Random post idle wait"
			};
			state_Nothing2.AddChildren(state_Nothing3.AddTickTransition(dead, DeathTrans).AddChildren(state_Nothing.AddTickTransition(roam, new Trans_IsNavmeshReady()), state_Nothing4.AddTickTransition(state_Nothing, new Trans_IsNavmeshReady
			{
				Inverted = true
			}).AddChildren(state_Nothing8.AddTickTransition(hurt, HurtTrans).AddChildren(state_Nothing6.AddTickTransition(dead, PathFailedTrans).AddTickTransition(approach, HowlTrans).AddTickTransition(state_Nothing16, new Trans_HasTarget())
				.AddTickTransition(approachFood, new Trans_SeesFood())
				.AddChildren(roam.AddEndTransition(sleep, new Trans_RandomChance
				{
					Chance = 0.25f
				}).AddEndTransition(randomIdle), sleep.AddEndTransition(roam), randomIdle.AddEndTransition(state_Nothing17), state_Nothing17.AddTickTransition(roam, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 0.0,
					MaxDuration = 3.0
				})), state_Nothing7.AddTickTransition(roam, new Trans_HasTarget
			{
				Inverted = true
			}).AddTickTransition(flee, EncounterEndTrans).AddTickTransition(flee, new Trans_TargetIsInSafeZone())
				.AddChildren(state_Nothing10.AddTickTransition(flee, new Trans_IsInWaterSlow() | new Trans_IsTargetInWater()).AddTickTransition(state_MoveToLastReachablePointNearTarget, PathFailedTrans).AddChildren(state_Nothing9.AddTickTransition(state_Nothing15, new Trans_TargetIsNearFire
				{
					onlySeeFireWhenClose = true
				}).AddChildren(state_Nothing16.AddTickTransition(howl, new Trans_HasBlackboardBool
				{
					Key = "WolfNearbyAlreadyHowled",
					Inverted = true
				}).AddTickTransition(approach, new Trans_AlwaysValid()), state_Nothing14.AddTickTransition(flee, new Trans_And
				{
					AllyGotHurtNearby,
					new Trans_TargetIsNearFire()
				}).AddTickTransition(fastApproach, AllyGotHurtNearby).AddTickTransition(charge, BarkTrans)
					.AddChildren(howl.AddTickTransition(approach, new Trans_TargetInRange
					{
						Range = 12f
					}).AddEndTransition(approach), approach.AddTickBranchingTrans(charge, new Trans_TargetInRange
					{
						Range = 12f
					}, bark, new Trans_HasBlackboardBool
					{
						Key = "WolfNearbyAlreadyBarked",
						Inverted = true
					}).AddTickTransition(approachFood, new Trans_And
					{
						new Trans_SeesFood(),
						new Trans_HasBlackboardBool
						{
							Key = "TriedToApproachUnreachableFood",
							Inverted = true
						}
					})), bark.AddTickTransition(charge, new Trans_TargetInRange
				{
					Range = 2f
				}).AddEndTransition(charge), charge.AddTickTransition(fastApproach, AllyGotHurtNearby).AddTickTransition(attack, new Trans_TargetInRange
				{
					Range = 2f
				}).AddTickTransition(approach, new Trans_ElapsedTime
				{
					Duration = 5.0
				})
					.AddFailureTransition(state_MoveToLastReachablePointNearTarget), attack.AddEndTransition(leapAway, new Trans_TargetInFront
				{
					Angle = 120f,
					Inverted = true
				}).AddEndTransition(state_Circle), leapAway.AddEndTransition(state_Circle), state_Circle.AddTickTransition(charge, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 0.75,
					MaxDuration = 1.5
				}).AddEndTransition(charge), reacCircle.AddTickTransition(reacCircle, AllyGotHurtNearby).AddTickTransition(charge, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 2.0,
					MaxDuration = 4.0
				}).AddEndTransition(charge), fastApproach.AddTickTransition(reacCircle, new Trans_TargetInRange
				{
					Range = reacCircle.radius + 5f
				}).AddTickTransition(charge, BarkTrans), fleeForHowl.AddEndTransition(howl)), state_Nothing12.AddTickTransition(flee, PathFailedTrans).AddTickTransition(flee, AllyGotHurtNearby).AddChildren(state_Nothing15.AddTickTransition(intimidated, new Trans_TargetInRange
				{
					Range = 12f
				}).AddTickTransition(growlFire, new Trans_HasBlackboardBool
				{
					Key = "AlreadyGrowled",
					Inverted = true
				}).AddTickTransition(approachFire, new Trans_AlwaysValid()), state_Nothing13.AddTickBranchingTrans(intimidated, FireMeleeTrans, growlFire, new Trans_RandomChance
				{
					Chance = 0.75f
				}).AddChildren(approachFire.AddTickTransition(fSMStateBase2, new Trans_TargetInRange
				{
					Range = 5f
				}).AddTickTransition(fastApproach, new Trans_TargetIsNearFire
				{
					Inverted = true
				}).AddTickTransition(fastApproach, new Trans_TargetInRange
				{
					Range = 21f,
					Inverted = true
				}), state_MoveToTarget.AddTickTransition(fSMStateBase2, new Trans_TargetInRange
				{
					Range = 5f
				}).AddTickTransition(approachFire, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 1.0,
					MaxDuration = 3.0
				})), growlFire.AddTickTransition(intimidated, FireMeleeTrans).AddTickTransition(fSMStateBase2, new Trans_TargetInRange
				{
					Range = 5f
				}).AddEndTransition(approachFire), fSMStateBase2.AddTickTransition(fSMStateBase3, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 0.5,
					MaxDuration = 1.25
				}).AddEndTransition(fSMStateBase3), fSMStateBase3.AddTickTransition(fSMStateBase4, new Trans_TargetInRange
				{
					Range = 2f
				}), fSMStateBase4.AddEndTransition(state_Flee), intimidated.AddEndTransition(fleeFire), fleeFire.AddEndTransition(state_MoveToTarget), state_Flee.AddEndTransition(state_MoveToTarget))), state_Nothing11.AddChildren(state_MoveToLastReachablePointNearTarget.AddFailureTransition(flee).AddTickTransition(flee, FireMeleeTrans).AddTickTransition(charge, new Trans_CanReachTarget_Slow())
					.AddEndTransition(charge, new Trans_CanReachTarget_Slow())
					.AddEndTransition(attackUnreachable)
					.AddEndTransition(flee), fSMStateBase.AddEndTransition(state_MoveToLastReachablePointNearTarget)), flee.AddTickTransition(dead, PathFailedTrans).AddEndTransition(fastApproach, new Trans_TargetInRange
				{
					Range = flee.desiredDistance
				}).AddEndTransition(roam)), state_Nothing5.AddTickTransition(state_Nothing15, new Trans_TargetIsNearFire
			{
				onlySeeFireWhenClose = true
			}).AddTickTransition(approach, HowlTrans).AddTickTransition(fastApproach, AllyGotHurtNearby)
				.AddTickTransition(charge, BarkTrans)
				.AddTickTransition(roam, new Trans_SeesFood
				{
					Inverted = true
				})
				.AddChildren(approachFood.AddTickTransition(growlFood, new Trans_TargetInRange
				{
					Range = 12f
				}).AddFailureTransition(roam).AddEndTransition(eatFood), eatFood.AddTickTransition(growlFood, new Trans_TargetInRange
				{
					Range = 12f
				}).AddFailureTransition(roam).AddEndTransition(roam), growlFood.AddTickTransition(bark, new Trans_TargetInRange
				{
					Range = 5f
				}).AddEndTransition(bark, new Trans_TargetInRange
				{
					Range = 12f
				}).AddEndTransition(approachFood))), hurt.AddEndTransition(flee, new Trans_IsHealthBelowPercentage()).AddEndTransition(flee, new Trans_HasBlackboardBool
			{
				Key = "HitByFire"
			}).AddEndTransition(flee, new Trans_TargetIsNearFire())
				.AddEndTransition(flee, new Trans_TargetInRange
				{
					Range = 50f,
					Inverted = true
				})
				.AddEndTransition(fleeForHowl, new Trans_InitialAlliesNotFighting())
				.AddEndTransition(charge, new Trans_And
				{
					new Trans_RandomChance
					{
						Chance = 0.5f
					},
					new Trans_TargetInRange
					{
						Range = 12f
					}
				})
				.AddEndTransition(reacCircle, new Trans_TargetInRange
				{
					Range = reacCircle.radius + 5f
				})
				.AddEndTransition(fastApproach)), attackUnreachable.AddFailureTransition(flee).AddEndTransition(flee, new Trans_TargetIsNearFire()).AddEndTransition(fSMStateBase)), dead);
			SetState(state_Nothing);
			Run();
		}
	}

	public override void Hurt(HitInfo hitInfo)
	{
		if (((Component)this).GetComponent<SenseComponent>().CanTarget(hitInfo.Initiator) && (hitInfo.Initiator.IsNonNpcPlayer() || !(Random.value > 0.5f)))
		{
			HurtTrans.Trigger(hitInfo);
			if (base.CurrentState != hurt && base.CurrentState != dead)
			{
				ForceTickOnTheNextUpdate();
			}
		}
	}

	public void Intimidate(BaseEntity target)
	{
		AllyGotHurtNearby.Trigger(target);
	}

	public void Howl(BaseEntity target)
	{
		HowlTrans.Trigger(target);
	}

	public void Bark(BaseEntity target)
	{
		BarkTrans.Trigger(target);
	}

	public override bool OnDied(HitInfo hitInfo)
	{
		DeathTrans.Trigger(hitInfo);
		return false;
	}
}


using Facepunch;
using Rust.Ai.Gen2;

public class Trans_Triggerable_HitInfo : Trans_Triggerable
{
	private HitInfo HitInfo;

	public virtual void Trigger(HitInfo hitInfo)
	{
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
		HitInfo = Pool.Get<HitInfo>();
		HitInfo.CopyFrom(hitInfo);
		Trigger();
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		if (base.Triggered && to is IParametrized<HitInfo> parametrized)
		{
			parametrized.SetParameter(HitInfo);
		}
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
[SoftRequireComponent(typeof(LimitedTurnNavAgent), typeof(SenseComponent), typeof(BlackboardComponent))]
public class State_ApproachFood : State_MoveToTarget
{
	public const string TriedToApproachUnreachableFood = "TriedToApproachUnreachableFood";

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (food.WaterFactor() > 0f || !base.Agent.CanReach(((Component)food).transform.position))
		{
			base.Blackboard.Add("TriedToApproachUnreachableFood");
			SingletonComponent<NpcFoodManager>.Instance.Remove(food);
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			destination = Vector3.zero;
			return false;
		}
		destination = ((Component)food).transform.position;
		return true;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
[SoftRequireComponent(typeof(RootMotionPlayer))]
public class State_EatFood : FSMStateBase
{
	[SerializeField]
	protected AnimationClip Animation;

	private const float damageToCorpsesPerLoop = 2.5f;

	private const float timeToForgetSightingWhileEating = 5f;

	private RootMotionPlayer.PlayServerState animState;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 val = ((Component)food).transform.position - ((Component)Owner).transform.position;
		val.y = 0f;
		((Component)Owner).transform.rotation = Quaternion.LookRotation(val);
		base.Senses.timeToForgetSightings.Value = 5f;
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (!animState.isPlaying)
		{
			if (food is BaseCorpse baseCorpse)
			{
				baseCorpse.Hurt(2.5f);
				if (baseCorpse.IsDead())
				{
					base.Senses.ClearTarget();
					return EFSMStateStatus.Success;
				}
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
			}
			else if (food is DroppedItem droppedItem)
			{
				droppedItem.item.amount = Mathf.FloorToInt((float)droppedItem.item.amount * 0.5f);
				if (droppedItem.item.amount <= 0)
				{
					droppedItem.DestroyItem();
					droppedItem.Kill();
					base.Senses.ClearTarget();
					return EFSMStateStatus.Success;
				}
				droppedItem.item.MarkDirty();
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
			}
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Senses.timeToForgetSightings.Reset();
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Flee : FSMStateBase
{
	[SerializeField]
	public float desiredDistance = 50f;

	[SerializeField]
	public float distance = 20f;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds speed = LimitedTurnNavAgent.Speeds.Sprint;

	[SerializeField]
	private int maxAttempts = 3;

	private int attempts;

	protected float startDistance;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		base.Blackboard.Remove("HitByFire");
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		attempts = 0;
		base.Agent.SetSpeed(speed);
		base.Agent.shouldStopAtDestination = false;
		startDistance = Vector3.Distance(((Component)Owner).transform.position, targetPosition);
		return MoveAwayFromTarget();
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (base.Agent.IsFollowingPath)
		{
			return base.OnStateUpdate(deltaTime);
		}
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		if (Vector3.Distance(targetPosition, ((Component)Owner).transform.position) > desiredDistance + startDistance)
		{
			return EFSMStateStatus.Success;
		}
		attempts++;
		if (attempts >= maxAttempts)
		{
			return EFSMStateStatus.Success;
		}
		return MoveAwayFromTarget();
	}

	protected virtual EFSMStateStatus MoveAwayFromTarget()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			Eqs.SamplePositionsInDonutShape(base.Agent.NavPosition, (List<Vector3>)(object)val, distance);
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				Vector3 val2 = Vector3Ex.NormalizeXZ(((Component)Owner).transform.position - targetPosition);
				foreach (Vector3 item3 in (List<Vector3>)(object)val)
				{
					Vector3 val3 = item3 - ((Component)Owner).transform.position;
					float item = Vector3.Dot(val2, ((Vector3)(ref val3)).normalized);
					((List<(Vector3, float)>)(object)pooledScoreList).Add((item3, item));
				}
				pooledScoreList.SortByScoreDesc(Owner);
				foreach (var item4 in (List<(Vector3, float)>)(object)pooledScoreList)
				{
					Vector3 item2 = item4.Item1;
					if (base.Agent.SamplePosition(item2, out var sample, 10f) && (base.Agent.canSwim || !base.Agent.IsInWater(sample)) && base.Agent.SetDestination(sample))
					{
						return EFSMStateStatus.None;
					}
				}
				return EFSMStateStatus.Failure;
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_FleeFire : State_Flee
{
	private int numExecutions;

	private int maxExecutionsBeforeMinDist = 2;

	private float minDistance = 8f;

	private float maxDistance = 20f;

	private double timeOfLastExecution;

	public override EFSMStateStatus OnStateEnter()
	{
		if (Time.timeAsDouble - timeOfLastExecution > 30.0)
		{
			numExecutions = 0;
		}
		timeOfLastExecution = Time.timeAsDouble;
		distance = 7f;
		desiredDistance = Mathx.RemapValClamped((float)numExecutions, 0f, (float)maxExecutionsBeforeMinDist, maxDistance, minDistance);
		numExecutions++;
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (base.Senses.FindTargetPosition(out var targetPosition) && Time.timeAsDouble - timeOfLastExecution > 1.0 && Vector3.Distance(((Component)Owner).transform.position, targetPosition) > desiredDistance)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Roam : FSMStateBase
{
	[SerializeField]
	private Vector2 distanceRange = new Vector2(10f, 20f);

	[SerializeField]
	private float homeRadius = 50f;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds minSpeed;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds maxSpeed = LimitedTurnNavAgent.Speeds.Sprint;

	[SerializeField]
	protected bool favourWater;

	private Vector3? spawnPosition;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Reset();
		if (!spawnPosition.HasValue)
		{
			spawnPosition = ((Component)Owner).transform.position;
		}
		if (!TrySetRoamDestination())
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	private bool TrySetRoamDestination()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			float num = Random.Range(distanceRange.x, distanceRange.y);
			Eqs.SamplePositionsInDonutShape(base.Agent.NavPosition, (List<Vector3>)(object)val, num);
			bool flag = Vector3.Distance(spawnPosition.Value, ((Component)Owner).transform.position) > homeRadius;
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				Vector3 val2 = spawnPosition.Value - ((Component)Owner).transform.position;
				Vector3 normalized = ((Vector3)(ref val2)).normalized;
				foreach (Vector3 item2 in (List<Vector3>)(object)val)
				{
					float num2 = 0f;
					if (flag)
					{
						float num3 = num2;
						val2 = item2 - ((Component)Owner).transform.position;
						num2 = num3 + Mathx.RemapValClamped(Vector3.Dot(normalized, ((Vector3)(ref val2)).normalized), -1f, 1f, 0f, 1f);
						if (base.Agent.IsPositionOnFavoredTerrain(item2))
						{
							num2 += 0.25f;
						}
					}
					else
					{
						num2 += Random.value;
						if (base.Agent.IsPositionOnFavoredTerrain(item2))
						{
							num2 += 10f;
						}
					}
					((List<(Vector3, float)>)(object)pooledScoreList).Add((item2, num2));
				}
				pooledScoreList.SortByScoreDesc(Owner);
				foreach (var item3 in (List<(Vector3, float)>)(object)pooledScoreList)
				{
					Vector3 item = item3.Item1;
					if (base.Agent.SamplePosition(item, out var sample, 10f) && (base.Agent.canSwim || !base.Agent.IsInWater(sample)) && base.Agent.SetDestination(sample))
					{
						float ratio = Mathf.InverseLerp(0f, distanceRange.y, num);
						base.Agent.SetSpeedRatio(ratio, minSpeed, maxSpeed);
						return true;
					}
				}
				return false;
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Agent.IsFollowingPath)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	private void Reset()
	{
		base.Senses.ClearTarget();
		base.Blackboard.Clear();
		if (Owner is BaseCombatEntity { healthFraction: <1f, SecondsSinceAttacked: >120f } baseCombatEntity)
		{
			baseCombatEntity.SetHealth(Owner.MaxHealth());
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Dead : FSMStateBase, IParametrized<HitInfo>
{
	[SerializeField]
	private string deathStatName;

	[SerializeField]
	private GameObjectRef CorpsePrefab;

	[SerializeField]
	private RootMotionData staticDeathAnim;

	[SerializeField]
	private RootMotionData forwardMotionDeathAnim;

	[SerializeField]
	private float ragdollWhenAnimRemainingTimeIsBelow = 0.5f;

	private HitInfo HitInfo;

	private RootMotionPlayer.PlayServerState animState;

	private Action _startRagdollAction;

	private Action StartRagdollAction => StartRagdoll;

	public void SetParameter(HitInfo parameter)
	{
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
		if (parameter == null)
		{
			Debug.LogWarning((object)"No parameter set for death state");
		}
		HitInfo = Pool.Get<HitInfo>();
		HitInfo.CopyFrom(parameter);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		if (HitInfo != null && (Object)(object)HitInfo.InitiatorPlayer != (Object)null)
		{
			BasePlayer initiatorPlayer = HitInfo.InitiatorPlayer;
			initiatorPlayer.GiveAchievement("KILL_ANIMAL");
			if (!string.IsNullOrEmpty(deathStatName))
			{
				initiatorPlayer.stats.Add(deathStatName, 1, (Stats)5);
				initiatorPlayer.stats.Save();
			}
			if (Owner is BaseCombatEntity killed)
			{
				initiatorPlayer.LifeStoryKill(killed);
			}
		}
		if (!CorpsePrefab.isValid)
		{
			Owner.Kill();
			return base.OnStateEnter();
		}
		if (forwardMotionDeathAnim != null && base.Agent.IsSpeedGTE(LimitedTurnNavAgent.Speeds.Run))
		{
			animState = base.AnimPlayer.PlayServerAndTakeFromPool(forwardMotionDeathAnim);
			float num = Mathf.Max(0f, forwardMotionDeathAnim.inPlaceAnimation.length - ragdollWhenAnimRemainingTimeIsBelow);
			((FacepunchBehaviour)Owner).Invoke(StartRagdollAction, num + AI.defaultInterpolationDelay);
		}
		else if (staticDeathAnim != null && HitInfo != null && Vector3.Dot(HitInfo.attackNormal, ((Component)Owner).transform.forward) < 0f)
		{
			animState = base.AnimPlayer.PlayServerAndTakeFromPool(staticDeathAnim);
			float num2 = Mathf.Max(0f, staticDeathAnim.inPlaceAnimation.length - ragdollWhenAnimRemainingTimeIsBelow);
			((FacepunchBehaviour)Owner).Invoke(StartRagdollAction, num2 + AI.defaultInterpolationDelay);
		}
		else
		{
			StartRagdoll();
		}
		return base.OnStateEnter();
	}

	private void StartRagdoll()
	{
		BaseCorpse baseCorpse = Owner.DropCorpse(CorpsePrefab.resourcePath);
		if (Object.op_Implicit((Object)(object)baseCorpse))
		{
			baseCorpse.Spawn();
			baseCorpse.TakeChildren(Owner);
		}
		((FacepunchBehaviour)Owner).Invoke((Action)Owner.KillMessage, 0.5f);
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
		Pool.Free<HitInfo>(ref HitInfo);
		base.OnStateExit();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Howl : State_PlayAnimation
{
	public const string WolfNearbyAlreadyHowled = "WolfNearbyAlreadyHowled";

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var targetEntity))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Agent.CanReach(((Component)targetEntity).transform.position, resetPathOnFailure: true))
		{
			return EFSMStateStatus.Failure;
		}
		base.Blackboard.Add("WolfNearbyAlreadyHowled");
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetInitialAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<BlackboardComponent>().Add("WolfNearbyAlreadyHowled");
				Wolf2FSM otherWolf = ((Component)item).GetComponent<Wolf2FSM>();
				((FacepunchBehaviour)Owner).Invoke((Action)delegate
				{
					otherWolf.Howl(targetEntity);
				}, 1f);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_Growl : State_PlayAnimationRM
{
	public const string AlreadyGrowled = "AlreadyGrowled";

	public override EFSMStateStatus OnStateEnter()
	{
		base.Blackboard.Increment("AlreadyGrowled");
		return base.OnStateEnter();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Bark : State_PlayAnimation
{
	public const string WolfNearbyAlreadyBarked = "WolfNearbyAlreadyBarked";

	public override EFSMStateStatus OnStateEnter()
	{
		if (!base.Senses.FindTarget(out var targetEntity))
		{
			return EFSMStateStatus.Failure;
		}
		base.Blackboard.Add("WolfNearbyAlreadyBarked");
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetInitialAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<BlackboardComponent>().Add("WolfNearbyAlreadyBarked");
				Wolf2FSM otherWolf = ((Component)item).GetComponent<Wolf2FSM>();
				((FacepunchBehaviour)Owner).Invoke((Action)delegate
				{
					otherWolf.Bark(targetEntity);
				}, Mathf.Max(0f, Animation.length + Random.Range(-0.5f, 0.5f)));
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Intimidated : State_PlayAnimationRM
{
	private static readonly float facingAwayDotThreshold = Mathf.Cos(MathF.PI / 2f);

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		FaceTarget = true;
		if (base.Senses.FindTargetPosition(out var targetPosition))
		{
			Vector3 forward = ((Component)Owner).transform.forward;
			Vector3 val = ((Component)Owner).transform.position - targetPosition;
			if (Vector3.Dot(forward, ((Vector3)(ref val)).normalized) > facingAwayDotThreshold)
			{
				return EFSMStateStatus.Success;
			}
		}
		return base.OnStateEnter();
	}
}


using System;
using Facepunch;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Hurt : State_PlayAnimationRM, IParametrized<HitInfo>
{
	[SerializeField]
	private RootMotionData StrongHitL;

	[SerializeField]
	private RootMotionData StrongHitR;

	[SerializeField]
	private RootMotionData WeakHit;

	[SerializeField]
	private float StaggerRatio = 0.5f;

	private HitInfo HitInfo;

	public void SetParameter(HitInfo parameter)
	{
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
		if (parameter == null)
		{
			Debug.LogWarning((object)"No parameter set for hurt state");
		}
		HitInfo = Pool.Get<HitInfo>();
		HitInfo.CopyFrom(parameter);
	}

	public bool ShouldStagger(BaseEntity owner, HitInfo hitInfo)
	{
		float num = owner.Health() + hitInfo.damageTypes.Total();
		float num2 = owner.MaxHealth() * StaggerRatio;
		if (num > num2)
		{
			return owner.Health() < num2;
		}
		return false;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		if (HitInfo == null)
		{
			Debug.LogWarning((object)"No hitinfo set for hurt state");
			return base.OnStateEnter();
		}
		if (Object.op_Implicit((Object)(object)HitInfo.InitiatorPlayer) && !HitInfo.damageTypes.IsMeleeType())
		{
			HitInfo.InitiatorPlayer.LifeStoryShotHit(HitInfo.Weapon);
		}
		if (HitInfo.damageTypes.Has(DamageType.Heat))
		{
			base.Blackboard.Add("HitByFire");
		}
		if (WeakHit == null || ShouldStagger(Owner, HitInfo))
		{
			bool flag = Vector3.Dot(HitInfo.attackNormal, ((Component)Owner).transform.right) > 0f;
			Animation = (flag ? StrongHitL : StrongHitR);
		}
		else
		{
			Animation = WeakHit;
		}
		if (HitInfo.Initiator is BaseCombatEntity baseCombatEntity)
		{
			bool flag2 = true;
			if (base.Senses.FindTarget(out var target))
			{
				bool num = Owner.Distance((BaseEntity)baseCombatEntity) < 16f;
				bool flag3 = !target.IsNonNpcPlayer() && baseCombatEntity.IsNonNpcPlayer();
				flag2 = num || flag3;
			}
			if (flag2)
			{
				base.Senses.TrySetTarget(baseCombatEntity);
			}
		}
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		Pool.Free<HitInfo>(ref HitInfo);
		base.OnStateExit();
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_WolfHurt : State_Hurt
{
	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		if (!base.Senses.FindTarget(out var target))
		{
			if (AI.logIssues)
			{
				Debug.LogWarning((object)"Got attacked but couldn't find a target");
			}
			return result;
		}
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetInitialAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<Wolf2FSM>().Intimidate(target);
			}
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using ConVar;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Assertions;

[Serializable]
public class State_Attack : State_PlayAnimationRM
{
	[SerializeField]
	public float Damage = 30f;

	[SerializeField]
	public float Delay = 0.5f;

	[SerializeField]
	public DamageType DamageType = DamageType.Bite;

	private Action _doDamageAction;

	protected Action DoDamageAction => _doDamageAction ?? (_doDamageAction = DoDamage);

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(Delay < Animation.inPlaceAnimation.length);
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		if (!FaceTarget)
		{
			Vector3 val = Vector3Ex.NormalizeXZ(((Component)Owner).transform.position - targetPosition);
			Vector3 val2 = Vector3.Cross(Vector3.up, val);
			targetPosition += ((Random.value > 0.5f) ? 1f : (-1f)) * val2;
			Vector3 val3 = Vector3Ex.NormalizeXZ(targetPosition - ((Component)Owner).transform.position);
			((Component)Owner).transform.rotation = Quaternion.LookRotation(val3);
		}
		((FacepunchBehaviour)Owner).Invoke(DoDamageAction, Delay + AI.defaultInterpolationDelay);
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		((FacepunchBehaviour)Owner).CancelInvoke(DoDamageAction);
		base.OnStateExit();
	}

	protected virtual void DoDamage()
	{
		if (base.Senses.FindTarget(out var target) && target is BaseCombatEntity baseCombatEntity)
		{
			baseCombatEntity.OnAttacked(Damage, DamageType, Owner, ignoreShield: false);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_Circle : FSMStateBase, IParametrized<BaseEntity>
{
	[SerializeField]
	public float radius = 16f;

	[SerializeField]
	public LimitedTurnNavAgent.Speeds speed = LimitedTurnNavAgent.Speeds.Sprint;

	private bool clockWise = true;

	private float radiusOffset;

	public void SetParameter(BaseEntity target)
	{
		base.Senses.TrySetTarget(target);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		base.Agent.SetSpeed(speed);
		radiusOffset = Random.Range(-1f, 1f);
		clockWise = Random.value > 0.5f;
		base.Agent.shouldStopAtDestination = false;
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	protected virtual bool GetCircleOrigin(out Vector3 origin)
	{
		return base.Senses.FindTargetPosition(out origin);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		if (!GetCircleOrigin(out var origin))
		{
			return EFSMStateStatus.Failure;
		}
		float num = radius + radiusOffset;
		Quaternion val = Quaternion.LookRotation(((Component)Owner).transform.position - origin);
		float num2 = (((Quaternion)(ref val)).eulerAngles.y + 5f * (float)(clockWise ? 1 : (-1))) * (MathF.PI / 180f);
		Vector3 val2 = origin + new Vector3(Mathf.Sin(num2), 0f, Mathf.Cos(num2)) * num;
		val2.y = Mathf.Lerp(origin.y, ((Component)Owner).transform.position.y, Mathf.InverseLerp(0f, Vector3.Distance(origin, ((Component)Owner).transform.position), num));
		NavMeshHit val3 = default(NavMeshHit);
		if (NavMesh.Raycast(((Component)Owner).transform.position, val2, ref val3, -1))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Agent.SetDestination(val2))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_ApproachFire : State_CircleDynamic
{
	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		base.Agent.deceleration.Value = 6f;
		distanceSpeedRange.x = 16f;
		return result;
	}

	public override void OnStateExit()
	{
		base.Agent.deceleration.Reset();
		base.OnStateExit();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_CircleDynamic : FSMStateBase, IParametrized<BaseEntity>
{
	[SerializeField]
	private LimitedTurnNavAgent.Speeds minSpeed;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds maxSpeed = LimitedTurnNavAgent.Speeds.Sprint;

	[SerializeField]
	protected Vector2 distanceSpeedRange = new Vector2(10f, 50f);

	[SerializeField]
	private Vector2 angleRange = Vector2.op_Implicit(new Vector3(20f, 80f));

	[SerializeField]
	private Vector2 angleDurationRange = new Vector2(1f, 3f);

	[SerializeField]
	private Vector2 burstDurationRange = new Vector2(1f, 3f);

	[SerializeField]
	private Vector2 burstCooldownRange = new Vector2(1f, 10f);

	private Action _updateBurstAction;

	private Action _endBurstAction;

	private Action _updateAngleAction;

	private bool clockWise = true;

	private int burstSpeedIndexOffset;

	private float randomAngle;

	private Action UpdateBurstAction => UpdateBurst;

	private Action EndBurstAction => EndBurst;

	private Action UpdateAngleAction => UpdateAngle;

	public void SetParameter(BaseEntity target)
	{
		base.Senses.TrySetTarget(target);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		clockWise = Random.value > 0.5f;
		EndBurst();
		UpdateAngle();
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		((FacepunchBehaviour)Owner).CancelInvoke(UpdateBurstAction);
		((FacepunchBehaviour)Owner).CancelInvoke(EndBurstAction);
		((FacepunchBehaviour)Owner).CancelInvoke(UpdateAngleAction);
		base.OnStateExit();
	}

	private void UpdateAngle()
	{
		randomAngle = Random.Range(angleRange.x, angleRange.y) * (float)(clockWise ? 1 : (-1));
		((FacepunchBehaviour)Owner).Invoke(UpdateAngleAction, Random.Range(angleDurationRange.x, angleDurationRange.y));
	}

	private void UpdateBurst()
	{
		burstSpeedIndexOffset = 2;
		clockWise = Random.value > 0.5f;
		float num = Random.Range(burstDurationRange.x, burstDurationRange.y);
		((FacepunchBehaviour)Owner).Invoke(EndBurstAction, num);
	}

	private void EndBurst()
	{
		burstSpeedIndexOffset = 0;
		float num = Random.Range(burstCooldownRange.x, burstCooldownRange.y);
		((FacepunchBehaviour)Owner).Invoke(UpdateBurstAction, num);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 position = ((Component)target).transform.position;
		float num = Vector3.Distance(((Component)Owner).transform.position, position);
		float normalizedDist = Mathf.InverseLerp(distanceSpeedRange.x, distanceSpeedRange.y, num);
		SetSpeed(target, num, normalizedDist);
		float currentDeviation = Mathx.RemapValClamped(num, distanceSpeedRange.x, distanceSpeedRange.y, randomAngle, 0f);
		base.Agent.currentDeviation = currentDeviation;
		Vector3 newDestination = position;
		if (!base.Agent.SetDestination(newDestination))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}

	protected virtual void SetSpeed(BaseEntity target, float distToTarget, float normalizedDist)
	{
		base.Agent.SetSpeedRatio(normalizedDist, minSpeed, maxSpeed, burstSpeedIndexOffset);
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public class State_MoveToLastReachablePointNearTarget : State_MoveToTarget
{
	private const float maxHorizontalDist = 7f;

	private const float maxVerticalDist = 2.7f;

	private const float traceVerticalOffset = 1f;

	private Vector3 reachableDestination;

	private LockState.LockHandle targetLock;

	public static bool CanJumpFromPosToPos(BaseEntity owner, Vector3 ownerLocation, Vector3 targetPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if (Mathf.Abs(targetPos.y - ownerLocation.y) > 2.7f)
		{
			return false;
		}
		if (Vector3.Distance(ownerLocation, targetPos) > 7f)
		{
			return false;
		}
		if (!owner.CanSee(ownerLocation + 1f * Vector3.up, targetPos + 1f * Vector3.up))
		{
			return false;
		}
		return true;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		if (!FindReachableLocation(out reachableDestination))
		{
			return EFSMStateStatus.Failure;
		}
		targetLock = base.Senses.LockCurrentTarget();
		base.Agent.deceleration.Value = 6f;
		return base.OnStateEnter();
	}

	private bool FindReachableLocation(out Vector3 location)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		location = default(Vector3);
		if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer basePlayer))
		{
			return false;
		}
		if (basePlayer.isMounted)
		{
			return false;
		}
		Vector3 position = ((Component)target).transform.position;
		if (Vector3.Distance(((Component)Owner).transform.position, position) > 50f)
		{
			return false;
		}
		Vector3? val = null;
		if (base.Agent.lastValidDestination.HasValue && Vector3.Distance(base.Agent.lastValidDestination.Value, position) <= 7f && base.Agent.SamplePosition(base.Agent.lastValidDestination.Value, out var sample, 7f) && CanJumpFromPosToPos(Owner, sample, position))
		{
			val = sample;
		}
		if (!val.HasValue && base.Agent.SamplePosition(position, out var sample2, 7f) && CanJumpFromPosToPos(Owner, sample2, position))
		{
			val = sample2;
		}
		if (!val.HasValue)
		{
			return false;
		}
		location = val.Value;
		return true;
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		destination = reachableDestination;
		return true;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (Trans_TargetIsNearFire.Test(Owner, base.Senses))
		{
			float ratio = Mathx.RemapValClamped(Vector3.Distance(((Component)Owner).transform.position, reachableDestination), 4f, 16f, 0f, 1f);
			base.Agent.SetSpeedRatio(ratio, LimitedTurnNavAgent.Speeds.Sneak, LimitedTurnNavAgent.Speeds.Jog);
		}
		else
		{
			base.Agent.SetSpeed(speed);
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.OnStateExit();
		base.Senses.UnlockTarget(ref targetLock);
		base.Agent.deceleration.Reset();
	}
}


using System;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_AttackUnreachable : FSMStateBase
{
	private enum Phase
	{
		PreJump,
		Jump,
		Attack,
		JumpBack,
		PostJumpBack
	}

	public float preJumpEnd = 0.29f;

	public float jumpEnd = 0.395f;

	public float attackEnd = 0.67f;

	public float jumpBackEnd = 0.765f;

	public float postJumpBackEnd = 0.95f;

	private const float groundCheckDistance = 2f;

	private const float damage = 35f;

	private const float meleeAttackRange = 1.7f;

	private const DamageType damageType = DamageType.Bite;

	public RootMotionData animClip;

	private Vector3 startLocation;

	private Quaternion startRotation;

	private Vector3 destination;

	private float elapsedTime;

	private LockState.LockHandle targetLock;

	private LockState.LockHandle movementLock;

	private Phase phase;

	private float previousOffsetZ;

	private RootMotionPlayer.PlayServerState animState;

	public static bool SampleGroundPositionUnderTarget(LimitedTurnNavAgent agent, BasePlayer targetAsPlayer, out Vector3 projectedLocation)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		float radius = BasePlayer.GetRadius();
		RaycastHit hitInfo;
		bool result = agent.SampleGroundPositionWithPhysics(((Component)targetAsPlayer).transform.position, out hitInfo, 2f, radius);
		projectedLocation = ((RaycastHit)(ref hitInfo)).point;
		return result;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer basePlayer))
		{
			return EFSMStateStatus.Failure;
		}
		destination = ((Component)target).transform.position;
		if (!basePlayer.IsOnGround() && !SampleGroundPositionUnderTarget(base.Agent, basePlayer, out destination))
		{
			return EFSMStateStatus.Failure;
		}
		if (!State_MoveToLastReachablePointNearTarget.CanJumpFromPosToPos(Owner, ((Component)Owner).transform.position, destination))
		{
			return EFSMStateStatus.Failure;
		}
		movementLock = base.Agent.Pause();
		elapsedTime = 0f;
		targetLock = base.Senses.LockCurrentTarget();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(animClip.inPlaceAnimation);
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = false;
		SetPhase(Phase.PreJump);
		return base.OnStateEnter();
	}

	private void SetPhase(Phase newPhase)
	{
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		phase = newPhase;
		previousOffsetZ = animClip.zMotionCurve.Evaluate(elapsedTime);
		if (phase == Phase.Jump)
		{
			if (base.Senses.FindTarget(out var target) && target is BasePlayer targetAsPlayer)
			{
				SampleGroundPositionUnderTarget(base.Agent, targetAsPlayer, out destination);
			}
			startLocation = ((Component)Owner).transform.position;
			((Component)Owner).transform.rotation = Quaternion.LookRotation(Vector3Ex.WithY(destination - ((Component)Owner).transform.position, 0f));
			base.Agent.IsJumping = true;
		}
		else if (phase == Phase.Attack)
		{
			startRotation = ((Component)Owner).transform.rotation;
			if (base.Senses.FindTarget(out var target2))
			{
				if (target2 is BaseCombatEntity baseCombatEntity && Vector3.Distance(((Component)Owner).transform.position, ((Component)baseCombatEntity).transform.position) <= 1.7f)
				{
					baseCombatEntity.OnAttacked(35f, DamageType.Bite, Owner, ignoreShield: false);
				}
				if (target2 is BasePlayer basePlayer && Vector3.Distance(((Component)Owner).transform.position, ((Component)basePlayer).transform.position) <= 1f)
				{
					basePlayer.DoPush(((Component)Owner).transform.forward * 10f + Vector3.up * 3f);
				}
			}
		}
		else if (phase == Phase.PostJumpBack)
		{
			base.Agent.IsJumping = false;
		}
	}

	private Vector3 ThreePointLerp(Vector3 a, Vector3 b, Vector3 c, float t)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Lerp(Vector3.Lerp(a, b, t), Vector3.Lerp(b, c, t), t);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_031f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		elapsedTime += deltaTime;
		float num = elapsedTime / Mathf.Max(animClip.inPlaceAnimation.length, 0.001f);
		if (phase == Phase.PreJump)
		{
			Quaternion val = Quaternion.LookRotation(Vector3Ex.WithY(destination - ((Component)Owner).transform.position, 0f));
			((Component)Owner).transform.rotation = Quaternion.Slerp(((Component)Owner).transform.rotation, val, 2f * deltaTime);
			float num2 = animClip.zMotionCurve.Evaluate(elapsedTime);
			Vector3 val2 = ((Component)Owner).transform.forward * (num2 - previousOffsetZ);
			previousOffsetZ = num2;
			Transform transform = ((Component)Owner).transform;
			transform.position += val2;
			if (num >= preJumpEnd)
			{
				SetPhase(Phase.Jump);
			}
		}
		if (phase == Phase.Jump)
		{
			Vector3 b = (startLocation + destination) * 0.5f;
			b.y = Mathf.Max(startLocation.y, destination.y);
			float t = Mathx.RemapValClamped(num, preJumpEnd, jumpEnd, 0f, 1f);
			Vector3 position = ThreePointLerp(startLocation, b, destination, t);
			((Component)Owner).transform.position = position;
			if (num >= jumpEnd)
			{
				SetPhase(Phase.Attack);
			}
		}
		if (phase == Phase.Attack)
		{
			((Component)Owner).transform.rotation = startRotation * Quaternion.AngleAxis(animClip.yRotationCurve.Evaluate(elapsedTime), Vector3.up);
			if (num > attackEnd)
			{
				SetPhase(Phase.JumpBack);
			}
		}
		if (phase == Phase.JumpBack)
		{
			Vector3 b2 = (startLocation + destination) * 0.5f;
			b2.y = Mathf.Max(startLocation.y, destination.y);
			float t2 = Mathx.RemapValClamped(num, attackEnd, jumpBackEnd, 0f, 1f);
			Vector3 position2 = ThreePointLerp(destination, b2, startLocation, t2);
			((Component)Owner).transform.position = position2;
			((Component)Owner).transform.rotation = Quaternion.LookRotation(Vector3Ex.WithY(startLocation - destination, 0f));
			if (num >= jumpBackEnd)
			{
				SetPhase(Phase.PostJumpBack);
			}
		}
		if (phase == Phase.PostJumpBack)
		{
			float num3 = animClip.zMotionCurve.Evaluate(elapsedTime);
			Vector3 val3 = ((Component)Owner).transform.forward * (num3 - previousOffsetZ);
			previousOffsetZ = num3;
			Transform transform2 = ((Component)Owner).transform;
			transform2.position -= val3;
		}
		if (num >= postJumpBackEnd)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = true;
		base.Senses.UnlockTarget(ref targetLock);
		base.Agent.Unpause(ref movementLock);
		if (phase != Phase.PostJumpBack)
		{
			base.Agent.IsJumping = false;
		}
		base.OnStateExit();
	}
}


private enum Phase
{
	PreJump,
	Jump,
	Attack,
	JumpBack,
	PostJumpBack
}


public class AIArena2 : FacepunchBehaviour, IClientComponent
{
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class BlackboardComponent : EntityComponent<BaseEntity>, IServerComponent
{
	[SerializeField]
	private float factDuration = 30f;

	private Dictionary<string, int> addedFacts = new Dictionary<string, int>();

	private Dictionary<string, float> factExpirationTimes = new Dictionary<string, float>();

	public override void InitShared()
	{
		base.InitShared();
		((MonoBehaviour)this).InvokeRepeating("CleanExpiredFacts", Random.value, 1f);
	}

	public void Add(string value)
	{
		if (addedFacts.TryAdd(value, 1))
		{
			factExpirationTimes[value] = Time.time + factDuration;
		}
	}

	public void Increment(string value)
	{
		if (!addedFacts.TryGetValue(value, out var value2))
		{
			value2 = 0;
		}
		value2++;
		addedFacts[value] = value2;
		factExpirationTimes[value] = Time.time + factDuration;
	}

	public void Remove(string value)
	{
		if (addedFacts.Remove(value))
		{
			factExpirationTimes.Remove(value);
		}
	}

	public void Clear()
	{
		addedFacts.Clear();
		factExpirationTimes.Clear();
	}

	public bool Has(string value)
	{
		return addedFacts.ContainsKey(value);
	}

	public bool Count(string value, out int count)
	{
		return addedFacts.TryGetValue(value, out count);
	}

	public void CleanExpiredFacts()
	{
		TimeWarning val = TimeWarning.New("BlackboardComponent.CleanExpiredFacts", 0);
		try
		{
			float time = Time.time;
			PooledList<string> val2 = Pool.Get<PooledList<string>>();
			try
			{
				foreach (var (text2, _) in addedFacts)
				{
					if (factExpirationTimes[text2] < time)
					{
						((List<string>)(object)val2).Add(text2);
					}
				}
				foreach (string item in (List<string>)(object)val2)
				{
					Remove(item);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;

[Flags]
public enum EFSMStateStatus
{
	None = 0,
	Success = 1,
	Failure = 2
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(LimitedTurnNavAgent), typeof(RootMotionPlayer), typeof(SenseComponent))]
[SoftRequireComponent(typeof(BlackboardComponent), typeof(NPCEncounterTimer))]
public class FSMComponent : EntityComponent<BaseEntity>
{
	public class TickFSMWorkQueue : PersistentObjectWorkQueue<FSMComponent>
	{
		protected override void RunJob(FSMComponent component)
		{
			if (((PersistentObjectWorkQueue<FSMComponent>)this).ShouldAdd(component) && ((Behaviour)component).enabled)
			{
				component.Senses.Tick();
				((Component)component).GetComponent<NPCEncounterTimer>().Tick();
				component.Tick();
			}
		}

		protected override bool ShouldAdd(FSMComponent component)
		{
			if (base.ShouldAdd(component))
			{
				return component.baseEntity.IsValid();
			}
			return false;
		}
	}

	private bool isRunning;

	private SenseComponent _senses;

	public const float minRefreshIntervalSeconds = 0f;

	public const float maxRefreshIntervalSeconds = 0.5f;

	private double? _lastTickTime;

	private double nextRefreshTime;

	private const int maxStateChangesPerTick = 3;

	private List<FSMStateBase> sameFrameStateChangesHistory = new List<FSMStateBase>();

	private FSMStateBase pendingStateChange;

	public static TickFSMWorkQueue workQueue = new TickFSMWorkQueue();

	public const float frameBudgetMs = 0.5f;

	public FSMStateBase CurrentState { get; private set; }

	private SenseComponent Senses => _senses ?? (_senses = ((Component)base.baseEntity).GetComponent<SenseComponent>());

	private float RefreshInterval
	{
		get
		{
			if (!Senses.ShouldRefreshFast)
			{
				return 0.5f;
			}
			return 0f;
		}
	}

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	public void Run()
	{
		if (isRunning)
		{
			Debug.LogWarning((object)("[FSM] Trying to start a FSM that's already running on " + ((Object)((Component)base.baseEntity).gameObject).name));
			return;
		}
		isRunning = true;
		_lastTickTime = null;
		((PersistentObjectWorkQueue<FSMComponent>)workQueue).Add(this);
	}

	public void Stop()
	{
		if (!isRunning)
		{
			Debug.LogWarning((object)("[FSM] Trying to stop a FSM that is not running on " + ((Object)((Component)base.baseEntity).gameObject).name));
			return;
		}
		isRunning = false;
		((PersistentObjectWorkQueue<FSMComponent>)workQueue).Remove(this);
	}

	private void OnDestroy()
	{
		Stop();
	}

	public static void ShowDebugInfoAroundLocation(BasePlayer player, float radius = 100f)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (!player.IsValid())
		{
			return;
		}
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			BaseEntity.Query.Server.GetBrainsInSphere(((Component)player).transform.position, radius, (List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				FSMComponent component = ((Component)item).GetComponent<FSMComponent>();
				if (!((Object)(object)component == (Object)null) && component.CurrentState != null && component.isRunning)
				{
					player.ClientRPC(RpcTarget.Player("CL_ShowStateDebugInfo", player), ((Component)component.baseEntity).transform.position, component.CurrentState.Name);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected void ForceTickOnTheNextUpdate()
	{
		nextRefreshTime = 0.0;
	}

	public void Tick()
	{
		TimeWarning val = TimeWarning.New("FSMComponent.Tick", 0);
		try
		{
			if (Time.timeAsDouble < nextRefreshTime)
			{
				return;
			}
			nextRefreshTime = Time.timeAsDouble + (double)RefreshInterval;
			float deltaTime = (float)(Time.timeAsDouble - LastTickTime);
			LastTickTime = Time.timeAsDouble;
			sameFrameStateChangesHistory.Clear();
			if (pendingStateChange != null)
			{
				SetState(pendingStateChange);
			}
			else
			{
				if (CurrentState == null)
				{
					return;
				}
				TimeWarning val2 = TimeWarning.New("NormalTransitions", 0);
				try
				{
					PooledList<FSMStateBase> val3 = Pool.Get<PooledList<FSMStateBase>>();
					try
					{
						CurrentState.FindAncestry((List<FSMStateBase>)(object)val3);
						foreach (FSMStateBase item in (List<FSMStateBase>)(object)val3)
						{
							foreach (var (fSMTransitionBase, fSMStateBase) in item.transitions)
							{
								fSMTransitionBase.Init(base.baseEntity);
								if (fSMTransitionBase.Evaluate())
								{
									fSMStateBase.Owner = base.baseEntity;
									fSMTransitionBase.OnTransitionTaken(CurrentState, fSMStateBase);
									SetState(fSMStateBase);
									return;
								}
							}
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				EFSMStateStatus currentStateStatus = EFSMStateStatus.None;
				TimeWarning val4 = TimeWarning.New("StateTick", 0);
				try
				{
					TimeWarning val5 = TimeWarning.New(CurrentState.Name, 0);
					try
					{
						currentStateStatus = CurrentState.OnStateUpdate(deltaTime);
					}
					finally
					{
						((IDisposable)val5)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val4)?.Dispose();
				}
				EvaluateEndTransitions(currentStateStatus);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void EvaluateEndTransitions(EFSMStateStatus currentStateStatus)
	{
		TimeWarning val = TimeWarning.New("EndTransitions", 0);
		try
		{
			if (currentStateStatus == EFSMStateStatus.None)
			{
				return;
			}
			PooledList<FSMStateBase> val2 = Pool.Get<PooledList<FSMStateBase>>();
			try
			{
				CurrentState.FindAncestry((List<FSMStateBase>)(object)val2);
				foreach (FSMStateBase item in (List<FSMStateBase>)(object)val2)
				{
					foreach (var (fSMTransitionBase, fSMStateBase, eFSMStateStatus) in item.endTransitions)
					{
						if (eFSMStateStatus == (EFSMStateStatus.Success | EFSMStateStatus.Failure) || eFSMStateStatus == currentStateStatus)
						{
							bool flag = true;
							if (fSMTransitionBase != null)
							{
								fSMTransitionBase.Init(base.baseEntity);
								flag = fSMTransitionBase.Evaluate();
							}
							if (flag)
							{
								fSMStateBase.Owner = base.baseEntity;
								fSMTransitionBase?.OnTransitionTaken(CurrentState, fSMStateBase);
								SetState(fSMStateBase);
								ForceTickOnTheNextUpdate();
								return;
							}
						}
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void SetState(FSMStateBase newState)
	{
		TimeWarning val = TimeWarning.New("SetState", 0);
		try
		{
			pendingStateChange = null;
			sameFrameStateChangesHistory.Add(newState);
			if (sameFrameStateChangesHistory.Count > 3)
			{
				if (!AI.logIssues)
				{
					return;
				}
				StringBuilder stringBuilder = Pool.Get<StringBuilder>();
				stringBuilder.AppendFormat("[FSM] Possible endless recursion detected from {0} to {1} on {2}\n", CurrentState?.Name, newState.Name, base.baseEntity);
				foreach (FSMStateBase item in sameFrameStateChangesHistory)
				{
					stringBuilder.AppendFormat("{0} -> ", item.Name);
				}
				Debug.LogWarning((object)stringBuilder);
				pendingStateChange = newState;
				Pool.FreeUnmanaged(ref stringBuilder);
				return;
			}
			if (CurrentState != null)
			{
				TimeWarning val2 = TimeWarning.New("Transitions OnStateExit", 0);
				try
				{
					PooledList<FSMStateBase> val3 = Pool.Get<PooledList<FSMStateBase>>();
					try
					{
						CurrentState.FindAncestry((List<FSMStateBase>)(object)val3);
						foreach (FSMStateBase item2 in (List<FSMStateBase>)(object)val3)
						{
							foreach (var endTransition in item2.endTransitions)
							{
								endTransition.transition?.OnStateExit();
							}
							foreach (var transition in item2.transitions)
							{
								transition.transition.OnStateExit();
							}
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				TimeWarning val4 = TimeWarning.New("OnStateExit", 0);
				try
				{
					TimeWarning val5 = TimeWarning.New(CurrentState.Name, 0);
					try
					{
						CurrentState.OnStateExit();
					}
					finally
					{
						((IDisposable)val5)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val4)?.Dispose();
				}
			}
			CurrentState = newState;
			TimeWarning val6 = TimeWarning.New("Transitions OnStateEnter", 0);
			try
			{
				PooledList<FSMStateBase> val7 = Pool.Get<PooledList<FSMStateBase>>();
				try
				{
					CurrentState.FindAncestry((List<FSMStateBase>)(object)val7);
					foreach (FSMStateBase item3 in (List<FSMStateBase>)(object)val7)
					{
						foreach (var endTransition2 in item3.endTransitions)
						{
							endTransition2.transition?.OnStateEnter();
						}
						foreach (var transition2 in item3.transitions)
						{
							transition2.transition.OnStateEnter();
						}
					}
				}
				finally
				{
					((IDisposable)val7)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val6)?.Dispose();
			}
			TimeWarning val8 = TimeWarning.New("OnStateEnter", 0);
			try
			{
				TimeWarning val9 = TimeWarning.New(CurrentState.Name, 0);
				try
				{
					EFSMStateStatus currentStateStatus = CurrentState.OnStateEnter();
					EvaluateEndTransitions(currentStateStatus);
				}
				finally
				{
					((IDisposable)val9)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val8)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using UnityEngine;

public class TickFSMWorkQueue : PersistentObjectWorkQueue<FSMComponent>
{
	protected override void RunJob(FSMComponent component)
	{
		if (((PersistentObjectWorkQueue<FSMComponent>)this).ShouldAdd(component) && ((Behaviour)component).enabled)
		{
			component.Senses.Tick();
			((Component)component).GetComponent<NPCEncounterTimer>().Tick();
			component.Tick();
		}
	}

	protected override bool ShouldAdd(FSMComponent component)
	{
		if (base.ShouldAdd(component))
		{
			return component.baseEntity.IsValid();
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Rust.Ai.Gen2;
using UnityEngine;

public abstract class FSMStateBase
{
	[NonSerialized]
	public BaseEntity Owner;

	[SerializeField]
	private string _Name;

	[NonSerialized]
	public FSMStateBase parent;

	public List<(FSMTransitionBase transition, FSMStateBase dstState)> transitions = new List<(FSMTransitionBase, FSMStateBase)>();

	public List<(FSMTransitionBase transition, FSMStateBase dstState, EFSMStateStatus status)> endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();

	private SenseComponent _senses;

	private LimitedTurnNavAgent _agent;

	private RootMotionPlayer _animPlayer;

	private BlackboardComponent _blackboard;

	public string Name
	{
		get
		{
			if (string.IsNullOrEmpty(_Name))
			{
				_Name = GetType().Name.Replace("State_", "");
			}
			return _Name;
		}
		set
		{
			_Name = value;
		}
	}

	protected SenseComponent Senses => _senses ?? (_senses = ((Component)Owner).GetComponent<SenseComponent>());

	protected LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)Owner).GetComponent<LimitedTurnNavAgent>());

	protected RootMotionPlayer AnimPlayer => _animPlayer ?? (_animPlayer = ((Component)Owner).GetComponent<RootMotionPlayer>());

	protected BlackboardComponent Blackboard => _blackboard ?? (_blackboard = ((Component)Owner).GetComponent<BlackboardComponent>());

	public virtual EFSMStateStatus OnStateEnter()
	{
		return EFSMStateStatus.None;
	}

	public virtual EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		return EFSMStateStatus.None;
	}

	public virtual void OnStateExit()
	{
	}

	protected T GetRootFSM<T>() where T : FSMComponent
	{
		return ((Component)Owner).GetComponent<T>();
	}

	public virtual FSMStateBase Clone()
	{
		FSMStateBase obj = (FSMStateBase)MemberwiseClone();
		obj.transitions = new List<(FSMTransitionBase, FSMStateBase)>();
		obj.endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();
		return obj;
	}

	public void FindAncestry(List<FSMStateBase> ancestry)
	{
		TimeWarning val = TimeWarning.New("FindAncestry", 0);
		try
		{
			FindAncestryRecursive(ancestry);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void FindAncestryRecursive(List<FSMStateBase> ancestry)
	{
		parent?.FindAncestryRecursive(ancestry);
		ancestry.Add(this);
	}

	public FSMStateBase AddEndTransition(FSMStateBase dstState, FSMTransitionBase transition = null)
	{
		if (endTransitions == null)
		{
			endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();
		}
		endTransitions.Add((transition, dstState, EFSMStateStatus.Success | EFSMStateStatus.Failure));
		return this;
	}

	public FSMStateBase AddFailureTransition(FSMStateBase dstState)
	{
		if (endTransitions == null)
		{
			endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();
		}
		endTransitions.Add((null, dstState, EFSMStateStatus.Failure));
		return this;
	}

	public FSMStateBase AddTickTransition(FSMStateBase dstState, FSMTransitionBase transition)
	{
		if (transitions == null)
		{
			transitions = new List<(FSMTransitionBase, FSMStateBase)>();
		}
		transitions.Add((transition, dstState));
		return this;
	}

	public FSMStateBase AddTickBranchingTrans(FSMStateBase dstState1, FSMTransitionBase sharedTransition, FSMStateBase dstState2, FSMTransitionBase dstState2Trans)
	{
		if (transitions == null)
		{
			transitions = new List<(FSMTransitionBase, FSMStateBase)>();
		}
		transitions.Add((new Trans_And { sharedTransition, dstState2Trans }, dstState2));
		transitions.Add((sharedTransition, dstState1));
		return this;
	}

	public FSMStateBase AddChild(FSMStateBase child)
	{
		child.parent = this;
		return child;
	}

	public FSMStateBase AddChildren(FSMStateBase child1, FSMStateBase child2 = null, FSMStateBase child3 = null, FSMStateBase child4 = null, FSMStateBase child5 = null, FSMStateBase child6 = null, FSMStateBase child7 = null, FSMStateBase child8 = null, FSMStateBase child9 = null, FSMStateBase child10 = null)
	{
		AddChild(child1);
		if (child2 != null)
		{
			AddChild(child2);
		}
		if (child3 != null)
		{
			AddChild(child3);
		}
		if (child4 != null)
		{
			AddChild(child4);
		}
		if (child5 != null)
		{
			AddChild(child5);
		}
		if (child6 != null)
		{
			AddChild(child6);
		}
		if (child7 != null)
		{
			AddChild(child7);
		}
		if (child8 != null)
		{
			AddChild(child8);
		}
		if (child9 != null)
		{
			AddChild(child9);
		}
		if (child10 != null)
		{
			AddChild(child10);
		}
		return this;
	}

	public static FSMStateBase operator +(FSMStateBase parent, FSMStateBase child)
	{
		parent.AddChild(child);
		return parent;
	}
}


public interface IParametrized<T>
{
	void SetParameter(T parameter);
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_Nothing : FSMStateBase
{
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_MoveToTarget : FSMStateBase, IParametrized<BaseEntity>
{
	[SerializeField]
	public LimitedTurnNavAgent.Speeds speed = LimitedTurnNavAgent.Speeds.FullSprint;

	[SerializeField]
	public bool succeedWhenDestinationIsReached = true;

	[SerializeField]
	public bool stopAtDestination = true;

	[SerializeField]
	public float accelerationOverride;

	[SerializeField]
	public float decelerationOverride;

	public void SetParameter(BaseEntity target)
	{
		base.Senses.TrySetTarget(target);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		base.Agent.ResetPath();
		base.Agent.desiredSwimDepth.Reset();
		base.Agent.shouldStopAtDestination = stopAtDestination;
		base.Agent.SetSpeed(speed);
		if (accelerationOverride > 0f)
		{
			base.Agent.acceleration.Value = accelerationOverride;
		}
		if (decelerationOverride > 0f)
		{
			base.Agent.deceleration.Value = decelerationOverride;
		}
		if (!GetMoveDestination(out var destination) || !base.Agent.SetDestination(destination))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Agent.IsFollowingPath && succeedWhenDestinationIsReached)
		{
			return EFSMStateStatus.Success;
		}
		if (!GetMoveDestination(out var destination) || !base.Agent.SetDestination(destination))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	protected virtual bool GetMoveDestination(out Vector3 destination)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			destination = Vector3.zero;
			return false;
		}
		destination = targetPosition;
		return true;
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public abstract class State_PlayAnimationBase : FSMStateBase
{
	[SerializeField]
	public bool FaceTarget;

	protected RootMotionPlayer.PlayServerState animState;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (FaceTarget && base.Senses.FindTargetPosition(out var targetPosition))
		{
			Vector3 val = targetPosition - ((Component)Owner).transform.position;
			val.y = 0f;
			((Component)Owner).transform.rotation = Quaternion.LookRotation(val);
		}
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!animState.isPlaying)
		{
			return EFSMStateStatus.Success;
		}
		return EFSMStateStatus.None;
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimation : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip Animation;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
		return result;
	}

	protected virtual AnimationClip GetAnimation()
	{
		return Animation;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimationRM : State_PlayAnimationBase
{
	[SerializeField]
	public RootMotionData Animation;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(GetAnimation());
		return result;
	}

	protected virtual RootMotionData GetAnimation()
	{
		return Animation;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayRandomAnimation : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip[] animations;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(animations.GetRandom());
		return result;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimLoop : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip Start;

	[SerializeField]
	public AnimationClip Loop;

	[SerializeField]
	public AnimationClip Stop;

	[SerializeField]
	public float MinDuration = 7f;

	[SerializeField]
	public float MaxDuration = 14f;

	private float duration;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		duration = Random.Range(MinDuration, MaxDuration);
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Start);
		return result;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (duration > 0f)
		{
			duration -= deltaTime;
			if (duration <= 0f)
			{
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Stop);
			}
			else if (!animState.isPlaying)
			{
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Loop);
			}
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using System.Linq;
using Rust.Ai.Gen2;
using UnityEngine;

public abstract class FSMTransitionBase
{
	[SerializeField]
	public bool Inverted;

	[NonSerialized]
	public BaseEntity Owner;

	private SenseComponent _senses;

	private LimitedTurnNavAgent _agent;

	protected SenseComponent Senses => _senses ?? (_senses = ((Component)Owner).GetComponent<SenseComponent>());

	protected LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)Owner).GetComponent<LimitedTurnNavAgent>());

	public virtual void Init(BaseEntity owner)
	{
		Owner = owner;
	}

	public virtual void OnStateEnter()
	{
	}

	public virtual void OnStateExit()
	{
	}

	public virtual void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
	}

	public bool Evaluate()
	{
		if (!Inverted)
		{
			return EvaluateInternal();
		}
		return !EvaluateInternal();
	}

	protected virtual bool EvaluateInternal()
	{
		return false;
	}

	public virtual string GetName()
	{
		return (Inverted ? "!" : "") + GetGenericTypeName(GetType());
	}

	protected static string GetGenericTypeName(Type type)
	{
		if (type.IsGenericType)
		{
			string name = type.Name;
			return (name[..name.IndexOf('`')] + "<" + string.Join(", ", type.GetGenericArguments().Select(GetGenericTypeName)) + ">").Replace("Trans_", "");
		}
		return type.Name.Replace("Trans_", "");
	}

	public virtual FSMTransitionBase Clone()
	{
		return (FSMTransitionBase)MemberwiseClone();
	}

	public static Trans_And operator &(FSMTransitionBase lhs, FSMTransitionBase rhs)
	{
		return new Trans_And { lhs, rhs };
	}

	public static Trans_Or operator |(FSMTransitionBase lhs, FSMTransitionBase rhs)
	{
		return new Trans_Or { lhs, rhs };
	}

	public static FSMTransitionBase operator ~(FSMTransitionBase instance)
	{
		instance.Inverted = !instance.Inverted;
		return instance;
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_AlwaysValid : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		return true;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public abstract class Trans_Composite : FSMTransitionBase, IEnumerable<FSMTransitionBase>, IEnumerable
{
	[SerializeField]
	protected List<FSMTransitionBase> transitions = new List<FSMTransitionBase>();

	public IEnumerator<FSMTransitionBase> GetEnumerator()
	{
		return transitions.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public void Add(FSMTransitionBase transition)
	{
		transitions.Add(transition);
	}

	public Trans_Composite()
	{
	}

	public override void Init(BaseEntity owner)
	{
		base.Init(owner);
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.Init(owner);
		}
	}

	public Trans_Composite(List<FSMTransitionBase> transitions)
	{
		this.transitions = transitions;
	}

	public override void OnStateEnter()
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnStateEnter();
		}
	}

	public override void OnStateExit()
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnStateExit();
		}
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnTransitionTaken(from, to);
		}
	}

	protected virtual string GetNameSeparator()
	{
		return " ";
	}

	public override string GetName()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("(");
		for (int i = 0; i < transitions.Count; i++)
		{
			stringBuilder.Append(transitions[i].GetName());
			if (i < transitions.Count - 1)
			{
				stringBuilder.Append(" ");
				stringBuilder.Append(GetNameSeparator());
				stringBuilder.Append(" ");
			}
		}
		stringBuilder.Append(" )");
		return stringBuilder.ToString();
	}

	public override FSMTransitionBase Clone()
	{
		Trans_Composite obj = base.Clone() as Trans_Composite;
		obj.transitions = new List<FSMTransitionBase>();
		return obj;
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_And : Trans_Composite
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_And", 0);
		try
		{
			foreach (FSMTransitionBase transition in transitions)
			{
				if (!transition.Evaluate())
				{
					return false;
				}
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override string GetNameSeparator()
	{
		return "&&";
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_Or : Trans_Composite
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Or", 0);
		try
		{
			foreach (FSMTransitionBase transition in transitions)
			{
				if (transition.Evaluate())
				{
					return true;
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override string GetNameSeparator()
	{
		return "||";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

public class Trans_Lambda : FSMTransitionBase
{
	private Func<BaseEntity, bool> EvaluateFunc;

	public Trans_Lambda(Func<BaseEntity, bool> evaluateFunc)
	{
		EvaluateFunc = evaluateFunc;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Lambda", 0);
		try
		{
			if ((Object)(object)Owner == (Object)null)
			{
				return false;
			}
			return EvaluateFunc(Owner);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_RandomChance : FSMTransitionBase
{
	[SerializeField]
	public float Chance = 0.5f;

	private bool Triggered;

	public override void OnStateEnter()
	{
		Triggered = Random.value <= Chance;
	}

	public override void OnStateExit()
	{
		Triggered = false;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_RandomChance", 0);
		try
		{
			return Triggered;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_Cooldown : FSMTransitionBase
{
	[SerializeField]
	public float cooldown = 20f;

	private double? lastTakenTime;

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		base.OnTransitionTaken(from, to);
		lastTakenTime = Time.timeAsDouble;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Cooldown", 0);
		try
		{
			return !lastTakenTime.HasValue || Time.timeAsDouble - lastTakenTime.Value >= (double)cooldown;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {cooldown}s";
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_Triggerable : FSMTransitionBase
{
	protected bool Triggered { get; private set; }

	public void Trigger()
	{
		Triggered = true;
	}

	public override void OnStateEnter()
	{
		Triggered = false;
	}

	public override void OnStateExit()
	{
		Triggered = false;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Triggerable", 0);
		try
		{
			return Triggered;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using Rust.Ai.Gen2;

public class Trans_Triggerable<T> : Trans_Triggerable
{
	private T Parameter;

	public void Trigger(T parameter)
	{
		Parameter = parameter;
		Trigger();
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		if (base.Triggered && to is IParametrized<T> parametrized)
		{
			parametrized.SetParameter(Parameter);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_ElapsedTime : FSMTransitionBase
{
	[SerializeField]
	public double Duration = 6.0;

	private double startTime;

	public override void OnStateEnter()
	{
		startTime = Time.timeAsDouble;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_ElapsedTime", 0);
		try
		{
			return Time.timeAsDouble >= startTime + Duration;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {Duration}s";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_ElapsedTimeRandomized : Trans_ElapsedTime
{
	[SerializeField]
	public double MinDuration = 2.0;

	[SerializeField]
	public double MaxDuration = 6.0;

	public override void OnStateEnter()
	{
		Duration = MinDuration + (double)Random.value * (MaxDuration - MinDuration);
		base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_TargetInRange : FSMTransitionBase
{
	[SerializeField]
	public float Range = 4f;

	[SerializeField]
	public float TimeToPredict;

	protected override bool EvaluateInternal()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TargetInRange", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			Vector3 val2 = ((Component)target).transform.position;
			if (TimeToPredict > 0f && target.ToNonNpcPlayer(out var player))
			{
				Vector3 inferedVelocity = player.inferedVelocity;
				inferedVelocity = Vector3.ProjectOnPlane(inferedVelocity, ((Component)Owner).transform.right);
				val2 += inferedVelocity * TimeToPredict;
			}
			return Vector3.Distance(val2, ((Component)Owner).transform.position) <= Range;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return string.Format("{0} {1}{2}m", base.GetName(), Inverted ? ">=" : "<", Range);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_TargetInFront : FSMTransitionBase
{
	[SerializeField]
	public float Angle = 90f;

	protected override bool EvaluateInternal()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TargetInFront", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			Vector3 val2 = targetPosition - ((Component)Owner).transform.position;
			return Vector3.Angle(((Component)Owner).transform.forward, val2) < Angle;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return string.Format("{0} {1}{2}°", base.GetName(), Inverted ? ">=" : "<", Angle);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_TargetIsNearFire : FSMTransitionBase
{
	public bool onlySeeFireWhenClose;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetIsNearFire", 0);
		try
		{
			return Test(Owner, base.Senses, onlySeeFireWhenClose);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool Test(BaseEntity owner, SenseComponent senses, bool onlySeeFireWhenClose = false)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Test", 0);
		try
		{
			if (!senses.FindTarget(out var target))
			{
				return false;
			}
			if (target.ToNonNpcPlayer(out var player) && SingletonComponent<NpcNoiseManager>.Instance.HasPlayerSpokenNear(owner, player))
			{
				return true;
			}
			if (!senses.FindFire(out var fire))
			{
				return false;
			}
			bool flag = Vector3.Distance(((Component)target).transform.position, ((Component)fire).transform.position) < 16f;
			bool flag2 = Vector3.Distance(((Component)owner).transform.position, ((Component)target).transform.position) < 18f;
			if (onlySeeFireWhenClose)
			{
				return flag && flag2;
			}
			return flag;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_HasTarget : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasTarget", 0);
		try
		{
			BaseEntity target;
			return base.Senses.FindTarget(out target);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

internal abstract class FSMSlowTransitionBase : FSMTransitionBase
{
	private bool cachedEvalResult;

	private double? lastEvalTime;

	private double cacheLifeTime = 1.0;

	protected sealed override bool EvaluateInternal()
	{
		double timeAsDouble = Time.timeAsDouble;
		if (!lastEvalTime.HasValue || timeAsDouble - lastEvalTime.Value > cacheLifeTime)
		{
			cachedEvalResult = EvaluateAtInterval();
			lastEvalTime = timeAsDouble;
		}
		return cachedEvalResult;
	}

	protected abstract bool EvaluateAtInterval();
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_CanReachTarget_Slow : FSMSlowTransitionBase
{
	protected override bool EvaluateAtInterval()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_CanReachTarget_Slow", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			return base.Agent.CanReach(targetPosition);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsTargetOnNavmesh_Slow : FSMSlowTransitionBase
{
	protected override bool EvaluateAtInterval()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_IsTargetOnNavmesh_Slow", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			Vector3 sample;
			return base.Agent.SamplePosition(targetPosition, out sample, 2f);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsHealthBelowPercentage : FSMTransitionBase
{
	[SerializeField]
	public float percentage = 0.25f;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsHealthBelowPercentage", 0);
		try
		{
			return Owner is BaseCombatEntity baseCombatEntity && baseCombatEntity.healthFraction < percentage;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} <{percentage * 100f}%";
	}
}


using System;
using ConVar;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_IsNavmeshReady : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsNavmeshReady", 0);
		try
		{
			return AI.move && base.Agent.IsNavmeshReady;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_InitialAlliesNotFighting : FSMTransitionBase
{
	[SerializeField]
	public float MinAllyHealthFraction = 0.3f;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_InitialAlliesNotFighting", 0);
		try
		{
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				base.Senses.GetInitialAllies((List<BaseEntity>)(object)val2);
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (!((Component)item).GetComponent<SenseComponent>().FindTarget(out var _) && (!(item is BaseCombatEntity baseCombatEntity) || !(baseCombatEntity.healthFraction < MinAllyHealthFraction)))
					{
						return true;
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_HasBlackboardBool : FSMTransitionBase
{
	[SerializeField]
	public string Key;

	private BlackboardComponent _blackboard;

	private BlackboardComponent Blackboard => _blackboard ?? (_blackboard = ((Component)Owner).GetComponent<BlackboardComponent>());

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasBlackboardBool", 0);
		try
		{
			return Blackboard.Has(Key);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return base.GetName() + " " + Key;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_BlackboardCounterGte : FSMTransitionBase
{
	[SerializeField]
	public string Key;

	[SerializeField]
	public int MinValue;

	private BlackboardComponent _blackboard;

	private BlackboardComponent Blackboard => _blackboard ?? (_blackboard = ((Component)Owner).GetComponent<BlackboardComponent>());

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasBlackboardBool", 0);
		try
		{
			if (!Blackboard.Count(Key, out var count))
			{
				return false;
			}
			return count >= MinValue;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {Key} >= {MinValue}";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_NoiseNearby : FSMTransitionBase
{
	[SerializeField]
	public float distance = 7f;

	protected override bool EvaluateInternal()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_NoiseNearby", 0);
		try
		{
			NpcNoiseEvent currentNoise = base.Senses.currentNoise;
			return currentNoise != null && Vector3.Distance(((Component)Owner).transform.position, currentNoise.Position) < distance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		base.OnTransitionTaken(from, to);
		if (base.Senses.currentNoise != null)
		{
			if (to is IParametrized<NpcNoiseEvent> parametrized)
			{
				parametrized.SetParameter(base.Senses.currentNoise);
			}
			base.Senses.ConsumeCurrentNoise();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} <{distance}m";
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_SeesFood : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_SeesFood", 0);
		try
		{
			BaseEntity food;
			return base.Senses.FindFood(out food);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_IsTargetInWater : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsTargetInWater", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			if (!target.ToNonNpcPlayer(out var _))
			{
				return false;
			}
			if (!base.Senses.GetVisibilityStatus(target, out var status))
			{
				return false;
			}
			return status.isInWaterCached;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_IsSwimming : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsSwimming", 0);
		try
		{
			return base.Agent.canSwim && base.Agent.IsSwimming;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsInWaterSlow : FSMSlowTransitionBase
{
	protected override bool EvaluateAtInterval()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_IsInWaterSlow", 0);
		try
		{
			if (base.Agent.canSwim)
			{
				return base.Agent.IsSwimming;
			}
			return WaterLevel.GetWaterDepth(((Component)Owner).transform.position, waves: false, volumes: false) >= 0.3f;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_TargetIsInSafeZone : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetIsInSafeZone", 0);
		try
		{
			BaseEntity target;
			return base.Senses.FindTarget(out target) && target.InSafeZone();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Diagnostics;
using ConVar;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Events;

[SoftRequireComponent(typeof(NavMeshAgent))]
public class LimitedTurnNavAgent : EntityComponent<BaseEntity>
{
	public enum Speeds
	{
		Sneak,
		Walk,
		Jog,
		Run,
		Sprint,
		FullSprint
	}

	[SerializeField]
	private NavMeshAgent agent;

	[SerializeField]
	[Header("Speed")]
	private float sneakSpeed = 0.6f;

	[SerializeField]
	private float walkSpeed = 0.89f;

	[SerializeField]
	private float jogSpeed = 2.45f;

	[SerializeField]
	private float runSpeed = 4.4f;

	[SerializeField]
	private float sprintSpeed = 6f;

	[SerializeField]
	private float fullSprintSpeed = 9f;

	[SerializeField]
	public bool canSwim;

	[SerializeField]
	private float swimSpeed = 0.6f;

	[SerializeField]
	private float swimSprintSpeed = 0.89f;

	public ResettableFloat desiredSwimDepth = new ResettableFloat(0.7f);

	public ResettableFloat acceleration = new ResettableFloat(10f);

	public ResettableFloat deceleration = new ResettableFloat(2f);

	[SerializeField]
	private float maxTurnRadius = 2f;

	[SerializeField]
	private Enum preferedTopology = (Enum)537002081;

	[SerializeField]
	private Enum preferedBiome = (Enum)15;

	public const BaseEntity.Flags FLAG_IS_SWIMMING = BaseEntity.Flags.Reserved1;

	public const BaseEntity.Flags FLAG_IS_JUMPING = BaseEntity.Flags.Reserved2;

	private const float emergencyDeceleration = 10f;

	private static NavMeshPath path;

	[NonSerialized]
	public UnityEvent onPathFailed = new UnityEvent();

	private LockState movementLock = new LockState();

	private bool isNavMeshReady;

	private int? lastFrameCall;

	private static ListHashSet<LimitedTurnNavAgent> steeringComponents = new ListHashSet<LimitedTurnNavAgent>();

	[NonSerialized]
	public float currentDeviation;

	[NonSerialized]
	public bool shouldStopAtDestination = true;

	private float cachedPathLength;

	private Vector3? previousLocalPosition;

	private float curSpeed;

	private float desiredSpeed;

	public bool IsSwimming
	{
		get
		{
			return base.baseEntity.flags.HasFlag(BaseEntity.Flags.Reserved1);
		}
		private set
		{
			base.baseEntity.SetFlag(BaseEntity.Flags.Reserved1, value);
		}
	}

	public bool IsJumping
	{
		get
		{
			return base.baseEntity.flags.HasFlag(BaseEntity.Flags.Reserved2);
		}
		set
		{
			base.baseEntity.SetFlag(BaseEntity.Flags.Reserved2, value);
		}
	}

	public Vector3 NavPosition => agent.nextPosition;

	public bool isPaused => movementLock.IsLocked;

	public bool IsNavmeshReady => isNavMeshReady;

	public Vector3? lastValidDestination { get; private set; }

	public float RemainingDistance => agent.remainingDistance;

	public bool IsFollowingPath
	{
		get
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			if (agent.hasPath)
			{
				return agent.remainingDistance > (shouldStopAtDestination ? ((Bounds)(ref base.baseEntity.bounds)).extents.z : maxTurnRadius);
			}
			return false;
		}
	}

	public LockState.LockHandle Pause()
	{
		if (!movementLock.IsLocked)
		{
			OnPaused();
		}
		return movementLock.AddLock();
	}

	public bool Unpause(ref LockState.LockHandle handle)
	{
		bool result = movementLock.RemoveLock(ref handle);
		if (!movementLock.IsLocked)
		{
			OnUnpaused();
		}
		return result;
	}

	public void Move(Vector3 offset)
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:Move", 0);
		try
		{
			if (AI.logIssues && lastFrameCall.HasValue && lastFrameCall == Time.frameCount)
			{
				StackTrace stackTrace = new StackTrace();
				Debug.LogError((object)("Move called multiple times in the same frame\n" + stackTrace.ToString()));
			}
			agent.Move(offset);
			lastFrameCall = Time.frameCount;
			if (canSwim)
			{
				Vector3 nextPosition = agent.nextPosition;
				WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(nextPosition, waves: false, volumes: false);
				IsSwimming = waterInfo.currentDepth > desiredSwimDepth.Value;
				if (IsSwimming)
				{
					nextPosition.y = ((Component)base.baseEntity).transform.position.y;
					nextPosition.y = Mathf.MoveTowards(nextPosition.y, waterInfo.surfaceLevel - desiredSwimDepth.Value, 1f * Time.deltaTime);
					nextPosition.y = Mathf.Max(nextPosition.y, waterInfo.terrainHeight);
					((Component)base.baseEntity).transform.position = nextPosition;
				}
				else
				{
					((Component)base.baseEntity).transform.position = agent.nextPosition;
				}
			}
			else
			{
				IsSwimming = false;
				((Component)base.baseEntity).transform.position = agent.nextPosition;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ResetPath()
	{
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:ResetPath", 0);
		try
		{
			shouldStopAtDestination = true;
			acceleration.Reset();
			deceleration.Reset();
			currentDeviation = 0f;
			SetSpeed(0f);
			if (agent.hasPath)
			{
				agent.ResetPath();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool CanReach(Vector3 location, bool resetPathOnFailure = false)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Invalid comparison between Unknown and I4
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:CanReach", 0);
		try
		{
			if (!IsPositionOnNavmesh(location, out var sample))
			{
				FailPath(location, null, resetPathOnFailure);
				return false;
			}
			if (!CalculatePathCustom(sample, path))
			{
				FailPath(sample, path, resetPathOnFailure);
				return false;
			}
			bool flag = (int)path.status == 0;
			if (!flag)
			{
				FailPath(sample, path, resetPathOnFailure);
			}
			else if (flag && resetPathOnFailure)
			{
				lastValidDestination = path.GetDestination();
			}
			return flag;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool SetDestination(Vector3 newDestination, bool resetPathOnFailure = false)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:SetDestination", 0);
		try
		{
			if (shouldStopAtDestination && agent.hasPath && Vector3.Distance(agent.destination, newDestination) < 1f)
			{
				return true;
			}
			if (!CalculatePathCustom(newDestination, path))
			{
				FailPath(newDestination, path, resetPathOnFailure);
				return false;
			}
			if ((int)path.status != 0)
			{
				FailPath(newDestination, path, resetPathOnFailure);
				return false;
			}
			SetPath(path);
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void InitShared()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Expected O, but got Unknown
		base.InitShared();
		if (path == null)
		{
			path = new NavMeshPath();
		}
	}

	private void OnPaused()
	{
		if (((Behaviour)agent).enabled && agent.isOnNavMesh)
		{
			ResetPath();
		}
	}

	private void OnUnpaused()
	{
	}

	private void SetPath(NavMeshPath newPath)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:SetPath", 0);
		try
		{
			if (agent.path != newPath)
			{
				agent.SetPath(newPath);
			}
			cachedPathLength = newPath.GetPathLength();
			lastValidDestination = newPath.GetDestination();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ShowFailedPath(Vector3? destination, NavMeshPath failedPath)
	{
	}

	private void FailPath(Vector3? destination, NavMeshPath failedPath = null, bool resetPathOnFailure = false)
	{
		ShowFailedPath(destination, failedPath);
		if (resetPathOnFailure)
		{
			onPathFailed.Invoke();
			ResetPath();
		}
	}

	private float GetSpeedForGait(Speeds gait)
	{
		return gait switch
		{
			Speeds.Sneak => sneakSpeed, 
			Speeds.Walk => walkSpeed, 
			Speeds.Jog => jogSpeed, 
			Speeds.Run => runSpeed, 
			Speeds.Sprint => sprintSpeed, 
			Speeds.FullSprint => fullSprintSpeed, 
			_ => walkSpeed, 
		};
	}

	public void SetSpeed(Speeds gait)
	{
		SetSpeed(GetSpeedForGait(gait));
	}

	public bool IsSpeedGTE(Speeds minGait)
	{
		return curSpeed >= GetSpeedForGait(minGait) - 0.01f;
	}

	public void SetSpeed(float speed)
	{
		desiredSpeed = speed;
	}

	public void SetSpeedRatio(float ratio, Speeds minSpeed = Speeds.Sneak, Speeds maxSpeed = Speeds.Sprint, int offset = 0)
	{
		int num = Mathf.FloorToInt(Mathf.Lerp((float)minSpeed, (float)maxSpeed, ratio));
		num = Mathf.Clamp(num + offset, (int)minSpeed, (int)maxSpeed);
		SetSpeed((Speeds)num);
	}

	private void OnEnable()
	{
		steeringComponents.TryAdd(this);
	}

	private void OnDisable()
	{
		steeringComponents.Remove(this);
	}

	public static void TickSteering()
	{
		for (int num = steeringComponents.Count - 1; num >= 0; num--)
		{
			LimitedTurnNavAgent limitedTurnNavAgent = steeringComponents[num];
			if (limitedTurnNavAgent.IsUnityNull() || !limitedTurnNavAgent.baseEntity.IsValid())
			{
				steeringComponents.RemoveAt(num);
			}
			else
			{
				limitedTurnNavAgent.Tick();
			}
		}
	}

	private void Tick()
	{
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:Tick", 0);
		try
		{
			try
			{
				if (!AI.move)
				{
					return;
				}
				if (!isNavMeshReady)
				{
					isNavMeshReady = (Object)(object)agent != (Object)null && ((Behaviour)agent).enabled && agent.isOnNavMesh;
					if (!isNavMeshReady)
					{
						return;
					}
					agent.updateRotation = false;
					agent.updatePosition = false;
					agent.updateUpAxis = false;
					agent.isStopped = true;
				}
				if (movementLock.IsLocked)
				{
					if (previousLocalPosition.HasValue)
					{
						Vector3 val2 = ((Component)base.baseEntity).transform.localPosition - previousLocalPosition.Value;
						curSpeed = ((Vector3)(ref val2)).magnitude / Time.deltaTime;
					}
					return;
				}
				if (IsSwimming && curSpeed > swimSprintSpeed)
				{
					if (AI.logIssues)
					{
						Debug.LogError((object)$"Speed is too high: {curSpeed}/{swimSprintSpeed}");
					}
					curSpeed = swimSpeed;
				}
				else if (!IsSwimming && curSpeed > fullSprintSpeed)
				{
					if (AI.logIssues)
					{
						Debug.LogError((object)$"Speed is too high: {curSpeed}/{fullSprintSpeed}");
					}
					curSpeed = fullSprintSpeed;
				}
				if (!shouldStopAtDestination || IsFollowingPath)
				{
					SteerTowardsWaypoint();
					return;
				}
				curSpeed = Mathf.Max(desiredSpeed, curSpeed - 10f * Time.deltaTime);
				ResetPath();
			}
			finally
			{
				previousLocalPosition = ((Component)base.baseEntity).transform.localPosition;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static float GetBrakingDistance(float speed, float brakingDeceleration)
	{
		float num = speed / Mathf.Max(brakingDeceleration, 0.001f);
		return 0.5f * brakingDeceleration * num * num;
	}

	private float AdjustSpeedForSwimming(float speed)
	{
		if (!IsSwimming || speed <= 0f)
		{
			return speed;
		}
		if (!(speed < sprintSpeed))
		{
			return swimSprintSpeed;
		}
		return swimSpeed;
	}

	private void SteerTowardsWaypoint()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SteerTowardsWaypoint", 0);
		try
		{
			Transform transform = ((Component)base.baseEntity).transform;
			Vector3 val2 = agent.steeringTarget - transform.position;
			Vector3 val3 = ((Vector3)(ref val2)).normalized;
			if (Mathf.Abs(cachedPathLength - Vector3.Distance(transform.position, agent.destination)) < 5f)
			{
				val3 = Quaternion.AngleAxis(currentDeviation, Vector3.up) * val3;
			}
			float num = AdjustSpeedForSwimming(desiredSpeed);
			if (shouldStopAtDestination && agent.remainingDistance - maxTurnRadius < GetBrakingDistance(curSpeed, deceleration.Value))
			{
				curSpeed = Mathf.Max(1f, curSpeed - deceleration.Value * Time.deltaTime);
			}
			else if (curSpeed > num)
			{
				float num2 = (curSpeed - num) / deceleration.Value;
				float num3 = ((curSpeed > walkSpeed && num2 > 1f) ? 10f : deceleration.Value);
				curSpeed = Mathf.Max(num, curSpeed - num3 * Time.deltaTime);
			}
			else if (curSpeed < num)
			{
				curSpeed = Mathf.Min(num, curSpeed + acceleration.Value * Time.deltaTime);
			}
			agent.isStopped = true;
			if (!(((Vector3)(ref val3)).magnitude < 0.01f))
			{
				float num4 = (shouldStopAtDestination ? Mathx.RemapValClamped(agent.remainingDistance, maxTurnRadius * 2f, 0f, maxTurnRadius, 0.001f) : maxTurnRadius);
				float num5 = curSpeed / num4;
				Vector3 val4 = Vector3.RotateTowards(transform.forward, val3, num5 * Time.deltaTime, 0f);
				Vector3 offset = val4 * (curSpeed * Time.deltaTime);
				transform.rotation = Quaternion.LookRotation(Vector3Ex.WithY(val4, 0f));
				Move(offset);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionOnNavmesh(Vector3 position, out Vector3 sample)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return SamplePosition(position, out sample, 0.5f);
	}

	public bool SampleGroundPositionWithPhysics(Vector3 position, out RaycastHit hitInfo, float maxDistance = 2f, float radius = 0f, int layerMask = 1503731969)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SampleGroundPositionWithPhysics", 0);
		try
		{
			Vector3 val2 = position + Vector3.up * radius * 1.5f;
			float maxDistance2 = maxDistance + radius * 1.5f;
			if (!GamePhysics.TraceRealm(GamePhysics.Realm.Server, new Ray(val2, Vector3.down), radius, out hitInfo, maxDistance2, layerMask, (QueryTriggerInteraction)1))
			{
				((RaycastHit)(ref hitInfo)).point = position;
				return false;
			}
			if (radius > 0f && ((RaycastHit)(ref hitInfo)).distance <= 0f)
			{
				((RaycastHit)(ref hitInfo)).point = position;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionOnFavoredTerrain(Vector3 position)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionOnFavoredTerrain", 0);
		try
		{
			return IsPositionAtTopologyRequirement(position, preferedTopology) && IsPositionABiomeRequirement(position, preferedBiome);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionAtTopologyRequirement(Vector3 position, Enum topologyRequirement)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionAtTopologyRequirement", 0);
		try
		{
			if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
			{
				return false;
			}
			Enum val2 = (Enum)TerrainMeta.TopologyMap.GetTopology(position);
			if ((topologyRequirement & val2) == 0)
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionABiomeRequirement(Vector3 position, Enum biomeRequirement)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionABiomeRequirement", 0);
		try
		{
			if ((int)biomeRequirement == 0)
			{
				return true;
			}
			if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
			{
				return false;
			}
			Enum val2 = (Enum)TerrainMeta.BiomeMap.GetBiomeMaxType(position);
			if ((biomeRequirement & val2) == 0)
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsInWater(Vector3 position)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsInWater", 0);
		try
		{
			if (WaterLevel.GetOverallWaterDepth(position, waves: false, volumes: false) >= 0.3f)
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool SamplePosition(Vector3 position, out Vector3 sample, float maxDistance)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SamplePosition", 0);
		try
		{
			sample = position;
			NavMeshHit val2 = default(NavMeshHit);
			if (!NavMesh.SamplePosition(position, ref val2, maxDistance, agent.areaMask))
			{
				return false;
			}
			sample = ((NavMeshHit)(ref val2)).position;
			return ((NavMeshHit)(ref val2)).hit;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool Raycast(Vector3 targetPosition, out NavMeshHit hitInfo)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Raycast", 0);
		try
		{
			return agent.Raycast(targetPosition, ref hitInfo);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool CalculatePathCustom(Vector3 destination, NavMeshPath path)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("CalculatePathCustom", 0);
		try
		{
			return agent.CalculatePath(destination, path);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public enum Speeds
{
	Sneak,
	Walk,
	Jog,
	Run,
	Sprint,
	FullSprint
}


using System;
using UnityEngine;
using UnityEngine.AI;

public static class NavMeshPathEx
{
	private static Vector3[] cornersBuffer = (Vector3[])(object)new Vector3[128];

	public static float GetPathLength(this NavMeshPath path)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetPathLength", 0);
		try
		{
			float num = 0f;
			int cornersNonAlloc = path.GetCornersNonAlloc(cornersBuffer);
			if (cornersNonAlloc < 2)
			{
				return num;
			}
			for (int i = 0; i < cornersNonAlloc - 1; i++)
			{
				num += Vector3.Distance(cornersBuffer[i], cornersBuffer[i + 1]);
			}
			return num;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetOrigin(this NavMeshPath path)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetOrigin", 0);
		try
		{
			if (path.GetCornersNonAlloc(cornersBuffer) < 1)
			{
				return Vector3.zero;
			}
			return cornersBuffer[0];
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetDestination(this NavMeshPath path)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetDestination", 0);
		try
		{
			int cornersNonAlloc = path.GetCornersNonAlloc(cornersBuffer);
			if (cornersNonAlloc < 1)
			{
				return Vector3.zero;
			}
			return cornersBuffer[cornersNonAlloc - 1];
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using ConVar;
using Rust;
using UnityEngine;

public class BaseNPC2 : BaseCombatEntity
{
	[SerializeField]
	private float mass = 45f;

	public override bool IsNpc => true;

	public bool IsAnimal => true;

	public override float RealisticMass => mass;

	public string displayName
	{
		get
		{
			PrefabInformation prefabInformation = null;
			if (base.isServer)
			{
				prefabInformation = PrefabAttribute.server.Find<PrefabInformation>(prefabID);
			}
			if (prefabInformation == null)
			{
				if (AI.logIssues)
				{
					Debug.LogError((object)("PrefabInformation not found for " + Categorize() + ")"));
				}
				return "NPC";
			}
			return prefabInformation.title.english;
		}
	}

	public override float MaxVelocity()
	{
		return 10f;
	}

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			Query.Server.AddBrain(this);
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer && !Application.isQuitting)
		{
			Query.Server.RemoveBrain(this);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

[SoftRequireComponent(typeof(SenseComponent))]
public class NPCEncounterTimer : EntityComponent<BaseEntity>, IServerComponent
{
	public float giveUpDurationSeconds = 120f;

	[NonSerialized]
	public UnityEvent onShouldGiveUp = new UnityEvent();

	private const float fireTimeMultiplier = 4f;

	private const float mountedTimeMultiplier = 12f;

	private float? encounterRemainingTimeSeconds;

	private double? _lastTickTime;

	private SenseComponent _senseComponent;

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	private SenseComponent Senses => _senseComponent ?? (_senseComponent = ((Component)base.baseEntity).GetComponent<SenseComponent>());

	public void Tick()
	{
		float num = (float)(Time.timeAsDouble - LastTickTime);
		LastTickTime = Time.timeAsDouble;
		BaseEntity target;
		bool flag = Senses.FindTarget(out target);
		if (encounterRemainingTimeSeconds.HasValue && !flag)
		{
			encounterRemainingTimeSeconds = null;
		}
		else if (!encounterRemainingTimeSeconds.HasValue && flag)
		{
			StartTimer();
		}
		else
		{
			if (!encounterRemainingTimeSeconds.HasValue)
			{
				return;
			}
			if (base.baseEntity is BaseCombatEntity { SecondsSinceAttacked: <5f })
			{
				StartTimer();
				PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					Senses.GetInitialAllies((List<BaseEntity>)(object)val);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val)
					{
						((Component)item).GetComponent<NPCEncounterTimer>().StartTimer();
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			float num2 = 1f;
			if (target.ToNonNpcPlayer(out var player) && player.isMounted)
			{
				num2 = 12f;
			}
			else if (Trans_TargetIsNearFire.Test(base.baseEntity, Senses))
			{
				num2 = 4f;
			}
			encounterRemainingTimeSeconds -= num * num2;
			if (!(encounterRemainingTimeSeconds <= 0f))
			{
				return;
			}
			GiveUp();
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				Senses.GetInitialAllies((List<BaseEntity>)(object)val2);
				foreach (BaseEntity item2 in (List<BaseEntity>)(object)val2)
				{
					((Component)item2).GetComponent<NPCEncounterTimer>().GiveUp();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
	}

	private void StartTimer()
	{
		encounterRemainingTimeSeconds = giveUpDurationSeconds;
	}

	private void GiveUp()
	{
		if (encounterRemainingTimeSeconds.HasValue)
		{
			encounterRemainingTimeSeconds = null;
			onShouldGiveUp.Invoke();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/AI/NPC team", fileName = "NPCTeam_new", order = 0)]
public class NPCTeam : BaseScriptableObject
{
}


using System;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(LimitedTurnNavAgent))]
public class RootMotionPlayer : EntityComponent<BaseEntity>, IServerComponent
{
	public struct Warp
	{
		public float startTime;

		public float endTime;

		public Vector3 translationScale;

		public float rotationScale;

		public Warp(float startTime, float endTime, Vector3 translationScale, float rotationScale = 1f)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			this.startTime = startTime;
			this.endTime = endTime;
			this.translationScale = translationScale;
			this.rotationScale = rotationScale;
		}
	}

	public class PlayServerState : IPooled
	{
		public AnimationClip animClip;

		public RootMotionData rmData;

		public float elapsedTime;

		public Vector3 initialLocation;

		public Quaternion initialRotation;

		public Action ServerTickAction;

		public Warp[] warps;

		public bool constrainToNavmesh;

		public Vector3 lastUnscaledOffset;

		public float lastUnscaledRotation;

		public bool isPlaying;

		public void Reset()
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			isPlaying = false;
			rmData = null;
			animClip = null;
			initialRotation = Quaternion.identity;
			warps = null;
			constrainToNavmesh = true;
			elapsedTime = 0f;
			ServerTickAction = null;
			lastUnscaledOffset = Vector3.zero;
			lastUnscaledRotation = 0f;
		}

		void IPooled.EnterPool()
		{
			Reset();
		}

		void IPooled.LeavePool()
		{
			Reset();
		}

		public static PlayServerState TakeFromPool(RootMotionData data, Transform transform)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			PlayServerState playServerState = Pool.Get<PlayServerState>();
			playServerState.rmData = data;
			playServerState.initialLocation = transform.position;
			playServerState.initialRotation = transform.rotation;
			return playServerState;
		}

		public static PlayServerState TakeFromPool(AnimationClip data, Transform transform)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			PlayServerState playServerState = Pool.Get<PlayServerState>();
			playServerState.animClip = data;
			playServerState.initialLocation = transform.position;
			playServerState.initialRotation = transform.rotation;
			return playServerState;
		}

		public int GetAnimHash()
		{
			if (rmData != null)
			{
				if ((Object)(object)rmData.inPlaceAnimation == (Object)null)
				{
					Debug.LogError((object)("RootMotionPlayer.PlayServer: rmData.inPlaceAnimation is null for " + ((Object)rmData).name));
				}
				return Animator.StringToHash(((Object)rmData.inPlaceAnimation).name);
			}
			if ((Object)(object)animClip == (Object)null)
			{
				Debug.LogError((object)"RootMotionPlayer.PlayServer: animClip is null");
			}
			return Animator.StringToHash(((Object)animClip).name);
		}

		public float GetAnimLength()
		{
			if (!(rmData != null))
			{
				return animClip.length;
			}
			return rmData.inPlaceAnimation.length;
		}

		public bool Step(float deltaTime, ref Vector3 location, ref Quaternion rotation, float rootBoneLocalZOffset = 0f)
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_018a: Unknown result type (might be due to invalid IL or missing references)
			//IL_018f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			//IL_0195: Unknown result type (might be due to invalid IL or missing references)
			//IL_0199: Unknown result type (might be due to invalid IL or missing references)
			//IL_019f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0209: Unknown result type (might be due to invalid IL or missing references)
			//IL_020e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0213: Unknown result type (might be due to invalid IL or missing references)
			//IL_0218: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_014b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0162: Unknown result type (might be due to invalid IL or missing references)
			if (elapsedTime >= GetAnimLength())
			{
				return false;
			}
			if (rmData == null)
			{
				elapsedTime += deltaTime;
				return elapsedTime < GetAnimLength() - 0.25f;
			}
			Vector3 zero = Vector3.zero;
			zero.x = rmData.xMotionCurve.Evaluate(elapsedTime);
			zero.y = (constrainToNavmesh ? 0f : rmData.yMotionCurve.Evaluate(elapsedTime));
			zero.z = rmData.zMotionCurve.Evaluate(elapsedTime);
			float num = rmData.yRotationCurve.Evaluate(elapsedTime);
			Vector3 val = zero - lastUnscaledOffset;
			float num2 = num - lastUnscaledRotation;
			lastUnscaledOffset = zero;
			lastUnscaledRotation = num;
			if (warps != null)
			{
				Warp[] array = warps;
				for (int i = 0; i < array.Length; i++)
				{
					Warp warp = array[i];
					if (warp.startTime <= elapsedTime && elapsedTime <= warp.endTime)
					{
						val.x *= warp.translationScale.x;
						val.y *= warp.translationScale.y;
						val.z *= warp.translationScale.z;
						num2 *= warp.rotationScale;
					}
				}
			}
			Vector3 val2 = initialRotation * val;
			location -= rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
			location += val2;
			rotation *= Quaternion.Euler(0f, num2, 0f);
			location += rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
			elapsedTime += deltaTime;
			return elapsedTime < GetAnimLength() - 0.25f;
		}

		public Quaternion Track(Vector3 ownerPos, Vector3 targetPos, Quaternion rotation, float trackingSpeed, float deltaTime)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Vector3Ex.NormalizeXZ(targetPos - ownerPos);
			initialRotation = Quaternion.RotateTowards(initialRotation, Quaternion.LookRotation(val, Vector3.up), trackingSpeed * deltaTime);
			rotation *= Quaternion.Inverse(rotation) * initialRotation;
			return rotation;
		}
	}

	[SerializeField]
	private float rootBoneLocalZOffset;

	private LimitedTurnNavAgent _agent;

	private PlayServerState currentPlayState;

	private Action _playServerTickAction;

	private LockState.LockHandle lockHandle;

	private LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>());

	private Action PlayServerTickAction => PlayServerTick;

	public PlayServerState PlayServerAndTakeFromPool(RootMotionData data)
	{
		PlayServerState playServerState = PlayServerState.TakeFromPool(data, ((Component)base.baseEntity).transform);
		PlayServer(playServerState);
		return playServerState;
	}

	public PlayServerState PlayServerAndTakeFromPool(AnimationClip data)
	{
		PlayServerState playServerState = PlayServerState.TakeFromPool(data, ((Component)base.baseEntity).transform);
		PlayServer(playServerState);
		return playServerState;
	}

	public void PlayServer(PlayServerState state)
	{
		if (AI.logIssues && state.rmData == null && (Object)(object)state.animClip == (Object)null)
		{
			Debug.LogError((object)"RootMotionPlayer.PlayServer: state.rmData and state.animClip are both null");
			return;
		}
		if (currentPlayState != null)
		{
			StopServer(currentPlayState);
		}
		currentPlayState = state;
		currentPlayState.isPlaying = true;
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayMontageDelayed"), currentPlayState.GetAnimHash());
		lockHandle = Agent.Pause();
		((FacepunchBehaviour)base.baseEntity).InvokeRepeating(PlayServerTickAction, 0f, 0f);
	}

	public void PlayServerAdditive(AnimationClip animClip)
	{
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayAdditiveMontage"), Animator.StringToHash(((Object)animClip).name));
	}

	private void PlayServerTick()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("RootMotionPlayer:PlayServerTick", 0);
		try
		{
			Vector3 location = ((Component)base.baseEntity).transform.position;
			Quaternion rotation = ((Component)base.baseEntity).transform.rotation;
			bool num = !currentPlayState.Step(Time.deltaTime, ref location, ref rotation, rootBoneLocalZOffset);
			if (currentPlayState.rmData != null)
			{
				if (currentPlayState.constrainToNavmesh)
				{
					Agent.Move(location - ((Component)base.baseEntity).transform.position);
				}
				else
				{
					((Component)base.baseEntity).transform.position = location;
				}
				((Component)base.baseEntity).transform.rotation = rotation;
			}
			if (num)
			{
				StopServer(currentPlayState, interrupt: false);
				currentPlayState = null;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Track(Vector3 targetPos, float trackingSpeed = 45f, float? timeStep = null)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (currentPlayState != null && !(currentPlayState.rmData == null))
		{
			if (!timeStep.HasValue)
			{
				timeStep = Time.deltaTime;
			}
			((Component)base.baseEntity).transform.rotation = currentPlayState.Track(((Component)this).transform.position, targetPos, ((Component)base.baseEntity).transform.rotation, trackingSpeed, timeStep.Value);
		}
	}

	private void StopServer(PlayServerState state, bool interrupt = true)
	{
		if (state != null && state.isPlaying)
		{
			state.isPlaying = false;
			if (state == currentPlayState)
			{
				((FacepunchBehaviour)base.baseEntity).CancelInvoke(PlayServerTickAction);
				Agent.Unpause(ref lockHandle);
				currentPlayState = null;
			}
			if (interrupt)
			{
				base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_StopMontage"));
			}
		}
	}

	public void StopServerAndReturnToPool(ref PlayServerState state, bool interrupt = true)
	{
		if (state != null)
		{
			StopServer(state, interrupt);
			Pool.Free<PlayServerState>(ref state);
		}
	}
}


using UnityEngine;

public struct Warp
{
	public float startTime;

	public float endTime;

	public Vector3 translationScale;

	public float rotationScale;

	public Warp(float startTime, float endTime, Vector3 translationScale, float rotationScale = 1f)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		this.startTime = startTime;
		this.endTime = endTime;
		this.translationScale = translationScale;
		this.rotationScale = rotationScale;
	}
}


using System;
using Facepunch;
using UnityEngine;

public class PlayServerState : IPooled
{
	public AnimationClip animClip;

	public RootMotionData rmData;

	public float elapsedTime;

	public Vector3 initialLocation;

	public Quaternion initialRotation;

	public Action ServerTickAction;

	public Warp[] warps;

	public bool constrainToNavmesh;

	public Vector3 lastUnscaledOffset;

	public float lastUnscaledRotation;

	public bool isPlaying;

	public void Reset()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		isPlaying = false;
		rmData = null;
		animClip = null;
		initialRotation = Quaternion.identity;
		warps = null;
		constrainToNavmesh = true;
		elapsedTime = 0f;
		ServerTickAction = null;
		lastUnscaledOffset = Vector3.zero;
		lastUnscaledRotation = 0f;
	}

	void IPooled.EnterPool()
	{
		Reset();
	}

	void IPooled.LeavePool()
	{
		Reset();
	}

	public static PlayServerState TakeFromPool(RootMotionData data, Transform transform)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		PlayServerState playServerState = Pool.Get<PlayServerState>();
		playServerState.rmData = data;
		playServerState.initialLocation = transform.position;
		playServerState.initialRotation = transform.rotation;
		return playServerState;
	}

	public static PlayServerState TakeFromPool(AnimationClip data, Transform transform)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		PlayServerState playServerState = Pool.Get<PlayServerState>();
		playServerState.animClip = data;
		playServerState.initialLocation = transform.position;
		playServerState.initialRotation = transform.rotation;
		return playServerState;
	}

	public int GetAnimHash()
	{
		if (rmData != null)
		{
			if ((Object)(object)rmData.inPlaceAnimation == (Object)null)
			{
				Debug.LogError((object)("RootMotionPlayer.PlayServer: rmData.inPlaceAnimation is null for " + ((Object)rmData).name));
			}
			return Animator.StringToHash(((Object)rmData.inPlaceAnimation).name);
		}
		if ((Object)(object)animClip == (Object)null)
		{
			Debug.LogError((object)"RootMotionPlayer.PlayServer: animClip is null");
		}
		return Animator.StringToHash(((Object)animClip).name);
	}

	public float GetAnimLength()
	{
		if (!(rmData != null))
		{
			return animClip.length;
		}
		return rmData.inPlaceAnimation.length;
	}

	public bool Step(float deltaTime, ref Vector3 location, ref Quaternion rotation, float rootBoneLocalZOffset = 0f)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		if (elapsedTime >= GetAnimLength())
		{
			return false;
		}
		if (rmData == null)
		{
			elapsedTime += deltaTime;
			return elapsedTime < GetAnimLength() - 0.25f;
		}
		Vector3 zero = Vector3.zero;
		zero.x = rmData.xMotionCurve.Evaluate(elapsedTime);
		zero.y = (constrainToNavmesh ? 0f : rmData.yMotionCurve.Evaluate(elapsedTime));
		zero.z = rmData.zMotionCurve.Evaluate(elapsedTime);
		float num = rmData.yRotationCurve.Evaluate(elapsedTime);
		Vector3 val = zero - lastUnscaledOffset;
		float num2 = num - lastUnscaledRotation;
		lastUnscaledOffset = zero;
		lastUnscaledRotation = num;
		if (warps != null)
		{
			Warp[] array = warps;
			for (int i = 0; i < array.Length; i++)
			{
				Warp warp = array[i];
				if (warp.startTime <= elapsedTime && elapsedTime <= warp.endTime)
				{
					val.x *= warp.translationScale.x;
					val.y *= warp.translationScale.y;
					val.z *= warp.translationScale.z;
					num2 *= warp.rotationScale;
				}
			}
		}
		Vector3 val2 = initialRotation * val;
		location -= rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
		location += val2;
		rotation *= Quaternion.Euler(0f, num2, 0f);
		location += rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
		elapsedTime += deltaTime;
		return elapsedTime < GetAnimLength() - 0.25f;
	}

	public Quaternion Track(Vector3 ownerPos, Vector3 targetPos, Quaternion rotation, float trackingSpeed, float deltaTime)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.NormalizeXZ(targetPos - ownerPos);
		initialRotation = Quaternion.RotateTowards(initialRotation, Quaternion.LookRotation(val, Vector3.up), trackingSpeed * deltaTime);
		rotation *= Quaternion.Inverse(rotation) * initialRotation;
		return rotation;
	}
}


using UnityEngine;

public class RootMotionTester : MonoBehaviour
{
	public RootMotionData anim;

	public Transform target;

	public float timeStep = 0.1f;

	public float trackingSpeed = 90f;

	public float trackingDuration = 1f;

	public float rotArrowLength = 0.2f;

	public float targetVelocityYaw = 45f;

	public float targetVelocityMagnitude = 5f;

	public int trackingStepIndex;

	public float parentFrontOffset;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust.Ai;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class SenseComponent : EntityComponent<BaseEntity>
{
	[Serializable]
	public struct Cone
	{
		public float halfAngle;

		public float range;

		public Cone(float halfAngle = 80f, float range = 10f)
		{
			this.halfAngle = halfAngle;
			this.range = range;
		}
	}

	public class VisibilityStatus : IPooled
	{
		private BaseEntity baseEntity;

		private BaseEntity targetEntity;

		public Vector3 lastKnownPosition;

		private const float waterCheckInterval = 1f;

		private double? lastTimeInWaterUpdated;

		public float timeVisible { get; private set; }

		public float timeNotVisible { get; private set; }

		public bool isVisible => timeVisible > 0f;

		public float timeWatched { get; private set; }

		public float timeNotWatched { get; private set; }

		public float timeAimedAt { get; private set; }

		public float timeNotAimedAt { get; private set; }

		public WaterLevel.WaterInfo? lastWaterInfo { get; private set; }

		public bool isInWaterCached
		{
			get
			{
				//IL_0093: Unknown result type (might be due to invalid IL or missing references)
				//IL_009d: Unknown result type (might be due to invalid IL or missing references)
				//IL_008c: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
				if (!targetEntity.ToNonNpcPlayer(out var player))
				{
					return false;
				}
				if (!lastWaterInfo.HasValue || !lastTimeInWaterUpdated.HasValue || Time.timeAsDouble - lastTimeInWaterUpdated > 1.0)
				{
					BaseMountable entAsT;
					Vector3 val = (((Object)(object)player.GetMounted()).Is<BaseMountable>(out entAsT) ? (Vector3.down * 0.5f) : Vector3.zero);
					lastWaterInfo = WaterLevel.GetWaterInfo(((Component)targetEntity).transform.position + val, waves: false, volumes: false);
					lastTimeInWaterUpdated = Time.timeAsDouble;
				}
				return lastWaterInfo.Value.currentDepth >= 0.3f;
			}
		}

		private void Reset()
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			targetEntity = null;
			baseEntity = null;
			timeWatched = 0f;
			timeNotWatched = 100f;
			timeAimedAt = 0f;
			timeNotAimedAt = 100f;
			timeVisible = 0f;
			timeNotVisible = 100f;
			lastKnownPosition = Vector3.zero;
			lastWaterInfo = null;
			lastTimeInWaterUpdated = null;
		}

		public void EnterPool()
		{
			Reset();
		}

		public void LeavePool()
		{
			Reset();
		}

		public static VisibilityStatus GetFromPool(BaseEntity baseEntity, BaseEntity targetEntity, float deltaTime, Vector3? lastKnownPositionOverride = null)
		{
			VisibilityStatus visibilityStatus = Pool.Get<VisibilityStatus>();
			visibilityStatus.baseEntity = baseEntity;
			visibilityStatus.targetEntity = targetEntity;
			visibilityStatus.UpdateVisibility(isVisible: true, deltaTime, lastKnownPositionOverride);
			return visibilityStatus;
		}

		private bool CheckValid()
		{
			if (!baseEntity.IsValid() || !targetEntity.IsValid())
			{
				if (AI.logIssues)
				{
					Debug.LogError((object)$"SenseComponent:UpdateVisibility NRE: {baseEntity} {targetEntity}");
				}
				return false;
			}
			return true;
		}

		public void UpdateVisibility(bool isVisible, float deltaTime, Vector3? lastKnownPositionOverride = null)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			if (!CheckValid())
			{
				return;
			}
			if (lastKnownPositionOverride.HasValue)
			{
				lastKnownPosition = lastKnownPositionOverride.Value;
			}
			else if (isVisible)
			{
				lastKnownPosition = ((Component)targetEntity).transform.position;
			}
			if (isVisible)
			{
				timeNotVisible = 0f;
				timeVisible += deltaTime;
				Vector3 val = ((Component)targetEntity).transform.forward;
				Vector3 position = ((Component)targetEntity).transform.position;
				if (targetEntity.ToNonNpcPlayer(out var player))
				{
					val = player.eyes.HeadForward();
					position = player.eyes.position;
				}
				Vector3 val2 = ((Component)baseEntity).transform.position - position;
				float num = Mathf.Acos(Vector3.Dot(val, ((Vector3)(ref val2)).normalized)) * 57.29578f * 2f;
				bool num2 = num < AI.watchedAngle;
				if (num2)
				{
					timeNotWatched = 0f;
					timeWatched += deltaTime;
				}
				else
				{
					timeWatched = 0f;
					timeNotWatched += deltaTime;
				}
				if (num2 && (Object)(object)player != (Object)null && player.modelState.aiming && num < AI.aimedAtAngle && !(player.GetHeldEntity() is BaseMelee { canScareAiWhenAimed: false }))
				{
					timeNotAimedAt = 0f;
					timeAimedAt += deltaTime;
				}
				else
				{
					timeAimedAt = 0f;
					timeNotAimedAt += deltaTime;
				}
			}
			else
			{
				timeVisible = 0f;
				timeNotVisible += deltaTime;
				timeWatched = 0f;
				timeNotWatched += deltaTime;
				timeAimedAt = 0f;
				timeNotAimedAt += deltaTime;
			}
		}
	}

	[SerializeField]
	private Vector3 LongRangeVisionRectangle = new Vector3(6f, 30f, 60f);

	[SerializeField]
	private Cone ShortRangeVisionCone = new Cone(100f, 30f);

	[SerializeField]
	private float touchDistance = 6f;

	[SerializeField]
	private float noiseRangeMultiplier = 1f;

	[SerializeField]
	private float hearingRange = 50f;

	[SerializeField]
	private NPCTeam team;

	[NonSerialized]
	public ResettableFloat timeToForgetSightings = new ResettableFloat(30f);

	private const float timeToForgetNoises = 5f;

	private static HashSet<BaseEntity> entitiesUpdatedThisFrame = new HashSet<BaseEntity>();

	[ServerVar]
	public static float minRefreshIntervalSeconds = 0.2f;

	[ServerVar]
	public static float maxRefreshIntervalSeconds = 1f;

	private double? _lastTickTime;

	private double nextRefreshTime;

	private double spawnTime;

	private Dictionary<BaseEntity, double> _alliesWeAreAwareOf = new Dictionary<BaseEntity, double>(3);

	private Dictionary<BaseEntity, VisibilityStatus> entitiesWeAreAwareOf = new Dictionary<BaseEntity, VisibilityStatus>(8);

	private static readonly Dictionary<NpcNoiseIntensity, float> noiseRadii = new Dictionary<NpcNoiseIntensity, float>
	{
		{
			NpcNoiseIntensity.None,
			0f
		},
		{
			NpcNoiseIntensity.Low,
			10f
		},
		{
			NpcNoiseIntensity.Medium,
			20f
		},
		{
			NpcNoiseIntensity.High,
			50f
		}
	};

	private NpcNoiseEvent _currentNoise;

	[SerializeField]
	private float foodDetectionRange = 30f;

	private BaseEntity _nearestFood;

	[SerializeField]
	private float fireDetectionRange = 20f;

	[NonSerialized]
	public UnityEvent onFireMelee = new UnityEvent();

	private BaseEntity _nearestFire;

	private double? lastMeleeTime;

	[SerializeField]
	private float TargetingCooldown = 5f;

	private BaseEntity _target;

	private const float npcDistPenaltyToFavorTargetingPlayers = 10f;

	private double? lastTargetTime;

	private LockState lockState = new LockState();

	public float RefreshInterval
	{
		get
		{
			if (!ShouldRefreshFast)
			{
				return maxRefreshIntervalSeconds;
			}
			return minRefreshIntervalSeconds;
		}
	}

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	public bool HasPlayerInVicinity { get; private set; }

	public bool ShouldRefreshFast
	{
		get
		{
			if (!HasPlayerInVicinity)
			{
				if ((Object)(object)Target != (Object)null)
				{
					return Target.IsNonNpcPlayer();
				}
				return false;
			}
			return true;
		}
	}

	public NpcNoiseEvent currentNoise => _currentNoise;

	private BaseEntity Target
	{
		get
		{
			return _target;
		}
		set
		{
			if (base.baseEntity.isServer)
			{
				BaseEntity target = _target;
				_target = value;
				if ((Object)(object)target != (Object)(object)_target)
				{
					base.baseEntity.SendNetworkUpdate();
				}
			}
		}
	}

	private bool ChangedTargetRecently
	{
		get
		{
			if (lastTargetTime.HasValue)
			{
				return Time.timeAsDouble - lastTargetTime.Value < (double)TargetingCooldown;
			}
			return true;
		}
	}

	public void GetInitialAllies(List<BaseEntity> allies)
	{
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			foreach (var (baseEntity2, num2) in _alliesWeAreAwareOf)
			{
				if (!baseEntity2.IsValid() || (baseEntity2 is BaseCombatEntity baseCombatEntity && baseCombatEntity.IsDead()))
				{
					((List<BaseEntity>)(object)val).Add(baseEntity2);
				}
				else if (!(num2 - spawnTime > (double)(maxRefreshIntervalSeconds * 2f)))
				{
					allies.Add(baseEntity2);
				}
			}
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				_alliesWeAreAwareOf.Remove(item);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Vector3? GetLKP(BaseEntity entity)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (GetVisibilityStatus(entity, out var status))
		{
			return status.isVisible ? ((Component)entity).transform.position : status.lastKnownPosition;
		}
		return null;
	}

	public bool GetVisibilityStatus(BaseEntity entity, out VisibilityStatus status)
	{
		status = null;
		if (!CanTarget(entity))
		{
			return false;
		}
		if (!entitiesWeAreAwareOf.TryGetValue(entity, out status))
		{
			return false;
		}
		return true;
	}

	public bool Forget(BaseEntity entity)
	{
		if (!entitiesWeAreAwareOf.TryGetValue(entity, out var value))
		{
			return false;
		}
		entitiesWeAreAwareOf.Remove(entity);
		Pool.Free<VisibilityStatus>(ref value);
		return true;
	}

	public bool IsVisible(BaseEntity entity)
	{
		if (!GetVisibilityStatus(entity, out var status))
		{
			return false;
		}
		return status.isVisible;
	}

	public void GetSeenEntities(List<BaseEntity> perceivedEntities)
	{
		TimeWarning val = TimeWarning.New("SenseComponent:GetSeenEntities", 0);
		try
		{
			foreach (BaseEntity key in entitiesWeAreAwareOf.Keys)
			{
				if (IsVisible(key))
				{
					perceivedEntities.Add(key);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetOncePerceivedEntities(List<BaseEntity> perceivedEntities)
	{
		foreach (BaseEntity key in entitiesWeAreAwareOf.Keys)
		{
			if (GetVisibilityStatus(key, out var _))
			{
				perceivedEntities.Add(key);
			}
		}
	}

	private Matrix4x4 GetEyeTransform()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		return Matrix4x4.TRS(base.baseEntity.CenterPoint(), ((Component)base.baseEntity).transform.rotation, Vector3.one);
	}

	public override void InitShared()
	{
		base.InitShared();
		spawnTime = Time.timeAsDouble;
	}

	public override void Hurt(HitInfo hitInfo)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity initiator = hitInfo.Initiator;
		if (!CanTarget(initiator))
		{
			return;
		}
		Vector3 val = ((Component)initiator).transform.position + Quaternion.AngleAxis(Random.Range(0f, 360f), Vector3.up) * Vector3.forward * 5f;
		if (entitiesWeAreAwareOf.TryGetValue(initiator, out var value))
		{
			if (!value.isVisible && value.timeNotVisible > 3f)
			{
				value.lastKnownPosition = val;
			}
		}
		else
		{
			VisibilityStatus fromPool = VisibilityStatus.GetFromPool(base.baseEntity, initiator, 0.01f, val);
			entitiesWeAreAwareOf.Add(initiator, fromPool);
		}
	}

	public void Tick()
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:Tick", 0);
		try
		{
			double timeAsDouble = Time.timeAsDouble;
			if (timeAsDouble < nextRefreshTime)
			{
				return;
			}
			float deltaTime = (float)(timeAsDouble - LastTickTime);
			LastTickTime = timeAsDouble;
			HasPlayerInVicinity = false;
			entitiesUpdatedThisFrame.Clear();
			TimeWarning val2 = TimeWarning.New("SenseComponent:Tick:ProcessEntities", 0);
			try
			{
				PooledList<BaseEntity> val3 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					BaseEntity.Query.Server.GetPlayersAndBrainsInSphere(((Component)base.baseEntity).transform.position, LongRangeVisionRectangle.z, (List<BaseEntity>)(object)val3, BaseEntity.Query.DistanceCheckType.None);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val3)
					{
						if (!((Object)(object)item == (Object)(object)base.baseEntity))
						{
							if (item.IsNonNpcPlayer())
							{
								HasPlayerInVicinity = true;
							}
							if (InSameTeam(item) && !_alliesWeAreAwareOf.ContainsKey(item))
							{
								_alliesWeAreAwareOf.Add(item, timeAsDouble);
							}
							if (CanTarget(item))
							{
								UpdateEntityVisibility(item, deltaTime);
							}
						}
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			TimeWarning val4 = TimeWarning.New("SenseComponent:Tick:RemoveEntities", 0);
			try
			{
				PooledList<BaseEntity> val5 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					foreach (var (baseEntity2, visibilityStatus2) in entitiesWeAreAwareOf)
					{
						if (!CanTarget(baseEntity2))
						{
							((List<BaseEntity>)(object)val5).Add(baseEntity2);
						}
						else if (!visibilityStatus2.isVisible && visibilityStatus2.timeNotVisible > timeToForgetSightings.Value)
						{
							((List<BaseEntity>)(object)val5).Add(baseEntity2);
						}
						else if (!entitiesUpdatedThisFrame.Contains(baseEntity2) && visibilityStatus2.isVisible)
						{
							entitiesWeAreAwareOf[baseEntity2].UpdateVisibility(isVisible: false, deltaTime, null);
						}
					}
					entitiesUpdatedThisFrame.Clear();
					foreach (BaseEntity item2 in (List<BaseEntity>)(object)val5)
					{
						if (Target.IsValid() && (Object)(object)Target == (Object)(object)item2)
						{
							ClearTarget(forget: false);
						}
						Forget(item2);
					}
				}
				finally
				{
					((IDisposable)val5)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
			TickHearing(deltaTime);
			TickFoodDetection(deltaTime);
			TickFireDetection(deltaTime);
			TickTargeting(deltaTime);
			nextRefreshTime = Time.timeAsDouble + (double)RefreshInterval;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void GetModifiedSenses(BaseEntity entity, out float modTouchDistance, out float modHalfAngle, out float modShortVisionRange, out Vector3 modLongVisionRectangle)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		modTouchDistance = touchDistance;
		modHalfAngle = ShortRangeVisionCone.halfAngle;
		modShortVisionRange = ShortRangeVisionCone.range;
		modLongVisionRectangle = LongRangeVisionRectangle;
		if (entity.ToNonNpcPlayer(out var player))
		{
			if (player.IsDucked())
			{
				modTouchDistance = ((Bounds)(ref base.baseEntity.bounds)).extents.z * 1.5f;
				modHalfAngle = ShortRangeVisionCone.halfAngle * 0.85f;
				modShortVisionRange = ShortRangeVisionCone.range * 0.5f;
				modLongVisionRectangle = Vector3.Scale(LongRangeVisionRectangle, new Vector3(3f, 0.5f, 0.5f));
			}
			else if (player.IsRunning())
			{
				modTouchDistance = touchDistance * 3f;
				modHalfAngle = ShortRangeVisionCone.halfAngle;
				modShortVisionRange = ShortRangeVisionCone.range * 1.3f;
				modLongVisionRectangle = LongRangeVisionRectangle * 1.15f;
			}
		}
	}

	private bool IsInAnyRange(BaseEntity entity)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsInAnyRange", 0);
		try
		{
			Matrix4x4 eyeTransform = GetEyeTransform();
			Vector3 position = ((Matrix4x4)(ref eyeTransform)).GetPosition();
			eyeTransform = GetEyeTransform();
			Vector3 val2 = ((Matrix4x4)(ref eyeTransform)).rotation * Vector3.forward;
			Vector3 val3 = ((Component)entity).transform.position - position;
			float magnitude = ((Vector3)(ref val3)).magnitude;
			GetModifiedSenses(entity, out var modTouchDistance, out var modHalfAngle, out var modShortVisionRange, out var modLongVisionRectangle);
			if (magnitude < modTouchDistance)
			{
				return true;
			}
			if (Vector3.Angle(val2, ((Vector3)(ref val3)).normalized) < modHalfAngle)
			{
				if (magnitude < modShortVisionRange)
				{
					return true;
				}
				if (TOD_Sky.Instance.IsDay && magnitude < modLongVisionRectangle.z && Mathf.Abs(((Component)entity).transform.position.y - position.y) < modLongVisionRectangle.y * 0.5f)
				{
					Vector3 val4 = Vector3.Cross(val2, ((Component)entity).transform.position - position);
					if (((Vector3)(ref val4)).magnitude < modLongVisionRectangle.x * 0.5f)
					{
						return true;
					}
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void UpdateEntityVisibility(BaseEntity entity, float deltaTime)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		bool flag = IsInAnyRange(entity);
		if (flag && entity.ToNonNpcPlayer(out var player))
		{
			TimeWarning val = TimeWarning.New("SenseComponent:ProcessEntity:CanSee", 0);
			try
			{
				Matrix4x4 eyeTransform = GetEyeTransform();
				Vector3 position = ((Matrix4x4)(ref eyeTransform)).GetPosition();
				flag = base.baseEntity.CanSee(position, player.eyes.position);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (entitiesWeAreAwareOf.TryGetValue(entity, out var value))
		{
			value.UpdateVisibility(flag, deltaTime, null);
			entitiesUpdatedThisFrame.Add(entity);
		}
		else if (flag)
		{
			VisibilityStatus fromPool = VisibilityStatus.GetFromPool(base.baseEntity, entity, deltaTime, null);
			entitiesWeAreAwareOf.Add(entity, fromPool);
			entitiesUpdatedThisFrame.Add(entity);
		}
	}

	public bool InSameTeam(BaseEntity other)
	{
		if (team != null && ((Object)(object)((Component)other).GetComponent<SenseComponent>()).Is<SenseComponent>(out SenseComponent entAsT) && team == entAsT.team)
		{
			return true;
		}
		return base.baseEntity.InSameNpcTeam(other);
	}

	private void TickHearing(float deltaTime)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickHearing", 0);
		try
		{
			if (_currentNoise != null)
			{
				Pool.Free<NpcNoiseEvent>(ref _currentNoise);
			}
			if (noiseRangeMultiplier <= 0f)
			{
				return;
			}
			PooledList<NpcNoiseEvent> val2 = Pool.Get<PooledList<NpcNoiseEvent>>();
			try
			{
				SingletonComponent<NpcNoiseManager>.Instance.GetNoisesAround(((Component)base.baseEntity).transform.position, hearingRange, (List<NpcNoiseEvent>)(object)val2);
				NpcNoiseEvent npcNoiseEvent = null;
				float? num = null;
				foreach (NpcNoiseEvent item in (List<NpcNoiseEvent>)(object)val2)
				{
					if ((Object)(object)item.Initiator == (Object)(object)base.baseEntity || !CanTarget(item.Initiator))
					{
						continue;
					}
					float num2 = (float)(Time.timeAsDouble - item.EventTime);
					if (!(num2 > 5f) && (npcNoiseEvent == null || item.Intensity >= npcNoiseEvent.Intensity))
					{
						if (!noiseRadii.TryGetValue(item.Intensity, out var value))
						{
							Debug.LogError((object)$"Unknown noise intensity: {item.Intensity}");
						}
						else if (!(Vector3.Distance(item.Position, ((Component)base.baseEntity).transform.position) > Mathf.Min(value * noiseRangeMultiplier, hearingRange)) && (npcNoiseEvent == null || item.Intensity != npcNoiseEvent.Intensity || !(num2 > num)))
						{
							npcNoiseEvent = item;
							num = num2;
						}
					}
				}
				if (npcNoiseEvent != null)
				{
					_currentNoise = Pool.Get<NpcNoiseEvent>();
					_currentNoise.Initiator = npcNoiseEvent.Initiator;
					_currentNoise.Position = npcNoiseEvent.Position;
					_currentNoise.Intensity = npcNoiseEvent.Intensity;
					if (!FindTarget(out var _))
					{
						TrySetTarget(npcNoiseEvent.Initiator);
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool ConsumeCurrentNoise()
	{
		if (_currentNoise == null)
		{
			return false;
		}
		Pool.Free<NpcNoiseEvent>(ref _currentNoise);
		return true;
	}

	public bool FindFood(out BaseEntity food)
	{
		if (!_nearestFood.IsValid() || _nearestFood.IsDestroyed || !SingletonComponent<NpcFoodManager>.Instance.Contains(_nearestFood))
		{
			food = null;
			return false;
		}
		food = _nearestFood;
		return true;
	}

	private void TickFoodDetection(float deltaTime)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickFoodDetection", 0);
		try
		{
			_nearestFood = null;
			if (foodDetectionRange <= 0f)
			{
				return;
			}
			float num = foodDetectionRange * foodDetectionRange;
			float num2 = float.MaxValue;
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				SingletonComponent<NpcFoodManager>.Instance.GetFoodAround(((Component)base.baseEntity).transform.position, foodDetectionRange, (List<BaseEntity>)(object)val2);
				LimitedTurnNavAgent component = ((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>();
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (!NpcFoodManager.IsFoodImmobile(item) || (item is BaseCorpse baseCorpse && ((Object)(object)((Component)baseCorpse).GetComponent<HeadDispenser>()).Is<HeadDispenser>(out HeadDispenser entAsT) && ((Object)(object)entAsT.SourceEntity.GetEntity()).Is<BaseEntity>(out BaseEntity entAsT2) && entAsT2.InSameNpcTeam(base.baseEntity)))
					{
						continue;
					}
					if (!component.IsPositionOnNavmesh(((Component)item).transform.position, out var sample))
					{
						SingletonComponent<NpcFoodManager>.Instance.Remove(item);
						continue;
					}
					sample = ((Component)item).transform.position - ((Component)base.baseEntity).transform.position;
					float sqrMagnitude = ((Vector3)(ref sample)).sqrMagnitude;
					if (sqrMagnitude < num2 && sqrMagnitude < num)
					{
						_nearestFood = item;
						num2 = sqrMagnitude;
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool FindFire(out BaseEntity fire)
	{
		if (!_nearestFire.IsValid() || _nearestFire.IsDestroyed || !NpcFireManager.IsOnFire(_nearestFire))
		{
			_nearestFire = null;
		}
		fire = _nearestFire;
		return (Object)(object)fire != (Object)null;
	}

	private void TickFireDetection(float deltaTime)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickFireDetection", 0);
		try
		{
			if (fireDetectionRange <= 0f)
			{
				return;
			}
			if ((Object)(object)Target != (Object)null && SingletonComponent<NpcFireManager>.Instance.DidMeleeWithFireRecently(base.baseEntity, Target, out var meleeTime) && (!lastMeleeTime.HasValue || meleeTime != lastMeleeTime.Value))
			{
				lastMeleeTime = meleeTime;
				onFireMelee.Invoke();
			}
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				SingletonComponent<NpcFireManager>.Instance.GetFiresAround(((Component)base.baseEntity).transform.position, fireDetectionRange, (List<BaseEntity>)(object)val2);
				BaseEntity baseEntity = null;
				float num = fireDetectionRange * fireDetectionRange;
				float num2 = float.MaxValue;
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					Vector3 val3 = ((Component)item).transform.position - ((Component)base.baseEntity).transform.position;
					float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
					if (sqrMagnitude < num2 && sqrMagnitude < num)
					{
						baseEntity = item;
						num2 = sqrMagnitude;
					}
				}
				if ((Object)(object)baseEntity != (Object)null)
				{
					_nearestFire = baseEntity;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public LockState.LockHandle LockCurrentTarget()
	{
		return lockState.AddLock();
	}

	public bool UnlockTarget(ref LockState.LockHandle handle)
	{
		return lockState.RemoveLock(ref handle);
	}

	public bool CanTarget(BaseEntity entity)
	{
		if (!entity.IsValid())
		{
			return false;
		}
		if (entity.IsTransferProtected())
		{
			return false;
		}
		if (entity.IsDestroyed)
		{
			return false;
		}
		if (!entity.IsNonNpcPlayer() && !entity.IsNpc)
		{
			return false;
		}
		if (entity.IsNpcPlayer())
		{
			return false;
		}
		if (entity is BaseCombatEntity baseCombatEntity && baseCombatEntity.IsDead())
		{
			return false;
		}
		if (InSameTeam(entity))
		{
			return false;
		}
		if (entity is BasePlayer item)
		{
			if (AI.ignoreplayers)
			{
				return false;
			}
			if (SimpleAIMemory.PlayerIgnoreList.Contains(item))
			{
				return false;
			}
		}
		object obj = Interface.CallHook("IOnNpcTarget", (object)this, (object)entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public bool FindTarget(out BaseEntity target)
	{
		if (!CanTarget(Target))
		{
			ClearTarget();
			target = null;
			return false;
		}
		target = Target;
		return (Object)(object)target != (Object)null;
	}

	public bool FindTargetPosition(out Vector3 targetPosition)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!FindTarget(out var target))
		{
			targetPosition = Vector3.zero;
			return false;
		}
		targetPosition = ((Component)target).transform.position;
		return true;
	}

	public bool TrySetTarget(BaseEntity newTarget, bool bypassCooldown = true)
	{
		if (lockState.IsLocked)
		{
			return false;
		}
		if ((Object)(object)newTarget == (Object)null)
		{
			ClearTarget();
			return true;
		}
		if ((Object)(object)newTarget == (Object)(object)Target)
		{
			return true;
		}
		if (!CanTarget(newTarget))
		{
			return false;
		}
		if ((Object)(object)Target != (Object)null && !bypassCooldown && ChangedTargetRecently)
		{
			return false;
		}
		lastTargetTime = Time.timeAsDouble;
		Target = newTarget;
		return true;
	}

	public void ClearTarget(bool forget = true)
	{
		if (Target.IsValid())
		{
			if (forget)
			{
				Forget(Target);
			}
			lastTargetTime = null;
			Target = null;
		}
	}

	private void TickTargeting(float deltaTime)
	{
		TimeWarning val = TimeWarning.New("SenseComponent:TickTargeting", 0);
		try
		{
			if ((Object)(object)Target != (Object)null && !CanTarget(Target))
			{
				ClearTarget();
			}
			if ((Object)(object)Target != (Object)null && ChangedTargetRecently)
			{
				return;
			}
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				GetOncePerceivedEntities((List<BaseEntity>)(object)val2);
				if (((List<BaseEntity>)(object)val2).Count == 0)
				{
					return;
				}
				BaseEntity baseEntity = null;
				float num = float.MaxValue;
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (CanTarget(item))
					{
						float num2 = base.baseEntity.SqrDistance(item);
						if (item.IsNpc)
						{
							num2 += 100f;
						}
						if (num2 < num)
						{
							num = num2;
							baseEntity = item;
						}
					}
				}
				if ((Object)(object)baseEntity != (Object)null)
				{
					TrySetTarget(baseEntity, bypassCooldown: false);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void SaveComponent(BaseNetworkable.SaveInfo info)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		base.SaveComponent(info);
		if (base.baseEntity.isServer)
		{
			info.msg.npcSensesState = Pool.Get<NPCSensesState>();
			if ((Object)(object)Target != (Object)null)
			{
				info.msg.npcSensesState.targetEntityId = Target.net.ID;
			}
		}
	}

	public override void LoadComponent(BaseNetworkable.LoadInfo info)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		NPCSensesState npcSensesState = info.msg.npcSensesState;
		if (npcSensesState != null)
		{
			if (((NetworkableId)(ref npcSensesState.targetEntityId)).IsValid)
			{
				if (base.baseEntity.isServer)
				{
					_target = BaseNetworkable.serverEntities.Find(npcSensesState.targetEntityId) as BaseEntity;
				}
			}
			else
			{
				_target = null;
			}
		}
		base.LoadComponent(info);
	}
}


using System;

[Serializable]
public struct Cone
{
	public float halfAngle;

	public float range;

	public Cone(float halfAngle = 80f, float range = 10f)
	{
		this.halfAngle = halfAngle;
		this.range = range;
	}
}


using ConVar;
using Facepunch;
using UnityEngine;

public class VisibilityStatus : IPooled
{
	private BaseEntity baseEntity;

	private BaseEntity targetEntity;

	public Vector3 lastKnownPosition;

	private const float waterCheckInterval = 1f;

	private double? lastTimeInWaterUpdated;

	public float timeVisible { get; private set; }

	public float timeNotVisible { get; private set; }

	public bool isVisible => timeVisible > 0f;

	public float timeWatched { get; private set; }

	public float timeNotWatched { get; private set; }

	public float timeAimedAt { get; private set; }

	public float timeNotAimedAt { get; private set; }

	public WaterLevel.WaterInfo? lastWaterInfo { get; private set; }

	public bool isInWaterCached
	{
		get
		{
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			if (!targetEntity.ToNonNpcPlayer(out var player))
			{
				return false;
			}
			if (!lastWaterInfo.HasValue || !lastTimeInWaterUpdated.HasValue || Time.timeAsDouble - lastTimeInWaterUpdated > 1.0)
			{
				BaseMountable entAsT;
				Vector3 val = (((Object)(object)player.GetMounted()).Is<BaseMountable>(out entAsT) ? (Vector3.down * 0.5f) : Vector3.zero);
				lastWaterInfo = WaterLevel.GetWaterInfo(((Component)targetEntity).transform.position + val, waves: false, volumes: false);
				lastTimeInWaterUpdated = Time.timeAsDouble;
			}
			return lastWaterInfo.Value.currentDepth >= 0.3f;
		}
	}

	private void Reset()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		targetEntity = null;
		baseEntity = null;
		timeWatched = 0f;
		timeNotWatched = 100f;
		timeAimedAt = 0f;
		timeNotAimedAt = 100f;
		timeVisible = 0f;
		timeNotVisible = 100f;
		lastKnownPosition = Vector3.zero;
		lastWaterInfo = null;
		lastTimeInWaterUpdated = null;
	}

	public void EnterPool()
	{
		Reset();
	}

	public void LeavePool()
	{
		Reset();
	}

	public static VisibilityStatus GetFromPool(BaseEntity baseEntity, BaseEntity targetEntity, float deltaTime, Vector3? lastKnownPositionOverride = null)
	{
		VisibilityStatus visibilityStatus = Pool.Get<VisibilityStatus>();
		visibilityStatus.baseEntity = baseEntity;
		visibilityStatus.targetEntity = targetEntity;
		visibilityStatus.UpdateVisibility(isVisible: true, deltaTime, lastKnownPositionOverride);
		return visibilityStatus;
	}

	private bool CheckValid()
	{
		if (!baseEntity.IsValid() || !targetEntity.IsValid())
		{
			if (AI.logIssues)
			{
				Debug.LogError((object)$"SenseComponent:UpdateVisibility NRE: {baseEntity} {targetEntity}");
			}
			return false;
		}
		return true;
	}

	public void UpdateVisibility(bool isVisible, float deltaTime, Vector3? lastKnownPositionOverride = null)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckValid())
		{
			return;
		}
		if (lastKnownPositionOverride.HasValue)
		{
			lastKnownPosition = lastKnownPositionOverride.Value;
		}
		else if (isVisible)
		{
			lastKnownPosition = ((Component)targetEntity).transform.position;
		}
		if (isVisible)
		{
			timeNotVisible = 0f;
			timeVisible += deltaTime;
			Vector3 val = ((Component)targetEntity).transform.forward;
			Vector3 position = ((Component)targetEntity).transform.position;
			if (targetEntity.ToNonNpcPlayer(out var player))
			{
				val = player.eyes.HeadForward();
				position = player.eyes.position;
			}
			Vector3 val2 = ((Component)baseEntity).transform.position - position;
			float num = Mathf.Acos(Vector3.Dot(val, ((Vector3)(ref val2)).normalized)) * 57.29578f * 2f;
			bool num2 = num < AI.watchedAngle;
			if (num2)
			{
				timeNotWatched = 0f;
				timeWatched += deltaTime;
			}
			else
			{
				timeWatched = 0f;
				timeNotWatched += deltaTime;
			}
			if (num2 && (Object)(object)player != (Object)null && player.modelState.aiming && num < AI.aimedAtAngle && !(player.GetHeldEntity() is BaseMelee { canScareAiWhenAimed: false }))
			{
				timeNotAimedAt = 0f;
				timeAimedAt += deltaTime;
			}
			else
			{
				timeAimedAt = 0f;
				timeNotAimedAt += deltaTime;
			}
		}
		else
		{
			timeVisible = 0f;
			timeNotVisible += deltaTime;
			timeWatched = 0f;
			timeNotWatched += deltaTime;
			timeAimedAt = 0f;
			timeNotAimedAt += deltaTime;
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine.Assertions;

public class LockState
{
	public class LockHandle
	{
	}

	private HashSet<LockHandle> locks = new HashSet<LockHandle>();

	public bool IsLocked => locks.Count > 0;

	public LockHandle AddLock()
	{
		LockHandle lockHandle = Pool.Get<LockHandle>();
		locks.Add(lockHandle);
		return lockHandle;
	}

	public bool RemoveLock(ref LockHandle handle)
	{
		if (handle == null)
		{
			return false;
		}
		bool num = locks.Remove(handle);
		Assert.IsTrue(num, "Trying to remove a lock that doesn't exist");
		if (num)
		{
			Pool.FreeUnsafe<LockHandle>(ref handle);
		}
		return num;
	}
}


public class LockHandle
{
}


using UnityEngine;

public static class BaseEntityTargettingExtensions
{
	public static bool InSameNpcTeam(this BaseEntity entity, BaseEntity other)
	{
		if ((Object)(object)entity == (Object)null || (Object)(object)other == (Object)null)
		{
			return false;
		}
		return ((object)entity).GetType() == ((object)other).GetType();
	}

	public static bool IsNonNpcPlayer(this BaseEntity entity)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			return !basePlayer.IsNpc;
		}
		return false;
	}

	public static bool IsNpcPlayer(this BaseEntity entity)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			return basePlayer.IsNpc;
		}
		return false;
	}

	public static bool ToNonNpcPlayer(this BaseEntity entity, out BasePlayer player)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer == (Object)null || basePlayer.IsNpc)
		{
			player = null;
			return false;
		}
		player = basePlayer;
		return true;
	}
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;

public class UI_RustButtonGroup : MonoBehaviour
{
	[SerializeField]
	[Header("Button Group")]
	protected List<RustButton> _buttons = new List<RustButton>();

	[SerializeField]
	protected bool _unpressSiblings;

	[SerializeField]
	[Tooltip("This button will appear 'pressed' at the beginning.")]
	private RustButton _defaultButton;

	[SerializeField]
	private bool _allowToggleOff;

	public List<RustButton> Buttons => _buttons;

	private void Start()
	{
		SetupButtons();
	}

	public void AddListenerToGroup(UnityAction action)
	{
		if (_buttons.Count <= 0)
		{
			Debug.LogError((object)"No Buttons found in group.");
			return;
		}
		foreach (RustButton button in _buttons)
		{
			if (!((Object)(object)button == (Object)null))
			{
				button.OnPressed.AddListener(action);
			}
		}
	}

	public void AddListenerToIndex(int index, UnityAction action)
	{
		if (_buttons.Count <= 0)
		{
			Debug.LogError((object)"No Buttons found in group.");
		}
		else if (_buttons.Count - 1 < index)
		{
			Debug.LogError((object)$"No Buttons found at index {index}.");
		}
		else if ((Object)(object)_buttons[index] == (Object)null)
		{
			Debug.LogError((object)$"Button at index {index} is null.");
		}
		else
		{
			_buttons[index].OnPressed.AddListener(action);
		}
	}

	public void EnableButton(int index)
	{
		if (_buttons.Count <= index)
		{
			Debug.LogError((object)$"Button with index {index} doesn't exist.");
		}
		else
		{
			_buttons[index].SetToggleTrue(true);
		}
	}

	protected virtual void SetupButtons()
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Expected O, but got Unknown
		if (_buttons.Count <= 0)
		{
			Debug.LogError((object)"No Buttons found in group.");
			return;
		}
		foreach (RustButton button in _buttons)
		{
			if ((Object)(object)button == (Object)null)
			{
				continue;
			}
			if ((Object)(object)_defaultButton != (Object)null && (Object)(object)button == (Object)(object)_defaultButton)
			{
				button.PreventToggleOff = false;
				button.SetToggleTrue(true);
			}
			if (!_unpressSiblings)
			{
				continue;
			}
			button.OnPressed.AddListener((UnityAction)delegate
			{
				if (!_allowToggleOff)
				{
					button.PreventToggleOff = true;
				}
				UnpressSiblings(button);
			});
		}
	}

	public void UnpressSiblings(RustButton thisButton)
	{
		foreach (RustButton button in _buttons)
		{
			if (!((Object)(object)thisButton == (Object)(object)button) && !((Object)(object)button == (Object)null))
			{
				button.PreventToggleOff = false;
				button.SetToggleFalse(true);
			}
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.Events;

public class ClockSlider : RustSlider
{
	private bool isUpdatingText;

	public override float Value
	{
		get
		{
			return ((RustSlider)this).Value;
		}
		set
		{
			value = Mathf.Clamp(value, base.MinValue, base.MaxValue);
			if (base.Integer)
			{
				value = Mathf.Round(value);
			}
			if (base.ValueInternal != value)
			{
				base.ValueInternal = value;
			}
			string text = FormatText(value);
			if ((Object)(object)base.NumberInput != (Object)null && !base.NumberInput.IsFocused && base.NumberInput.Text != text)
			{
				UpdateTextNoNotify(text);
			}
			base.SliderCanvas.fillAmount = ((RustSlider)this).ValueNormalized;
			if (base.lastCallbackValue != value)
			{
				base.lastCallbackValue = value;
				((UnityEvent<float>)(object)base.OnChanged)?.Invoke(value);
			}
		}
	}

	protected override void Awake()
	{
		((RustSlider)this).Awake();
		if ((Object)(object)base.NumberInput != (Object)null)
		{
			((UnityEvent<string>)(object)base.NumberInput.OnValueChanged).RemoveListener((UnityAction<string>)TextChanged);
			((UnityEvent<string>)(object)base.NumberInput.OnValueChanged).AddListener((UnityAction<string>)TextChanged);
			((UnityEvent<string>)(object)base.NumberInput.OnEndEdit).RemoveListener((UnityAction<string>)OnEndEdit);
			((UnityEvent<string>)(object)base.NumberInput.OnEndEdit).AddListener((UnityAction<string>)OnEndEdit);
		}
	}

	public void OnEndEdit(string text)
	{
		if (isUpdatingText)
		{
			return;
		}
		if (!text.Contains(":"))
		{
			text = ((text.Length == 4) ? text.Insert(2, ":") : ((text.Length == 3) ? text.Insert(1, ":") : ((text.Length != 1) ? "00:00" : ("0" + text + ":00"))));
			UpdateTextNoNotify(text);
		}
		else
		{
			if (text.Length == 3)
			{
				text = text.Insert(3, "00");
			}
			UpdateTextNoNotify(text);
		}
		UpdateValue(text, updateText: true);
	}

	public void TextChanged(string text)
	{
		if (isUpdatingText)
		{
			return;
		}
		int num = -1;
		if (!text.Contains(":"))
		{
			if (text.Length == 2)
			{
				text = text.Insert(2, ":");
				num = 3;
			}
			if (text.Length == 1)
			{
				int.TryParse(text, out var result);
				if (result > 2)
				{
					text = "0" + text + ":";
					num = 3;
				}
			}
			UpdateTextNoNotify(text);
			if (num != -1)
			{
				base.NumberInput.InputField.caretPosition = num;
			}
		}
		UpdateValue(text, updateText: false);
	}

	private void UpdateValue(string text, bool updateText)
	{
		string[] array = text.Split(':');
		if (array.Length != 2 || !int.TryParse(array[0], out var result) || !int.TryParse(array[1], out var result2))
		{
			return;
		}
		result = Mathf.Clamp(result, 0, 23);
		result2 = Mathf.Clamp(result2, 0, 59);
		((RustSlider)this).Value = (float)result + (float)result2 / 60f;
		if (updateText)
		{
			string text2 = FormatText(((RustSlider)this).Value);
			if (base.NumberInput.Text != text2)
			{
				UpdateTextNoNotify(text2);
			}
		}
	}

	private string FormatText(float value)
	{
		int num = Mathf.RoundToInt(value * 60f);
		int num2 = num / 60;
		int num3 = num % 60;
		return $"{num2:D2}:{num3:D2}";
	}

	private void UpdateTextNoNotify(string text)
	{
		isUpdatingText = true;
		base.NumberInput.Text = text;
		isUpdatingText = false;
	}
}


using UnityEngine;

public class MuteListController : UIDialog
{
	public RectTransform ListParent;

	public GameObjectRef UserWidget;

	public SteamFriendsList SearchList;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ReportBug : UIDialog
{
	public GameObject GetInformation;

	public GameObject Finished;

	public RustInput Subject;

	public RustInput Message;

	public RustButton ReportButton;

	public RustButtonGroup Category;

	public RustIcon ProgressIcon;

	public RustText ProgressText;

	public RawImage ScreenshotImage;

	public GameObject ScreenshotRoot;

	public UIBackgroundBlur BlurController;

	public RustButton SubmitButton;

	public GameObject SubmitErrorRoot;

	public RustText CooldownText;

	public RustText ContentMissingText;
}


using Rust.UI;
using UnityEngine;

public class ReportPlayer : UIDialog
{
	public const string BreakServerRulesKey = "break_server_rules";

	public GameObject FindPlayer;

	public GameObject GetInformation;

	public GameObject Finished;

	public GameObject RecentlyReported;

	public Dropdown ReasonDropdown;

	public RustInput Subject;

	public RustInput Message;

	public RustButton ReportButton;

	public SteamUserButton SteamUserButton;

	public RustIcon ProgressIcon;

	public RustText ProgressText;

	public static Option[] ReportReasons = (Option[])(object)new Option[6]
	{
		new Option(new Phrase("report.reason.none", "Select an option"), "none", false, (Icons)61641),
		new Option(new Phrase("report.reason.abuse", "Racism/Sexism/Abusive"), "abusive", false, (Icons)62806),
		new Option(new Phrase("report.reason.cheat", "Cheating"), "cheat", false, (Icons)61531),
		new Option(new Phrase("report.reason.spam", "Spamming"), "spam", false, (Icons)61601),
		new Option(new Phrase("report.reason.name", "Offensive Name"), "name", false, (Icons)63417),
		new Option(new Phrase("report.reason.server_rules", "Breaking Server Rules"), "break_server_rules", false, (Icons)61546)
	};
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class SteamInventoryCrafting : MonoBehaviour
{
	public GameObject Container;

	public ToggleGroup ToggleGroup;

	public Button ConvertToItem;

	public Button DeleteButton;

	public TextMeshProUGUI WoodAmount;

	public TextMeshProUGUI ClothAmount;

	public TextMeshProUGUI MetalAmount;

	public TextMeshProUGUI InfoText;

	public SteamInventoryCrateOpen CraftModal;

	public GameObject CraftingContainer;

	public GameObject CraftingButton;

	public SteamInventoryNewItem NewItemModal;

	public IPlayerItemDefinition ResultItem { get; private set; }

	public Coroutine MarketCoroutine { get; private set; }
}


using Rust.UI;
using TMPro;
using UnityEngine;

public class SteamInventoryCrateOpen : MonoBehaviour
{
	public TextMeshProUGUI Name;

	public TextMeshProUGUI Requirements;

	public TextMeshProUGUI Label;

	public HttpImage IconImage;

	public GameObject ErrorPanel;

	public TextMeshProUGUI ErrorText;

	public GameObject CraftButton;

	public GameObject ProgressPanel;

	public SteamInventoryNewItem NewItemModal;
}


using UnityEngine;

public class SteamInventoryIcon : MonoBehaviour
{
}


using Facepunch.Extend;
using Rust.UI;
using TMPro;
using UnityEngine;

public class SteamInventoryItem : MonoBehaviour
{
	public IPlayerItem Item;

	public HttpImage Image;

	public bool Setup(IPlayerItem item)
	{
		Item = item;
		if (PlayerItemExtensions.GetDefinition(item) == null)
		{
			return false;
		}
		((TMP_Text)((Component)TransformEx.FindChildRecursive(((Component)this).transform, "ItemName")).GetComponent<TextMeshProUGUI>()).text = PlayerItemExtensions.GetDefinition(item).Name;
		return Image.Load(PlayerItemExtensions.GetDefinition(item).IconUrl);
	}
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;

public class SteamInventoryManager : SingletonComponent<SteamInventoryManager>
{
	public GameObject inventoryItemPrefab;

	public GameObject inventoryCanvas;

	public GameObject missingItems;

	public SteamInventoryCrafting CraftControl;

	public List<GameObject> items;

	public GameObject LoadingOverlay;
}


using System.Threading.Tasks;
using Rust.UI;
using UnityEngine;

public class SteamInventoryNewItem : MonoBehaviour
{
	public async Task Open(IPlayerItem item)
	{
		((Component)this).gameObject.SetActive(true);
		((Component)this).GetComponentInChildren<Rust.UI.SteamInventoryItem>().Setup(item);
		while (Object.op_Implicit((Object)(object)this) && ((Component)this).gameObject.activeSelf)
		{
			await Task.Delay(100);
		}
	}
}


using Rust.UI;
using UnityEngine;

public class ServerAdminConvarInfo : MonoBehaviour
{
	public RustText InfoName;

	public RustText InfoValue;

	public RustInput VariableInput;

	public Tooltip TooltipComponent;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminPlayerEntry : MonoBehaviour
{
	public RustText PlayerName;

	public RustText Ping;

	public RustButton Button;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminPlayerId : MonoBehaviour
{
	public RustText PlayerName;

	public RustText PlayerId;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminPlayerInfo : MonoBehaviour
{
	public RustText PlayerName;

	public RustText SteamID;

	public RustText OwnerSteamID;

	public RustText Ping;

	public RustText Address;

	public RustText ConnectedTime;

	public RustText ViolationLevel;

	public RustText Health;

	public RustInput KickReasonInput;

	public RustInput BanReasonInput;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminServerInfo : MonoBehaviour
{
	public RustText InfoName;

	public RustText InfoValue;
}


using UnityEngine;

public class ServerAdminUGCEntry : MonoBehaviour
{
}


using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;

public class ServerAdminUGCEntryAudio : ServerAdminUGCEntry
{
	public AudioSource AudioSpeaker;

	public RustText DurationText;

	public RustSlider ProgressSlider;

	public RustIcon PlayIcon;
}


using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;
using UnityEngine.UI;

public class ServerAdminUGCEntryImage : ServerAdminUGCEntry
{
	public RawImage Image;

	public RectTransform Backing;

	public GameObject MultiImageRoot;

	public RustText ImageIndex;

	public Vector2 OriginalImageSize;
}


using Rust.UI.ServerAdmin;
using UnityEngine;

public class ServerAdminUGCEntryPattern : ServerAdminUGCEntry
{
	public GameObjectRef StarPrefab;

	public RectTransform StarRoot;
}


using Rust.UI.ServerAdmin;
using UnityEngine;
using UnityEngine.UI;

public class ServerAdminUGCEntrySculpture : ServerAdminUGCEntry
{
	public Camera Camera;

	public Material MaterialToUse;

	public RawImage Target;
}


using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;

public class ServerAdminUGCEntryStub : MonoBehaviour
{
	public ServerAdminUGCEntryAudio AudioWidget;

	public ServerAdminUGCEntryImage ImageWidget;

	public ServerAdminUGCEntryPattern PatternWidget;

	public ServerAdminUGCEntryVendingMachine VendingWidget;

	public ServerAdminUGCEntrySculpture SculptureWidget;

	public RustText PrefabName;

	public RustButton HistoryButton;

	public ServerAdminPlayerId[] HistoryIds = new ServerAdminPlayerId[0];
}


using Rust.UI;
using Rust.UI.ServerAdmin;

public class ServerAdminUGCEntryVendingMachine : ServerAdminUGCEntry
{
	public RustText NameLabel;
}


using Facepunch;
using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;
using UnityEngine.UI;

public class ServerAdminUI : SingletonComponent<ServerAdminUI>
{
	public GameObjectRef PlayerEntry;

	public RectTransform PlayerInfoParent;

	public RustText PlayerCount;

	public RustInput PlayerNameFilter;

	public GameObjectRef ServerInfoEntry;

	public RectTransform ServerInfoParent;

	public GameObjectRef ConvarInfoEntry;

	public GameObjectRef ConvarInfoLongEntry;

	public RectTransform ConvarInfoParent;

	public ServerAdminPlayerInfo PlayerInfo;

	public RustInput UgcNameFilter;

	public GameObjectRef ImageEntry;

	public GameObjectRef PatternEntry;

	public GameObjectRef SoundEntry;

	public RustButton ShowWantedPostersButton;

	public VirtualScroll UgcVirtualScroll;

	public GameObject ExpandedUgcRoot;

	public RawImage ExpandedImage;

	public RectTransform ExpandedImageBacking;
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(Toggle))]
internal class ForceWeather : MonoBehaviour
{
	private Toggle component;

	public bool Rain;

	public bool Fog;

	public bool Wind;

	public bool Clouds;

	public void OnEnable()
	{
		component = ((Component)this).GetComponent<Toggle>();
	}

	public void Update()
	{
		if (!((Object)(object)SingletonComponent<Climate>.Instance == (Object)null))
		{
			if (Rain)
			{
				SingletonComponent<Climate>.Instance.Overrides.Rain = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Rain, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
			if (Fog)
			{
				SingletonComponent<Climate>.Instance.Overrides.Fog = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Fog, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
			if (Wind)
			{
				SingletonComponent<Climate>.Instance.Overrides.Wind = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Wind, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
			if (Clouds)
			{
				SingletonComponent<Climate>.Instance.Overrides.Clouds = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Clouds, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Development.Attributes;
using Rust.UI.MainMenu;
using UnityEngine;

[ResetStaticFields]
public class UI_MenuManager : SingletonComponent<UI_MenuManager>
{
	[SerializeField]
	private UI_Popup _genericPopupPrefab;

	[SerializeField]
	private Transform _genericPopupParent;

	[SerializeField]
	[Header("Background Image Settings")]
	private CanvasGroup _homeVideoOverlay;

	[SerializeField]
	private float _homeVideoOverlayAlpha = 1f;

	[SerializeField]
	private float _otherPageVideoOverlayAlpha = 0.98f;

	[SerializeField]
	private CanvasGroup _pageBackgroundOverlay;

	[SerializeField]
	private float _pageBackgroundOverlayAlpha = 0.98f;

	public static Action OnOpenStateChanged;

	private static bool _isOpen = true;

	public List<GameObject> HideInMenu = new List<GameObject>();

	public List<GameObject> HideInGame = new List<GameObject>();

	private UI_MenuNavigationGroup _navGroup;

	public Transform GenericPopupParent => _genericPopupParent;

	public static bool IsOpen => _isOpen;
}


using System;
using Rust.UI.MainMenu;
using UnityEngine;

[Serializable]
public class UI_NavigationEntry
{
	public string Path;

	public GameObject Reference;

	[NonSerialized]
	public UI_Page Page;

	public void Hide()
	{
		if (CheckReference() && (Object)(object)Page != (Object)null)
		{
			Page.Close();
		}
	}

	public void Show()
	{
		if (CheckReference() && (Object)(object)Page != (Object)null)
		{
			Page.Open();
		}
	}

	private bool CheckReference()
	{
		if ((Object)(object)Reference == (Object)null)
		{
			Debug.LogError((object)("Navigation Entry '" + Path + "' doesn't have a valid reference."));
			return false;
		}
		return true;
	}
}


using Rust.UI.MainMenu;

public abstract class UI_Page : UI_Window
{
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_RegisterNavigation : MonoBehaviour
{
	public UI_NavigationEntry NavigationEntry;

	public void Setup()
	{
		if (NavigationEntry != null)
		{
			SetupEntry();
		}
	}

	private void SetupEntry()
	{
		UI_Page page = default(UI_Page);
		if (!((Object)(object)NavigationEntry.Reference == (Object)null) && NavigationEntry.Reference.TryGetComponent<UI_Page>(ref page))
		{
			NavigationEntry.Page = page;
		}
	}
}


using UnityEngine;

public class UI_DemoWindowButton : MonoBehaviour
{
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UI_Hero_InfoBox : FacepunchBehaviour
{
	[SerializeField]
	[Header("References")]
	protected RustText _title;

	[SerializeField]
	protected RustText _subtitle;

	[SerializeField]
	protected RustText _tag;

	[SerializeField]
	protected CoverImage _coverImage;

	[SerializeField]
	protected RustButton _button;

	[SerializeField]
	protected FlexTransition _hoverFlex;

	[SerializeField]
	protected Image _blackout;

	[SerializeField]
	[Header("Settings")]
	private Phrase _titlePhrase;

	[SerializeField]
	private Phrase _subtitlePhrase;

	[SerializeField]
	protected Texture _image;

	[SerializeField]
	protected bool _internalLink;

	[SerializeField]
	protected string _linkUrl;
}


using Rust.UI;
using UnityEngine;

public class UI_PatchInfo : FacepunchBehaviour
{
	[SerializeField]
	private RustText _title;

	[SerializeField]
	private RustText _description;

	[SerializeField]
	private RustText _date;

	[SerializeField]
	private RustButton _readMoreButton;

	[SerializeField]
	private RustButton _changelogButton;

	[SerializeField]
	private GameObject _devlogTag;
}


using System.Collections.Generic;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_Hero_QuickJoin : UI_Hero_InfoBox
{
	[SerializeField]
	private List<UI_ServerEntry> _quickJoinEntries = new List<UI_ServerEntry>();
}


using Rust.UI.MainMenu;

public class UI_Hero_Store : UI_Hero_InfoBox
{
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_HomePage : UI_Page
{
	[SerializeField]
	private UI_Hero_QuickJoin _quickJoin;
}


using Rust.UI;
using UnityEngine;

public class UI_NotificationEntry : MonoBehaviour
{
	[Header("Icons")]
	[SerializeField]
	private RustIcon _basicIcon;

	[SerializeField]
	private RustIcon _standardIcon;

	[SerializeField]
	private RustIcon _banIcon;

	[SerializeField]
	private RustIcon _warningIcon;

	[Header("UI Elements")]
	[SerializeField]
	private GameObject _linkIcon;

	[SerializeField]
	private RustButton _linkButton;

	[SerializeField]
	private RustText _notificationText;
}


public enum NotificationType
{
	Basic,
	Standard,
	Warning,
	Ban
}


using System;
using Rust.UI.MainMenu;

[Serializable]
public struct NotificationData
{
	public NotificationType NotificationType;

	public string NotificationText;

	public string NotificationLink;

	public bool IsInternal;

	public Phrase Phrase;

	public bool HasSeen;

	public int? Id;

	public object[] PhraseArguments;

	public bool HasLink => !string.IsNullOrEmpty(NotificationLink);

	public NotificationData(NotificationType type, string text, string link = "", bool isInternal = true, Phrase phrase = null, bool hasSeen = false, int? id = null, params object[] arguments)
	{
		NotificationType = type;
		NotificationText = text;
		NotificationLink = link;
		IsInternal = isInternal;
		Phrase = phrase;
		HasSeen = hasSeen;
		Id = id;
		PhraseArguments = arguments;
	}

	public override bool Equals(object obj)
	{
		if (obj is NotificationData notificationData)
		{
			if (NotificationText == notificationData.NotificationText)
			{
				return NotificationLink == notificationData.NotificationLink;
			}
			return false;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (NotificationText?.GetHashCode() ?? 0) + (NotificationLink?.GetHashCode() ?? 0);
	}
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_Notifications : UI_Window
{
	[Header("Prefab & Container")]
	[SerializeField]
	private GameObject _entryPrefab;

	[SerializeField]
	private RectTransform _contentRoot;

	[SerializeField]
	private GameObject _noNotifications;

	[SerializeField]
	private GameObject _circle;

	[SerializeField]
	private StyleAsset _regularStyle;

	[SerializeField]
	private StyleAsset _seenStyle;
}


using Facepunch.Flexbox;
using UnityEngine;

public class UI_ServerBrowser_Header : MonoBehaviour
{
	public enum HeaderState
	{
		None,
		Ascending,
		Descending
	}

	[Header("References")]
	[SerializeField]
	private FlexTransition _ascendingTransition;

	[SerializeField]
	private FlexTransition _descendingTransition;
}


public enum HeaderState
{
	None,
	Ascending,
	Descending
}


using System.Collections.Generic;
using UnityEngine;

public class UI_ServerBrowser_ModifyComponentsOnCategory : MonoBehaviour
{
	[SerializeField]
	private List<GameObject> _disableComponentsWhileActive = new List<GameObject>();

	[SerializeField]
	private List<GameObject> _enableComponentsWhileActive = new List<GameObject>();
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UI_ServerBrowser_NoResults_Controller : MonoBehaviour
{
	[SerializeField]
	private CanvasGroup _noServersFound;

	[SerializeField]
	private RustButton _button;

	[SerializeField]
	private FlexTransition _transition;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UIElements;

public class UI_ServerBrowser_RefreshButton : RustButton
{
	[SerializeField]
	private UI_LoadingRotate loadingRotate;

	[SerializeField]
	private Image refreshOverview;

	[SerializeField]
	private RustText text;

	private Phrase _refreshPhrase = new Phrase("serverbrowser.refresh", "Refresh");

	private Phrase _cancelPhrase = new Phrase("serverbrowser.cancel", "Cancel");

	public void SetRefreshState(bool state)
	{
		if (!((Object)(object)loadingRotate == (Object)null))
		{
			if (state)
			{
				loadingRotate.ContinuouslyRotate(state: true);
				((RustButton)this).SetToggleVisualOn();
				text.SetPhrase(_cancelPhrase, Array.Empty<object>());
			}
			else
			{
				loadingRotate.Reset();
				loadingRotate.ContinuouslyRotate(state: false);
				((RustButton)this).SetToggleVisualOff();
				text.SetPhrase(_refreshPhrase, Array.Empty<object>());
			}
		}
	}
}


using System;
using Rust.UI;
using TMPro;
using UnityEngine;

public class UI_ServerBrowser_TagModifierButton : RustButton
{
	[Header("Tag Modifier Button")]
	[SerializeField]
	private string _serverTag;

	[SerializeField]
	private RustText _countText;

	private string _tag;

	private LTDescr _countTween;

	public string ServerTag => _serverTag;

	public string CompactTag
	{
		get
		{
			if (_tag == null)
			{
				_tag = ServerTagCompressor.ShortenTag(_serverTag);
			}
			return _tag;
		}
	}

	public void SetCount(int count)
	{
		if (!((Object)(object)_countText == (Object)null))
		{
			if (_countTween != null)
			{
				LeanTween.cancel(_countTween.id);
			}
			int.TryParse(((TMP_Text)_countText).text, out var result);
			_countTween = LeanTween.value(((Component)this).gameObject, (float)result, (float)count, 0.2f).setEaseOutQuad().setOnUpdate((Action<float>)delegate(float val)
			{
				int num = Mathf.RoundToInt(val);
				((TMP_Text)_countText).text = num.ToString();
			});
		}
	}
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UI_ServerEntry : MonoBehaviour
{
	[Header("References")]
	[SerializeField]
	private RustButton _button;

	[SerializeField]
	private RustText _serverNameText;

	[SerializeField]
	private RustText _modeText;

	[SerializeField]
	private RustText _playerCurrentText;

	[SerializeField]
	private RustText _playerMaxText;

	[SerializeField]
	private RustText _pingText;

	[SerializeField]
	private RustText _mapTypeText;

	[SerializeField]
	private ServerBrowserTagList _tagController;

	[SerializeField]
	private GameObject _favouritingParticlesPrefab;

	[Header("References - Last Played")]
	[SerializeField]
	private RustText _lastPlayedText;

	[SerializeField]
	private GameObject _lastPlayedObject;

	[Header("References - Friends")]
	[SerializeField]
	private RustText _friendsText;

	[SerializeField]
	private GameObject _friendsObject;

	[SerializeField]
	private Tooltip _friendsTooltip;

	[SerializeField]
	[Header("References - Queue")]
	private RustText _queueText;

	[SerializeField]
	private GameObject _queueObject;

	[SerializeField]
	[Header("References - Favourites")]
	private RustButton _favouritesButton;

	[SerializeField]
	private FlexTransition _favouritesTransition;

	[SerializeField]
	private RectTransform _favouritesSpawnPoint;

	[Header("References - Styles")]
	[SerializeField]
	private StyleAsset _evenStyle;

	[SerializeField]
	private StyleAsset _oddStyle;

	[SerializeField]
	private StyleAsset _favouriteStyle;

	[Header("Other")]
	[SerializeField]
	private bool _joinOnClick;

	public static Phrase LastJoinedPhrase = (Phrase)(object)new TokenisedPhrase("serverentry.lastplayed.ago", "{0} ago");

	public static Phrase FriendsPhrase = (Phrase)(object)new TokenisedPhrase("serverentry.friends", "{0} friends");
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UI_TabBox : MonoBehaviour
{
	[SerializeField]
	private bool _autoClose = true;

	[SerializeField]
	private RustText _filterEnabledText;

	[SerializeField]
	private RustButton _collapseButton;

	[SerializeField]
	private Image _spacerImage;

	public static readonly Phrase FiltersPhrase = new Phrase("tabbox.filters", "{0} filters");

	public static readonly Phrase EnabledPhrase = new Phrase("tabbox.filters.enabled", "enabled");

	public static readonly Phrase DisabledPhrase = new Phrase("tabbox.filters.disabled", "disabled");
}


using System;
using System.Collections.Generic;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_TagController : MonoBehaviour
{
	[Serializable]
	public class TagData
	{
		public string TagName;

		public GameObject TagObject;
	}

	[SerializeField]
	private List<TagData> _tags = new List<TagData>();

	public void ClearTags()
	{
		foreach (TagData tag in _tags)
		{
			if (tag.TagObject.activeInHierarchy)
			{
				tag.TagObject.SetActive(false);
			}
		}
	}

	public void EnableTag(string tagName)
	{
		foreach (TagData tag in _tags)
		{
			if (tag.TagName == tagName && !tag.TagObject.activeInHierarchy)
			{
				tag.TagObject.SetActive(true);
				return;
			}
		}
		Debug.LogError((object)("Tag '" + tagName + "' not found in the list."));
	}
}


using System;
using UnityEngine;

[Serializable]
public class TagData
{
	public string TagName;

	public GameObject TagObject;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SessionPage : UI_Page
{
	public static UI_SessionPage Instance;

	public HttpImage serverLogoImage;

	[SerializeField]
	private RustText _topServerName;

	[SerializeField]
	private GameObject _rustPlusBanner;

	[SerializeField]
	private GameObject _connectToServerButton;

	[SerializeField]
	private GameObject _quitButton;

	[SerializeField]
	private GameObject _quitDemo;

	[SerializeField]
	private GameObject _quitTutorial;

	[SerializeField]
	private RustButton _rustPlusButton;

	[SerializeField]
	private RustButton _tutorialButton;

	[SerializeField]
	private UI_ConnectModal _connectModal;

	[SerializeField]
	private CompanionSetupScreen _setupScreen;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_ConnectModal : UI_Window
{
	[SerializeField]
	[Header("References")]
	private RustText _title;

	[SerializeField]
	private RustText _description;

	[SerializeField]
	private HttpImage _headerImage;

	[SerializeField]
	private GameObject _headerImageLoading;

	[SerializeField]
	private ServerBrowserTagList _tagController;

	[SerializeField]
	private RustText _mapTypeText;

	[SerializeField]
	private RustButton _websiteButton;

	[SerializeField]
	private Tooltip _websiteTooltip;

	[SerializeField]
	private GameObject _descriptionLoading;

	[SerializeField]
	private GameObject _connectToServerButton;

	[SerializeField]
	private GameObject _needsPremiumButton;

	[SerializeField]
	private GameObject _mapButton;

	[SerializeField]
	private UI_ServerMap _map;

	[Header("References - Friends")]
	[SerializeField]
	private RustText _friendsText;

	[SerializeField]
	private GameObject _friendsObject;

	[SerializeField]
	private Tooltip _friendsTooltip;

	[Header("Info Box References")]
	[SerializeField]
	private RustText _playerCount;

	[SerializeField]
	private GameObject _queuedPlayersObject;

	[SerializeField]
	private RustText _queuedPlayersCount;

	[SerializeField]
	private GameObject _lastPlayedObject;

	[SerializeField]
	private RustText _lastPlayedText;

	[SerializeField]
	private GameObject _wipedObject;

	[SerializeField]
	private RustText _wipedText;

	[SerializeField]
	private ScrollRect _scrollRect;

	[SerializeField]
	private RectMask2D _scrollMask;

	public static Phrase lastPlayedPhrase = new Phrase("connection.modal.lastplayed.ago", "{0} ago");

	public static Phrase serverAgePhrase = new Phrase("connection.modal.serverage.old", "{0} old");

	public static Phrase loadingError = new Phrase("connection.modal.error", "Error loading server");
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
public class UI_FoilShaderMouseFollow : MonoBehaviour
{
	[Header("Foil Shader Settings")]
	[SerializeField]
	private RawImage _rawImage;

	[SerializeField]
	private Image _image;

	[SerializeField]
	private float _rotationSpeed = 10f;

	[SerializeField]
	private float _tiltSensitivity = 3f;

	[SerializeField]
	private float _maxTilt = 10f;

	[SerializeField]
	[Header("Global Settings")]
	private bool _useGlobal;

	[Range(0f, 1f)]
	[SerializeField]
	private float _normalisedMaxGlobalDistance;
}


using UnityEngine;

public class UI_HideTutorialCategory : MonoBehaviour
{
	[SerializeField]
	private GameObject _tutorialCategoryButton;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_InteractionToast : UI_Window
{
	[Header("Interaction Modal")]
	[SerializeField]
	private RustText _text;

	[SerializeField]
	private GameObject _informationPanel;

	[SerializeField]
	private RustText _informationTitle;

	[SerializeField]
	private RustText _informationText;

	[SerializeField]
	private RustButton _firstButton;

	[SerializeField]
	private RustButton _secondButton;

	[SerializeField]
	private RustIcon _firstIcon;

	[SerializeField]
	private RustIcon _secondIcon;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_ServerMap : UI_Window
{
	[Header("References")]
	[SerializeField]
	private HttpImage _httpImage;

	[SerializeField]
	private GameObject _loadingObject;

	[SerializeField]
	private RustButton _gridButton;
}


using Rust.UI.MainMenu;

public class UI_TutorialModal : UI_Window
{
}


using System;
using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_MenuNavigationGroup : UI_RustButtonGroup
{
	[Serializable]
	private class TabButton
	{
		public RustButton Button;

		public string Path;
	}

	[SerializeField]
	[Header("Navigation Groups (IGNORE BUTTON GROUPS - Just Add Here)")]
	private List<TabButton> _navigationGroups = new List<TabButton>();
}


using System;

[Serializable]
private class TabButton
{
	public RustButton Button;

	public string Path;
}


public static class UI_Utils
{
	private static Phrase _monthSingularPhrase = new Phrase("time.month", "month");

	private static Phrase _monthsPhrase = new Phrase("time.months", "months");

	private static Phrase _weekSingularPhrase = new Phrase("time.week", "week");

	private static Phrase _weeksPhrase = new Phrase("time.weeks", "weeks");

	private static Phrase _daysSingularPhrase = new Phrase("time.day", "day");

	private static Phrase _daysPhrase = new Phrase("time.days", "days");

	private static Phrase _hourSingularPhrase = new Phrase("time.hour", "hour");

	private static Phrase _hoursPhrase = new Phrase("time.hours", "hours");

	private static Phrase _minuteSingularPhrase = new Phrase("time.minute", "minute");

	private static Phrase _minutesPhrase = new Phrase("time.minutes", "minutes");

	private static Phrase _secondSingularPhrase = new Phrase("time.second", "second");

	private static Phrase _secondsPhrase = new Phrase("time.seconds", "seconds");
}


using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class CompanionSetupScreen : UI_Window
{
	public enum ScreenState
	{
		Loading,
		Error,
		NoServer,
		NotSupported,
		NotInstalled,
		Disabled,
		Enabled,
		ShowHelp
	}

	public const string PairedKey = "companionPaired";

	public GameObject pleaseSignInMessage;

	public GameObject loadingMessage;

	public GameObject errorMessage;

	public GameObject notSupportedMessage;

	public GameObject disabledMessage;

	public GameObject enabledMessage;

	public GameObject refreshButton;

	public GameObject enableButton;

	public GameObject disableButton;

	public GameObject pairButton;

	public RustText serverName;

	public FlexTransition removeFooterTransition;
}


public enum ScreenState
{
	Loading,
	Error,
	NoServer,
	NotSupported,
	NotInstalled,
	Disabled,
	Enabled,
	ShowHelp
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class Hero : SingletonComponent<Hero>
{
	public CanvasGroup CanvasGroup;

	public Video VideoPlayer;

	public RustText TitleText;

	public RustText ButtonText;

	public HttpImage TitleImage;

	[Header("Item Store Links")]
	public RustButton ItemStoreButton;

	public RustButton LimitedTabButton;

	public RustButton GeneralTabButton;
}


using Coffee.UIEffects;
using UnityEngine;

[RequireComponent(typeof(RectTransform))]
public class GradientMouseFollow : MonoBehaviour
{
	[SerializeField]
	private UIGradient gradient;
}


using Development.Attributes;

[ResetStaticFields]
public static class SteamInventoryRecipeIndex
{
}


using System;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SteamInventoryCraftingModal : UI_SteamInventoryItemBaseModal
{
	[Serializable]
	public struct MaterialGroup
	{
		public GameObject GameObject;

		public RustText CountText;

		public Image BackgroundImage;
	}

	[SerializeField]
	private MaterialGroup woodGroup;

	[SerializeField]
	private MaterialGroup metalGroup;

	[SerializeField]
	private MaterialGroup clothGroup;

	[Space]
	[SerializeField]
	private GameObject craftOK;

	[SerializeField]
	private GameObject craftKO;

	[SerializeField]
	private UI_SteamInventoryNewItemModal newItemModal;
}


using System;
using UnityEngine;
using UnityEngine.UI;

[Serializable]
public struct MaterialGroup
{
	public GameObject GameObject;

	public RustText CountText;

	public Image BackgroundImage;
}


using System;
using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SteamInventoryItemBaseModal : UI_Window
{
	[Serializable]
	private struct Tag
	{
		public string Name;

		public GameObject GameObject;
	}

	[SerializeField]
	protected HttpImage iconImage;

	[SerializeField]
	protected RustText nameText;

	[SerializeField]
	protected RustText descText;

	[SerializeField]
	protected RustText itemTypeText;

	[SerializeField]
	private UI_BackgroundAspectRatioFitter background;

	[Header("Marketable Tag")]
	[SerializeField]
	private GameObject marketablePriceGroup;

	[SerializeField]
	private GameObject marketableLockedGroup;

	[SerializeField]
	protected RustText daysLeftText;

	[SerializeField]
	protected RustText priceText;

	[SerializeField]
	private List<Tag> tagDefinitions = new List<Tag>();

	[Header("Skin Viewer")]
	[SerializeField]
	private CoverImage skinViewerImage;

	[SerializeField]
	private GameObject icon2D;

	[SerializeField]
	private GameObject icon3D;

	[SerializeField]
	private GameObject skinFullscreenButton;

	[SerializeField]
	private GameObject loadingOverlay;

	[SerializeField]
	private Color loadingColor;

	[SerializeField]
	private AnimationCurve loadingCompletePunchCurve;
}


using System;
using UnityEngine;

[Serializable]
private struct Tag
{
	public string Name;

	public GameObject GameObject;
}


using Rust.UI.MainMenu;

public class UI_SteamInventoryNewItemModal : UI_Window
{
	public UI_SteamInventoryItem uiItem;

	private IPlayerItem _item;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SteamInventoryPlayerItemModal : UI_SteamInventoryItemBaseModal
{
	[SerializeField]
	[Header("Breakdown")]
	private GameObject breakdownGroup;

	[SerializeField]
	private GameObject notScrappableGroup;

	[SerializeField]
	protected UI_SteamInventoryCraftingModal.MaterialGroup woodGroup;

	[SerializeField]
	protected UI_SteamInventoryCraftingModal.MaterialGroup metalGroup;

	[SerializeField]
	protected UI_SteamInventoryCraftingModal.MaterialGroup clothGroup;

	[SerializeField]
	[Header("Breakdown Controls")]
	private GameObject breakdownButtonGroup;

	[SerializeField]
	private GameObject cantBreakdownButtonGroup;

	[SerializeField]
	private GameObject deleteButtonGroup;

	[SerializeField]
	private RustText cantBreakdownReasonText;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SteamInventory : UI_Page
{
	public static UI_SteamInventory Instance;

	[SerializeField]
	private FlexVirtualScroll virtualScrollFlex;

	[SerializeField]
	[Space]
	private UI_SteamInventoryCrafting crafting;

	[SerializeField]
	private UI_SteamInventoryItem inventoryItemPrefab;

	[SerializeField]
	private RectTransform inventoryItemParent;

	[Space]
	public GameObject loadingOverlay;

	[SerializeField]
	private UI_StoreTakeover takeovers;

	[SerializeField]
	private RustButton refreshButton;

	[SerializeField]
	private RustInput searchBar;

	public static UI_SteamInventoryCrafting Crafting => Instance?.crafting;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SteamInventoryCrafting : MonoBehaviour
{
	[SerializeField]
	private RustText clothAmountText;

	[SerializeField]
	private RustText woodAmountText;

	[SerializeField]
	private RustText metalAmountText;

	[Space]
	[SerializeField]
	private Transform craftingButtonParent;

	[SerializeField]
	private GameObject craftingButtonPrefab;

	[SerializeField]
	private UI_SteamInventoryNewItemModal newItemModal;

	[SerializeField]
	private UI_SteamInventoryCraftingModal craftingModal;

	[Space]
	[SerializeField]
	private UI_SteamInventoryPlayerItemModal bagOpeningModal;

	[SerializeField]
	private UI_SteamInventoryPlayerItemModal playerItemModal;

	[SerializeField]
	private UI_Popup deleteWarningPopup;

	[SerializeField]
	private UI_Popup craftingWarningPopup;
}


using Rust.UI;
using UnityEngine;

public class UI_SteamInventoryItem : MonoBehaviour
{
	public RustButton button;

	[SerializeField]
	private HttpImage image;

	[SerializeField]
	private GameObject takeoverGroup;

	[SerializeField]
	private CoverImage takeoverImage;

	[SerializeField]
	private RustText nameText;

	[SerializeField]
	private RustText subtitleText;

	[SerializeField]
	private GameObject twitchDropTag;

	public IPlayerItem PlayerItem;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class UI_SettingsGestureButton : UI_SettingsGestureDraggable
{
	[SerializeField]
	private StyleAsset unlockedStyle;

	[SerializeField]
	private StyleAsset lockedStyle;

	[SerializeField]
	[Space]
	private GameObject boundLine;

	[SerializeField]
	private GameObject dragIcon;

	[SerializeField]
	private Image gestureIcon;

	[SerializeField]
	private RustText gestureNameText;

	[SerializeField]
	[Space]
	private RectTransform videoPreview;

	[SerializeField]
	private VideoPlayer videoPlayer;

	[SerializeField]
	private RawImage videoRawTexture;

	[SerializeField]
	[Space]
	private GameObject deleteButton;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public abstract class UI_SettingsGestureDraggable : BaseMonoBehaviour
{
	[SerializeField]
	public RustButton button;

	[SerializeField]
	private GameObject draggedPrefab;

	public GestureConfig gestureConfig { get; private set; }

	public UI_SettingsGestureWheel wheel { get; private set; }
}


using Rust.UI;
using UnityEngine;

public class UI_SettingsGesturePack : MonoBehaviour
{
	[SerializeField]
	private RustText headerText;

	[SerializeField]
	public RectTransform contentParent;

	[SerializeField]
	private GameObject storeButton;

	[SerializeField]
	private GameObject lockIcon;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsGestureWheel : MonoBehaviour
{
	[SerializeField]
	private RustText wheelHeaderText;

	[SerializeField]
	private RustButton leftArrowButton;

	[SerializeField]
	private RustButton rightArrowButton;

	[SerializeField]
	[Space]
	private UI_SettingsGestureWidget[] gestureWidgets;

	[SerializeField]
	private RustText gestureTitleText;

	[SerializeField]
	private RustText gestureDescriptionText;

	[SerializeField]
	private Image gestureIcon;

	[SerializeField]
	[Space]
	private RectTransform wheelCenter;

	[SerializeField]
	private float radius = 100f;

	[SerializeField]
	private float initialAngleOffset;

	[Space]
	[SerializeField]
	private UI_SettingsGestureButton gestureButtonPrefab;

	[Space]
	[SerializeField]
	private RectTransform ownedButtonsParent;

	[SerializeField]
	private RectTransform lockedPacksParent;

	[SerializeField]
	private UI_SettingsGesturePack packPrefab;

	[SerializeField]
	[Space]
	public RectTransform dragAndDropCanvas;

	[SerializeField]
	private CanvasGroup assignOverlay;

	[SerializeField]
	private Canvas buttonListCanvas;

	[SerializeField]
	[Space]
	private GameObject hoveredGestureTexts;

	[SerializeField]
	private GameObject emptyWheelTexts;
}


using LeTai.TrueShadow;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsGestureWidget : UI_SettingsGestureDraggable
{
	[SerializeField]
	private StyleAsset boundStyle;

	[SerializeField]
	private StyleAsset emptyStyle;

	[SerializeField]
	[Space]
	private Image gestureIcon;

	[SerializeField]
	private GameObject emptyIcon;

	[SerializeField]
	private GameObject hoverImage;

	[SerializeField]
	private Canvas canvas;

	[SerializeField]
	private TrueShadow shadow;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class PopulateResolutionDropdown : MonoBehaviour
{
	public UI_SettingsTweakDropdown Dropdown;
}


using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsApplyTweakChanges : MonoBehaviour
{
	public Button ApplyButton;

	public RustButton applyButton;

	public FlexTransition flexTransition;

	public UI_SettingsTweakConvar[] Options;
}


using Rust.UI;
using UnityEngine;

public class UI_SettingsFramerateSlider : MonoBehaviour
{
	public RustSlider slider;

	public RustInput rustInput;
}


using Rust.UI;
using UnityEngine;

public class UI_SettingsKeyBindButton : MonoBehaviour
{
	[HideInInspector]
	public string currentBind;

	public RustButton button;

	public StyleAsset boundStyle;

	public StyleAsset notBoundStyle;

	public RustText text;
}


using UnityEngine;

public abstract class UI_SettingsTweakBase : MonoBehaviour
{
	public Phrase tooltip;

	public Sprite tooltipImage;

	public string tooltipVideoURL;

	[Tooltip("For any clickable URL in the tooltip.")]
	public string tooltipExternalURL;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsTweakColour : UI_SettingsTweakConvar
{
	public Image BackgroundImage;

	public RustButton Opener;

	public RectTransform Dropdown;

	public RectTransform DropdownContainer;

	public GameObject DropdownItemPrefab;

	public AccessibilityColourCollection forColourCollection;

	public AccessibilityMaterialCollection forMaterialCollection;

	public int currentValue;
}


using Rust.UI.MainMenu;
using UnityEngine.Events;

public class UI_SettingsTweakConvar : UI_SettingsTweakBase
{
	public string convarName;

	public bool ApplyImmediatelyOnChange = true;

	public UnityEvent onValueChanged = new UnityEvent();
}


using System;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsTweakDropdown : UI_SettingsTweakConvar
{
	[Serializable]
	public class NameValue
	{
		public string value;

		public Color imageColor;

		public Phrase label;

		public string untranslatedLabel;

		public bool rightToLeft;

		public bool useColorInsteadOfText;
	}

	public RustText Current;

	public Image CurrentColor;

	public RustButton Opener;

	public RectTransform Dropdown;

	public RectTransform DropdownContainer;

	public GameObject DropdownItemPrefab;

	public NameValue[] nameValues;

	public bool forceEnglish;

	[HideInInspector]
	public int currentValue;
}


using System;
using UnityEngine;

[Serializable]
public class NameValue
{
	public string value;

	public Color imageColor;

	public Phrase label;

	public string untranslatedLabel;

	public bool rightToLeft;

	public bool useColorInsteadOfText;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsTweakDropdownItem : MonoBehaviour
{
	public Image Image;

	public RustText Text;

	[Space]
	public StyleAsset DefaultStyle;

	public StyleAsset SelectedStyle;

	public RustButton Button;

	public void SetSelected(bool selected)
	{
		((RustControl)Button).Styles = (selected ? SelectedStyle : DefaultStyle);
		((RustControl)Button).ApplyStyles();
	}
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SettingsTweakKeyBind : UI_SettingsTweakBase
{
	[Space]
	public GameObject blockingCanvas;

	public RustButton button;

	public RustText labelText;

	public UI_SettingsKeyBindButton btnA;

	public UI_SettingsKeyBindButton btnB;

	public CanvasGroup resetButton;

	public string bindString;

	public static bool IsBinding { get; private set; }
}


using Rust.UI.MainMenu;

public class UI_SettingsTweakPresetGraphics : UI_SettingsTweakPresetSelect
{
}


using System;
using Rust.UI.MainMenu;

public class UI_SettingsTweakPresetSelect : UI_SettingsTweakDropdown
{
	[Serializable]
	public struct Presets
	{
		public string[] PresetValues;
	}

	public string StreamingAssetsFilename = "";

	public UI_SettingsTweakConvar[] TargetOptions;

	public string[] AdditionalTargetOptions;

	public Presets[] PresetsArray;

	public int CustomIndex;
}


using System;

[Serializable]
public struct Presets
{
	public string[] PresetValues;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine.Events;

public class UI_SettingsTweakSlider : UI_SettingsTweakConvar
{
	public RustSlider rustSliderControl;

	public RustInput rustInput;

	public bool applyOnMouseUp;

	private TimeSince mouseDown;

	public UnityEvent OnMouseUp;

	private float GetSliderValue()
	{
		return rustSliderControl.Value;
	}
}


using Rust.UI;
using Rust.UI.MainMenu;

public class UI_SettingsTweakToggle : UI_SettingsTweakConvar
{
	public RustButton buttonControl;

	public bool inverse;

	public static string lastConVarChanged;

	public static TimeSince timeSinceLastConVarChange;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SafeModeWarning : UI_Popup, IClientComponent
{
	[SerializeField]
	[Space]
	private GameObject yesButton;

	[SerializeField]
	private GameObject timer;

	[SerializeField]
	private RustText timerText;

	[SerializeField]
	private float timeToWait = 5f;
}


using System;
using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_Settings : UI_Page
{
	[Serializable]
	private class SettingTab
	{
		public string name;

		public UI_SettingsTabButton tabButton;

		public GameObject content;

		[ReadOnly]
		public List<SettingEntry> settings;

		public RustButton button => tabButton.button;

		public CanvasGroup canvasGroup => tabButton.canvasGroup;
	}

	private class SettingEntry
	{
		[NonSerialized]
		public SettingTab ownerTab;

		public string convarName;

		public string nameToken;

		public UI_SettingsTweakBase tweakUIBase;

		private CanvasGroup _canvasGroup;

		private RustText _labelText;

		private RustButton _button;

		private string searchIndex;

		public GameObject gameObject
		{
			get
			{
				UI_SettingsTweakBase uI_SettingsTweakBase = tweakUIBase;
				if (uI_SettingsTweakBase == null)
				{
					return null;
				}
				return ((Component)uI_SettingsTweakBase).gameObject;
			}
		}

		public CanvasGroup canvasGroup
		{
			get
			{
				if ((Object)(object)_canvasGroup == (Object)null)
				{
					_canvasGroup = gameObject.GetComponent<CanvasGroup>();
				}
				return _canvasGroup;
			}
		}

		public RustText labelText
		{
			get
			{
				if ((Object)(object)_labelText == (Object)null)
				{
					_labelText = gameObject.GetComponentInChildren<RustText>();
				}
				return _labelText;
			}
		}

		public RustButton button
		{
			get
			{
				if ((Object)(object)_button == (Object)null)
				{
					_button = gameObject.GetComponent<RustButton>();
				}
				return _button;
			}
		}

		public SettingEntry(string convarName, UI_SettingsTweakBase tweakUIBase)
		{
			this.convarName = convarName;
			this.tweakUIBase = tweakUIBase;
		}

		public string GetSettingName()
		{
			return Translate.Get(nameToken, (string)null, false);
		}

		public string GetTooltip()
		{
			return Translate.Get(tweakUIBase.tooltip.token, (string)null, false);
		}

		public void BuildSearchIndex()
		{
			searchIndex = string.Join(" ", GetSettingName(), GetTooltip());
		}

		public bool Matches(string query)
		{
			if (string.IsNullOrWhiteSpace(query))
			{
				return false;
			}
			string[] array = query.Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries);
			foreach (string text in array)
			{
				int startIndex = 0;
				while (true)
				{
					int num = searchIndex.IndexOf(text, startIndex, StringComparison.OrdinalIgnoreCase);
					if (num < 0)
					{
						break;
					}
					if (!RustText.IsInsideTag(searchIndex, num))
					{
						return true;
					}
					startIndex = num + text.Length;
				}
			}
			return false;
		}
	}

	[SerializeField]
	private List<SettingTab> tabs;

	[SerializeField]
	private UI_SearchBar searchBar;

	[SerializeField]
	[Space]
	private GameObject gestureGroup;

	[SerializeField]
	private CanvasGroup tooltipGroup;

	[SerializeField]
	private RustText tooltipNameText;

	[SerializeField]
	private RustText tooltipDescText;

	[SerializeField]
	private CanvasGroup tooltipImageGroup;

	[SerializeField]
	private CoverImage tooltipImage;

	[SerializeField]
	private CoverVideo tooltipVideo;

	[SerializeField]
	[Space]
	private ScrollRect scrollRect;

	[SerializeField]
	private CanvasGroup scrollbar;

	[SerializeField]
	private RectMask2D mask;

	[SerializeField]
	private UI_Popup safeModePopupPrefab;

	[SerializeField]
	private UI_SettingsGestureWheel gestureWheel;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
private class SettingTab
{
	public string name;

	public UI_SettingsTabButton tabButton;

	public GameObject content;

	[ReadOnly]
	public List<SettingEntry> settings;

	public RustButton button => tabButton.button;

	public CanvasGroup canvasGroup => tabButton.canvasGroup;
}


using System;
using UnityEngine;

private class SettingEntry
{
	[NonSerialized]
	public SettingTab ownerTab;

	public string convarName;

	public string nameToken;

	public UI_SettingsTweakBase tweakUIBase;

	private CanvasGroup _canvasGroup;

	private RustText _labelText;

	private RustButton _button;

	private string searchIndex;

	public GameObject gameObject
	{
		get
		{
			UI_SettingsTweakBase uI_SettingsTweakBase = tweakUIBase;
			if (uI_SettingsTweakBase == null)
			{
				return null;
			}
			return ((Component)uI_SettingsTweakBase).gameObject;
		}
	}

	public CanvasGroup canvasGroup
	{
		get
		{
			if ((Object)(object)_canvasGroup == (Object)null)
			{
				_canvasGroup = gameObject.GetComponent<CanvasGroup>();
			}
			return _canvasGroup;
		}
	}

	public RustText labelText
	{
		get
		{
			if ((Object)(object)_labelText == (Object)null)
			{
				_labelText = gameObject.GetComponentInChildren<RustText>();
			}
			return _labelText;
		}
	}

	public RustButton button
	{
		get
		{
			if ((Object)(object)_button == (Object)null)
			{
				_button = gameObject.GetComponent<RustButton>();
			}
			return _button;
		}
	}

	public SettingEntry(string convarName, UI_SettingsTweakBase tweakUIBase)
	{
		this.convarName = convarName;
		this.tweakUIBase = tweakUIBase;
	}

	public string GetSettingName()
	{
		return Translate.Get(nameToken, (string)null, false);
	}

	public string GetTooltip()
	{
		return Translate.Get(tweakUIBase.tooltip.token, (string)null, false);
	}

	public void BuildSearchIndex()
	{
		searchIndex = string.Join(" ", GetSettingName(), GetTooltip());
	}

	public bool Matches(string query)
	{
		if (string.IsNullOrWhiteSpace(query))
		{
			return false;
		}
		string[] array = query.Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries);
		foreach (string text in array)
		{
			int startIndex = 0;
			while (true)
			{
				int num = searchIndex.IndexOf(text, startIndex, StringComparison.OrdinalIgnoreCase);
				if (num < 0)
				{
					break;
				}
				if (!RustText.IsInsideTag(searchIndex, num))
				{
					return true;
				}
				startIndex = num + text.Length;
			}
		}
		return false;
	}
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SettingsKeyBindsTab : MonoBehaviour
{
	private UI_SettingsTweakKeyBind[] keybinds;

	public static string keyDefaults;
}


using Rust.UI;
using UnityEngine;

public class UI_SettingsTabButton : MonoBehaviour
{
	public RustButton button;

	public CanvasGroup canvasGroup;

	public GameObject searchResult;

	public RustText searchResultCountText;

	public void SetSearchResult(int matchCount)
	{
		canvasGroup.alpha = ((matchCount != 0) ? 1f : 0.3f);
		searchResult.SetActive(matchCount != 0);
		if (matchCount != 0)
		{
			searchResultCountText.SetText(matchCount.ToString());
		}
	}

	public void CancelSearch()
	{
		canvasGroup.alpha = 1f;
		searchResult.SetActive(false);
	}
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreCart : UI_Window
{
	public static readonly Phrase CartEmptyPhrase = new Phrase("store.cart", "Cart");

	public static readonly Phrase CartPhrase = new Phrase("store.cart.items", "Cart ({0})");

	[SerializeField]
	[Space]
	private StyleAsset emptyStyle;

	[SerializeField]
	private StyleAsset notEmptySyle;

	[SerializeField]
	private RustButton cartButton;

	[SerializeField]
	private Canvas cartButtonCanvas;

	[SerializeField]
	private RustText cartButtonText;

	[SerializeField]
	private RustText itemCountText;

	[SerializeField]
	private RustText totalValueText;

	[Space]
	[SerializeField]
	private RectTransform itemParent;

	[SerializeField]
	private GameObject cartItemPrefab;

	[SerializeField]
	private RustButton checkoutButton;

	[SerializeField]
	private GameObject emptyGroup;

	[SerializeField]
	private GameObject footer;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreCartItem : MonoBehaviour
{
	public RustButton closeButton;

	public StoreSource source;

	private IPlayerItemDefinition _item;
}


public static class IPlayerItemDefinitionExtensions
{
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UI_StoreGeneralSubTabButton : BaseMonoBehaviour
{
	[SerializeField]
	private FlexTransition transition;

	[Space]
	[SerializeField]
	private FlexElement flexElement;

	[SerializeField]
	private FlexElement textParent;

	[SerializeField]
	private RustText text;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreGeneralTabButton : MonoBehaviour
{
	[SerializeField]
	private UI_StoreGeneralTab generalTab;
}


public static class PriceFormatter
{
}


using Rust.UI.MainMenu;

public class UI_StoreDLCTab : UI_StoreTabBase
{
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreFeaturedTab : UI_StoreTabBase
{
	[Space]
	[SerializeField]
	private UI_StoreCountdown countdown;
}


using System;
using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreGeneralTab : UI_StoreTabBase
{
	[Serializable]
	public struct Section
	{
		public string Name;

		public GameObject Group;

		public RectTransform MarkdownTarget;

		public RustButton Button;
	}

	[Space]
	[SerializeField]
	private ScrollRect scrollRect;

	[SerializeField]
	private RectTransform content;

	[SerializeField]
	private FlexElement scrollRectContentFlex;

	[SerializeField]
	[Space]
	private Section[] sections;

	[SerializeField]
	private RectMask2D mask;
}


using System;
using UnityEngine;

[Serializable]
public struct Section
{
	public string Name;

	public GameObject Group;

	public RectTransform MarkdownTarget;

	public RustButton Button;
}


using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreLimitedTab : UI_StoreTabBase
{
	[Space]
	[SerializeField]
	private UI_StoreItemGrid itemGrid;

	[SerializeField]
	private UI_StoreCountdown countdown;

	[SerializeField]
	private Scrollbar scrollbar;

	[SerializeField]
	private ScrollRect scrollRect;
}


using Rust.UI.MainMenu;

public class UI_StoreTabBase : UI_Window
{
	protected UI_Store store;
}


using System;
using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_Store : UI_Page
{
	[Serializable]
	private class StoreTab
	{
		public string name;

		public RustButton button;

		public UI_StoreTabBase page;
	}

	private const string JOURNEY_ID_KEY = "journey_id";

	public static UI_Store Instance;

	[SerializeField]
	private List<StoreTab> tabs;

	[SerializeField]
	private SteamDLCItem[] dlcItems;

	[SerializeField]
	private UI_StoreLimitedItemModal weeklySkinModal;

	[SerializeField]
	private UI_StoreCart cart;

	[SerializeField]
	private RectTransform pageOverlayParent;

	[SerializeField]
	private GameObject loadingOverlay;

	[SerializeField]
	private GameObject noConnectionOverlay;

	public UI_StoreTakeover Takeovers;

	public UI_StoreCheckoutResultPage checkoutResultPagePrefab;

	[SerializeField]
	private GameObject newHeaderButtonTag;

	public static int CurrentWeekID;

	private const string CART_KEY = "STORE_CART_ITEMS";

	[SerializeField]
	[Header("Search")]
	private UI_StoreItemGrid searchGrid;

	[SerializeField]
	private RustText searchSubtitleText;

	public static Guid JourneyId
	{
		get
		{
			if (Guid.TryParse(PlayerPrefs.GetString("journey_id", ""), out var result))
			{
				return result;
			}
			Guid result2 = Guid.NewGuid();
			PlayerPrefs.SetString("journey_id", result2.ToString());
			PlayerPrefs.Save();
			return result2;
		}
		private set
		{
			PlayerPrefs.SetString("journey_id", value.ToString());
			PlayerPrefs.Save();
		}
	}

	public void EnsureJourneyId()
	{
		_ = JourneyId;
	}

	public void CreateNewJourneyId()
	{
		PlayerPrefs.DeleteKey("journey_id");
		PlayerPrefs.Save();
		EnsureJourneyId();
	}

	private StoreSource ParseSource(string query)
	{
		StoreSource result = default(StoreSource);
		string[] array = query.Split('&');
		foreach (string text in array)
		{
			if (text.StartsWith("source_area="))
			{
				result.source_area = text.Substring(12);
			}
			else if (text.StartsWith("source="))
			{
				result.source = text.Substring(7);
			}
			else if (text.StartsWith("source_id="))
			{
				result.source_id = text.Substring(10);
			}
		}
		return result;
	}
}


using System;

[Serializable]
private class StoreTab
{
	public string name;

	public RustButton button;

	public UI_StoreTabBase page;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreAddCartButton : ListComponent<UI_StoreAddCartButton>
{
	[SerializeField]
	private StyleAsset notInCartStyle;

	[SerializeField]
	private StyleAsset inCartStyle;

	[SerializeField]
	private RustButton button;

	[SerializeField]
	private RustText priceText;

	[SerializeField]
	private GameObject discountTag;

	[SerializeField]
	private RustText discountText;

	[SerializeField]
	[Space]
	private Animator animator;

	[SerializeField]
	private UI_StoreCartButtonAnimation animationSequence;

	[SerializeField]
	[Space]
	private Rust.UI.SteamInventoryItem autoInitItem;
}


using UnityEngine;
using UnityEngine.UI;

public class UI_StoreBackground : BaseMonoBehaviour
{
	public RectTransform viewport;

	public RectTransform section;

	public Image backgroundImage;

	public float fadeRange = 400f;

	public float fadeSpeed = 5f;
}


using System;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreCarrouselButton : MonoBehaviour
{
	public RustButton button;

	[Space]
	public RustText titleText;

	public RustText subtitleText;

	public CoverImage coverImage;

	public GameObject videoIcon;

	[Space]
	public GameObject gaugeParent;

	public Image gaugeImage;

	public GameObject variantGroup;

	public RustText variantText;

	public void UpdateGauge(float fillAmount)
	{
		if (fillAmount != 0f && !gaugeParent.activeInHierarchy)
		{
			gaugeParent.SetActive(true);
		}
		else if (fillAmount == 0f && gaugeParent.activeInHierarchy)
		{
			gaugeParent.SetActive(false);
		}
		gaugeImage.fillAmount = fillAmount;
	}

	public Texture GetTexture()
	{
		CoverImage obj = coverImage;
		if (obj == null)
		{
			return null;
		}
		return obj.texture;
	}

	public void Init(IPlayerItemDefinition itemDef)
	{
	}

	public void Init(UI_StoreItemOverlayPage.PageElement element)
	{
		if (element.Name != null && !string.IsNullOrEmpty(element.Name.english))
		{
			titleText.SetPhrase(element.Name, Array.Empty<object>());
		}
		else if ((Object)(object)element.Item != (Object)null)
		{
			titleText.SetPhrase(element.Item.displayName, Array.Empty<object>());
		}
		videoIcon.SetActive(element.isVideo);
		coverImage.texture = (((Object)(object)element.GalleryImage != (Object)null) ? element.GalleryImage : element.FullscreenImage);
		variantGroup.SetActive(element.VariantCount > 0);
		variantText.SetText(element.VariantCount.ToString());
	}
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UI_StoreCartButtonAnimation : BaseMonoBehaviour
{
	[SerializeField]
	private CanvasGroup loading;

	[SerializeField]
	private GameObject addToCartGroup;

	[Space]
	[SerializeField]
	private FlexElement inCartGroup;

	[SerializeField]
	private FlexElement inCartTextParent;

	[SerializeField]
	private RustFlexText inCartText;

	[SerializeField]
	private FlexGraphicTransform inCartIcon;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreCheckoutResultButton : MonoBehaviour
{
	public RustButton button;

	[Space]
	[SerializeField]
	private RustText titleText;

	[SerializeField]
	private RustText subtitleText;

	[SerializeField]
	[Space]
	private CoverImage takeoverImage;

	[SerializeField]
	private HttpImage httpImage;

	[SerializeField]
	[Space]
	private GameObject gaugeParent;

	[SerializeField]
	private Image gaugeImage;

	[Header("Animation")]
	[SerializeField]
	[Space]
	private CanvasGroup canvasGroup;
}


using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreCheckoutResultPage : UI_Window
{
	[Space]
	[SerializeField]
	private FlexTransition crossFadeTransition;

	[SerializeField]
	private CoverImage coverBackground;

	[SerializeField]
	private Sprite defaultBackground;

	[SerializeField]
	private RustText itemNameText;

	[SerializeField]
	private RustText itemSubtitleText;

	[SerializeField]
	[Space]
	private UI_StoreCheckoutResultButton carrouselButtonPrefab;

	[SerializeField]
	private RectTransform buttonsParent;

	[Space]
	[SerializeField]
	private GraphicRaycaster footerGraphicRaycaster;

	[SerializeField]
	private CanvasGroup arrowButtons;

	[SerializeField]
	private ScrollRect scrollRect;

	[SerializeField]
	private FlexElement scrollContentFlex;

	[SerializeField]
	private CanvasGroup leftArrow;

	[SerializeField]
	private CanvasGroup rightArrow;

	[SerializeField]
	private bool autoCycleEnabled = true;

	[SerializeField]
	private float autoCycleInterval = 10f;

	[SerializeField]
	private UI_StoreTakeover localTakeovers;

	[Space]
	[Header("Skin Viewer")]
	[SerializeField]
	private CoverImage skinViewerImage;

	[SerializeField]
	private GameObject icon3D;

	[SerializeField]
	private GameObject icon2D;

	[SerializeField]
	private GameObject loadingOverlay;

	[SerializeField]
	protected HttpImage iconImage;

	[SerializeField]
	[Header("Intro Sequence")]
	private CanvasGroup fadeOverlay;

	[SerializeField]
	private CanvasGroup inventoryButton;
}


using Rust.UI;
using UnityEngine;

public class UI_StoreCountdown : MonoBehaviour
{
	[SerializeField]
	private RustText refreshesInText;

	[SerializeField]
	private RustText countdownText;
}


using Rust.UI.MainMenu;

public class UI_StoreFakeItemsTakeover : UI_StoreTakeover
{
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreItemDLC : MonoBehaviour
{
	public int appID;

	public UI_StoreItemOverlayPage overlayPagePrefab;

	public UI_StoreAddCartButton cartButton;

	private IPlayerItemDefinition _item;
}


using System;

[Serializable]
public struct StoreSource
{
	public string source_area;

	public string source;

	public string source_id;
}


using System;
using System.Collections.Generic;
using Facepunch.Flexbox;
using Rust.UI.MainMenu;
using UnityEngine;

[RequireComponent(typeof(FlexGridsElement))]
public class UI_StoreItemGrid : MonoBehaviour
{
	public enum OrderingRule
	{
		TakeoverOrder,
		WhitelistOrder,
		OwnedLast,
		OwnedFirst,
		PriceLowToHigh,
		PriceHighToLow,
		Alphabetical,
		ReverseAlphabetical,
		FeaturedFirst,
		LargestFirst,
		Random,
		FeaturedLast,
		FakeItemsOrder,
		FeaturingOrder
	}

	public enum RuleMatchMode
	{
		All,
		Any
	}

	public enum FilterRule
	{
		TagInclude,
		TagExclude,
		OnlyFeatured,
		ExcludeFeatured,
		NeedTakeOver,
		ItemShortName,
		ExcludeOwned
	}

	[Serializable]
	public class StoreFilterRule
	{
		public bool enabled = true;

		public FilterRule ruleType;

		public List<string> tags = new List<string>();

		public List<string> itemShortNames = new List<string>();
	}

	[Serializable]
	public struct ItemSizeSettings
	{
		public SteamInventoryItem Item;

		public int ItemID;

		[Range(1f, 12f)]
		public int SizeX;

		[Range(1f, 5f)]
		public int SizeY;

		public int GetItemID
		{
			get
			{
				if (!((Object)(object)Item != (Object)null))
				{
					return ItemID;
				}
				return Item.id;
			}
		}
	}

	[SerializeField]
	private FlexGridsElement grid;

	[SerializeField]
	[Tooltip("The source of the items, for analytics")]
	private StoreSource source;

	[SerializeField]
	[Space]
	private UI_StoreItemTile skinItemTilePrefab;

	[SerializeField]
	private UI_StoreItemTile featuredSkinItemTilePrefab;

	[SerializeField]
	private bool allowExtraItems;

	[SerializeField]
	private int maxCellCount;

	[SerializeField]
	[Min(0f)]
	public int cellWidth;

	[SerializeField]
	[Min(0f)]
	public int cellHeight;

	public bool fixedGrid;

	public List<Vector2Int> fixedSizes = new List<Vector2Int>();

	[SerializeField]
	private bool autoSizing;

	[SerializeField]
	private Vector2 baseItemSize = new Vector2(1f, 1f);

	[SerializeField]
	private Vector2 featuredItemSize;

	[SerializeField]
	private ItemSizeSettings[] sizeOverrides;

	[SerializeField]
	private List<OrderingRule> orderingRules = new List<OrderingRule>();

	[SerializeField]
	private List<SteamInventoryItem> whiteListedItems = new List<SteamInventoryItem>();

	[SerializeField]
	private UI_StoreFakeItemsTakeover fakeAdditionalItems;

	public bool dynamicContent = true;

	[SerializeField]
	private RuleMatchMode ruleMatchMode = RuleMatchMode.Any;

	[SerializeField]
	private List<StoreFilterRule> rules = new List<StoreFilterRule>();

	public FlexGridsElement Grid => grid;

	private UI_Store store => UI_Store.Instance;
}


public enum OrderingRule
{
	TakeoverOrder,
	WhitelistOrder,
	OwnedLast,
	OwnedFirst,
	PriceLowToHigh,
	PriceHighToLow,
	Alphabetical,
	ReverseAlphabetical,
	FeaturedFirst,
	LargestFirst,
	Random,
	FeaturedLast,
	FakeItemsOrder,
	FeaturingOrder
}


public enum RuleMatchMode
{
	All,
	Any
}


public enum FilterRule
{
	TagInclude,
	TagExclude,
	OnlyFeatured,
	ExcludeFeatured,
	NeedTakeOver,
	ItemShortName,
	ExcludeOwned
}


using System;
using System.Collections.Generic;

[Serializable]
public class StoreFilterRule
{
	public bool enabled = true;

	public FilterRule ruleType;

	public List<string> tags = new List<string>();

	public List<string> itemShortNames = new List<string>();
}


using System;
using UnityEngine;

[Serializable]
public struct ItemSizeSettings
{
	public global::SteamInventoryItem Item;

	public int ItemID;

	[Range(1f, 12f)]
	public int SizeX;

	[Range(1f, 5f)]
	public int SizeY;

	public int GetItemID
	{
		get
		{
			if (!((Object)(object)Item != (Object)null))
			{
				return ItemID;
			}
			return Item.id;
		}
	}
}


using System;
using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreItemOverlayPage : UI_Window
{
	[Serializable]
	public struct PageElement
	{
		public Phrase Name;

		[ItemSelector]
		public ItemDefinition Item;

		public bool isVideo;

		public string videoURL;

		public Texture FullscreenImage;

		public Texture GalleryImage;

		[Min(0f)]
		public int VariantCount;

		public bool overrideItem;

		public Phrase ItemName;

		public Sprite ItemIcon;

		public Phrase GetTitle()
		{
			if (Name != null && !string.IsNullOrEmpty(Name.english))
			{
				return Name;
			}
			if ((Object)(object)Item != (Object)null)
			{
				return Item.displayName;
			}
			return Phrase.op_Implicit(string.Empty);
		}

		public Phrase GetRedirectItemName()
		{
			if ((Object)(object)Item != (Object)null && (Object)(object)Item.isRedirectOf != (Object)null)
			{
				return Item.isRedirectOf.displayName;
			}
			if (overrideItem)
			{
				return ItemName;
			}
			return null;
		}

		public Sprite GetRedirectItemIcon()
		{
			if ((Object)(object)Item != (Object)null && (Object)(object)Item.isRedirectOf != (Object)null)
			{
				return Item.isRedirectOf.iconSprite;
			}
			if (overrideItem)
			{
				return ItemIcon;
			}
			return null;
		}
	}

	[Serializable]
	public struct PageContent
	{
		public PageElement[] Elements;
	}

	[SerializeField]
	[Header("Page Content")]
	[Space]
	private FlexTransition crossFadeTransition;

	[SerializeField]
	private CoverVideo coverVideo;

	[SerializeField]
	private CoverImage coverImage;

	[SerializeField]
	private UI_BackgroundAspectRatioFitter coverBackground;

	[SerializeField]
	private GameObject textContainerGroup;

	[SerializeField]
	private RustText titleText;

	[SerializeField]
	private GameObject itemGroup;

	[SerializeField]
	private RustText itemNameText;

	[SerializeField]
	private Image itemIconImage;

	[SerializeField]
	private GameObject variantGroup;

	[SerializeField]
	private RustText variantCoutText;

	[Header("Gallery")]
	[SerializeField]
	private Transform galleryParent;

	[SerializeField]
	private CanvasGroup arrowButtons;

	[SerializeField]
	private ScrollRect scrollRect;

	[SerializeField]
	private CanvasGroup leftArrow;

	[SerializeField]
	private CanvasGroup rightArrow;

	[SerializeField]
	private UI_StoreAddCartButton cartButton;

	[SerializeField]
	private GameObject ownedButton;

	[Space]
	[SerializeField]
	private bool autoCycleEnabled = true;

	[SerializeField]
	private float autoCycleInterval = 10f;

	[SerializeField]
	private UI_StoreCarrouselButton carouselButtonPrefab;

	[SerializeField]
	[Space]
	private PageContent pageContent;
}


using System;
using UnityEngine;

[Serializable]
public struct PageElement
{
	public Phrase Name;

	[ItemSelector]
	public ItemDefinition Item;

	public bool isVideo;

	public string videoURL;

	public Texture FullscreenImage;

	public Texture GalleryImage;

	[Min(0f)]
	public int VariantCount;

	public bool overrideItem;

	public Phrase ItemName;

	public Sprite ItemIcon;

	public Phrase GetTitle()
	{
		if (Name != null && !string.IsNullOrEmpty(Name.english))
		{
			return Name;
		}
		if ((Object)(object)Item != (Object)null)
		{
			return Item.displayName;
		}
		return Phrase.op_Implicit(string.Empty);
	}

	public Phrase GetRedirectItemName()
	{
		if ((Object)(object)Item != (Object)null && (Object)(object)Item.isRedirectOf != (Object)null)
		{
			return Item.isRedirectOf.displayName;
		}
		if (overrideItem)
		{
			return ItemName;
		}
		return null;
	}

	public Sprite GetRedirectItemIcon()
	{
		if ((Object)(object)Item != (Object)null && (Object)(object)Item.isRedirectOf != (Object)null)
		{
			return Item.isRedirectOf.iconSprite;
		}
		if (overrideItem)
		{
			return ItemIcon;
		}
		return null;
	}
}


using System;

[Serializable]
public struct PageContent
{
	public PageElement[] Elements;
}


using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreItemTile : BaseMonoBehaviour
{
	public RustButton button;

	[SerializeField]
	public CanvasGroup animatedParent;

	[SerializeField]
	private RustText skinNameText;

	[SerializeField]
	private RustText itemTypeText;

	[Space]
	[SerializeField]
	private CanvasGroup imageGroup;

	[SerializeField]
	protected HttpImage httpImage;

	[SerializeField]
	private CoverVideo coverVideo;

	[SerializeField]
	public CoverImage coverImage;

	[SerializeField]
	[Header("Header")]
	[Space]
	private GameObject headerTextGroup;

	[SerializeField]
	private RustText headerText;

	[SerializeField]
	private FlexElement paddedContainer;

	[SerializeField]
	private UI_StoreAddCartButton cartButton;

	[Space]
	[SerializeField]
	private GameObject ownedTag;

	[SerializeField]
	private bool disableCartWhenOwned;

	[SerializeField]
	private bool fadeIconWhenOwned = true;
}


using System.Collections.Generic;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreItemTileWeeklySkin : UI_StoreItemTile
{
	[SerializeField]
	private bool applyIconColor;

	[SerializeField]
	private bool animatedShimmers;

	[SerializeField]
	private Image coloredGradient;

	private static readonly Dictionary<IPlayerItemDefinition, Color> CachedGradientColors = new Dictionary<IPlayerItemDefinition, Color>();

	private static readonly int ShimmerStrength = Shader.PropertyToID("_ShimmerStrength");

	private static readonly int ShimmerSpeed = Shader.PropertyToID("_ShimmerSpeed");

	[SerializeField]
	private float idleShimmerStrength;

	[SerializeField]
	private float idleShimmerSpeed;

	[SerializeField]
	private float hoverShimmerStrength = 0.154f;

	[SerializeField]
	private float hoverShimmerSpeed = 0.03f;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreLimitedItemModal : UI_SteamInventoryPlayerItemModal
{
	[SerializeField]
	private UI_StoreAddCartButton cartButton;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StorePackShowcase : MonoBehaviour
{
	public SteamInventoryItem item;

	public UI_StoreAddCartButton cartButton;

	public GameObject background;
}


using System;
using Facepunch.Models;
using Rust.UI.MainMenu;
using UnityEngine;

[Serializable]
public struct ItemStoreTakeover
{
	public Phrase NameOverride;

	public Phrase SubtitleOverride;

	public Phrase HeaderPhrase;

	public Sprite IconOverride;

	public Sprite IconPortraitOverride;

	public Sprite IconSquareOverride;

	public string ImageURL;

	public string VideoURL;

	public UI_StoreItemOverlayPage PagePrefab;

	public UI_StoreItemTile TilePrefabOverride;

	public SteamInventoryItem Item;

	[Tooltip("Will be used if you don't have an Item definition (DLCs)")]
	public int ItemId;

	public readonly int GetItemID()
	{
		if (!((Object)(object)Item != (Object)null))
		{
			return ItemId;
		}
		return Item.id;
	}

	public ItemStoreTakeover(StoreFeaturing storeFeaturing)
	{
		NameOverride = Phrase.op_Implicit(storeFeaturing.TitleText);
		SubtitleOverride = Phrase.op_Implicit(storeFeaturing.SubtitleText);
		HeaderPhrase = Phrase.op_Implicit(storeFeaturing.HeaderText);
		ImageURL = storeFeaturing.ImageUrl;
		VideoURL = storeFeaturing.VideoUrl;
		ItemId = storeFeaturing.ItemID;
		IconOverride = null;
		IconPortraitOverride = null;
		IconSquareOverride = null;
		PagePrefab = null;
		TilePrefabOverride = null;
		Item = null;
	}

	public readonly bool IsValid()
	{
		return GetItemID() != 0;
	}

	public void OverridesWith(ItemStoreTakeover other)
	{
		if (!string.IsNullOrEmpty(other.NameOverride.translated))
		{
			NameOverride = other.NameOverride;
		}
		if (!string.IsNullOrEmpty(other.SubtitleOverride.translated))
		{
			SubtitleOverride = other.SubtitleOverride;
		}
		if (other.HeaderPhrase != null && !string.IsNullOrEmpty(other.HeaderPhrase.translated))
		{
			HeaderPhrase = other.HeaderPhrase;
		}
		if ((Object)(object)other.IconOverride != (Object)null)
		{
			IconOverride = other.IconOverride;
		}
		if ((Object)(object)other.IconPortraitOverride != (Object)null)
		{
			IconPortraitOverride = other.IconPortraitOverride;
		}
		if ((Object)(object)other.IconSquareOverride != (Object)null)
		{
			IconSquareOverride = other.IconSquareOverride;
		}
		if (!string.IsNullOrEmpty(other.ImageURL))
		{
			ImageURL = other.ImageURL;
		}
		if (!string.IsNullOrEmpty(other.VideoURL))
		{
			VideoURL = other.VideoURL;
		}
		if ((Object)(object)other.PagePrefab != (Object)null)
		{
			PagePrefab = other.PagePrefab;
		}
		if ((Object)(object)other.TilePrefabOverride != (Object)null)
		{
			TilePrefabOverride = other.TilePrefabOverride;
		}
		if ((Object)(object)other.Item != (Object)null)
		{
			Item = other.Item;
		}
		if (other.ItemId != 0)
		{
			ItemId = other.ItemId;
		}
	}

	public Sprite GetBestIconForRect(float width, float height)
	{
		float num = width / height;
		bool flag = num > 1.15f;
		bool flag2 = num < 0.8f;
		if (flag)
		{
			return IconOverride;
		}
		if (flag2)
		{
			if ((Object)(object)IconPortraitOverride != (Object)null)
			{
				return IconPortraitOverride;
			}
			return IconOverride;
		}
		if ((Object)(object)IconSquareOverride != (Object)null)
		{
			return IconSquareOverride;
		}
		return IconOverride;
	}
}


using System;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreTakeover : MonoBehaviour
{
	public bool ignoreFeaturingTakeovers;

	public ItemStoreTakeover[] Takeovers = Array.Empty<ItemStoreTakeover>();
}


using UnityEngine;

public class UI_BackgroundAspectRatioFitter : MonoBehaviour
{
	public RectTransform rectTransform;

	public Vector2 offset;
}


using UnityEngine;

public class UI_MainMenuNavigate : MonoBehaviour
{
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_Popup : UI_Window
{
	[Space]
	[SerializeField]
	private Transform buttonsParent;

	[SerializeField]
	private RustText titleText;

	[SerializeField]
	private RustText messageText;

	[SerializeField]
	private RustButton buttonTemplate;

	[SerializeField]
	private RustButton[] buttons;
}


using System;
using Facepunch.Flexbox;
using UnityEngine;

public class UI_Window : BaseMonoBehaviour
{
	[SerializeField]
	private bool _skipAutoFixState;

	[Header("Window - Transitions")]
	[SerializeField]
	private FlexTransition _openTransition;

	[SerializeField]
	private bool _oneShotTransition;

	[Header("Window - Canvas")]
	[SerializeField]
	protected CanvasGroup _group;

	[SerializeField]
	[Header("Window - Escape Capture")]
	protected UIEscapeCapture _escape;

	[Header("Window - Flex Element")]
	[SerializeField]
	private FlexElement _flex;

	protected bool _firstTimeOpened = true;

	protected bool _opened;

	public event Action OnOpen;

	public event Action OnClose;

	protected virtual void Awake()
	{
		if (!_opened && !_skipAutoFixState)
		{
			FixBrokenState();
		}
	}

	private void FixBrokenState()
	{
		TimeWarning val = TimeWarning.New("UI_Window.FixBrokenState", 0);
		try
		{
			if ((Object)(object)_group == (Object)null)
			{
				if (((Component)this).gameObject.activeSelf)
				{
					((Component)this).gameObject.SetActive(false);
				}
				return;
			}
			if (!((Component)this).gameObject.activeSelf)
			{
				((Component)this).gameObject.SetActive(true);
			}
			SetUI(state: false);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void Open()
	{
		if (!_opened)
		{
			_opened = true;
			SetUI(state: true);
			OnOpened();
			if (_firstTimeOpened)
			{
				_firstTimeOpened = false;
			}
		}
	}

	public virtual void Close()
	{
		if (_opened)
		{
			_opened = false;
			SetUI(state: false);
			OnClosed();
		}
	}

	public bool IsOpen()
	{
		return _opened;
	}

	protected virtual void OnOpened()
	{
		this.OnOpen?.Invoke();
		if (Object.op_Implicit((Object)(object)_openTransition))
		{
			if (_oneShotTransition)
			{
				_openTransition.PlayOneOff();
			}
			else
			{
				_openTransition.SwitchState(true, true);
			}
		}
	}

	protected virtual void OnClosed()
	{
		this.OnClose?.Invoke();
		if (Object.op_Implicit((Object)(object)_openTransition))
		{
			_openTransition.SwitchState(false, false);
		}
	}

	public virtual void SetUI(bool state)
	{
		if ((Object)(object)_group == (Object)null)
		{
			((Component)this).gameObject.SetActive(state);
		}
		else
		{
			if (state && !((Component)this).gameObject.activeSelf)
			{
				((Component)this).gameObject.SetActive(true);
			}
			_group.alpha = (state ? 1 : 0);
			_group.interactable = state;
			_group.blocksRaycasts = state;
		}
		if ((Object)(object)_escape != (Object)null)
		{
			((Behaviour)_escape).enabled = state;
		}
		if ((Object)(object)_flex != (Object)null)
		{
			((Behaviour)_flex).enabled = state;
		}
	}
}


using Rust.UI;
using Rust.UI.MainMenu;
using Rust.UI.MainMenu.Workshop;
using UnityEngine;

public class UI_Workshop : UI_Page
{
	public static UI_Workshop Instance;

	[SerializeField]
	private UI_WorkshopItemList itemList;

	[SerializeField]
	private RustButton initialTabButton;

	public static Phrase loading_workshop = (Phrase)(object)new TokenisedPhrase("loading.workshop", "Loading Workshop");

	public static Phrase loading_workshop_setup = (Phrase)(object)new TokenisedPhrase("loading.workshop.initializing", "Setting Up Scene");

	public static Phrase loading_workshop_skinnables = (Phrase)(object)new TokenisedPhrase("loading.workshop.skinnables", "Getting Skinnables");

	public static Phrase loading_workshop_item = (Phrase)(object)new TokenisedPhrase("loading.workshop.item", "Loading Item Data");

	private readonly Phrase createNewSkinPhrase = new Phrase("workshop.createskin.title", "Create skin");

	private readonly Phrase createNewSkinBodyPhrase = new Phrase("workshop.createskin.body", "Do you want to create a new skin? This will load the workshop scene.");

	private readonly Phrase yesPhrase = new Phrase("workshop.continue", "Continue");

	private readonly Phrase cancelPhrase = new Phrase("workshop.cancel", "Cancel");
}


using Rust.UI;
using UnityEngine;

public class UI_WorkshopItemButton : MonoBehaviour
{
	[SerializeField]
	private HttpImage httpImage;

	[SerializeField]
	private Transform scaledParent;

	[SerializeField]
	private GameObject loadingIndicator;
}


using Rust.UI;
using Rust.UI.MainMenu.Workshop;
using UnityEngine;

public class UI_WorkshopItemList : MonoBehaviour
{
	[SerializeField]
	private RustButton previousPageButton;

	[SerializeField]
	private RustButton nextPageButton;

	[SerializeField]
	private UI_WorkshopItemButton itemPrefab;

	[SerializeField]
	private UI_WorkshopItemButton myItemPrefab;

	[SerializeField]
	private Transform itemsParent;

	[SerializeField]
	private RustText pageInfoText;

	[SerializeField]
	private Dropdown itemTypeSelector;
}


using System;
using System.Collections.Generic;
using Benchmark;
using ProtoBuf;
using UnityEngine;

[JsonModel]
public class Building
{
	[JsonModel]
	public class Entity
	{
		public ulong NetId;

		public string ResPath;

		public ulong ParentNetId;

		public Vector3 Pos;

		public Vector3 RotEuler;

		public ulong SkinID;

		public virtual void FromProto(Entity ent)
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			NetId = ent.baseNetworkable.uid.Value;
			ResPath = StringPool.Get(ent.baseNetworkable.prefabID);
			ParentNetId = ent.parent?.uid.Value ?? 0;
			Pos = ent.baseEntity.pos;
			RotEuler = ent.baseEntity.rot;
			SkinID = ent.baseEntity.skinid;
		}
	}

	[JsonModel]
	public class BuildingEntity : Entity
	{
		public BuildingGrade.Enum Grade;

		public ulong Model;

		public override void FromProto(Entity ent)
		{
			base.FromProto(ent);
			if (ent.buildingBlock != null)
			{
				Grade = (BuildingGrade.Enum)ent.buildingBlock.grade;
				Model = ent.buildingBlock.model;
			}
			else
			{
				Grade = BuildingGrade.Enum.None;
				Model = 0uL;
			}
		}
	}

	[JsonModel]
	public class SpawnMarker
	{
		[Flags]
		public enum SpawnType
		{
			LocalPlayer = 1,
			RemotePlayer = 2
		}

		public Vector3 Pos;

		public Vector3 RotEuler;

		public SpawnType Type;
	}

	public const uint InvalidBuildingId = 0u;

	public uint Id;

	public List<BuildingEntity> BuildingEntities;

	public List<SpawnMarker> SpawnMarkers;

	public Building(uint id)
	{
		Id = id;
		BuildingEntities = new List<BuildingEntity>();
		SpawnMarkers = new List<SpawnMarker>();
	}

	public override string ToString()
	{
		return $"{Id}: {BuildingEntities.Count} entities";
	}
}


using ProtoBuf;
using UnityEngine;

[JsonModel]
public class Entity
{
	public ulong NetId;

	public string ResPath;

	public ulong ParentNetId;

	public Vector3 Pos;

	public Vector3 RotEuler;

	public ulong SkinID;

	public virtual void FromProto(Entity ent)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		NetId = ent.baseNetworkable.uid.Value;
		ResPath = StringPool.Get(ent.baseNetworkable.prefabID);
		ParentNetId = ent.parent?.uid.Value ?? 0;
		Pos = ent.baseEntity.pos;
		RotEuler = ent.baseEntity.rot;
		SkinID = ent.baseEntity.skinid;
	}
}


using ProtoBuf;

[JsonModel]
public class BuildingEntity : Entity
{
	public BuildingGrade.Enum Grade;

	public ulong Model;

	public override void FromProto(Entity ent)
	{
		base.FromProto(ent);
		if (ent.buildingBlock != null)
		{
			Grade = (BuildingGrade.Enum)ent.buildingBlock.grade;
			Model = ent.buildingBlock.model;
		}
		else
		{
			Grade = BuildingGrade.Enum.None;
			Model = 0uL;
		}
	}
}


using System;
using UnityEngine;

[JsonModel]
public class SpawnMarker
{
	[Flags]
	public enum SpawnType
	{
		LocalPlayer = 1,
		RemotePlayer = 2
	}

	public Vector3 Pos;

	public Vector3 RotEuler;

	public SpawnType Type;
}


using System;

[Flags]
public enum SpawnType
{
	LocalPlayer = 1,
	RemotePlayer = 2
}


using System;
using AntiHackJobs;
using BasePlayerJobs;
using CoarseQueryGridJobs;
using CompanionServer.Cameras;
using Facepunch.MarchingCubes;
using Facepunch.NativeMeshSimplification;
using GamePhysicsJobs;
using GenerateErosionJobs;
using HitBoxSystemJobs;
using Instancing;
using OceanSimulationJobs;
using ProjectileJobs;
using Rust.Water5;
using ServerOcclusionJobs;
using TerrainHeightMapJobs;
using TerrainTexturingJobs;
using TerrainTopologyMapJobs;
using TerrainWaterMapJobs;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.Jobs;
using UtilityJobs;
using WaterLevelJobs;
using WaterSystemJobs;

[DOTSCompilerGenerated]
internal class __JobReflectionRegistrationOutput__1221673671587648887
{
	public static void CreateJobReflectionData()
	{
		try
		{
			IJobExtensions.EarlyJobInit<FishShoal.FishCollisionGatherJob>();
			IJobExtensions.EarlyJobInit<FishShoal.FishCollisionProcessJob>();
			IJobParallelForExtensions.EarlyJobInit<FishShoal.FishUpdateJob>();
			IJobExtensions.EarlyJobInit<FishShoal.KillFish>();
			IJobParallelForTransformExtensions.EarlyJobInit<TransformLineRenderer.LineRendererUpdateJob>();
			IJobExtensions.EarlyJobInit<AddAndBlurSphereJob>();
			IJobForExtensions.EarlyJobInit<BoxBlur3DJob>();
			IJobExtensions.EarlyJobInit<BoxBlurCylinderJob>();
			IJobExtensions.EarlyJobInit<BoxBlurSphereJob>();
			IJobExtensions.EarlyJobInit<CarveAndBlurCylinderJob>();
			IJobExtensions.EarlyJobInit<CarveAndBlurSphereJob>();
			IJobExtensions.EarlyJobInit<CleanFloatingIslandsJob>();
			IJobParallelForExtensions.EarlyJobInit<Hopper.FillRaycastJob>();
			IJobExtensions.EarlyJobInit<PostCullingJob>();
			IJobExtensions.EarlyJobInit<GenerateAscSeqListJob>();
			IJobExtensions.EarlyJobInit<InvertIndexListJob>();
			IJobExtensions.EarlyJobInit<RaycastSamplePositionsJob>();
			IJobExtensions.EarlyJobInit<RaycastBufferSetupJob>();
			IJobParallelForExtensions.EarlyJobInit<RaycastRaySetupJob>();
			IJobParallelForExtensions.EarlyJobInit<RaycastRayProcessingJob>();
			IJobExtensions.EarlyJobInit<RaycastOutputCompressJob>();
			IJobExtensions.EarlyJobInit<RaycastColliderProcessingJob>();
			IJobExtensions.EarlyJobInit<GatherPlayersWithTicksJob>();
			IJobExtensions.EarlyJobInit<BuildLayerMasksJob>();
			IJobExtensions.EarlyJobInit<GatherHitIndicesJob>();
			IJobExtensions.EarlyJobInit<BuildBatchLookupMapJob>();
			IJobExtensions.EarlyJobInit<GatherNoClipBatchesJob>();
			IJobExtensions.EarlyJobInit<FindValidIndicesJob>();
			IJobExtensions.EarlyJobInit<PreCullingJob>();
			IJobParallelForDeferExtensions.EarlyJobInit<FillFalseJobDefer>();
			IJobParallelForDeferExtensions.EarlyJobInit<AdjustByTopologyJob>();
			IJobParallelForDeferExtensions.EarlyJobInit<SmallDisplacementPlaneTraceJob>();
			IJobParallelForDeferExtensions.EarlyJobInit<OceanTraceJob>();
			IJobForExtensions.EarlyJobInit<PaintSplatJob>();
			IJobParallelForExtensions.EarlyJobInit<PopulateDeltaHeightJob>();
			IJobParallelForExtensions.EarlyJobInit<CopyBackFloatHeightToShortHeightJob>();
			IJobParallelForExtensions.EarlyJobInit<EvaporationJob>();
			IJobParallelForBatchExtensions.EarlyJobInit<PrepareMapJob>();
			IJobParallelForExtensions.EarlyJobInit<TransportSedimentJob>();
			IJobParallelForExtensions.EarlyJobInit<CalcMinHeightMapJob>();
			IJobParallelForExtensions.EarlyJobInit<ErosionAndDepositionJob>();
			IJobParallelForExtensions.EarlyJobInit<TileCalculateAngleMap>();
			IJobParallelForExtensions.EarlyJobInit<AdjustWaterHeightByFluxJob>();
			IJobParallelForExtensions.EarlyJobInit<CalculateOutputFluxJob>();
			IJobParallelForExtensions.EarlyJobInit<RefillOceanJob>();
			IJobParallelForExtensions.EarlyJobInit<WaterIncrementationJob>();
			IJobExtensions.EarlyJobInit<GetCoarseDistsToShoreJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightByPosJob>();
			IJobExtensions.EarlyJobInit<GetHeightByUVJob>();
			IJobExtensions.EarlyJobInit<GetHeightByUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightByIndexJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByPosJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByUVJob>();
			IJobExtensions.EarlyJobInit<GetTopologyRadiusJob>();
			IJobParallelForExtensions.EarlyJobInit<GetTopologyRadiusJobIndirect>();
			IJobParallelForExtensions.EarlyJobInit<GetTopologyRadiusNormalizedJobIndirect>();
			IJobExtensions.EarlyJobInit<GetTopologyByIndexJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightsFastJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightsJob>();
			IJobExtensions.EarlyJobInit<TerrainHeightMapJobs.GetHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckPosRadJob>();
			IJobExtensions.EarlyJobInit<CheckPosRadBatchJob>();
			IJobExtensions.EarlyJobInit<CheckPosRadBatchJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckBoundsJob>();
			IJobExtensions.EarlyJobInit<CheckBoundsJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckRayJob>();
			IJobExtensions.EarlyJobInit<CalculatePathBetweenGridsJob>();
			IJobParallelForBatchExtensions.EarlyJobInit<CalculatePathsBetweenGridsJob>();
			IJobExtensions.EarlyJobInit<ToUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherWavesIndicesJobIndirect>();
			IJobExtensions.EarlyJobInit<ApplyMaxHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<SelectMaxWaterLevelJobIndirect>();
			IJobExtensions.EarlyJobInit<CalcCenterJobIndirect>();
			IJobExtensions.EarlyJobInit<InitialValidateInfoJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherValidInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherInvalidInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<UpdateWaterHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<SetupHeadQueryJobIndirect>();
			IJobExtensions.EarlyJobInit<ApplyHeadQueryResultsJobIndirect>();
			IJobExtensions.EarlyJobInit<ResolveWaterInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<UpdateWaterCache>();
			IJobExtensions.EarlyJobInit<GatherPosToValidateJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<RecacheTransforms>();
			IJobExtensions.EarlyJobInit<CalcWaterFactorsJobIndirect>();
			IJobExtensions.EarlyJobInit<GetWaterFactorsParamsJobIndirect>();
			IJobForExtensions.EarlyJobInit<TraceAllJob>();
			IJobExtensions.EarlyJobInit<CalcMidpoingJob>();
			IJobExtensions.EarlyJobInit<CheckHitsJob>();
			IJobExtensions.EarlyJobInit<GenerateOverlapCapsuleCommandsJob>();
			IJobExtensions.EarlyJobInit<ValidateOverlapCapsuleCommandsJob>();
			IJobExtensions.EarlyJobInit<FindSphereCmdsInCapsuleCmdsJob>();
			IJobExtensions.EarlyJobInit<GenerateSphereCmdsFromCapsuleCmdsJob>();
			IJobExtensions.EarlyJobInit<GenerateOverlapSphereCommandsJob>();
			IJobExtensions.EarlyJobInit<ValidateOverlapSphereCommandsJob>();
			IJobExtensions.EarlyJobInit<RemoveLayerMaskJob>();
			IJobExtensions.EarlyJobInit<CountRaycastHitsJobs>();
			IJobExtensions.EarlyJobInit<ScatterColliderHitsJob>();
			IJobExtensions.EarlyJobInit<PreProcessWaterSpheresJob>();
			IJobExtensions.EarlyJobInit<PreProcessWaterRaysJob>();
			IJobExtensions.EarlyJobInit<PostProcessWaterRaysJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<ReadPositionDataTransformJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<BatchUpdateVelocityEndJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<GenerateRaysJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<GenerateRaysMidstepJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<PosRotReadJob>();
			IJobExtensions.EarlyJobInit<CopyBackJob>();
			IJobExtensions.EarlyJobInit<PopulateArraysJob>();
			IJobExtensions.EarlyJobInit<SimplifyMeshJob>();
			IJobParallelForExtensions.EarlyJobInit<BakePhysicsMeshesJob>();
			IJobExtensions.EarlyJobInit<CleanupDuplicateVerticesJob>();
			IJobExtensions.EarlyJobInit<MarchJob>();
			IJobExtensions.EarlyJobInit<GetHeightBatchedJob>();
			IJobExtensions.EarlyJobInit<Rust.Water5.GetHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherJob<OverlapCapsuleCommand>>();
			IJobExtensions.EarlyJobInit<FillJob<float>>();
			IJobExtensions.EarlyJobInit<FillJob<int>>();
			IJobExtensions.EarlyJobInit<FillJob<bool>>();
			IJobExtensions.EarlyJobInit<GatherJob<Vector3>>();
			IJobExtensions.EarlyJobInit<GatherJob<float>>();
			IJobExtensions.EarlyJobInit<CopyArrayJob<float>>();
			IJobExtensions.EarlyJobInit<GatherJob<int>>();
		}
		catch (Exception ex)
		{
			EarlyInitHelpers.JobReflectionDataCreationFailed(ex);
		}
	}

	[RuntimeInitializeOnLoadMethod(/*Could not decode attribute arguments.*/)]
	public static void EarlyInit()
	{
		CreateJobReflectionData();
	}
}


