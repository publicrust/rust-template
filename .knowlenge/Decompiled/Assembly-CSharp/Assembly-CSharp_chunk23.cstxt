using System;
using Rust;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

[DefaultExecutionOrder(-103)]
public class AiManager : SingletonComponent<AiManager>, IServerComponent
{
	[Header("Cover System")]
	[SerializeField]
	public bool UseCover = true;

	public float CoverPointVolumeCellSize = 20f;

	public float CoverPointVolumeCellHeight = 8f;

	public float CoverPointRayLength = 1f;

	public CoverPointVolume cpvPrefab;

	[SerializeField]
	public LayerMask DynamicCoverPointVolumeLayerMask;

	private WorldSpaceGrid<CoverPointVolume> coverPointVolumeGrid;

	[ServerVar(Help = "If true we'll wait for the navmesh to generate before completely starting the server. This might cause your server to hitch and lag as it generates in the background.")]
	public static bool nav_wait = true;

	[ServerVar(Help = "If set to true the navmesh won't generate.. which means Ai that uses the navmesh won't be able to move")]
	public static bool nav_disable = false;

	[ServerVar(Help = "If set to true, npcs will attempt to place themselves on the navmesh if not on a navmesh when set destination is called.")]
	public static bool setdestination_navmesh_failsafe = false;

	[ServerVar(Help = "If ai_dormant is true, any npc outside the range of players will render itself dormant and take up less resources, but wildlife won't simulate as well.")]
	public static bool ai_dormant = true;

	[ServerVar(Help = "If an agent is beyond this distance to a player, it's flagged for becoming dormant.")]
	public static float ai_to_player_distance_wakeup_range = 160f;

	[ServerVar(Help = "nav_obstacles_carve_state defines which obstacles can carve the terrain. 0 - No carving, 1 - Only player construction carves, 2 - All obstacles carve.")]
	public static int nav_obstacles_carve_state = 2;

	[ServerVar(Help = "ai_dormant_max_wakeup_per_tick defines the maximum number of dormant agents we will wake up in a single tick. (default: 30)")]
	public static int ai_dormant_max_wakeup_per_tick = 30;

	[ServerVar(Help = "ai_htn_player_tick_budget defines the maximum amount of milliseconds ticking htn player agents are allowed to consume. (default: 4 ms)")]
	public static float ai_htn_player_tick_budget = 4f;

	[ServerVar(Help = "ai_htn_player_junkpile_tick_budget defines the maximum amount of milliseconds ticking htn player junkpile agents are allowed to consume. (default: 4 ms)")]
	public static float ai_htn_player_junkpile_tick_budget = 4f;

	[ServerVar(Help = "ai_htn_animal_tick_budget defines the maximum amount of milliseconds ticking htn animal agents are allowed to consume. (default: 4 ms)")]
	public static float ai_htn_animal_tick_budget = 4f;

	[ServerVar(Help = "If ai_htn_use_agency_tick is true, the ai manager's agency system will tick htn agents at the ms budgets defined in ai_htn_player_tick_budget and ai_htn_animal_tick_budget. If it's false, each agent registers with the invoke system individually, with no frame-budget restrictions. (default: true)")]
	public static bool ai_htn_use_agency_tick = true;

	private readonly BasePlayer[] playerVicinityQuery = new BasePlayer[1];

	private readonly Func<BasePlayer, bool> filter = InterestedInPlayersOnly;

	[ServerVar(Help = "The maximum amount of nodes processed each frame in the asynchronous pathfinding process. Increasing this value will cause the paths to be processed faster, but can cause some hiccups in frame rate. Default value is 100, a good range for tuning is between 50 and 500.")]
	public static int pathfindingIterationsPerFrame
	{
		get
		{
			return NavMesh.pathfindingIterationsPerFrame;
		}
		set
		{
			NavMesh.pathfindingIterationsPerFrame = value;
		}
	}

	public bool repeat => true;

	internal void OnEnableAgency()
	{
	}

	internal void OnDisableAgency()
	{
	}

	internal void UpdateAgency()
	{
	}

	internal void OnEnableCover()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (coverPointVolumeGrid == null)
		{
			Vector3 size = TerrainMeta.Size;
			coverPointVolumeGrid = new WorldSpaceGrid<CoverPointVolume>(size.x, CoverPointVolumeCellSize, (RoundingMode)0);
		}
	}

	internal void OnDisableCover()
	{
		if (coverPointVolumeGrid != null && coverPointVolumeGrid.Cells != null)
		{
			for (int i = 0; i < coverPointVolumeGrid.Cells.Length; i++)
			{
				Object.Destroy((Object)(object)coverPointVolumeGrid.Cells[i]);
			}
		}
	}

	public static CoverPointVolume CreateNewCoverVolume(Vector3 point, Transform coverPointGroup)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SingletonComponent<AiManager>.Instance != (Object)null && ((Behaviour)SingletonComponent<AiManager>.Instance).enabled && SingletonComponent<AiManager>.Instance.UseCover)
		{
			CoverPointVolume coverPointVolume = SingletonComponent<AiManager>.Instance.GetCoverVolumeContaining(point);
			if ((Object)(object)coverPointVolume == (Object)null)
			{
				Vector2i val = SingletonComponent<AiManager>.Instance.coverPointVolumeGrid.WorldToGridCoords(point);
				coverPointVolume = ((!((Object)(object)SingletonComponent<AiManager>.Instance.cpvPrefab != (Object)null)) ? new GameObject("CoverPointVolume").AddComponent<CoverPointVolume>() : Object.Instantiate<CoverPointVolume>(SingletonComponent<AiManager>.Instance.cpvPrefab));
				((Component)coverPointVolume).transform.localPosition = default(Vector3);
				((Component)coverPointVolume).transform.position = SingletonComponent<AiManager>.Instance.coverPointVolumeGrid.GridToWorldCoords(val) + Vector3.up * point.y;
				((Component)coverPointVolume).transform.localScale = new Vector3(SingletonComponent<AiManager>.Instance.CoverPointVolumeCellSize, SingletonComponent<AiManager>.Instance.CoverPointVolumeCellHeight, SingletonComponent<AiManager>.Instance.CoverPointVolumeCellSize);
				coverPointVolume.CoverLayerMask = SingletonComponent<AiManager>.Instance.DynamicCoverPointVolumeLayerMask;
				coverPointVolume.CoverPointRayLength = SingletonComponent<AiManager>.Instance.CoverPointRayLength;
				SingletonComponent<AiManager>.Instance.coverPointVolumeGrid[val] = coverPointVolume;
				coverPointVolume.GenerateCoverPoints(coverPointGroup);
			}
			return coverPointVolume;
		}
		return null;
	}

	public CoverPointVolume GetCoverVolumeContaining(Vector3 point)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (coverPointVolumeGrid == null)
		{
			return null;
		}
		Vector2i val = coverPointVolumeGrid.WorldToGridCoords(point);
		return coverPointVolumeGrid[val];
	}

	public void Initialize()
	{
		OnEnableAgency();
		if (UseCover)
		{
			OnEnableCover();
		}
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			OnDisableAgency();
			if (UseCover)
			{
				OnDisableCover();
			}
		}
	}

	public float? ExecuteUpdate(float deltaTime, float nextInterval)
	{
		if (nav_disable)
		{
			return nextInterval;
		}
		UpdateAgency();
		return Random.value + 1f;
	}

	private static bool InterestedInPlayersOnly(BaseEntity entity)
	{
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return false;
		}
		if (basePlayer.IsSleeping() || !basePlayer.IsConnected)
		{
			return false;
		}
		return true;
	}
}


using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;

public class Memory
{
	public struct SeenInfo
	{
		public BaseEntity Entity;

		public Vector3 Position;

		public float Timestamp;

		public float Danger;
	}

	public struct ExtendedInfo
	{
		public BaseEntity Entity;

		public Vector3 Direction;

		public float Dot;

		public float DistanceSqr;

		public byte LineOfSight;

		public float LastHurtUsTime;
	}

	public List<BaseEntity> Visible = new List<BaseEntity>();

	public List<SeenInfo> All = new List<SeenInfo>();

	public List<ExtendedInfo> AllExtended = new List<ExtendedInfo>();

	public SeenInfo Update(BaseEntity entity, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, out ExtendedInfo extendedInfo)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return Update(entity, entity.ServerPosition, score, direction, dot, distanceSqr, lineOfSight, updateLastHurtUsTime, lastHurtUsTime, out extendedInfo);
	}

	public SeenInfo Update(BaseEntity entity, Vector3 position, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, out ExtendedInfo extendedInfo)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		extendedInfo = default(ExtendedInfo);
		bool flag = false;
		for (int i = 0; i < AllExtended.Count; i++)
		{
			if ((Object)(object)AllExtended[i].Entity == (Object)(object)entity)
			{
				ExtendedInfo extendedInfo2 = AllExtended[i];
				extendedInfo2.Direction = direction;
				extendedInfo2.Dot = dot;
				extendedInfo2.DistanceSqr = distanceSqr;
				extendedInfo2.LineOfSight = lineOfSight;
				if (updateLastHurtUsTime)
				{
					extendedInfo2.LastHurtUsTime = lastHurtUsTime;
				}
				AllExtended[i] = extendedInfo2;
				extendedInfo = extendedInfo2;
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			if (updateLastHurtUsTime)
			{
				ExtendedInfo extendedInfo3 = default(ExtendedInfo);
				extendedInfo3.Entity = entity;
				extendedInfo3.Direction = direction;
				extendedInfo3.Dot = dot;
				extendedInfo3.DistanceSqr = distanceSqr;
				extendedInfo3.LineOfSight = lineOfSight;
				extendedInfo3.LastHurtUsTime = lastHurtUsTime;
				ExtendedInfo extendedInfo4 = extendedInfo3;
				AllExtended.Add(extendedInfo4);
				extendedInfo = extendedInfo4;
			}
			else
			{
				ExtendedInfo extendedInfo3 = default(ExtendedInfo);
				extendedInfo3.Entity = entity;
				extendedInfo3.Direction = direction;
				extendedInfo3.Dot = dot;
				extendedInfo3.DistanceSqr = distanceSqr;
				extendedInfo3.LineOfSight = lineOfSight;
				ExtendedInfo extendedInfo5 = extendedInfo3;
				AllExtended.Add(extendedInfo5);
				extendedInfo = extendedInfo5;
			}
		}
		return Update(entity, position, score);
	}

	public SeenInfo Update(BaseEntity ent, float danger = 0f)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return Update(ent, ent.ServerPosition, danger);
	}

	public SeenInfo Update(BaseEntity ent, Vector3 position, float danger = 0f)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < All.Count; i++)
		{
			if ((Object)(object)All[i].Entity == (Object)(object)ent)
			{
				SeenInfo seenInfo = All[i];
				seenInfo.Position = position;
				seenInfo.Timestamp = Time.realtimeSinceStartup;
				seenInfo.Danger += danger;
				All[i] = seenInfo;
				return seenInfo;
			}
		}
		SeenInfo seenInfo2 = default(SeenInfo);
		seenInfo2.Entity = ent;
		seenInfo2.Position = position;
		seenInfo2.Timestamp = Time.realtimeSinceStartup;
		seenInfo2.Danger = danger;
		SeenInfo seenInfo3 = seenInfo2;
		All.Add(seenInfo3);
		Visible.Add(ent);
		return seenInfo3;
	}

	public void AddDanger(Vector3 position, float amount)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < All.Count; i++)
		{
			if (Mathf.Approximately(All[i].Position.x, position.x) && Mathf.Approximately(All[i].Position.y, position.y) && Mathf.Approximately(All[i].Position.z, position.z))
			{
				SeenInfo value = All[i];
				value.Danger = amount;
				All[i] = value;
				return;
			}
		}
		All.Add(new SeenInfo
		{
			Position = position,
			Timestamp = Time.realtimeSinceStartup,
			Danger = amount
		});
	}

	public SeenInfo GetInfo(BaseEntity entity)
	{
		foreach (SeenInfo item in All)
		{
			if ((Object)(object)item.Entity == (Object)(object)entity)
			{
				return item;
			}
		}
		return default(SeenInfo);
	}

	public SeenInfo GetInfo(Vector3 position)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		foreach (SeenInfo item in All)
		{
			Vector3 val = item.Position - position;
			if (((Vector3)(ref val)).sqrMagnitude < 1f)
			{
				return item;
			}
		}
		return default(SeenInfo);
	}

	public ExtendedInfo GetExtendedInfo(BaseEntity entity)
	{
		foreach (ExtendedInfo item in AllExtended)
		{
			if ((Object)(object)item.Entity == (Object)(object)entity)
			{
				return item;
			}
		}
		return default(ExtendedInfo);
	}

	internal void Forget(float maxSecondsOld)
	{
		for (int i = 0; i < All.Count; i++)
		{
			float num = Time.realtimeSinceStartup - All[i].Timestamp;
			if (num > maxSecondsOld)
			{
				if ((Object)(object)All[i].Entity != (Object)null)
				{
					Visible.Remove(All[i].Entity);
					for (int j = 0; j < AllExtended.Count; j++)
					{
						if ((Object)(object)AllExtended[j].Entity == (Object)(object)All[i].Entity)
						{
							AllExtended.RemoveAt(j);
							break;
						}
					}
				}
				All.RemoveAt(i);
				i--;
			}
			else
			{
				if (!(num > 0f))
				{
					continue;
				}
				float num2 = num / maxSecondsOld;
				if (All[i].Danger > 0f)
				{
					SeenInfo value = All[i];
					value.Danger -= num2;
					All[i] = value;
				}
				if (!(num >= 1f))
				{
					continue;
				}
				for (int k = 0; k < AllExtended.Count; k++)
				{
					if ((Object)(object)AllExtended[k].Entity == (Object)(object)All[i].Entity)
					{
						ExtendedInfo value2 = AllExtended[k];
						value2.LineOfSight = 0;
						AllExtended[k] = value2;
						break;
					}
				}
			}
		}
		for (int l = 0; l < Visible.Count; l++)
		{
			if ((Object)(object)Visible[l] == (Object)null)
			{
				Visible.RemoveAt(l);
				l--;
			}
		}
		for (int m = 0; m < AllExtended.Count; m++)
		{
			if ((Object)(object)AllExtended[m].Entity == (Object)null)
			{
				AllExtended.RemoveAt(m);
				m--;
			}
		}
	}
}


using UnityEngine;

public struct SeenInfo
{
	public BaseEntity Entity;

	public Vector3 Position;

	public float Timestamp;

	public float Danger;
}


using UnityEngine;

public struct ExtendedInfo
{
	public BaseEntity Entity;

	public Vector3 Direction;

	public float Dot;

	public float DistanceSqr;

	public byte LineOfSight;

	public float LastHurtUsTime;
}


using UnityEngine;

public class NavmeshPrefabInstantiator : MonoBehaviour
{
	public GameObjectRef NavmeshPrefab;

	private void Start()
	{
		if (NavmeshPrefab != null)
		{
			NavmeshPrefab.Instantiate(((Component)this).transform).SetActive(true);
			Object.Destroy((Object)(object)this);
		}
	}
}


using ConVar;
using Rust.Ai;
using UnityEngine;

public class ScientistSpawner : SpawnGroup
{
	[Header("Scientist Spawner")]
	public bool Mobile = true;

	public bool NeverMove;

	public bool SpawnHostile;

	public bool OnlyAggroMarkedTargets = true;

	public bool IsPeacekeeper = true;

	public bool IsBandit;

	public bool IsMilitaryTunnelLab;

	public WaypointSet Waypoints;

	public Transform[] LookAtInterestPointsStationary;

	public Vector2 RadioEffectRepeatRange = new Vector2(10f, 15f);

	public Model Model;

	[SerializeField]
	private AiLocationManager _mgr;

	private float _nextForcedRespawn = float.PositiveInfinity;

	private bool _lastSpawnCallHadAliveMembers;

	private bool _lastSpawnCallHadMaxAliveMembers;

	protected override void Spawn(int numToSpawn)
	{
		if (!AI.npc_enable)
		{
			return;
		}
		if (base.currentPopulation == maxPopulation)
		{
			_lastSpawnCallHadMaxAliveMembers = true;
			_lastSpawnCallHadAliveMembers = true;
			return;
		}
		if (_lastSpawnCallHadMaxAliveMembers)
		{
			_nextForcedRespawn = Time.time + 2200f;
		}
		if (Time.time < _nextForcedRespawn)
		{
			if (base.currentPopulation == 0 && _lastSpawnCallHadAliveMembers)
			{
				_lastSpawnCallHadMaxAliveMembers = false;
				_lastSpawnCallHadAliveMembers = false;
				return;
			}
			if (base.currentPopulation > 0)
			{
				_lastSpawnCallHadMaxAliveMembers = false;
				_lastSpawnCallHadAliveMembers = base.currentPopulation > 0;
				return;
			}
		}
		_lastSpawnCallHadMaxAliveMembers = false;
		_lastSpawnCallHadAliveMembers = base.currentPopulation > 0;
		base.Spawn(numToSpawn);
	}

	protected override void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
	{
	}

	protected override void OnDrawGizmos()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		base.OnDrawGizmos();
		if (LookAtInterestPointsStationary == null || LookAtInterestPointsStationary.Length == 0)
		{
			return;
		}
		Gizmos.color = Color.magenta - new Color(0f, 0f, 0f, 0.5f);
		Transform[] lookAtInterestPointsStationary = LookAtInterestPointsStationary;
		foreach (Transform val in lookAtInterestPointsStationary)
		{
			if ((Object)(object)val != (Object)null)
			{
				Gizmos.DrawSphere(val.position, 0.1f);
				Gizmos.DrawLine(((Component)this).transform.position, val.position);
			}
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class AiLocationManager : FacepunchBehaviour, IServerComponent
{
	public static List<AiLocationManager> Managers = new List<AiLocationManager>();

	[SerializeField]
	public AiLocationSpawner MainSpawner;

	[SerializeField]
	public AiLocationSpawner.SquadSpawnerLocation LocationWhenMainSpawnerIsNull = AiLocationSpawner.SquadSpawnerLocation.None;

	public Transform CoverPointGroup;

	public Transform PatrolPointGroup;

	public CoverPointVolume DynamicCoverPointVolume;

	public bool SnapCoverPointsToGround;

	private List<PathInterestNode> patrolPoints;

	public AiLocationSpawner.SquadSpawnerLocation LocationType
	{
		get
		{
			if ((Object)(object)MainSpawner != (Object)null)
			{
				return MainSpawner.Location;
			}
			return LocationWhenMainSpawnerIsNull;
		}
	}

	private void Awake()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Managers.Add(this);
		if (!SnapCoverPointsToGround)
		{
			return;
		}
		AICoverPoint[] componentsInChildren = ((Component)CoverPointGroup).GetComponentsInChildren<AICoverPoint>();
		NavMeshHit val = default(NavMeshHit);
		foreach (AICoverPoint aICoverPoint in componentsInChildren)
		{
			if (NavMesh.SamplePosition(((Component)aICoverPoint).transform.position, ref val, 4f, -1))
			{
				((Component)aICoverPoint).transform.position = ((NavMeshHit)(ref val)).position;
			}
		}
	}

	private void OnDestroy()
	{
		Managers.Remove(this);
	}

	public PathInterestNode GetFirstPatrolPointInRange(Vector3 from, float minRange = 10f, float maxRange = 100f)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)PatrolPointGroup == (Object)null)
		{
			return null;
		}
		if (patrolPoints == null)
		{
			patrolPoints = new List<PathInterestNode>(((Component)PatrolPointGroup).GetComponentsInChildren<PathInterestNode>());
		}
		if (patrolPoints.Count == 0)
		{
			return null;
		}
		float num = minRange * minRange;
		float num2 = maxRange * maxRange;
		foreach (PathInterestNode patrolPoint in patrolPoints)
		{
			Vector3 val = ((Component)patrolPoint).transform.position - from;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			if (sqrMagnitude >= num && sqrMagnitude <= num2)
			{
				return patrolPoint;
			}
		}
		return null;
	}

	public PathInterestNode GetRandomPatrolPointInRange(Vector3 from, float minRange = 10f, float maxRange = 100f, PathInterestNode currentPatrolPoint = null)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)PatrolPointGroup == (Object)null)
		{
			return null;
		}
		if (patrolPoints == null)
		{
			patrolPoints = new List<PathInterestNode>(((Component)PatrolPointGroup).GetComponentsInChildren<PathInterestNode>());
		}
		if (patrolPoints.Count == 0)
		{
			return null;
		}
		float num = minRange * minRange;
		float num2 = maxRange * maxRange;
		for (int i = 0; i < 20; i++)
		{
			PathInterestNode pathInterestNode = patrolPoints[Random.Range(0, patrolPoints.Count)];
			if (Time.time < pathInterestNode.NextVisitTime)
			{
				if ((Object)(object)pathInterestNode == (Object)(object)currentPatrolPoint)
				{
					return null;
				}
				continue;
			}
			Vector3 val = ((Component)pathInterestNode).transform.position - from;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			if (sqrMagnitude >= num && sqrMagnitude <= num2)
			{
				pathInterestNode.NextVisitTime = Time.time + AI.npc_patrol_point_cooldown;
				return pathInterestNode;
			}
		}
		return null;
	}
}


using ConVar;
using Rust.Ai;
using UnityEngine;

public class AiLocationSpawner : SpawnGroup
{
	public enum SquadSpawnerLocation
	{
		MilitaryTunnels,
		JunkpileA,
		JunkpileG,
		CH47,
		None,
		Compound,
		BanditTown,
		CargoShip
	}

	public SquadSpawnerLocation Location;

	public AiLocationManager Manager;

	public JunkPile Junkpile;

	public bool IsMainSpawner = true;

	public float chance = 1f;

	private int defaultMaxPopulation;

	private int defaultNumToSpawnPerTickMax;

	private int defaultNumToSpawnPerTickMin;

	public override void SpawnInitial()
	{
		if (IsMainSpawner)
		{
			if (Location == SquadSpawnerLocation.MilitaryTunnels)
			{
				maxPopulation = AI.npc_max_population_military_tunnels;
				numToSpawnPerTickMax = AI.npc_spawn_per_tick_max_military_tunnels;
				numToSpawnPerTickMin = AI.npc_spawn_per_tick_min_military_tunnels;
				respawnDelayMax = AI.npc_respawn_delay_max_military_tunnels;
				respawnDelayMin = AI.npc_respawn_delay_min_military_tunnels;
			}
			else
			{
				defaultMaxPopulation = maxPopulation;
				defaultNumToSpawnPerTickMax = numToSpawnPerTickMax;
				defaultNumToSpawnPerTickMin = numToSpawnPerTickMin;
			}
		}
		else
		{
			defaultMaxPopulation = maxPopulation;
			defaultNumToSpawnPerTickMax = numToSpawnPerTickMax;
			defaultNumToSpawnPerTickMin = numToSpawnPerTickMin;
		}
		base.SpawnInitial();
	}

	protected override void Spawn(int numToSpawn)
	{
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.npc_enable)
		{
			maxPopulation = 0;
			numToSpawnPerTickMax = 0;
			numToSpawnPerTickMin = 0;
			return;
		}
		if (numToSpawn == 0)
		{
			if (IsMainSpawner)
			{
				if (Location == SquadSpawnerLocation.MilitaryTunnels)
				{
					maxPopulation = AI.npc_max_population_military_tunnels;
					numToSpawnPerTickMax = AI.npc_spawn_per_tick_max_military_tunnels;
					numToSpawnPerTickMin = AI.npc_spawn_per_tick_min_military_tunnels;
					numToSpawn = Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1);
				}
				else
				{
					maxPopulation = defaultMaxPopulation;
					numToSpawnPerTickMax = defaultNumToSpawnPerTickMax;
					numToSpawnPerTickMin = defaultNumToSpawnPerTickMin;
					numToSpawn = Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1);
				}
			}
			else
			{
				maxPopulation = defaultMaxPopulation;
				numToSpawnPerTickMax = defaultNumToSpawnPerTickMax;
				numToSpawnPerTickMin = defaultNumToSpawnPerTickMin;
				numToSpawn = Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1);
			}
		}
		float npc_junkpilespawn_chance = chance;
		switch (Location)
		{
		case SquadSpawnerLocation.JunkpileA:
			npc_junkpilespawn_chance = AI.npc_junkpilespawn_chance;
			break;
		case SquadSpawnerLocation.JunkpileG:
			npc_junkpilespawn_chance = AI.npc_junkpilespawn_chance;
			break;
		}
		if (numToSpawn == 0 || Random.value > npc_junkpilespawn_chance)
		{
			return;
		}
		numToSpawn = Mathf.Min(numToSpawn, maxPopulation - base.currentPopulation);
		for (int i = 0; i < numToSpawn; i++)
		{
			GameObjectRef prefab = GetPrefab();
			Vector3 pos;
			Quaternion rot;
			BaseSpawnPoint spawnPoint = GetSpawnPoint(prefab, out pos, out rot);
			if (Object.op_Implicit((Object)(object)spawnPoint))
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(prefab.resourcePath, pos, rot);
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					baseEntity.Spawn();
					SpawnPointInstance spawnPointInstance = ((Component)baseEntity).gameObject.AddComponent<SpawnPointInstance>();
					spawnPointInstance.parentSpawnPointUser = this;
					spawnPointInstance.parentSpawnPoint = spawnPoint;
					spawnPointInstance.Entity = baseEntity;
					spawnPointInstance.Notify();
				}
			}
		}
	}

	protected override BaseSpawnPoint GetSpawnPoint(GameObjectRef prefabRef, out Vector3 pos, out Quaternion rot)
	{
		return base.GetSpawnPoint(prefabRef, out pos, out rot);
	}
}


public enum SquadSpawnerLocation
{
	MilitaryTunnels,
	JunkpileA,
	JunkpileG,
	CH47,
	None,
	Compound,
	BanditTown,
	CargoShip
}


using System;
using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;

public class WaypointSet : MonoBehaviour, IServerComponent
{
	public enum NavModes
	{
		Loop,
		PingPong
	}

	[Serializable]
	public struct Waypoint
	{
		public Transform Transform;

		public float WaitTime;

		public Transform[] LookatPoints;

		[NonSerialized]
		public bool IsOccupied;
	}

	[SerializeField]
	private List<Waypoint> _points = new List<Waypoint>();

	[SerializeField]
	private NavModes navMode;

	public List<Waypoint> Points
	{
		get
		{
			return _points;
		}
		set
		{
			_points = value;
		}
	}

	public NavModes NavMode => navMode;

	private void OnDrawGizmos()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Points.Count; i++)
		{
			Transform transform = Points[i].Transform;
			if ((Object)(object)transform != (Object)null)
			{
				if (Points[i].IsOccupied)
				{
					Gizmos.color = Color.red;
				}
				else
				{
					Gizmos.color = Color.cyan;
				}
				Gizmos.DrawSphere(transform.position, 0.25f);
				Gizmos.color = Color.cyan;
				if (i + 1 < Points.Count)
				{
					Gizmos.DrawLine(transform.position, Points[i + 1].Transform.position);
				}
				else if (NavMode == NavModes.Loop)
				{
					Gizmos.DrawLine(transform.position, Points[0].Transform.position);
				}
				Gizmos.color = Color.magenta - new Color(0f, 0f, 0f, 0.5f);
				Transform[] lookatPoints = Points[i].LookatPoints;
				foreach (Transform val in lookatPoints)
				{
					Gizmos.DrawSphere(val.position, 0.1f);
					Gizmos.DrawLine(transform.position, val.position);
				}
			}
		}
	}
}


public enum NavModes
{
	Loop,
	PingPong
}


using System;
using UnityEngine;

[Serializable]
public struct Waypoint
{
	public Transform Transform;

	public float WaitTime;

	public Transform[] LookatPoints;

	[NonSerialized]
	public bool IsOccupied;
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using Rust.Ai.HTN.ScientistJunkpile;
using UnityEngine;

public class ScientistJunkpileSpawner : MonoBehaviour, IServerComponent, ISpawnGroup
{
	public enum JunkpileType
	{
		A,
		B,
		C,
		D,
		E,
		F,
		G
	}

	public GameObjectRef ScientistPrefab;

	[NonSerialized]
	public List<BaseCombatEntity> Spawned = new List<BaseCombatEntity>();

	[NonSerialized]
	public BaseSpawnPoint[] SpawnPoints;

	public int MaxPopulation = 1;

	public bool InitialSpawn;

	public float MinRespawnTimeMinutes = 120f;

	public float MaxRespawnTimeMinutes = 120f;

	public float MovementRadius = -1f;

	public bool ReducedLongRangeAccuracy;

	public JunkpileType SpawnType;

	[Range(0f, 1f)]
	public float SpawnBaseChance = 1f;

	private float nextRespawnTime;

	private bool pendingRespawn;

	public int currentPopulation => Spawned.Count;

	private void Awake()
	{
		SpawnPoints = ((Component)this).GetComponentsInChildren<BaseSpawnPoint>();
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Add((ISpawnGroup)this);
		}
	}

	protected void OnDestroy()
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Remove((ISpawnGroup)this);
		}
		else
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": SpawnHandler instance not found."));
		}
	}

	public void Fill()
	{
		DoRespawn();
	}

	public void Clear()
	{
		if (Spawned == null)
		{
			return;
		}
		foreach (BaseCombatEntity item in Spawned)
		{
			if (!((Object)(object)item == (Object)null) && !((Object)(object)((Component)item).gameObject == (Object)null) && !((Object)(object)((Component)item).transform == (Object)null))
			{
				BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					baseEntity.Kill();
				}
			}
		}
		Spawned.Clear();
	}

	public void SpawnInitial()
	{
		nextRespawnTime = Time.time + Random.Range(3f, 4f);
		pendingRespawn = true;
	}

	public void SpawnRepeating()
	{
		CheckIfRespawnNeeded();
	}

	public void CheckIfRespawnNeeded()
	{
		if (!pendingRespawn)
		{
			if (Spawned == null || Spawned.Count == 0 || IsAllSpawnedDead())
			{
				ScheduleRespawn();
			}
		}
		else if ((Spawned == null || Spawned.Count == 0 || IsAllSpawnedDead()) && Time.time >= nextRespawnTime)
		{
			DoRespawn();
		}
	}

	private bool IsAllSpawnedDead()
	{
		int num = 0;
		while (num < Spawned.Count)
		{
			BaseCombatEntity baseCombatEntity = Spawned[num];
			if ((Object)(object)baseCombatEntity == (Object)null || (Object)(object)((Component)baseCombatEntity).transform == (Object)null || baseCombatEntity.IsDestroyed || baseCombatEntity.IsDead())
			{
				Spawned.RemoveAt(num);
				num--;
				num++;
				continue;
			}
			return false;
		}
		return true;
	}

	public void ScheduleRespawn()
	{
		nextRespawnTime = Time.time + Random.Range(MinRespawnTimeMinutes, MaxRespawnTimeMinutes) * 60f;
		pendingRespawn = true;
	}

	public void DoRespawn()
	{
		if (!Application.isLoading && !Application.isLoadingSave)
		{
			SpawnScientist();
		}
		pendingRespawn = false;
	}

	public void SpawnScientist()
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.npc_enable || Spawned == null || Spawned.Count >= MaxPopulation)
		{
			return;
		}
		float num = SpawnBaseChance;
		switch (SpawnType)
		{
		case JunkpileType.A:
			num = AI.npc_junkpilespawn_chance;
			break;
		case JunkpileType.G:
			num = AI.npc_junkpilespawn_chance;
			break;
		}
		if (Random.value > num)
		{
			return;
		}
		int num2 = MaxPopulation - Spawned.Count;
		for (int i = 0; i < num2; i++)
		{
			if (!((Object)(object)GetSpawnPoint(out var pos, out var rot) == (Object)null))
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(ScientistPrefab.resourcePath, pos, rot, startActive: false);
				if (!((Object)(object)baseEntity != (Object)null))
				{
					break;
				}
				baseEntity.enableSaving = false;
				((Component)baseEntity).gameObject.AwakeFromInstantiate();
				baseEntity.Spawn();
				Spawned.Add((BaseCombatEntity)baseEntity);
			}
		}
	}

	private BaseSpawnPoint GetSpawnPoint(out Vector3 pos, out Quaternion rot)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		BaseSpawnPoint baseSpawnPoint = null;
		pos = Vector3.zero;
		rot = Quaternion.identity;
		int num = Random.Range(0, SpawnPoints.Length);
		for (int i = 0; i < SpawnPoints.Length; i++)
		{
			baseSpawnPoint = SpawnPoints[(num + i) % SpawnPoints.Length];
			if (Object.op_Implicit((Object)(object)baseSpawnPoint) && ((Component)baseSpawnPoint).gameObject.activeSelf)
			{
				break;
			}
		}
		if (Object.op_Implicit((Object)(object)baseSpawnPoint))
		{
			baseSpawnPoint.GetLocation(out pos, out rot);
		}
		return baseSpawnPoint;
	}
}


public enum JunkpileType
{
	A,
	B,
	C,
	D,
	E,
	F,
	G
}


using System;
using FIMSpace.FLook;
using FIMSpace.FSpine;
using FIMSpace.FTail;
using Network;
using Rust.Ai.Gen2;
using UnityEngine;

public class NPCAnimController : EntityComponent<BaseEntity>, IClientComponent
{
	public enum AnimatorType
	{
		NoStrafe,
		Strafe
	}

	[SerializeField]
	private string animationsPrefix = "wolf_";

	[SerializeField]
	private string[] animationBlacklist = new string[4] { "prowl", "walk", "trot", "run" };

	[ClientVar(ClientAdmin = true)]
	public static float lookInterpSpeed = 3f;

	[ClientVar(ClientAdmin = true)]
	public static float spineInterpSpeed = 3f;

	[SerializeField]
	private AnimatorType animatorType;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private FSpineAnimator spineAnimator;

	[SerializeField]
	private FLookAnimator lookAnimator;

	[SerializeField]
	private TailAnimator2 tailAnimator;

	[SerializeField]
	private float maxPitchToConformToSlope = 30f;

	[SerializeField]
	private bool onlyConformPitchToSlope = true;

	[SerializeField]
	private float posInterpSpeed = 10f;

	[SerializeField]
	private float rotInterpSpeed = 2f;

	[SerializeField]
	public bool enableLookAtDuringLocomotion = true;

	[SerializeField]
	public bool enableLookAtDuringProwl = true;

	[SerializeField]
	private AnimationClip[] animationsWithLookAt;

	[SerializeField]
	private AnimationClip[] animationsWithSpineDeform;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("NPCAnimController.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}
}


public enum AnimatorType
{
	NoStrafe,
	Strafe
}


using System;
using Network;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class TigerFSM : FSMComponent
{
	public State_PlayRandomAnimation randomIdle = new State_PlayRandomAnimation();

	public State_Roam roam = new State_Roam();

	public State_CircleDynamic approach = new State_CircleDynamic();

	public State_FastSneak fastSneak = new State_FastSneak();

	public State_Roar roar = new State_Roar();

	public State_Growl growlFire = new State_Growl();

	public State_MoveToTarget charge = new State_MoveToTarget();

	public State_Observe observe = new State_Observe();

	public State_DeadlyAttack attack = new State_DeadlyAttack();

	public State_Circle comboCircle = new State_Circle();

	public State_HurtWithAdditive hurt = new State_HurtWithAdditive();

	public State_FleeToHide flee = new State_FleeToHide();

	public State_Flee permaFlee = new State_Flee();

	public State_Dead dead = new State_Dead();

	public State_ApproachFood approachFood = new State_ApproachFood();

	public State_EatFood eatFood = new State_EatFood();

	public State_PlayAnimLoop sleep = new State_PlayAnimLoop();

	public State_AttackUnreachableWarped attackUnreachable = new State_AttackUnreachableWarped();

	public State_DragCorpse dragCorpse = new State_DragCorpse();

	private Trans_Triggerable_HitInfo HurtTrans;

	private Trans_Triggerable_HitInfo StaggerTrans;

	private Trans_Triggerable_HitInfo DeathTrans;

	[ServerVar(Help = "The range at which the tiger will charge instead of fleeing if aimed at")]
	public static float chargeRange = 20f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TigerFSM.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Expected O, but got Unknown
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Expected O, but got Unknown
		if (base.baseEntity.isServer)
		{
			State_Nothing state_Nothing = new State_Nothing
			{
				Name = "WaitForNavMesh"
			};
			new State_MoveToTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Walk,
				decelerationOverride = 6f,
				Name = "Step forward"
			};
			State_MoveToLastReachablePointNearTarget state_MoveToLastReachablePointNearTarget = new State_MoveToLastReachablePointNearTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Jog,
				succeedWhenDestinationIsReached = true,
				Name = "Go to last destination slow"
			};
			State_MoveToLastReachablePointNearTarget state_MoveToLastReachablePointNearTarget2 = new State_MoveToLastReachablePointNearTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Sprint,
				succeedWhenDestinationIsReached = true,
				Name = "Go to last destination"
			};
			DeathTrans = new Trans_Triggerable_HitInfo();
			HurtTrans = new Trans_Triggerable_HitInfo();
			StaggerTrans = new Trans_Triggerable_HitInfo();
			Trans_Triggerable FireMeleeTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<SenseComponent>().onFireMelee.AddListener((UnityAction)delegate
			{
				FireMeleeTrans.Trigger();
			});
			Trans_Triggerable EncounterEndTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<NPCEncounterTimer>().onShouldGiveUp.AddListener((UnityAction)delegate
			{
				EncounterEndTrans.Trigger();
			});
			State_Nothing obj = new State_Nothing
			{
				Name = "Root"
			};
			State_Nothing state_Nothing2 = new State_Nothing
			{
				Name = "Alive"
			};
			State_Nothing state_Nothing3 = new State_Nothing
			{
				Name = "OnNavmesh"
			};
			State_Nothing state_Nothing4 = new State_Nothing
			{
				Name = "Food"
			};
			State_Nothing state_Nothing5 = new State_Nothing
			{
				Name = "Roaming"
			};
			State_Nothing state_Nothing6 = new State_Nothing
			{
				Name = "Has target"
			};
			State_Nothing state_Nothing7 = new State_Nothing
			{
				Name = "Ready to strike"
			};
			State_Nothing state_Nothing8 = new State_Nothing
			{
				Name = "Not hurt"
			};
			State_Nothing state_Nothing9 = new State_Nothing
			{
				Name = "Random post idle wait"
			};
			Trans_And transition = new Trans_And
			{
				~new Trans_BlackboardCounterGte
				{
					Key = "AlreadyGrowled",
					MinValue = 2
				},
				new Trans_Cooldown
				{
					cooldown = 6f
				},
				new Trans_TargetIsNearFire
				{
					onlySeeFireWhenClose = true
				}
			};
			Trans_Or trans_Or = HurtTrans | new Trans_IsWatchedByTarget
			{
				requireAiming = true,
				minTime = 3f
			};
			Trans_Or trans_Or2 = HurtTrans | new Trans_IsWatchedByTarget
			{
				requireAiming = true,
				minTime = 0.5f
			};
			_ = obj + (state_Nothing2.AddTickTransition(dead, DeathTrans) + state_Nothing.AddTickTransition(roam, new Trans_IsNavmeshReady()) + (state_Nothing3.AddTickTransition(state_Nothing, ~new Trans_IsNavmeshReady()) + (state_Nothing8.AddTickTransition(hurt, StaggerTrans) + (state_Nothing5.AddTickTransition(approach, new Trans_HasTarget()).AddTickTransition(approachFood, new Trans_SeesFood()) + roam.AddEndTransition(sleep, new Trans_RandomChance
			{
				Chance = 0.25f
			}).AddFailureTransition(dead).AddEndTransition(randomIdle) + sleep.AddEndTransition(roam) + randomIdle.AddEndTransition(state_Nothing9) + state_Nothing9.AddTickTransition(roam, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 0.0,
				MaxDuration = 3.0
			})) + (state_Nothing6.AddTickTransition(roam, new Trans_HasTarget
			{
				Inverted = true
			}).AddTickTransition(permaFlee, EncounterEndTrans).AddTickTransition(permaFlee, new Trans_TargetIsInSafeZone())
				.AddTickTransition(permaFlee, new Trans_IsInWaterSlow() | new Trans_IsTargetInWater()) + (state_Nothing7.AddTickTransition(growlFire, transition).AddTickTransition(approachFood, new Trans_SeesFood() & ~new Trans_HasBlackboardBool
			{
				Key = "TriedToApproachUnreachableFood"
			}).AddTickTransition(charge, new Trans_TargetInRange
			{
				Range = 10f
			})
				.AddTickTransition(charge, new Trans_TargetInRange
				{
					Range = chargeRange
				} & trans_Or)
				.AddTickTransition(flee, ~new Trans_TargetInRange
				{
					Range = chargeRange
				} & trans_Or2) + approach.AddTickTransition(observe, new Trans_And
			{
				~new Trans_HasBlackboardBool
				{
					Key = "AlreadyGrowled"
				},
				new Trans_IsWatchedByTarget
				{
					requireAiming = false
				},
				~new Trans_TargetInRange
				{
					Range = 15f
				}
			}).AddTickTransition(fastSneak, ~new Trans_IsInTargetViewCone
			{
				angle = 70f
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget) + fastSneak.AddTickTransition(approach, new Trans_IsInTargetViewCone
			{
				angle = 60f
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget) + observe.AddTickTransition(approach, new Trans_IsWatchedByTarget
			{
				wantsWatched = false,
				requireAiming = false
			}).AddTickTransition(charge, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 8.0,
				MaxDuration = 12.0
			} & new Trans_TargetInRange
			{
				Range = chargeRange
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget)) + charge.AddTickTransition(attack, new Trans_TargetInRange
			{
				Range = attack.range
			}).AddTickTransition(approach, new Trans_ElapsedTime
			{
				Duration = 5.0
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget2) + attack.AddEndTransition(comboCircle, new Trans_IsTargetDown()).AddEndTransition(flee) + comboCircle.AddTickTransition(charge, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 0.75,
				MaxDuration = 1.5
			}).AddFailureTransition(state_MoveToLastReachablePointNearTarget2).AddEndTransition(charge) + growlFire.AddTickTransition(attack, new Trans_TargetInRange
			{
				Range = 2f
			}).AddEndTransition(approach) + state_MoveToLastReachablePointNearTarget.AddTickBranchingTrans(permaFlee, trans_Or2, state_MoveToLastReachablePointNearTarget2, new Trans_TargetInRange
			{
				Range = chargeRange
			}).AddTickTransition(permaFlee, FireMeleeTrans).AddTickTransition(approach, new Trans_CanReachTarget_Slow())
				.AddFailureTransition(permaFlee)
				.AddEndTransition(attackUnreachable) + state_MoveToLastReachablePointNearTarget2.AddTickTransition(permaFlee, FireMeleeTrans).AddTickTransition(charge, new Trans_CanReachTarget_Slow()).AddFailureTransition(permaFlee)
				.AddEndTransition(attackUnreachable) + flee.AddFailureTransition(dead).AddEndTransition(approach)) + (state_Nothing4.AddTickTransition(growlFire, transition).AddTickTransition(flee, trans_Or2) + approachFood.AddTickTransition(roam, ~new Trans_SeesFood()).AddTickTransition(charge, new Trans_TargetInRange
			{
				Range = 10f
			}).AddFailureTransition(roam)
				.AddEndTransition(eatFood) + eatFood.AddTickTransition(roam, ~new Trans_SeesFood()).AddTickTransition(dragCorpse, new Trans_TargetInRange
			{
				Range = 20f
			}).AddFailureTransition(roam)
				.AddEndTransition(roam) + dragCorpse.AddTickTransition(attack, new Trans_TargetInRange
			{
				Range = 3f
			}).AddTickTransition(permaFlee, new Trans_ElapsedTime
			{
				Duration = 1.0
			} & new Trans_TargetInRange
			{
				Range = 12f
			}).AddTickTransition(eatFood, ~new Trans_TargetInRange
			{
				Range = 30f
			})
				.AddFailureTransition(permaFlee)
				.AddEndTransition(permaFlee)) + permaFlee.AddFailureTransition(dead).AddEndTransition(roam)) + hurt.AddEndTransition(flee)) + attackUnreachable.AddFailureTransition(permaFlee).AddEndTransition(permaFlee, new Trans_HasBlackboardBool
			{
				Key = "HitDuringCharge"
			}).AddEndTransition(flee)) + dead;
			SetState(state_Nothing);
			Run();
		}
	}

	public override void Hurt(HitInfo hitInfo)
	{
		if (!((Component)this).GetComponent<SenseComponent>().CanTarget(hitInfo.Initiator))
		{
			return;
		}
		((Component)this).GetComponent<RootMotionPlayer>().PlayServerAdditive(hurt.WeakHitAdditive);
		if (base.CurrentState == roar || base.CurrentState == charge || base.CurrentState == attack || base.CurrentState == attackUnreachable)
		{
			((Component)this).GetComponent<BlackboardComponent>().Add("HitDuringCharge");
		}
		HurtTrans.Trigger(hitInfo);
		if (hurt.ShouldStagger(base.baseEntity, hitInfo))
		{
			StaggerTrans.Trigger(hitInfo);
			if (base.CurrentState != hurt && base.CurrentState != dead)
			{
				ForceTickOnTheNextUpdate();
			}
		}
	}

	public override bool OnDied(HitInfo hitInfo)
	{
		DeathTrans.Trigger(hitInfo);
		return false;
	}
}


using System;
using Network;
using Rust.Ai.Gen2;
using UnityEngine;

public class TigerSneakTelegraphGrowl : EntityComponent<BaseEntity>
{
	[SerializeField]
	private SoundDefinition growlSound;

	[ServerVar(Help = "Minimum angle for the tiger to growl when stalking a player")]
	public static float minAngle = 60f;

	[ServerVar(Help = "Time between growls when stalking a player")]
	public static float minTimeBetweenGrowls = 5f;

	private static readonly float[] growlDistances = new float[3] { 50f, 30f, 20f };

	private SenseComponent _senses;

	private double? lastGrowlTime;

	private BasePlayer targetPlayer;

	private int numGrowlsForCurrentPlayer;

	private SenseComponent Senses => _senses ?? (_senses = ((Component)this).GetComponent<SenseComponent>());

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TigerSneakTelegraphGrowl.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		if (base.baseEntity.isServer)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)Tick, 0f, 0.5f);
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.baseEntity.isServer)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)Tick);
			UpdateTarget(null);
		}
	}

	private void Tick()
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		Senses.FindTarget(out var target);
		UpdateTarget(target);
		if (!((Object)(object)targetPlayer == (Object)null) && (!lastGrowlTime.HasValue || !((double)Time.time - lastGrowlTime.Value < (double)minTimeBetweenGrowls)) && Senses.GetVisibilityStatus(target, out var status) && numGrowlsForCurrentPlayer < growlDistances.Length)
		{
			float num = growlDistances[numGrowlsForCurrentPlayer];
			if (!(Vector3.Distance(((Component)target).transform.position, ((Component)this).transform.position) > num) && !(status.timeNotWatched <= 0f) && !Trans_IsInTargetViewCone.IsInTargetViewCone(Senses, minAngle))
			{
				base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayTigerSneakTelegraphGrowl"));
				lastGrowlTime = Time.timeAsDouble;
				numGrowlsForCurrentPlayer++;
			}
		}
	}

	private void UpdateTarget(BaseEntity newTarget)
	{
		BasePlayer basePlayer = targetPlayer;
		targetPlayer = newTarget as BasePlayer;
		if ((Object)(object)basePlayer != (Object)(object)targetPlayer)
		{
			if (basePlayer.IsValid())
			{
				basePlayer.ClientRPC(RpcTarget.Player("CL_AddPredatorHuntingPlayer", basePlayer), arg1: false);
			}
			if (targetPlayer.IsValid())
			{
				targetPlayer.ClientRPC(RpcTarget.Player("CL_AddPredatorHuntingPlayer", targetPlayer), arg1: true);
			}
			lastGrowlTime = null;
			numGrowlsForCurrentPlayer = 0;
		}
	}
}


using Rust.Ai.Gen2;

public class Crocodile : BaseNPC2
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 1f;

	public override string Categorize()
	{
		return "Crocodile";
	}
}


using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class CrocodileFSM : FSMComponent
{
	public State_PlayRandomAnimation randomIdle = new State_PlayRandomAnimation();

	public State_Roam roam = new State_Roam();

	public State_CircleDynamic approach = new State_CircleDynamic();

	public State_CrocCharge charge = new State_CrocCharge();

	public State_CrocIntimidate intimidate = new State_CrocIntimidate();

	public State_CrocTurn intimidateTurn = new State_CrocTurn();

	public State_AttackWithTracking staticAttack = new State_AttackWithTracking();

	public State_AttackWithTracking bellyFlop = new State_AttackWithTracking();

	public State_AttackWithTracking intimidateSnap = new State_AttackWithTracking();

	public State_AttackWithTracking swimAttack = new State_AttackWithTracking();

	public State_GoBackToWater flee = new State_GoBackToWater();

	public State_HurtWithAdditive hurt = new State_HurtWithAdditive();

	public State_Dead dead = new State_Dead();

	public State_ApproachFood approachFood = new State_ApproachFood();

	public State_BringFoodBackToWater bringFoodBackToWater = new State_BringFoodBackToWater();

	public State_TryAmbushUnderwater diveRoam = new State_TryAmbushUnderwater();

	private Trans_Triggerable_HitInfo HurtTrans;

	private Trans_Triggerable_HitInfo DeathTrans;

	public override void InitShared()
	{
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Expected O, but got Unknown
		if (base.baseEntity.isServer)
		{
			State_Nothing state_Nothing = new State_Nothing
			{
				Name = "WaitForNavMesh"
			};
			State_MoveToBreakFoundation state_MoveToBreakFoundation = new State_MoveToBreakFoundation
			{
				Name = "MoveToFoundation",
				speed = LimitedTurnNavAgent.Speeds.Run,
				accelerationOverride = charge.accelerationOverride,
				decelerationOverride = charge.decelerationOverride,
				stopAtDestination = true,
				succeedWhenDestinationIsReached = true
			};
			State_CrocBreakFoundation state_CrocBreakFoundation = new State_CrocBreakFoundation
			{
				Name = "BreakFoundation",
				Animation = bellyFlop.Animation,
				DamageType = bellyFlop.DamageType,
				damageDelay = bellyFlop.damageDelay,
				damage = bellyFlop.damage,
				radius = 3f,
				trackingDuration = bellyFlop.trackingDuration,
				trackingSpeed = 360f,
				forceScale = bellyFlop.forceScale,
				doesStrafeDodge = false
			};
			DeathTrans = new Trans_Triggerable_HitInfo();
			HurtTrans = new Trans_Triggerable_HitInfo();
			Trans_Triggerable EncounterEndTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<NPCEncounterTimer>().onShouldGiveUp.AddListener((UnityAction)delegate
			{
				EncounterEndTrans.Trigger();
			});
			Trans_IsSwimming trans_IsSwimming = new Trans_IsSwimming();
			FSMTransitionBase fSMTransitionBase = ~new Trans_IsSwimming();
			FSMTransitionBase dstState2Trans = ~(new Trans_TargetInRange
			{
				Range = 30f
			} | trans_IsSwimming | new Trans_IsTargetInWater());
			Trans_CrocHasStraightPathToTarget trans_CrocHasStraightPathToTarget = new Trans_CrocHasStraightPathToTarget();
			State_Nothing obj = new State_Nothing
			{
				Name = "Root"
			};
			State_Nothing state_Nothing2 = new State_Nothing
			{
				Name = "Alive"
			};
			State_Nothing state_Nothing3 = new State_Nothing
			{
				Name = "Reachable"
			};
			State_Nothing state_Nothing4 = new State_Nothing
			{
				Name = "OnNavmesh"
			};
			new State_Nothing().Name = "Food";
			State_Nothing state_Nothing5 = new State_Nothing
			{
				Name = "Roaming"
			};
			State_Nothing state_Nothing6 = new State_Nothing
			{
				Name = "Has target"
			};
			State_Nothing state_Nothing7 = new State_Nothing
			{
				Name = "Random post idle wait"
			};
			_ = obj + (state_Nothing2.AddTickTransition(dead, DeathTrans) + state_Nothing.AddTickTransition(roam, new Trans_IsNavmeshReady()) + state_Nothing4.AddTickTransition(state_Nothing, ~new Trans_IsNavmeshReady()) + (state_Nothing5.AddTickBranchingTrans(charge, new Trans_HasTarget(), flee, dstState2Trans).AddTickTransition(approachFood, new Trans_SeesFood()) + roam.AddFailureTransition(dead).AddEndTransition(randomIdle, fSMTransitionBase).AddEndTransition(state_Nothing7) + randomIdle.AddEndTransition(state_Nothing7) + state_Nothing7.AddTickTransition(roam, new Trans_ElapsedTimeRandomized
			{
				MinDuration = 7.0,
				MaxDuration = 14.0
			})) + (state_Nothing6.AddTickTransition(roam, ~new Trans_HasTarget()).AddTickTransition(flee, EncounterEndTrans).AddTickTransition(flee, new Trans_TargetIsInSafeZone())
				.AddTickTransition(flee, new Trans_IsTargetProtectedByMount()) + (state_Nothing3.AddTickTransition(flee, new Trans_Cooldown
			{
				cooldown = 30f
			} & new Trans_IsTargetTooFarFromWater()) + charge.AddTickTransition(flee, fSMTransitionBase & new Trans_ElapsedTime
			{
				Duration = 15.0
			} & ~new Trans_TargetInRange
			{
				Range = 15f
			}).AddTickTransition(bellyFlop, fSMTransitionBase & new Trans_Cooldown
			{
				cooldown = 6f
			} & new Trans_TargetInFront
			{
				Angle = 45f
			} & new Trans_TargetInRange
			{
				Range = 5f,
				TimeToPredict = 0.46f
			} & trans_CrocHasStraightPathToTarget).AddTickTransition(intimidateTurn, fSMTransitionBase & new Trans_Cooldown
			{
				cooldown = 5f
			} & ~new Trans_TargetInFront
			{
				Angle = 80f
			} & new Trans_TargetInRange
			{
				Range = 5f
			} & trans_CrocHasStraightPathToTarget)
				.AddTickTransition(staticAttack, fSMTransitionBase & new Trans_TargetInRange
				{
					Range = 2f,
					TimeToPredict = 0.5f
				} & trans_CrocHasStraightPathToTarget)
				.AddTickTransition(swimAttack, trans_IsSwimming & new Trans_TargetInRange
				{
					Range = 5.65f,
					TimeToPredict = 0.85f
				} & trans_CrocHasStraightPathToTarget)
				.AddFailureTransition(state_MoveToBreakFoundation) + intimidate.AddTickTransition(charge, HurtTrans).AddTickTransition(charge, new Trans_ElapsedTime
			{
				Duration = 0.25
			} & new Trans_TargetInRange
			{
				Range = 4f
			}).AddTickTransition(charge, new Trans_ElapsedTime
			{
				Duration = 1.5
			} & new Trans_TargetInRange
			{
				Range = 6f
			})
				.AddTickBranchingTrans(charge, ~new Trans_TargetInFront
				{
					Angle = 70f
				}, intimidateTurn, new Trans_Cooldown
				{
					cooldown = 5f
				})
				.AddEndTransition(charge)) + state_MoveToBreakFoundation.AddTickTransition(charge, new Trans_CanReachTarget_Slow()).AddFailureTransition(flee).AddEndTransition(state_CrocBreakFoundation)) + approachFood.AddTickBranchingTrans(charge, HurtTrans, flee, dstState2Trans).AddTickTransition(charge, new Trans_TargetInRange
			{
				Range = 8f
			}).AddTickTransition(roam, ~new Trans_SeesFood())
				.AddFailureTransition(roam)
				.AddEndTransition(bringFoodBackToWater) + bringFoodBackToWater.AddTickBranchingTrans(charge, HurtTrans, flee, dstState2Trans).AddTickTransition(charge, new Trans_TargetInRange
			{
				Range = 8f
			}).AddFailureTransition(roam)
				.AddEndTransition(roam) + bellyFlop.AddEndTransition(intimidateTurn, fSMTransitionBase & ~new Trans_TargetInFront
			{
				Angle = 30f
			}).AddEndTransition(intimidateSnap, fSMTransitionBase).AddEndTransition(charge) + state_CrocBreakFoundation.AddEndTransition(charge) + swimAttack.AddEndTransition(charge) + staticAttack.AddEndTransition(intimidateSnap) + intimidateSnap.AddEndTransition(intimidate) + intimidateTurn.AddEndTransition(intimidateSnap, new Trans_TargetInRange
			{
				Range = 6f
			}).AddEndTransition(charge) + flee.AddTickTransition(intimidate, fSMTransitionBase & new Trans_ElapsedTime
			{
				Duration = 3.0
			} & new Trans_TargetInRange
			{
				Range = 8f
			}).AddTickTransition(diveRoam, trans_IsSwimming).AddFailureTransition(dead)
				.AddEndTransition(diveRoam) + diveRoam.AddTickTransition(charge, ~new Trans_IsTargetProtectedByMount() & (new Trans_IsTargetInWater() | (new Trans_TargetInRange
			{
				Range = 8f
			} & new Trans_IsTargetOnNavmesh_Slow()))).AddTickTransition(roam, ~new Trans_TargetInRange
			{
				Range = 50f
			}).AddFailureTransition(dead) + dead);
			SetState(state_Nothing);
			Run();
		}
	}

	public override void Hurt(HitInfo hitInfo)
	{
		if (((Component)this).GetComponent<SenseComponent>().CanTarget(hitInfo.Initiator))
		{
			((Component)this).GetComponent<RootMotionPlayer>().PlayServerAdditive(hurt.WeakHitAdditive);
			HurtTrans.Trigger(hitInfo);
			if (base.CurrentState == approach || base.CurrentState == approachFood || base.CurrentState == bringFoodBackToWater || base.CurrentState == intimidate)
			{
				ForceTickOnTheNextUpdate();
			}
		}
	}

	public override bool OnDied(HitInfo hitInfo)
	{
		DeathTrans.Trigger(hitInfo);
		return false;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_LandOrSwimAttack : State_Attack
{
	public RootMotionData swimAttack;

	protected override RootMotionData GetAnimation()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (WaterLevel.GetWaterDepth(((Component)Owner).transform.position, waves: false, volumes: false) > 0f)
		{
			return swimAttack;
		}
		return Animation;
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_CrocIntimidate : FSMStateBase
{
	private float remainingDuration;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		if (Owner is BaseCombatEntity baseCombatEntity)
		{
			remainingDuration = Mathx.RemapValClamped(baseCombatEntity.healthFraction, 1f, 0.3f, 5f, 0f);
			if (remainingDuration == 0f)
			{
				return EFSMStateStatus.Success;
			}
			return result;
		}
		return EFSMStateStatus.Failure;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (remainingDuration > 0f)
		{
			remainingDuration -= deltaTime;
			if (remainingDuration <= 0f)
			{
				return EFSMStateStatus.Success;
			}
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_CrocTurn : State_PlayAnimationRM
{
	[SerializeField]
	public RootMotionData turn90L;

	[SerializeField]
	public RootMotionData turn90R;

	[SerializeField]
	public RootMotionData turn180;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 val = targetPosition - ((Component)Owner).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		float num = Vector3.SignedAngle(((Component)Owner).transform.forward, normalized, Vector3.up);
		if (Mathf.Abs(num) > 130f)
		{
			Animation = turn180;
		}
		else if (num > 0f)
		{
			Animation = turn90R;
		}
		else
		{
			Animation = turn90L;
		}
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_CrocCharge : State_MoveToTarget
{
	private const float maxChargeDuration = 6f;

	private float remainingChargeDuration;

	private Action _reallowChargingAction;

	private Action _surpriseAction;

	private Action _resetSurpriseAction;

	private double nextSurpriseTime;

	private Action ReallowChargingAction => ResetStamina;

	private Action SurpriseAction => Surprise;

	private Action ResetSurpriseAction => ResetSurprise;

	public override EFSMStateStatus OnStateEnter()
	{
		ResetStamina();
		ResetSurprise();
		return base.OnStateEnter();
	}

	private void ResetStamina()
	{
		remainingChargeDuration = 6f;
	}

	private void ResetSurprise()
	{
		float num = Random.Range(3f, 6f);
		((FacepunchBehaviour)Owner).Invoke(SurpriseAction, num);
		((FacepunchBehaviour)Owner).Invoke(ResetSurpriseAction, num + Random.Range(3f, 6f));
	}

	private void Surprise()
	{
		nextSurpriseTime = Time.timeAsDouble + (double)Random.Range(3f, 6f);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		if (Owner is BaseCombatEntity baseCombatEntity)
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return EFSMStateStatus.Success;
			}
			base.Agent.acceleration.Value = accelerationOverride;
			float num = Mathx.RemapValClamped(baseCombatEntity.healthFraction, 1f, 0.3f, 0f, 1f);
			bool flag = false;
			BasePlayer player;
			if (base.Agent.IsSwimming)
			{
				flag = true;
				base.Agent.acceleration.Value = 2.5f;
				num = 1f;
			}
			else if (baseCombatEntity.lastAttackedTime > 0f && Time.time < baseCombatEntity.lastAttackedTime + 0.5f)
			{
				flag = true;
				num = 1f;
			}
			else if (Time.timeAsDouble > nextSurpriseTime && Time.timeAsDouble < nextSurpriseTime + 0.5)
			{
				num = 1f;
			}
			else if (base.Agent.RemainingDistance < 4f)
			{
				flag = true;
				num = 1f;
			}
			else if (target.ToNonNpcPlayer(out player) && player.modelState.sprinting)
			{
				Vector3 estimatedVelocity = player.estimatedVelocity;
				if (Vector3.Dot(((Vector3)(ref estimatedVelocity)).normalized, ((Component)Owner).transform.forward) > 0.5f)
				{
					base.Agent.acceleration.Value = 2f;
					num = 1f;
				}
			}
			if (!flag && num >= 1f)
			{
				float num2 = remainingChargeDuration;
				remainingChargeDuration -= deltaTime;
				if (num2 > 0f && remainingChargeDuration <= 0f)
				{
					((FacepunchBehaviour)Owner).Invoke(ReallowChargingAction, 6f);
				}
			}
			if (!flag && remainingChargeDuration <= 0f)
			{
				num = Mathf.Min(num, 0.3f);
			}
			base.Agent.SetSpeedRatio(num, speed, LimitedTurnNavAgent.Speeds.FullSprint);
			if (base.Senses.GetVisibilityStatus(target, out var status) && status.isInWaterCached)
			{
				base.Agent.desiredSwimDepth.Value = Mathf.Max(base.Agent.desiredSwimDepth.DefaultValue, status.lastWaterInfo.Value.currentDepth + 1f);
			}
		}
		return base.OnStateUpdate(deltaTime);
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		destination = default(Vector3);
		if (!base.Senses.FindTarget(out var target))
		{
			return false;
		}
		if (target.IsNonNpcPlayer() && base.Agent.canSwim && base.Senses.GetVisibilityStatus(target, out var status) && status.isInWaterCached)
		{
			destination = Vector3Ex.WithY(((Component)target).transform.position, status.lastWaterInfo.Value.terrainHeight);
			return true;
		}
		return base.GetMoveDestination(out destination);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_GoBackToWater : State_MoveToTarget
{
	private Vector3 nearestWaterPoint;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		if (base.Agent.IsSwimming)
		{
			return EFSMStateStatus.Success;
		}
		TimeWarning val = TimeWarning.New("State_GoBackToWater GetCoarseVectorToShore and GetHeight", 0);
		try
		{
			(Vector3 shoreDir, float shoreDist) coarseVectorToShore = TerrainTexturing.Instance.GetCoarseVectorToShore(((Component)Owner).transform.position);
			Vector3 item = coarseVectorToShore.shoreDir;
			float item2 = coarseVectorToShore.shoreDist;
			Vector3 val2 = item * item2;
			Vector3 val3 = ((Component)Owner).transform.position + ((Vector3)(ref val2)).normalized * (((Vector3)(ref val2)).magnitude + 10f);
			val3.y = TerrainMeta.HeightMap.GetHeight(val3);
			PooledList<Vector3> val4 = Pool.Get<PooledList<Vector3>>();
			try
			{
				Eqs.SamplePositionsInDonutShape(val3, (List<Vector3>)(object)val4);
				ListEx.Shuffle<Vector3>((List<Vector3>)(object)val4, (uint)Environment.TickCount);
				nearestWaterPoint = val3;
				foreach (Vector3 item3 in (List<Vector3>)(object)val4)
				{
					if (base.Agent.SamplePosition(item3, out var sample, 10f) && base.Agent.IsInWater(sample))
					{
						nearestWaterPoint = sample;
						break;
					}
				}
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnStateEnter();
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		destination = nearestWaterPoint;
		return true;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_BringFoodBackToWater : State_GoBackToWater
{
	private BaseCorpse corpse;

	private Action _updateCorpsePositionAction;

	private Action UpdateCorpsePositionAction => OnStateFixedUpdate;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (!(food is BaseCorpse baseCorpse))
		{
			return EFSMStateStatus.Failure;
		}
		if (!SingletonComponent<NpcFoodManager>.Instance.Remove(baseCorpse))
		{
			return EFSMStateStatus.Failure;
		}
		((Component)Owner).transform.forward = Vector3Ex.NormalizeXZ(((Component)baseCorpse).transform.position - ((Component)Owner).transform.position);
		corpse = baseCorpse;
		corpse.SetFlag(BaseEntity.Flags.Reserved3, b: true);
		((FacepunchBehaviour)Owner).InvokeRepeatingFixedTime(UpdateCorpsePositionAction);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!corpse.IsValid() || corpse.IsDead())
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}

	private void OnStateFixedUpdate()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (corpse.IsValid() && !corpse.IsDead())
		{
			Rigidbody component = ((Component)corpse).GetComponent<Rigidbody>();
			if (component != null)
			{
				component.MovePosition(((Component)Owner).transform.position + ((Component)Owner).transform.forward * 1.6f + ((Component)Owner).transform.up * 0.6f);
				component.velocity = Vector3.zero;
				component.angularVelocity = Vector3.zero;
			}
		}
	}

	public override void OnStateExit()
	{
		base.OnStateExit();
		if (corpse.IsValid())
		{
			corpse.SetFlag(BaseEntity.Flags.Reserved3, b: false);
		}
		((FacepunchBehaviour)Owner).CancelInvokeFixedTime(UpdateCorpsePositionAction);
		corpse = null;
	}
}


using System;
using ConVar;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_AttackWithTracking : State_PlayAnimationRM
{
	public DamageType DamageType = DamageType.Bite;

	public float damageDelay = 0.5f;

	public float damage = 30f;

	public float forceScale = 1f;

	public float trackingSpeed = 90f;

	public float trackingDuration = 9999f;

	public float radius = 4f;

	public bool doesStrafeDodge;

	private Action _doDamageAction;

	private static readonly Vector3 force = new Vector3(15f, 3f, 15f);

	private double startTime;

	private Action DoDamageAction => _doDamageAction ?? (_doDamageAction = DoDamage);

	public override EFSMStateStatus OnStateEnter()
	{
		FaceTarget = false;
		startTime = Time.timeAsDouble;
		((FacepunchBehaviour)Owner).Invoke(DoDamageAction, damageDelay + AI.defaultInterpolationDelay);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (trackingDuration > 0f && trackingSpeed > 0f && Time.timeAsDouble - startTime < (double)(trackingDuration + AI.defaultInterpolationDelay) && base.Senses.FindTarget(out var target))
		{
			base.AnimPlayer.Track(((Component)target).transform.position, trackingSpeed, null);
		}
		return base.OnStateUpdate(deltaTime);
	}

	protected virtual void DoDamage()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !(target is BaseCombatEntity baseCombatEntity))
		{
			return;
		}
		if (baseCombatEntity.ToNonNpcPlayer(out var player) && doesStrafeDodge)
		{
			Vector3 estimatedVelocity = player.estimatedVelocity;
			if (Mathf.Abs(Vector3.Dot(((Vector3)(ref estimatedVelocity)).normalized, ((Component)Owner).transform.right)) > 0.7f)
			{
				return;
			}
		}
		if (base.Senses.GetVisibilityStatus(target, out var status) && status.timeNotVisible < 1f && Vector3.Distance(((Component)Owner).transform.position, ((Component)baseCombatEntity).transform.position) < radius)
		{
			baseCombatEntity.OnAttacked(damage, DamageType, Owner, ignoreShield: false);
			if (forceScale > 0f && (Object)(object)player != (Object)null)
			{
				Vector3 val = ((Vector3.Dot(((Component)Owner).transform.right, Vector3Ex.NormalizeXZ(((Component)player).transform.position - ((Component)Owner).transform.position)) > 0f) ? ((Component)Owner).transform.right : (-((Component)Owner).transform.right));
				player.DoPush((((Component)Owner).transform.forward * force.z + val * force.x + Vector3.up * force.y) * forceScale);
			}
		}
	}

	public override void OnStateExit()
	{
		((FacepunchBehaviour)Owner).CancelInvoke(DoDamageAction);
		base.OnStateExit();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_MoveToBreakFoundation : State_CrocCharge
{
	private const float maxHorizontalDist = 10f;

	private Vector3 attackLocation;

	private bool FindReachableLocation(out Vector3 location)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		location = default(Vector3);
		if (!base.Senses.FindTarget(out var target) || !target.ToNonNpcPlayer(out var player))
		{
			return false;
		}
		Vector3 position = ((Component)target).transform.position;
		if (Vector3.Distance(((Component)Owner).transform.position, position) > 50f)
		{
			return false;
		}
		if (((Object)(object)State_CrocBreakFoundation.FindNearestTwigFoundationOnTargetBuilding(base.Agent, player, null)).Is<BuildingBlock>(out BuildingBlock entAsT) && base.Agent.SamplePosition(entAsT.ClosestPoint(((Component)Owner).transform.position), out var sample, 10f))
		{
			location = sample;
			return true;
		}
		if (base.Agent.SamplePosition(position, out var sample2, 3f))
		{
			location = sample2;
			return true;
		}
		return false;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !target.ToNonNpcPlayer(out var _))
		{
			return EFSMStateStatus.Failure;
		}
		if (!FindReachableLocation(out attackLocation))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 val = attackLocation + ((Bounds)(ref Owner.bounds)).extents.y * Vector3.up;
		Vector3 val2 = target.CenterPoint() - val;
		if (GamePhysics.Trace(new Ray(val, val2), 0f, out var _, ((Vector3)(ref val2)).magnitude, 1503731969, (QueryTriggerInteraction)0))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		destination = attackLocation;
		return true;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_CrocBreakFoundation : State_AttackWithTracking
{
	public const float attackRange = 3f;

	private static bool FindBuildingBlockNearby(LimitedTurnNavAgent agent, Vector3 position, out BuildingBlock buildingBlock)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (agent.SampleGroundPositionWithPhysics(position, out var hitInfo, 2f, BasePlayer.GetRadius(), 2097152) && hitInfo.GetEntity() is BuildingBlock buildingBlock2)
		{
			buildingBlock = buildingBlock2;
			return true;
		}
		PooledList<BuildingBlock> val = Pool.Get<PooledList<BuildingBlock>>();
		try
		{
			Vis.Entities(position, 4f, (List<BuildingBlock>)(object)val, 2097152, (QueryTriggerInteraction)2);
			if (((List<BuildingBlock>)(object)val).Count > 0)
			{
				buildingBlock = ((List<BuildingBlock>)(object)val)[0];
				return true;
			}
			buildingBlock = null;
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static BuildingBlock FindNearestTwigFoundationOnTargetBuilding(LimitedTurnNavAgent agent, BasePlayer targetPlayer, float? maxDistance = null)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (!FindBuildingBlockNearby(agent, ((Component)targetPlayer).transform.position, out var buildingBlock))
		{
			return null;
		}
		BuildingManager.Building building = BuildingManager.server.GetBuilding(buildingBlock.buildingID);
		BuildingBlock result = null;
		float num = float.MaxValue;
		Enumerator<BuildingBlock> enumerator = building.buildingBlocks.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BuildingBlock current = enumerator.Current;
				if (current.grade == BuildingGrade.Enum.Twigs && (Object)(object)current.parentEntity.Get(serverside: true) == (Object)null && (current.ShortPrefabName == "foundation" || current.ShortPrefabName == "foundation.triangle"))
				{
					float num2 = current.Distance(((Component)agent).transform.position);
					if ((!maxDistance.HasValue || !(num2 > maxDistance.Value)) && num2 < num)
					{
						result = current;
						num = num2;
					}
				}
			}
			return result;
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	protected override void DoDamage()
	{
		if (base.Senses.FindTarget(out var target) && target.ToNonNpcPlayer(out var player))
		{
			BuildingBlock buildingBlock = FindNearestTwigFoundationOnTargetBuilding(base.Agent, player, null);
			if ((Object)(object)buildingBlock == (Object)null)
			{
				base.DoDamage();
			}
			else
			{
				buildingBlock.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_TryAmbushUnderwater : FSMStateBase
{
	[SerializeField]
	private Vector2 distanceRange = new Vector2(10f, 20f);

	[SerializeField]
	private float maxDistFromDivingPoint = 50f;

	private const float desiredDepth = 3f;

	private Vector3 divePosition;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		base.Agent.desiredSwimDepth.Value = 3f;
		divePosition = ((Component)Owner).transform.position;
		return FindNewUnderwaterWaitingPosition();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Agent.IsFollowingPath)
		{
			return FindNewUnderwaterWaitingPosition();
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.Agent.desiredSwimDepth.Reset();
		base.OnStateExit();
	}

	private EFSMStateStatus FindNewUnderwaterWaitingPosition()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			float radius = Random.Range(distanceRange.x, distanceRange.y);
			Eqs.SamplePositionsInDonutShape(base.Agent.NavPosition, (List<Vector3>)(object)val, radius);
			if (Vector3.Distance(divePosition, ((Component)Owner).transform.position) > maxDistFromDivingPoint)
			{
				Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
				try
				{
					Vector3 val2 = divePosition - ((Component)Owner).transform.position;
					Vector3 normalized = ((Vector3)(ref val2)).normalized;
					foreach (Vector3 item2 in (List<Vector3>)(object)val)
					{
						val2 = item2 - ((Component)Owner).transform.position;
						float item = Vector3.Dot(normalized, ((Vector3)(ref val2)).normalized);
						((List<(Vector3, float)>)(object)pooledScoreList).Add((item2, item));
					}
					pooledScoreList.SortByScoreDesc(Owner);
					pooledScoreList.Reorder((List<Vector3>)(object)val);
				}
				finally
				{
					((IDisposable)(object)pooledScoreList)?.Dispose();
				}
			}
			else
			{
				ListEx.Shuffle<Vector3>((List<Vector3>)(object)val, (uint)Environment.TickCount);
			}
			foreach (Vector3 item3 in (List<Vector3>)(object)val)
			{
				if (base.Agent.SamplePosition(item3, out var sample, 10f) && base.Agent.IsInWater(sample) && base.Agent.SetDestination(sample))
				{
					base.Agent.SetSpeed((!base.Agent.IsSwimming) ? LimitedTurnNavAgent.Speeds.Run : LimitedTurnNavAgent.Speeds.Sneak);
					return EFSMStateStatus.None;
				}
			}
			return EFSMStateStatus.Failure;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_TooFarFromWater : FSMTransitionBase
{
	public float maxDistance = 20f;

	protected override bool EvaluateInternal()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TooFarFromWater", 0);
		try
		{
			return TerrainTexturing.Instance.GetCoarseDistanceToShore(((Component)Owner).transform.position) < 0f - maxDistance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_IsTargetTooFarFromWater : FSMTransitionBase
{
	public float maxDistance = 30f;

	protected override bool EvaluateInternal()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_IsTargetTooFarFromWater", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			return TerrainTexturing.Instance.GetCoarseDistanceToShore(targetPosition) < 0f - maxDistance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
internal class Trans_CrocHasStraightPathToTarget : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_CrocHasStraightPathToTarget", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			Vector3 targetPosition = ((Component)target).transform.position;
			if (target.IsNonNpcPlayer() && base.Agent.canSwim && base.Senses.GetVisibilityStatus(target, out var status) && status.isInWaterCached)
			{
				targetPosition = Vector3Ex.WithY(((Component)target).transform.position, status.lastWaterInfo.Value.terrainHeight);
			}
			NavMeshHit hitInfo;
			return !base.Agent.Raycast(targetPosition, out hitInfo);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsTargetProtectedByMount : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsTargetProtectedByMount", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target) || !target.ToNonNpcPlayer(out var player))
			{
				return false;
			}
			BaseMountable entAsT;
			return ((Object)(object)player.GetMounted()).Is<BaseMountable>(out entAsT) && entAsT.ProtectsFromAnimals;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

public class ClawMarkSpawner : EntityComponent<BaseEntity>, IServerComponent
{
	public GameObjectRef clawDecal;

	public float radius = 130f;

	public float height = 1.8f;

	public float minTreeRadius = 1.4f;

	[Range(0f, 1f)]
	public float ratioOfTreesMarked = 0.5f;

	private static bool showClawMarks;

	private List<ClawMark> clawMarks = new List<ClawMark>();

	[ServerVar]
	public static void ShowClawMarks(Arg arg)
	{
		bool @bool = arg.GetBool(0, !showClawMarks);
		if (@bool == showClawMarks)
		{
			arg.ReplyWith("Claw marks are already " + (showClawMarks ? "visible" : "hidden") + ".");
			return;
		}
		showClawMarks = @bool;
		BaseNPC2[] array;
		if (showClawMarks)
		{
			array = BaseEntity.Util.FindAll<BaseNPC2>();
			for (int i = 0; i < array.Length; i++)
			{
				ClawMarkSpawner component = ((Component)array[i]).GetComponent<ClawMarkSpawner>();
				if ((Object)(object)component != (Object)null)
				{
					component.SpawnClawMarks();
				}
			}
			arg.ReplyWith("Claw marks are now visible.");
			return;
		}
		array = BaseEntity.Util.FindAll<BaseNPC2>();
		for (int i = 0; i < array.Length; i++)
		{
			ClawMarkSpawner component2 = ((Component)array[i]).GetComponent<ClawMarkSpawner>();
			if ((Object)(object)component2 != (Object)null)
			{
				component2.ClearClawMarks();
			}
		}
		arg.ReplyWith("Claw marks are now hidden.");
	}

	public override void InitShared()
	{
		UpdateBaseEntity();
		if (showClawMarks)
		{
			SpawnClawMarks();
		}
	}

	public override void DestroyShared()
	{
		ClearClawMarks();
	}

	private void SpawnClawMarks()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		if (!base.baseEntity.isServer)
		{
			return;
		}
		if (AI.logIssues && clawMarks.Count > 0)
		{
			Debug.LogWarning((object)$"Claw marks already spawned for {base.baseEntity}.");
			return;
		}
		PooledList<TreeEntity> val = Pool.Get<PooledList<TreeEntity>>();
		try
		{
			BaseEntity.Query.Server.GetInSphere(((Component)base.baseEntity).transform.position, radius, (List<TreeEntity>)(object)val);
			clawMarks.Capacity = ((List<TreeEntity>)(object)val).Count;
			RaycastHit val3 = default(RaycastHit);
			foreach (TreeEntity item in (List<TreeEntity>)(object)val)
			{
				if (Random.value > ratioOfTreesMarked || (Object)(object)item.serverCollider == (Object)null)
				{
					continue;
				}
				float num = Mathf.Min(((Bounds)(ref item.bounds)).extents.x, ((Bounds)(ref item.bounds)).extents.z);
				if (num < minTreeRadius)
				{
					continue;
				}
				Vector3 val2 = ((Component)item).transform.position + Vector3.up * height;
				Vector3 forward = ((Component)item).transform.forward;
				if (!item.serverCollider.Raycast(new Ray(val2 - forward * num, forward), ref val3, num))
				{
					continue;
				}
				ClawMark clawMark = GameManager.server.CreateEntity(clawDecal.resourcePath, ((RaycastHit)(ref val3)).point, Quaternion.LookRotation(-((RaycastHit)(ref val3)).normal)) as ClawMark;
				if ((Object)(object)clawMark == (Object)null)
				{
					if (AI.logIssues)
					{
						Debug.LogWarning((object)$"Failed to create claw mark for {base.baseEntity}.");
					}
				}
				else
				{
					clawMarks.Add(clawMark);
					clawMark.SetParent(item, worldPositionStays: true);
					clawMark.Spawn();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ClearClawMarks()
	{
		if (!base.baseEntity.isServer)
		{
			return;
		}
		foreach (ClawMark clawMark in clawMarks)
		{
			clawMark.Kill();
		}
		clawMarks.Clear();
	}
}


using Rust.Ai.Gen2;

[SoftRequireComponent(typeof(TigerFSM))]
public class Panther : BaseNPC2
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 0.5f;

	public override string Categorize()
	{
		return "Panther";
	}
}


using Rust.Ai.Gen2;

[SoftRequireComponent(typeof(TigerFSM))]
public class Tiger : BaseNPC2
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 0.5f;

	public override string Categorize()
	{
		return "Tiger";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_HurtWithAdditive : State_Hurt
{
	public AnimationClip WeakHitAdditive;
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_Roar : State_PlayAnimation
{
	public const string AlreadyRoared = "AlreadyRoared";

	public override EFSMStateStatus OnStateEnter()
	{
		if (!base.Senses.FindTarget(out var _))
		{
			return EFSMStateStatus.Failure;
		}
		base.Blackboard.Add("AlreadyRoared");
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_DeadlyAttack : State_Attack
{
	public float range = 4f;

	public SoundDefinition impactSound;

	private static readonly Vector3 force = new Vector3(15f, 3f, 15f);

	protected override void DoDamage()
	{
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !(target is BaseCombatEntity baseCombatEntity))
		{
			return;
		}
		float amount = Damage;
		if (target.IsNonNpcPlayer())
		{
			float num = baseCombatEntity.baseProtection.Get(DamageType);
			float num2 = (1f - num) * 1.2f;
			float num3 = Damage * num2;
			if (num == 0f && baseCombatEntity.health >= 30f && num3 > baseCombatEntity.health)
			{
				amount = (baseCombatEntity.health - 1f) * (1f / num2);
			}
		}
		baseCombatEntity.OnAttacked(amount, DamageType, Owner, ignoreShield: false);
		Owner.ClientRPC(RpcTarget.NetworkGroup("RPC_PlayNPCAttackImpactSound"));
		if (baseCombatEntity.ToNonNpcPlayer(out var player))
		{
			Vector3 val = ((Vector3.Dot(((Component)Owner).transform.right, Vector3Ex.NormalizeXZ(((Component)player).transform.position - ((Component)Owner).transform.position)) > 0f) ? ((Component)Owner).transform.right : (-((Component)Owner).transform.right));
			player.DoPush(((Component)Owner).transform.forward * force.z + val * force.x + Vector3.up * force.y);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_FleeToHide : State_Flee
{
	public const string HitDuringChargeKey = "HitDuringCharge";

	private bool clockWise;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		base.Blackboard.Remove("HitDuringCharge");
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		Vector3 val = Vector3Ex.NormalizeXZ(targetPosition - ((Component)Owner).transform.position);
		clockWise = Vector3.Dot(((Component)Owner).transform.right, val) > 0f;
		return base.OnStateEnter();
	}

	protected override EFSMStateStatus MoveAwayFromTarget()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		Vector3 val = ((Component)Owner).transform.position - targetPosition;
		float magnitude = ((Vector3)(ref val)).magnitude;
		Vector3 val2 = ((Component)Owner).transform.forward;
		float num = 15f;
		if (magnitude > 6f)
		{
			val2 = Vector3Ex.NormalizeXZ(((Component)Owner).transform.position - targetPosition);
			num = 55f;
		}
		val2 = Quaternion.AngleAxis(num * (clockWise ? 1f : (-1f)), Vector3.up) * val2;
		PooledList<Vector3> val3 = Pool.Get<PooledList<Vector3>>();
		try
		{
			Eqs.SamplePositionsInDonutShape(base.Agent.NavPosition, (List<Vector3>)(object)val3, distance);
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				foreach (Vector3 item3 in (List<Vector3>)(object)val3)
				{
					Vector3 val4 = val2;
					Vector3 val5 = item3 - ((Component)Owner).transform.position;
					float item = Vector3.Dot(val4, ((Vector3)(ref val5)).normalized);
					((List<(Vector3, float)>)(object)pooledScoreList).Add((item3, item));
				}
				pooledScoreList.SortByScoreDesc(Owner);
				foreach (var item4 in (List<(Vector3, float)>)(object)pooledScoreList)
				{
					Vector3 item2 = item4.Item1;
					if (base.Agent.SamplePosition(item2, out var sample, 10f) && (base.Agent.canSwim || !base.Agent.IsInWater(sample)) && base.Agent.SetDestination(sample))
					{
						return EFSMStateStatus.None;
					}
				}
				return EFSMStateStatus.Failure;
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val3)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Observe : State_MoveToTarget
{
	private double startTime;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus eFSMStateStatus = base.OnStateEnter();
		if (eFSMStateStatus == EFSMStateStatus.Failure)
		{
			return eFSMStateStatus;
		}
		succeedWhenDestinationIsReached = false;
		stopAtDestination = false;
		base.Agent.deceleration.Value = 0.1f;
		base.Agent.SetSpeed(0f);
		startTime = Time.timeAsDouble;
		base.Agent.currentDeviation = 2f;
		return eFSMStateStatus;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (Time.timeAsDouble - startTime > 6.0)
		{
			base.Agent.SetSpeed(0.2f);
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_AttackUnreachableWarped : FSMStateBase
{
	private enum Phase
	{
		PreJump,
		Jump,
		Attack,
		JumpBack,
		PostJumpBack
	}

	public float jumpOnStart = 1.03f;

	public float jumpOnEnd = 1.63f;

	public float jumpOffStart = 2.9f;

	public float jumpOffEnd = 3.47f;

	public float totalDuration = 3.6f;

	private const float groundCheckDistance = 2f;

	private const float damage = 35f;

	private const float meleeAttackRange = 1.7f;

	private const DamageType damageType = DamageType.Bite;

	public RootMotionData animClip;

	private float elapsedTime;

	private LockState.LockHandle targetLock;

	private LockState.LockHandle movementLock;

	private Phase phase;

	private RootMotionPlayer.Warp[] warps = new RootMotionPlayer.Warp[2];

	private RootMotionPlayer.PlayServerState animState;

	private Vector3 destination;

	private bool didHit;

	public static bool SampleGroundPositionUnderTarget(LimitedTurnNavAgent agent, BasePlayer targetAsPlayer, out Vector3 projectedLocation)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (targetAsPlayer.IsOnGround() && !targetAsPlayer.OnLadder())
		{
			projectedLocation = ((Component)targetAsPlayer).transform.position;
			return true;
		}
		float radius = BasePlayer.GetRadius();
		RaycastHit hitInfo;
		bool result = agent.SampleGroundPositionWithPhysics(((Component)targetAsPlayer).transform.position, out hitInfo, 2f, radius * 0.5f);
		projectedLocation = ((RaycastHit)(ref hitInfo)).point;
		return result;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer targetAsPlayer))
		{
			return EFSMStateStatus.Failure;
		}
		destination = ((Component)target).transform.position;
		if (!SampleGroundPositionUnderTarget(base.Agent, targetAsPlayer, out destination))
		{
			return EFSMStateStatus.Failure;
		}
		if (!State_MoveToLastReachablePointNearTarget.CanJumpFromPosToPos(Owner, ((Component)Owner).transform.position, destination))
		{
			return EFSMStateStatus.Failure;
		}
		movementLock = base.Agent.Pause();
		didHit = false;
		elapsedTime = 0f;
		targetLock = base.Senses.LockCurrentTarget();
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = false;
		animState = RootMotionPlayer.PlayServerState.TakeFromPool(animClip, ((Component)Owner).transform);
		animState.warps = warps;
		animState.constrainToNavmesh = false;
		base.AnimPlayer.PlayServer(animState);
		SetPhase(Phase.PreJump);
		return base.OnStateEnter();
	}

	private EFSMStateStatus SetPhase(Phase newPhase)
	{
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_032a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		phase = newPhase;
		if (phase == Phase.Jump)
		{
			if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer targetAsPlayer))
			{
				return EFSMStateStatus.Failure;
			}
			if (SampleGroundPositionUnderTarget(base.Agent, targetAsPlayer, out var projectedLocation))
			{
				destination = projectedLocation;
			}
			Vector3 position = ((Component)Owner).transform.position;
			animState.initialRotation = Quaternion.LookRotation(Vector3Ex.WithY(destination - ((Component)Owner).transform.position, 0f));
			((Component)Owner).transform.rotation = animState.initialRotation;
			float num = animClip.zMotionCurve.Evaluate(jumpOnEnd) - animClip.zMotionCurve.Evaluate(jumpOnStart);
			float num2 = animClip.yMotionCurve.Evaluate(jumpOnEnd) - animClip.yMotionCurve.Evaluate(jumpOnStart);
			RootMotionPlayer.Warp warp = new RootMotionPlayer.Warp(jumpOnStart, jumpOnEnd, Vector3.one);
			warp.translationScale.z = Vector3.Distance(Vector3Ex.WithY(destination, 0f), Vector3Ex.WithY(position, 0f)) / num;
			warp.translationScale.y = (destination.y - position.y) / num2;
			warps[0] = warp;
			float num3 = animClip.zMotionCurve.Evaluate(jumpOffStart) - animClip.zMotionCurve.Evaluate(jumpOffEnd);
			float num4 = animClip.yMotionCurve.Evaluate(jumpOffStart) - animClip.yMotionCurve.Evaluate(jumpOffEnd);
			RootMotionPlayer.Warp warp2 = new RootMotionPlayer.Warp(jumpOffStart, jumpOffEnd, Vector3.one);
			warp2.translationScale.z = Vector3.Distance(Vector3Ex.WithY(destination, 0f), Vector3Ex.WithY(position, 0f)) / num3;
			warp2.translationScale.y = (destination.y - position.y) / num4;
			warps[1] = warp2;
			base.Agent.IsJumping = true;
		}
		else if (phase == Phase.Attack)
		{
			if (base.Senses.FindTarget(out var target2))
			{
				if (target2 is BaseCombatEntity baseCombatEntity && Vector3.Distance(((Component)Owner).transform.position, ((Component)baseCombatEntity).transform.position) <= 1.7f)
				{
					didHit = true;
					baseCombatEntity.OnAttacked(35f, DamageType.Bite, Owner, ignoreShield: false);
				}
				if (target2 is BasePlayer basePlayer && Vector3.Distance(((Component)Owner).transform.position, ((Component)basePlayer).transform.position) <= 1f)
				{
					basePlayer.DoPush(((Component)Owner).transform.forward * 10f + Vector3.up * 3f);
				}
			}
		}
		else if (phase == Phase.PostJumpBack)
		{
			base.Agent.IsJumping = false;
		}
		return EFSMStateStatus.None;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		elapsedTime += deltaTime;
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		if (phase == Phase.PreJump)
		{
			Quaternion val = Quaternion.LookRotation(Vector3Ex.WithY(targetPosition - ((Component)Owner).transform.position, 0f));
			animState.initialRotation = Quaternion.RotateTowards(animState.initialRotation, val, Time.deltaTime * 60f);
			((Component)Owner).transform.rotation = animState.initialRotation;
			if (elapsedTime >= jumpOnStart && SetPhase(Phase.Jump) == EFSMStateStatus.Failure)
			{
				return EFSMStateStatus.Failure;
			}
		}
		if (phase == Phase.Jump && elapsedTime >= jumpOnEnd)
		{
			SetPhase(Phase.Attack);
		}
		if (phase == Phase.Attack && elapsedTime > jumpOffStart)
		{
			SetPhase(Phase.JumpBack);
		}
		if (phase == Phase.JumpBack && elapsedTime >= jumpOffEnd)
		{
			SetPhase(Phase.PostJumpBack);
		}
		if (elapsedTime >= animClip.inPlaceAnimation.length - 0.25f)
		{
			if (!didHit)
			{
				return EFSMStateStatus.Failure;
			}
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = true;
		base.Senses.UnlockTarget(ref targetLock);
		base.Agent.Unpause(ref movementLock);
		if (phase != Phase.PostJumpBack)
		{
			base.Agent.IsJumping = false;
		}
		base.OnStateExit();
	}
}


private enum Phase
{
	PreJump,
	Jump,
	Attack,
	JumpBack,
	PostJumpBack
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_DragCorpse : FSMStateBase
{
	[SerializeField]
	protected RootMotionData Animation;

	private const int numLoops = 6;

	private int currentLoop;

	private BaseCorpse corpse;

	private RootMotionPlayer.PlayServerState animState;

	private Action _updateCorpsePositionAction;

	private Action UpdateCorpsePositionAction => OnStateFixedUpdate;

	public override EFSMStateStatus OnStateEnter()
	{
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (!(food is BaseCorpse food2))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Senses.FindTarget(out var _))
		{
			return EFSMStateStatus.Failure;
		}
		if (!SingletonComponent<NpcFoodManager>.Instance.Remove(food2))
		{
			return EFSMStateStatus.Failure;
		}
		corpse = food2;
		corpse.SetFlag(BaseEntity.Flags.Reserved3, b: true);
		((FacepunchBehaviour)Owner).InvokeRepeatingFixedTime(UpdateCorpsePositionAction);
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (!corpse.IsValid() || corpse.IsDead())
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		if (animState != null)
		{
			Quaternion val = Quaternion.LookRotation(Vector3Ex.WithY(targetPosition - ((Component)Owner).transform.position, 0f));
			animState.initialRotation = Quaternion.RotateTowards(animState.initialRotation, val, Time.deltaTime * 60f);
			((Component)Owner).transform.rotation = animState.initialRotation;
		}
		if (!animState.isPlaying)
		{
			currentLoop++;
			if (currentLoop >= 6)
			{
				return EFSMStateStatus.Success;
			}
			base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
			animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
		}
		return base.OnStateUpdate(deltaTime);
	}

	private void OnStateFixedUpdate()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (corpse.IsValid() && !corpse.IsDead())
		{
			Rigidbody component = ((Component)corpse).GetComponent<Rigidbody>();
			if (component != null)
			{
				component.MovePosition(((Component)Owner).transform.position + ((Component)Owner).transform.forward * 1.6f + ((Component)Owner).transform.up * 0.6f);
				component.velocity = Vector3.zero;
				component.angularVelocity = Vector3.zero;
			}
		}
	}

	public override void OnStateExit()
	{
		base.OnStateExit();
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
		currentLoop = 0;
		if (corpse.IsValid())
		{
			SingletonComponent<NpcFoodManager>.Instance.Add(corpse);
			corpse.SetFlag(BaseEntity.Flags.Reserved3, b: false);
		}
		corpse = null;
		((FacepunchBehaviour)Owner).CancelInvokeFixedTime(UpdateCorpsePositionAction);
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_FastSneak : State_CircleDynamic
{
	public override EFSMStateStatus OnStateEnter()
	{
		base.Agent.deceleration.Value = 10f;
		return base.OnStateEnter();
	}

	protected override void SetSpeed(BaseEntity target, float distToTarget, float normalizedDist)
	{
		if (!target.ToNonNpcPlayer(out var player))
		{
			base.SetSpeed(target, distToTarget, normalizedDist);
		}
		else if (distToTarget > 50f)
		{
			base.Agent.SetSpeed(8.25f);
		}
		else if (player.modelState.sprinting && distToTarget < 20f)
		{
			base.Agent.SetSpeed(6.875f);
		}
		else if (player.modelState.sprinting)
		{
			base.Agent.SetSpeed(8.25f);
		}
		else if (player.modelState.ducked || player.estimatedSpeed < 0.1f)
		{
			base.Agent.SetSpeed(1.7f);
		}
		else
		{
			base.Agent.SetSpeed(3.5f);
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_IsTargetDown : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		if (!base.Senses.FindTarget(out var target))
		{
			return false;
		}
		if (!target.ToNonNpcPlayer(out var player))
		{
			return false;
		}
		return player.IsWounded();
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_IsWatchedByTarget : FSMTransitionBase
{
	public float minTime = 1.5f;

	public bool requireAiming = true;

	public bool wantsWatched = true;

	protected override bool EvaluateInternal()
	{
		if (!base.Senses.FindTarget(out var target))
		{
			return false;
		}
		if (!base.Senses.GetVisibilityStatus(target, out var status))
		{
			return false;
		}
		return ((!wantsWatched) ? (requireAiming ? status.timeNotAimedAt : status.timeNotWatched) : (requireAiming ? status.timeAimedAt : status.timeWatched)) > minTime;
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_IsTargetVisible : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		if (!base.Senses.FindTarget(out var target))
		{
			return false;
		}
		if (!base.Senses.GetVisibilityStatus(target, out var status))
		{
			return false;
		}
		return status.isVisible;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_IsInTargetViewCone : FSMTransitionBase
{
	public float angle = 90f;

	protected override bool EvaluateInternal()
	{
		return IsInTargetViewCone(base.Senses, angle);
	}

	public static bool IsInTargetViewCone(SenseComponent senses, float testAngle)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (!senses.FindTarget(out var target))
		{
			return false;
		}
		Vector3 val = ((Component)senses.GetBaseEntity()).transform.position - ((Component)target).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = (target.ToNonNpcPlayer(out var player) ? player.eyes.BodyForward() : ((Component)target).transform.forward);
		return Vector3.Dot(((Vector3)(ref val)).normalized, normalized) > Mathf.Cos(testAngle * (MathF.PI / 180f));
	}

	public override string ToString()
	{
		if (!Inverted)
		{
			return $"We are in target view cone of {angle} degrees";
		}
		return $"We are not in target view cone of {angle} degrees";
	}
}


using Rust.Ai.Gen2;

[SoftRequireComponent(typeof(Wolf2FSM))]
public class Wolf2 : BaseNPC2
{
	public override string Categorize()
	{
		return "Wolf";
	}
}


public static class NPCRangeConstants
{
	public const float MeleeRange = 2f;

	public const float CloseRange = 10f;

	public const float MediumRange = 16f;

	public const float LongRange = 50f;
}


public static class FireConstants
{
	public const float fireCirclingRadius = 16f;

	public const string HitByFire = "HitByFire";
}


using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class Wolf2FSM : FSMComponent
{
	public State_PlayRandomAnimation randomIdle = new State_PlayRandomAnimation();

	public State_Roam roam = new State_Roam();

	public State_Howl howl = new State_Howl();

	public State_CircleDynamic approach = new State_CircleDynamic();

	public State_Bark bark = new State_Bark();

	public State_Growl growlFire = new State_Growl();

	public State_ApproachFire approachFire = new State_ApproachFire();

	public State_FleeFire fleeFire = new State_FleeFire();

	public State_MoveToTarget charge = new State_MoveToTarget();

	public State_Attack attack = new State_Attack();

	public State_PlayAnimationRM leapAway = new State_PlayAnimationRM();

	public State_Circle reacCircle = new State_Circle();

	public State_CircleDynamic fastApproach = new State_CircleDynamic();

	public State_WolfHurt hurt = new State_WolfHurt();

	public State_Intimidated intimidated = new State_Intimidated();

	public State_Flee flee = new State_Flee();

	public State_Flee fleeForHowl = new State_Flee();

	public State_Dead dead = new State_Dead();

	public State_ApproachFood approachFood = new State_ApproachFood();

	public State_EatFood eatFood = new State_EatFood();

	public State_PlayAnimationRM growlFood = new State_PlayAnimationRM();

	public State_PlayAnimLoop sleep = new State_PlayAnimLoop();

	public State_AttackUnreachable attackUnreachable = new State_AttackUnreachable();

	private Trans_Triggerable_HitInfo HurtTrans;

	private Trans_Triggerable_HitInfo DeathTrans;

	private Trans_Triggerable<BaseEntity> AllyGotHurtNearby;

	private Trans_Triggerable<BaseEntity> HowlTrans;

	private Trans_Triggerable<BaseEntity> BarkTrans;

	public override void InitShared()
	{
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Expected O, but got Unknown
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Expected O, but got Unknown
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Expected O, but got Unknown
		if (base.baseEntity.isServer)
		{
			State_Nothing state_Nothing = new State_Nothing
			{
				Name = "WaitForNavMesh"
			};
			State_Circle state_Circle = new State_Circle
			{
				radius = 2f,
				speed = LimitedTurnNavAgent.Speeds.Sprint,
				Name = "Combo circle"
			};
			State_MoveToTarget state_MoveToTarget = new State_MoveToTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Walk,
				decelerationOverride = 6f,
				Name = "Step forward"
			};
			State_MoveToLastReachablePointNearTarget state_MoveToLastReachablePointNearTarget = new State_MoveToLastReachablePointNearTarget
			{
				speed = LimitedTurnNavAgent.Speeds.Sprint,
				succeedWhenDestinationIsReached = true,
				Name = "Go to last destination"
			};
			FSMStateBase fSMStateBase = leapAway.Clone();
			fSMStateBase.Name = "Leap away unreachable";
			State_Flee state_Flee = new State_Flee
			{
				distance = 8f,
				desiredDistance = 16f,
				Name = "Flee fire after attack"
			};
			FSMStateBase fSMStateBase2 = state_Circle.Clone();
			fSMStateBase2.Name = "Circle short fire";
			FSMStateBase fSMStateBase3 = charge.Clone();
			fSMStateBase3.Name = "Charge fire";
			FSMStateBase fSMStateBase4 = attack.Clone();
			fSMStateBase4.Name = "Attack fire";
			DeathTrans = new Trans_Triggerable_HitInfo();
			HurtTrans = new Trans_Triggerable_HitInfo();
			Trans_Triggerable PathFailedTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>().onPathFailed.AddListener((UnityAction)delegate
			{
				PathFailedTrans.Trigger();
			});
			Trans_Triggerable FireMeleeTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<SenseComponent>().onFireMelee.AddListener((UnityAction)delegate
			{
				FireMeleeTrans.Trigger();
			});
			Trans_Triggerable EncounterEndTrans = new Trans_Triggerable();
			((Component)base.baseEntity).GetComponent<NPCEncounterTimer>().onShouldGiveUp.AddListener((UnityAction)delegate
			{
				EncounterEndTrans.Trigger();
			});
			BarkTrans = new Trans_Triggerable<BaseEntity>();
			AllyGotHurtNearby = new Trans_Triggerable<BaseEntity>();
			HowlTrans = new Trans_Triggerable<BaseEntity>();
			State_Nothing state_Nothing2 = new State_Nothing();
			state_Nothing2.Name = "Root";
			State_Nothing state_Nothing3 = new State_Nothing
			{
				Name = "Alive"
			};
			State_Nothing state_Nothing4 = new State_Nothing
			{
				Name = "OnNavmesh"
			};
			State_Nothing state_Nothing5 = new State_Nothing
			{
				Name = "Food"
			};
			State_Nothing state_Nothing6 = new State_Nothing
			{
				Name = "Roaming"
			};
			State_Nothing state_Nothing7 = new State_Nothing
			{
				Name = "Has target"
			};
			State_Nothing state_Nothing8 = new State_Nothing
			{
				Name = "Not hurt"
			};
			State_Nothing state_Nothing9 = new State_Nothing
			{
				Name = "No fire"
			};
			State_Nothing state_Nothing10 = new State_Nothing
			{
				Name = "Reachable"
			};
			State_Nothing state_Nothing11 = new State_Nothing
			{
				Name = "Unreachable"
			};
			State_Nothing state_Nothing12 = new State_Nothing
			{
				Name = "Fire"
			};
			State_Nothing state_Nothing13 = new State_Nothing
			{
				Name = "Fire melee reac"
			};
			State_Nothing state_Nothing14 = new State_Nothing
			{
				Name = "Ready to help"
			};
			State_Nothing state_Nothing15 = new State_Nothing
			{
				Name = "Fire entry"
			};
			State_Nothing state_Nothing16 = new State_Nothing
			{
				Name = "Combat entry"
			};
			State_Nothing state_Nothing17 = new State_Nothing
			{
				Name = "Random post idle wait"
			};
			state_Nothing2.AddChildren(state_Nothing3.AddTickTransition(dead, DeathTrans).AddChildren(state_Nothing.AddTickTransition(roam, new Trans_IsNavmeshReady()), state_Nothing4.AddTickTransition(state_Nothing, new Trans_IsNavmeshReady
			{
				Inverted = true
			}).AddChildren(state_Nothing8.AddTickTransition(hurt, HurtTrans).AddChildren(state_Nothing6.AddTickTransition(dead, PathFailedTrans).AddTickTransition(approach, HowlTrans).AddTickTransition(state_Nothing16, new Trans_HasTarget())
				.AddTickTransition(approachFood, new Trans_SeesFood())
				.AddChildren(roam.AddEndTransition(sleep, new Trans_RandomChance
				{
					Chance = 0.25f
				}).AddEndTransition(randomIdle), sleep.AddEndTransition(roam), randomIdle.AddEndTransition(state_Nothing17), state_Nothing17.AddTickTransition(roam, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 0.0,
					MaxDuration = 3.0
				})), state_Nothing7.AddTickTransition(roam, new Trans_HasTarget
			{
				Inverted = true
			}).AddTickTransition(flee, EncounterEndTrans).AddTickTransition(flee, new Trans_TargetIsInSafeZone())
				.AddChildren(state_Nothing10.AddTickTransition(flee, new Trans_IsInWaterSlow() | new Trans_IsTargetInWater()).AddTickTransition(state_MoveToLastReachablePointNearTarget, PathFailedTrans).AddChildren(state_Nothing9.AddTickTransition(state_Nothing15, new Trans_TargetIsNearFire
				{
					onlySeeFireWhenClose = true
				}).AddChildren(state_Nothing16.AddTickTransition(howl, new Trans_HasBlackboardBool
				{
					Key = "WolfNearbyAlreadyHowled",
					Inverted = true
				}).AddTickTransition(approach, new Trans_AlwaysValid()), state_Nothing14.AddTickTransition(flee, new Trans_And
				{
					AllyGotHurtNearby,
					new Trans_TargetIsNearFire()
				}).AddTickTransition(fastApproach, AllyGotHurtNearby).AddTickTransition(charge, BarkTrans)
					.AddChildren(howl.AddTickTransition(approach, new Trans_TargetInRange
					{
						Range = 12f
					}).AddEndTransition(approach), approach.AddTickBranchingTrans(charge, new Trans_TargetInRange
					{
						Range = 12f
					}, bark, new Trans_HasBlackboardBool
					{
						Key = "WolfNearbyAlreadyBarked",
						Inverted = true
					}).AddTickTransition(approachFood, new Trans_And
					{
						new Trans_SeesFood(),
						new Trans_HasBlackboardBool
						{
							Key = "TriedToApproachUnreachableFood",
							Inverted = true
						}
					})), bark.AddTickTransition(charge, new Trans_TargetInRange
				{
					Range = 2f
				}).AddEndTransition(charge), charge.AddTickTransition(fastApproach, AllyGotHurtNearby).AddTickTransition(attack, new Trans_TargetInRange
				{
					Range = 2f
				}).AddTickTransition(approach, new Trans_ElapsedTime
				{
					Duration = 5.0
				})
					.AddFailureTransition(state_MoveToLastReachablePointNearTarget), attack.AddEndTransition(leapAway, new Trans_TargetInFront
				{
					Angle = 120f,
					Inverted = true
				}).AddEndTransition(state_Circle), leapAway.AddEndTransition(state_Circle), state_Circle.AddTickTransition(charge, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 0.75,
					MaxDuration = 1.5
				}).AddEndTransition(charge), reacCircle.AddTickTransition(reacCircle, AllyGotHurtNearby).AddTickTransition(charge, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 2.0,
					MaxDuration = 4.0
				}).AddEndTransition(charge), fastApproach.AddTickTransition(reacCircle, new Trans_TargetInRange
				{
					Range = reacCircle.radius + 5f
				}).AddTickTransition(charge, BarkTrans), fleeForHowl.AddEndTransition(howl)), state_Nothing12.AddTickTransition(flee, PathFailedTrans).AddTickTransition(flee, AllyGotHurtNearby).AddChildren(state_Nothing15.AddTickTransition(intimidated, new Trans_TargetInRange
				{
					Range = 12f
				}).AddTickTransition(growlFire, new Trans_HasBlackboardBool
				{
					Key = "AlreadyGrowled",
					Inverted = true
				}).AddTickTransition(approachFire, new Trans_AlwaysValid()), state_Nothing13.AddTickBranchingTrans(intimidated, FireMeleeTrans, growlFire, new Trans_RandomChance
				{
					Chance = 0.75f
				}).AddChildren(approachFire.AddTickTransition(fSMStateBase2, new Trans_TargetInRange
				{
					Range = 5f
				}).AddTickTransition(fastApproach, new Trans_TargetIsNearFire
				{
					Inverted = true
				}).AddTickTransition(fastApproach, new Trans_TargetInRange
				{
					Range = 21f,
					Inverted = true
				}), state_MoveToTarget.AddTickTransition(fSMStateBase2, new Trans_TargetInRange
				{
					Range = 5f
				}).AddTickTransition(approachFire, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 1.0,
					MaxDuration = 3.0
				})), growlFire.AddTickTransition(intimidated, FireMeleeTrans).AddTickTransition(fSMStateBase2, new Trans_TargetInRange
				{
					Range = 5f
				}).AddEndTransition(approachFire), fSMStateBase2.AddTickTransition(fSMStateBase3, new Trans_ElapsedTimeRandomized
				{
					MinDuration = 0.5,
					MaxDuration = 1.25
				}).AddEndTransition(fSMStateBase3), fSMStateBase3.AddTickTransition(fSMStateBase4, new Trans_TargetInRange
				{
					Range = 2f
				}), fSMStateBase4.AddEndTransition(state_Flee), intimidated.AddEndTransition(fleeFire), fleeFire.AddEndTransition(state_MoveToTarget), state_Flee.AddEndTransition(state_MoveToTarget))), state_Nothing11.AddChildren(state_MoveToLastReachablePointNearTarget.AddFailureTransition(flee).AddTickTransition(flee, FireMeleeTrans).AddTickTransition(charge, new Trans_CanReachTarget_Slow())
					.AddEndTransition(charge, new Trans_CanReachTarget_Slow())
					.AddEndTransition(attackUnreachable)
					.AddEndTransition(flee), fSMStateBase.AddEndTransition(state_MoveToLastReachablePointNearTarget)), flee.AddTickTransition(dead, PathFailedTrans).AddEndTransition(fastApproach, new Trans_TargetInRange
				{
					Range = flee.desiredDistance
				}).AddEndTransition(roam)), state_Nothing5.AddTickTransition(state_Nothing15, new Trans_TargetIsNearFire
			{
				onlySeeFireWhenClose = true
			}).AddTickTransition(approach, HowlTrans).AddTickTransition(fastApproach, AllyGotHurtNearby)
				.AddTickTransition(charge, BarkTrans)
				.AddTickTransition(roam, new Trans_SeesFood
				{
					Inverted = true
				})
				.AddChildren(approachFood.AddTickTransition(growlFood, new Trans_TargetInRange
				{
					Range = 12f
				}).AddFailureTransition(roam).AddEndTransition(eatFood), eatFood.AddTickTransition(growlFood, new Trans_TargetInRange
				{
					Range = 12f
				}).AddFailureTransition(roam).AddEndTransition(roam), growlFood.AddTickTransition(bark, new Trans_TargetInRange
				{
					Range = 5f
				}).AddEndTransition(bark, new Trans_TargetInRange
				{
					Range = 12f
				}).AddEndTransition(approachFood))), hurt.AddEndTransition(flee, new Trans_IsHealthBelowPercentage()).AddEndTransition(flee, new Trans_HasBlackboardBool
			{
				Key = "HitByFire"
			}).AddEndTransition(flee, new Trans_TargetIsNearFire())
				.AddEndTransition(flee, new Trans_TargetInRange
				{
					Range = 50f,
					Inverted = true
				})
				.AddEndTransition(fleeForHowl, new Trans_InitialAlliesNotFighting())
				.AddEndTransition(charge, new Trans_And
				{
					new Trans_RandomChance
					{
						Chance = 0.5f
					},
					new Trans_TargetInRange
					{
						Range = 12f
					}
				})
				.AddEndTransition(reacCircle, new Trans_TargetInRange
				{
					Range = reacCircle.radius + 5f
				})
				.AddEndTransition(fastApproach)), attackUnreachable.AddFailureTransition(flee).AddEndTransition(flee, new Trans_TargetIsNearFire()).AddEndTransition(fSMStateBase)), dead);
			SetState(state_Nothing);
			Run();
		}
	}

	public override void Hurt(HitInfo hitInfo)
	{
		if (((Component)this).GetComponent<SenseComponent>().CanTarget(hitInfo.Initiator) && (hitInfo.Initiator.IsNonNpcPlayer() || !(Random.value > 0.5f)))
		{
			HurtTrans.Trigger(hitInfo);
			if (base.CurrentState != hurt && base.CurrentState != dead)
			{
				ForceTickOnTheNextUpdate();
			}
		}
	}

	public void Intimidate(BaseEntity target)
	{
		AllyGotHurtNearby.Trigger(target);
	}

	public void Howl(BaseEntity target)
	{
		HowlTrans.Trigger(target);
	}

	public void Bark(BaseEntity target)
	{
		BarkTrans.Trigger(target);
	}

	public override bool OnDied(HitInfo hitInfo)
	{
		DeathTrans.Trigger(hitInfo);
		return false;
	}
}


using Facepunch;
using Rust.Ai.Gen2;

public class Trans_Triggerable_HitInfo : Trans_Triggerable
{
	private HitInfo HitInfo;

	public virtual void Trigger(HitInfo hitInfo)
	{
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
		HitInfo = Pool.Get<HitInfo>();
		HitInfo.CopyFrom(hitInfo);
		Trigger();
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		if (base.Triggered && to is IParametrized<HitInfo> parametrized)
		{
			parametrized.SetParameter(HitInfo);
		}
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
[SoftRequireComponent(typeof(LimitedTurnNavAgent), typeof(SenseComponent), typeof(BlackboardComponent))]
public class State_ApproachFood : State_MoveToTarget
{
	public const string TriedToApproachUnreachableFood = "TriedToApproachUnreachableFood";

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (food.WaterFactor() > 0f || !base.Agent.CanReach(((Component)food).transform.position))
		{
			base.Blackboard.Add("TriedToApproachUnreachableFood");
			SingletonComponent<NpcFoodManager>.Instance.Remove(food);
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			destination = Vector3.zero;
			return false;
		}
		destination = ((Component)food).transform.position;
		return true;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
[SoftRequireComponent(typeof(RootMotionPlayer))]
public class State_EatFood : FSMStateBase
{
	[SerializeField]
	protected AnimationClip Animation;

	private const float damageToCorpsesPerLoop = 2.5f;

	private const float timeToForgetSightingWhileEating = 5f;

	private RootMotionPlayer.PlayServerState animState;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 val = ((Component)food).transform.position - ((Component)Owner).transform.position;
		val.y = 0f;
		((Component)Owner).transform.rotation = Quaternion.LookRotation(val);
		base.Senses.timeToForgetSightings.Value = 5f;
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Senses.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (!animState.isPlaying)
		{
			if (food is BaseCorpse baseCorpse)
			{
				baseCorpse.Hurt(2.5f);
				if (baseCorpse.IsDead())
				{
					base.Senses.ClearTarget();
					return EFSMStateStatus.Success;
				}
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
			}
			else if (food is DroppedItem droppedItem)
			{
				droppedItem.item.amount = Mathf.FloorToInt((float)droppedItem.item.amount * 0.5f);
				if (droppedItem.item.amount <= 0)
				{
					droppedItem.DestroyItem();
					droppedItem.Kill();
					base.Senses.ClearTarget();
					return EFSMStateStatus.Success;
				}
				droppedItem.item.MarkDirty();
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
			}
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Senses.timeToForgetSightings.Reset();
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Flee : FSMStateBase
{
	[SerializeField]
	public float desiredDistance = 50f;

	[SerializeField]
	public float distance = 20f;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds speed = LimitedTurnNavAgent.Speeds.Sprint;

	[SerializeField]
	private int maxAttempts = 3;

	private int attempts;

	protected float startDistance;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		base.Blackboard.Remove("HitByFire");
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		attempts = 0;
		base.Agent.SetSpeed(speed);
		base.Agent.shouldStopAtDestination = false;
		startDistance = Vector3.Distance(((Component)Owner).transform.position, targetPosition);
		return MoveAwayFromTarget();
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (base.Agent.IsFollowingPath)
		{
			return base.OnStateUpdate(deltaTime);
		}
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		if (Vector3.Distance(targetPosition, ((Component)Owner).transform.position) > desiredDistance + startDistance)
		{
			return EFSMStateStatus.Success;
		}
		attempts++;
		if (attempts >= maxAttempts)
		{
			return EFSMStateStatus.Success;
		}
		return MoveAwayFromTarget();
	}

	protected virtual EFSMStateStatus MoveAwayFromTarget()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Success;
		}
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			Eqs.SamplePositionsInDonutShape(base.Agent.NavPosition, (List<Vector3>)(object)val, distance);
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				Vector3 val2 = Vector3Ex.NormalizeXZ(((Component)Owner).transform.position - targetPosition);
				foreach (Vector3 item3 in (List<Vector3>)(object)val)
				{
					Vector3 val3 = item3 - ((Component)Owner).transform.position;
					float item = Vector3.Dot(val2, ((Vector3)(ref val3)).normalized);
					((List<(Vector3, float)>)(object)pooledScoreList).Add((item3, item));
				}
				pooledScoreList.SortByScoreDesc(Owner);
				foreach (var item4 in (List<(Vector3, float)>)(object)pooledScoreList)
				{
					Vector3 item2 = item4.Item1;
					if (base.Agent.SamplePosition(item2, out var sample, 10f) && (base.Agent.canSwim || !base.Agent.IsInWater(sample)) && base.Agent.SetDestination(sample))
					{
						return EFSMStateStatus.None;
					}
				}
				return EFSMStateStatus.Failure;
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_FleeFire : State_Flee
{
	private int numExecutions;

	private int maxExecutionsBeforeMinDist = 2;

	private float minDistance = 8f;

	private float maxDistance = 20f;

	private double timeOfLastExecution;

	public override EFSMStateStatus OnStateEnter()
	{
		if (Time.timeAsDouble - timeOfLastExecution > 30.0)
		{
			numExecutions = 0;
		}
		timeOfLastExecution = Time.timeAsDouble;
		distance = 7f;
		desiredDistance = Mathx.RemapValClamped((float)numExecutions, 0f, (float)maxExecutionsBeforeMinDist, maxDistance, minDistance);
		numExecutions++;
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (base.Senses.FindTargetPosition(out var targetPosition) && Time.timeAsDouble - timeOfLastExecution > 1.0 && Vector3.Distance(((Component)Owner).transform.position, targetPosition) > desiredDistance)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Roam : FSMStateBase
{
	[SerializeField]
	private Vector2 distanceRange = new Vector2(10f, 20f);

	[SerializeField]
	private float homeRadius = 50f;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds minSpeed;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds maxSpeed = LimitedTurnNavAgent.Speeds.Sprint;

	[SerializeField]
	protected bool favourWater;

	private Vector3? spawnPosition;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Reset();
		if (!spawnPosition.HasValue)
		{
			spawnPosition = ((Component)Owner).transform.position;
		}
		if (!TrySetRoamDestination())
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	private bool TrySetRoamDestination()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		PooledList<Vector3> val = Pool.Get<PooledList<Vector3>>();
		try
		{
			float num = Random.Range(distanceRange.x, distanceRange.y);
			Eqs.SamplePositionsInDonutShape(base.Agent.NavPosition, (List<Vector3>)(object)val, num);
			bool flag = Vector3.Distance(spawnPosition.Value, ((Component)Owner).transform.position) > homeRadius;
			Eqs.PooledScoreList pooledScoreList = Pool.Get<Eqs.PooledScoreList>();
			try
			{
				Vector3 val2 = spawnPosition.Value - ((Component)Owner).transform.position;
				Vector3 normalized = ((Vector3)(ref val2)).normalized;
				foreach (Vector3 item2 in (List<Vector3>)(object)val)
				{
					float num2 = 0f;
					if (flag)
					{
						float num3 = num2;
						val2 = item2 - ((Component)Owner).transform.position;
						num2 = num3 + Mathx.RemapValClamped(Vector3.Dot(normalized, ((Vector3)(ref val2)).normalized), -1f, 1f, 0f, 1f);
						if (base.Agent.IsPositionOnFavoredTerrain(item2))
						{
							num2 += 0.25f;
						}
					}
					else
					{
						num2 += Random.value;
						if (base.Agent.IsPositionOnFavoredTerrain(item2))
						{
							num2 += 10f;
						}
					}
					((List<(Vector3, float)>)(object)pooledScoreList).Add((item2, num2));
				}
				pooledScoreList.SortByScoreDesc(Owner);
				foreach (var item3 in (List<(Vector3, float)>)(object)pooledScoreList)
				{
					Vector3 item = item3.Item1;
					if (base.Agent.SamplePosition(item, out var sample, 10f) && (base.Agent.canSwim || !base.Agent.IsInWater(sample)) && base.Agent.SetDestination(sample))
					{
						float ratio = Mathf.InverseLerp(0f, distanceRange.y, num);
						base.Agent.SetSpeedRatio(ratio, minSpeed, maxSpeed);
						return true;
					}
				}
				return false;
			}
			finally
			{
				((IDisposable)(object)pooledScoreList)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!base.Agent.IsFollowingPath)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	private void Reset()
	{
		base.Senses.ClearTarget();
		base.Blackboard.Clear();
		if (Owner is BaseCombatEntity { healthFraction: <1f, SecondsSinceAttacked: >120f } baseCombatEntity)
		{
			baseCombatEntity.SetHealth(Owner.MaxHealth());
		}
	}
}


using System;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Dead : FSMStateBase, IParametrized<HitInfo>
{
	[SerializeField]
	private string deathStatName;

	[SerializeField]
	private GameObjectRef CorpsePrefab;

	[SerializeField]
	private RootMotionData staticDeathAnim;

	[SerializeField]
	private RootMotionData forwardMotionDeathAnim;

	[SerializeField]
	private float ragdollWhenAnimRemainingTimeIsBelow = 0.5f;

	private HitInfo HitInfo;

	private RootMotionPlayer.PlayServerState animState;

	private Action _startRagdollAction;

	private Action StartRagdollAction => StartRagdoll;

	public void SetParameter(HitInfo parameter)
	{
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
		if (parameter == null)
		{
			Debug.LogWarning((object)"No parameter set for death state");
		}
		HitInfo = Pool.Get<HitInfo>();
		HitInfo.CopyFrom(parameter);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		if (HitInfo != null && (Object)(object)HitInfo.InitiatorPlayer != (Object)null)
		{
			BasePlayer initiatorPlayer = HitInfo.InitiatorPlayer;
			initiatorPlayer.GiveAchievement("KILL_ANIMAL");
			if (!string.IsNullOrEmpty(deathStatName))
			{
				initiatorPlayer.stats.Add(deathStatName, 1, (Stats)5);
				initiatorPlayer.stats.Save();
			}
			if (Owner is BaseCombatEntity killed)
			{
				initiatorPlayer.LifeStoryKill(killed);
			}
		}
		if (!CorpsePrefab.isValid)
		{
			Owner.Kill();
			return base.OnStateEnter();
		}
		if (forwardMotionDeathAnim != null && base.Agent.IsSpeedGTE(LimitedTurnNavAgent.Speeds.Run))
		{
			animState = base.AnimPlayer.PlayServerAndTakeFromPool(forwardMotionDeathAnim);
			float num = Mathf.Max(0f, forwardMotionDeathAnim.inPlaceAnimation.length - ragdollWhenAnimRemainingTimeIsBelow);
			((FacepunchBehaviour)Owner).Invoke(StartRagdollAction, num + AI.defaultInterpolationDelay);
		}
		else if (staticDeathAnim != null && HitInfo != null && Vector3.Dot(HitInfo.attackNormal, ((Component)Owner).transform.forward) < 0f)
		{
			animState = base.AnimPlayer.PlayServerAndTakeFromPool(staticDeathAnim);
			float num2 = Mathf.Max(0f, staticDeathAnim.inPlaceAnimation.length - ragdollWhenAnimRemainingTimeIsBelow);
			((FacepunchBehaviour)Owner).Invoke(StartRagdollAction, num2 + AI.defaultInterpolationDelay);
		}
		else
		{
			StartRagdoll();
		}
		return base.OnStateEnter();
	}

	private void StartRagdoll()
	{
		BaseCorpse baseCorpse = Owner.DropCorpse(CorpsePrefab.resourcePath);
		if (Object.op_Implicit((Object)(object)baseCorpse))
		{
			baseCorpse.Spawn();
			baseCorpse.TakeChildren(Owner);
		}
		((FacepunchBehaviour)Owner).Invoke((Action)Owner.KillMessage, 0.5f);
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
		Pool.Free<HitInfo>(ref HitInfo);
		base.OnStateExit();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Howl : State_PlayAnimation
{
	public const string WolfNearbyAlreadyHowled = "WolfNearbyAlreadyHowled";

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var targetEntity))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Agent.CanReach(((Component)targetEntity).transform.position, resetPathOnFailure: true))
		{
			return EFSMStateStatus.Failure;
		}
		base.Blackboard.Add("WolfNearbyAlreadyHowled");
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetInitialAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<BlackboardComponent>().Add("WolfNearbyAlreadyHowled");
				Wolf2FSM otherWolf = ((Component)item).GetComponent<Wolf2FSM>();
				((FacepunchBehaviour)Owner).Invoke((Action)delegate
				{
					otherWolf.Howl(targetEntity);
				}, 1f);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_Growl : State_PlayAnimationRM
{
	public const string AlreadyGrowled = "AlreadyGrowled";

	public override EFSMStateStatus OnStateEnter()
	{
		base.Blackboard.Increment("AlreadyGrowled");
		return base.OnStateEnter();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Bark : State_PlayAnimation
{
	public const string WolfNearbyAlreadyBarked = "WolfNearbyAlreadyBarked";

	public override EFSMStateStatus OnStateEnter()
	{
		if (!base.Senses.FindTarget(out var targetEntity))
		{
			return EFSMStateStatus.Failure;
		}
		base.Blackboard.Add("WolfNearbyAlreadyBarked");
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetInitialAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<BlackboardComponent>().Add("WolfNearbyAlreadyBarked");
				Wolf2FSM otherWolf = ((Component)item).GetComponent<Wolf2FSM>();
				((FacepunchBehaviour)Owner).Invoke((Action)delegate
				{
					otherWolf.Bark(targetEntity);
				}, Mathf.Max(0f, Animation.length + Random.Range(-0.5f, 0.5f)));
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Intimidated : State_PlayAnimationRM
{
	private static readonly float facingAwayDotThreshold = Mathf.Cos(MathF.PI / 2f);

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		FaceTarget = true;
		if (base.Senses.FindTargetPosition(out var targetPosition))
		{
			Vector3 forward = ((Component)Owner).transform.forward;
			Vector3 val = ((Component)Owner).transform.position - targetPosition;
			if (Vector3.Dot(forward, ((Vector3)(ref val)).normalized) > facingAwayDotThreshold)
			{
				return EFSMStateStatus.Success;
			}
		}
		return base.OnStateEnter();
	}
}


using System;
using Facepunch;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_Hurt : State_PlayAnimationRM, IParametrized<HitInfo>
{
	[SerializeField]
	private RootMotionData StrongHitL;

	[SerializeField]
	private RootMotionData StrongHitR;

	[SerializeField]
	private RootMotionData WeakHit;

	[SerializeField]
	private float StaggerRatio = 0.5f;

	private HitInfo HitInfo;

	public void SetParameter(HitInfo parameter)
	{
		if (HitInfo != null)
		{
			Pool.Free<HitInfo>(ref HitInfo);
		}
		if (parameter == null)
		{
			Debug.LogWarning((object)"No parameter set for hurt state");
		}
		HitInfo = Pool.Get<HitInfo>();
		HitInfo.CopyFrom(parameter);
	}

	public bool ShouldStagger(BaseEntity owner, HitInfo hitInfo)
	{
		float num = owner.Health() + hitInfo.damageTypes.Total();
		float num2 = owner.MaxHealth() * StaggerRatio;
		if (num > num2)
		{
			return owner.Health() < num2;
		}
		return false;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		if (HitInfo == null)
		{
			Debug.LogWarning((object)"No hitinfo set for hurt state");
			return base.OnStateEnter();
		}
		if (Object.op_Implicit((Object)(object)HitInfo.InitiatorPlayer) && !HitInfo.damageTypes.IsMeleeType())
		{
			HitInfo.InitiatorPlayer.LifeStoryShotHit(HitInfo.Weapon);
		}
		if (HitInfo.damageTypes.Has(DamageType.Heat))
		{
			base.Blackboard.Add("HitByFire");
		}
		if (WeakHit == null || ShouldStagger(Owner, HitInfo))
		{
			bool flag = Vector3.Dot(HitInfo.attackNormal, ((Component)Owner).transform.right) > 0f;
			Animation = (flag ? StrongHitL : StrongHitR);
		}
		else
		{
			Animation = WeakHit;
		}
		if (HitInfo.Initiator is BaseCombatEntity baseCombatEntity)
		{
			bool flag2 = true;
			if (base.Senses.FindTarget(out var target))
			{
				bool num = Owner.Distance((BaseEntity)baseCombatEntity) < 16f;
				bool flag3 = !target.IsNonNpcPlayer() && baseCombatEntity.IsNonNpcPlayer();
				flag2 = num || flag3;
			}
			if (flag2)
			{
				base.Senses.TrySetTarget(baseCombatEntity);
			}
		}
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		Pool.Free<HitInfo>(ref HitInfo);
		base.OnStateExit();
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_WolfHurt : State_Hurt
{
	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		if (!base.Senses.FindTarget(out var target))
		{
			if (AI.logIssues)
			{
				Debug.LogWarning((object)"Got attacked but couldn't find a target");
			}
			return result;
		}
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			base.Senses.GetInitialAllies((List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				((Component)item).GetComponent<Wolf2FSM>().Intimidate(target);
			}
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using ConVar;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Assertions;

[Serializable]
public class State_Attack : State_PlayAnimationRM
{
	[SerializeField]
	public float Damage = 30f;

	[SerializeField]
	public float Delay = 0.5f;

	[SerializeField]
	public DamageType DamageType = DamageType.Bite;

	private Action _doDamageAction;

	protected Action DoDamageAction => _doDamageAction ?? (_doDamageAction = DoDamage);

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(Delay < Animation.inPlaceAnimation.length);
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			return EFSMStateStatus.Failure;
		}
		if (!FaceTarget)
		{
			Vector3 val = Vector3Ex.NormalizeXZ(((Component)Owner).transform.position - targetPosition);
			Vector3 val2 = Vector3.Cross(Vector3.up, val);
			targetPosition += ((Random.value > 0.5f) ? 1f : (-1f)) * val2;
			Vector3 val3 = Vector3Ex.NormalizeXZ(targetPosition - ((Component)Owner).transform.position);
			((Component)Owner).transform.rotation = Quaternion.LookRotation(val3);
		}
		((FacepunchBehaviour)Owner).Invoke(DoDamageAction, Delay + AI.defaultInterpolationDelay);
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		((FacepunchBehaviour)Owner).CancelInvoke(DoDamageAction);
		base.OnStateExit();
	}

	protected virtual void DoDamage()
	{
		if (base.Senses.FindTarget(out var target) && target is BaseCombatEntity baseCombatEntity)
		{
			baseCombatEntity.OnAttacked(Damage, DamageType, Owner, ignoreShield: false);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_Circle : FSMStateBase, IParametrized<BaseEntity>
{
	[SerializeField]
	public float radius = 16f;

	[SerializeField]
	public LimitedTurnNavAgent.Speeds speed = LimitedTurnNavAgent.Speeds.Sprint;

	private bool clockWise = true;

	private float radiusOffset;

	public void SetParameter(BaseEntity target)
	{
		base.Senses.TrySetTarget(target);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		base.Agent.SetSpeed(speed);
		radiusOffset = Random.Range(-1f, 1f);
		clockWise = Random.value > 0.5f;
		base.Agent.shouldStopAtDestination = false;
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	protected virtual bool GetCircleOrigin(out Vector3 origin)
	{
		return base.Senses.FindTargetPosition(out origin);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		if (!GetCircleOrigin(out var origin))
		{
			return EFSMStateStatus.Failure;
		}
		float num = radius + radiusOffset;
		Quaternion val = Quaternion.LookRotation(((Component)Owner).transform.position - origin);
		float num2 = (((Quaternion)(ref val)).eulerAngles.y + 5f * (float)(clockWise ? 1 : (-1))) * (MathF.PI / 180f);
		Vector3 val2 = origin + new Vector3(Mathf.Sin(num2), 0f, Mathf.Cos(num2)) * num;
		val2.y = Mathf.Lerp(origin.y, ((Component)Owner).transform.position.y, Mathf.InverseLerp(0f, Vector3.Distance(origin, ((Component)Owner).transform.position), num));
		NavMeshHit val3 = default(NavMeshHit);
		if (NavMesh.Raycast(((Component)Owner).transform.position, val2, ref val3, -1))
		{
			return EFSMStateStatus.Failure;
		}
		if (!base.Agent.SetDestination(val2))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_ApproachFire : State_CircleDynamic
{
	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		base.Agent.deceleration.Value = 6f;
		distanceSpeedRange.x = 16f;
		return result;
	}

	public override void OnStateExit()
	{
		base.Agent.deceleration.Reset();
		base.OnStateExit();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_CircleDynamic : FSMStateBase, IParametrized<BaseEntity>
{
	[SerializeField]
	private LimitedTurnNavAgent.Speeds minSpeed;

	[SerializeField]
	private LimitedTurnNavAgent.Speeds maxSpeed = LimitedTurnNavAgent.Speeds.Sprint;

	[SerializeField]
	protected Vector2 distanceSpeedRange = new Vector2(10f, 50f);

	[SerializeField]
	private Vector2 angleRange = Vector2.op_Implicit(new Vector3(20f, 80f));

	[SerializeField]
	private Vector2 angleDurationRange = new Vector2(1f, 3f);

	[SerializeField]
	private Vector2 burstDurationRange = new Vector2(1f, 3f);

	[SerializeField]
	private Vector2 burstCooldownRange = new Vector2(1f, 10f);

	private Action _updateBurstAction;

	private Action _endBurstAction;

	private Action _updateAngleAction;

	private bool clockWise = true;

	private int burstSpeedIndexOffset;

	private float randomAngle;

	private Action UpdateBurstAction => UpdateBurst;

	private Action EndBurstAction => EndBurst;

	private Action UpdateAngleAction => UpdateAngle;

	public void SetParameter(BaseEntity target)
	{
		base.Senses.TrySetTarget(target);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		clockWise = Random.value > 0.5f;
		EndBurst();
		UpdateAngle();
		return base.OnStateEnter();
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		((FacepunchBehaviour)Owner).CancelInvoke(UpdateBurstAction);
		((FacepunchBehaviour)Owner).CancelInvoke(EndBurstAction);
		((FacepunchBehaviour)Owner).CancelInvoke(UpdateAngleAction);
		base.OnStateExit();
	}

	private void UpdateAngle()
	{
		randomAngle = Random.Range(angleRange.x, angleRange.y) * (float)(clockWise ? 1 : (-1));
		((FacepunchBehaviour)Owner).Invoke(UpdateAngleAction, Random.Range(angleDurationRange.x, angleDurationRange.y));
	}

	private void UpdateBurst()
	{
		burstSpeedIndexOffset = 2;
		clockWise = Random.value > 0.5f;
		float num = Random.Range(burstDurationRange.x, burstDurationRange.y);
		((FacepunchBehaviour)Owner).Invoke(EndBurstAction, num);
	}

	private void EndBurst()
	{
		burstSpeedIndexOffset = 0;
		float num = Random.Range(burstCooldownRange.x, burstCooldownRange.y);
		((FacepunchBehaviour)Owner).Invoke(UpdateBurstAction, num);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 position = ((Component)target).transform.position;
		float num = Vector3.Distance(((Component)Owner).transform.position, position);
		float normalizedDist = Mathf.InverseLerp(distanceSpeedRange.x, distanceSpeedRange.y, num);
		SetSpeed(target, num, normalizedDist);
		float currentDeviation = Mathx.RemapValClamped(num, distanceSpeedRange.x, distanceSpeedRange.y, randomAngle, 0f);
		base.Agent.currentDeviation = currentDeviation;
		Vector3 newDestination = position;
		if (!base.Agent.SetDestination(newDestination))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}

	protected virtual void SetSpeed(BaseEntity target, float distToTarget, float normalizedDist)
	{
		base.Agent.SetSpeedRatio(normalizedDist, minSpeed, maxSpeed, burstSpeedIndexOffset);
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public class State_MoveToLastReachablePointNearTarget : State_MoveToTarget
{
	private const float maxHorizontalDist = 7f;

	private const float maxVerticalDist = 2.7f;

	private const float traceVerticalOffset = 1f;

	private Vector3 reachableDestination;

	private LockState.LockHandle targetLock;

	public static bool CanJumpFromPosToPos(BaseEntity owner, Vector3 ownerLocation, Vector3 targetPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if (Mathf.Abs(targetPos.y - ownerLocation.y) > 2.7f)
		{
			return false;
		}
		if (Vector3.Distance(ownerLocation, targetPos) > 7f)
		{
			return false;
		}
		if (!owner.CanSee(ownerLocation + 1f * Vector3.up, targetPos + 1f * Vector3.up))
		{
			return false;
		}
		return true;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		if (!FindReachableLocation(out reachableDestination))
		{
			return EFSMStateStatus.Failure;
		}
		targetLock = base.Senses.LockCurrentTarget();
		base.Agent.deceleration.Value = 6f;
		return base.OnStateEnter();
	}

	private bool FindReachableLocation(out Vector3 location)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		location = default(Vector3);
		if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer basePlayer))
		{
			return false;
		}
		if (basePlayer.isMounted)
		{
			return false;
		}
		Vector3 position = ((Component)target).transform.position;
		if (Vector3.Distance(((Component)Owner).transform.position, position) > 50f)
		{
			return false;
		}
		Vector3? val = null;
		if (base.Agent.lastValidDestination.HasValue && Vector3.Distance(base.Agent.lastValidDestination.Value, position) <= 7f && base.Agent.SamplePosition(base.Agent.lastValidDestination.Value, out var sample, 7f) && CanJumpFromPosToPos(Owner, sample, position))
		{
			val = sample;
		}
		if (!val.HasValue && base.Agent.SamplePosition(position, out var sample2, 7f) && CanJumpFromPosToPos(Owner, sample2, position))
		{
			val = sample2;
		}
		if (!val.HasValue)
		{
			return false;
		}
		location = val.Value;
		return true;
	}

	protected override bool GetMoveDestination(out Vector3 destination)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		destination = reachableDestination;
		return true;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (Trans_TargetIsNearFire.Test(Owner, base.Senses))
		{
			float ratio = Mathx.RemapValClamped(Vector3.Distance(((Component)Owner).transform.position, reachableDestination), 4f, 16f, 0f, 1f);
			base.Agent.SetSpeedRatio(ratio, LimitedTurnNavAgent.Speeds.Sneak, LimitedTurnNavAgent.Speeds.Jog);
		}
		else
		{
			base.Agent.SetSpeed(speed);
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.OnStateExit();
		base.Senses.UnlockTarget(ref targetLock);
		base.Agent.deceleration.Reset();
	}
}


using System;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[Serializable]
public class State_AttackUnreachable : FSMStateBase
{
	private enum Phase
	{
		PreJump,
		Jump,
		Attack,
		JumpBack,
		PostJumpBack
	}

	public float preJumpEnd = 0.29f;

	public float jumpEnd = 0.395f;

	public float attackEnd = 0.67f;

	public float jumpBackEnd = 0.765f;

	public float postJumpBackEnd = 0.95f;

	private const float groundCheckDistance = 2f;

	private const float damage = 35f;

	private const float meleeAttackRange = 1.7f;

	private const DamageType damageType = DamageType.Bite;

	public RootMotionData animClip;

	private Vector3 startLocation;

	private Quaternion startRotation;

	private Vector3 destination;

	private float elapsedTime;

	private LockState.LockHandle targetLock;

	private LockState.LockHandle movementLock;

	private Phase phase;

	private float previousOffsetZ;

	private RootMotionPlayer.PlayServerState animState;

	public static bool SampleGroundPositionUnderTarget(LimitedTurnNavAgent agent, BasePlayer targetAsPlayer, out Vector3 projectedLocation)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		float radius = BasePlayer.GetRadius();
		RaycastHit hitInfo;
		bool result = agent.SampleGroundPositionWithPhysics(((Component)targetAsPlayer).transform.position, out hitInfo, 2f, radius);
		projectedLocation = ((RaycastHit)(ref hitInfo)).point;
		return result;
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTarget(out var target) || !(target is BasePlayer basePlayer))
		{
			return EFSMStateStatus.Failure;
		}
		destination = ((Component)target).transform.position;
		if (!basePlayer.IsOnGround() && !SampleGroundPositionUnderTarget(base.Agent, basePlayer, out destination))
		{
			return EFSMStateStatus.Failure;
		}
		if (!State_MoveToLastReachablePointNearTarget.CanJumpFromPosToPos(Owner, ((Component)Owner).transform.position, destination))
		{
			return EFSMStateStatus.Failure;
		}
		movementLock = base.Agent.Pause();
		elapsedTime = 0f;
		targetLock = base.Senses.LockCurrentTarget();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(animClip.inPlaceAnimation);
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = false;
		SetPhase(Phase.PreJump);
		return base.OnStateEnter();
	}

	private void SetPhase(Phase newPhase)
	{
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		phase = newPhase;
		previousOffsetZ = animClip.zMotionCurve.Evaluate(elapsedTime);
		if (phase == Phase.Jump)
		{
			if (base.Senses.FindTarget(out var target) && target is BasePlayer targetAsPlayer)
			{
				SampleGroundPositionUnderTarget(base.Agent, targetAsPlayer, out destination);
			}
			startLocation = ((Component)Owner).transform.position;
			((Component)Owner).transform.rotation = Quaternion.LookRotation(Vector3Ex.WithY(destination - ((Component)Owner).transform.position, 0f));
			base.Agent.IsJumping = true;
		}
		else if (phase == Phase.Attack)
		{
			startRotation = ((Component)Owner).transform.rotation;
			if (base.Senses.FindTarget(out var target2))
			{
				if (target2 is BaseCombatEntity baseCombatEntity && Vector3.Distance(((Component)Owner).transform.position, ((Component)baseCombatEntity).transform.position) <= 1.7f)
				{
					baseCombatEntity.OnAttacked(35f, DamageType.Bite, Owner, ignoreShield: false);
				}
				if (target2 is BasePlayer basePlayer && Vector3.Distance(((Component)Owner).transform.position, ((Component)basePlayer).transform.position) <= 1f)
				{
					basePlayer.DoPush(((Component)Owner).transform.forward * 10f + Vector3.up * 3f);
				}
			}
		}
		else if (phase == Phase.PostJumpBack)
		{
			base.Agent.IsJumping = false;
		}
	}

	private Vector3 ThreePointLerp(Vector3 a, Vector3 b, Vector3 c, float t)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Lerp(Vector3.Lerp(a, b, t), Vector3.Lerp(b, c, t), t);
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_031f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		elapsedTime += deltaTime;
		float num = elapsedTime / Mathf.Max(animClip.inPlaceAnimation.length, 0.001f);
		if (phase == Phase.PreJump)
		{
			Quaternion val = Quaternion.LookRotation(Vector3Ex.WithY(destination - ((Component)Owner).transform.position, 0f));
			((Component)Owner).transform.rotation = Quaternion.Slerp(((Component)Owner).transform.rotation, val, 2f * deltaTime);
			float num2 = animClip.zMotionCurve.Evaluate(elapsedTime);
			Vector3 val2 = ((Component)Owner).transform.forward * (num2 - previousOffsetZ);
			previousOffsetZ = num2;
			Transform transform = ((Component)Owner).transform;
			transform.position += val2;
			if (num >= preJumpEnd)
			{
				SetPhase(Phase.Jump);
			}
		}
		if (phase == Phase.Jump)
		{
			Vector3 b = (startLocation + destination) * 0.5f;
			b.y = Mathf.Max(startLocation.y, destination.y);
			float t = Mathx.RemapValClamped(num, preJumpEnd, jumpEnd, 0f, 1f);
			Vector3 position = ThreePointLerp(startLocation, b, destination, t);
			((Component)Owner).transform.position = position;
			if (num >= jumpEnd)
			{
				SetPhase(Phase.Attack);
			}
		}
		if (phase == Phase.Attack)
		{
			((Component)Owner).transform.rotation = startRotation * Quaternion.AngleAxis(animClip.yRotationCurve.Evaluate(elapsedTime), Vector3.up);
			if (num > attackEnd)
			{
				SetPhase(Phase.JumpBack);
			}
		}
		if (phase == Phase.JumpBack)
		{
			Vector3 b2 = (startLocation + destination) * 0.5f;
			b2.y = Mathf.Max(startLocation.y, destination.y);
			float t2 = Mathx.RemapValClamped(num, attackEnd, jumpBackEnd, 0f, 1f);
			Vector3 position2 = ThreePointLerp(destination, b2, startLocation, t2);
			((Component)Owner).transform.position = position2;
			((Component)Owner).transform.rotation = Quaternion.LookRotation(Vector3Ex.WithY(startLocation - destination, 0f));
			if (num >= jumpBackEnd)
			{
				SetPhase(Phase.PostJumpBack);
			}
		}
		if (phase == Phase.PostJumpBack)
		{
			float num3 = animClip.zMotionCurve.Evaluate(elapsedTime);
			Vector3 val3 = ((Component)Owner).transform.forward * (num3 - previousOffsetZ);
			previousOffsetZ = num3;
			Transform transform2 = ((Component)Owner).transform;
			transform2.position -= val3;
		}
		if (num >= postJumpBackEnd)
		{
			return EFSMStateStatus.Success;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
		((Behaviour)((Component)Owner).GetComponent<NavMeshAgent>()).enabled = true;
		base.Senses.UnlockTarget(ref targetLock);
		base.Agent.Unpause(ref movementLock);
		if (phase != Phase.PostJumpBack)
		{
			base.Agent.IsJumping = false;
		}
		base.OnStateExit();
	}
}


private enum Phase
{
	PreJump,
	Jump,
	Attack,
	JumpBack,
	PostJumpBack
}


public class AIArena2 : FacepunchBehaviour, IClientComponent
{
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class BlackboardComponent : EntityComponent<BaseEntity>, IServerComponent
{
	[SerializeField]
	private float factDuration = 30f;

	private Dictionary<string, int> addedFacts = new Dictionary<string, int>();

	private Dictionary<string, float> factExpirationTimes = new Dictionary<string, float>();

	public override void InitShared()
	{
		base.InitShared();
		((MonoBehaviour)this).InvokeRepeating("CleanExpiredFacts", Random.value, 1f);
	}

	public void Add(string value)
	{
		if (addedFacts.TryAdd(value, 1))
		{
			factExpirationTimes[value] = Time.time + factDuration;
		}
	}

	public void Increment(string value)
	{
		if (!addedFacts.TryGetValue(value, out var value2))
		{
			value2 = 0;
		}
		value2++;
		addedFacts[value] = value2;
		factExpirationTimes[value] = Time.time + factDuration;
	}

	public void Remove(string value)
	{
		if (addedFacts.Remove(value))
		{
			factExpirationTimes.Remove(value);
		}
	}

	public void Clear()
	{
		addedFacts.Clear();
		factExpirationTimes.Clear();
	}

	public bool Has(string value)
	{
		return addedFacts.ContainsKey(value);
	}

	public bool Count(string value, out int count)
	{
		return addedFacts.TryGetValue(value, out count);
	}

	public void CleanExpiredFacts()
	{
		TimeWarning val = TimeWarning.New("BlackboardComponent.CleanExpiredFacts", 0);
		try
		{
			float time = Time.time;
			PooledList<string> val2 = Pool.Get<PooledList<string>>();
			try
			{
				foreach (var (text2, _) in addedFacts)
				{
					if (factExpirationTimes[text2] < time)
					{
						((List<string>)(object)val2).Add(text2);
					}
				}
				foreach (string item in (List<string>)(object)val2)
				{
					Remove(item);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;

[Flags]
public enum EFSMStateStatus
{
	None = 0,
	Success = 1,
	Failure = 2
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(BlackboardComponent), typeof(NPCEncounterTimer))]
[SoftRequireComponent(typeof(LimitedTurnNavAgent), typeof(RootMotionPlayer), typeof(SenseComponent))]
public class FSMComponent : EntityComponent<BaseEntity>
{
	public class TickFSMWorkQueue : PersistentObjectWorkQueue<FSMComponent>
	{
		protected override void RunJob(FSMComponent component)
		{
			if (((PersistentObjectWorkQueue<FSMComponent>)this).ShouldAdd(component) && ((Behaviour)component).enabled)
			{
				component.Senses.Tick();
				((Component)component).GetComponent<NPCEncounterTimer>().Tick();
				component.Tick();
			}
		}

		protected override bool ShouldAdd(FSMComponent component)
		{
			if (base.ShouldAdd(component))
			{
				return component.baseEntity.IsValid();
			}
			return false;
		}
	}

	private bool isRunning;

	private SenseComponent _senses;

	public const float minRefreshIntervalSeconds = 0f;

	public const float maxRefreshIntervalSeconds = 0.5f;

	private double? _lastTickTime;

	private double nextRefreshTime;

	private const int maxStateChangesPerTick = 3;

	private List<FSMStateBase> sameFrameStateChangesHistory = new List<FSMStateBase>();

	private FSMStateBase pendingStateChange;

	public static TickFSMWorkQueue workQueue = new TickFSMWorkQueue();

	public const float frameBudgetMs = 0.5f;

	public FSMStateBase CurrentState { get; private set; }

	private SenseComponent Senses => _senses ?? (_senses = ((Component)base.baseEntity).GetComponent<SenseComponent>());

	private float RefreshInterval
	{
		get
		{
			if (!Senses.ShouldRefreshFast)
			{
				return 0.5f;
			}
			return 0f;
		}
	}

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	public void Run()
	{
		if (isRunning)
		{
			Debug.LogWarning((object)("[FSM] Trying to start a FSM that's already running on " + ((Object)((Component)base.baseEntity).gameObject).name));
			return;
		}
		isRunning = true;
		_lastTickTime = null;
		((PersistentObjectWorkQueue<FSMComponent>)workQueue).Add(this);
	}

	public void Stop()
	{
		if (!isRunning)
		{
			Debug.LogWarning((object)("[FSM] Trying to stop a FSM that is not running on " + ((Object)((Component)base.baseEntity).gameObject).name));
			return;
		}
		isRunning = false;
		((PersistentObjectWorkQueue<FSMComponent>)workQueue).Remove(this);
	}

	private void OnDestroy()
	{
		Stop();
	}

	public static void ShowDebugInfoAroundLocation(BasePlayer player, float radius = 100f)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (!player.IsValid())
		{
			return;
		}
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			BaseEntity.Query.Server.GetBrainsInSphere(((Component)player).transform.position, radius, (List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				FSMComponent component = ((Component)item).GetComponent<FSMComponent>();
				if (!((Object)(object)component == (Object)null) && component.CurrentState != null && component.isRunning)
				{
					player.ClientRPC(RpcTarget.Player("CL_ShowStateDebugInfo", player), ((Component)component.baseEntity).transform.position, component.CurrentState.Name);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected void ForceTickOnTheNextUpdate()
	{
		nextRefreshTime = 0.0;
	}

	public void Tick()
	{
		TimeWarning val = TimeWarning.New("FSMComponent.Tick", 0);
		try
		{
			if (Time.timeAsDouble < nextRefreshTime)
			{
				return;
			}
			nextRefreshTime = Time.timeAsDouble + (double)RefreshInterval;
			float deltaTime = (float)(Time.timeAsDouble - LastTickTime);
			LastTickTime = Time.timeAsDouble;
			sameFrameStateChangesHistory.Clear();
			if (pendingStateChange != null)
			{
				SetState(pendingStateChange);
			}
			else
			{
				if (CurrentState == null)
				{
					return;
				}
				TimeWarning val2 = TimeWarning.New("NormalTransitions", 0);
				try
				{
					PooledList<FSMStateBase> val3 = Pool.Get<PooledList<FSMStateBase>>();
					try
					{
						CurrentState.FindAncestry((List<FSMStateBase>)(object)val3);
						foreach (FSMStateBase item in (List<FSMStateBase>)(object)val3)
						{
							foreach (var (fSMTransitionBase, fSMStateBase) in item.transitions)
							{
								fSMTransitionBase.Init(base.baseEntity);
								if (fSMTransitionBase.Evaluate())
								{
									fSMStateBase.Owner = base.baseEntity;
									fSMTransitionBase.OnTransitionTaken(CurrentState, fSMStateBase);
									SetState(fSMStateBase);
									return;
								}
							}
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				EFSMStateStatus currentStateStatus = EFSMStateStatus.None;
				TimeWarning val4 = TimeWarning.New("StateTick", 0);
				try
				{
					TimeWarning val5 = TimeWarning.New(CurrentState.Name, 0);
					try
					{
						currentStateStatus = CurrentState.OnStateUpdate(deltaTime);
					}
					finally
					{
						((IDisposable)val5)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val4)?.Dispose();
				}
				EvaluateEndTransitions(currentStateStatus);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void EvaluateEndTransitions(EFSMStateStatus currentStateStatus)
	{
		TimeWarning val = TimeWarning.New("EndTransitions", 0);
		try
		{
			if (currentStateStatus == EFSMStateStatus.None)
			{
				return;
			}
			PooledList<FSMStateBase> val2 = Pool.Get<PooledList<FSMStateBase>>();
			try
			{
				CurrentState.FindAncestry((List<FSMStateBase>)(object)val2);
				foreach (FSMStateBase item in (List<FSMStateBase>)(object)val2)
				{
					foreach (var (fSMTransitionBase, fSMStateBase, eFSMStateStatus) in item.endTransitions)
					{
						if (eFSMStateStatus == (EFSMStateStatus.Success | EFSMStateStatus.Failure) || eFSMStateStatus == currentStateStatus)
						{
							bool flag = true;
							if (fSMTransitionBase != null)
							{
								fSMTransitionBase.Init(base.baseEntity);
								flag = fSMTransitionBase.Evaluate();
							}
							if (flag)
							{
								fSMStateBase.Owner = base.baseEntity;
								fSMTransitionBase?.OnTransitionTaken(CurrentState, fSMStateBase);
								SetState(fSMStateBase);
								ForceTickOnTheNextUpdate();
								return;
							}
						}
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void SetState(FSMStateBase newState)
	{
		TimeWarning val = TimeWarning.New("SetState", 0);
		try
		{
			pendingStateChange = null;
			sameFrameStateChangesHistory.Add(newState);
			if (sameFrameStateChangesHistory.Count > 3)
			{
				if (!AI.logIssues)
				{
					return;
				}
				StringBuilder stringBuilder = Pool.Get<StringBuilder>();
				stringBuilder.AppendFormat("[FSM] Possible endless recursion detected from {0} to {1} on {2}\n", CurrentState?.Name, newState.Name, base.baseEntity);
				foreach (FSMStateBase item in sameFrameStateChangesHistory)
				{
					stringBuilder.AppendFormat("{0} -> ", item.Name);
				}
				Debug.LogWarning((object)stringBuilder);
				pendingStateChange = newState;
				Pool.FreeUnmanaged(ref stringBuilder);
				return;
			}
			if (CurrentState != null)
			{
				TimeWarning val2 = TimeWarning.New("Transitions OnStateExit", 0);
				try
				{
					PooledList<FSMStateBase> val3 = Pool.Get<PooledList<FSMStateBase>>();
					try
					{
						CurrentState.FindAncestry((List<FSMStateBase>)(object)val3);
						foreach (FSMStateBase item2 in (List<FSMStateBase>)(object)val3)
						{
							foreach (var endTransition in item2.endTransitions)
							{
								endTransition.transition?.OnStateExit();
							}
							foreach (var transition in item2.transitions)
							{
								transition.transition.OnStateExit();
							}
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				TimeWarning val4 = TimeWarning.New("OnStateExit", 0);
				try
				{
					TimeWarning val5 = TimeWarning.New(CurrentState.Name, 0);
					try
					{
						CurrentState.OnStateExit();
					}
					finally
					{
						((IDisposable)val5)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val4)?.Dispose();
				}
			}
			CurrentState = newState;
			TimeWarning val6 = TimeWarning.New("Transitions OnStateEnter", 0);
			try
			{
				PooledList<FSMStateBase> val7 = Pool.Get<PooledList<FSMStateBase>>();
				try
				{
					CurrentState.FindAncestry((List<FSMStateBase>)(object)val7);
					foreach (FSMStateBase item3 in (List<FSMStateBase>)(object)val7)
					{
						foreach (var endTransition2 in item3.endTransitions)
						{
							endTransition2.transition?.OnStateEnter();
						}
						foreach (var transition2 in item3.transitions)
						{
							transition2.transition.OnStateEnter();
						}
					}
				}
				finally
				{
					((IDisposable)val7)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val6)?.Dispose();
			}
			TimeWarning val8 = TimeWarning.New("OnStateEnter", 0);
			try
			{
				TimeWarning val9 = TimeWarning.New(CurrentState.Name, 0);
				try
				{
					EFSMStateStatus currentStateStatus = CurrentState.OnStateEnter();
					EvaluateEndTransitions(currentStateStatus);
				}
				finally
				{
					((IDisposable)val9)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val8)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using UnityEngine;

public class TickFSMWorkQueue : PersistentObjectWorkQueue<FSMComponent>
{
	protected override void RunJob(FSMComponent component)
	{
		if (((PersistentObjectWorkQueue<FSMComponent>)this).ShouldAdd(component) && ((Behaviour)component).enabled)
		{
			component.Senses.Tick();
			((Component)component).GetComponent<NPCEncounterTimer>().Tick();
			component.Tick();
		}
	}

	protected override bool ShouldAdd(FSMComponent component)
	{
		if (base.ShouldAdd(component))
		{
			return component.baseEntity.IsValid();
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Rust.Ai.Gen2;
using UnityEngine;

public abstract class FSMStateBase
{
	[NonSerialized]
	public BaseEntity Owner;

	[SerializeField]
	private string _Name;

	[NonSerialized]
	public FSMStateBase parent;

	public List<(FSMTransitionBase transition, FSMStateBase dstState)> transitions = new List<(FSMTransitionBase, FSMStateBase)>();

	public List<(FSMTransitionBase transition, FSMStateBase dstState, EFSMStateStatus status)> endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();

	private SenseComponent _senses;

	private LimitedTurnNavAgent _agent;

	private RootMotionPlayer _animPlayer;

	private BlackboardComponent _blackboard;

	public string Name
	{
		get
		{
			if (string.IsNullOrEmpty(_Name))
			{
				_Name = GetType().Name.Replace("State_", "");
			}
			return _Name;
		}
		set
		{
			_Name = value;
		}
	}

	protected SenseComponent Senses => _senses ?? (_senses = ((Component)Owner).GetComponent<SenseComponent>());

	protected LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)Owner).GetComponent<LimitedTurnNavAgent>());

	protected RootMotionPlayer AnimPlayer => _animPlayer ?? (_animPlayer = ((Component)Owner).GetComponent<RootMotionPlayer>());

	protected BlackboardComponent Blackboard => _blackboard ?? (_blackboard = ((Component)Owner).GetComponent<BlackboardComponent>());

	public virtual EFSMStateStatus OnStateEnter()
	{
		return EFSMStateStatus.None;
	}

	public virtual EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		return EFSMStateStatus.None;
	}

	public virtual void OnStateExit()
	{
	}

	protected T GetRootFSM<T>() where T : FSMComponent
	{
		return ((Component)Owner).GetComponent<T>();
	}

	public virtual FSMStateBase Clone()
	{
		FSMStateBase obj = (FSMStateBase)MemberwiseClone();
		obj.transitions = new List<(FSMTransitionBase, FSMStateBase)>();
		obj.endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();
		return obj;
	}

	public void FindAncestry(List<FSMStateBase> ancestry)
	{
		TimeWarning val = TimeWarning.New("FindAncestry", 0);
		try
		{
			FindAncestryRecursive(ancestry);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void FindAncestryRecursive(List<FSMStateBase> ancestry)
	{
		parent?.FindAncestryRecursive(ancestry);
		ancestry.Add(this);
	}

	public FSMStateBase AddEndTransition(FSMStateBase dstState, FSMTransitionBase transition = null)
	{
		if (endTransitions == null)
		{
			endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();
		}
		endTransitions.Add((transition, dstState, EFSMStateStatus.Success | EFSMStateStatus.Failure));
		return this;
	}

	public FSMStateBase AddFailureTransition(FSMStateBase dstState)
	{
		if (endTransitions == null)
		{
			endTransitions = new List<(FSMTransitionBase, FSMStateBase, EFSMStateStatus)>();
		}
		endTransitions.Add((null, dstState, EFSMStateStatus.Failure));
		return this;
	}

	public FSMStateBase AddTickTransition(FSMStateBase dstState, FSMTransitionBase transition)
	{
		if (transitions == null)
		{
			transitions = new List<(FSMTransitionBase, FSMStateBase)>();
		}
		transitions.Add((transition, dstState));
		return this;
	}

	public FSMStateBase AddTickBranchingTrans(FSMStateBase dstState1, FSMTransitionBase sharedTransition, FSMStateBase dstState2, FSMTransitionBase dstState2Trans)
	{
		if (transitions == null)
		{
			transitions = new List<(FSMTransitionBase, FSMStateBase)>();
		}
		transitions.Add((new Trans_And { sharedTransition, dstState2Trans }, dstState2));
		transitions.Add((sharedTransition, dstState1));
		return this;
	}

	public FSMStateBase AddChild(FSMStateBase child)
	{
		child.parent = this;
		return child;
	}

	public FSMStateBase AddChildren(FSMStateBase child1, FSMStateBase child2 = null, FSMStateBase child3 = null, FSMStateBase child4 = null, FSMStateBase child5 = null, FSMStateBase child6 = null, FSMStateBase child7 = null, FSMStateBase child8 = null, FSMStateBase child9 = null, FSMStateBase child10 = null)
	{
		AddChild(child1);
		if (child2 != null)
		{
			AddChild(child2);
		}
		if (child3 != null)
		{
			AddChild(child3);
		}
		if (child4 != null)
		{
			AddChild(child4);
		}
		if (child5 != null)
		{
			AddChild(child5);
		}
		if (child6 != null)
		{
			AddChild(child6);
		}
		if (child7 != null)
		{
			AddChild(child7);
		}
		if (child8 != null)
		{
			AddChild(child8);
		}
		if (child9 != null)
		{
			AddChild(child9);
		}
		if (child10 != null)
		{
			AddChild(child10);
		}
		return this;
	}

	public static FSMStateBase operator +(FSMStateBase parent, FSMStateBase child)
	{
		parent.AddChild(child);
		return parent;
	}
}


public interface IParametrized<T>
{
	void SetParameter(T parameter);
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class State_Nothing : FSMStateBase
{
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_MoveToTarget : FSMStateBase, IParametrized<BaseEntity>
{
	[SerializeField]
	public LimitedTurnNavAgent.Speeds speed = LimitedTurnNavAgent.Speeds.FullSprint;

	[SerializeField]
	public bool succeedWhenDestinationIsReached = true;

	[SerializeField]
	public bool stopAtDestination = true;

	[SerializeField]
	public float accelerationOverride;

	[SerializeField]
	public float decelerationOverride;

	public void SetParameter(BaseEntity target)
	{
		base.Senses.TrySetTarget(target);
	}

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		base.Agent.ResetPath();
		base.Agent.desiredSwimDepth.Reset();
		base.Agent.shouldStopAtDestination = stopAtDestination;
		base.Agent.SetSpeed(speed);
		if (accelerationOverride > 0f)
		{
			base.Agent.acceleration.Value = accelerationOverride;
		}
		if (decelerationOverride > 0f)
		{
			base.Agent.deceleration.Value = decelerationOverride;
		}
		if (!GetMoveDestination(out var destination) || !base.Agent.SetDestination(destination))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Agent.IsFollowingPath && succeedWhenDestinationIsReached)
		{
			return EFSMStateStatus.Success;
		}
		if (!GetMoveDestination(out var destination) || !base.Agent.SetDestination(destination))
		{
			return EFSMStateStatus.Failure;
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		base.Agent.ResetPath();
		base.OnStateExit();
	}

	protected virtual bool GetMoveDestination(out Vector3 destination)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Senses.FindTargetPosition(out var targetPosition))
		{
			destination = Vector3.zero;
			return false;
		}
		destination = targetPosition;
		return true;
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

public abstract class State_PlayAnimationBase : FSMStateBase
{
	[SerializeField]
	public bool FaceTarget;

	protected RootMotionPlayer.PlayServerState animState;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (FaceTarget && base.Senses.FindTargetPosition(out var targetPosition))
		{
			Vector3 val = targetPosition - ((Component)Owner).transform.position;
			val.y = 0f;
			((Component)Owner).transform.rotation = Quaternion.LookRotation(val);
		}
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!animState.isPlaying)
		{
			return EFSMStateStatus.Success;
		}
		return EFSMStateStatus.None;
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimation : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip Animation;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
		return result;
	}

	protected virtual AnimationClip GetAnimation()
	{
		return Animation;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimationRM : State_PlayAnimationBase
{
	[SerializeField]
	public RootMotionData Animation;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(GetAnimation());
		return result;
	}

	protected virtual RootMotionData GetAnimation()
	{
		return Animation;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayRandomAnimation : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip[] animations;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(animations.GetRandom());
		return result;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimLoop : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip Start;

	[SerializeField]
	public AnimationClip Loop;

	[SerializeField]
	public AnimationClip Stop;

	[SerializeField]
	public float MinDuration = 7f;

	[SerializeField]
	public float MaxDuration = 14f;

	private float duration;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		duration = Random.Range(MinDuration, MaxDuration);
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Start);
		return result;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (duration > 0f)
		{
			duration -= deltaTime;
			if (duration <= 0f)
			{
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Stop);
			}
			else if (!animState.isPlaying)
			{
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Loop);
			}
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using System.Linq;
using Rust.Ai.Gen2;
using UnityEngine;

public abstract class FSMTransitionBase
{
	[SerializeField]
	public bool Inverted;

	[NonSerialized]
	public BaseEntity Owner;

	private SenseComponent _senses;

	private LimitedTurnNavAgent _agent;

	protected SenseComponent Senses => _senses ?? (_senses = ((Component)Owner).GetComponent<SenseComponent>());

	protected LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)Owner).GetComponent<LimitedTurnNavAgent>());

	public virtual void Init(BaseEntity owner)
	{
		Owner = owner;
	}

	public virtual void OnStateEnter()
	{
	}

	public virtual void OnStateExit()
	{
	}

	public virtual void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
	}

	public bool Evaluate()
	{
		if (!Inverted)
		{
			return EvaluateInternal();
		}
		return !EvaluateInternal();
	}

	protected virtual bool EvaluateInternal()
	{
		return false;
	}

	public virtual string GetName()
	{
		return (Inverted ? "!" : "") + GetGenericTypeName(GetType());
	}

	protected static string GetGenericTypeName(Type type)
	{
		if (type.IsGenericType)
		{
			string name = type.Name;
			return (name[..name.IndexOf('`')] + "<" + string.Join(", ", type.GetGenericArguments().Select(GetGenericTypeName)) + ">").Replace("Trans_", "");
		}
		return type.Name.Replace("Trans_", "");
	}

	public virtual FSMTransitionBase Clone()
	{
		return (FSMTransitionBase)MemberwiseClone();
	}

	public static Trans_And operator &(FSMTransitionBase lhs, FSMTransitionBase rhs)
	{
		return new Trans_And { lhs, rhs };
	}

	public static Trans_Or operator |(FSMTransitionBase lhs, FSMTransitionBase rhs)
	{
		return new Trans_Or { lhs, rhs };
	}

	public static FSMTransitionBase operator ~(FSMTransitionBase instance)
	{
		instance.Inverted = !instance.Inverted;
		return instance;
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_AlwaysValid : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		return true;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public abstract class Trans_Composite : FSMTransitionBase, IEnumerable<FSMTransitionBase>, IEnumerable
{
	[SerializeField]
	protected List<FSMTransitionBase> transitions = new List<FSMTransitionBase>();

	public IEnumerator<FSMTransitionBase> GetEnumerator()
	{
		return transitions.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public void Add(FSMTransitionBase transition)
	{
		transitions.Add(transition);
	}

	public Trans_Composite()
	{
	}

	public override void Init(BaseEntity owner)
	{
		base.Init(owner);
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.Init(owner);
		}
	}

	public Trans_Composite(List<FSMTransitionBase> transitions)
	{
		this.transitions = transitions;
	}

	public override void OnStateEnter()
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnStateEnter();
		}
	}

	public override void OnStateExit()
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnStateExit();
		}
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnTransitionTaken(from, to);
		}
	}

	protected virtual string GetNameSeparator()
	{
		return " ";
	}

	public override string GetName()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("(");
		for (int i = 0; i < transitions.Count; i++)
		{
			stringBuilder.Append(transitions[i].GetName());
			if (i < transitions.Count - 1)
			{
				stringBuilder.Append(" ");
				stringBuilder.Append(GetNameSeparator());
				stringBuilder.Append(" ");
			}
		}
		stringBuilder.Append(" )");
		return stringBuilder.ToString();
	}

	public override FSMTransitionBase Clone()
	{
		Trans_Composite obj = base.Clone() as Trans_Composite;
		obj.transitions = new List<FSMTransitionBase>();
		return obj;
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_And : Trans_Composite
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_And", 0);
		try
		{
			foreach (FSMTransitionBase transition in transitions)
			{
				if (!transition.Evaluate())
				{
					return false;
				}
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override string GetNameSeparator()
	{
		return "&&";
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_Or : Trans_Composite
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Or", 0);
		try
		{
			foreach (FSMTransitionBase transition in transitions)
			{
				if (transition.Evaluate())
				{
					return true;
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override string GetNameSeparator()
	{
		return "||";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

public class Trans_Lambda : FSMTransitionBase
{
	private Func<BaseEntity, bool> EvaluateFunc;

	public Trans_Lambda(Func<BaseEntity, bool> evaluateFunc)
	{
		EvaluateFunc = evaluateFunc;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Lambda", 0);
		try
		{
			if ((Object)(object)Owner == (Object)null)
			{
				return false;
			}
			return EvaluateFunc(Owner);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_RandomChance : FSMTransitionBase
{
	[SerializeField]
	public float Chance = 0.5f;

	private bool Triggered;

	public override void OnStateEnter()
	{
		Triggered = Random.value <= Chance;
	}

	public override void OnStateExit()
	{
		Triggered = false;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_RandomChance", 0);
		try
		{
			return Triggered;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_Cooldown : FSMTransitionBase
{
	[SerializeField]
	public float cooldown = 20f;

	private double? lastTakenTime;

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		base.OnTransitionTaken(from, to);
		lastTakenTime = Time.timeAsDouble;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Cooldown", 0);
		try
		{
			return !lastTakenTime.HasValue || Time.timeAsDouble - lastTakenTime.Value >= (double)cooldown;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {cooldown}s";
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_Triggerable : FSMTransitionBase
{
	protected bool Triggered { get; private set; }

	public void Trigger()
	{
		Triggered = true;
	}

	public override void OnStateEnter()
	{
		Triggered = false;
	}

	public override void OnStateExit()
	{
		Triggered = false;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Triggerable", 0);
		try
		{
			return Triggered;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using Rust.Ai.Gen2;

public class Trans_Triggerable<T> : Trans_Triggerable
{
	private T Parameter;

	public void Trigger(T parameter)
	{
		Parameter = parameter;
		Trigger();
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		if (base.Triggered && to is IParametrized<T> parametrized)
		{
			parametrized.SetParameter(Parameter);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_ElapsedTime : FSMTransitionBase
{
	[SerializeField]
	public double Duration = 6.0;

	private double startTime;

	public override void OnStateEnter()
	{
		startTime = Time.timeAsDouble;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_ElapsedTime", 0);
		try
		{
			return Time.timeAsDouble >= startTime + Duration;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {Duration}s";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_ElapsedTimeRandomized : Trans_ElapsedTime
{
	[SerializeField]
	public double MinDuration = 2.0;

	[SerializeField]
	public double MaxDuration = 6.0;

	public override void OnStateEnter()
	{
		Duration = MinDuration + (double)Random.value * (MaxDuration - MinDuration);
		base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_TargetInRange : FSMTransitionBase
{
	[SerializeField]
	public float Range = 4f;

	[SerializeField]
	public float TimeToPredict;

	protected override bool EvaluateInternal()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TargetInRange", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			Vector3 val2 = ((Component)target).transform.position;
			if (TimeToPredict > 0f && target.ToNonNpcPlayer(out var player))
			{
				Vector3 inferedVelocity = player.inferedVelocity;
				inferedVelocity = Vector3.ProjectOnPlane(inferedVelocity, ((Component)Owner).transform.right);
				val2 += inferedVelocity * TimeToPredict;
			}
			return Vector3.Distance(val2, ((Component)Owner).transform.position) <= Range;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return string.Format("{0} {1}{2}m", base.GetName(), Inverted ? ">=" : "<", Range);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_TargetInFront : FSMTransitionBase
{
	[SerializeField]
	public float Angle = 90f;

	protected override bool EvaluateInternal()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TargetInFront", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			Vector3 val2 = targetPosition - ((Component)Owner).transform.position;
			return Vector3.Angle(((Component)Owner).transform.forward, val2) < Angle;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return string.Format("{0} {1}{2}", base.GetName(), Inverted ? ">=" : "<", Angle);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_TargetIsNearFire : FSMTransitionBase
{
	public bool onlySeeFireWhenClose;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetIsNearFire", 0);
		try
		{
			return Test(Owner, base.Senses, onlySeeFireWhenClose);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool Test(BaseEntity owner, SenseComponent senses, bool onlySeeFireWhenClose = false)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Test", 0);
		try
		{
			if (!senses.FindTarget(out var target))
			{
				return false;
			}
			if (target.ToNonNpcPlayer(out var player) && SingletonComponent<NpcNoiseManager>.Instance.HasPlayerSpokenNear(owner, player))
			{
				return true;
			}
			if (!senses.FindFire(out var fire))
			{
				return false;
			}
			bool flag = Vector3.Distance(((Component)target).transform.position, ((Component)fire).transform.position) < 16f;
			bool flag2 = Vector3.Distance(((Component)owner).transform.position, ((Component)target).transform.position) < 18f;
			if (onlySeeFireWhenClose)
			{
				return flag && flag2;
			}
			return flag;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_HasTarget : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasTarget", 0);
		try
		{
			BaseEntity target;
			return base.Senses.FindTarget(out target);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

internal abstract class FSMSlowTransitionBase : FSMTransitionBase
{
	private bool cachedEvalResult;

	private double? lastEvalTime;

	private double cacheLifeTime = 1.0;

	protected sealed override bool EvaluateInternal()
	{
		double timeAsDouble = Time.timeAsDouble;
		if (!lastEvalTime.HasValue || timeAsDouble - lastEvalTime.Value > cacheLifeTime)
		{
			cachedEvalResult = EvaluateAtInterval();
			lastEvalTime = timeAsDouble;
		}
		return cachedEvalResult;
	}

	protected abstract bool EvaluateAtInterval();
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_CanReachTarget_Slow : FSMSlowTransitionBase
{
	protected override bool EvaluateAtInterval()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_CanReachTarget_Slow", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			return base.Agent.CanReach(targetPosition);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsTargetOnNavmesh_Slow : FSMSlowTransitionBase
{
	protected override bool EvaluateAtInterval()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_IsTargetOnNavmesh_Slow", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			Vector3 sample;
			return base.Agent.SamplePosition(targetPosition, out sample, 2f);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsHealthBelowPercentage : FSMTransitionBase
{
	[SerializeField]
	public float percentage = 0.25f;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsHealthBelowPercentage", 0);
		try
		{
			return Owner is BaseCombatEntity baseCombatEntity && baseCombatEntity.healthFraction < percentage;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} <{percentage * 100f}%";
	}
}


using System;
using ConVar;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_IsNavmeshReady : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsNavmeshReady", 0);
		try
		{
			return AI.move && base.Agent.IsNavmeshReady;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_InitialAlliesNotFighting : FSMTransitionBase
{
	[SerializeField]
	public float MinAllyHealthFraction = 0.3f;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_InitialAlliesNotFighting", 0);
		try
		{
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				base.Senses.GetInitialAllies((List<BaseEntity>)(object)val2);
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (!((Component)item).GetComponent<SenseComponent>().FindTarget(out var _) && (!(item is BaseCombatEntity baseCombatEntity) || !(baseCombatEntity.healthFraction < MinAllyHealthFraction)))
					{
						return true;
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_HasBlackboardBool : FSMTransitionBase
{
	[SerializeField]
	public string Key;

	private BlackboardComponent _blackboard;

	private BlackboardComponent Blackboard => _blackboard ?? (_blackboard = ((Component)Owner).GetComponent<BlackboardComponent>());

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasBlackboardBool", 0);
		try
		{
			return Blackboard.Has(Key);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return base.GetName() + " " + Key;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_BlackboardCounterGte : FSMTransitionBase
{
	[SerializeField]
	public string Key;

	[SerializeField]
	public int MinValue;

	private BlackboardComponent _blackboard;

	private BlackboardComponent Blackboard => _blackboard ?? (_blackboard = ((Component)Owner).GetComponent<BlackboardComponent>());

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasBlackboardBool", 0);
		try
		{
			if (!Blackboard.Count(Key, out var count))
			{
				return false;
			}
			return count >= MinValue;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {Key} >= {MinValue}";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_NoiseNearby : FSMTransitionBase
{
	[SerializeField]
	public float distance = 7f;

	protected override bool EvaluateInternal()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_NoiseNearby", 0);
		try
		{
			NpcNoiseEvent currentNoise = base.Senses.currentNoise;
			return currentNoise != null && Vector3.Distance(((Component)Owner).transform.position, currentNoise.Position) < distance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		base.OnTransitionTaken(from, to);
		if (base.Senses.currentNoise != null)
		{
			if (to is IParametrized<NpcNoiseEvent> parametrized)
			{
				parametrized.SetParameter(base.Senses.currentNoise);
			}
			base.Senses.ConsumeCurrentNoise();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} <{distance}m";
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_SeesFood : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_SeesFood", 0);
		try
		{
			BaseEntity food;
			return base.Senses.FindFood(out food);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_IsTargetInWater : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsTargetInWater", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			if (!target.ToNonNpcPlayer(out var _))
			{
				return false;
			}
			if (!base.Senses.GetVisibilityStatus(target, out var status))
			{
				return false;
			}
			return status.isInWaterCached;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_IsSwimming : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsSwimming", 0);
		try
		{
			return base.Agent.canSwim && base.Agent.IsSwimming;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsInWaterSlow : FSMSlowTransitionBase
{
	protected override bool EvaluateAtInterval()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_IsInWaterSlow", 0);
		try
		{
			if (base.Agent.canSwim)
			{
				return base.Agent.IsSwimming;
			}
			return WaterLevel.GetWaterDepth(((Component)Owner).transform.position, waves: false, volumes: false) >= 0.3f;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_TargetIsInSafeZone : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetIsInSafeZone", 0);
		try
		{
			BaseEntity target;
			return base.Senses.FindTarget(out target) && target.InSafeZone();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Diagnostics;
using ConVar;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Events;

[SoftRequireComponent(typeof(NavMeshAgent))]
public class LimitedTurnNavAgent : EntityComponent<BaseEntity>
{
	public enum Speeds
	{
		Sneak,
		Walk,
		Jog,
		Run,
		Sprint,
		FullSprint
	}

	[SerializeField]
	private NavMeshAgent agent;

	[SerializeField]
	[Header("Speed")]
	private float sneakSpeed = 0.6f;

	[SerializeField]
	private float walkSpeed = 0.89f;

	[SerializeField]
	private float jogSpeed = 2.45f;

	[SerializeField]
	private float runSpeed = 4.4f;

	[SerializeField]
	private float sprintSpeed = 6f;

	[SerializeField]
	private float fullSprintSpeed = 9f;

	[SerializeField]
	public bool canSwim;

	[SerializeField]
	private float swimSpeed = 0.6f;

	[SerializeField]
	private float swimSprintSpeed = 0.89f;

	public ResettableFloat desiredSwimDepth = new ResettableFloat(0.7f);

	public ResettableFloat acceleration = new ResettableFloat(10f);

	public ResettableFloat deceleration = new ResettableFloat(2f);

	[SerializeField]
	private float maxTurnRadius = 2f;

	[SerializeField]
	private Enum preferedTopology = (Enum)537002081;

	[SerializeField]
	private Enum preferedBiome = (Enum)15;

	public const BaseEntity.Flags FLAG_IS_SWIMMING = BaseEntity.Flags.Reserved1;

	public const BaseEntity.Flags FLAG_IS_JUMPING = BaseEntity.Flags.Reserved2;

	private const float emergencyDeceleration = 10f;

	private static NavMeshPath path;

	[NonSerialized]
	public UnityEvent onPathFailed = new UnityEvent();

	private LockState movementLock = new LockState();

	private bool isNavMeshReady;

	private int? lastFrameCall;

	private static ListHashSet<LimitedTurnNavAgent> steeringComponents = new ListHashSet<LimitedTurnNavAgent>();

	[NonSerialized]
	public float currentDeviation;

	[NonSerialized]
	public bool shouldStopAtDestination = true;

	private float cachedPathLength;

	private Vector3? previousLocalPosition;

	private float curSpeed;

	private float desiredSpeed;

	public bool IsSwimming
	{
		get
		{
			return base.baseEntity.flags.HasFlag(BaseEntity.Flags.Reserved1);
		}
		private set
		{
			base.baseEntity.SetFlag(BaseEntity.Flags.Reserved1, value);
		}
	}

	public bool IsJumping
	{
		get
		{
			return base.baseEntity.flags.HasFlag(BaseEntity.Flags.Reserved2);
		}
		set
		{
			base.baseEntity.SetFlag(BaseEntity.Flags.Reserved2, value);
		}
	}

	public Vector3 NavPosition => agent.nextPosition;

	public bool isPaused => movementLock.IsLocked;

	public bool IsNavmeshReady => isNavMeshReady;

	public Vector3? lastValidDestination { get; private set; }

	public float RemainingDistance => agent.remainingDistance;

	public bool IsFollowingPath
	{
		get
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			if (agent.hasPath)
			{
				return agent.remainingDistance > (shouldStopAtDestination ? ((Bounds)(ref base.baseEntity.bounds)).extents.z : maxTurnRadius);
			}
			return false;
		}
	}

	public LockState.LockHandle Pause()
	{
		if (!movementLock.IsLocked)
		{
			OnPaused();
		}
		return movementLock.AddLock();
	}

	public bool Unpause(ref LockState.LockHandle handle)
	{
		bool result = movementLock.RemoveLock(ref handle);
		if (!movementLock.IsLocked)
		{
			OnUnpaused();
		}
		return result;
	}

	public void Move(Vector3 offset)
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:Move", 0);
		try
		{
			if (AI.logIssues && lastFrameCall.HasValue && lastFrameCall == Time.frameCount)
			{
				StackTrace stackTrace = new StackTrace();
				Debug.LogError((object)("Move called multiple times in the same frame\n" + stackTrace.ToString()));
			}
			agent.Move(offset);
			lastFrameCall = Time.frameCount;
			if (canSwim)
			{
				Vector3 nextPosition = agent.nextPosition;
				WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(nextPosition, waves: false, volumes: false);
				IsSwimming = waterInfo.currentDepth > desiredSwimDepth.Value;
				if (IsSwimming)
				{
					nextPosition.y = ((Component)base.baseEntity).transform.position.y;
					nextPosition.y = Mathf.MoveTowards(nextPosition.y, waterInfo.surfaceLevel - desiredSwimDepth.Value, 1f * Time.deltaTime);
					nextPosition.y = Mathf.Max(nextPosition.y, waterInfo.terrainHeight);
					((Component)base.baseEntity).transform.position = nextPosition;
				}
				else
				{
					((Component)base.baseEntity).transform.position = agent.nextPosition;
				}
			}
			else
			{
				IsSwimming = false;
				((Component)base.baseEntity).transform.position = agent.nextPosition;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ResetPath()
	{
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:ResetPath", 0);
		try
		{
			shouldStopAtDestination = true;
			acceleration.Reset();
			deceleration.Reset();
			currentDeviation = 0f;
			SetSpeed(0f);
			if (agent.hasPath)
			{
				agent.ResetPath();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool CanReach(Vector3 location, bool resetPathOnFailure = false)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Invalid comparison between Unknown and I4
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:CanReach", 0);
		try
		{
			if (!IsPositionOnNavmesh(location, out var sample))
			{
				FailPath(location, null, resetPathOnFailure);
				return false;
			}
			if (!CalculatePathCustom(sample, path))
			{
				FailPath(sample, path, resetPathOnFailure);
				return false;
			}
			bool flag = (int)path.status == 0;
			if (!flag)
			{
				FailPath(sample, path, resetPathOnFailure);
			}
			else if (flag && resetPathOnFailure)
			{
				lastValidDestination = path.GetDestination();
			}
			return flag;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool SetDestination(Vector3 newDestination, bool resetPathOnFailure = false)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:SetDestination", 0);
		try
		{
			if (shouldStopAtDestination && agent.hasPath && Vector3.Distance(agent.destination, newDestination) < 1f)
			{
				return true;
			}
			if (!CalculatePathCustom(newDestination, path))
			{
				FailPath(newDestination, path, resetPathOnFailure);
				return false;
			}
			if ((int)path.status != 0)
			{
				FailPath(newDestination, path, resetPathOnFailure);
				return false;
			}
			SetPath(path);
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void InitShared()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Expected O, but got Unknown
		base.InitShared();
		if (path == null)
		{
			path = new NavMeshPath();
		}
	}

	private void OnPaused()
	{
		if (((Behaviour)agent).enabled && agent.isOnNavMesh)
		{
			ResetPath();
		}
	}

	private void OnUnpaused()
	{
	}

	private void SetPath(NavMeshPath newPath)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:SetPath", 0);
		try
		{
			if (agent.path != newPath)
			{
				agent.SetPath(newPath);
			}
			cachedPathLength = newPath.GetPathLength();
			lastValidDestination = newPath.GetDestination();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ShowFailedPath(Vector3? destination, NavMeshPath failedPath)
	{
	}

	private void FailPath(Vector3? destination, NavMeshPath failedPath = null, bool resetPathOnFailure = false)
	{
		ShowFailedPath(destination, failedPath);
		if (resetPathOnFailure)
		{
			onPathFailed.Invoke();
			ResetPath();
		}
	}

	private float GetSpeedForGait(Speeds gait)
	{
		return gait switch
		{
			Speeds.Sneak => sneakSpeed, 
			Speeds.Walk => walkSpeed, 
			Speeds.Jog => jogSpeed, 
			Speeds.Run => runSpeed, 
			Speeds.Sprint => sprintSpeed, 
			Speeds.FullSprint => fullSprintSpeed, 
			_ => walkSpeed, 
		};
	}

	public void SetSpeed(Speeds gait)
	{
		SetSpeed(GetSpeedForGait(gait));
	}

	public bool IsSpeedGTE(Speeds minGait)
	{
		return curSpeed >= GetSpeedForGait(minGait) - 0.01f;
	}

	public void SetSpeed(float speed)
	{
		desiredSpeed = speed;
	}

	public void SetSpeedRatio(float ratio, Speeds minSpeed = Speeds.Sneak, Speeds maxSpeed = Speeds.Sprint, int offset = 0)
	{
		int num = Mathf.FloorToInt(Mathf.Lerp((float)minSpeed, (float)maxSpeed, ratio));
		num = Mathf.Clamp(num + offset, (int)minSpeed, (int)maxSpeed);
		SetSpeed((Speeds)num);
	}

	private void OnEnable()
	{
		steeringComponents.TryAdd(this);
	}

	private void OnDisable()
	{
		steeringComponents.Remove(this);
	}

	public static void TickSteering()
	{
		for (int num = steeringComponents.Count - 1; num >= 0; num--)
		{
			LimitedTurnNavAgent limitedTurnNavAgent = steeringComponents[num];
			if (limitedTurnNavAgent.IsUnityNull() || !limitedTurnNavAgent.baseEntity.IsValid())
			{
				steeringComponents.RemoveAt(num);
			}
			else
			{
				limitedTurnNavAgent.Tick();
			}
		}
	}

	private void Tick()
	{
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:Tick", 0);
		try
		{
			try
			{
				if (!AI.move)
				{
					return;
				}
				if (!isNavMeshReady)
				{
					isNavMeshReady = (Object)(object)agent != (Object)null && ((Behaviour)agent).enabled && agent.isOnNavMesh;
					if (!isNavMeshReady)
					{
						return;
					}
					agent.updateRotation = false;
					agent.updatePosition = false;
					agent.updateUpAxis = false;
					agent.isStopped = true;
				}
				if (movementLock.IsLocked)
				{
					if (previousLocalPosition.HasValue)
					{
						Vector3 val2 = ((Component)base.baseEntity).transform.localPosition - previousLocalPosition.Value;
						curSpeed = ((Vector3)(ref val2)).magnitude / Time.deltaTime;
					}
					return;
				}
				if (IsSwimming && curSpeed > swimSprintSpeed)
				{
					if (AI.logIssues)
					{
						Debug.LogError((object)$"Speed is too high: {curSpeed}/{swimSprintSpeed}");
					}
					curSpeed = swimSpeed;
				}
				else if (!IsSwimming && curSpeed > fullSprintSpeed)
				{
					if (AI.logIssues)
					{
						Debug.LogError((object)$"Speed is too high: {curSpeed}/{fullSprintSpeed}");
					}
					curSpeed = fullSprintSpeed;
				}
				if (!shouldStopAtDestination || IsFollowingPath)
				{
					SteerTowardsWaypoint();
					return;
				}
				curSpeed = Mathf.Max(desiredSpeed, curSpeed - 10f * Time.deltaTime);
				ResetPath();
			}
			finally
			{
				previousLocalPosition = ((Component)base.baseEntity).transform.localPosition;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static float GetBrakingDistance(float speed, float brakingDeceleration)
	{
		float num = speed / Mathf.Max(brakingDeceleration, 0.001f);
		return 0.5f * brakingDeceleration * num * num;
	}

	private float AdjustSpeedForSwimming(float speed)
	{
		if (!IsSwimming || speed <= 0f)
		{
			return speed;
		}
		if (!(speed < sprintSpeed))
		{
			return swimSprintSpeed;
		}
		return swimSpeed;
	}

	private void SteerTowardsWaypoint()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SteerTowardsWaypoint", 0);
		try
		{
			Transform transform = ((Component)base.baseEntity).transform;
			Vector3 val2 = agent.steeringTarget - transform.position;
			Vector3 val3 = ((Vector3)(ref val2)).normalized;
			if (Mathf.Abs(cachedPathLength - Vector3.Distance(transform.position, agent.destination)) < 5f)
			{
				val3 = Quaternion.AngleAxis(currentDeviation, Vector3.up) * val3;
			}
			float num = AdjustSpeedForSwimming(desiredSpeed);
			if (shouldStopAtDestination && agent.remainingDistance - maxTurnRadius < GetBrakingDistance(curSpeed, deceleration.Value))
			{
				curSpeed = Mathf.Max(1f, curSpeed - deceleration.Value * Time.deltaTime);
			}
			else if (curSpeed > num)
			{
				float num2 = (curSpeed - num) / deceleration.Value;
				float num3 = ((curSpeed > walkSpeed && num2 > 1f) ? 10f : deceleration.Value);
				curSpeed = Mathf.Max(num, curSpeed - num3 * Time.deltaTime);
			}
			else if (curSpeed < num)
			{
				curSpeed = Mathf.Min(num, curSpeed + acceleration.Value * Time.deltaTime);
			}
			agent.isStopped = true;
			if (!(((Vector3)(ref val3)).magnitude < 0.01f))
			{
				float num4 = (shouldStopAtDestination ? Mathx.RemapValClamped(agent.remainingDistance, maxTurnRadius * 2f, 0f, maxTurnRadius, 0.001f) : maxTurnRadius);
				float num5 = curSpeed / num4;
				Vector3 val4 = Vector3.RotateTowards(transform.forward, val3, num5 * Time.deltaTime, 0f);
				Vector3 offset = val4 * (curSpeed * Time.deltaTime);
				transform.rotation = Quaternion.LookRotation(Vector3Ex.WithY(val4, 0f));
				Move(offset);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionOnNavmesh(Vector3 position, out Vector3 sample)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return SamplePosition(position, out sample, 0.5f);
	}

	public bool SampleGroundPositionWithPhysics(Vector3 position, out RaycastHit hitInfo, float maxDistance = 2f, float radius = 0f, int layerMask = 1503731969)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SampleGroundPositionWithPhysics", 0);
		try
		{
			Vector3 val2 = position + Vector3.up * radius * 1.5f;
			float maxDistance2 = maxDistance + radius * 1.5f;
			if (!GamePhysics.TraceRealm(GamePhysics.Realm.Server, new Ray(val2, Vector3.down), radius, out hitInfo, maxDistance2, layerMask, (QueryTriggerInteraction)1))
			{
				((RaycastHit)(ref hitInfo)).point = position;
				return false;
			}
			if (radius > 0f && ((RaycastHit)(ref hitInfo)).distance <= 0f)
			{
				((RaycastHit)(ref hitInfo)).point = position;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionOnFavoredTerrain(Vector3 position)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionOnFavoredTerrain", 0);
		try
		{
			return IsPositionAtTopologyRequirement(position, preferedTopology) && IsPositionABiomeRequirement(position, preferedBiome);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionAtTopologyRequirement(Vector3 position, Enum topologyRequirement)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionAtTopologyRequirement", 0);
		try
		{
			if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
			{
				return false;
			}
			Enum val2 = (Enum)TerrainMeta.TopologyMap.GetTopology(position);
			if ((topologyRequirement & val2) == 0)
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionABiomeRequirement(Vector3 position, Enum biomeRequirement)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionABiomeRequirement", 0);
		try
		{
			if ((int)biomeRequirement == 0)
			{
				return true;
			}
			if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
			{
				return false;
			}
			Enum val2 = (Enum)TerrainMeta.BiomeMap.GetBiomeMaxType(position);
			if ((biomeRequirement & val2) == 0)
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsInWater(Vector3 position)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsInWater", 0);
		try
		{
			if (WaterLevel.GetOverallWaterDepth(position, waves: false, volumes: false) >= 0.3f)
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool SamplePosition(Vector3 position, out Vector3 sample, float maxDistance)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SamplePosition", 0);
		try
		{
			sample = position;
			NavMeshHit val2 = default(NavMeshHit);
			if (!NavMesh.SamplePosition(position, ref val2, maxDistance, agent.areaMask))
			{
				return false;
			}
			sample = ((NavMeshHit)(ref val2)).position;
			return ((NavMeshHit)(ref val2)).hit;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool Raycast(Vector3 targetPosition, out NavMeshHit hitInfo)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Raycast", 0);
		try
		{
			return agent.Raycast(targetPosition, ref hitInfo);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool CalculatePathCustom(Vector3 destination, NavMeshPath path)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("CalculatePathCustom", 0);
		try
		{
			return agent.CalculatePath(destination, path);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public enum Speeds
{
	Sneak,
	Walk,
	Jog,
	Run,
	Sprint,
	FullSprint
}


using System;
using UnityEngine;
using UnityEngine.AI;

public static class NavMeshPathEx
{
	private static Vector3[] cornersBuffer = (Vector3[])(object)new Vector3[128];

	public static float GetPathLength(this NavMeshPath path)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetPathLength", 0);
		try
		{
			float num = 0f;
			int cornersNonAlloc = path.GetCornersNonAlloc(cornersBuffer);
			if (cornersNonAlloc < 2)
			{
				return num;
			}
			for (int i = 0; i < cornersNonAlloc - 1; i++)
			{
				num += Vector3.Distance(cornersBuffer[i], cornersBuffer[i + 1]);
			}
			return num;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetOrigin(this NavMeshPath path)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetOrigin", 0);
		try
		{
			if (path.GetCornersNonAlloc(cornersBuffer) < 1)
			{
				return Vector3.zero;
			}
			return cornersBuffer[0];
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetDestination(this NavMeshPath path)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetDestination", 0);
		try
		{
			int cornersNonAlloc = path.GetCornersNonAlloc(cornersBuffer);
			if (cornersNonAlloc < 1)
			{
				return Vector3.zero;
			}
			return cornersBuffer[cornersNonAlloc - 1];
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using ConVar;
using Rust;
using UnityEngine;

public class BaseNPC2 : BaseCombatEntity
{
	[SerializeField]
	private float mass = 45f;

	public override bool IsNpc => true;

	public bool IsAnimal => true;

	public override float RealisticMass => mass;

	public string displayName
	{
		get
		{
			PrefabInformation prefabInformation = null;
			if (base.isServer)
			{
				prefabInformation = PrefabAttribute.server.Find<PrefabInformation>(prefabID);
			}
			if (prefabInformation == null)
			{
				if (AI.logIssues)
				{
					Debug.LogError((object)("PrefabInformation not found for " + Categorize() + ")"));
				}
				return "NPC";
			}
			return prefabInformation.title.english;
		}
	}

	public override float MaxVelocity()
	{
		return 10f;
	}

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			Query.Server.AddBrain(this);
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer && !Application.isQuitting)
		{
			Query.Server.RemoveBrain(this);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

[SoftRequireComponent(typeof(SenseComponent))]
public class NPCEncounterTimer : EntityComponent<BaseEntity>, IServerComponent
{
	public float giveUpDurationSeconds = 120f;

	[NonSerialized]
	public UnityEvent onShouldGiveUp = new UnityEvent();

	private const float fireTimeMultiplier = 4f;

	private const float mountedTimeMultiplier = 12f;

	private float? encounterRemainingTimeSeconds;

	private double? _lastTickTime;

	private SenseComponent _senseComponent;

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	private SenseComponent Senses => _senseComponent ?? (_senseComponent = ((Component)base.baseEntity).GetComponent<SenseComponent>());

	public void Tick()
	{
		float num = (float)(Time.timeAsDouble - LastTickTime);
		LastTickTime = Time.timeAsDouble;
		BaseEntity target;
		bool flag = Senses.FindTarget(out target);
		if (encounterRemainingTimeSeconds.HasValue && !flag)
		{
			encounterRemainingTimeSeconds = null;
		}
		else if (!encounterRemainingTimeSeconds.HasValue && flag)
		{
			StartTimer();
		}
		else
		{
			if (!encounterRemainingTimeSeconds.HasValue)
			{
				return;
			}
			if (base.baseEntity is BaseCombatEntity { SecondsSinceAttacked: <5f })
			{
				StartTimer();
				PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					Senses.GetInitialAllies((List<BaseEntity>)(object)val);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val)
					{
						((Component)item).GetComponent<NPCEncounterTimer>().StartTimer();
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			float num2 = 1f;
			if (target.ToNonNpcPlayer(out var player) && player.isMounted)
			{
				num2 = 12f;
			}
			else if (Trans_TargetIsNearFire.Test(base.baseEntity, Senses))
			{
				num2 = 4f;
			}
			encounterRemainingTimeSeconds -= num * num2;
			if (!(encounterRemainingTimeSeconds <= 0f))
			{
				return;
			}
			GiveUp();
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				Senses.GetInitialAllies((List<BaseEntity>)(object)val2);
				foreach (BaseEntity item2 in (List<BaseEntity>)(object)val2)
				{
					((Component)item2).GetComponent<NPCEncounterTimer>().GiveUp();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
	}

	private void StartTimer()
	{
		encounterRemainingTimeSeconds = giveUpDurationSeconds;
	}

	private void GiveUp()
	{
		if (encounterRemainingTimeSeconds.HasValue)
		{
			encounterRemainingTimeSeconds = null;
			onShouldGiveUp.Invoke();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/AI/NPC team", fileName = "NPCTeam_new", order = 0)]
public class NPCTeam : BaseScriptableObject
{
}


using System;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(LimitedTurnNavAgent))]
public class RootMotionPlayer : EntityComponent<BaseEntity>, IServerComponent
{
	public struct Warp
	{
		public float startTime;

		public float endTime;

		public Vector3 translationScale;

		public float rotationScale;

		public Warp(float startTime, float endTime, Vector3 translationScale, float rotationScale = 1f)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			this.startTime = startTime;
			this.endTime = endTime;
			this.translationScale = translationScale;
			this.rotationScale = rotationScale;
		}
	}

	public class PlayServerState : IPooled
	{
		public AnimationClip animClip;

		public RootMotionData rmData;

		public float elapsedTime;

		public Vector3 initialLocation;

		public Quaternion initialRotation;

		public Action ServerTickAction;

		public Warp[] warps;

		public bool constrainToNavmesh;

		public Vector3 lastUnscaledOffset;

		public float lastUnscaledRotation;

		public bool isPlaying;

		public void Reset()
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			isPlaying = false;
			rmData = null;
			animClip = null;
			initialRotation = Quaternion.identity;
			warps = null;
			constrainToNavmesh = true;
			elapsedTime = 0f;
			ServerTickAction = null;
			lastUnscaledOffset = Vector3.zero;
			lastUnscaledRotation = 0f;
		}

		void IPooled.EnterPool()
		{
			Reset();
		}

		void IPooled.LeavePool()
		{
			Reset();
		}

		public static PlayServerState TakeFromPool(RootMotionData data, Transform transform)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			PlayServerState playServerState = Pool.Get<PlayServerState>();
			playServerState.rmData = data;
			playServerState.initialLocation = transform.position;
			playServerState.initialRotation = transform.rotation;
			return playServerState;
		}

		public static PlayServerState TakeFromPool(AnimationClip data, Transform transform)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			PlayServerState playServerState = Pool.Get<PlayServerState>();
			playServerState.animClip = data;
			playServerState.initialLocation = transform.position;
			playServerState.initialRotation = transform.rotation;
			return playServerState;
		}

		public int GetAnimHash()
		{
			if (rmData != null)
			{
				if ((Object)(object)rmData.inPlaceAnimation == (Object)null)
				{
					Debug.LogError((object)("RootMotionPlayer.PlayServer: rmData.inPlaceAnimation is null for " + ((Object)rmData).name));
				}
				return Animator.StringToHash(((Object)rmData.inPlaceAnimation).name);
			}
			if ((Object)(object)animClip == (Object)null)
			{
				Debug.LogError((object)"RootMotionPlayer.PlayServer: animClip is null");
			}
			return Animator.StringToHash(((Object)animClip).name);
		}

		public float GetAnimLength()
		{
			if (!(rmData != null))
			{
				return animClip.length;
			}
			return rmData.inPlaceAnimation.length;
		}

		public bool Step(float deltaTime, ref Vector3 location, ref Quaternion rotation, float rootBoneLocalZOffset = 0f)
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_018a: Unknown result type (might be due to invalid IL or missing references)
			//IL_018f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			//IL_0195: Unknown result type (might be due to invalid IL or missing references)
			//IL_0199: Unknown result type (might be due to invalid IL or missing references)
			//IL_019f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0209: Unknown result type (might be due to invalid IL or missing references)
			//IL_020e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0213: Unknown result type (might be due to invalid IL or missing references)
			//IL_0218: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_014b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0162: Unknown result type (might be due to invalid IL or missing references)
			if (elapsedTime >= GetAnimLength())
			{
				return false;
			}
			if (rmData == null)
			{
				elapsedTime += deltaTime;
				return elapsedTime < GetAnimLength() - 0.25f;
			}
			Vector3 zero = Vector3.zero;
			zero.x = rmData.xMotionCurve.Evaluate(elapsedTime);
			zero.y = (constrainToNavmesh ? 0f : rmData.yMotionCurve.Evaluate(elapsedTime));
			zero.z = rmData.zMotionCurve.Evaluate(elapsedTime);
			float num = rmData.yRotationCurve.Evaluate(elapsedTime);
			Vector3 val = zero - lastUnscaledOffset;
			float num2 = num - lastUnscaledRotation;
			lastUnscaledOffset = zero;
			lastUnscaledRotation = num;
			if (warps != null)
			{
				Warp[] array = warps;
				for (int i = 0; i < array.Length; i++)
				{
					Warp warp = array[i];
					if (warp.startTime <= elapsedTime && elapsedTime <= warp.endTime)
					{
						val.x *= warp.translationScale.x;
						val.y *= warp.translationScale.y;
						val.z *= warp.translationScale.z;
						num2 *= warp.rotationScale;
					}
				}
			}
			Vector3 val2 = initialRotation * val;
			location -= rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
			location += val2;
			rotation *= Quaternion.Euler(0f, num2, 0f);
			location += rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
			elapsedTime += deltaTime;
			return elapsedTime < GetAnimLength() - 0.25f;
		}

		public Quaternion Track(Vector3 ownerPos, Vector3 targetPos, Quaternion rotation, float trackingSpeed, float deltaTime)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Vector3Ex.NormalizeXZ(targetPos - ownerPos);
			initialRotation = Quaternion.RotateTowards(initialRotation, Quaternion.LookRotation(val, Vector3.up), trackingSpeed * deltaTime);
			rotation *= Quaternion.Inverse(rotation) * initialRotation;
			return rotation;
		}
	}

	[SerializeField]
	private float rootBoneLocalZOffset;

	private LimitedTurnNavAgent _agent;

	private PlayServerState currentPlayState;

	private Action _playServerTickAction;

	private LockState.LockHandle lockHandle;

	private LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>());

	private Action PlayServerTickAction => PlayServerTick;

	public PlayServerState PlayServerAndTakeFromPool(RootMotionData data)
	{
		PlayServerState playServerState = PlayServerState.TakeFromPool(data, ((Component)base.baseEntity).transform);
		PlayServer(playServerState);
		return playServerState;
	}

	public PlayServerState PlayServerAndTakeFromPool(AnimationClip data)
	{
		PlayServerState playServerState = PlayServerState.TakeFromPool(data, ((Component)base.baseEntity).transform);
		PlayServer(playServerState);
		return playServerState;
	}

	public void PlayServer(PlayServerState state)
	{
		if (AI.logIssues && state.rmData == null && (Object)(object)state.animClip == (Object)null)
		{
			Debug.LogError((object)"RootMotionPlayer.PlayServer: state.rmData and state.animClip are both null");
			return;
		}
		if (currentPlayState != null)
		{
			StopServer(currentPlayState);
		}
		currentPlayState = state;
		currentPlayState.isPlaying = true;
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayMontageDelayed"), currentPlayState.GetAnimHash());
		lockHandle = Agent.Pause();
		((FacepunchBehaviour)base.baseEntity).InvokeRepeating(PlayServerTickAction, 0f, 0f);
	}

	public void PlayServerAdditive(AnimationClip animClip)
	{
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayAdditiveMontage"), Animator.StringToHash(((Object)animClip).name));
	}

	private void PlayServerTick()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("RootMotionPlayer:PlayServerTick", 0);
		try
		{
			Vector3 location = ((Component)base.baseEntity).transform.position;
			Quaternion rotation = ((Component)base.baseEntity).transform.rotation;
			bool num = !currentPlayState.Step(Time.deltaTime, ref location, ref rotation, rootBoneLocalZOffset);
			if (currentPlayState.rmData != null)
			{
				if (currentPlayState.constrainToNavmesh)
				{
					Agent.Move(location - ((Component)base.baseEntity).transform.position);
				}
				else
				{
					((Component)base.baseEntity).transform.position = location;
				}
				((Component)base.baseEntity).transform.rotation = rotation;
			}
			if (num)
			{
				StopServer(currentPlayState, interrupt: false);
				currentPlayState = null;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Track(Vector3 targetPos, float trackingSpeed = 45f, float? timeStep = null)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (currentPlayState != null && !(currentPlayState.rmData == null))
		{
			if (!timeStep.HasValue)
			{
				timeStep = Time.deltaTime;
			}
			((Component)base.baseEntity).transform.rotation = currentPlayState.Track(((Component)this).transform.position, targetPos, ((Component)base.baseEntity).transform.rotation, trackingSpeed, timeStep.Value);
		}
	}

	private void StopServer(PlayServerState state, bool interrupt = true)
	{
		if (state != null && state.isPlaying)
		{
			state.isPlaying = false;
			if (state == currentPlayState)
			{
				((FacepunchBehaviour)base.baseEntity).CancelInvoke(PlayServerTickAction);
				Agent.Unpause(ref lockHandle);
				currentPlayState = null;
			}
			if (interrupt)
			{
				base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_StopMontage"));
			}
		}
	}

	public void StopServerAndReturnToPool(ref PlayServerState state, bool interrupt = true)
	{
		if (state != null)
		{
			StopServer(state, interrupt);
			Pool.Free<PlayServerState>(ref state);
		}
	}
}


using UnityEngine;

public struct Warp
{
	public float startTime;

	public float endTime;

	public Vector3 translationScale;

	public float rotationScale;

	public Warp(float startTime, float endTime, Vector3 translationScale, float rotationScale = 1f)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		this.startTime = startTime;
		this.endTime = endTime;
		this.translationScale = translationScale;
		this.rotationScale = rotationScale;
	}
}


using System;
using Facepunch;
using UnityEngine;

public class PlayServerState : IPooled
{
	public AnimationClip animClip;

	public RootMotionData rmData;

	public float elapsedTime;

	public Vector3 initialLocation;

	public Quaternion initialRotation;

	public Action ServerTickAction;

	public Warp[] warps;

	public bool constrainToNavmesh;

	public Vector3 lastUnscaledOffset;

	public float lastUnscaledRotation;

	public bool isPlaying;

	public void Reset()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		isPlaying = false;
		rmData = null;
		animClip = null;
		initialRotation = Quaternion.identity;
		warps = null;
		constrainToNavmesh = true;
		elapsedTime = 0f;
		ServerTickAction = null;
		lastUnscaledOffset = Vector3.zero;
		lastUnscaledRotation = 0f;
	}

	void IPooled.EnterPool()
	{
		Reset();
	}

	void IPooled.LeavePool()
	{
		Reset();
	}

	public static PlayServerState TakeFromPool(RootMotionData data, Transform transform)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		PlayServerState playServerState = Pool.Get<PlayServerState>();
		playServerState.rmData = data;
		playServerState.initialLocation = transform.position;
		playServerState.initialRotation = transform.rotation;
		return playServerState;
	}

	public static PlayServerState TakeFromPool(AnimationClip data, Transform transform)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		PlayServerState playServerState = Pool.Get<PlayServerState>();
		playServerState.animClip = data;
		playServerState.initialLocation = transform.position;
		playServerState.initialRotation = transform.rotation;
		return playServerState;
	}

	public int GetAnimHash()
	{
		if (rmData != null)
		{
			if ((Object)(object)rmData.inPlaceAnimation == (Object)null)
			{
				Debug.LogError((object)("RootMotionPlayer.PlayServer: rmData.inPlaceAnimation is null for " + ((Object)rmData).name));
			}
			return Animator.StringToHash(((Object)rmData.inPlaceAnimation).name);
		}
		if ((Object)(object)animClip == (Object)null)
		{
			Debug.LogError((object)"RootMotionPlayer.PlayServer: animClip is null");
		}
		return Animator.StringToHash(((Object)animClip).name);
	}

	public float GetAnimLength()
	{
		if (!(rmData != null))
		{
			return animClip.length;
		}
		return rmData.inPlaceAnimation.length;
	}

	public bool Step(float deltaTime, ref Vector3 location, ref Quaternion rotation, float rootBoneLocalZOffset = 0f)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		if (elapsedTime >= GetAnimLength())
		{
			return false;
		}
		if (rmData == null)
		{
			elapsedTime += deltaTime;
			return elapsedTime < GetAnimLength() - 0.25f;
		}
		Vector3 zero = Vector3.zero;
		zero.x = rmData.xMotionCurve.Evaluate(elapsedTime);
		zero.y = (constrainToNavmesh ? 0f : rmData.yMotionCurve.Evaluate(elapsedTime));
		zero.z = rmData.zMotionCurve.Evaluate(elapsedTime);
		float num = rmData.yRotationCurve.Evaluate(elapsedTime);
		Vector3 val = zero - lastUnscaledOffset;
		float num2 = num - lastUnscaledRotation;
		lastUnscaledOffset = zero;
		lastUnscaledRotation = num;
		if (warps != null)
		{
			Warp[] array = warps;
			for (int i = 0; i < array.Length; i++)
			{
				Warp warp = array[i];
				if (warp.startTime <= elapsedTime && elapsedTime <= warp.endTime)
				{
					val.x *= warp.translationScale.x;
					val.y *= warp.translationScale.y;
					val.z *= warp.translationScale.z;
					num2 *= warp.rotationScale;
				}
			}
		}
		Vector3 val2 = initialRotation * val;
		location -= rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
		location += val2;
		rotation *= Quaternion.Euler(0f, num2, 0f);
		location += rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
		elapsedTime += deltaTime;
		return elapsedTime < GetAnimLength() - 0.25f;
	}

	public Quaternion Track(Vector3 ownerPos, Vector3 targetPos, Quaternion rotation, float trackingSpeed, float deltaTime)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.NormalizeXZ(targetPos - ownerPos);
		initialRotation = Quaternion.RotateTowards(initialRotation, Quaternion.LookRotation(val, Vector3.up), trackingSpeed * deltaTime);
		rotation *= Quaternion.Inverse(rotation) * initialRotation;
		return rotation;
	}
}


using UnityEngine;

public class RootMotionTester : MonoBehaviour
{
	public RootMotionData anim;

	public Transform target;

	public float timeStep = 0.1f;

	public float trackingSpeed = 90f;

	public float trackingDuration = 1f;

	public float rotArrowLength = 0.2f;

	public float targetVelocityYaw = 45f;

	public float targetVelocityMagnitude = 5f;

	public int trackingStepIndex;

	public float parentFrontOffset;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust.Ai;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class SenseComponent : EntityComponent<BaseEntity>
{
	[Serializable]
	public struct Cone
	{
		public float halfAngle;

		public float range;

		public Cone(float halfAngle = 80f, float range = 10f)
		{
			this.halfAngle = halfAngle;
			this.range = range;
		}
	}

	public class VisibilityStatus : IPooled
	{
		private BaseEntity baseEntity;

		private BaseEntity targetEntity;

		public Vector3 lastKnownPosition;

		private const float waterCheckInterval = 1f;

		private double? lastTimeInWaterUpdated;

		public float timeVisible { get; private set; }

		public float timeNotVisible { get; private set; }

		public bool isVisible => timeVisible > 0f;

		public float timeWatched { get; private set; }

		public float timeNotWatched { get; private set; }

		public float timeAimedAt { get; private set; }

		public float timeNotAimedAt { get; private set; }

		public WaterLevel.WaterInfo? lastWaterInfo { get; private set; }

		public bool isInWaterCached
		{
			get
			{
				//IL_0093: Unknown result type (might be due to invalid IL or missing references)
				//IL_009d: Unknown result type (might be due to invalid IL or missing references)
				//IL_008c: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
				if (!targetEntity.ToNonNpcPlayer(out var player))
				{
					return false;
				}
				if (!lastWaterInfo.HasValue || !lastTimeInWaterUpdated.HasValue || Time.timeAsDouble - lastTimeInWaterUpdated > 1.0)
				{
					BaseMountable entAsT;
					Vector3 val = (((Object)(object)player.GetMounted()).Is<BaseMountable>(out entAsT) ? (Vector3.down * 0.5f) : Vector3.zero);
					lastWaterInfo = WaterLevel.GetWaterInfo(((Component)targetEntity).transform.position + val, waves: false, volumes: false);
					lastTimeInWaterUpdated = Time.timeAsDouble;
				}
				return lastWaterInfo.Value.currentDepth >= 0.3f;
			}
		}

		private void Reset()
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			targetEntity = null;
			baseEntity = null;
			timeWatched = 0f;
			timeNotWatched = 100f;
			timeAimedAt = 0f;
			timeNotAimedAt = 100f;
			timeVisible = 0f;
			timeNotVisible = 100f;
			lastKnownPosition = Vector3.zero;
			lastWaterInfo = null;
			lastTimeInWaterUpdated = null;
		}

		public void EnterPool()
		{
			Reset();
		}

		public void LeavePool()
		{
			Reset();
		}

		public static VisibilityStatus GetFromPool(BaseEntity baseEntity, BaseEntity targetEntity, float deltaTime, Vector3? lastKnownPositionOverride = null)
		{
			VisibilityStatus visibilityStatus = Pool.Get<VisibilityStatus>();
			visibilityStatus.baseEntity = baseEntity;
			visibilityStatus.targetEntity = targetEntity;
			visibilityStatus.UpdateVisibility(isVisible: true, deltaTime, lastKnownPositionOverride);
			return visibilityStatus;
		}

		private bool CheckValid()
		{
			if (!baseEntity.IsValid() || !targetEntity.IsValid())
			{
				if (AI.logIssues)
				{
					Debug.LogError((object)$"SenseComponent:UpdateVisibility NRE: {baseEntity} {targetEntity}");
				}
				return false;
			}
			return true;
		}

		public void UpdateVisibility(bool isVisible, float deltaTime, Vector3? lastKnownPositionOverride = null)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			if (!CheckValid())
			{
				return;
			}
			if (lastKnownPositionOverride.HasValue)
			{
				lastKnownPosition = lastKnownPositionOverride.Value;
			}
			else if (isVisible)
			{
				lastKnownPosition = ((Component)targetEntity).transform.position;
			}
			if (isVisible)
			{
				timeNotVisible = 0f;
				timeVisible += deltaTime;
				Vector3 val = ((Component)targetEntity).transform.forward;
				Vector3 position = ((Component)targetEntity).transform.position;
				if (targetEntity.ToNonNpcPlayer(out var player))
				{
					val = player.eyes.HeadForward();
					position = player.eyes.position;
				}
				Vector3 val2 = ((Component)baseEntity).transform.position - position;
				float num = Mathf.Acos(Vector3.Dot(val, ((Vector3)(ref val2)).normalized)) * 57.29578f * 2f;
				bool num2 = num < AI.watchedAngle;
				if (num2)
				{
					timeNotWatched = 0f;
					timeWatched += deltaTime;
				}
				else
				{
					timeWatched = 0f;
					timeNotWatched += deltaTime;
				}
				if (num2 && (Object)(object)player != (Object)null && player.modelState.aiming && num < AI.aimedAtAngle && !(player.GetHeldEntity() is BaseMelee { canScareAiWhenAimed: false }))
				{
					timeNotAimedAt = 0f;
					timeAimedAt += deltaTime;
				}
				else
				{
					timeAimedAt = 0f;
					timeNotAimedAt += deltaTime;
				}
			}
			else
			{
				timeVisible = 0f;
				timeNotVisible += deltaTime;
				timeWatched = 0f;
				timeNotWatched += deltaTime;
				timeAimedAt = 0f;
				timeNotAimedAt += deltaTime;
			}
		}
	}

	[SerializeField]
	private Vector3 LongRangeVisionRectangle = new Vector3(6f, 30f, 60f);

	[SerializeField]
	private Cone ShortRangeVisionCone = new Cone(100f, 30f);

	[SerializeField]
	private float touchDistance = 6f;

	[SerializeField]
	private float noiseRangeMultiplier = 1f;

	[SerializeField]
	private float hearingRange = 50f;

	[SerializeField]
	private NPCTeam team;

	[NonSerialized]
	public ResettableFloat timeToForgetSightings = new ResettableFloat(30f);

	private const float timeToForgetNoises = 5f;

	private static HashSet<BaseEntity> entitiesUpdatedThisFrame = new HashSet<BaseEntity>();

	[ServerVar]
	public static float minRefreshIntervalSeconds = 0.2f;

	[ServerVar]
	public static float maxRefreshIntervalSeconds = 1f;

	private double? _lastTickTime;

	private double nextRefreshTime;

	private double spawnTime;

	private Dictionary<BaseEntity, double> _alliesWeAreAwareOf = new Dictionary<BaseEntity, double>(3);

	private Dictionary<BaseEntity, VisibilityStatus> entitiesWeAreAwareOf = new Dictionary<BaseEntity, VisibilityStatus>(8);

	private static readonly Dictionary<NpcNoiseIntensity, float> noiseRadii = new Dictionary<NpcNoiseIntensity, float>
	{
		{
			NpcNoiseIntensity.None,
			0f
		},
		{
			NpcNoiseIntensity.Low,
			10f
		},
		{
			NpcNoiseIntensity.Medium,
			20f
		},
		{
			NpcNoiseIntensity.High,
			50f
		}
	};

	private NpcNoiseEvent _currentNoise;

	[SerializeField]
	private float foodDetectionRange = 30f;

	private BaseEntity _nearestFood;

	[SerializeField]
	private float fireDetectionRange = 20f;

	[NonSerialized]
	public UnityEvent onFireMelee = new UnityEvent();

	private BaseEntity _nearestFire;

	private double? lastMeleeTime;

	[SerializeField]
	private float TargetingCooldown = 5f;

	private BaseEntity _target;

	private const float npcDistPenaltyToFavorTargetingPlayers = 10f;

	private double? lastTargetTime;

	private LockState lockState = new LockState();

	public float RefreshInterval
	{
		get
		{
			if (!ShouldRefreshFast)
			{
				return maxRefreshIntervalSeconds;
			}
			return minRefreshIntervalSeconds;
		}
	}

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	public bool HasPlayerInVicinity { get; private set; }

	public bool ShouldRefreshFast
	{
		get
		{
			if (!HasPlayerInVicinity)
			{
				if ((Object)(object)Target != (Object)null)
				{
					return Target.IsNonNpcPlayer();
				}
				return false;
			}
			return true;
		}
	}

	public NpcNoiseEvent currentNoise => _currentNoise;

	private BaseEntity Target
	{
		get
		{
			return _target;
		}
		set
		{
			if (base.baseEntity.isServer)
			{
				BaseEntity target = _target;
				_target = value;
				if ((Object)(object)target != (Object)(object)_target)
				{
					base.baseEntity.SendNetworkUpdate();
				}
			}
		}
	}

	private bool ChangedTargetRecently
	{
		get
		{
			if (lastTargetTime.HasValue)
			{
				return Time.timeAsDouble - lastTargetTime.Value < (double)TargetingCooldown;
			}
			return true;
		}
	}

	public void GetInitialAllies(List<BaseEntity> allies)
	{
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			foreach (var (baseEntity2, num2) in _alliesWeAreAwareOf)
			{
				if (!baseEntity2.IsValid() || (baseEntity2 is BaseCombatEntity baseCombatEntity && baseCombatEntity.IsDead()))
				{
					((List<BaseEntity>)(object)val).Add(baseEntity2);
				}
				else if (!(num2 - spawnTime > (double)(maxRefreshIntervalSeconds * 2f)))
				{
					allies.Add(baseEntity2);
				}
			}
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				_alliesWeAreAwareOf.Remove(item);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Vector3? GetLKP(BaseEntity entity)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (GetVisibilityStatus(entity, out var status))
		{
			return status.isVisible ? ((Component)entity).transform.position : status.lastKnownPosition;
		}
		return null;
	}

	public bool GetVisibilityStatus(BaseEntity entity, out VisibilityStatus status)
	{
		status = null;
		if (!CanTarget(entity))
		{
			return false;
		}
		if (!entitiesWeAreAwareOf.TryGetValue(entity, out status))
		{
			return false;
		}
		return true;
	}

	public bool Forget(BaseEntity entity)
	{
		if (!entitiesWeAreAwareOf.TryGetValue(entity, out var value))
		{
			return false;
		}
		entitiesWeAreAwareOf.Remove(entity);
		Pool.Free<VisibilityStatus>(ref value);
		return true;
	}

	public bool IsVisible(BaseEntity entity)
	{
		if (!GetVisibilityStatus(entity, out var status))
		{
			return false;
		}
		return status.isVisible;
	}

	public void GetSeenEntities(List<BaseEntity> perceivedEntities)
	{
		TimeWarning val = TimeWarning.New("SenseComponent:GetSeenEntities", 0);
		try
		{
			foreach (BaseEntity key in entitiesWeAreAwareOf.Keys)
			{
				if (IsVisible(key))
				{
					perceivedEntities.Add(key);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetOncePerceivedEntities(List<BaseEntity> perceivedEntities)
	{
		foreach (BaseEntity key in entitiesWeAreAwareOf.Keys)
		{
			if (GetVisibilityStatus(key, out var _))
			{
				perceivedEntities.Add(key);
			}
		}
	}

	private Matrix4x4 GetEyeTransform()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		return Matrix4x4.TRS(base.baseEntity.CenterPoint(), ((Component)base.baseEntity).transform.rotation, Vector3.one);
	}

	public override void InitShared()
	{
		base.InitShared();
		spawnTime = Time.timeAsDouble;
	}

	public override void Hurt(HitInfo hitInfo)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity initiator = hitInfo.Initiator;
		if (!CanTarget(initiator))
		{
			return;
		}
		Vector3 val = ((Component)initiator).transform.position + Quaternion.AngleAxis(Random.Range(0f, 360f), Vector3.up) * Vector3.forward * 5f;
		if (entitiesWeAreAwareOf.TryGetValue(initiator, out var value))
		{
			if (!value.isVisible && value.timeNotVisible > 3f)
			{
				value.lastKnownPosition = val;
			}
		}
		else
		{
			VisibilityStatus fromPool = VisibilityStatus.GetFromPool(base.baseEntity, initiator, 0.01f, val);
			entitiesWeAreAwareOf.Add(initiator, fromPool);
		}
	}

	public void Tick()
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:Tick", 0);
		try
		{
			double timeAsDouble = Time.timeAsDouble;
			if (timeAsDouble < nextRefreshTime)
			{
				return;
			}
			float deltaTime = (float)(timeAsDouble - LastTickTime);
			LastTickTime = timeAsDouble;
			HasPlayerInVicinity = false;
			entitiesUpdatedThisFrame.Clear();
			TimeWarning val2 = TimeWarning.New("SenseComponent:Tick:ProcessEntities", 0);
			try
			{
				PooledList<BaseEntity> val3 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					BaseEntity.Query.Server.GetPlayersAndBrainsInSphere(((Component)base.baseEntity).transform.position, LongRangeVisionRectangle.z, (List<BaseEntity>)(object)val3, BaseEntity.Query.DistanceCheckType.None);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val3)
					{
						if (!((Object)(object)item == (Object)(object)base.baseEntity))
						{
							if (item.IsNonNpcPlayer())
							{
								HasPlayerInVicinity = true;
							}
							if (InSameTeam(item) && !_alliesWeAreAwareOf.ContainsKey(item))
							{
								_alliesWeAreAwareOf.Add(item, timeAsDouble);
							}
							if (CanTarget(item))
							{
								UpdateEntityVisibility(item, deltaTime);
							}
						}
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			TimeWarning val4 = TimeWarning.New("SenseComponent:Tick:RemoveEntities", 0);
			try
			{
				PooledList<BaseEntity> val5 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					foreach (var (baseEntity2, visibilityStatus2) in entitiesWeAreAwareOf)
					{
						if (!CanTarget(baseEntity2))
						{
							((List<BaseEntity>)(object)val5).Add(baseEntity2);
						}
						else if (!visibilityStatus2.isVisible && visibilityStatus2.timeNotVisible > timeToForgetSightings.Value)
						{
							((List<BaseEntity>)(object)val5).Add(baseEntity2);
						}
						else if (!entitiesUpdatedThisFrame.Contains(baseEntity2) && visibilityStatus2.isVisible)
						{
							entitiesWeAreAwareOf[baseEntity2].UpdateVisibility(isVisible: false, deltaTime, null);
						}
					}
					entitiesUpdatedThisFrame.Clear();
					foreach (BaseEntity item2 in (List<BaseEntity>)(object)val5)
					{
						if (Target.IsValid() && (Object)(object)Target == (Object)(object)item2)
						{
							ClearTarget(forget: false);
						}
						Forget(item2);
					}
				}
				finally
				{
					((IDisposable)val5)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
			TickHearing(deltaTime);
			TickFoodDetection(deltaTime);
			TickFireDetection(deltaTime);
			TickTargeting(deltaTime);
			nextRefreshTime = Time.timeAsDouble + (double)RefreshInterval;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void GetModifiedSenses(BaseEntity entity, out float modTouchDistance, out float modHalfAngle, out float modShortVisionRange, out Vector3 modLongVisionRectangle)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		modTouchDistance = touchDistance;
		modHalfAngle = ShortRangeVisionCone.halfAngle;
		modShortVisionRange = ShortRangeVisionCone.range;
		modLongVisionRectangle = LongRangeVisionRectangle;
		if (entity.ToNonNpcPlayer(out var player))
		{
			if (player.IsDucked())
			{
				modTouchDistance = ((Bounds)(ref base.baseEntity.bounds)).extents.z * 1.5f;
				modHalfAngle = ShortRangeVisionCone.halfAngle * 0.85f;
				modShortVisionRange = ShortRangeVisionCone.range * 0.5f;
				modLongVisionRectangle = Vector3.Scale(LongRangeVisionRectangle, new Vector3(3f, 0.5f, 0.5f));
			}
			else if (player.IsRunning())
			{
				modTouchDistance = touchDistance * 3f;
				modHalfAngle = ShortRangeVisionCone.halfAngle;
				modShortVisionRange = ShortRangeVisionCone.range * 1.3f;
				modLongVisionRectangle = LongRangeVisionRectangle * 1.15f;
			}
		}
	}

	private bool IsInAnyRange(BaseEntity entity)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsInAnyRange", 0);
		try
		{
			Matrix4x4 eyeTransform = GetEyeTransform();
			Vector3 position = ((Matrix4x4)(ref eyeTransform)).GetPosition();
			eyeTransform = GetEyeTransform();
			Vector3 val2 = ((Matrix4x4)(ref eyeTransform)).rotation * Vector3.forward;
			Vector3 val3 = ((Component)entity).transform.position - position;
			float magnitude = ((Vector3)(ref val3)).magnitude;
			GetModifiedSenses(entity, out var modTouchDistance, out var modHalfAngle, out var modShortVisionRange, out var modLongVisionRectangle);
			if (magnitude < modTouchDistance)
			{
				return true;
			}
			if (Vector3.Angle(val2, ((Vector3)(ref val3)).normalized) < modHalfAngle)
			{
				if (magnitude < modShortVisionRange)
				{
					return true;
				}
				if (TOD_Sky.Instance.IsDay && magnitude < modLongVisionRectangle.z && Mathf.Abs(((Component)entity).transform.position.y - position.y) < modLongVisionRectangle.y * 0.5f)
				{
					Vector3 val4 = Vector3.Cross(val2, ((Component)entity).transform.position - position);
					if (((Vector3)(ref val4)).magnitude < modLongVisionRectangle.x * 0.5f)
					{
						return true;
					}
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void UpdateEntityVisibility(BaseEntity entity, float deltaTime)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		bool flag = IsInAnyRange(entity);
		if (flag && entity.ToNonNpcPlayer(out var player))
		{
			TimeWarning val = TimeWarning.New("SenseComponent:ProcessEntity:CanSee", 0);
			try
			{
				Matrix4x4 eyeTransform = GetEyeTransform();
				Vector3 position = ((Matrix4x4)(ref eyeTransform)).GetPosition();
				flag = base.baseEntity.CanSee(position, player.eyes.position);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (entitiesWeAreAwareOf.TryGetValue(entity, out var value))
		{
			value.UpdateVisibility(flag, deltaTime, null);
			entitiesUpdatedThisFrame.Add(entity);
		}
		else if (flag)
		{
			VisibilityStatus fromPool = VisibilityStatus.GetFromPool(base.baseEntity, entity, deltaTime, null);
			entitiesWeAreAwareOf.Add(entity, fromPool);
			entitiesUpdatedThisFrame.Add(entity);
		}
	}

	public bool InSameTeam(BaseEntity other)
	{
		if (team != null && ((Object)(object)((Component)other).GetComponent<SenseComponent>()).Is<SenseComponent>(out SenseComponent entAsT) && team == entAsT.team)
		{
			return true;
		}
		return base.baseEntity.InSameNpcTeam(other);
	}

	private void TickHearing(float deltaTime)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickHearing", 0);
		try
		{
			if (_currentNoise != null)
			{
				Pool.Free<NpcNoiseEvent>(ref _currentNoise);
			}
			if (noiseRangeMultiplier <= 0f)
			{
				return;
			}
			PooledList<NpcNoiseEvent> val2 = Pool.Get<PooledList<NpcNoiseEvent>>();
			try
			{
				SingletonComponent<NpcNoiseManager>.Instance.GetNoisesAround(((Component)base.baseEntity).transform.position, hearingRange, (List<NpcNoiseEvent>)(object)val2);
				NpcNoiseEvent npcNoiseEvent = null;
				float? num = null;
				foreach (NpcNoiseEvent item in (List<NpcNoiseEvent>)(object)val2)
				{
					if ((Object)(object)item.Initiator == (Object)(object)base.baseEntity || !CanTarget(item.Initiator))
					{
						continue;
					}
					float num2 = (float)(Time.timeAsDouble - item.EventTime);
					if (!(num2 > 5f) && (npcNoiseEvent == null || item.Intensity >= npcNoiseEvent.Intensity))
					{
						if (!noiseRadii.TryGetValue(item.Intensity, out var value))
						{
							Debug.LogError((object)$"Unknown noise intensity: {item.Intensity}");
						}
						else if (!(Vector3.Distance(item.Position, ((Component)base.baseEntity).transform.position) > Mathf.Min(value * noiseRangeMultiplier, hearingRange)) && (npcNoiseEvent == null || item.Intensity != npcNoiseEvent.Intensity || !(num2 > num)))
						{
							npcNoiseEvent = item;
							num = num2;
						}
					}
				}
				if (npcNoiseEvent != null)
				{
					_currentNoise = Pool.Get<NpcNoiseEvent>();
					_currentNoise.Initiator = npcNoiseEvent.Initiator;
					_currentNoise.Position = npcNoiseEvent.Position;
					_currentNoise.Intensity = npcNoiseEvent.Intensity;
					if (!FindTarget(out var _))
					{
						TrySetTarget(npcNoiseEvent.Initiator);
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool ConsumeCurrentNoise()
	{
		if (_currentNoise == null)
		{
			return false;
		}
		Pool.Free<NpcNoiseEvent>(ref _currentNoise);
		return true;
	}

	public bool FindFood(out BaseEntity food)
	{
		if (!_nearestFood.IsValid() || _nearestFood.IsDestroyed || !SingletonComponent<NpcFoodManager>.Instance.Contains(_nearestFood))
		{
			food = null;
			return false;
		}
		food = _nearestFood;
		return true;
	}

	private void TickFoodDetection(float deltaTime)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickFoodDetection", 0);
		try
		{
			_nearestFood = null;
			if (foodDetectionRange <= 0f)
			{
				return;
			}
			float num = foodDetectionRange * foodDetectionRange;
			float num2 = float.MaxValue;
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				SingletonComponent<NpcFoodManager>.Instance.GetFoodAround(((Component)base.baseEntity).transform.position, foodDetectionRange, (List<BaseEntity>)(object)val2);
				LimitedTurnNavAgent component = ((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>();
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (!NpcFoodManager.IsFoodImmobile(item) || (item is BaseCorpse baseCorpse && ((Object)(object)((Component)baseCorpse).GetComponent<HeadDispenser>()).Is<HeadDispenser>(out HeadDispenser entAsT) && ((Object)(object)entAsT.SourceEntity.GetEntity()).Is<BaseEntity>(out BaseEntity entAsT2) && entAsT2.InSameNpcTeam(base.baseEntity)))
					{
						continue;
					}
					if (!component.IsPositionOnNavmesh(((Component)item).transform.position, out var sample))
					{
						SingletonComponent<NpcFoodManager>.Instance.Remove(item);
						continue;
					}
					sample = ((Component)item).transform.position - ((Component)base.baseEntity).transform.position;
					float sqrMagnitude = ((Vector3)(ref sample)).sqrMagnitude;
					if (sqrMagnitude < num2 && sqrMagnitude < num)
					{
						_nearestFood = item;
						num2 = sqrMagnitude;
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool FindFire(out BaseEntity fire)
	{
		if (!_nearestFire.IsValid() || _nearestFire.IsDestroyed || !NpcFireManager.IsOnFire(_nearestFire))
		{
			_nearestFire = null;
		}
		fire = _nearestFire;
		return (Object)(object)fire != (Object)null;
	}

	private void TickFireDetection(float deltaTime)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickFireDetection", 0);
		try
		{
			if (fireDetectionRange <= 0f)
			{
				return;
			}
			if ((Object)(object)Target != (Object)null && SingletonComponent<NpcFireManager>.Instance.DidMeleeWithFireRecently(base.baseEntity, Target, out var meleeTime) && (!lastMeleeTime.HasValue || meleeTime != lastMeleeTime.Value))
			{
				lastMeleeTime = meleeTime;
				onFireMelee.Invoke();
			}
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				SingletonComponent<NpcFireManager>.Instance.GetFiresAround(((Component)base.baseEntity).transform.position, fireDetectionRange, (List<BaseEntity>)(object)val2);
				BaseEntity baseEntity = null;
				float num = fireDetectionRange * fireDetectionRange;
				float num2 = float.MaxValue;
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					Vector3 val3 = ((Component)item).transform.position - ((Component)base.baseEntity).transform.position;
					float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
					if (sqrMagnitude < num2 && sqrMagnitude < num)
					{
						baseEntity = item;
						num2 = sqrMagnitude;
					}
				}
				if ((Object)(object)baseEntity != (Object)null)
				{
					_nearestFire = baseEntity;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public LockState.LockHandle LockCurrentTarget()
	{
		return lockState.AddLock();
	}

	public bool UnlockTarget(ref LockState.LockHandle handle)
	{
		return lockState.RemoveLock(ref handle);
	}

	public bool CanTarget(BaseEntity entity)
	{
		if (!entity.IsValid())
		{
			return false;
		}
		if (entity.IsTransferProtected())
		{
			return false;
		}
		if (entity.IsDestroyed)
		{
			return false;
		}
		if (!entity.IsNonNpcPlayer() && !entity.IsNpc)
		{
			return false;
		}
		if (entity.IsNpcPlayer())
		{
			return false;
		}
		if (entity is BaseCombatEntity baseCombatEntity && baseCombatEntity.IsDead())
		{
			return false;
		}
		if (InSameTeam(entity))
		{
			return false;
		}
		if (entity is BasePlayer item)
		{
			if (AI.ignoreplayers)
			{
				return false;
			}
			if (SimpleAIMemory.PlayerIgnoreList.Contains(item))
			{
				return false;
			}
		}
		object obj = Interface.CallHook("IOnNpcTarget", (object)this, (object)entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public bool FindTarget(out BaseEntity target)
	{
		if (!CanTarget(Target))
		{
			ClearTarget();
			target = null;
			return false;
		}
		target = Target;
		return (Object)(object)target != (Object)null;
	}

	public bool FindTargetPosition(out Vector3 targetPosition)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!FindTarget(out var target))
		{
			targetPosition = Vector3.zero;
			return false;
		}
		targetPosition = ((Component)target).transform.position;
		return true;
	}

	public bool TrySetTarget(BaseEntity newTarget, bool bypassCooldown = true)
	{
		if (lockState.IsLocked)
		{
			return false;
		}
		if ((Object)(object)newTarget == (Object)null)
		{
			ClearTarget();
			return true;
		}
		if ((Object)(object)newTarget == (Object)(object)Target)
		{
			return true;
		}
		if (!CanTarget(newTarget))
		{
			return false;
		}
		if ((Object)(object)Target != (Object)null && !bypassCooldown && ChangedTargetRecently)
		{
			return false;
		}
		lastTargetTime = Time.timeAsDouble;
		Target = newTarget;
		return true;
	}

	public void ClearTarget(bool forget = true)
	{
		if (Target.IsValid())
		{
			if (forget)
			{
				Forget(Target);
			}
			lastTargetTime = null;
			Target = null;
		}
	}

	private void TickTargeting(float deltaTime)
	{
		TimeWarning val = TimeWarning.New("SenseComponent:TickTargeting", 0);
		try
		{
			if ((Object)(object)Target != (Object)null && !CanTarget(Target))
			{
				ClearTarget();
			}
			if ((Object)(object)Target != (Object)null && ChangedTargetRecently)
			{
				return;
			}
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				GetOncePerceivedEntities((List<BaseEntity>)(object)val2);
				if (((List<BaseEntity>)(object)val2).Count == 0)
				{
					return;
				}
				BaseEntity baseEntity = null;
				float num = float.MaxValue;
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (CanTarget(item))
					{
						float num2 = base.baseEntity.SqrDistance(item);
						if (item.IsNpc)
						{
							num2 += 100f;
						}
						if (num2 < num)
						{
							num = num2;
							baseEntity = item;
						}
					}
				}
				if ((Object)(object)baseEntity != (Object)null)
				{
					TrySetTarget(baseEntity, bypassCooldown: false);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void SaveComponent(BaseNetworkable.SaveInfo info)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		base.SaveComponent(info);
		if (base.baseEntity.isServer)
		{
			info.msg.npcSensesState = Pool.Get<NPCSensesState>();
			if ((Object)(object)Target != (Object)null)
			{
				info.msg.npcSensesState.targetEntityId = Target.net.ID;
			}
		}
	}

	public override void LoadComponent(BaseNetworkable.LoadInfo info)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		NPCSensesState npcSensesState = info.msg.npcSensesState;
		if (npcSensesState != null)
		{
			if (((NetworkableId)(ref npcSensesState.targetEntityId)).IsValid)
			{
				if (base.baseEntity.isServer)
				{
					_target = BaseNetworkable.serverEntities.Find(npcSensesState.targetEntityId) as BaseEntity;
				}
			}
			else
			{
				_target = null;
			}
		}
		base.LoadComponent(info);
	}
}


using System;

[Serializable]
public struct Cone
{
	public float halfAngle;

	public float range;

	public Cone(float halfAngle = 80f, float range = 10f)
	{
		this.halfAngle = halfAngle;
		this.range = range;
	}
}


using ConVar;
using Facepunch;
using UnityEngine;

public class VisibilityStatus : IPooled
{
	private BaseEntity baseEntity;

	private BaseEntity targetEntity;

	public Vector3 lastKnownPosition;

	private const float waterCheckInterval = 1f;

	private double? lastTimeInWaterUpdated;

	public float timeVisible { get; private set; }

	public float timeNotVisible { get; private set; }

	public bool isVisible => timeVisible > 0f;

	public float timeWatched { get; private set; }

	public float timeNotWatched { get; private set; }

	public float timeAimedAt { get; private set; }

	public float timeNotAimedAt { get; private set; }

	public WaterLevel.WaterInfo? lastWaterInfo { get; private set; }

	public bool isInWaterCached
	{
		get
		{
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			if (!targetEntity.ToNonNpcPlayer(out var player))
			{
				return false;
			}
			if (!lastWaterInfo.HasValue || !lastTimeInWaterUpdated.HasValue || Time.timeAsDouble - lastTimeInWaterUpdated > 1.0)
			{
				BaseMountable entAsT;
				Vector3 val = (((Object)(object)player.GetMounted()).Is<BaseMountable>(out entAsT) ? (Vector3.down * 0.5f) : Vector3.zero);
				lastWaterInfo = WaterLevel.GetWaterInfo(((Component)targetEntity).transform.position + val, waves: false, volumes: false);
				lastTimeInWaterUpdated = Time.timeAsDouble;
			}
			return lastWaterInfo.Value.currentDepth >= 0.3f;
		}
	}

	private void Reset()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		targetEntity = null;
		baseEntity = null;
		timeWatched = 0f;
		timeNotWatched = 100f;
		timeAimedAt = 0f;
		timeNotAimedAt = 100f;
		timeVisible = 0f;
		timeNotVisible = 100f;
		lastKnownPosition = Vector3.zero;
		lastWaterInfo = null;
		lastTimeInWaterUpdated = null;
	}

	public void EnterPool()
	{
		Reset();
	}

	public void LeavePool()
	{
		Reset();
	}

	public static VisibilityStatus GetFromPool(BaseEntity baseEntity, BaseEntity targetEntity, float deltaTime, Vector3? lastKnownPositionOverride = null)
	{
		VisibilityStatus visibilityStatus = Pool.Get<VisibilityStatus>();
		visibilityStatus.baseEntity = baseEntity;
		visibilityStatus.targetEntity = targetEntity;
		visibilityStatus.UpdateVisibility(isVisible: true, deltaTime, lastKnownPositionOverride);
		return visibilityStatus;
	}

	private bool CheckValid()
	{
		if (!baseEntity.IsValid() || !targetEntity.IsValid())
		{
			if (AI.logIssues)
			{
				Debug.LogError((object)$"SenseComponent:UpdateVisibility NRE: {baseEntity} {targetEntity}");
			}
			return false;
		}
		return true;
	}

	public void UpdateVisibility(bool isVisible, float deltaTime, Vector3? lastKnownPositionOverride = null)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckValid())
		{
			return;
		}
		if (lastKnownPositionOverride.HasValue)
		{
			lastKnownPosition = lastKnownPositionOverride.Value;
		}
		else if (isVisible)
		{
			lastKnownPosition = ((Component)targetEntity).transform.position;
		}
		if (isVisible)
		{
			timeNotVisible = 0f;
			timeVisible += deltaTime;
			Vector3 val = ((Component)targetEntity).transform.forward;
			Vector3 position = ((Component)targetEntity).transform.position;
			if (targetEntity.ToNonNpcPlayer(out var player))
			{
				val = player.eyes.HeadForward();
				position = player.eyes.position;
			}
			Vector3 val2 = ((Component)baseEntity).transform.position - position;
			float num = Mathf.Acos(Vector3.Dot(val, ((Vector3)(ref val2)).normalized)) * 57.29578f * 2f;
			bool num2 = num < AI.watchedAngle;
			if (num2)
			{
				timeNotWatched = 0f;
				timeWatched += deltaTime;
			}
			else
			{
				timeWatched = 0f;
				timeNotWatched += deltaTime;
			}
			if (num2 && (Object)(object)player != (Object)null && player.modelState.aiming && num < AI.aimedAtAngle && !(player.GetHeldEntity() is BaseMelee { canScareAiWhenAimed: false }))
			{
				timeNotAimedAt = 0f;
				timeAimedAt += deltaTime;
			}
			else
			{
				timeAimedAt = 0f;
				timeNotAimedAt += deltaTime;
			}
		}
		else
		{
			timeVisible = 0f;
			timeNotVisible += deltaTime;
			timeWatched = 0f;
			timeNotWatched += deltaTime;
			timeAimedAt = 0f;
			timeNotAimedAt += deltaTime;
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine.Assertions;

public class LockState
{
	public class LockHandle
	{
	}

	private HashSet<LockHandle> locks = new HashSet<LockHandle>();

	public bool IsLocked => locks.Count > 0;

	public LockHandle AddLock()
	{
		LockHandle lockHandle = Pool.Get<LockHandle>();
		locks.Add(lockHandle);
		return lockHandle;
	}

	public bool RemoveLock(ref LockHandle handle)
	{
		if (handle == null)
		{
			return false;
		}
		bool num = locks.Remove(handle);
		Assert.IsTrue(num, "Trying to remove a lock that doesn't exist");
		if (num)
		{
			Pool.FreeUnsafe<LockHandle>(ref handle);
		}
		return num;
	}
}


public class LockHandle
{
}


using UnityEngine;

public static class BaseEntityTargettingExtensions
{
	public static bool InSameNpcTeam(this BaseEntity entity, BaseEntity other)
	{
		if ((Object)(object)entity == (Object)null || (Object)(object)other == (Object)null)
		{
			return false;
		}
		return ((object)entity).GetType() == ((object)other).GetType();
	}

	public static bool IsNonNpcPlayer(this BaseEntity entity)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			return !basePlayer.IsNpc;
		}
		return false;
	}

	public static bool IsNpcPlayer(this BaseEntity entity)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			return basePlayer.IsNpc;
		}
		return false;
	}

	public static bool ToNonNpcPlayer(this BaseEntity entity, out BasePlayer player)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer == (Object)null || basePlayer.IsNpc)
		{
			player = null;
			return false;
		}
		player = basePlayer;
		return true;
	}
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;

public class UI_RustButtonGroup : MonoBehaviour
{
	[SerializeField]
	[Header("Button Group")]
	protected List<RustButton> _buttons = new List<RustButton>();

	[SerializeField]
	protected bool _unpressSiblings;

	[Tooltip("This button will appear 'pressed' at the beginning.")]
	[SerializeField]
	private RustButton _defaultButton;

	[SerializeField]
	private bool _allowToggleOff;

	public List<RustButton> Buttons => _buttons;

	private void Start()
	{
		SetupButtons();
	}

	public void AddListenerToGroup(UnityAction action)
	{
		if (_buttons.Count <= 0)
		{
			Debug.LogError((object)"No Buttons found in group.");
			return;
		}
		foreach (RustButton button in _buttons)
		{
			if (!((Object)(object)button == (Object)null))
			{
				button.OnPressed.AddListener(action);
			}
		}
	}

	public void AddListenerToIndex(int index, UnityAction action)
	{
		if (_buttons.Count <= 0)
		{
			Debug.LogError((object)"No Buttons found in group.");
		}
		else if (_buttons.Count - 1 < index)
		{
			Debug.LogError((object)$"No Buttons found at index {index}.");
		}
		else if ((Object)(object)_buttons[index] == (Object)null)
		{
			Debug.LogError((object)$"Button at index {index} is null.");
		}
		else
		{
			_buttons[index].OnPressed.AddListener(action);
		}
	}

	public void EnableButton(int index)
	{
		if (_buttons.Count <= index)
		{
			Debug.LogError((object)$"Button with index {index} doesn't exist.");
		}
		else
		{
			_buttons[index].SetToggleTrue(true);
		}
	}

	protected virtual void SetupButtons()
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Expected O, but got Unknown
		if (_buttons.Count <= 0)
		{
			Debug.LogError((object)"No Buttons found in group.");
			return;
		}
		foreach (RustButton button in _buttons)
		{
			if ((Object)(object)button == (Object)null)
			{
				continue;
			}
			if ((Object)(object)_defaultButton != (Object)null && (Object)(object)button == (Object)(object)_defaultButton)
			{
				button.PreventToggleOff = false;
				button.SetToggleTrue(true);
			}
			if (!_unpressSiblings)
			{
				continue;
			}
			button.OnPressed.AddListener((UnityAction)delegate
			{
				if (!_allowToggleOff)
				{
					button.PreventToggleOff = true;
				}
				UnpressSiblings(button);
			});
		}
	}

	public void UnpressSiblings(RustButton thisButton)
	{
		foreach (RustButton button in _buttons)
		{
			if (!((Object)(object)thisButton == (Object)(object)button) && !((Object)(object)button == (Object)null))
			{
				button.PreventToggleOff = false;
				button.SetToggleFalse(true);
			}
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.Events;

public class ClockSlider : RustSlider
{
	private bool isUpdatingText;

	public override float Value
	{
		get
		{
			return ((RustSlider)this).Value;
		}
		set
		{
			value = Mathf.Clamp(value, base.MinValue, base.MaxValue);
			if (base.Integer)
			{
				value = Mathf.Round(value);
			}
			if (base.ValueInternal != value)
			{
				base.ValueInternal = value;
			}
			string text = FormatText(value);
			if ((Object)(object)base.NumberInput != (Object)null && !base.NumberInput.IsFocused && base.NumberInput.Text != text)
			{
				UpdateTextNoNotify(text);
			}
			base.SliderCanvas.fillAmount = ((RustSlider)this).ValueNormalized;
			if (base.lastCallbackValue != value)
			{
				base.lastCallbackValue = value;
				((UnityEvent<float>)(object)base.OnChanged)?.Invoke(value);
			}
		}
	}

	protected override void Awake()
	{
		((RustSlider)this).Awake();
		if ((Object)(object)base.NumberInput != (Object)null)
		{
			((UnityEvent<string>)(object)base.NumberInput.OnValueChanged).RemoveListener((UnityAction<string>)TextChanged);
			((UnityEvent<string>)(object)base.NumberInput.OnValueChanged).AddListener((UnityAction<string>)TextChanged);
			((UnityEvent<string>)(object)base.NumberInput.OnEndEdit).RemoveListener((UnityAction<string>)OnEndEdit);
			((UnityEvent<string>)(object)base.NumberInput.OnEndEdit).AddListener((UnityAction<string>)OnEndEdit);
		}
	}

	public void OnEndEdit(string text)
	{
		if (isUpdatingText)
		{
			return;
		}
		if (!text.Contains(":"))
		{
			text = ((text.Length == 4) ? text.Insert(2, ":") : ((text.Length == 3) ? text.Insert(1, ":") : ((text.Length != 1) ? "00:00" : ("0" + text + ":00"))));
			UpdateTextNoNotify(text);
		}
		else
		{
			if (text.Length == 3)
			{
				text = text.Insert(3, "00");
			}
			UpdateTextNoNotify(text);
		}
		UpdateValue(text, updateText: true);
	}

	public void TextChanged(string text)
	{
		if (isUpdatingText)
		{
			return;
		}
		int num = -1;
		if (!text.Contains(":"))
		{
			if (text.Length == 2)
			{
				text = text.Insert(2, ":");
				num = 3;
			}
			if (text.Length == 1)
			{
				int.TryParse(text, out var result);
				if (result > 2)
				{
					text = "0" + text + ":";
					num = 3;
				}
			}
			UpdateTextNoNotify(text);
			if (num != -1)
			{
				base.NumberInput.InputField.caretPosition = num;
			}
		}
		UpdateValue(text, updateText: false);
	}

	private void UpdateValue(string text, bool updateText)
	{
		string[] array = text.Split(':');
		if (array.Length != 2 || !int.TryParse(array[0], out var result) || !int.TryParse(array[1], out var result2))
		{
			return;
		}
		result = Mathf.Clamp(result, 0, 23);
		result2 = Mathf.Clamp(result2, 0, 59);
		((RustSlider)this).Value = (float)result + (float)result2 / 60f;
		if (updateText)
		{
			string text2 = FormatText(((RustSlider)this).Value);
			if (base.NumberInput.Text != text2)
			{
				UpdateTextNoNotify(text2);
			}
		}
	}

	private string FormatText(float value)
	{
		int num = Mathf.RoundToInt(value * 60f);
		int num2 = num / 60;
		int num3 = num % 60;
		return $"{num2:D2}:{num3:D2}";
	}

	private void UpdateTextNoNotify(string text)
	{
		isUpdatingText = true;
		base.NumberInput.Text = text;
		isUpdatingText = false;
	}
}


using UnityEngine;

public class MuteListController : UIDialog
{
	public RectTransform ListParent;

	public GameObjectRef UserWidget;

	public SteamFriendsList SearchList;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ReportBug : UIDialog
{
	public GameObject GetInformation;

	public GameObject Finished;

	public RustInput Subject;

	public RustInput Message;

	public RustButton ReportButton;

	public RustButtonGroup Category;

	public RustIcon ProgressIcon;

	public RustText ProgressText;

	public RawImage ScreenshotImage;

	public GameObject ScreenshotRoot;

	public UIBackgroundBlur BlurController;

	public RustButton SubmitButton;

	public GameObject SubmitErrorRoot;

	public RustText CooldownText;

	public RustText ContentMissingText;
}


using Rust.UI;
using UnityEngine;

public class ReportPlayer : UIDialog
{
	public const string BreakServerRulesKey = "break_server_rules";

	public GameObject FindPlayer;

	public GameObject GetInformation;

	public GameObject Finished;

	public GameObject RecentlyReported;

	public Dropdown ReasonDropdown;

	public RustInput Subject;

	public RustInput Message;

	public RustButton ReportButton;

	public SteamUserButton SteamUserButton;

	public RustIcon ProgressIcon;

	public RustText ProgressText;

	public static Option[] ReportReasons = (Option[])(object)new Option[6]
	{
		new Option(new Phrase("report.reason.none", "Select an option"), "none", false, (Icons)61641),
		new Option(new Phrase("report.reason.abuse", "Racism/Sexism/Abusive"), "abusive", false, (Icons)62806),
		new Option(new Phrase("report.reason.cheat", "Cheating"), "cheat", false, (Icons)61531),
		new Option(new Phrase("report.reason.spam", "Spamming"), "spam", false, (Icons)61601),
		new Option(new Phrase("report.reason.name", "Offensive Name"), "name", false, (Icons)63417),
		new Option(new Phrase("report.reason.server_rules", "Breaking Server Rules"), "break_server_rules", false, (Icons)61546)
	};
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class SteamInventoryCrafting : MonoBehaviour
{
	public GameObject Container;

	public ToggleGroup ToggleGroup;

	public Button ConvertToItem;

	public Button DeleteButton;

	public TextMeshProUGUI WoodAmount;

	public TextMeshProUGUI ClothAmount;

	public TextMeshProUGUI MetalAmount;

	public TextMeshProUGUI InfoText;

	public SteamInventoryCrateOpen CraftModal;

	public GameObject CraftingContainer;

	public GameObject CraftingButton;

	public SteamInventoryNewItem NewItemModal;

	public IPlayerItemDefinition ResultItem { get; private set; }

	public Coroutine MarketCoroutine { get; private set; }
}


using Rust.UI;
using TMPro;
using UnityEngine;

public class SteamInventoryCrateOpen : MonoBehaviour
{
	public TextMeshProUGUI Name;

	public TextMeshProUGUI Requirements;

	public TextMeshProUGUI Label;

	public HttpImage IconImage;

	public GameObject ErrorPanel;

	public TextMeshProUGUI ErrorText;

	public GameObject CraftButton;

	public GameObject ProgressPanel;

	public SteamInventoryNewItem NewItemModal;
}


using UnityEngine;

public class SteamInventoryIcon : MonoBehaviour
{
}


using Facepunch.Extend;
using Rust.UI;
using TMPro;
using UnityEngine;

public class SteamInventoryItem : MonoBehaviour
{
	public IPlayerItem Item;

	public HttpImage Image;

	public bool Setup(IPlayerItem item)
	{
		Item = item;
		if (PlayerItemExtensions.GetDefinition(item) == null)
		{
			return false;
		}
		((TMP_Text)((Component)TransformEx.FindChildRecursive(((Component)this).transform, "ItemName")).GetComponent<TextMeshProUGUI>()).text = PlayerItemExtensions.GetDefinition(item).Name;
		return Image.Load(PlayerItemExtensions.GetDefinition(item).IconUrl);
	}
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;

public class SteamInventoryManager : SingletonComponent<SteamInventoryManager>
{
	public GameObject inventoryItemPrefab;

	public GameObject inventoryCanvas;

	public GameObject missingItems;

	public SteamInventoryCrafting CraftControl;

	public List<GameObject> items;

	public GameObject LoadingOverlay;
}


using System.Threading.Tasks;
using Rust.UI;
using UnityEngine;

public class SteamInventoryNewItem : MonoBehaviour
{
	public async Task Open(IPlayerItem item)
	{
		((Component)this).gameObject.SetActive(true);
		((Component)this).GetComponentInChildren<Rust.UI.SteamInventoryItem>().Setup(item);
		while (Object.op_Implicit((Object)(object)this) && ((Component)this).gameObject.activeSelf)
		{
			await Task.Delay(100);
		}
	}
}


using Rust.UI;
using UnityEngine;

public class ServerAdminConvarInfo : MonoBehaviour
{
	public RustText InfoName;

	public RustText InfoValue;

	public RustInput VariableInput;

	public Tooltip TooltipComponent;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminPlayerEntry : MonoBehaviour
{
	public RustText PlayerName;

	public RustText Ping;

	public RustButton Button;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminPlayerId : MonoBehaviour
{
	public RustText PlayerName;

	public RustText PlayerId;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminPlayerInfo : MonoBehaviour
{
	public RustText PlayerName;

	public RustText SteamID;

	public RustText OwnerSteamID;

	public RustText Ping;

	public RustText Address;

	public RustText ConnectedTime;

	public RustText ViolationLevel;

	public RustText Health;

	public RustInput KickReasonInput;

	public RustInput BanReasonInput;
}


using Rust.UI;
using UnityEngine;

public class ServerAdminServerInfo : MonoBehaviour
{
	public RustText InfoName;

	public RustText InfoValue;
}


using UnityEngine;

public class ServerAdminUGCEntry : MonoBehaviour
{
}


using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;

public class ServerAdminUGCEntryAudio : ServerAdminUGCEntry
{
	public AudioSource AudioSpeaker;

	public RustText DurationText;

	public RustSlider ProgressSlider;

	public RustIcon PlayIcon;
}


using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;
using UnityEngine.UI;

public class ServerAdminUGCEntryImage : ServerAdminUGCEntry
{
	public RawImage Image;

	public RectTransform Backing;

	public GameObject MultiImageRoot;

	public RustText ImageIndex;

	public Vector2 OriginalImageSize;
}


using Rust.UI.ServerAdmin;
using UnityEngine;

public class ServerAdminUGCEntryPattern : ServerAdminUGCEntry
{
	public GameObjectRef StarPrefab;

	public RectTransform StarRoot;
}


using Rust.UI.ServerAdmin;
using UnityEngine;
using UnityEngine.UI;

public class ServerAdminUGCEntrySculpture : ServerAdminUGCEntry
{
	public Camera Camera;

	public Material MaterialToUse;

	public RawImage Target;
}


using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;

public class ServerAdminUGCEntryStub : MonoBehaviour
{
	public ServerAdminUGCEntryAudio AudioWidget;

	public ServerAdminUGCEntryImage ImageWidget;

	public ServerAdminUGCEntryPattern PatternWidget;

	public ServerAdminUGCEntryVendingMachine VendingWidget;

	public ServerAdminUGCEntrySculpture SculptureWidget;

	public RustText PrefabName;

	public RustButton HistoryButton;

	public ServerAdminPlayerId[] HistoryIds = new ServerAdminPlayerId[0];
}


using Rust.UI;
using Rust.UI.ServerAdmin;

public class ServerAdminUGCEntryVendingMachine : ServerAdminUGCEntry
{
	public RustText NameLabel;
}


using Facepunch;
using Rust.UI;
using Rust.UI.ServerAdmin;
using UnityEngine;
using UnityEngine.UI;

public class ServerAdminUI : SingletonComponent<ServerAdminUI>
{
	public GameObjectRef PlayerEntry;

	public RectTransform PlayerInfoParent;

	public RustText PlayerCount;

	public RustInput PlayerNameFilter;

	public GameObjectRef ServerInfoEntry;

	public RectTransform ServerInfoParent;

	public GameObjectRef ConvarInfoEntry;

	public GameObjectRef ConvarInfoLongEntry;

	public RectTransform ConvarInfoParent;

	public ServerAdminPlayerInfo PlayerInfo;

	public RustInput UgcNameFilter;

	public GameObjectRef ImageEntry;

	public GameObjectRef PatternEntry;

	public GameObjectRef SoundEntry;

	public RustButton ShowWantedPostersButton;

	public VirtualScroll UgcVirtualScroll;

	public GameObject ExpandedUgcRoot;

	public RawImage ExpandedImage;

	public RectTransform ExpandedImageBacking;
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(Toggle))]
internal class ForceWeather : MonoBehaviour
{
	private Toggle component;

	public bool Rain;

	public bool Fog;

	public bool Wind;

	public bool Clouds;

	public void OnEnable()
	{
		component = ((Component)this).GetComponent<Toggle>();
	}

	public void Update()
	{
		if (!((Object)(object)SingletonComponent<Climate>.Instance == (Object)null))
		{
			if (Rain)
			{
				SingletonComponent<Climate>.Instance.Overrides.Rain = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Rain, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
			if (Fog)
			{
				SingletonComponent<Climate>.Instance.Overrides.Fog = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Fog, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
			if (Wind)
			{
				SingletonComponent<Climate>.Instance.Overrides.Wind = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Wind, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
			if (Clouds)
			{
				SingletonComponent<Climate>.Instance.Overrides.Clouds = Mathf.MoveTowards(SingletonComponent<Climate>.Instance.Overrides.Clouds, (float)(component.isOn ? 1 : 0), Time.deltaTime / 2f);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Development.Attributes;
using Rust.UI.MainMenu;
using UnityEngine;

[ResetStaticFields]
public class UI_MenuManager : SingletonComponent<UI_MenuManager>
{
	[SerializeField]
	private UI_Popup _genericPopupPrefab;

	[SerializeField]
	private Transform _genericPopupParent;

	[SerializeField]
	[Header("Background Image Settings")]
	private CanvasGroup _homeVideoOverlay;

	[SerializeField]
	private float _homeVideoOverlayAlpha = 1f;

	[SerializeField]
	private float _otherPageVideoOverlayAlpha = 0.98f;

	[SerializeField]
	private CanvasGroup _pageBackgroundOverlay;

	[SerializeField]
	private float _pageBackgroundOverlayAlpha = 0.98f;

	public static Action OnOpenStateChanged;

	private static bool _isOpen = true;

	public List<GameObject> HideInMenu = new List<GameObject>();

	public List<GameObject> HideInGame = new List<GameObject>();

	private UI_MenuNavigationGroup _navGroup;

	public Transform GenericPopupParent => _genericPopupParent;

	public static bool IsOpen => _isOpen;
}


using System;
using Rust.UI.MainMenu;
using UnityEngine;

[Serializable]
public class UI_NavigationEntry
{
	public string Path;

	public GameObject Reference;

	[NonSerialized]
	public UI_Page Page;

	public void Hide()
	{
		if (CheckReference() && (Object)(object)Page != (Object)null)
		{
			Page.Close();
		}
	}

	public void Show()
	{
		if (CheckReference() && (Object)(object)Page != (Object)null)
		{
			Page.Open();
		}
	}

	private bool CheckReference()
	{
		if ((Object)(object)Reference == (Object)null)
		{
			Debug.LogError((object)("Navigation Entry '" + Path + "' doesn't have a valid reference."));
			return false;
		}
		return true;
	}
}


using Rust.UI.MainMenu;

public abstract class UI_Page : UI_Window
{
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_RegisterNavigation : MonoBehaviour
{
	public UI_NavigationEntry NavigationEntry;

	public void Setup()
	{
		if (NavigationEntry != null)
		{
			SetupEntry();
		}
	}

	private void SetupEntry()
	{
		UI_Page page = default(UI_Page);
		if (!((Object)(object)NavigationEntry.Reference == (Object)null) && NavigationEntry.Reference.TryGetComponent<UI_Page>(ref page))
		{
			NavigationEntry.Page = page;
		}
	}
}


using UnityEngine;

public class UI_DemoWindowButton : MonoBehaviour
{
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UI_Hero_InfoBox : FacepunchBehaviour
{
	[SerializeField]
	[Header("References")]
	protected RustText _title;

	[SerializeField]
	protected RustText _subtitle;

	[SerializeField]
	protected RustText _tag;

	[SerializeField]
	protected CoverImage _coverImage;

	[SerializeField]
	protected RustButton _button;

	[SerializeField]
	protected FlexTransition _hoverFlex;

	[SerializeField]
	protected Image _blackout;

	[SerializeField]
	[Header("Settings")]
	private Phrase _titlePhrase;

	[SerializeField]
	private Phrase _subtitlePhrase;

	[SerializeField]
	protected Texture _image;

	[SerializeField]
	protected bool _internalLink;

	[SerializeField]
	protected string _linkUrl;
}


using Rust.UI;
using UnityEngine;

public class UI_PatchInfo : FacepunchBehaviour
{
	[SerializeField]
	private RustText _title;

	[SerializeField]
	private RustText _description;

	[SerializeField]
	private RustText _date;

	[SerializeField]
	private RustButton _readMoreButton;

	[SerializeField]
	private RustButton _changelogButton;

	[SerializeField]
	private GameObject _devlogTag;
}


using System.Collections.Generic;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_Hero_QuickJoin : UI_Hero_InfoBox
{
	[SerializeField]
	private List<UI_ServerEntry> _quickJoinEntries = new List<UI_ServerEntry>();
}


using Rust.UI;
using UnityEngine;

public class UI_Hero_QuickJoin_Entry : FacepunchBehaviour
{
	[SerializeField]
	private RustText _serverTitle;

	[SerializeField]
	private RustText _lastPlayed;

	[SerializeField]
	private RustButton _button;
}


using System.Collections.Generic;
using Facepunch.Flexbox;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class UI_Hero_Store : UI_Hero_InfoBox
{
	[SerializeField]
	[Header("Hero Store")]
	private VideoPlayer _video;

	[SerializeField]
	private GameObject _titleContainer;

	[SerializeField]
	private FlexTransition _loadingFlex;

	[SerializeField]
	private CanvasGroup _loadingGroup;

	[SerializeField]
	private RawImage _videoImage;

	[SerializeField]
	private List<Image> _progressBars;

	[SerializeField]
	private List<Image> _progressBarHolders;

	[Header("On Hover Animation")]
	[SerializeField]
	private CanvasGroup _menuBlurGroup;

	[SerializeField]
	private GameObject _expandButton;

	[SerializeField]
	private GameObject _viewInStoreButton;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_HomePage : UI_Page
{
	[SerializeField]
	private UI_Hero_QuickJoin _quickJoin;

	[SerializeField]
	private UI_Hero_Store _storeHero;
}


using Rust.UI;
using UnityEngine;

public class UI_NotificationEntry : MonoBehaviour
{
	[SerializeField]
	[Header("Icons")]
	private RustIcon _basicIcon;

	[SerializeField]
	private RustIcon _standardIcon;

	[SerializeField]
	private RustIcon _banIcon;

	[SerializeField]
	private RustIcon _warningIcon;

	[SerializeField]
	[Header("UI Elements")]
	private GameObject _linkIcon;

	[SerializeField]
	private RustButton _linkButton;

	[SerializeField]
	private RustText _notificationText;
}


public enum NotificationType
{
	Basic,
	Standard,
	Warning,
	Ban
}


using System;
using Rust.UI.MainMenu;

[Serializable]
public struct NotificationData
{
	public NotificationType NotificationType;

	public string NotificationText;

	public string NotificationLink;

	public bool IsInternal;

	public Phrase Phrase;

	public bool HasSeen;

	public int? Id;

	public object[] PhraseArguments;

	public bool HasLink => !string.IsNullOrEmpty(NotificationLink);

	public NotificationData(NotificationType type, string text, string link = "", bool isInternal = true, Phrase phrase = null, bool hasSeen = false, int? id = null, params object[] arguments)
	{
		NotificationType = type;
		NotificationText = text;
		NotificationLink = link;
		IsInternal = isInternal;
		Phrase = phrase;
		HasSeen = hasSeen;
		Id = id;
		PhraseArguments = arguments;
	}

	public override bool Equals(object obj)
	{
		if (obj is NotificationData notificationData)
		{
			if (NotificationText == notificationData.NotificationText)
			{
				return NotificationLink == notificationData.NotificationLink;
			}
			return false;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (NotificationText?.GetHashCode() ?? 0) + (NotificationLink?.GetHashCode() ?? 0);
	}
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_Notifications : UI_Window
{
	[Header("Prefab & Container")]
	[SerializeField]
	private GameObject _entryPrefab;

	[SerializeField]
	private RectTransform _contentRoot;

	[SerializeField]
	private GameObject _noNotifications;

	[SerializeField]
	private GameObject _circle;

	[SerializeField]
	private StyleAsset _regularStyle;

	[SerializeField]
	private StyleAsset _seenStyle;
}


using System;
using Rust.UI.MainMenu;

[Serializable]
internal struct ServerBrowserHeader
{
	public string AscendingSortOrder;

	public string DescendingSortOrder;

	public UI_ServerBrowser_Header Header;
}


using System;

[Serializable]
internal class ServerBrowserCategoryData
{
	public string Name;

	public ServerBrowserCategory Button;

	public ServerBrowserListBase List;
}


using System.Collections.Generic;
using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_ServerBrowserPage : UI_Page
{
	[SerializeField]
	private UI_ServerBrowser_RefreshButton _refreshButton;

	[SerializeField]
	private UI_ConnectModal _connectModal;

	[SerializeField]
	private UI_Window _shockbyteWindow;

	[Header("Categories")]
	[SerializeField]
	private List<ServerBrowserCategoryData> _categories;

	[SerializeField]
	[Header("Headers")]
	private List<ServerBrowserHeader> _headers;

	[Header("Filters")]
	[SerializeField]
	private RustButton _showEmptyToggle;

	[SerializeField]
	private RustButton _showFullToggle;

	[SerializeField]
	private RustButton _prioritisePremiumToggle;

	[SerializeField]
	private RustButton _useCacheToggle;

	[SerializeField]
	private RustInput _searchInput;

	[Header("No Results")]
	[SerializeField]
	private UI_ServerBrowser_NoResults_Controller _noResultsController;

	[Header("Other")]
	[SerializeField]
	private FlexTransition _favouritesButtonAnimation;

	[SerializeField]
	private GameObject _loadingSpinner;
}


using Facepunch.Flexbox;
using UnityEngine;

public class UI_ServerBrowser_Header : MonoBehaviour
{
	public enum HeaderState
	{
		None,
		Ascending,
		Descending
	}

	[Header("References")]
	[SerializeField]
	private FlexTransition _ascendingTransition;

	[SerializeField]
	private FlexTransition _descendingTransition;
}


public enum HeaderState
{
	None,
	Ascending,
	Descending
}


using System.Collections.Generic;
using UnityEngine;

public class UI_ServerBrowser_ModifyComponentsOnCategory : MonoBehaviour
{
	[SerializeField]
	private List<GameObject> _disableComponentsWhileActive = new List<GameObject>();

	[SerializeField]
	private List<GameObject> _enableComponentsWhileActive = new List<GameObject>();
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UI_ServerBrowser_NoResults_Controller : MonoBehaviour
{
	[SerializeField]
	private CanvasGroup _noServersFound;

	[SerializeField]
	private RustButton _button;

	[SerializeField]
	private FlexTransition _transition;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UIElements;

public class UI_ServerBrowser_RefreshButton : RustButton
{
	[SerializeField]
	private UI_LoadingRotate loadingRotate;

	[SerializeField]
	private Image refreshOverview;

	[SerializeField]
	private RustText text;

	private Phrase _refreshPhrase = new Phrase("serverbrowser.refresh", "Refresh");

	private Phrase _cancelPhrase = new Phrase("serverbrowser.cancel", "Cancel");

	public void SetRefreshState(bool state)
	{
		if (!((Object)(object)loadingRotate == (Object)null))
		{
			if (state)
			{
				loadingRotate.ContinuouslyRotate(state: true);
				((RustButton)this).SetToggleVisualOn();
				text.SetPhrase(_cancelPhrase, Array.Empty<object>());
			}
			else
			{
				loadingRotate.Reset();
				loadingRotate.ContinuouslyRotate(state: false);
				((RustButton)this).SetToggleVisualOff();
				text.SetPhrase(_refreshPhrase, Array.Empty<object>());
			}
		}
	}
}


using System;
using Rust.UI;
using TMPro;
using UnityEngine;

public class UI_ServerBrowser_TagModifierButton : RustButton
{
	[Header("Tag Modifier Button")]
	[SerializeField]
	private string _serverTag;

	[SerializeField]
	private RustText _countText;

	private string _tag;

	private LTDescr _countTween;

	public string ServerTag => _serverTag;

	public string CompactTag
	{
		get
		{
			if (_tag == null)
			{
				_tag = ServerTagCompressor.ShortenTag(_serverTag);
			}
			return _tag;
		}
	}

	public void SetCount(int count)
	{
		if (!((Object)(object)_countText == (Object)null))
		{
			if (_countTween != null)
			{
				LeanTween.cancel(_countTween.id);
			}
			int.TryParse(((TMP_Text)_countText).text, out var result);
			_countTween = LeanTween.value(((Component)this).gameObject, (float)result, (float)count, 0.2f).setEaseOutQuad().setOnUpdate((Action<float>)delegate(float val)
			{
				int num = Mathf.RoundToInt(val);
				((TMP_Text)_countText).text = num.ToString();
			});
		}
	}
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UI_ServerEntry : MonoBehaviour
{
	[Header("References")]
	[SerializeField]
	private RustButton _button;

	[SerializeField]
	private RustText _serverNameText;

	[SerializeField]
	private RustText _modeText;

	[SerializeField]
	private RustText _playerCurrentText;

	[SerializeField]
	private RustText _playerMaxText;

	[SerializeField]
	private RustText _pingText;

	[SerializeField]
	private RustText _mapTypeText;

	[SerializeField]
	private ServerBrowserTagList _tagController;

	[SerializeField]
	private GameObject _favouritingParticlesPrefab;

	[Header("References - Last Played")]
	[SerializeField]
	private RustText _lastPlayedText;

	[SerializeField]
	private GameObject _lastPlayedObject;

	[Header("References - Friends")]
	[SerializeField]
	private RustText _friendsText;

	[SerializeField]
	private GameObject _friendsObject;

	[SerializeField]
	private Tooltip _friendsTooltip;

	[SerializeField]
	[Header("References - Queue")]
	private RustText _queueText;

	[SerializeField]
	private GameObject _queueObject;

	[SerializeField]
	[Header("References - Favourites")]
	private RustButton _favouritesButton;

	[SerializeField]
	private FlexTransition _favouritesTransition;

	[SerializeField]
	private RectTransform _favouritesSpawnPoint;

	[Header("References - Styles")]
	[SerializeField]
	private StyleAsset _evenStyle;

	[SerializeField]
	private StyleAsset _oddStyle;

	[SerializeField]
	private StyleAsset _favouriteStyle;

	[Header("Other")]
	[SerializeField]
	private bool _joinOnClick;

	public static Phrase LastJoinedPhrase = (Phrase)(object)new TokenisedPhrase("serverentry.lastplayed.ago", "{0} ago");

	public static Phrase FriendsPhrase = (Phrase)(object)new TokenisedPhrase("serverentry.friends", "{0} friends");
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UI_TabBox : MonoBehaviour
{
	[SerializeField]
	private bool _autoClose = true;

	[SerializeField]
	private RustText _filterEnabledText;

	[SerializeField]
	private RustButton _collapseButton;

	[SerializeField]
	private Image _spacerImage;

	public static readonly Phrase FiltersPhrase = new Phrase("tabbox.filters", "{0} filters");

	public static readonly Phrase EnabledPhrase = new Phrase("tabbox.filters.enabled", "enabled");

	public static readonly Phrase DisabledPhrase = new Phrase("tabbox.filters.disabled", "disabled");
}


using System;
using System.Collections.Generic;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_TagController : MonoBehaviour
{
	[Serializable]
	public class TagData
	{
		public string TagName;

		public GameObject TagObject;
	}

	[SerializeField]
	private List<TagData> _tags = new List<TagData>();

	public void ClearTags()
	{
		foreach (TagData tag in _tags)
		{
			if (tag.TagObject.activeInHierarchy)
			{
				tag.TagObject.SetActive(false);
			}
		}
	}

	public void EnableTag(string tagName)
	{
		foreach (TagData tag in _tags)
		{
			if (tag.TagName == tagName && !tag.TagObject.activeInHierarchy)
			{
				tag.TagObject.SetActive(true);
				return;
			}
		}
		Debug.LogError((object)("Tag '" + tagName + "' not found in the list."));
	}
}


using System;
using UnityEngine;

[Serializable]
public class TagData
{
	public string TagName;

	public GameObject TagObject;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SessionPage : UI_Page
{
	public static UI_SessionPage Instance;

	public HttpImage serverLogoImage;

	[SerializeField]
	private RustText _topServerName;

	[SerializeField]
	private GameObject _rustPlusBanner;

	[SerializeField]
	private GameObject _connectToServerButton;

	[SerializeField]
	private GameObject _quitButton;

	[SerializeField]
	private GameObject _quitDemo;

	[SerializeField]
	private GameObject _quitTutorial;

	[SerializeField]
	private RustButton _rustPlusButton;

	[SerializeField]
	private RustButton _tutorialButton;

	[SerializeField]
	private UI_ConnectModal _connectModal;

	[SerializeField]
	private CompanionSetupScreen _setupScreen;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_ConnectModal : UI_Window
{
	[Header("References")]
	[SerializeField]
	private RustText _title;

	[SerializeField]
	private RustText _description;

	[SerializeField]
	private HttpImage _headerImage;

	[SerializeField]
	private GameObject _headerImageLoading;

	[SerializeField]
	private ServerBrowserTagList _tagController;

	[SerializeField]
	private RustText _mapTypeText;

	[SerializeField]
	private RustButton _websiteButton;

	[SerializeField]
	private Tooltip _websiteTooltip;

	[SerializeField]
	private GameObject _descriptionLoading;

	[SerializeField]
	private GameObject _connectToServerButton;

	[SerializeField]
	private GameObject _needsPremiumButton;

	[SerializeField]
	private GameObject _mapButton;

	[SerializeField]
	private UI_ServerMap _map;

	[Header("References - Friends")]
	[SerializeField]
	private RustText _friendsText;

	[SerializeField]
	private GameObject _friendsObject;

	[SerializeField]
	private Tooltip _friendsTooltip;

	[Header("Info Box References")]
	[SerializeField]
	private RustText _playerCount;

	[SerializeField]
	private GameObject _queuedPlayersObject;

	[SerializeField]
	private RustText _queuedPlayersCount;

	[SerializeField]
	private GameObject _lastPlayedObject;

	[SerializeField]
	private RustText _lastPlayedText;

	[SerializeField]
	private GameObject _wipedObject;

	[SerializeField]
	private RustText _wipedText;

	[SerializeField]
	private ScrollRect _scrollRect;

	[SerializeField]
	private RectMask2D _scrollMask;

	public static Phrase lastPlayedPhrase = new Phrase("connection.modal.lastplayed.ago", "{0} ago");

	public static Phrase serverAgePhrase = new Phrase("connection.modal.serverage.old", "{0} old");

	public static Phrase loadingError = new Phrase("connection.modal.error", "Error loading server");
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
public class UI_FoilShaderMouseFollow : MonoBehaviour
{
	[Header("Foil Shader Settings")]
	[SerializeField]
	private RawImage _rawImage;

	[SerializeField]
	private Image _image;

	[SerializeField]
	private float _rotationSpeed = 10f;

	[SerializeField]
	private float _tiltSensitivity = 3f;

	[SerializeField]
	private float _maxTilt = 10f;

	[Header("Global Settings")]
	[SerializeField]
	private bool _useGlobal;

	[SerializeField]
	[Range(0f, 1f)]
	private float _normalisedMaxGlobalDistance;
}


using UnityEngine;

public class UI_HideTutorialCategory : MonoBehaviour
{
	[SerializeField]
	private GameObject _tutorialCategoryButton;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_InteractionToast : UI_Window
{
	[Header("Interaction Modal")]
	[SerializeField]
	private RustText _text;

	[SerializeField]
	private GameObject _informationPanel;

	[SerializeField]
	private RustText _informationTitle;

	[SerializeField]
	private RustText _informationText;

	[SerializeField]
	private RustButton _firstButton;

	[SerializeField]
	private RustButton _secondButton;

	[SerializeField]
	private RustIcon _firstIcon;

	[SerializeField]
	private RustIcon _secondIcon;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_ServerMap : UI_Window
{
	[Header("References")]
	[SerializeField]
	private HttpImage _httpImage;

	[SerializeField]
	private GameObject _loadingObject;

	[SerializeField]
	private RustButton _gridButton;
}


using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.Video;

public class UI_TutorialModal : UI_Window
{
	[SerializeField]
	private RustButton _acceptButton;

	[SerializeField]
	private List<RustButton> _declineButtons;

	[SerializeField]
	private VideoPlayer _videoPlayer;
}


using System;
using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_MenuNavigationGroup : UI_RustButtonGroup
{
	[Serializable]
	private class TabButton
	{
		public RustButton Button;

		public string Path;
	}

	[Header("Navigation Groups (IGNORE BUTTON GROUPS - Just Add Here)")]
	[SerializeField]
	private List<TabButton> _navigationGroups = new List<TabButton>();
}


using System;

[Serializable]
private class TabButton
{
	public RustButton Button;

	public string Path;
}


public static class UI_Utils
{
	private static Phrase _monthSingularPhrase = new Phrase("time.month", "month");

	private static Phrase _monthsPhrase = new Phrase("time.months", "months");

	private static Phrase _weekSingularPhrase = new Phrase("time.week", "week");

	private static Phrase _weeksPhrase = new Phrase("time.weeks", "weeks");

	private static Phrase _daysSingularPhrase = new Phrase("time.day", "day");

	private static Phrase _daysPhrase = new Phrase("time.days", "days");

	private static Phrase _hourSingularPhrase = new Phrase("time.hour", "hour");

	private static Phrase _hoursPhrase = new Phrase("time.hours", "hours");

	private static Phrase _minuteSingularPhrase = new Phrase("time.minute", "minute");

	private static Phrase _minutesPhrase = new Phrase("time.minutes", "minutes");

	private static Phrase _secondSingularPhrase = new Phrase("time.second", "second");

	private static Phrase _secondsPhrase = new Phrase("time.seconds", "seconds");
}


using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class CompanionSetupScreen : UI_Window
{
	public enum ScreenState
	{
		Loading,
		Error,
		NoServer,
		NotSupported,
		NotInstalled,
		Disabled,
		Enabled,
		ShowHelp
	}

	public const string PairedKey = "companionPaired";

	public GameObject pleaseSignInMessage;

	public GameObject loadingMessage;

	public GameObject errorMessage;

	public GameObject notSupportedMessage;

	public GameObject disabledMessage;

	public GameObject enabledMessage;

	public GameObject refreshButton;

	public GameObject enableButton;

	public GameObject disableButton;

	public GameObject pairButton;

	public RustText serverName;

	public FlexTransition removeFooterTransition;
}


public enum ScreenState
{
	Loading,
	Error,
	NoServer,
	NotSupported,
	NotInstalled,
	Disabled,
	Enabled,
	ShowHelp
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class Hero : SingletonComponent<Hero>
{
	public CanvasGroup CanvasGroup;

	public Video VideoPlayer;

	public RustText TitleText;

	public RustText ButtonText;

	public HttpImage TitleImage;

	[Header("Item Store Links")]
	public RustButton ItemStoreButton;

	public RustButton LimitedTabButton;

	public RustButton GeneralTabButton;
}


using Coffee.UIEffects;
using UnityEngine;

[RequireComponent(typeof(RectTransform))]
public class GradientMouseFollow : MonoBehaviour
{
	[SerializeField]
	private UIGradient gradient;
}


using Development.Attributes;

[ResetStaticFields]
public static class SteamInventoryRecipeIndex
{
}


using System;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SteamInventoryCraftingModal : UI_SteamInventoryItemBaseModal
{
	[Serializable]
	public struct MaterialGroup
	{
		public GameObject GameObject;

		public RustText CountText;

		public Image BackgroundImage;
	}

	[SerializeField]
	private MaterialGroup woodGroup;

	[SerializeField]
	private MaterialGroup metalGroup;

	[SerializeField]
	private MaterialGroup clothGroup;

	[Space]
	[SerializeField]
	private GameObject craftOK;

	[SerializeField]
	private GameObject craftKO;

	[SerializeField]
	private UI_SteamInventoryNewItemModal newItemModal;
}


using System;
using UnityEngine;
using UnityEngine.UI;

[Serializable]
public struct MaterialGroup
{
	public GameObject GameObject;

	public RustText CountText;

	public Image BackgroundImage;
}


using System;
using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SteamInventoryItemBaseModal : UI_Window
{
	[Serializable]
	private struct Tag
	{
		public string Name;

		public GameObject GameObject;
	}

	[SerializeField]
	protected HttpImage iconImage;

	[SerializeField]
	protected RustText nameText;

	[SerializeField]
	protected RustText descText;

	[SerializeField]
	protected RustText itemTypeText;

	[SerializeField]
	private UI_BackgroundAspectRatioFitter background;

	[SerializeField]
	[Header("Marketable Tag")]
	private GameObject marketablePriceGroup;

	[SerializeField]
	private GameObject marketableLockedGroup;

	[SerializeField]
	protected RustText daysLeftText;

	[SerializeField]
	protected RustText priceText;

	[SerializeField]
	private List<Tag> tagDefinitions = new List<Tag>();

	[Header("Skin Viewer")]
	[SerializeField]
	private CoverImage skinViewerImage;

	[SerializeField]
	private GameObject icon2D;

	[SerializeField]
	private GameObject icon3D;

	[SerializeField]
	private GameObject skinFullscreenButton;

	[SerializeField]
	private GameObject loadingOverlay;

	[SerializeField]
	private Color loadingColor;

	[SerializeField]
	private AnimationCurve loadingCompletePunchCurve;
}


using System;
using UnityEngine;

[Serializable]
private struct Tag
{
	public string Name;

	public GameObject GameObject;
}


using Rust.UI.MainMenu;

public class UI_SteamInventoryNewItemModal : UI_Window
{
	public UI_SteamInventoryItem uiItem;

	private IPlayerItem _item;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SteamInventoryPlayerItemModal : UI_SteamInventoryItemBaseModal
{
	[Header("Breakdown")]
	[SerializeField]
	private GameObject breakdownGroup;

	[SerializeField]
	private GameObject notScrappableGroup;

	[SerializeField]
	protected UI_SteamInventoryCraftingModal.MaterialGroup woodGroup;

	[SerializeField]
	protected UI_SteamInventoryCraftingModal.MaterialGroup metalGroup;

	[SerializeField]
	protected UI_SteamInventoryCraftingModal.MaterialGroup clothGroup;

	[Header("Breakdown Controls")]
	[SerializeField]
	private GameObject breakdownButtonGroup;

	[SerializeField]
	private GameObject cantBreakdownButtonGroup;

	[SerializeField]
	private GameObject deleteButtonGroup;

	[SerializeField]
	private RustText cantBreakdownReasonText;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SteamInventory : UI_Page
{
	public static UI_SteamInventory Instance;

	[SerializeField]
	private FlexVirtualScroll virtualScrollFlex;

	[Space]
	[SerializeField]
	private UI_SteamInventoryCrafting crafting;

	[SerializeField]
	private UI_SteamInventoryItem inventoryItemPrefab;

	[SerializeField]
	private RectTransform inventoryItemParent;

	[Space]
	public GameObject loadingOverlay;

	[SerializeField]
	private UI_StoreTakeover takeovers;

	[SerializeField]
	private RustButton refreshButton;

	[SerializeField]
	private RustInput searchBar;

	public static UI_SteamInventoryCrafting Crafting => Instance?.crafting;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SteamInventoryCrafting : MonoBehaviour
{
	[SerializeField]
	private RustText clothAmountText;

	[SerializeField]
	private RustText woodAmountText;

	[SerializeField]
	private RustText metalAmountText;

	[SerializeField]
	[Space]
	private Transform craftingButtonParent;

	[SerializeField]
	private GameObject craftingButtonPrefab;

	[SerializeField]
	private UI_SteamInventoryNewItemModal newItemModal;

	[SerializeField]
	private UI_SteamInventoryCraftingModal craftingModal;

	[SerializeField]
	[Space]
	private UI_SteamInventoryPlayerItemModal bagOpeningModal;

	[SerializeField]
	private UI_SteamInventoryPlayerItemModal playerItemModal;

	[SerializeField]
	private UI_Popup deleteWarningPopup;

	[SerializeField]
	private UI_Popup craftingWarningPopup;
}


using Rust.UI;
using UnityEngine;

public class UI_SteamInventoryItem : MonoBehaviour
{
	public RustButton button;

	[SerializeField]
	private HttpImage image;

	[SerializeField]
	private GameObject takeoverGroup;

	[SerializeField]
	private CoverImage takeoverImage;

	[SerializeField]
	private RustText nameText;

	[SerializeField]
	private RustText subtitleText;

	[SerializeField]
	private GameObject twitchDropTag;

	public IPlayerItem PlayerItem;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class UI_SettingsGestureButton : UI_SettingsGestureDraggable
{
	[SerializeField]
	private StyleAsset unlockedStyle;

	[SerializeField]
	private StyleAsset lockedStyle;

	[Space]
	[SerializeField]
	private GameObject boundLine;

	[SerializeField]
	private GameObject dragIcon;

	[SerializeField]
	private Image gestureIcon;

	[SerializeField]
	private RustText gestureNameText;

	[Space]
	[SerializeField]
	private RectTransform videoPreview;

	[SerializeField]
	private VideoPlayer videoPlayer;

	[SerializeField]
	private RawImage videoRawTexture;

	[SerializeField]
	[Space]
	private GameObject deleteButton;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public abstract class UI_SettingsGestureDraggable : BaseMonoBehaviour
{
	[SerializeField]
	public RustButton button;

	[SerializeField]
	private GameObject draggedPrefab;

	public GestureConfig gestureConfig { get; private set; }

	public UI_SettingsGestureWheel wheel { get; private set; }
}


using Rust.UI;
using UnityEngine;

public class UI_SettingsGesturePack : MonoBehaviour
{
	[SerializeField]
	private RustText headerText;

	[SerializeField]
	public RectTransform contentParent;

	[SerializeField]
	private GameObject storeButton;

	[SerializeField]
	private GameObject lockIcon;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsGestureWheel : MonoBehaviour
{
	[SerializeField]
	private RustText wheelHeaderText;

	[SerializeField]
	private RustButton leftArrowButton;

	[SerializeField]
	private RustButton rightArrowButton;

	[SerializeField]
	[Space]
	private UI_SettingsGestureWidget[] gestureWidgets;

	[SerializeField]
	private RustText gestureTitleText;

	[SerializeField]
	private RustText gestureDescriptionText;

	[SerializeField]
	private Image gestureIcon;

	[Space]
	[SerializeField]
	private RectTransform wheelCenter;

	[SerializeField]
	private float radius = 100f;

	[SerializeField]
	private float initialAngleOffset;

	[Space]
	[SerializeField]
	private UI_SettingsGestureButton gestureButtonPrefab;

	[Space]
	[SerializeField]
	private RectTransform ownedButtonsParent;

	[SerializeField]
	private RectTransform lockedPacksParent;

	[SerializeField]
	private UI_SettingsGesturePack packPrefab;

	[Space]
	[SerializeField]
	public RectTransform dragAndDropCanvas;

	[SerializeField]
	private CanvasGroup assignOverlay;

	[SerializeField]
	private Canvas buttonListCanvas;

	[Space]
	[SerializeField]
	private GameObject hoveredGestureTexts;

	[SerializeField]
	private GameObject emptyWheelTexts;
}


using LeTai.TrueShadow;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsGestureWidget : UI_SettingsGestureDraggable
{
	[SerializeField]
	private StyleAsset boundStyle;

	[SerializeField]
	private StyleAsset emptyStyle;

	[Space]
	[SerializeField]
	private Image gestureIcon;

	[SerializeField]
	private GameObject emptyIcon;

	[SerializeField]
	private GameObject hoverImage;

	[SerializeField]
	private Canvas canvas;

	[SerializeField]
	private TrueShadow shadow;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class PopulateResolutionDropdown : MonoBehaviour
{
	public UI_SettingsTweakDropdown Dropdown;
}


using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsApplyTweakChanges : MonoBehaviour
{
	public Button ApplyButton;

	public RustButton applyButton;

	public FlexTransition flexTransition;

	public UI_SettingsTweakConvar[] Options;
}


using Rust.UI;
using UnityEngine;

public class UI_SettingsFramerateSlider : MonoBehaviour
{
	public RustSlider slider;

	public RustInput rustInput;
}


using Rust.UI;
using UnityEngine;

public class UI_SettingsKeyBindButton : MonoBehaviour
{
	[HideInInspector]
	public string currentBind;

	public RustButton button;

	public StyleAsset boundStyle;

	public StyleAsset notBoundStyle;

	public RustText text;
}


using UnityEngine;

public abstract class UI_SettingsTweakBase : MonoBehaviour
{
	public Phrase tooltip;

	public Sprite tooltipImage;

	public string tooltipVideoURL;

	[Tooltip("For any clickable URL in the tooltip.")]
	public string tooltipExternalURL;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsTweakColour : UI_SettingsTweakConvar
{
	public Image BackgroundImage;

	public RustButton Opener;

	public RectTransform Dropdown;

	public RectTransform DropdownContainer;

	public GameObject DropdownItemPrefab;

	public AccessibilityColourCollection forColourCollection;

	public AccessibilityMaterialCollection forMaterialCollection;

	public int currentValue;
}


using Rust.UI.MainMenu;
using UnityEngine.Events;

public class UI_SettingsTweakConvar : UI_SettingsTweakBase
{
	public string convarName;

	public bool ApplyImmediatelyOnChange = true;

	public UnityEvent onValueChanged = new UnityEvent();
}


using System;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsTweakDropdown : UI_SettingsTweakConvar
{
	[Serializable]
	public class NameValue
	{
		public string value;

		public Color imageColor;

		public Phrase label;

		public string untranslatedLabel;

		public bool rightToLeft;

		public bool useColorInsteadOfText;
	}

	public RustText Current;

	public Image CurrentColor;

	public RustButton Opener;

	public RectTransform Dropdown;

	public RectTransform DropdownContainer;

	public GameObject DropdownItemPrefab;

	public NameValue[] nameValues;

	public bool forceEnglish;

	[HideInInspector]
	public int currentValue;
}


using System;
using UnityEngine;

[Serializable]
public class NameValue
{
	public string value;

	public Color imageColor;

	public Phrase label;

	public string untranslatedLabel;

	public bool rightToLeft;

	public bool useColorInsteadOfText;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UI_SettingsTweakDropdownItem : MonoBehaviour
{
	public Image Image;

	public RustText Text;

	[Space]
	public StyleAsset DefaultStyle;

	public StyleAsset SelectedStyle;

	public RustButton Button;

	public void SetSelected(bool selected)
	{
		((RustControl)Button).Styles = (selected ? SelectedStyle : DefaultStyle);
		((RustControl)Button).ApplyStyles();
	}
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SettingsTweakKeyBind : UI_SettingsTweakBase
{
	[Space]
	public GameObject blockingCanvas;

	public RustButton button;

	public RustText labelText;

	public UI_SettingsKeyBindButton btnA;

	public UI_SettingsKeyBindButton btnB;

	public CanvasGroup resetButton;

	public string bindString;

	public static bool IsBinding { get; private set; }
}


using Rust.UI.MainMenu;

public class UI_SettingsTweakPresetGraphics : UI_SettingsTweakPresetSelect
{
}


using System;
using Rust.UI.MainMenu;

public class UI_SettingsTweakPresetSelect : UI_SettingsTweakDropdown
{
	[Serializable]
	public struct Presets
	{
		public string[] PresetValues;
	}

	public string StreamingAssetsFilename = "";

	public UI_SettingsTweakConvar[] TargetOptions;

	public string[] AdditionalTargetOptions;

	public Presets[] PresetsArray;

	public int CustomIndex;
}


using System;

[Serializable]
public struct Presets
{
	public string[] PresetValues;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine.Events;

public class UI_SettingsTweakSlider : UI_SettingsTweakConvar
{
	public RustSlider rustSliderControl;

	public RustInput rustInput;

	public bool applyOnMouseUp;

	private TimeSince mouseDown;

	public UnityEvent OnMouseUp;

	private float GetSliderValue()
	{
		return rustSliderControl.Value;
	}
}


using Rust.UI;
using Rust.UI.MainMenu;

public class UI_SettingsTweakToggle : UI_SettingsTweakConvar
{
	public RustButton buttonControl;

	public bool inverse;

	public static string lastConVarChanged;

	public static TimeSince timeSinceLastConVarChange;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_Popup_CrosshairImportExport : UI_Popup
{
	[SerializeField]
	private bool isExport;

	[SerializeField]
	private RustInput inputField;

	[SerializeField]
	private RustText placeHolderTextField;

	[SerializeField]
	private RustText copyButtonTextField;

	[SerializeField]
	private Image inputFieldBackgroundImage;

	[SerializeField]
	private Color defaultBackgroundColor;

	[SerializeField]
	private Color failedBackgroundColor;

	public Phrase placeHolderPhrase;

	public Phrase invalidCodePhrase;

	public Phrase copyCodePhrase;

	public Phrase copiedPhrase;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SafeModeWarning : UI_Popup, IClientComponent
{
	[Space]
	[SerializeField]
	private GameObject yesButton;

	[SerializeField]
	private GameObject timer;

	[SerializeField]
	private RustText timerText;

	[SerializeField]
	private float timeToWait = 5f;
}


using System;
using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_Settings : UI_Page
{
	[Serializable]
	private class SettingTab
	{
		public string name;

		public UI_SettingsTabButton tabButton;

		public GameObject content;

		[ReadOnly]
		public List<SettingEntry> settings;

		public RustButton button => tabButton.button;

		public CanvasGroup canvasGroup => tabButton.canvasGroup;
	}

	private class SettingEntry
	{
		[NonSerialized]
		public SettingTab ownerTab;

		public string convarName;

		public string nameToken;

		public UI_SettingsTweakBase tweakUIBase;

		private CanvasGroup _canvasGroup;

		private RustText _labelText;

		private RustButton _button;

		private string searchIndex;

		public GameObject gameObject
		{
			get
			{
				UI_SettingsTweakBase uI_SettingsTweakBase = tweakUIBase;
				if (uI_SettingsTweakBase == null)
				{
					return null;
				}
				return ((Component)uI_SettingsTweakBase).gameObject;
			}
		}

		public CanvasGroup canvasGroup
		{
			get
			{
				if ((Object)(object)_canvasGroup == (Object)null)
				{
					_canvasGroup = gameObject.GetComponent<CanvasGroup>();
				}
				return _canvasGroup;
			}
		}

		public RustText labelText
		{
			get
			{
				if ((Object)(object)_labelText == (Object)null)
				{
					_labelText = gameObject.GetComponentInChildren<RustText>();
				}
				return _labelText;
			}
		}

		public RustButton button
		{
			get
			{
				if ((Object)(object)_button == (Object)null)
				{
					_button = gameObject.GetComponent<RustButton>();
				}
				return _button;
			}
		}

		public SettingEntry(string convarName, UI_SettingsTweakBase tweakUIBase)
		{
			this.convarName = convarName;
			this.tweakUIBase = tweakUIBase;
		}

		public string GetSettingName()
		{
			return Translate.Get(nameToken, (string)null, false);
		}

		public string GetTooltip()
		{
			return Translate.Get(tweakUIBase.tooltip.token, (string)null, false);
		}

		public void BuildSearchIndex()
		{
			searchIndex = string.Join(" ", GetSettingName(), GetTooltip());
		}

		public bool Matches(string query)
		{
			if (string.IsNullOrWhiteSpace(query))
			{
				return false;
			}
			string[] array = query.Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries);
			foreach (string text in array)
			{
				int startIndex = 0;
				while (true)
				{
					int num = searchIndex.IndexOf(text, startIndex, StringComparison.OrdinalIgnoreCase);
					if (num < 0)
					{
						break;
					}
					if (!RustText.IsInsideTag(searchIndex, num))
					{
						return true;
					}
					startIndex = num + text.Length;
				}
			}
			return false;
		}
	}

	[SerializeField]
	private List<SettingTab> tabs;

	[SerializeField]
	private UI_SearchBar searchBar;

	[SerializeField]
	[Space]
	private GameObject gestureGroup;

	[SerializeField]
	private CanvasGroup tooltipGroup;

	[SerializeField]
	private RustText tooltipNameText;

	[SerializeField]
	private RustText tooltipDescText;

	[SerializeField]
	private CanvasGroup tooltipImageGroup;

	[SerializeField]
	private CoverImage tooltipImage;

	[SerializeField]
	private CoverVideo tooltipVideo;

	[Space]
	[SerializeField]
	private ScrollRect scrollRect;

	[SerializeField]
	private CanvasGroup scrollbar;

	[SerializeField]
	private RectMask2D mask;

	[SerializeField]
	private UI_Popup safeModePopupPrefab;

	[SerializeField]
	private UI_SettingsGestureWheel gestureWheel;

	[SerializeField]
	private GameObject previewCrosshair;

	[SerializeField]
	private UI_Popup_CrosshairImportExport crosshairImportPopupPrefab;

	[SerializeField]
	private UI_Popup_CrosshairImportExport crosshairExportPopupPrefab;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
private class SettingTab
{
	public string name;

	public UI_SettingsTabButton tabButton;

	public GameObject content;

	[ReadOnly]
	public List<SettingEntry> settings;

	public RustButton button => tabButton.button;

	public CanvasGroup canvasGroup => tabButton.canvasGroup;
}


using System;
using UnityEngine;

private class SettingEntry
{
	[NonSerialized]
	public SettingTab ownerTab;

	public string convarName;

	public string nameToken;

	public UI_SettingsTweakBase tweakUIBase;

	private CanvasGroup _canvasGroup;

	private RustText _labelText;

	private RustButton _button;

	private string searchIndex;

	public GameObject gameObject
	{
		get
		{
			UI_SettingsTweakBase uI_SettingsTweakBase = tweakUIBase;
			if (uI_SettingsTweakBase == null)
			{
				return null;
			}
			return ((Component)uI_SettingsTweakBase).gameObject;
		}
	}

	public CanvasGroup canvasGroup
	{
		get
		{
			if ((Object)(object)_canvasGroup == (Object)null)
			{
				_canvasGroup = gameObject.GetComponent<CanvasGroup>();
			}
			return _canvasGroup;
		}
	}

	public RustText labelText
	{
		get
		{
			if ((Object)(object)_labelText == (Object)null)
			{
				_labelText = gameObject.GetComponentInChildren<RustText>();
			}
			return _labelText;
		}
	}

	public RustButton button
	{
		get
		{
			if ((Object)(object)_button == (Object)null)
			{
				_button = gameObject.GetComponent<RustButton>();
			}
			return _button;
		}
	}

	public SettingEntry(string convarName, UI_SettingsTweakBase tweakUIBase)
	{
		this.convarName = convarName;
		this.tweakUIBase = tweakUIBase;
	}

	public string GetSettingName()
	{
		return Translate.Get(nameToken, (string)null, false);
	}

	public string GetTooltip()
	{
		return Translate.Get(tweakUIBase.tooltip.token, (string)null, false);
	}

	public void BuildSearchIndex()
	{
		searchIndex = string.Join(" ", GetSettingName(), GetTooltip());
	}

	public bool Matches(string query)
	{
		if (string.IsNullOrWhiteSpace(query))
		{
			return false;
		}
		string[] array = query.Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries);
		foreach (string text in array)
		{
			int startIndex = 0;
			while (true)
			{
				int num = searchIndex.IndexOf(text, startIndex, StringComparison.OrdinalIgnoreCase);
				if (num < 0)
				{
					break;
				}
				if (!RustText.IsInsideTag(searchIndex, num))
				{
					return true;
				}
				startIndex = num + text.Length;
			}
		}
		return false;
	}
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_SettingsKeyBindsTab : MonoBehaviour
{
	private UI_SettingsTweakKeyBind[] keybinds;

	public static string keyDefaults;
}


using Rust.UI;
using UnityEngine;

public class UI_SettingsTabButton : MonoBehaviour
{
	public RustButton button;

	public CanvasGroup canvasGroup;

	public GameObject searchResult;

	public RustText searchResultCountText;

	public void SetSearchResult(int matchCount)
	{
		canvasGroup.alpha = ((matchCount != 0) ? 1f : 0.3f);
		searchResult.SetActive(matchCount != 0);
		if (matchCount != 0)
		{
			searchResultCountText.SetText(matchCount.ToString());
		}
	}

	public void CancelSearch()
	{
		canvasGroup.alpha = 1f;
		searchResult.SetActive(false);
	}
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreCart : UI_Window
{
	public static readonly Phrase CartEmptyPhrase = new Phrase("store.cart", "Cart");

	public static readonly Phrase CartPhrase = new Phrase("store.cart.items", "Cart ({0})");

	[Space]
	[SerializeField]
	private StyleAsset emptyStyle;

	[SerializeField]
	private StyleAsset notEmptySyle;

	[SerializeField]
	private RustButton cartButton;

	[SerializeField]
	private Canvas cartButtonCanvas;

	[SerializeField]
	private RustText cartButtonText;

	[SerializeField]
	private RustText itemCountText;

	[SerializeField]
	private RustText totalValueText;

	[Space]
	[SerializeField]
	private RectTransform itemParent;

	[SerializeField]
	private GameObject cartItemPrefab;

	[SerializeField]
	private RustButton checkoutButton;

	[SerializeField]
	private GameObject emptyGroup;

	[SerializeField]
	private GameObject footer;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreCartItem : MonoBehaviour
{
	public RustButton closeButton;

	public StoreSource source;

	private IPlayerItemDefinition _item;
}


public static class IPlayerItemDefinitionExtensions
{
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UI_StoreGeneralSubTabButton : BaseMonoBehaviour
{
	[SerializeField]
	private FlexTransition transition;

	[Space]
	[SerializeField]
	private FlexElement flexElement;

	[SerializeField]
	private FlexElement textParent;

	[SerializeField]
	private RustText text;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreGeneralTabButton : MonoBehaviour
{
	[SerializeField]
	private UI_StoreGeneralTab generalTab;
}


public static class PriceFormatter
{
}


using Rust.UI.MainMenu;

public class UI_StoreDLCTab : UI_StoreTabBase
{
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreFeaturedTab : UI_StoreTabBase
{
	[Space]
	[SerializeField]
	private UI_StoreCountdown countdown;
}


using System;
using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreGeneralTab : UI_StoreTabBase
{
	[Serializable]
	public struct Section
	{
		public string Name;

		public GameObject Group;

		public RectTransform MarkdownTarget;

		public RustButton Button;
	}

	[SerializeField]
	[Space]
	private ScrollRect scrollRect;

	[SerializeField]
	private RectTransform content;

	[SerializeField]
	private FlexElement scrollRectContentFlex;

	[Space]
	[SerializeField]
	private Section[] sections;

	[SerializeField]
	private RectMask2D mask;
}


using System;
using UnityEngine;

[Serializable]
public struct Section
{
	public string Name;

	public GameObject Group;

	public RectTransform MarkdownTarget;

	public RustButton Button;
}


using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreLimitedTab : UI_StoreTabBase
{
	[SerializeField]
	[Space]
	private UI_StoreItemGrid itemGrid;

	[SerializeField]
	private UI_StoreCountdown countdown;

	[SerializeField]
	private Scrollbar scrollbar;

	[SerializeField]
	private ScrollRect scrollRect;
}


using Rust.UI.MainMenu;

public class UI_StoreTabBase : UI_Window
{
	protected UI_Store store;
}


using System;
using System.Collections.Generic;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_Store : UI_Page
{
	[Serializable]
	private class StoreTab
	{
		public string name;

		public RustButton button;

		public UI_StoreTabBase page;
	}

	private const string JOURNEY_ID_KEY = "journey_id";

	public static UI_Store Instance;

	[SerializeField]
	private List<StoreTab> tabs;

	[SerializeField]
	private SteamDLCItem[] dlcItems;

	[SerializeField]
	private UI_StoreLimitedItemModal weeklySkinModal;

	[SerializeField]
	private UI_StoreCart cart;

	[SerializeField]
	private RectTransform pageOverlayParent;

	[SerializeField]
	private GameObject loadingOverlay;

	[SerializeField]
	private GameObject noConnectionOverlay;

	public UI_StoreTakeover Takeovers;

	public UI_StoreCheckoutResultPage checkoutResultPagePrefab;

	[SerializeField]
	private GameObject newHeaderButtonTag;

	public static int CurrentWeekID;

	private const string CART_KEY = "STORE_CART_ITEMS";

	[SerializeField]
	[Header("Search")]
	private UI_StoreItemGrid searchGrid;

	[SerializeField]
	private RustText searchSubtitleText;

	public static Guid JourneyId
	{
		get
		{
			if (Guid.TryParse(PlayerPrefs.GetString("journey_id", ""), out var result))
			{
				return result;
			}
			Guid result2 = Guid.NewGuid();
			PlayerPrefs.SetString("journey_id", result2.ToString());
			PlayerPrefs.Save();
			return result2;
		}
		private set
		{
			PlayerPrefs.SetString("journey_id", value.ToString());
			PlayerPrefs.Save();
		}
	}

	public void EnsureJourneyId()
	{
		_ = JourneyId;
	}

	public void CreateNewJourneyId()
	{
		PlayerPrefs.DeleteKey("journey_id");
		PlayerPrefs.Save();
		EnsureJourneyId();
	}

	private StoreSource ParseSource(string query)
	{
		StoreSource result = default(StoreSource);
		string[] array = query.Split('&');
		foreach (string text in array)
		{
			if (text.StartsWith("source_area="))
			{
				result.source_area = text.Substring(12);
			}
			else if (text.StartsWith("source="))
			{
				result.source = text.Substring(7);
			}
			else if (text.StartsWith("source_id="))
			{
				result.source_id = text.Substring(10);
			}
		}
		return result;
	}
}


using System;

[Serializable]
private class StoreTab
{
	public string name;

	public RustButton button;

	public UI_StoreTabBase page;
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreAddCartButton : ListComponent<UI_StoreAddCartButton>
{
	[SerializeField]
	private StyleAsset notInCartStyle;

	[SerializeField]
	private StyleAsset inCartStyle;

	[SerializeField]
	private RustButton button;

	[SerializeField]
	private RustText priceText;

	[SerializeField]
	private GameObject discountTag;

	[SerializeField]
	private RustText discountText;

	[Space]
	[SerializeField]
	private Animator animator;

	[SerializeField]
	private UI_StoreCartButtonAnimation animationSequence;

	[Space]
	[SerializeField]
	private Rust.UI.SteamInventoryItem autoInitItem;
}


using UnityEngine;
using UnityEngine.UI;

public class UI_StoreBackground : BaseMonoBehaviour
{
	public RectTransform viewport;

	public RectTransform section;

	public Image backgroundImage;

	public float fadeRange = 400f;

	public float fadeSpeed = 5f;
}


using System;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreCarrouselButton : MonoBehaviour
{
	public RustButton button;

	[Space]
	public RustText titleText;

	public RustText subtitleText;

	public CoverImage coverImage;

	public GameObject videoIcon;

	[Space]
	public GameObject gaugeParent;

	public Image gaugeImage;

	public GameObject variantGroup;

	public RustText variantText;

	public void UpdateGauge(float fillAmount)
	{
		if (fillAmount != 0f && !gaugeParent.activeInHierarchy)
		{
			gaugeParent.SetActive(true);
		}
		else if (fillAmount == 0f && gaugeParent.activeInHierarchy)
		{
			gaugeParent.SetActive(false);
		}
		gaugeImage.fillAmount = fillAmount;
	}

	public void Init(IPlayerItemDefinition itemDef)
	{
	}

	public void Init(UI_StoreItemOverlayPage.PageElement element, UI_StoreItemOverlayPage page)
	{
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		if (element.Name != null && !string.IsNullOrEmpty(element.Name.english))
		{
			titleText.SetPhrase(element.Name, Array.Empty<object>());
		}
		else if ((Object)(object)element.Item != (Object)null)
		{
			titleText.SetPhrase(element.Item.displayName, Array.Empty<object>());
		}
		videoIcon.SetActive(element.isVideo);
		Sprite val = (((Object)(object)element.FullscreenSprite == (Object)null) ? element.GallerySprite : element.FullscreenSprite);
		Sprite val2 = null;
		if ((Object)(object)val != (Object)null && (Object)(object)page.SmallAtlas != (Object)null)
		{
			Rect rect = val.rect;
			if (((Rect)(ref rect)).width > 512f)
			{
				rect = val.rect;
				if (((Rect)(ref rect)).height > 512f)
				{
					val2 = page.SmallAtlas.GetSprite(((Object)val).name);
				}
			}
		}
		coverImage.sprite = (((Object)(object)val2 != (Object)null) ? val2 : val);
		variantGroup.SetActive(element.VariantCount > 0);
		variantText.SetText(element.VariantCount.ToString());
	}
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UI_StoreCartButtonAnimation : BaseMonoBehaviour
{
	[SerializeField]
	private CanvasGroup loading;

	[SerializeField]
	private GameObject addToCartGroup;

	[Space]
	[SerializeField]
	private FlexElement inCartGroup;

	[SerializeField]
	private FlexElement inCartTextParent;

	[SerializeField]
	private RustFlexText inCartText;

	[SerializeField]
	private FlexGraphicTransform inCartIcon;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreCheckoutResultButton : MonoBehaviour
{
	public RustButton button;

	[Space]
	[SerializeField]
	private RustText titleText;

	[SerializeField]
	private RustText subtitleText;

	[Space]
	[SerializeField]
	private CoverImage takeoverImage;

	[SerializeField]
	private HttpImage httpImage;

	[SerializeField]
	[Space]
	private GameObject gaugeParent;

	[SerializeField]
	private Image gaugeImage;

	[Space]
	[Header("Animation")]
	[SerializeField]
	private CanvasGroup canvasGroup;
}


using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreCheckoutResultPage : UI_Window
{
	[Space]
	[SerializeField]
	private FlexTransition crossFadeTransition;

	[SerializeField]
	private CoverImage coverBackground;

	[SerializeField]
	private Sprite defaultBackground;

	[SerializeField]
	private RustText itemNameText;

	[SerializeField]
	private RustText itemSubtitleText;

	[Space]
	[SerializeField]
	private UI_StoreCheckoutResultButton carrouselButtonPrefab;

	[SerializeField]
	private RectTransform buttonsParent;

	[SerializeField]
	[Space]
	private GraphicRaycaster footerGraphicRaycaster;

	[SerializeField]
	private CanvasGroup arrowButtons;

	[SerializeField]
	private ScrollRect scrollRect;

	[SerializeField]
	private FlexElement scrollContentFlex;

	[SerializeField]
	private CanvasGroup leftArrow;

	[SerializeField]
	private CanvasGroup rightArrow;

	[SerializeField]
	private bool autoCycleEnabled = true;

	[SerializeField]
	private float autoCycleInterval = 10f;

	[SerializeField]
	private UI_StoreTakeover localTakeovers;

	[SerializeField]
	[Space]
	[Header("Skin Viewer")]
	private CoverImage skinViewerImage;

	[SerializeField]
	private GameObject icon3D;

	[SerializeField]
	private GameObject icon2D;

	[SerializeField]
	private GameObject loadingOverlay;

	[SerializeField]
	protected HttpImage iconImage;

	[Header("Intro Sequence")]
	[SerializeField]
	private CanvasGroup fadeOverlay;

	[SerializeField]
	private CanvasGroup inventoryButton;
}


using Rust.UI;
using UnityEngine;

public class UI_StoreCountdown : MonoBehaviour
{
	[SerializeField]
	private RustText refreshesInText;

	[SerializeField]
	private RustText countdownText;
}


using Rust.UI.MainMenu;

public class UI_StoreFakeItemsTakeover : UI_StoreTakeover
{
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreItemDLC : MonoBehaviour
{
	public int appID;

	public UI_StoreItemOverlayPage overlayPagePrefab;

	public UI_StoreAddCartButton cartButton;

	private IPlayerItemDefinition _item;
}


using System;

[Serializable]
public struct StoreSource
{
	public string source_area;

	public string source;

	public string source_id;
}


using System;
using System.Collections.Generic;
using Facepunch.Flexbox;
using Rust.UI.MainMenu;
using UnityEngine;

[RequireComponent(typeof(FlexGridsElement))]
public class UI_StoreItemGrid : MonoBehaviour
{
	public enum OrderingRule
	{
		TakeoverOrder,
		WhitelistOrder,
		OwnedLast,
		OwnedFirst,
		PriceLowToHigh,
		PriceHighToLow,
		Alphabetical,
		ReverseAlphabetical,
		FeaturedFirst,
		LargestFirst,
		Random,
		FeaturedLast,
		FakeItemsOrder,
		FeaturingOrder
	}

	public enum RuleMatchMode
	{
		All,
		Any
	}

	public enum FilterRule
	{
		TagInclude,
		TagExclude,
		OnlyFeatured,
		ExcludeFeatured,
		NeedTakeOver,
		ItemShortName,
		ExcludeOwned
	}

	[Serializable]
	public class StoreFilterRule
	{
		public bool enabled = true;

		public FilterRule ruleType;

		public List<string> tags = new List<string>();

		public List<string> itemShortNames = new List<string>();
	}

	[Serializable]
	public struct ItemSizeSettings
	{
		public SteamInventoryItem Item;

		public int ItemID;

		[Range(1f, 12f)]
		public int SizeX;

		[Range(1f, 5f)]
		public int SizeY;

		public int GetItemID
		{
			get
			{
				if (!((Object)(object)Item != (Object)null))
				{
					return ItemID;
				}
				return Item.id;
			}
		}
	}

	[SerializeField]
	private FlexGridsElement grid;

	[SerializeField]
	[Tooltip("The source of the items, for analytics")]
	private StoreSource source;

	[Space]
	[SerializeField]
	private UI_StoreItemTile skinItemTilePrefab;

	[SerializeField]
	private UI_StoreItemTile featuredSkinItemTilePrefab;

	[SerializeField]
	private bool allowExtraItems;

	[SerializeField]
	private int maxCellCount;

	[SerializeField]
	[Min(0f)]
	public int cellWidth;

	[Min(0f)]
	[SerializeField]
	public int cellHeight;

	public bool fixedGrid;

	public List<Vector2Int> fixedSizes = new List<Vector2Int>();

	[SerializeField]
	private bool autoSizing;

	[SerializeField]
	private Vector2 baseItemSize = new Vector2(1f, 1f);

	[SerializeField]
	private Vector2 featuredItemSize;

	[SerializeField]
	private ItemSizeSettings[] sizeOverrides;

	[SerializeField]
	private List<OrderingRule> orderingRules = new List<OrderingRule>();

	[SerializeField]
	private List<SteamInventoryItem> whiteListedItems = new List<SteamInventoryItem>();

	[SerializeField]
	private UI_StoreFakeItemsTakeover fakeAdditionalItems;

	public bool dynamicContent = true;

	[SerializeField]
	private RuleMatchMode ruleMatchMode = RuleMatchMode.Any;

	[SerializeField]
	private List<StoreFilterRule> rules = new List<StoreFilterRule>();

	public FlexGridsElement Grid => grid;

	private UI_Store store => UI_Store.Instance;
}


public enum OrderingRule
{
	TakeoverOrder,
	WhitelistOrder,
	OwnedLast,
	OwnedFirst,
	PriceLowToHigh,
	PriceHighToLow,
	Alphabetical,
	ReverseAlphabetical,
	FeaturedFirst,
	LargestFirst,
	Random,
	FeaturedLast,
	FakeItemsOrder,
	FeaturingOrder
}


public enum RuleMatchMode
{
	All,
	Any
}


public enum FilterRule
{
	TagInclude,
	TagExclude,
	OnlyFeatured,
	ExcludeFeatured,
	NeedTakeOver,
	ItemShortName,
	ExcludeOwned
}


using System;
using System.Collections.Generic;

[Serializable]
public class StoreFilterRule
{
	public bool enabled = true;

	public FilterRule ruleType;

	public List<string> tags = new List<string>();

	public List<string> itemShortNames = new List<string>();
}


using System;
using UnityEngine;

[Serializable]
public struct ItemSizeSettings
{
	public global::SteamInventoryItem Item;

	public int ItemID;

	[Range(1f, 12f)]
	public int SizeX;

	[Range(1f, 5f)]
	public int SizeY;

	public int GetItemID
	{
		get
		{
			if (!((Object)(object)Item != (Object)null))
			{
				return ItemID;
			}
			return Item.id;
		}
	}
}


using System;
using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.U2D;
using UnityEngine.UI;

public class UI_StoreItemOverlayPage : UI_Window
{
	[Serializable]
	public struct PageElement
	{
		public Phrase Name;

		[ItemSelector]
		public ItemDefinition Item;

		public bool isVideo;

		public string videoURL;

		public Sprite FullscreenSprite;

		public Sprite GallerySprite;

		[Min(0f)]
		public int VariantCount;

		public bool overrideItem;

		public Phrase ItemName;

		public Sprite ItemIcon;

		public Phrase GetTitle()
		{
			if (Name != null && !string.IsNullOrEmpty(Name.english))
			{
				return Name;
			}
			if ((Object)(object)Item != (Object)null)
			{
				return Item.displayName;
			}
			return Phrase.op_Implicit(string.Empty);
		}

		public Phrase GetRedirectItemName()
		{
			if ((Object)(object)Item != (Object)null && (Object)(object)Item.isRedirectOf != (Object)null)
			{
				return Item.isRedirectOf.displayName;
			}
			if (overrideItem)
			{
				return ItemName;
			}
			return null;
		}

		public Sprite GetRedirectItemIcon()
		{
			if ((Object)(object)Item != (Object)null && (Object)(object)Item.isRedirectOf != (Object)null)
			{
				return Item.isRedirectOf.iconSprite;
			}
			if (overrideItem)
			{
				return ItemIcon;
			}
			return null;
		}
	}

	[Serializable]
	public struct PageContent
	{
		public PageElement[] Elements;
	}

	[Space]
	[Header("Page Content")]
	[SerializeField]
	private FlexTransition crossFadeTransition;

	[SerializeField]
	private CoverVideo coverVideo;

	[SerializeField]
	private CoverImage coverImage;

	[SerializeField]
	private UI_BackgroundAspectRatioFitter coverBackground;

	[SerializeField]
	private GameObject textContainerGroup;

	[SerializeField]
	private RustText titleText;

	[SerializeField]
	private GameObject itemGroup;

	[SerializeField]
	private RustText itemNameText;

	[SerializeField]
	private Image itemIconImage;

	[SerializeField]
	private GameObject variantGroup;

	[SerializeField]
	private RustText variantCoutText;

	[Header("Gallery")]
	public SpriteAtlas SmallAtlas;

	[SerializeField]
	private Transform galleryParent;

	[SerializeField]
	private CanvasGroup arrowButtons;

	[SerializeField]
	private ScrollRect scrollRect;

	[SerializeField]
	private CanvasGroup leftArrow;

	[SerializeField]
	private CanvasGroup rightArrow;

	[SerializeField]
	private UI_StoreAddCartButton cartButton;

	[SerializeField]
	private GameObject ownedButton;

	[SerializeField]
	[Space]
	private bool autoCycleEnabled = true;

	[SerializeField]
	private float autoCycleInterval = 10f;

	[SerializeField]
	private UI_StoreCarrouselButton carouselButtonPrefab;

	[Space]
	[SerializeField]
	private PageContent pageContent;
}


using System;
using UnityEngine;

[Serializable]
public struct PageElement
{
	public Phrase Name;

	[ItemSelector]
	public ItemDefinition Item;

	public bool isVideo;

	public string videoURL;

	public Sprite FullscreenSprite;

	public Sprite GallerySprite;

	[Min(0f)]
	public int VariantCount;

	public bool overrideItem;

	public Phrase ItemName;

	public Sprite ItemIcon;

	public Phrase GetTitle()
	{
		if (Name != null && !string.IsNullOrEmpty(Name.english))
		{
			return Name;
		}
		if ((Object)(object)Item != (Object)null)
		{
			return Item.displayName;
		}
		return Phrase.op_Implicit(string.Empty);
	}

	public Phrase GetRedirectItemName()
	{
		if ((Object)(object)Item != (Object)null && (Object)(object)Item.isRedirectOf != (Object)null)
		{
			return Item.isRedirectOf.displayName;
		}
		if (overrideItem)
		{
			return ItemName;
		}
		return null;
	}

	public Sprite GetRedirectItemIcon()
	{
		if ((Object)(object)Item != (Object)null && (Object)(object)Item.isRedirectOf != (Object)null)
		{
			return Item.isRedirectOf.iconSprite;
		}
		if (overrideItem)
		{
			return ItemIcon;
		}
		return null;
	}
}


using System;

[Serializable]
public struct PageContent
{
	public PageElement[] Elements;
}


using Facepunch.Flexbox;
using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreItemTile : BaseMonoBehaviour
{
	public RustButton button;

	[SerializeField]
	public CanvasGroup animatedParent;

	[SerializeField]
	private RustText skinNameText;

	[SerializeField]
	private RustText itemTypeText;

	[SerializeField]
	[Space]
	private CanvasGroup imageGroup;

	[SerializeField]
	protected HttpImage httpImage;

	[SerializeField]
	private CoverVideo coverVideo;

	[SerializeField]
	public CoverImage coverImage;

	[SerializeField]
	[Space]
	[Header("Header")]
	private GameObject headerTextGroup;

	[SerializeField]
	private RustText headerText;

	[SerializeField]
	private FlexElement paddedContainer;

	[SerializeField]
	private UI_StoreAddCartButton cartButton;

	[SerializeField]
	[Space]
	private GameObject ownedTag;

	[SerializeField]
	private bool disableCartWhenOwned;

	[SerializeField]
	private bool fadeIconWhenOwned = true;
}


using System.Collections.Generic;
using Rust.UI.MainMenu;
using UnityEngine;
using UnityEngine.UI;

public class UI_StoreItemTileWeeklySkin : UI_StoreItemTile
{
	[SerializeField]
	private bool applyIconColor;

	[SerializeField]
	private bool animatedShimmers;

	[SerializeField]
	private Image coloredGradient;

	private static readonly Dictionary<IPlayerItemDefinition, Color> CachedGradientColors = new Dictionary<IPlayerItemDefinition, Color>();

	private static readonly int ShimmerStrength = Shader.PropertyToID("_ShimmerStrength");

	private static readonly int ShimmerSpeed = Shader.PropertyToID("_ShimmerSpeed");

	[SerializeField]
	private float idleShimmerStrength;

	[SerializeField]
	private float idleShimmerSpeed;

	[SerializeField]
	private float hoverShimmerStrength = 0.154f;

	[SerializeField]
	private float hoverShimmerSpeed = 0.03f;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreLimitedItemModal : UI_SteamInventoryPlayerItemModal
{
	[SerializeField]
	private UI_StoreAddCartButton cartButton;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StorePackShowcase : MonoBehaviour
{
	public SteamInventoryItem item;

	public UI_StoreAddCartButton cartButton;

	public GameObject background;
}


using System;
using Facepunch.Models;
using Rust.UI.MainMenu;
using UnityEngine;

[Serializable]
public struct ItemStoreTakeover
{
	public Phrase NameOverride;

	public Phrase SubtitleOverride;

	public Phrase HeaderPhrase;

	public Sprite IconOverride;

	public Sprite IconPortraitOverride;

	public Sprite IconSquareOverride;

	public string ImageURL;

	public string VideoURL;

	public UI_StoreItemOverlayPage PagePrefab;

	public UI_StoreItemTile TilePrefabOverride;

	public SteamInventoryItem Item;

	[Tooltip("Will be used if you don't have an Item definition (DLCs)")]
	public int ItemId;

	public readonly int GetItemID()
	{
		if (!((Object)(object)Item != (Object)null))
		{
			return ItemId;
		}
		return Item.id;
	}

	public ItemStoreTakeover(StoreFeaturing storeFeaturing)
	{
		NameOverride = Phrase.op_Implicit(storeFeaturing.TitleText);
		SubtitleOverride = Phrase.op_Implicit(storeFeaturing.SubtitleText);
		HeaderPhrase = Phrase.op_Implicit(storeFeaturing.HeaderText);
		ImageURL = storeFeaturing.ImageUrl;
		VideoURL = storeFeaturing.VideoUrl;
		ItemId = storeFeaturing.ItemID;
		IconOverride = null;
		IconPortraitOverride = null;
		IconSquareOverride = null;
		PagePrefab = null;
		TilePrefabOverride = null;
		Item = null;
	}

	public readonly bool IsValid()
	{
		return GetItemID() != 0;
	}

	public void OverridesWith(ItemStoreTakeover other)
	{
		if (!string.IsNullOrEmpty(other.NameOverride.translated))
		{
			NameOverride = other.NameOverride;
		}
		if (!string.IsNullOrEmpty(other.SubtitleOverride.translated))
		{
			SubtitleOverride = other.SubtitleOverride;
		}
		if (other.HeaderPhrase != null && !string.IsNullOrEmpty(other.HeaderPhrase.translated))
		{
			HeaderPhrase = other.HeaderPhrase;
		}
		if ((Object)(object)other.IconOverride != (Object)null)
		{
			IconOverride = other.IconOverride;
		}
		if ((Object)(object)other.IconPortraitOverride != (Object)null)
		{
			IconPortraitOverride = other.IconPortraitOverride;
		}
		if ((Object)(object)other.IconSquareOverride != (Object)null)
		{
			IconSquareOverride = other.IconSquareOverride;
		}
		if (!string.IsNullOrEmpty(other.ImageURL))
		{
			ImageURL = other.ImageURL;
		}
		if (!string.IsNullOrEmpty(other.VideoURL))
		{
			VideoURL = other.VideoURL;
		}
		if ((Object)(object)other.PagePrefab != (Object)null)
		{
			PagePrefab = other.PagePrefab;
		}
		if ((Object)(object)other.TilePrefabOverride != (Object)null)
		{
			TilePrefabOverride = other.TilePrefabOverride;
		}
		if ((Object)(object)other.Item != (Object)null)
		{
			Item = other.Item;
		}
		if (other.ItemId != 0)
		{
			ItemId = other.ItemId;
		}
	}

	public Sprite GetBestIconForRect(float width, float height)
	{
		float num = width / height;
		bool flag = num > 1.15f;
		bool flag2 = num < 0.8f;
		if (flag)
		{
			return IconOverride;
		}
		if (flag2)
		{
			if ((Object)(object)IconPortraitOverride != (Object)null)
			{
				return IconPortraitOverride;
			}
			return IconOverride;
		}
		if ((Object)(object)IconSquareOverride != (Object)null)
		{
			return IconSquareOverride;
		}
		return IconOverride;
	}
}


using System;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_StoreTakeover : MonoBehaviour
{
	public bool ignoreFeaturingTakeovers;

	public ItemStoreTakeover[] Takeovers = Array.Empty<ItemStoreTakeover>();
}


using UnityEngine;

public class UI_BackgroundAspectRatioFitter : MonoBehaviour
{
	public RectTransform rectTransform;

	public Vector2 offset;
}


using UnityEngine;

public class UI_MainMenuNavigate : MonoBehaviour
{
}


using Rust.UI;
using Rust.UI.MainMenu;
using UnityEngine;

public class UI_Popup : UI_Window
{
	[SerializeField]
	[Space]
	private Transform buttonsParent;

	[SerializeField]
	private RustText titleText;

	[SerializeField]
	private RustText messageText;

	[SerializeField]
	private RustButton buttonTemplate;

	[SerializeField]
	private RustButton[] buttons;
}


using System;
using Facepunch.Flexbox;
using UnityEngine;

public class UI_Window : BaseMonoBehaviour
{
	[SerializeField]
	private bool _skipAutoFixState;

	[SerializeField]
	[Header("Window - Transitions")]
	private FlexTransition _openTransition;

	[SerializeField]
	private bool _oneShotTransition;

	[SerializeField]
	[Header("Window - Canvas")]
	protected CanvasGroup _group;

	[SerializeField]
	[Header("Window - Escape Capture")]
	protected UIEscapeCapture _escape;

	[SerializeField]
	[Header("Window - Flex Element")]
	private FlexElement _flex;

	protected bool _firstTimeOpened = true;

	protected bool _opened;

	public event Action OnOpen;

	public event Action OnClose;

	protected virtual void Awake()
	{
		if (!_opened && !_skipAutoFixState)
		{
			FixBrokenState();
		}
	}

	private void FixBrokenState()
	{
		TimeWarning val = TimeWarning.New("UI_Window.FixBrokenState", 0);
		try
		{
			if ((Object)(object)_group == (Object)null)
			{
				if (((Component)this).gameObject.activeSelf)
				{
					((Component)this).gameObject.SetActive(false);
				}
				return;
			}
			if (!((Component)this).gameObject.activeSelf)
			{
				((Component)this).gameObject.SetActive(true);
			}
			SetUI(state: false);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void Open()
	{
		if (!_opened)
		{
			_opened = true;
			SetUI(state: true);
			OnOpened();
			if (_firstTimeOpened)
			{
				_firstTimeOpened = false;
			}
		}
	}

	public virtual void Close()
	{
		if (_opened)
		{
			_opened = false;
			SetUI(state: false);
			OnClosed();
		}
	}

	public bool IsOpen()
	{
		return _opened;
	}

	protected virtual void OnOpened()
	{
		this.OnOpen?.Invoke();
		if (Object.op_Implicit((Object)(object)_openTransition))
		{
			if (_oneShotTransition)
			{
				_openTransition.PlayOneOff();
			}
			else
			{
				_openTransition.SwitchState(true, true);
			}
		}
	}

	protected virtual void OnClosed()
	{
		this.OnClose?.Invoke();
		if (Object.op_Implicit((Object)(object)_openTransition))
		{
			_openTransition.SwitchState(false, false);
		}
	}

	public virtual void SetUI(bool state)
	{
		if ((Object)(object)_group == (Object)null)
		{
			((Component)this).gameObject.SetActive(state);
		}
		else
		{
			if (state && !((Component)this).gameObject.activeSelf)
			{
				((Component)this).gameObject.SetActive(true);
			}
			_group.alpha = (state ? 1 : 0);
			_group.interactable = state;
			_group.blocksRaycasts = state;
		}
		if ((Object)(object)_escape != (Object)null)
		{
			((Behaviour)_escape).enabled = state;
		}
		if ((Object)(object)_flex != (Object)null)
		{
			((Behaviour)_flex).enabled = state;
		}
	}
}


using Rust.UI;
using Rust.UI.MainMenu;
using Rust.UI.MainMenu.Workshop;
using UnityEngine;

public class UI_Workshop : UI_Page
{
	public static UI_Workshop Instance;

	[SerializeField]
	private UI_WorkshopItemList itemList;

	[SerializeField]
	private RustButton initialTabButton;

	public static Phrase loading_workshop = (Phrase)(object)new TokenisedPhrase("loading.workshop", "Loading Workshop");

	public static Phrase loading_workshop_setup = (Phrase)(object)new TokenisedPhrase("loading.workshop.initializing", "Setting Up Scene");

	public static Phrase loading_workshop_skinnables = (Phrase)(object)new TokenisedPhrase("loading.workshop.skinnables", "Getting Skinnables");

	public static Phrase loading_workshop_item = (Phrase)(object)new TokenisedPhrase("loading.workshop.item", "Loading Item Data");

	private readonly Phrase createNewSkinPhrase = new Phrase("workshop.createskin.title", "Create skin");

	private readonly Phrase createNewSkinBodyPhrase = new Phrase("workshop.createskin.body", "Do you want to create a new skin? This will load the workshop scene.");

	private readonly Phrase yesPhrase = new Phrase("workshop.continue", "Continue");

	private readonly Phrase cancelPhrase = new Phrase("workshop.cancel", "Cancel");
}


using Rust.UI;
using UnityEngine;

public class UI_WorkshopItemButton : MonoBehaviour
{
	[SerializeField]
	private HttpImage httpImage;

	[SerializeField]
	private Transform scaledParent;

	[SerializeField]
	private GameObject loadingIndicator;
}


using Rust.UI;
using Rust.UI.MainMenu.Workshop;
using UnityEngine;

public class UI_WorkshopItemList : MonoBehaviour
{
	[SerializeField]
	private RustButton previousPageButton;

	[SerializeField]
	private RustButton nextPageButton;

	[SerializeField]
	private UI_WorkshopItemButton itemPrefab;

	[SerializeField]
	private UI_WorkshopItemButton myItemPrefab;

	[SerializeField]
	private Transform itemsParent;

	[SerializeField]
	private RustText pageInfoText;

	[SerializeField]
	private Dropdown itemTypeSelector;
}


using System;
using System.Collections.Generic;
using Benchmark;
using ProtoBuf;
using UnityEngine;

[JsonModel]
public class Building
{
	[JsonModel]
	public class Entity
	{
		public ulong NetId;

		public string ResPath;

		public ulong ParentNetId;

		public Vector3 Pos;

		public Vector3 RotEuler;

		public ulong SkinID;

		public virtual void FromProto(Entity ent)
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			NetId = ent.baseNetworkable.uid.Value;
			ResPath = StringPool.Get(ent.baseNetworkable.prefabID);
			ParentNetId = ent.parent?.uid.Value ?? 0;
			Pos = ent.baseEntity.pos;
			RotEuler = ent.baseEntity.rot;
			SkinID = ent.baseEntity.skinid;
		}
	}

	[JsonModel]
	public class BuildingEntity : Entity
	{
		public BuildingGrade.Enum Grade;

		public ulong Model;

		public override void FromProto(Entity ent)
		{
			base.FromProto(ent);
			if (ent.buildingBlock != null)
			{
				Grade = (BuildingGrade.Enum)ent.buildingBlock.grade;
				Model = ent.buildingBlock.model;
			}
			else
			{
				Grade = BuildingGrade.Enum.None;
				Model = 0uL;
			}
		}
	}

	[JsonModel]
	public class SpawnMarker
	{
		[Flags]
		public enum SpawnType
		{
			LocalPlayer = 1,
			RemotePlayer = 2
		}

		public Vector3 Pos;

		public Vector3 RotEuler;

		public SpawnType Type;
	}

	public const uint InvalidBuildingId = 0u;

	public uint Id;

	public List<BuildingEntity> BuildingEntities;

	public List<SpawnMarker> SpawnMarkers;

	public Building(uint id)
	{
		Id = id;
		BuildingEntities = new List<BuildingEntity>();
		SpawnMarkers = new List<SpawnMarker>();
	}

	public override string ToString()
	{
		return $"{Id}: {BuildingEntities.Count} entities";
	}
}


using ProtoBuf;
using UnityEngine;

[JsonModel]
public class Entity
{
	public ulong NetId;

	public string ResPath;

	public ulong ParentNetId;

	public Vector3 Pos;

	public Vector3 RotEuler;

	public ulong SkinID;

	public virtual void FromProto(Entity ent)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		NetId = ent.baseNetworkable.uid.Value;
		ResPath = StringPool.Get(ent.baseNetworkable.prefabID);
		ParentNetId = ent.parent?.uid.Value ?? 0;
		Pos = ent.baseEntity.pos;
		RotEuler = ent.baseEntity.rot;
		SkinID = ent.baseEntity.skinid;
	}
}


using ProtoBuf;

[JsonModel]
public class BuildingEntity : Entity
{
	public BuildingGrade.Enum Grade;

	public ulong Model;

	public override void FromProto(Entity ent)
	{
		base.FromProto(ent);
		if (ent.buildingBlock != null)
		{
			Grade = (BuildingGrade.Enum)ent.buildingBlock.grade;
			Model = ent.buildingBlock.model;
		}
		else
		{
			Grade = BuildingGrade.Enum.None;
			Model = 0uL;
		}
	}
}


using System;
using UnityEngine;

[JsonModel]
public class SpawnMarker
{
	[Flags]
	public enum SpawnType
	{
		LocalPlayer = 1,
		RemotePlayer = 2
	}

	public Vector3 Pos;

	public Vector3 RotEuler;

	public SpawnType Type;
}


using System;

[Flags]
public enum SpawnType
{
	LocalPlayer = 1,
	RemotePlayer = 2
}


using System;
using AntiHackJobs;
using BasePlayerJobs;
using CoarseQueryGridJobs;
using CompanionServer.Cameras;
using Facepunch.MarchingCubes;
using Facepunch.NativeMeshSimplification;
using GamePhysicsJobs;
using GenerateErosionJobs;
using HitBoxSystemJobs;
using Instancing;
using OceanSimulationJobs;
using ProjectileJobs;
using Rust.Water5;
using ServerOcclusionJobs;
using TerrainHeightMapJobs;
using TerrainTexturingJobs;
using TerrainTopologyMapJobs;
using TerrainWaterMapJobs;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.Jobs;
using UtilityJobs;
using WaterLevelJobs;
using WaterSystemJobs;

[DOTSCompilerGenerated]
internal class __JobReflectionRegistrationOutput__1221673671587648887
{
	public static void CreateJobReflectionData()
	{
		try
		{
			IJobExtensions.EarlyJobInit<FishShoal.FishCollisionGatherJob>();
			IJobExtensions.EarlyJobInit<FishShoal.FishCollisionProcessJob>();
			IJobParallelForExtensions.EarlyJobInit<FishShoal.FishUpdateJob>();
			IJobExtensions.EarlyJobInit<FishShoal.KillFish>();
			IJobParallelForTransformExtensions.EarlyJobInit<QueryVisJobs.ConstructCommandsJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<QueryVisJobs.CheckWaterLevelVisibilityJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<TransformLineRenderer.LineRendererUpdateJob>();
			IJobExtensions.EarlyJobInit<AddAndBlurSphereJob>();
			IJobForExtensions.EarlyJobInit<BoxBlur3DJob>();
			IJobExtensions.EarlyJobInit<BoxBlurCylinderJob>();
			IJobExtensions.EarlyJobInit<BoxBlurSphereJob>();
			IJobExtensions.EarlyJobInit<CarveAndBlurCylinderJob>();
			IJobExtensions.EarlyJobInit<CarveAndBlurSphereJob>();
			IJobExtensions.EarlyJobInit<CleanFloatingIslandsJob>();
			IJobParallelForExtensions.EarlyJobInit<Hopper.FillRaycastJob>();
			IJobExtensions.EarlyJobInit<PostCullingJob>();
			IJobExtensions.EarlyJobInit<GenerateAscSeqListJob>();
			IJobExtensions.EarlyJobInit<InvertIndexListJob>();
			IJobExtensions.EarlyJobInit<RaycastSamplePositionsJob>();
			IJobExtensions.EarlyJobInit<RaycastBufferSetupJob>();
			IJobParallelForExtensions.EarlyJobInit<RaycastRaySetupJob>();
			IJobParallelForExtensions.EarlyJobInit<RaycastRayProcessingJob>();
			IJobExtensions.EarlyJobInit<RaycastOutputCompressJob>();
			IJobExtensions.EarlyJobInit<RaycastColliderProcessingJob>();
			IJobExtensions.EarlyJobInit<GatherPlayersWithTicksJob>();
			IJobExtensions.EarlyJobInit<BuildLayerMasksJob>();
			IJobExtensions.EarlyJobInit<GatherHitIndicesJob>();
			IJobExtensions.EarlyJobInit<BuildBatchLookupMapJob>();
			IJobExtensions.EarlyJobInit<GatherNoClipBatchesJob>();
			IJobExtensions.EarlyJobInit<FindValidIndicesJob>();
			IJobExtensions.EarlyJobInit<InsideTerrainHeightsChecksJob>();
			IJobExtensions.EarlyJobInit<ScatterInvertedBool>();
			IJobForExtensions.EarlyJobInit<GenerateInsideMeshCommandsJob>();
			IJobForExtensions.EarlyJobInit<CheckInsideMeshHitsJob>();
			IJobForExtensions.EarlyJobInit<FilterInsideMeshHitsJob>();
			IJobExtensions.EarlyJobInit<PreCullingJob>();
			IJobParallelForDeferExtensions.EarlyJobInit<FillFalseJobDefer>();
			IJobParallelForDeferExtensions.EarlyJobInit<AdjustByTopologyJob>();
			IJobParallelForDeferExtensions.EarlyJobInit<SmallDisplacementPlaneTraceJob>();
			IJobParallelForDeferExtensions.EarlyJobInit<OceanTraceJob>();
			IJobForExtensions.EarlyJobInit<PaintSplatJob>();
			IJobParallelForExtensions.EarlyJobInit<PopulateDeltaHeightJob>();
			IJobParallelForExtensions.EarlyJobInit<CopyBackFloatHeightToShortHeightJob>();
			IJobParallelForExtensions.EarlyJobInit<EvaporationJob>();
			IJobParallelForBatchExtensions.EarlyJobInit<PrepareMapJob>();
			IJobParallelForExtensions.EarlyJobInit<TransportSedimentJob>();
			IJobParallelForExtensions.EarlyJobInit<CalcMinHeightMapJob>();
			IJobParallelForExtensions.EarlyJobInit<ErosionAndDepositionJob>();
			IJobParallelForExtensions.EarlyJobInit<TileCalculateAngleMap>();
			IJobParallelForExtensions.EarlyJobInit<AdjustWaterHeightByFluxJob>();
			IJobParallelForExtensions.EarlyJobInit<CalculateOutputFluxJob>();
			IJobParallelForExtensions.EarlyJobInit<RefillOceanJob>();
			IJobParallelForExtensions.EarlyJobInit<WaterIncrementationJob>();
			IJobExtensions.EarlyJobInit<GetCoarseDistsToShoreJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightByPosJob>();
			IJobExtensions.EarlyJobInit<GetHeightByUVJob>();
			IJobExtensions.EarlyJobInit<GetHeightByUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightByIndexJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByPosJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByUVJob>();
			IJobExtensions.EarlyJobInit<GetTopologyRadiusJob>();
			IJobParallelForExtensions.EarlyJobInit<GetTopologyRadiusJobIndirect>();
			IJobParallelForExtensions.EarlyJobInit<GetTopologyRadiusNormalizedJobIndirect>();
			IJobExtensions.EarlyJobInit<GetTopologyByIndexJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightsFastJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightsJob>();
			IJobExtensions.EarlyJobInit<TerrainHeightMapJobs.GetHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckPosRadJob>();
			IJobExtensions.EarlyJobInit<CheckPosRadBatchJob>();
			IJobExtensions.EarlyJobInit<CheckPosRadBatchJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckBoundsJob>();
			IJobExtensions.EarlyJobInit<CheckBoundsJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckRayJob>();
			IJobExtensions.EarlyJobInit<CalculatePathBetweenGridsJob>();
			IJobParallelForBatchExtensions.EarlyJobInit<CalculatePathsBetweenGridsJob>();
			IJobForExtensions.EarlyJobInit<CalculateSubGridSamplePointsJob>();
			IJobExtensions.EarlyJobInit<ToUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherWavesIndicesJobIndirect>();
			IJobExtensions.EarlyJobInit<ApplyMaxHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<SelectMaxWaterLevelJobIndirect>();
			IJobExtensions.EarlyJobInit<CalcCenterJobIndirect>();
			IJobExtensions.EarlyJobInit<InitialValidateInfoJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherValidInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherInvalidInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<UpdateWaterHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<SetupHeadQueryJobIndirect>();
			IJobExtensions.EarlyJobInit<ApplyHeadQueryResultsJobIndirect>();
			IJobExtensions.EarlyJobInit<ResolveWaterInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<UpdateWaterCache>();
			IJobExtensions.EarlyJobInit<GatherPosToValidateJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<RecacheTransforms>();
			IJobExtensions.EarlyJobInit<CalcWaterFactorsJobIndirect>();
			IJobExtensions.EarlyJobInit<GetWaterFactorsParamsJobIndirect>();
			IJobForExtensions.EarlyJobInit<TraceAllJob>();
			IJobExtensions.EarlyJobInit<CalcMidpoingJob>();
			IJobExtensions.EarlyJobInit<CheckHitsJob>();
			IJobExtensions.EarlyJobInit<GenerateOverlapBoxCommandsJob>();
			IJobExtensions.EarlyJobInit<ValidateOverlapBoxCommandsJob>();
			IJobExtensions.EarlyJobInit<GenerateOverlapCapsuleCommandsJob>();
			IJobExtensions.EarlyJobInit<ValidateOverlapCapsuleCommandsJob>();
			IJobExtensions.EarlyJobInit<FindSphereCmdsInCapsuleCmdsJob>();
			IJobExtensions.EarlyJobInit<GenerateSphereCmdsFromCapsuleCmdsJob>();
			IJobExtensions.EarlyJobInit<GenerateOverlapSphereCommandsJob>();
			IJobExtensions.EarlyJobInit<ValidateOverlapSphereCommandsJob>();
			IJobExtensions.EarlyJobInit<RemoveLayerMaskJob>();
			IJobExtensions.EarlyJobInit<CountRaycastHitsJobs>();
			IJobExtensions.EarlyJobInit<ScatterColliderHitsJob>();
			IJobExtensions.EarlyJobInit<PreProcessWaterSpheresJob>();
			IJobExtensions.EarlyJobInit<PreProcessWaterRaysJob>();
			IJobExtensions.EarlyJobInit<PostProcessWaterRaysJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<ReadPositionDataTransformJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<BatchUpdateVelocityEndJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<GenerateRaysJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<GenerateRaysMidstepJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<PosRotReadJob>();
			IJobExtensions.EarlyJobInit<CopyBackJob>();
			IJobExtensions.EarlyJobInit<PopulateArraysJob>();
			IJobExtensions.EarlyJobInit<SimplifyMeshJob>();
			IJobParallelForExtensions.EarlyJobInit<BakePhysicsMeshesJob>();
			IJobExtensions.EarlyJobInit<CleanupDuplicateVerticesJob>();
			IJobExtensions.EarlyJobInit<MarchJob>();
			IJobExtensions.EarlyJobInit<GetHeightBatchedJob>();
			IJobExtensions.EarlyJobInit<Rust.Water5.GetHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherJob<OverlapCapsuleCommand>>();
			IJobExtensions.EarlyJobInit<FillJob<float>>();
			IJobExtensions.EarlyJobInit<FillJob<int>>();
			IJobExtensions.EarlyJobInit<FillJob<bool>>();
			IJobExtensions.EarlyJobInit<GatherJob<Vector3>>();
			IJobExtensions.EarlyJobInit<GatherJob<float>>();
			IJobExtensions.EarlyJobInit<CopyArrayJob<float>>();
			IJobExtensions.EarlyJobInit<GatherJob<int>>();
		}
		catch (Exception ex)
		{
			EarlyInitHelpers.JobReflectionDataCreationFailed(ex);
		}
	}

	[RuntimeInitializeOnLoadMethod(/*Could not decode attribute arguments.*/)]
	public static void EarlyInit()
	{
		CreateJobReflectionData();
	}
}


