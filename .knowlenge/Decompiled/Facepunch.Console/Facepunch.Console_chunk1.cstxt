using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Facepunch;
using Facepunch.Extend;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

public class ConsoleSystem
{
	public class Arg
	{
		public Option Option;

		public Command cmd;

		public string RawCommand;

		public string FullString = "";

		public string[] Args;

		public bool Invalid = true;

		public string Reply = "";

		public bool Silent;

		public bool IsClientside => Option.IsClient;

		public bool IsServerside => Option.IsServer;

		public Connection Connection => Option.Connection;

		public bool IsConnectionAdmin
		{
			get
			{
				if (Option.Connection != null && Option.Connection.connected && Option.Connection.authLevel != 0)
				{
					if (Option.Connection.encryptionLevel > 1)
					{
						return Option.Connection.trusted;
					}
					return true;
				}
				return false;
			}
		}

		public bool IsAdmin
		{
			get
			{
				if (!IsConnectionAdmin)
				{
					return IsRcon;
				}
				return true;
			}
		}

		public bool IsRcon => Option.FromRcon;

		public Arg(Option options, string rconCommand)
		{
			Option = options;
			BuildCommand(rconCommand);
		}

		internal void BuildCommand(string command)
		{
			RawCommand = command;
			if (string.IsNullOrEmpty(command))
			{
				Invalid = true;
				return;
			}
			if (command.IndexOf('.') <= 0 || command.IndexOf(' ', 0, command.IndexOf('.')) != -1)
			{
				command = "global." + command;
			}
			int num = command.IndexOf('.');
			if (num <= 0)
			{
				return;
			}
			string text = command.Substring(0, num);
			if (text.Length < 1)
			{
				return;
			}
			text = text.Trim().ToLower();
			string text2 = command.Substring(num + 1);
			if (text2.Length >= 1)
			{
				int num2 = text2.IndexOf(' ');
				if (num2 > 0)
				{
					FullString = text2.Substring(num2 + 1);
					FullString = FullString.Trim();
					Args = StringExtensions.SplitQuotesStrings(FullString, 16);
					text2 = text2.Substring(0, num2);
				}
				text2 = text2.Trim().ToLower();
				if (cmd == null && Option.IsClient)
				{
					cmd = Index.Client.Find(text + "." + text2);
				}
				if (cmd == null && Option.IsServer)
				{
					cmd = Index.Server.Find(text + "." + text2);
				}
				Invalid = cmd == null;
			}
		}

		internal bool HasPermission()
		{
			if (cmd == null)
			{
				return false;
			}
			if (Option.IsUnrestricted)
			{
				return true;
			}
			if (IsClientside)
			{
				if (cmd.ClientAdmin)
				{
					if (ClientCanRunAdminCommands != null)
					{
						return ClientCanRunAdminCommands();
					}
					return false;
				}
				if (Option.IsFromServer && !cmd.AllowRunFromServer)
				{
					Debug.Log((object)("Server tried to run command \"" + FullString + "\", but we blocked it."));
					return false;
				}
				return cmd.Client;
			}
			if (cmd.ServerAdmin)
			{
				if (IsRcon)
				{
					return true;
				}
				if (IsAdmin)
				{
					return true;
				}
			}
			if (cmd.ServerUser && Connection != null)
			{
				return true;
			}
			return false;
		}

		internal bool CanSeeInFind(Command command)
		{
			if (command == null)
			{
				return false;
			}
			if (Option.IsUnrestricted)
			{
				return true;
			}
			if (IsClientside)
			{
				return command.Client;
			}
			if (IsServerside)
			{
				return command.Server;
			}
			return false;
		}

		public void ReplyWith(string strValue)
		{
			Reply = strValue;
		}

		public void ReplyWith(object obj)
		{
			Reply = JsonConvert.SerializeObject(obj, (Formatting)1);
		}

		public bool HasArgs(int iMinimum = 1)
		{
			if (Args == null)
			{
				return false;
			}
			return Args.Length >= iMinimum;
		}

		public bool HasArg(string value, bool remove = false)
		{
			if (Args == null)
			{
				return false;
			}
			if (Array.IndexOf(Args, value) == -1)
			{
				return false;
			}
			if (remove)
			{
				Args = Args.Where((string x) => x != value).ToArray();
			}
			return true;
		}

		public bool TryRemoveKeyBindEventArgs()
		{
			if (Args == null)
			{
				return false;
			}
			int num = Args.Length;
			Args = Args.Where((string x) => x != "True" && x != "False").ToArray();
			return Args.Length != num;
		}

		public string GetString(int iArg, string def = "")
		{
			if (HasArgs(iArg + 1))
			{
				return Args[iArg];
			}
			return def;
		}

		public int GetInt(int iArg, int def = 0)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (int.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public long GetLong(int iArg, long def = 0L)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (long.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public ulong GetULong(int iArg, ulong def = 0uL)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (ulong.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public bool TryGetUInt(int iArg, out uint value)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				value = 0u;
				return false;
			}
			return uint.TryParse(@string, out value);
		}

		public uint GetUInt(int iArg, uint def = 0u)
		{
			if (!TryGetUInt(iArg, out var value))
			{
				return def;
			}
			return value;
		}

		public ulong GetUInt64(int iArg, ulong def = 0uL)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (ulong.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public float GetFloat(int iArg, float def = 0f)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (float.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public bool GetBool(int iArg, bool def = false)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (@string == string.Empty || @string == "0")
			{
				return false;
			}
			if (@string.Equals("f", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			if (@string.Equals("false", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			if (@string.Equals("no", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			if (@string.Equals("none", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			if (@string.Equals("null", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			return true;
		}

		public long GetTimestamp(int iArg, long def = 0L)
		{
			string text = GetString(iArg, null);
			if (text == null)
			{
				return def;
			}
			int num = 3600;
			if (text.Length > 1 && char.IsLetter(text[text.Length - 1]))
			{
				switch (text[text.Length - 1])
				{
				case 's':
					num = 1;
					break;
				case 'm':
					num = 60;
					break;
				case 'h':
					num = 3600;
					break;
				case 'd':
					num = 86400;
					break;
				case 'w':
					num = 604800;
					break;
				case 'M':
					num = 2592000;
					break;
				case 'Y':
					num = 31536000;
					break;
				}
				text = text.Substring(0, text.Length - 1);
			}
			if (long.TryParse(text, out var result))
			{
				if (result > 0 && result <= 315360000)
				{
					return DateTimeOffset.UtcNow.ToUnixTimeSeconds() + result * num;
				}
				return result;
			}
			return def;
		}

		public long GetTicks(int iArg, long def = 0L)
		{
			string text = GetString(iArg, null);
			if (text == null)
			{
				return def;
			}
			int num = 3600;
			if (text.Length > 1 && char.IsLetter(text[text.Length - 1]))
			{
				switch (text[text.Length - 1])
				{
				case 's':
					num = 1;
					break;
				case 'm':
					num = 60;
					break;
				case 'h':
					num = 3600;
					break;
				case 'd':
					num = 86400;
					break;
				case 'w':
					num = 604800;
					break;
				case 'M':
					num = 2592000;
					break;
				case 'Y':
					num = 31536000;
					break;
				}
				text = text.Substring(0, text.Length - 1);
			}
			if (long.TryParse(text, out var result))
			{
				return result * num * 10000000;
			}
			return def;
		}

		public void ReplyWithObject(object rval)
		{
			if (rval != null)
			{
				if (rval is string)
				{
					ReplyWith((string)rval);
					return;
				}
				string strValue = JsonConvert.SerializeObject(rval, (Formatting)1);
				ReplyWith(strValue);
			}
		}

		public Vector3 GetVector3(int iArg, Vector3 def = default(Vector3))
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			return StringExtensions.ToVector3(@string);
		}

		public Color GetColor(int iArg, Color def = default(Color))
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			return StringExtensions.ToColor(@string);
		}
	}

	public class Factory : Attribute
	{
		public string Name;

		public Factory(string systemName)
		{
			Name = systemName;
		}
	}

	public class Command
	{
		public string Name;

		public string Parent;

		public string FullName;

		public Func<string> GetOveride;

		public Action<string> SetOveride;

		public Action<Arg> Call;

		public bool Variable;

		public string Default;

		public string DefaultValue;

		public bool Saved;

		public bool ServerAdmin;

		public bool ServerUser;

		public bool Replicated;

		public bool ShowInAdminUI;

		public bool ClientAdmin;

		public bool Client;

		public bool ClientInfo;

		public bool AllowRunFromServer;

		public string Description = string.Empty;

		public string Arguments = string.Empty;

		public bool Server
		{
			get
			{
				if (!ServerAdmin)
				{
					return ServerUser;
				}
				return true;
			}
		}

		public string String => GetOveride?.Invoke() ?? "";

		public int AsInt => StringExtensions.ToInt(String, 0);

		public float AsFloat => StringExtensions.ToFloat(String, 0f);

		public bool AsBool => StringExtensions.ToBool(String);

		public Vector3 AsVector3 => StringExtensions.ToVector3(String);

		public event Action<Command> OnValueChanged;

		public Command()
		{
			Call = DefaultCall;
		}

		private void ValueChanged()
		{
			if (Saved)
			{
				HasChanges = true;
			}
			if (ClientInfo)
			{
				SendToServer(BuildCommand("setinfo", FullName, String));
			}
			if (this.OnValueChanged != null)
			{
				this.OnValueChanged(this);
			}
		}

		private void DefaultCall(Arg arg)
		{
			if (SetOveride != null && arg.HasArgs())
			{
				if (arg.IsClientside && Replicated)
				{
					SendToServer(arg.RawCommand);
					arg.Silent = true;
					Debug.LogWarning((object)("ConVar '" + Name + "' will be replicated to all other players on the server"));
				}
				else
				{
					Set(arg.Args[0]);
				}
			}
		}

		public void Set(string value)
		{
			if (SetOveride != null)
			{
				string @string = String;
				SetOveride(value);
				if (@string != String)
				{
					ValueChanged();
				}
			}
		}

		public void Set(float f)
		{
			string text = f.ToString("0.00");
			if (!(String == text))
			{
				Set(text);
			}
		}

		public void Set(bool val)
		{
			if (AsBool != val)
			{
				Set(val ? "1" : "0");
			}
		}
	}

	public interface IConsoleCommand
	{
		void Call(Arg arg);
	}

	public interface IConsoleButton
	{
		bool IsPressed { get; set; }
	}

	public static class Index
	{
		public static class Server
		{
			public static Dictionary<string, Command> Dict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

			public static Dictionary<string, Command> GlobalDict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

			public static List<Command> Replicated = new List<Command>();

			public static Command Find(string strName)
			{
				if (!strName.Contains("."))
				{
					strName = "global." + strName;
				}
				if (Dict.TryGetValue(strName, out var value))
				{
					return value;
				}
				GlobalDict.TryGetValue(strName.Replace("global.", ""), out value);
				return value;
			}
		}

		public static class Client
		{
			public static Dictionary<string, Command> Dict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

			public static Dictionary<string, Command> GlobalDict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

			public static Command Find(string strName)
			{
				if (!strName.Contains("."))
				{
					strName = WithGlobal.Get(strName);
				}
				if (Dict.TryGetValue(strName, out var value))
				{
					return value;
				}
				GlobalDict.TryGetValue(WithoutGlobal.Get(strName), out value);
				return value;
			}
		}

		private static readonly Memoized<string, string> WithGlobal = new Memoized<string, string>((Func<string, string>)((string s) => "global." + s));

		private static readonly Memoized<string, string> WithoutGlobal = new Memoized<string, string>((Func<string, string>)((string s) => s.Replace("global.", "")));

		public static Command[] All { get; set; }

		public static void Initialize(Command[] Commands)
		{
			Command[] array = Commands;
			foreach (Command command2 in array)
			{
				if (command2.Variable && command2.GetOveride != null)
				{
					try
					{
						command2.DefaultValue = command2.GetOveride() ?? "";
					}
					catch
					{
					}
				}
			}
			All = Commands;
			Server.Dict = new Dictionary<string, Command>();
			Client.Dict = new Dictionary<string, Command>();
			array = All;
			foreach (Command command3 in array)
			{
				if (command3.Server)
				{
					if (Server.Dict.ContainsKey(command3.FullName))
					{
						Debug.LogWarning((object)("Server Vars have multiple entries for " + command3.FullName));
					}
					else
					{
						Server.Dict.Add(command3.FullName, command3);
					}
					if (command3.Parent != "global" && !Server.GlobalDict.ContainsKey(command3.Name))
					{
						Server.GlobalDict.Add(command3.Name, command3);
					}
					if (command3.Replicated)
					{
						if (!command3.Variable || !command3.ServerAdmin)
						{
							Debug.LogWarning((object)("Replicated server var " + command3.FullName + " has a bad config"));
						}
						else
						{
							Server.Replicated.Add(command3);
							command3.OnValueChanged += delegate(Command command)
							{
								ConsoleSystem.OnReplicatedVarChanged?.Invoke(command.FullName, command.String);
							};
						}
					}
				}
				if (command3.Client)
				{
					if (Client.Dict.ContainsKey(command3.FullName))
					{
						Debug.LogWarning((object)("Client Vars have multiple entries for " + command3.FullName));
					}
					else
					{
						Client.Dict.Add(command3.FullName, command3);
					}
					if (command3.Parent != "global" && !Client.GlobalDict.ContainsKey(command3.Name))
					{
						Client.GlobalDict.Add(command3.Name, command3);
					}
				}
			}
			Input.RunBind += delegate(string strCommand, bool pressed)
			{
				Command command4 = Client.Find(strCommand);
				if (command4 != null && command4.Variable && !command4.ClientAdmin && !command4.ServerAdmin && !command4.Replicated)
				{
					command4.Set(pressed);
				}
				else
				{
					Run(Option.Client, $"{strCommand} {pressed}");
				}
			};
		}

		public static void Reset()
		{
			if (All == null)
			{
				return;
			}
			Command[] all = All;
			foreach (Command command in all)
			{
				if (command.Variable && command.Default != null)
				{
					try
					{
						command.Set(command.Default);
					}
					catch (Exception arg)
					{
						Debug.LogError((object)$"Exception running {command.FullName} = {command.Default}: {arg}");
					}
				}
			}
		}
	}

	public struct Option
	{
		public static Option Unrestricted
		{
			get
			{
				Option result = default(Option);
				result.IsServer = true;
				result.IsClient = true;
				result.ForwardtoServerOnMissing = true;
				result.PrintOutput = true;
				result.IsUnrestricted = true;
				return result;
			}
		}

		public static Option Client
		{
			get
			{
				Option result = default(Option);
				result.IsClient = true;
				result.ForwardtoServerOnMissing = true;
				result.PrintOutput = true;
				return result;
			}
		}

		public static Option Server
		{
			get
			{
				Option result = default(Option);
				result.IsServer = true;
				result.PrintOutput = true;
				result.FromRcon = true;
				return result;
			}
		}

		public bool IsServer { get; set; }

		public bool IsClient { get; set; }

		public bool ForwardtoServerOnMissing { get; set; }

		public bool PrintOutput { get; set; }

		public bool IsUnrestricted { get; set; }

		public bool FromRcon { get; set; }

		public bool PrintValueOnly { get; set; }

		public int RconConnectionId { get; set; }

		public bool IsFromServer { get; set; }

		public Connection Connection { get; set; }

		public Option Quiet()
		{
			PrintOutput = false;
			return this;
		}

		public Option WithRconId(int id)
		{
			RconConnectionId = id;
			return this;
		}

		public Option PrintValue()
		{
			PrintValueOnly = true;
			return this;
		}

		public Option FromServer()
		{
			IsFromServer = true;
			return this;
		}

		public Option FromConnection(Connection connection)
		{
			FromRcon = false;
			Connection = connection;
			return this;
		}
	}

	public static bool HasChanges = false;

	public static Func<bool> ClientCanRunAdminCommands;

	public static Func<string, bool> OnSendToServer;

	public static string LastError = null;

	public static Arg CurrentArgs = null;

	private static List<string> ignoredCommands = new List<string> { "projectpath", "useHub", "hubIPC", "cloudEnvironment", "licensingIpc", "hubSessionId", "accessToken" };

	public static event Action<string, string> OnReplicatedVarChanged;

	public static void UpdateValuesFromCommandLine()
	{
		if (Interface.CallHook("IOnRunCommandLine") != null)
		{
			return;
		}
		foreach (KeyValuePair<string, string> @switch in CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string strCommand = @switch.Key.Substring(1);
			Run(Option.Unrestricted, strCommand, text);
		}
	}

	internal static bool SendToServer(string command)
	{
		if (OnSendToServer != null)
		{
			return OnSendToServer(command);
		}
		return false;
	}

	public static void RunFile(Option options, string strFile)
	{
		string[] array = strFile.Split(new char[1] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
		for (int i = 0; i < array.Length; i++)
		{
			string text = array[i].Trim();
			if (!string.IsNullOrWhiteSpace(text) && text[0] != '#')
			{
				Run(options, text);
			}
		}
		HasChanges = false;
	}

	public static string Run(Option options, string strCommand, params object[] args)
	{
		LastError = null;
		string text = BuildCommand(strCommand, args);
		Arg arg = new Arg(options, text);
		bool flag = arg.HasPermission();
		if (!arg.Invalid && flag)
		{
			Arg currentArgs = CurrentArgs;
			CurrentArgs = arg;
			bool flag2 = Internal(arg);
			CurrentArgs = currentArgs;
			if (options.PrintOutput && flag2 && arg.Reply != null && arg.Reply.Length > 0)
			{
				DebugEx.Log((object)arg.Reply, (StackTraceLogType)0);
			}
			return arg.Reply;
		}
		LastError = "Command not found";
		if (!flag)
		{
			LastError = "Permission denied";
		}
		if (!options.IsServer && (!options.ForwardtoServerOnMissing || !SendToServer(text)))
		{
			LastError = "Command '" + strCommand + "' not found";
			if (options.PrintOutput && !ignoredCommands.Contains(strCommand))
			{
				DebugEx.Log((object)LastError, (StackTraceLogType)0);
			}
			return null;
		}
		if (options.IsServer && options.PrintOutput)
		{
			LastError = "Command '" + strCommand + "' not found";
			if (!ignoredCommands.Contains(strCommand))
			{
				DebugEx.Log((object)LastError, (StackTraceLogType)0);
			}
		}
		return null;
	}

	private static bool Internal(Arg arg)
	{
		if (arg.Invalid)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnServerCommand", (object)arg);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!arg.HasPermission())
		{
			arg.ReplyWith("You cannot run this command");
			return false;
		}
		try
		{
			TimeWarning val = TimeWarning.New("ConsoleSystem: " + arg.cmd.FullName, 0);
			try
			{
				arg.cmd.Call(arg);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		catch (Exception ex)
		{
			arg.ReplyWith("Error: " + arg.cmd.FullName + " - " + ex.Message + " (" + ex.Source + ")");
			Debug.LogException(ex);
			return false;
		}
		if (arg.cmd.Variable && arg.cmd.GetOveride != null && string.IsNullOrWhiteSpace(arg.Reply))
		{
			string @string = arg.cmd.String;
			string text = (arg.cmd.Variable ? arg.cmd.String : "");
			if (!arg.Silent)
			{
				if (arg.Option.PrintValueOnly)
				{
					arg.ReplyWith(@string);
				}
				else if (text != @string)
				{
					arg.ReplyWith($"{arg.cmd.FullName}: changed from {StringExtensions.QuoteSafe(text)} to {StringExtensions.QuoteSafe(@string)}");
				}
				else
				{
					arg.ReplyWith($"{arg.cmd.FullName}: {StringExtensions.QuoteSafe(@string)}");
				}
			}
		}
		return true;
	}

	public static string BuildCommand(string strCommand, params object[] args)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		if (args == null || args.Length == 0)
		{
			return strCommand;
		}
		StringBuilder stringBuilder = Pool.Get<StringBuilder>();
		stringBuilder.Clear();
		stringBuilder.Append(strCommand);
		foreach (object obj in args)
		{
			if (obj == null)
			{
				stringBuilder.Append(" \"\"");
			}
			else if (obj is Color val)
			{
				stringBuilder.Append(" \"").Append(val.r).Append(',')
					.Append(val.g)
					.Append(',')
					.Append(val.b)
					.Append(',')
					.Append(val.a)
					.Append('"');
			}
			else if (obj is Vector3 val2)
			{
				stringBuilder.Append(" \"").Append(val2.x).Append(',')
					.Append(val2.y)
					.Append(',')
					.Append(val2.z)
					.Append('"');
			}
			else if (obj is IEnumerable<string> enumerable)
			{
				foreach (string item in enumerable)
				{
					StringBuilderExtensions.QuoteSafe(stringBuilder.Append(' '), item);
				}
			}
			else
			{
				StringBuilderExtensions.QuoteSafe(stringBuilder.Append(' '), obj.ToString());
			}
		}
		string result = stringBuilder.ToString();
		stringBuilder.Clear();
		Pool.FreeUnmanaged(ref stringBuilder);
		return result;
	}

	public static string SaveToConfigString(bool bServer)
	{
		string text = "";
		IEnumerable<Command> enumerable = ((!bServer) ? Index.All.Where((Command x) => x.Saved && x.Client && !x.Replicated) : Index.All.Where((Command x) => x.Saved && x.ServerAdmin));
		foreach (Command item in enumerable)
		{
			if (item.GetOveride != null)
			{
				text = text + item.FullName + " " + StringExtensions.QuoteSafe(item.String);
				text += Environment.NewLine;
			}
		}
		return text;
	}
}


using System;
using System.Linq;
using Facepunch.Extend;
using Network;
using Newtonsoft.Json;
using UnityEngine;

public class Arg
{
	public Option Option;

	public Command cmd;

	public string RawCommand;

	public string FullString = "";

	public string[] Args;

	public bool Invalid = true;

	public string Reply = "";

	public bool Silent;

	public bool IsClientside => Option.IsClient;

	public bool IsServerside => Option.IsServer;

	public Connection Connection => Option.Connection;

	public bool IsConnectionAdmin
	{
		get
		{
			if (Option.Connection != null && Option.Connection.connected && Option.Connection.authLevel != 0)
			{
				if (Option.Connection.encryptionLevel > 1)
				{
					return Option.Connection.trusted;
				}
				return true;
			}
			return false;
		}
	}

	public bool IsAdmin
	{
		get
		{
			if (!IsConnectionAdmin)
			{
				return IsRcon;
			}
			return true;
		}
	}

	public bool IsRcon => Option.FromRcon;

	public Arg(Option options, string rconCommand)
	{
		Option = options;
		BuildCommand(rconCommand);
	}

	internal void BuildCommand(string command)
	{
		RawCommand = command;
		if (string.IsNullOrEmpty(command))
		{
			Invalid = true;
			return;
		}
		if (command.IndexOf('.') <= 0 || command.IndexOf(' ', 0, command.IndexOf('.')) != -1)
		{
			command = "global." + command;
		}
		int num = command.IndexOf('.');
		if (num <= 0)
		{
			return;
		}
		string text = command.Substring(0, num);
		if (text.Length < 1)
		{
			return;
		}
		text = text.Trim().ToLower();
		string text2 = command.Substring(num + 1);
		if (text2.Length >= 1)
		{
			int num2 = text2.IndexOf(' ');
			if (num2 > 0)
			{
				FullString = text2.Substring(num2 + 1);
				FullString = FullString.Trim();
				Args = StringExtensions.SplitQuotesStrings(FullString, 16);
				text2 = text2.Substring(0, num2);
			}
			text2 = text2.Trim().ToLower();
			if (cmd == null && Option.IsClient)
			{
				cmd = Index.Client.Find(text + "." + text2);
			}
			if (cmd == null && Option.IsServer)
			{
				cmd = Index.Server.Find(text + "." + text2);
			}
			Invalid = cmd == null;
		}
	}

	internal bool HasPermission()
	{
		if (cmd == null)
		{
			return false;
		}
		if (Option.IsUnrestricted)
		{
			return true;
		}
		if (IsClientside)
		{
			if (cmd.ClientAdmin)
			{
				if (ClientCanRunAdminCommands != null)
				{
					return ClientCanRunAdminCommands();
				}
				return false;
			}
			if (Option.IsFromServer && !cmd.AllowRunFromServer)
			{
				Debug.Log((object)("Server tried to run command \"" + FullString + "\", but we blocked it."));
				return false;
			}
			return cmd.Client;
		}
		if (cmd.ServerAdmin)
		{
			if (IsRcon)
			{
				return true;
			}
			if (IsAdmin)
			{
				return true;
			}
		}
		if (cmd.ServerUser && Connection != null)
		{
			return true;
		}
		return false;
	}

	internal bool CanSeeInFind(Command command)
	{
		if (command == null)
		{
			return false;
		}
		if (Option.IsUnrestricted)
		{
			return true;
		}
		if (IsClientside)
		{
			return command.Client;
		}
		if (IsServerside)
		{
			return command.Server;
		}
		return false;
	}

	public void ReplyWith(string strValue)
	{
		Reply = strValue;
	}

	public void ReplyWith(object obj)
	{
		Reply = JsonConvert.SerializeObject(obj, (Formatting)1);
	}

	public bool HasArgs(int iMinimum = 1)
	{
		if (Args == null)
		{
			return false;
		}
		return Args.Length >= iMinimum;
	}

	public bool HasArg(string value, bool remove = false)
	{
		if (Args == null)
		{
			return false;
		}
		if (Array.IndexOf(Args, value) == -1)
		{
			return false;
		}
		if (remove)
		{
			Args = Args.Where((string x) => x != value).ToArray();
		}
		return true;
	}

	public bool TryRemoveKeyBindEventArgs()
	{
		if (Args == null)
		{
			return false;
		}
		int num = Args.Length;
		Args = Args.Where((string x) => x != "True" && x != "False").ToArray();
		return Args.Length != num;
	}

	public string GetString(int iArg, string def = "")
	{
		if (HasArgs(iArg + 1))
		{
			return Args[iArg];
		}
		return def;
	}

	public int GetInt(int iArg, int def = 0)
	{
		string @string = GetString(iArg, null);
		if (@string == null)
		{
			return def;
		}
		if (int.TryParse(@string, out var result))
		{
			return result;
		}
		return def;
	}

	public long GetLong(int iArg, long def = 0L)
	{
		string @string = GetString(iArg, null);
		if (@string == null)
		{
			return def;
		}
		if (long.TryParse(@string, out var result))
		{
			return result;
		}
		return def;
	}

	public ulong GetULong(int iArg, ulong def = 0uL)
	{
		string @string = GetString(iArg, null);
		if (@string == null)
		{
			return def;
		}
		if (ulong.TryParse(@string, out var result))
		{
			return result;
		}
		return def;
	}

	public bool TryGetUInt(int iArg, out uint value)
	{
		string @string = GetString(iArg, null);
		if (@string == null)
		{
			value = 0u;
			return false;
		}
		return uint.TryParse(@string, out value);
	}

	public uint GetUInt(int iArg, uint def = 0u)
	{
		if (!TryGetUInt(iArg, out var value))
		{
			return def;
		}
		return value;
	}

	public ulong GetUInt64(int iArg, ulong def = 0uL)
	{
		string @string = GetString(iArg, null);
		if (@string == null)
		{
			return def;
		}
		if (ulong.TryParse(@string, out var result))
		{
			return result;
		}
		return def;
	}

	public float GetFloat(int iArg, float def = 0f)
	{
		string @string = GetString(iArg, null);
		if (@string == null)
		{
			return def;
		}
		if (float.TryParse(@string, out var result))
		{
			return result;
		}
		return def;
	}

	public bool GetBool(int iArg, bool def = false)
	{
		string @string = GetString(iArg, null);
		if (@string == null)
		{
			return def;
		}
		if (@string == string.Empty || @string == "0")
		{
			return false;
		}
		if (@string.Equals("f", StringComparison.InvariantCultureIgnoreCase))
		{
			return false;
		}
		if (@string.Equals("false", StringComparison.InvariantCultureIgnoreCase))
		{
			return false;
		}
		if (@string.Equals("no", StringComparison.InvariantCultureIgnoreCase))
		{
			return false;
		}
		if (@string.Equals("none", StringComparison.InvariantCultureIgnoreCase))
		{
			return false;
		}
		if (@string.Equals("null", StringComparison.InvariantCultureIgnoreCase))
		{
			return false;
		}
		return true;
	}

	public long GetTimestamp(int iArg, long def = 0L)
	{
		string text = GetString(iArg, null);
		if (text == null)
		{
			return def;
		}
		int num = 3600;
		if (text.Length > 1 && char.IsLetter(text[text.Length - 1]))
		{
			switch (text[text.Length - 1])
			{
			case 's':
				num = 1;
				break;
			case 'm':
				num = 60;
				break;
			case 'h':
				num = 3600;
				break;
			case 'd':
				num = 86400;
				break;
			case 'w':
				num = 604800;
				break;
			case 'M':
				num = 2592000;
				break;
			case 'Y':
				num = 31536000;
				break;
			}
			text = text.Substring(0, text.Length - 1);
		}
		if (long.TryParse(text, out var result))
		{
			if (result > 0 && result <= 315360000)
			{
				return DateTimeOffset.UtcNow.ToUnixTimeSeconds() + result * num;
			}
			return result;
		}
		return def;
	}

	public long GetTicks(int iArg, long def = 0L)
	{
		string text = GetString(iArg, null);
		if (text == null)
		{
			return def;
		}
		int num = 3600;
		if (text.Length > 1 && char.IsLetter(text[text.Length - 1]))
		{
			switch (text[text.Length - 1])
			{
			case 's':
				num = 1;
				break;
			case 'm':
				num = 60;
				break;
			case 'h':
				num = 3600;
				break;
			case 'd':
				num = 86400;
				break;
			case 'w':
				num = 604800;
				break;
			case 'M':
				num = 2592000;
				break;
			case 'Y':
				num = 31536000;
				break;
			}
			text = text.Substring(0, text.Length - 1);
		}
		if (long.TryParse(text, out var result))
		{
			return result * num * 10000000;
		}
		return def;
	}

	public void ReplyWithObject(object rval)
	{
		if (rval != null)
		{
			if (rval is string)
			{
				ReplyWith((string)rval);
				return;
			}
			string strValue = JsonConvert.SerializeObject(rval, (Formatting)1);
			ReplyWith(strValue);
		}
	}

	public Vector3 GetVector3(int iArg, Vector3 def = default(Vector3))
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		string @string = GetString(iArg, null);
		if (@string == null)
		{
			return def;
		}
		return StringExtensions.ToVector3(@string);
	}

	public Color GetColor(int iArg, Color def = default(Color))
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		string @string = GetString(iArg, null);
		if (@string == null)
		{
			return def;
		}
		return StringExtensions.ToColor(@string);
	}
}


using System;

public class Factory : Attribute
{
	public string Name;

	public Factory(string systemName)
	{
		Name = systemName;
	}
}


using System;
using Facepunch.Extend;
using UnityEngine;

public class Command
{
	public string Name;

	public string Parent;

	public string FullName;

	public Func<string> GetOveride;

	public Action<string> SetOveride;

	public Action<Arg> Call;

	public bool Variable;

	public string Default;

	public string DefaultValue;

	public bool Saved;

	public bool ServerAdmin;

	public bool ServerUser;

	public bool Replicated;

	public bool ShowInAdminUI;

	public bool ClientAdmin;

	public bool Client;

	public bool ClientInfo;

	public bool AllowRunFromServer;

	public string Description = string.Empty;

	public string Arguments = string.Empty;

	public bool Server
	{
		get
		{
			if (!ServerAdmin)
			{
				return ServerUser;
			}
			return true;
		}
	}

	public string String => GetOveride?.Invoke() ?? "";

	public int AsInt => StringExtensions.ToInt(String, 0);

	public float AsFloat => StringExtensions.ToFloat(String, 0f);

	public bool AsBool => StringExtensions.ToBool(String);

	public Vector3 AsVector3 => StringExtensions.ToVector3(String);

	public event Action<Command> OnValueChanged;

	public Command()
	{
		Call = DefaultCall;
	}

	private void ValueChanged()
	{
		if (Saved)
		{
			HasChanges = true;
		}
		if (ClientInfo)
		{
			SendToServer(BuildCommand("setinfo", FullName, String));
		}
		if (this.OnValueChanged != null)
		{
			this.OnValueChanged(this);
		}
	}

	private void DefaultCall(Arg arg)
	{
		if (SetOveride != null && arg.HasArgs())
		{
			if (arg.IsClientside && Replicated)
			{
				SendToServer(arg.RawCommand);
				arg.Silent = true;
				Debug.LogWarning((object)("ConVar '" + Name + "' will be replicated to all other players on the server"));
			}
			else
			{
				Set(arg.Args[0]);
			}
		}
	}

	public void Set(string value)
	{
		if (SetOveride != null)
		{
			string @string = String;
			SetOveride(value);
			if (@string != String)
			{
				ValueChanged();
			}
		}
	}

	public void Set(float f)
	{
		string text = f.ToString("0.00");
		if (!(String == text))
		{
			Set(text);
		}
	}

	public void Set(bool val)
	{
		if (AsBool != val)
		{
			Set(val ? "1" : "0");
		}
	}
}


public interface IConsoleCommand
{
	void Call(Arg arg);
}


public interface IConsoleButton
{
	bool IsPressed { get; set; }
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class Index
{
	public static class Server
	{
		public static Dictionary<string, Command> Dict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

		public static Dictionary<string, Command> GlobalDict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

		public static List<Command> Replicated = new List<Command>();

		public static Command Find(string strName)
		{
			if (!strName.Contains("."))
			{
				strName = "global." + strName;
			}
			if (Dict.TryGetValue(strName, out var value))
			{
				return value;
			}
			GlobalDict.TryGetValue(strName.Replace("global.", ""), out value);
			return value;
		}
	}

	public static class Client
	{
		public static Dictionary<string, Command> Dict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

		public static Dictionary<string, Command> GlobalDict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

		public static Command Find(string strName)
		{
			if (!strName.Contains("."))
			{
				strName = WithGlobal.Get(strName);
			}
			if (Dict.TryGetValue(strName, out var value))
			{
				return value;
			}
			GlobalDict.TryGetValue(WithoutGlobal.Get(strName), out value);
			return value;
		}
	}

	private static readonly Memoized<string, string> WithGlobal = new Memoized<string, string>((Func<string, string>)((string s) => "global." + s));

	private static readonly Memoized<string, string> WithoutGlobal = new Memoized<string, string>((Func<string, string>)((string s) => s.Replace("global.", "")));

	public static Command[] All { get; set; }

	public static void Initialize(Command[] Commands)
	{
		Command[] array = Commands;
		foreach (Command command2 in array)
		{
			if (command2.Variable && command2.GetOveride != null)
			{
				try
				{
					command2.DefaultValue = command2.GetOveride() ?? "";
				}
				catch
				{
				}
			}
		}
		All = Commands;
		Server.Dict = new Dictionary<string, Command>();
		Client.Dict = new Dictionary<string, Command>();
		array = All;
		foreach (Command command3 in array)
		{
			if (command3.Server)
			{
				if (Server.Dict.ContainsKey(command3.FullName))
				{
					Debug.LogWarning((object)("Server Vars have multiple entries for " + command3.FullName));
				}
				else
				{
					Server.Dict.Add(command3.FullName, command3);
				}
				if (command3.Parent != "global" && !Server.GlobalDict.ContainsKey(command3.Name))
				{
					Server.GlobalDict.Add(command3.Name, command3);
				}
				if (command3.Replicated)
				{
					if (!command3.Variable || !command3.ServerAdmin)
					{
						Debug.LogWarning((object)("Replicated server var " + command3.FullName + " has a bad config"));
					}
					else
					{
						Server.Replicated.Add(command3);
						command3.OnValueChanged += delegate(Command command)
						{
							ConsoleSystem.OnReplicatedVarChanged?.Invoke(command.FullName, command.String);
						};
					}
				}
			}
			if (command3.Client)
			{
				if (Client.Dict.ContainsKey(command3.FullName))
				{
					Debug.LogWarning((object)("Client Vars have multiple entries for " + command3.FullName));
				}
				else
				{
					Client.Dict.Add(command3.FullName, command3);
				}
				if (command3.Parent != "global" && !Client.GlobalDict.ContainsKey(command3.Name))
				{
					Client.GlobalDict.Add(command3.Name, command3);
				}
			}
		}
		Input.RunBind += delegate(string strCommand, bool pressed)
		{
			Command command4 = Client.Find(strCommand);
			if (command4 != null && command4.Variable && !command4.ClientAdmin && !command4.ServerAdmin && !command4.Replicated)
			{
				command4.Set(pressed);
			}
			else
			{
				Run(Option.Client, $"{strCommand} {pressed}");
			}
		};
	}

	public static void Reset()
	{
		if (All == null)
		{
			return;
		}
		Command[] all = All;
		foreach (Command command in all)
		{
			if (command.Variable && command.Default != null)
			{
				try
				{
					command.Set(command.Default);
				}
				catch (Exception arg)
				{
					Debug.LogError((object)$"Exception running {command.FullName} = {command.Default}: {arg}");
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;

public static class Server
{
	public static Dictionary<string, Command> Dict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

	public static Dictionary<string, Command> GlobalDict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

	public static List<Command> Replicated = new List<Command>();

	public static Command Find(string strName)
	{
		if (!strName.Contains("."))
		{
			strName = "global." + strName;
		}
		if (Dict.TryGetValue(strName, out var value))
		{
			return value;
		}
		GlobalDict.TryGetValue(strName.Replace("global.", ""), out value);
		return value;
	}
}


using System;
using System.Collections.Generic;

public static class Client
{
	public static Dictionary<string, Command> Dict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

	public static Dictionary<string, Command> GlobalDict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

	public static Command Find(string strName)
	{
		if (!strName.Contains("."))
		{
			strName = WithGlobal.Get(strName);
		}
		if (Dict.TryGetValue(strName, out var value))
		{
			return value;
		}
		GlobalDict.TryGetValue(WithoutGlobal.Get(strName), out value);
		return value;
	}
}


using Network;

public struct Option
{
	public static Option Unrestricted
	{
		get
		{
			Option result = default(Option);
			result.IsServer = true;
			result.IsClient = true;
			result.ForwardtoServerOnMissing = true;
			result.PrintOutput = true;
			result.IsUnrestricted = true;
			return result;
		}
	}

	public static Option Client
	{
		get
		{
			Option result = default(Option);
			result.IsClient = true;
			result.ForwardtoServerOnMissing = true;
			result.PrintOutput = true;
			return result;
		}
	}

	public static Option Server
	{
		get
		{
			Option result = default(Option);
			result.IsServer = true;
			result.PrintOutput = true;
			result.FromRcon = true;
			return result;
		}
	}

	public bool IsServer { get; set; }

	public bool IsClient { get; set; }

	public bool ForwardtoServerOnMissing { get; set; }

	public bool PrintOutput { get; set; }

	public bool IsUnrestricted { get; set; }

	public bool FromRcon { get; set; }

	public bool PrintValueOnly { get; set; }

	public int RconConnectionId { get; set; }

	public bool IsFromServer { get; set; }

	public Connection Connection { get; set; }

	public Option Quiet()
	{
		PrintOutput = false;
		return this;
	}

	public Option WithRconId(int id)
	{
		RconConnectionId = id;
		return this;
	}

	public Option PrintValue()
	{
		PrintValueOnly = true;
		return this;
	}

	public Option FromServer()
	{
		IsFromServer = true;
		return this;
	}

	public Option FromConnection(Connection connection)
	{
		FromRcon = false;
		Connection = connection;
		return this;
	}
}


using System;

public class ConsoleVar : Attribute
{
	public string Name;

	public bool ClientAdmin;

	public bool ServerAdmin;

	public bool ServerUser;

	public bool Saved;

	public string Help;

	public bool ClientInfo;

	public bool Replicated;

	public bool Clientside;

	public bool Serverside;

	public bool EditorOnly;

	public bool AllowRunFromServer;

	public string Default;

	public string[] PreprocessorConditions;

	public bool ShowInAdminUI;
}


public class ServerVar : ConsoleVar
{
	public ServerVar()
	{
		Serverside = true;
		ServerAdmin = true;
	}
}


public class ServerUserVar : ConsoleVar
{
	public ServerUserVar()
	{
		Serverside = true;
		ServerAdmin = false;
		ServerUser = true;
	}
}


public class ServerAllVar : ConsoleVar
{
	public ServerAllVar()
	{
		Serverside = true;
		ServerAdmin = true;
		ServerUser = true;
	}
}


public class ClientVar : ConsoleVar
{
	public ClientVar()
	{
		Clientside = true;
	}
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public class ReplicatedVar : ConsoleVar
{
	public ReplicatedVar()
	{
		Serverside = true;
		ServerAdmin = true;
		Clientside = true;
		ClientAdmin = true;
		Replicated = true;
	}
}


using System;

public class HelpAttribute : Attribute
{
	public string Help;

	public HelpAttribute(string h)
	{
		Help = h;
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class Commands : ConsoleSystem
{
	[ClientVar]
	[ServerVar]
	public static void Find(Arg arg)
	{
		if (!arg.HasArgs())
		{
			return;
		}
		string str = arg.GetString(0);
		IEnumerable<Command> enumerable = Index.All.Where((Command x) => x.Description.Contains(str) || x.FullName.Contains(str) || x.Arguments.Contains(str));
		string text = "";
		string text2 = "";
		foreach (Command item in enumerable)
		{
			if (arg.CanSeeInFind(item))
			{
				if (!item.Variable || item.GetOveride == null)
				{
					string arg2 = $"{item.FullName}( {item.Arguments} )";
					text2 += $" {arg2} {item.Description}\n";
				}
				else
				{
					text += $" {item.FullName.PadRight(24)} {item.Description} ({item.String})\n";
				}
			}
		}
		arg.ReplyWith("Variables:\n" + text + "\nCommands:\n" + text2);
	}

	[ServerVar]
	[ClientVar(AllowRunFromServer = true)]
	public static void Echo(string fullString)
	{
		Debug.Log((object)fullString);
	}
}


using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		MonoScriptData result = default(MonoScriptData);
		result.FilePathsData = new byte[575]
		{
			0, 0, 0, 2, 0, 0, 0, 40, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 67, 111, 110, 115, 111, 108,
			101, 92, 65, 114, 103, 46, 99, 115, 0, 0,
			0, 9, 0, 0, 0, 47, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 67, 111, 110, 115, 111, 108, 101, 92,
			65, 116, 116, 114, 105, 98, 117, 116, 101, 115,
			46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
			44, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 70, 97, 99,
			101, 112, 117, 110, 99, 104, 46, 67, 111, 110,
			115, 111, 108, 101, 92, 67, 111, 109, 109, 97,
			110, 100, 46, 99, 115, 0, 0, 0, 1, 0,
			0, 0, 48, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 70,
			97, 99, 101, 112, 117, 110, 99, 104, 46, 67,
			111, 110, 115, 111, 108, 101, 92, 67, 111, 109,
			109, 97, 110, 100, 76, 105, 110, 101, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 45, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 46, 67, 111, 110, 115, 111,
			108, 101, 92, 67, 111, 109, 109, 97, 110, 100,
			115, 46, 99, 115, 0, 0, 0, 3, 0, 0,
			0, 50, 92, 65, 115, 115, 101, 116, 115, 92,
			80, 108, 117, 103, 105, 110, 115, 92, 70, 97,
			99, 101, 112, 117, 110, 99, 104, 46, 67, 111,
			110, 115, 111, 108, 101, 92, 67, 111, 110, 115,
			111, 108, 101, 83, 121, 115, 116, 101, 109, 46,
			99, 115, 0, 0, 0, 4, 0, 0, 0, 42,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 67, 111, 110, 115,
			111, 108, 101, 92, 73, 110, 100, 101, 120, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 47,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 67, 111, 110, 115,
			111, 108, 101, 92, 78, 101, 116, 119, 111, 114,
			107, 105, 110, 103, 46, 99, 115, 0, 0, 0,
			2, 0, 0, 0, 43, 92, 65, 115, 115, 101,
			116, 115, 92, 80, 108, 117, 103, 105, 110, 115,
			92, 70, 97, 99, 101, 112, 117, 110, 99, 104,
			46, 67, 111, 110, 115, 111, 108, 101, 92, 79,
			112, 116, 105, 111, 110, 46, 99, 115, 0, 0,
			0, 1, 0, 0, 0, 40, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 67, 111, 110, 115, 111, 108, 101, 92,
			82, 117, 110, 46, 99, 115, 0, 0, 0, 1,
			0, 0, 0, 41, 92, 65, 115, 115, 101, 116,
			115, 92, 80, 108, 117, 103, 105, 110, 115, 92,
			70, 97, 99, 101, 112, 117, 110, 99, 104, 46,
			67, 111, 110, 115, 111, 108, 101, 92, 83, 97,
			118, 101, 46, 99, 115
		};
		result.TypesData = new byte[577]
		{
			1, 0, 0, 0, 14, 124, 67, 111, 110, 115,
			111, 108, 101, 83, 121, 115, 116, 101, 109, 0,
			0, 0, 0, 17, 67, 111, 110, 115, 111, 108,
			101, 83, 121, 115, 116, 101, 109, 124, 65, 114,
			103, 1, 0, 0, 0, 14, 124, 67, 111, 110,
			115, 111, 108, 101, 83, 121, 115, 116, 101, 109,
			0, 0, 0, 0, 21, 67, 111, 110, 115, 111,
			108, 101, 83, 121, 115, 116, 101, 109, 124, 70,
			97, 99, 116, 111, 114, 121, 0, 0, 0, 0,
			11, 124, 67, 111, 110, 115, 111, 108, 101, 86,
			97, 114, 0, 0, 0, 0, 10, 124, 83, 101,
			114, 118, 101, 114, 86, 97, 114, 0, 0, 0,
			0, 14, 124, 83, 101, 114, 118, 101, 114, 85,
			115, 101, 114, 86, 97, 114, 0, 0, 0, 0,
			13, 124, 83, 101, 114, 118, 101, 114, 65, 108,
			108, 86, 97, 114, 0, 0, 0, 0, 10, 124,
			67, 108, 105, 101, 110, 116, 86, 97, 114, 0,
			0, 0, 0, 14, 124, 82, 101, 112, 108, 105,
			99, 97, 116, 101, 100, 86, 97, 114, 0, 0,
			0, 0, 14, 124, 72, 101, 108, 112, 65, 116,
			116, 114, 105, 98, 117, 116, 101, 1, 0, 0,
			0, 14, 124, 67, 111, 110, 115, 111, 108, 101,
			83, 121, 115, 116, 101, 109, 0, 0, 0, 0,
			21, 67, 111, 110, 115, 111, 108, 101, 83, 121,
			115, 116, 101, 109, 124, 67, 111, 109, 109, 97,
			110, 100, 1, 0, 0, 0, 14, 124, 67, 111,
			110, 115, 111, 108, 101, 83, 121, 115, 116, 101,
			109, 0, 0, 0, 0, 9, 124, 67, 111, 109,
			109, 97, 110, 100, 115, 1, 0, 0, 0, 14,
			124, 67, 111, 110, 115, 111, 108, 101, 83, 121,
			115, 116, 101, 109, 0, 0, 0, 0, 29, 67,
			111, 110, 115, 111, 108, 101, 83, 121, 115, 116,
			101, 109, 124, 73, 67, 111, 110, 115, 111, 108,
			101, 67, 111, 109, 109, 97, 110, 100, 0, 0,
			0, 0, 28, 67, 111, 110, 115, 111, 108, 101,
			83, 121, 115, 116, 101, 109, 124, 73, 67, 111,
			110, 115, 111, 108, 101, 66, 117, 116, 116, 111,
			110, 1, 0, 0, 0, 14, 124, 67, 111, 110,
			115, 111, 108, 101, 83, 121, 115, 116, 101, 109,
			0, 0, 0, 0, 19, 67, 111, 110, 115, 111,
			108, 101, 83, 121, 115, 116, 101, 109, 124, 73,
			110, 100, 101, 120, 0, 0, 0, 0, 26, 67,
			111, 110, 115, 111, 108, 101, 83, 121, 115, 116,
			101, 109, 43, 73, 110, 100, 101, 120, 124, 83,
			101, 114, 118, 101, 114, 0, 0, 0, 0, 26,
			67, 111, 110, 115, 111, 108, 101, 83, 121, 115,
			116, 101, 109, 43, 73, 110, 100, 101, 120, 124,
			67, 108, 105, 101, 110, 116, 1, 0, 0, 0,
			14, 124, 67, 111, 110, 115, 111, 108, 101, 83,
			121, 115, 116, 101, 109, 1, 0, 0, 0, 14,
			124, 67, 111, 110, 115, 111, 108, 101, 83, 121,
			115, 116, 101, 109, 0, 0, 0, 0, 20, 67,
			111, 110, 115, 111, 108, 101, 83, 121, 115, 116,
			101, 109, 124, 79, 112, 116, 105, 111, 110, 1,
			0, 0, 0, 14, 124, 67, 111, 110, 115, 111,
			108, 101, 83, 121, 115, 116, 101, 109, 1, 0,
			0, 0, 14, 124, 67, 111, 110, 115, 111, 108,
			101, 83, 121, 115, 116, 101, 109
		};
		result.TotalFiles = 11;
		result.TotalTypes = 27;
		result.IsEditorOnly = false;
		return result;
	}
}


private struct MonoScriptData
{
	public byte[] FilePathsData;

	public byte[] TypesData;

	public int TotalTypes;

	public int TotalFiles;

	public bool IsEditorOnly;
}


