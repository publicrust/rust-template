using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		MonoScriptData result = default(MonoScriptData);
		result.FilePathsData = new byte[362]
		{
			0, 0, 0, 1, 0, 0, 0, 46, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 83, 107, 101, 108, 101, 116,
			111, 110, 92, 83, 107, 101, 108, 101, 116, 111,
			110, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 56, 92, 65, 115, 115, 101, 116, 115, 92,
			80, 108, 117, 103, 105, 110, 115, 92, 70, 97,
			99, 101, 112, 117, 110, 99, 104, 46, 83, 107,
			101, 108, 101, 116, 111, 110, 92, 83, 107, 101,
			108, 101, 116, 111, 110, 65, 116, 116, 97, 99,
			104, 109, 101, 110, 116, 46, 99, 115, 0, 0,
			0, 5, 0, 0, 0, 56, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 83, 107, 101, 108, 101, 116, 111, 110,
			92, 83, 107, 101, 108, 101, 116, 111, 110, 68,
			101, 102, 105, 110, 105, 116, 105, 111, 110, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 53,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 70, 97, 99, 101,
			112, 117, 110, 99, 104, 46, 83, 107, 101, 108,
			101, 116, 111, 110, 92, 83, 107, 101, 108, 101,
			116, 111, 110, 82, 97, 103, 100, 111, 108, 108,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			50, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 70, 97, 99,
			101, 112, 117, 110, 99, 104, 46, 83, 107, 101,
			108, 101, 116, 111, 110, 92, 83, 107, 101, 108,
			101, 116, 111, 110, 83, 107, 105, 110, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 53, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 46, 83, 107, 101, 108, 101,
			116, 111, 110, 92, 83, 107, 101, 108, 101, 116,
			111, 110, 83, 107, 105, 110, 76, 111, 100, 46,
			99, 115
		};
		result.TypesData = new byte[347]
		{
			0, 0, 0, 0, 18, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 124, 83, 107, 101, 108, 101,
			116, 111, 110, 0, 0, 0, 0, 28, 70, 97,
			99, 101, 112, 117, 110, 99, 104, 124, 83, 107,
			101, 108, 101, 116, 111, 110, 65, 116, 116, 97,
			99, 104, 109, 101, 110, 116, 0, 0, 0, 0,
			28, 70, 97, 99, 101, 112, 117, 110, 99, 104,
			124, 83, 107, 101, 108, 101, 116, 111, 110, 68,
			101, 102, 105, 110, 105, 116, 105, 111, 110, 0,
			0, 0, 0, 33, 70, 97, 99, 101, 112, 117,
			110, 99, 104, 46, 83, 107, 101, 108, 101, 116,
			111, 110, 68, 101, 102, 105, 110, 105, 116, 105,
			111, 110, 124, 66, 111, 110, 101, 0, 0, 0,
			0, 36, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 83, 107, 101, 108, 101, 116, 111, 110,
			68, 101, 102, 105, 110, 105, 116, 105, 111, 110,
			124, 70, 105, 110, 100, 74, 111, 98, 0, 0,
			0, 0, 44, 70, 97, 99, 101, 112, 117, 110,
			99, 104, 46, 83, 107, 101, 108, 101, 116, 111,
			110, 68, 101, 102, 105, 110, 105, 116, 105, 111,
			110, 124, 82, 97, 103, 100, 111, 108, 108, 83,
			101, 116, 116, 105, 110, 103, 115, 0, 0, 0,
			0, 38, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 46, 83, 107, 101, 108, 101, 116, 111, 110,
			68, 101, 102, 105, 110, 105, 116, 105, 111, 110,
			43, 124, 66, 111, 100, 121, 83, 105, 100, 101,
			0, 0, 0, 0, 25, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 124, 83, 107, 101, 108, 101,
			116, 111, 110, 82, 97, 103, 100, 111, 108, 108,
			0, 0, 0, 0, 22, 70, 97, 99, 101, 112,
			117, 110, 99, 104, 124, 83, 107, 101, 108, 101,
			116, 111, 110, 83, 107, 105, 110, 0, 0, 0,
			0, 25, 70, 97, 99, 101, 112, 117, 110, 99,
			104, 124, 83, 107, 101, 108, 101, 116, 111, 110,
			83, 107, 105, 110, 76, 111, 100
		};
		result.TotalFiles = 6;
		result.TotalTypes = 10;
		result.IsEditorOnly = false;
		return result;
	}
}


private struct MonoScriptData
{
	public byte[] FilePathsData;

	public byte[] TypesData;

	public int TotalTypes;

	public int TotalFiles;

	public bool IsEditorOnly;
}


using System;

[Flags]
public enum BoneFlag
{
	Left = 1,
	Middle = 2,
	Right = 4,
	Pelvis = 8,
	Hip = 0x10,
	Knee = 0x20,
	Foot = 0x40,
	Arm = 0x80,
	Elbow = 0x100,
	Spine = 0x200,
	Head = 0x400,
	Eye = 0x800,
	Finger = 0x1000,
	Thumb = 0x2000
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;

[AddComponentMenu("Facepunch/Skeleton")]
public class Skeleton : MonoBehaviour
{
	public SkeletonDefinition Source;

	public GameObject[] Bones;

	public Transform GetTransform(int id)
	{
		if (id < 0)
		{
			return null;
		}
		if (!((Object)(object)Bones[id] != (Object)null))
		{
			return null;
		}
		return Bones[id].transform;
	}

	public Transform GetTransformSlow(string name)
	{
		TimeWarning val = TimeWarning.New("GetTransformSlow", 0);
		try
		{
			SkeletonDefinition.Bone bone = Source.FindBone(name);
			if (!string.IsNullOrEmpty(bone.Name))
			{
				return GetTransform(bone.Id);
			}
			if (Bones != null && Bones.Length != 0)
			{
				TimeWarning val2 = TimeWarning.New("RecurisveSearch", 0);
				try
				{
					for (int i = 0; i < Bones.Length; i++)
					{
						Transform val3 = TransformEx.FindChildRecursive(Bones[i].transform, name);
						if ((Object)(object)val3 != (Object)null)
						{
							return val3;
						}
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			return null;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public int GetBoneId(string boneName)
	{
		for (int i = 0; i < Source.Bones.Length; i++)
		{
			if (string.Equals(Source.Bones[i].Name, boneName, StringComparison.InvariantCultureIgnoreCase))
			{
				return Source.Bones[i].Id;
			}
		}
		return -1;
	}

	public IEnumerable<Transform> GetTransforms()
	{
		return Source.Bones.Select((SkeletonDefinition.Bone x) => GetTransform(x.Id));
	}

	public GameObject GetGameObject(int id)
	{
		if (id < 0)
		{
			return null;
		}
		return Bones[id];
	}

	public void CopyTo(Skeleton to)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)to.Source != (Object)(object)Source)
		{
			throw new ArgumentException("Trying to copy transforms between different skeletons, source :" + ((Object)((Component)to).gameObject).name + " to :" + ((Object)((Component)to).gameObject).name);
		}
		if (to.Bones.Length != Bones.Length)
		{
			throw new ArgumentException("Bone arrays are different sizes, skeleton might need rebuilding");
		}
		Vector3 val = default(Vector3);
		Quaternion val2 = default(Quaternion);
		for (int i = 0; i < Bones.Length; i++)
		{
			if (!((Object)(object)Bones[i] == (Object)null) && !((Object)(object)to.Bones[i] == (Object)null))
			{
				Bones[i].transform.GetPositionAndRotation(ref val, ref val2);
				to.Bones[i].transform.SetPositionAndRotation(val, val2);
			}
		}
	}

	public void CopyFrom(Vector3[] sourceBonePos, Quaternion[] sourceBoneRot, bool localSpace)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (sourceBonePos.Length != sourceBoneRot.Length)
		{
			throw new ArgumentException("Bone pos and rot arrays are different sizes");
		}
		if (sourceBonePos.Length != Bones.Length)
		{
			throw new ArgumentException("Bone arrays are different sizes, skeleton might need rebuilding");
		}
		for (int i = 0; i < sourceBonePos.Length; i++)
		{
			if (!((Object)(object)Bones[i] == (Object)null))
			{
				_ = ref sourceBonePos[i];
				if (localSpace)
				{
					Bones[i].transform.SetLocalPositionAndRotation(sourceBonePos[i], sourceBoneRot[i]);
				}
				else
				{
					Bones[i].transform.SetPositionAndRotation(sourceBonePos[i], sourceBoneRot[i]);
				}
			}
		}
	}

	public void CopySkeletonSkins(SkeletonSkin[] renderers, LODGroup lodGroup = null)
	{
		SkinnedMeshRenderer[] array = (SkinnedMeshRenderer[])(object)new SkinnedMeshRenderer[renderers.Length];
		for (int i = 0; i < renderers.Length; i++)
		{
			array[i] = CopySkin(renderers[i]);
		}
		if ((Object)(object)lodGroup != (Object)null)
		{
			CopyLodGroup(lodGroup, renderers, array);
		}
	}

	private void CopyLodGroup(LODGroup lodGroup, SkeletonSkin[] renderers, SkinnedMeshRenderer[] created)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		LOD[] lODs = lodGroup.GetLODs();
		foreach (LOD val in lODs)
		{
			for (int j = 0; j < val.renderers.Length; j++)
			{
				int num = LookupRendererIndex(renderers, val.renderers[j]);
				val.renderers[j] = (Renderer)(object)((num >= 0) ? created[num] : null);
			}
		}
		LODGroup obj = ((Component)this).gameObject.AddComponent<LODGroup>();
		obj.size = lodGroup.size;
		obj.animateCrossFading = lodGroup.animateCrossFading;
		obj.fadeMode = lodGroup.fadeMode;
		obj.enabled = lodGroup.enabled;
		obj.SetLODs(lODs);
	}

	private int LookupRendererIndex(SkeletonSkin[] renderers, Renderer renderer)
	{
		for (int i = 0; i < renderers.Length; i++)
		{
			if ((Object)(object)renderers[i].SkinnedMeshRenderer == (Object)(object)renderer)
			{
				return i;
			}
		}
		return -1;
	}

	private SkinnedMeshRenderer CopySkin(SkeletonSkin renderer)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = new GameObject();
		val.transform.parent = ((Component)this).transform;
		val.transform.localPosition = Vector3.zero;
		val.transform.localRotation = Quaternion.identity;
		val.transform.localScale = Vector3.one;
		val.layer = ((Component)this).gameObject.layer;
		return renderer.DuplicateAndRetarget(val, this);
	}

	public void CopySkeletonAttachments(SkeletonAttachment[] attachments)
	{
		for (int i = 0; i < attachments.Length; i++)
		{
			CopyAttachment(attachments[i]);
		}
	}

	private void CopyAttachment(SkeletonAttachment skeletonAttachment)
	{
		Skeleton componentInParent = ((Component)skeletonAttachment).GetComponentInParent<Skeleton>();
		if ((Object)(object)componentInParent == (Object)null)
		{
			throw new Exception("SkeletonAttachment has no Skeleton");
		}
		if ((Object)(object)Source != (Object)(object)componentInParent.Source)
		{
			throw new Exception("SkeletonAttachment uses different Skeleton");
		}
		int num = componentInParent.ReverseLookupBone(((Component)((Component)skeletonAttachment).transform.parent).gameObject);
		if (num < 0)
		{
			throw new Exception("SkeletonAttachment attached to bone that isn't in skeleton");
		}
		skeletonAttachment.CopyTo(Bones[num]);
	}

	private int ReverseLookupBone(GameObject bone)
	{
		return Array.IndexOf(Bones, bone);
	}

	public void Rebuild()
	{
		Bones = GetBones(((Component)this).gameObject, Source);
	}

	public static GameObject[] GetBones(GameObject root, SkeletonDefinition skeletonDef)
	{
		Transform[] allChildren = root.GetComponentsInChildren<Transform>();
		return skeletonDef.Bones.Select((SkeletonDefinition.Bone bone) => FindBoneImpl(root, in bone, allChildren)).ToArray();
	}

	private static GameObject FindBoneImpl(GameObject root, in SkeletonDefinition.Bone bone, Transform[] allChildren)
	{
		int num = 0;
		Transform val = null;
		foreach (Transform val2 in allChildren)
		{
			if (string.Equals(((Object)val2).name, bone.Name, StringComparison.OrdinalIgnoreCase))
			{
				num++;
				val = val2;
			}
		}
		if (num == 1)
		{
			return ((Component)val).gameObject;
		}
		if (num > 1)
		{
			Debug.LogWarning((object)(((Object)root).name + ": Multiple bones named " + bone.Name), (Object)(object)root);
			return null;
		}
		return null;
	}
}


using UnityEngine;

public class SkeletonAttachment : MonoBehaviour
{
	public void CopyTo(GameObject parent)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = new GameObject();
		val.transform.parent = parent.transform;
		val.transform.localPosition = ((Component)this).transform.localPosition;
		val.transform.localRotation = ((Component)this).transform.localRotation;
		val.transform.localScale = ((Component)this).transform.localScale;
		MeshFilter component = ((Component)this).GetComponent<MeshFilter>();
		if (Object.op_Implicit((Object)(object)component))
		{
			val.AddComponent<MeshFilter>().sharedMesh = component.sharedMesh;
		}
		MeshRenderer component2 = ((Component)this).GetComponent<MeshRenderer>();
		if (Object.op_Implicit((Object)(object)component2))
		{
			((Renderer)val.AddComponent<MeshRenderer>()).sharedMaterials = ((Renderer)component2).sharedMaterials;
		}
	}
}


using System;
using Facepunch;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[CreateAssetMenu(fileName = "Skeleton", menuName = "Facepunch/Skeleton Definition")]
public class SkeletonDefinition : ScriptableObject
{
	[Serializable]
	public struct Bone
	{
		public int Id;

		public int Depth;

		public int Parent;

		public string Name;

		public GameObject Target;

		public BoneFlag Flags;
	}

	[BurstCompile]
	private struct FindJob : IJob
	{
		public FixedString512Bytes Name;

		public NativeArray<FixedString512Bytes> Bones;

		public NativeReference<int> FoundIndex;

		public void Execute()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			FixedString512Bytes val = FixedStringMethods.ToLowerAscii<FixedString512Bytes>(ref Name);
			FoundIndex.Value = -1;
			for (int i = 0; i < Bones.Length; i++)
			{
				FixedString512Bytes val2 = Bones[i];
				if ((ref val) == (ref val2))
				{
					FoundIndex.Value = i;
					break;
				}
			}
		}
	}

	[Serializable]
	public struct RagdollSettings
	{
		[Serializable]
		public struct BodySide
		{
			public int Hip;

			public int Knee;

			public int Foot;

			public int Arm;

			public int Elbow;
		}

		public int Pelvis;

		public int Head;

		public int Spine;

		public BodySide Left;

		public BodySide Right;

		public float Mass;

		public float ArmGirth;

		public float LegGirth;

		public float HeadSize;

		public PhysicMaterial Material;
	}

	public GameObject SourceObject;

	public Bone[] Bones;

	[NonSerialized]
	private NativeArray<FixedString512Bytes> NativeBoneNames;

	[NonSerialized]
	private NativeReference<int> SearchIndex;

	public RagdollSettings Ragdoll;

	private void OnDestroy()
	{
		if (NativeBoneNames.IsCreated)
		{
			NativeBoneNames.Dispose();
		}
		if (SearchIndex.IsCreated)
		{
			SearchIndex.Dispose();
		}
	}

	public Bone FindBone(string name)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		FixedString512Bytes name2 = FixedString512Bytes.op_Implicit(name);
		if (!NativeBoneNames.IsCreated)
		{
			NativeBoneNames = new NativeArray<FixedString512Bytes>(Bones.Length, (Allocator)4, (NativeArrayOptions)1);
			FixedString512Bytes val = default(FixedString512Bytes);
			for (int i = 0; i < Bones.Length; i++)
			{
				Bone bone = Bones[i];
				((FixedString512Bytes)(ref val))..ctor(bone.Name);
				NativeBoneNames[i] = FixedStringMethods.ToLowerAscii<FixedString512Bytes>(ref val);
			}
		}
		if (!SearchIndex.IsCreated)
		{
			SearchIndex = new NativeReference<int>(-1, AllocatorHandle.op_Implicit((Allocator)4));
		}
		FindJob findJob = default(FindJob);
		findJob.Name = name2;
		findJob.Bones = NativeBoneNames;
		findJob.FoundIndex = SearchIndex;
		FindJob findJob2 = findJob;
		IJobExtensions.RunByRef<FindJob>(ref findJob2);
		if (SearchIndex.Value != -1)
		{
			return Bones[SearchIndex.Value];
		}
		return default(Bone);
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Bone
{
	public int Id;

	public int Depth;

	public int Parent;

	public string Name;

	public GameObject Target;

	public BoneFlag Flags;
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
private struct FindJob : IJob
{
	public FixedString512Bytes Name;

	public NativeArray<FixedString512Bytes> Bones;

	public NativeReference<int> FoundIndex;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		FixedString512Bytes val = FixedStringMethods.ToLowerAscii<FixedString512Bytes>(ref Name);
		FoundIndex.Value = -1;
		for (int i = 0; i < Bones.Length; i++)
		{
			FixedString512Bytes val2 = Bones[i];
			if ((ref val) == (ref val2))
			{
				FoundIndex.Value = i;
				break;
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct RagdollSettings
{
	[Serializable]
	public struct BodySide
	{
		public int Hip;

		public int Knee;

		public int Foot;

		public int Arm;

		public int Elbow;
	}

	public int Pelvis;

	public int Head;

	public int Spine;

	public BodySide Left;

	public BodySide Right;

	public float Mass;

	public float ArmGirth;

	public float LegGirth;

	public float HeadSize;

	public PhysicMaterial Material;
}


using System;

[Serializable]
public struct BodySide
{
	public int Hip;

	public int Knee;

	public int Foot;

	public int Arm;

	public int Elbow;
}


using Facepunch;

public class SkeletonRagdoll : Skeleton
{
}


using Facepunch;
using UnityEngine;

[AddComponentMenu("Facepunch/SkeletonSkin")]
[ExecuteInEditMode]
public class SkeletonSkin : MonoBehaviour
{
	public SkinnedMeshRenderer SkinnedMeshRenderer;

	public SkeletonDefinition SkeletonDefinition;

	public int LOD;

	public int RootBone;

	public int[] TargetBones;

	public Transform[] BoneTransforms;

	public void Retarget(Skeleton target)
	{
		if (TargetBones == null || BoneTransforms == null)
		{
			return;
		}
		SkinnedMeshRenderer.rootBone = target.GetTransform(RootBone);
		bool flag = (Object)(object)SkeletonDefinition != (Object)(object)target.Source;
		for (int i = 0; i < BoneTransforms.Length; i++)
		{
			Transform val = (flag ? target.GetTransformSlow(SkeletonDefinition.Bones[TargetBones[i]].Name) : target.GetTransform(TargetBones[i]));
			if ((Object)(object)val == (Object)null)
			{
				Debug.LogWarning((object)("Skeleton retarget didn't find a bone: " + SkeletonDefinition.Bones[TargetBones[i]].Name));
			}
			BoneTransforms[i] = val;
		}
		SkinnedMeshRenderer.bones = BoneTransforms;
		for (int j = 0; j < BoneTransforms.Length; j++)
		{
			BoneTransforms[j] = null;
		}
	}

	public SkinnedMeshRenderer DuplicateAndRetarget(GameObject host, Skeleton target)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		SkinnedMeshRenderer val = host.AddComponent<SkinnedMeshRenderer>();
		((Renderer)val).receiveShadows = ((Renderer)SkinnedMeshRenderer).receiveShadows;
		val.skinnedMotionVectors = SkinnedMeshRenderer.skinnedMotionVectors;
		((Renderer)val).motionVectorGenerationMode = ((Renderer)SkinnedMeshRenderer).motionVectorGenerationMode;
		val.updateWhenOffscreen = SkinnedMeshRenderer.updateWhenOffscreen;
		((Renderer)val).localBounds = ((Renderer)SkinnedMeshRenderer).localBounds;
		((Renderer)val).shadowCastingMode = ((Renderer)SkinnedMeshRenderer).shadowCastingMode;
		val.sharedMesh = SkinnedMeshRenderer.sharedMesh;
		((Renderer)val).sharedMaterials = ((Renderer)SkinnedMeshRenderer).sharedMaterials;
		val.rootBone = target.GetTransform(RootBone);
		Transform[] array = (Transform[])(object)new Transform[TargetBones.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = target.GetTransform(TargetBones[i]);
		}
		val.bones = array;
		return val;
	}
}


using UnityEngine;

[AddComponentMenu("Facepunch/Skeleton Skin LOD")]
[RequireComponent(typeof(LODGroup))]
[ExecuteInEditMode]
public class SkeletonSkinLod : MonoBehaviour
{
	private static LOD[] emptyLOD = (LOD[])(object)new LOD[1];

	public LODGroup LODGroup;

	[Range(0f, 1f)]
	public float LodRange0 = 0.15f;

	[Range(0f, 1f)]
	public float LodRange1 = 0.05f;

	[Range(0f, 1f)]
	public float LodRange2 = 0.02f;

	[Range(0f, 1f)]
	public float LodRange3 = 0.003f;

	private LOD[] LODs;

	private void Awake()
	{
		SetUpLODArray();
	}

	private void SetUpLODArray()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		if (LODs == null)
		{
			LODs = (LOD[])(object)new LOD[5];
			LODs[0] = new LOD(LodRange0, (Renderer[])(object)new Renderer[32]);
			LODs[1] = new LOD(LodRange1, (Renderer[])(object)new Renderer[32]);
			LODs[2] = new LOD(LodRange2, (Renderer[])(object)new Renderer[32]);
			LODs[3] = new LOD(LodRange3, (Renderer[])(object)new Renderer[32]);
			LODs[4] = new LOD(LodRange3 * 0.5f, (Renderer[])(object)new Renderer[32]);
		}
	}

	public void AddRenderer(int lod, Renderer r)
	{
		if (lod == -1)
		{
			return;
		}
		if (LODs == null)
		{
			SetUpLODArray();
		}
		for (int i = 0; i < 32 && !((Object)(object)LODs[lod].renderers[i] == (Object)(object)r); i++)
		{
			if ((Object)(object)LODs[lod].renderers[i] == (Object)null)
			{
				LODs[lod].renderers[i] = r;
				if (lod == 4)
				{
					LODs[4].screenRelativeTransitionHeight = LodRange3 * 0.5f;
					LODs[3].screenRelativeTransitionHeight = LodRange2 * 0.5f;
				}
				break;
			}
		}
	}

	public void Clear()
	{
		if ((Object)(object)LODGroup == (Object)null || LODs == null)
		{
			return;
		}
		if (LODs == null)
		{
			SetUpLODArray();
		}
		for (int i = 0; i < LODs.Length; i++)
		{
			for (int j = 0; j < 32; j++)
			{
				LODs[i].renderers[j] = null;
			}
		}
		LODGroup.SetLODs(emptyLOD);
		LODs[4].screenRelativeTransitionHeight = LodRange3 * 0.999f;
		LODs[3].screenRelativeTransitionHeight = LodRange3;
	}

	public void Rebuild()
	{
		if (!((Object)(object)LODGroup == (Object)null))
		{
			if (LODs == null)
			{
				SetUpLODArray();
			}
			LODGroup.SetLODs(LODs);
		}
	}

	public void SoftRebuild()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)LODGroup == (Object)null))
		{
			if (LODs == null)
			{
				SetUpLODArray();
				return;
			}
			LODs[0] = new LOD(LodRange0, LODs[0].renderers);
			LODs[1] = new LOD(LodRange1, LODs[1].renderers);
			LODs[2] = new LOD(LodRange2, LODs[2].renderers);
			LODs[3] = new LOD(LodRange3, LODs[3].renderers);
			LODs[4] = new LOD(LodRange3 * 0.5f, LODs[4].renderers);
			LODGroup.SetLODs(LODs);
		}
	}
}


using System;
using Facepunch;
using Unity.Jobs;
using UnityEngine;

[DOTSCompilerGenerated]
internal class __JobReflectionRegistrationOutput__17411244733757682161
{
	public static void CreateJobReflectionData()
	{
		try
		{
			IJobExtensions.EarlyJobInit<SkeletonDefinition.FindJob>();
		}
		catch (Exception ex)
		{
			EarlyInitHelpers.JobReflectionDataCreationFailed(ex);
		}
	}

	[RuntimeInitializeOnLoadMethod(/*Could not decode attribute arguments.*/)]
	public static void EarlyInit()
	{
		CreateJobReflectionData();
	}
}


