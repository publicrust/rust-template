using System;
using System.Collections;
using System.IO;
using System.Threading;
using Facepunch.Extend;
using Facepunch.Utility;
using Rust;
using Rust.Workshop.Editor;
using UnityEngine;
using UnityEngine.UI;

public class TextureRow : MaterialRow
{
	private string Filename;

	public bool IsNormalMap;

	public RawImage TargetImage;

	public Text FilenameLabel;

	public Button Reset;

	public Button Clear;

	public bool HasChanges;

	private Texture Default;

	private FileSystemWatcher watcher;

	public bool IsDefault => (Object)(object)Default == (Object)(object)TargetImage.texture;

	public bool IsClear => (Object)(object)TargetImage.texture == (Object)null;

	public void Update()
	{
		((Component)Reset).gameObject.SetActive(!IsDefault);
		((Component)Clear).gameObject.SetActive(!IsClear);
		lock (this)
		{
			if (HasChanges)
			{
				try
				{
					Load(Filename);
					HasChanges = false;
					return;
				}
				catch
				{
					Thread.Sleep(10);
					return;
				}
			}
		}
	}

	public void SetFilenameText(string filename)
	{
		FilenameLabel.text = StringExtensions.TruncateFilename(filename, 48, (string)null);
	}

	public void OnDisable()
	{
		if (!Application.isQuitting)
		{
			StopWatching();
		}
	}

	public void OpenFileBrowser()
	{
		((MonoBehaviour)this).StartCoroutine(BrowseForTexture());
	}

	public IEnumerator BrowseForTexture()
	{
		yield return ((MonoBehaviour)this).StartCoroutine(base.Editor.FileDialog.Open((string)null, ".png|.jpg", "OPEN FILE", (Sprite)null, -1L, true));
		if (base.Editor.FileDialog.result == null)
		{
			yield break;
		}
		FileInfo fileInfo = new FileInfo(base.Editor.FileDialog.result);
		try
		{
			Load(fileInfo.FullName);
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)("Couldn't load texture: " + ex.Message));
		}
	}

	public void Load(string fullname)
	{
		StopWatching();
		FileInfo fileInfo = new FileInfo(fullname);
		if (fileInfo.Exists)
		{
			Texture2D val = base.Editor.SetTexture(ParamName, fileInfo.FullName, IsNormalMap);
			if (Object.op_Implicit((Object)(object)val))
			{
				SetTexture((Texture)(object)val);
				StartWatching();
			}
		}
	}

	public void SetTexture(Texture tex)
	{
		TargetImage.texture = tex;
		if ((Object)(object)tex != (Object)null)
		{
			Filename = ((Object)tex).name;
			SetFilenameText(Filename);
		}
		if (IsDefault)
		{
			Filename = "Default";
			SetFilenameText(Filename);
		}
		if ((Object)(object)tex == (Object)null)
		{
			Filename = "None";
			SetFilenameText(Filename);
		}
	}

	public override void Read(Material source, Material def)
	{
		StopWatching();
		Texture texture = source.GetTexture(ParamName);
		Default = def.GetTexture(ParamName);
		SetTexture(texture);
	}

	public void OpenFileLocation()
	{
		if (!IsDefault)
		{
			Os.OpenFolder(Filename);
		}
	}

	public void SaveFile()
	{
		if (!((Object)(object)TargetImage.texture == (Object)null))
		{
			((MonoBehaviour)this).StartCoroutine(DoSaveFile());
		}
	}

	private IEnumerator DoSaveFile()
	{
		yield return ((MonoBehaviour)this).StartCoroutine(base.Editor.FileDialog.Save((string)null, ".png", "SAVE FILE", (Sprite)null, true, (string)null));
		if (!string.IsNullOrEmpty(base.Editor.FileDialog.result))
		{
			Debug.Log((object)("Save Png to " + base.Editor.FileDialog.result));
			Texture val = TargetImage.texture;
			Texture2D val2 = (Texture2D)val;
			bool num = IsNormalMap && (int)val2.format != 5 && (int)val2.format != 4;
			if (num)
			{
				val = (Texture)(object)Texture.CreateReadableCopy((Texture2D)(object)((val is Texture2D) ? val : null), 0, 0, false);
				Texture.DecompressNormals((Texture2D)(object)((val is Texture2D) ? val : null));
			}
			Texture.SaveAsPng(val, base.Editor.FileDialog.result);
			if (num)
			{
				Object.Destroy((Object)(object)val);
			}
		}
	}

	public void ResetToDefault()
	{
		StopWatching();
		SetTexture(Default);
		base.Editor.SetTexture(ParamName, Default);
	}

	public void ResetToClear()
	{
		StopWatching();
		SetTexture(null);
		base.Editor.SetTexture(ParamName, null);
	}

	public void StartWatching()
	{
		StopWatching();
		FileInfo fileInfo = new FileInfo(Filename);
		if (fileInfo.Exists)
		{
			watcher = new FileSystemWatcher();
			watcher.Path = fileInfo.Directory.FullName;
			watcher.Filter = fileInfo.Name;
			watcher.NotifyFilter = NotifyFilters.Size | NotifyFilters.LastWrite;
			watcher.Changed += delegate(object a, FileSystemEventArgs e)
			{
				FileChanged(e.FullPath);
			};
			watcher.EnableRaisingEvents = true;
		}
	}

	public void FileChanged(string name)
	{
		lock (this)
		{
			HasChanges = true;
		}
	}

	public void StopWatching()
	{
		if (watcher != null)
		{
			watcher.Dispose();
			watcher = null;
		}
	}
}


public interface IWorkshopScreenshotCamera
{
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using Facepunch.Extend;
using Facepunch.Utility;
using Newtonsoft.Json;
using Rust;
using Rust.Workshop;
using Steamworks;
using Steamworks.Data;
using Steamworks.Ugc;
using UnityEngine;
using UnityEngine.UI;

public class Publisher : MonoBehaviour
{
	public InputField ChangeLog;

	public Button PublishButton;

	public Texture2D IconBackground;

	public static Action PreIconRender;

	public static Action PostIconRender;

	public List<Transform> DeployableScreenshotAnchors;

	public List<Transform> ClothingScreenshotAnchors;

	public List<Transform> WeaponScreenshotAnchors;

	public Transform FirstPersonViewScreenshotAnchor;

	public GameObject screenshotCamera;

	public Toggle flashlightToggle;

	public Toggle rainToggle;

	public Toggle fogToggle;

	public Toggle spotlightToggle;

	public Toggle firstPersonToggle;

	public Toggle adsToggle;

	public Slider timeSlider;

	private Skinnable Skinnable;

	private Skin Skin;

	private ulong ItemId;

	private string Title;

	private GameObject Prefab;

	private List<string> AutomatedScreenshotPaths = new List<string>();

	private static readonly int API_SEND_CHUNK_SIZE = 3;

	protected WorkshopItemEditor Editor => SingletonComponent<WorkshopItemEditor>.Instance;

	public void StartExport()
	{
		DoExport(publishToSteam: true, OpenFolder: false);
	}

	public void Update()
	{
		((Selectable)PublishButton).interactable = CanPublish();
	}

	public bool CanPublish()
	{
		if (Editor.ItemTitle.Length == 0)
		{
			return false;
		}
		return true;
	}

	private async Task DoExport(bool publishToSteam, bool OpenFolder, string forceFolderName = null)
	{
		_ = 1;
		try
		{
			Skinnable = Editor.Skinnable;
			Skin = Editor.Skin;
			ItemId = Editor.ItemId;
			Title = Editor.ItemTitle;
			Prefab = Editor.Prefab;
			WorkshopItemEditor.Loading(v1: true, "Exporting..", "", 0f);
			string tempFolder = Path.GetTempFileName();
			File.Delete(tempFolder);
			Directory.CreateDirectory(tempFolder);
			if (forceFolderName != null)
			{
				tempFolder = forceFolderName;
			}
			Debug.Log((object)tempFolder);
			await ExportToFolder(tempFolder, OpenFolder);
			if (publishToSteam)
			{
				await PublishToSteam(tempFolder);
			}
			if (forceFolderName != tempFolder)
			{
				Directory.Delete(tempFolder, recursive: true);
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
		finally
		{
			WorkshopItemEditor.Loading(v1: false, "", "", 0f);
		}
	}

	private async Task ExportToFolder(string folder, bool OpenFolder)
	{
		Skin.Manifest data = new Skin.Manifest
		{
			ItemType = Skinnable.Name,
			Version = 3,
			Groups = new Skin.Manifest.Group[Skin.Materials.Length],
			PublishDate = DateTime.UtcNow,
			AuthorId = SteamId.op_Implicit(SteamClient.SteamId)
		};
		for (int i = 0; i < Skin.Materials.Length; i++)
		{
			data.Groups[i] = new Skin.Manifest.Group();
			Material mat = Skin.Materials[i];
			Skin.Manifest.Group group = data.Groups[i];
			bool isCloth = ((Object)mat.shader).name.Contains("Cloth");
			bool hasDetailLayer = mat.IsKeywordEnabled("_DETAILLAYER_ON");
			bool hasDirtLayer = mat.IsKeywordEnabled("_DIRTLAYER_ON");
			bool isSpecular = ((Object)mat.shader).name.Contains("Specular") || mat.GetInt("_MaterialType") == 1;
			await ExportTexture(group.Textures, folder, i, "_MainTex", mat, Skin.DefaultMaterials[i]);
			await ExportTexture(group.Textures, folder, i, "_OcclusionMap", mat, Skin.DefaultMaterials[i]);
			if (!isSpecular)
			{
				await ExportTexture(group.Textures, folder, i, "_MetallicGlossMap", mat, Skin.DefaultMaterials[i]);
			}
			else
			{
				await ExportTexture(group.Textures, folder, i, "_SpecGlossMap", mat, Skin.DefaultMaterials[i]);
			}
			await ExportTexture(group.Textures, folder, i, "_BumpMap", mat, Skin.DefaultMaterials[i], isNormalMap: true);
			await ExportTexture(group.Textures, folder, i, "_EmissionMap", mat, Skin.DefaultMaterials[i]);
			if (isCloth)
			{
				await ExportTexture(group.Textures, folder, i, "_MicrofiberFuzzMask", mat, Skin.DefaultMaterials[i]);
			}
			if (hasDetailLayer)
			{
				await ExportTexture(group.Textures, folder, i, "_DetailAlbedoMap", mat, Skin.DefaultMaterials[i]);
				await ExportTexture(group.Textures, folder, i, "_DetailMask", mat, Skin.DefaultMaterials[i]);
				await ExportTexture(group.Textures, folder, i, "_DetailNormalMap", mat, Skin.DefaultMaterials[i], isNormalMap: true);
				await ExportTexture(group.Textures, folder, i, "_DetailOcclusionMap", mat, Skin.DefaultMaterials[i]);
			}
			if (hasDirtLayer)
			{
				await ExportTexture(group.Textures, folder, i, "_DirtColor", mat, Skin.DefaultMaterials[i]);
			}
			group.Floats.Add("_Cutoff", mat.GetFloat("_Cutoff"));
			group.Floats.Add("_BumpScale", mat.GetFloat("_BumpScale"));
			group.Floats.Add("_Glossiness", mat.GetFloat("_Glossiness"));
			if (!isSpecular)
			{
				group.Floats.Add("_Metallic", mat.GetFloat("_Metallic"));
			}
			group.Floats.Add("_OcclusionStrength", mat.GetFloat("_OcclusionStrength"));
			if (isCloth)
			{
				group.Floats.Add("_MicrofiberFuzzIntensity", mat.GetFloat("_MicrofiberFuzzIntensity"));
				group.Floats.Add("_MicrofiberFuzzScatter", mat.GetFloat("_MicrofiberFuzzScatter"));
				group.Floats.Add("_MicrofiberFuzzOcclusion", mat.GetFloat("_MicrofiberFuzzOcclusion"));
			}
			if (hasDetailLayer)
			{
				group.Floats.Add("_DetailNormalMapScale", mat.GetFloat("_DetailNormalMapScale"));
				group.Floats.Add("_DetailOcclusionStrength", mat.GetFloat("_DetailOcclusionStrength"));
				group.Floats.Add("_DetailOverlaySmoothness", mat.GetFloat("_DetailOverlaySmoothness"));
				group.Floats.Add("_DetailOverlaySpecular", mat.GetFloat("_DetailOverlaySpecular"));
			}
			if (hasDirtLayer)
			{
				group.Floats.Add("_DirtAmount", mat.GetFloat("_DirtAmount"));
			}
			group.Colors.Add("_Color", new Skin.Manifest.ColorEntry(mat.GetColor("_Color")));
			if (isSpecular)
			{
				group.Colors.Add("_SpecColor", new Skin.Manifest.ColorEntry(mat.GetColor("_SpecColor")));
			}
			group.Colors.Add("_EmissionColor", new Skin.Manifest.ColorEntry(mat.GetColor("_EmissionColor")));
			if (isCloth)
			{
				group.Colors.Add("_MicrofiberFuzzColor", new Skin.Manifest.ColorEntry(mat.GetColor("_MicrofiberFuzzColor")));
			}
			if (hasDetailLayer)
			{
				group.Colors.Add("_DetailColor", new Skin.Manifest.ColorEntry(mat.GetColor("_DetailColor")));
			}
		}
		PreIconRender?.Invoke();
		await Task.Delay(TimeSpan.FromSeconds(1.0));
		WorkshopItemEditor.Loading(v1: true, "Exporting Screenshots - Icons", "", 0f);
		PropRenderer.RenderScreenshot(Prefab, folder + "/icon.png", 512, 512, 4);
		CreateWorkshopIcon(folder);
		PostIconRender?.Invoke();
		string contents = JsonConvert.SerializeObject((object)data, (Formatting)1);
		File.WriteAllText(folder + "/manifest.txt", contents);
		if (OpenFolder)
		{
			Os.OpenFolder(folder);
		}
	}

	private void CreateWorkshopIcon(string folder)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Expected O, but got Unknown
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Expected O, but got Unknown
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Expected O, but got Unknown
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Expected O, but got Unknown
		//IL_0076: Expected O, but got Unknown
		Texture2D val = new Texture2D(512, 512, (TextureFormat)5, false);
		ImageConversion.LoadImage(val, File.ReadAllBytes(folder + "/icon.png"));
		RenderTexture val2 = new RenderTexture(512, 512, 0);
		RenderTextureEx.Blit(val2, (Texture)(object)IconBackground);
		RenderTextureEx.BlitWithAlphaBlending(val2, (Texture)(object)val);
		RenderTextureEx.ToTexture(val2, (Texture)(object)val);
		File.WriteAllBytes(bytes: ImageConversion.EncodeToPNG(val), path: folder + "/icon_background.png");
		Object.DestroyImmediate((Object)(object)val);
		Object.DestroyImmediate((Object)val2);
	}

	private async Task PublishToSteam(string folder)
	{
		Editor val = default(Editor);
		if (ItemId == 0L)
		{
			val = Editor.NewMicrotransactionFile;
		}
		else
		{
			((Editor)(ref val))..ctor(PublishedFileId.op_Implicit(ItemId));
		}
		Editor val2 = ((Editor)(ref val)).WithContent(folder);
		val2 = ((Editor)(ref val2)).WithPreviewFile(folder + "/icon_background.png");
		val2 = ((Editor)(ref val2)).WithTitle(Title);
		val2 = ((Editor)(ref val2)).WithTag("Version3");
		val2 = ((Editor)(ref val2)).WithTag(Skinnable.Name);
		val2 = ((Editor)(ref val2)).WithTag("Skin");
		val = ((Editor)(ref val2)).WithPublicVisibility();
		if (!string.IsNullOrEmpty(ChangeLog.text))
		{
			val = ((Editor)(ref val)).WithChangeLog(ChangeLog.text);
		}
		WorkshopItemEditor.Loading(v1: true, "Publishing To Steam", "", 0f);
		PublishResult result = await ((Editor)(ref val)).SubmitAsync((IProgress<float>)null, (Action<PublishResult>)null);
		if (!((PublishResult)(ref result)).Success)
		{
			Debug.LogError((object)("Error: " + ((object)(Result)(ref result.Result)/*cast due to .constrained prefix*/).ToString()));
		}
		else
		{
			PublishedFileId fileId = result.FileId;
			Debug.Log((object)("Published File: " + ((object)(PublishedFileId)(ref fileId)/*cast due to .constrained prefix*/).ToString()));
		}
		Item? item = await SteamUGC.QueryFileAsync(result.FileId);
		if (!item.HasValue)
		{
			Debug.Log((object)"Error Retrieving item information!");
			return;
		}
		if (((PublishResult)(ref result)).Success && AutomatedScreenshotPaths != null)
		{
			List<List<string>> list = ListEx.ChunkBy<string>(AutomatedScreenshotPaths, API_SEND_CHUNK_SIZE);
			foreach (List<string> chunk in list)
			{
				val = new Editor(result.FileId);
				foreach (string item2 in chunk)
				{
					val = ((Editor)(ref val)).AddAdditionalPreviewFile(item2, (ItemPreviewType)0);
				}
				result = await ((Editor)(ref val)).SubmitAsync((IProgress<float>)null, (Action<PublishResult>)null);
				Debug.Log((object)$"Updated Workshop Item with [{chunk.Count}] screenshots, result: [{result.Result}]");
			}
		}
		WorkshopItemEditor editor = Editor;
		Item value = item.Value;
		editor.ItemId = PublishedFileId.op_Implicit(((Item)(ref value)).Id);
		WorkshopItemEditor editor2 = Editor;
		value = item.Value;
		editor2.ItemTitle = ((Item)(ref value)).Title;
		ChangeLog.text = "";
		value = item.Value;
		Application.OpenURL(((Item)(ref value)).Url);
	}

	private async Task ExportTexture(Dictionary<string, string> data, string folder, int group, string paramname, Material mat, Material defaultMat, bool isNormalMap = false)
	{
		WorkshopItemEditor.Loading(v1: true, "Exporting Texture " + paramname, "", 0f);
		Texture texture = mat.GetTexture(paramname);
		Texture texture2 = defaultMat.GetTexture(paramname);
		if (!((Object)(object)texture == (Object)(object)texture2))
		{
			if ((Object)(object)texture == (Object)null)
			{
				data.Add(paramname, "none");
				return;
			}
			texture = (Texture)(object)Texture.LimitSize((Texture2D)texture, Skinnable.Groups[group].MaxTextureSize, Skinnable.Groups[group].MaxTextureSize, isNormalMap);
			string text = string.Format("{0}{1}{2}", paramname, group, ".png");
			data.Add(paramname, text);
			Texture.SaveAsPng(texture, folder + "/" + text);
			await Task.Delay(1);
		}
	}

	public void Export()
	{
		DoExport();
	}

	public async Task DoExport()
	{
		string text = await Editor.FileDialog.SaveAsync((string)null, (string)null, "SAVE FILE", (Sprite)null, true);
		if (text != null && !File.Exists(text))
		{
			if (!Directory.Exists(text))
			{
				Directory.CreateDirectory(text);
			}
			await DoExport(publishToSteam: false, OpenFolder: true, text);
		}
	}
}


using UnityEngine;

public class WorkshopCameraKeybindAnchor : MonoBehaviour
{
	public KeyCode holdKey = (KeyCode)306;

	public KeyCode pressKey;
}


using Facepunch.Extend;
using Rust;
using Rust.Workshop;
using UnityEngine;

internal class WorkshopPlayerPreview : MonoBehaviour
{
	public static GameObject Instance;

	protected WorkshopInterface Interface => ((Component)this).GetComponentInParent<WorkshopInterface>();

	public void Setup(GameObject ClothingPrefab, ulong id, bool focus, bool IsClothing, float additionalZoom = 0f)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		Cleanup();
		Instance = Global.CreatePrefab("assets/prefabs/player/player_model.prefab");
		Instance.transform.position = Vector3.zero;
		Instance.transform.rotation = Quaternion.identity;
		Instance.SetActive(true);
		ClothingPrefab.transform.SetParent(Instance.transform);
		ClothingPrefab.SetActive(false);
		Instance.transform.position = SingletonComponent<WorkshopItemEditor>.Instance.item_position_a.transform.position;
		Instance.transform.rotation = SingletonComponent<WorkshopItemEditor>.Instance.item_position_a.transform.rotation;
		if (focus)
		{
			FocusCameraOnPreview(additionalZoom);
		}
	}

	public static void FocusCameraOnPreview(float additionalZoom = 0f)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)Instance == (Object)null))
		{
			CameraEx.FocusOnRenderer(Camera.main, Instance, new Vector3(0.3f, 0.1f, 1f), Vector3.up, -1, additionalZoom);
		}
	}

	public void Cleanup()
	{
		if ((Object)(object)Instance != (Object)null)
		{
			Object.Destroy((Object)(object)Instance);
			Instance = null;
		}
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Cleanup();
		}
	}
}


using Facepunch.Extend;
using Rust.Platform.Steam;
using Rust.Workshop;
using Steamworks.Ugc;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class WorkshopView : MonoBehaviour
{
	public TextMeshProUGUI Title;

	public TextMeshProUGUI AuthorName;

	public TextMeshProUGUI VoteInfo;

	public Button VoteUp;

	public Button VoteDown;

	private IWorkshopContent item;

	protected WorkshopInterface Interface => ((Component)this).GetComponentInParent<WorkshopInterface>();

	protected WorkshopItemEditor Editor => Interface.Editor;

	public void Update()
	{
		if (item != null && string.IsNullOrEmpty(((TMP_Text)AuthorName).text))
		{
			((TMP_Text)AuthorName).text = StringExtensions.Truncate(item.Owner.UserName, 32, (string)null).ToUpper();
		}
	}

	public void UpdateFrom(IWorkshopContent item)
	{
		this.item = item;
		if (this.item != null)
		{
			((TMP_Text)Title).text = StringExtensions.Truncate(item.Title, 24, (string)null).ToUpper();
			((TMP_Text)AuthorName).text = StringExtensions.Truncate(item.Owner.UserName, 32, (string)null).ToUpper();
		}
		else
		{
			((TMP_Text)Title).text = "FAILED TO LOAD SKIN";
			((TMP_Text)AuthorName).text = "";
		}
	}

	public void OnVoteUp()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (item != null)
		{
			IWorkshopContent obj = item;
			SteamWorkshopContent val = (SteamWorkshopContent)(object)((obj is SteamWorkshopContent) ? obj : null);
			if (val != null)
			{
				Item value = val.Value;
				((Item)(ref value)).Vote(true);
			}
			UpdateFrom(item);
		}
	}

	public void OnVoteDown()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (item != null)
		{
			IWorkshopContent obj = item;
			SteamWorkshopContent val = (SteamWorkshopContent)(object)((obj is SteamWorkshopContent) ? obj : null);
			if (val != null)
			{
				Item value = val.Value;
				((Item)(ref value)).Vote(false);
			}
			UpdateFrom(item);
		}
	}

	public void OpenWeb()
	{
		if (item != null)
		{
			IWorkshopContent obj = item;
			Application.OpenURL((obj != null) ? obj.Url : null);
		}
	}

	internal void Clear()
	{
		item = null;
		((TMP_Text)Title).text = "";
		((TMP_Text)AuthorName).text = "";
	}
}


using System.Collections;
using Facepunch.Utility;
using Rust.Workshop;
using Rust.Workshop.Import;
using UnityEngine;

internal class ImportVersion1 : SingletonComponent<ImportVersion1>
{
	internal IEnumerator DoImport(IWorkshopContent item, Skin skin)
	{
		WorkshopItemEditor.Loading(v1: true, "Downloading..", "", 0f);
		if (!item.IsInstalled)
		{
			item.Download();
			while (item.IsDownloading)
			{
				yield return null;
			}
			WorkshopItemEditor.Loading(v1: true, "Installing..", "", 0f);
			while (!item.IsInstalled)
			{
				yield return null;
			}
		}
		Os.OpenFolder(item.Directory);
		WorkshopItemEditor.Loading(v1: true, "Unable To Import", "", 0f);
		yield return (object)new WaitForSeconds(5f);
	}
}


using System;
using System.Collections;
using System.IO;
using Facepunch.Utility;
using Rust;
using Rust.Workshop;
using Rust.Workshop.Import;
using UnityEngine;

internal class ImportVersion2 : SingletonComponent<ImportVersion2>
{
	private AssetBundle Bundle;

	public void OnDisable()
	{
		if (!Application.isQuitting && (Object)(object)Bundle != (Object)null)
		{
			Bundle.Unload(true);
			Bundle = null;
			Debug.Log((object)"CLEANUP BUNDLE");
		}
	}

	internal IEnumerator DoImport(IWorkshopContent item, Skin skin)
	{
		if ((Object)(object)Bundle != (Object)null)
		{
			Bundle.Unload(true);
			Bundle = null;
		}
		WorkshopItemEditor.Loading(v1: true, "Downloading..", "", 0f);
		if (!item.IsInstalled)
		{
			item.Download();
			while (item.IsDownloading)
			{
				yield return null;
			}
			while (!item.IsInstalled)
			{
				yield return null;
			}
		}
		string text = item.Directory + "/bundle";
		if (File.Exists(text))
		{
			yield return ((MonoBehaviour)this).StartCoroutine(LoadItem(item.Directory, text, skin));
			yield break;
		}
		Debug.LogWarning((object)"No Bundle Found!");
		Os.OpenFolder(item.Directory);
		yield return (object)new WaitForSeconds(5f);
	}

	public IEnumerator LoadItem(string Folder, string BundleName, Skin skin)
	{
		AssetBundleCreateRequest request = AssetBundle.LoadFromFileAsync(BundleName);
		yield return (object)new WaitUntil((Func<bool>)(() => ((AsyncOperation)request).isDone));
		if ((Object)(object)request.assetBundle == (Object)null)
		{
			Debug.LogWarning((object)"Asset bundle is null!");
			yield break;
		}
		Bundle = request.assetBundle;
		WorkshopSkinBase asset = request.assetBundle.LoadAsset<WorkshopSkinBase>("Meta.asset");
		if ((Object)(object)asset == (Object)null)
		{
			string[] allAssetNames = request.assetBundle.GetAllAssetNames();
			foreach (string text in allAssetNames)
			{
				asset = request.assetBundle.LoadAsset<WorkshopSkinBase>(text);
				if ((Object)(object)asset != (Object)null)
				{
					break;
				}
			}
		}
		if ((Object)(object)asset == (Object)null)
		{
			Os.OpenFolder(Folder);
			yield return (object)new WaitForSeconds(5f);
			yield break;
		}
		yield return ((MonoBehaviour)this).StartCoroutine(ProcessMaterial(0, asset.skinMaterial0, skin));
		yield return ((MonoBehaviour)this).StartCoroutine(ProcessMaterial(1, asset.skinMaterial1, skin));
		yield return ((MonoBehaviour)this).StartCoroutine(ProcessMaterial(2, asset.skinMaterial2, skin));
		yield return ((MonoBehaviour)this).StartCoroutine(ProcessMaterial(3, asset.skinMaterial3, skin));
	}

	private IEnumerator ProcessMaterial(int v, Material inputMaterial, Skin skin)
	{
		if ((Object)(object)inputMaterial == (Object)null || skin.Materials.Length <= v)
		{
			yield break;
		}
		yield return null;
		ImportTexture("_MainTex", inputMaterial, skin.Materials[v], normal: false, skin, v);
		ImportTexture("_BumpMap", inputMaterial, skin.Materials[v], normal: true, skin, v);
		ImportTexture("_OcclusionMap", inputMaterial, skin.Materials[v], normal: false, skin, v);
		if ((Object)(object)ImportTexture("_SpecGlossMap", inputMaterial, skin.Materials[v], normal: false, skin, v) == (Object)null)
		{
			Texture2D val = ImportTexture("_MetallicGlossMap", inputMaterial, skin.Materials[v], normal: false, skin, v, "_SpecGlossMap");
			if ((Object)(object)val != (Object)null)
			{
				ConvertMetalToSpec(val, skin.Materials[v]);
			}
		}
	}

	private Texture2D ImportTexture(string name, Material inputMaterial, Material outputMaterial, bool normal, Skin skin, int group, string targetName = null)
	{
		if (targetName == null)
		{
			targetName = name;
		}
		Texture texture = outputMaterial.GetTexture(name);
		Texture texture2 = inputMaterial.GetTexture(name);
		if ((Object)(object)texture2 == (Object)null)
		{
			return null;
		}
		if ((Object)(object)texture == (Object)null || ((Object)texture2).name == ((Object)texture).name)
		{
			return null;
		}
		texture2 = (Texture)(object)Texture.LimitSize((Texture2D)(object)((texture2 is Texture2D) ? texture2 : null), skin.Skinnable.Groups[group].MaxTextureSize, skin.Skinnable.Groups[group].MaxTextureSize, normal);
		outputMaterial.SetTexture(targetName, texture2);
		return (Texture2D)(object)((texture2 is Texture2D) ? texture2 : null);
	}

	private Texture2D ConvertMetalToSpec(Texture2D tex, Material outputMaterial)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		tex = Texture.CreateReadableCopy(tex, 0, 0, false);
		Color val = default(Color);
		for (int i = 0; i < ((Texture)tex).height; i++)
		{
			for (int j = 0; j < ((Texture)tex).width; j++)
			{
				Color pixel = tex.GetPixel(j, i);
				if (pixel.a == 0f)
				{
					pixel.a = 0.007843138f;
				}
				((Color)(ref val))..ctor(pixel.r, pixel.r, pixel.r, pixel.a);
				tex.SetPixel(j, i, val);
			}
		}
		tex.Apply();
		outputMaterial.SetTexture("_SpecGlossMap", (Texture)(object)tex);
		outputMaterial.SetFloat("_Glossiness", 1f);
		outputMaterial.SetColor("_SpecColor", Color.white);
		return tex;
	}
}


using System.Collections;
using Rust.Workshop;
using Rust.Workshop.Import;
using UnityEngine;

internal class ImportVersion3 : SingletonComponent<ImportVersion3>
{
	internal IEnumerator DoImport(IWorkshopContent item, Skin skin, bool compressTexturesOnLoad = true)
	{
		WorkshopItemEditor.Loading(v1: true, "Downloading..", "", 0f);
		yield return ((MonoBehaviour)this).StartCoroutine(DownloadFromWorkshop(item));
		if (!item.IsInstalled || item.Directory == null)
		{
			Debug.Log((object)"Error opening item, not downloaded properly.");
			Debug.Log((object)("item.Directory: " + item.Directory));
			Debug.Log((object)("item.Installed: " + item.IsInstalled));
		}
		else
		{
			WorkshopItemEditor.Loading(v1: true, "Loading..", "Reloading Textures", 0f);
			yield return ((MonoBehaviour)this).StartCoroutine(skin.LoadIcon(item.WorkshopId, item.Directory));
			yield return ((MonoBehaviour)this).StartCoroutine(skin.LoadAssets(item.WorkshopId, item.Directory, null, compressTexturesOnLoad));
		}
	}

	private IEnumerator DownloadFromWorkshop(IWorkshopContent item)
	{
		item.Download();
		while (item.IsDownloading)
		{
			yield return null;
		}
		while (!item.IsInstalled)
		{
			yield return null;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class Group
{
	public string Name = "MAIN";

	public Material Material;

	public int MaxTextureSize = 1024;
}


public enum SkinType
{
	TShirt,
	Pants,
	SleepingBag,
	Hoodie,
	LongTShirt,
	Cap,
	Beenie,
	Boots,
	Jacket,
	Balaclava,
	Boonie,
	SnowJacket,
	Bandana,
	AK47,
	BoltRifle,
	Revolver,
	Rock,
	Hammer,
	PipeShotgun,
	PumpShotgun,
	SemiAutoPistol,
	Thompson,
	WoodStorage,
	BucketHat,
	BurlapGloves,
	BurlapPants,
	BurlapShirt
}


private struct MonoScriptData
{
	public byte[] FilePathsData;

	public byte[] TypesData;

	public int TotalTypes;

	public int TotalFiles;

	public bool IsEditorOnly;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[JsonModel]
public class Manifest
{
	[JsonModel]
	public class Group
	{
		public Dictionary<string, string> Textures { get; set; } = new Dictionary<string, string>();

		public Dictionary<string, float> Floats { get; set; } = new Dictionary<string, float>();

		public Dictionary<string, ColorEntry> Colors { get; set; } = new Dictionary<string, ColorEntry>();
	}

	[JsonModel]
	public class ColorEntry
	{
		public float r { get; set; }

		public float g { get; set; }

		public float b { get; set; }

		public ColorEntry(Color c)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			r = c.r;
			g = c.g;
			b = c.b;
		}
	}

	public int Version { get; set; }

	public string ItemType { get; set; }

	public ulong AuthorId { get; set; }

	public DateTime PublishDate { get; set; }

	public Group[] Groups { get; set; }
}


using System;
using Newtonsoft.Json;

public class Item
{
	public string name;

	public uint itemdefid;

	public string type;

	public string price_category;

	public string icon_url;

	public string icon_url_large;

	public bool marketable;

	public bool tradable;

	public bool commodity;

	public string market_hash_name;

	public string market_name;

	public string bundle;

	public string description;

	public string workshopid;

	public string itemshortname;

	public string tags;

	public string store_tags;

	public string store_images;

	public string exchange;

	public bool store_hidden;

	public string background_color;

	public string name_color;

	[NonSerialized]
	public DropChance dropChance;

	[NonSerialized]
	public Price priceCategory;

	public string workshopdownload;

	[JsonIgnore]
	public double Price => (double)priceCategory / 100.0;
}


public class PlaytimeDropItem : Item
{
	public int drop_interval;

	public bool use_drop_window;

	public int drop_window;

	public int drop_max_per_window;

	public bool use_drop_limit;

	public int drop_limit;
}


using System.Collections.Generic;

[JsonModel]
public class Group
{
	public Dictionary<string, string> Textures { get; set; } = new Dictionary<string, string>();

	public Dictionary<string, float> Floats { get; set; } = new Dictionary<string, float>();

	public Dictionary<string, ColorEntry> Colors { get; set; } = new Dictionary<string, ColorEntry>();
}


using UnityEngine;

[JsonModel]
public class ColorEntry
{
	public float r { get; set; }

	public float g { get; set; }

	public float b { get; set; }

	public ColorEntry(Color c)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		r = c.r;
		g = c.g;
		b = c.b;
	}
}


