using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using System.Threading;
using Mono.Unix.Native;
using ObjectStream;
using ObjectStream.Data;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Plugins;

public class PluginCompiler
{
	private static class Algorithms
	{
		public static readonly HashAlgorithm MD5 = new MD5CryptoServiceProvider();

		public static readonly HashAlgorithm SHA1 = new SHA1Managed();

		public static readonly HashAlgorithm SHA256 = new SHA256Managed();

		public static readonly HashAlgorithm SHA384 = new SHA384Managed();

		public static readonly HashAlgorithm SHA512 = new SHA512Managed();

		public static readonly HashAlgorithm RIPEMD160 = new RIPEMD160Managed();
	}

	public static bool AutoShutdown = true;

	public static bool TraceRan;

	public static string FileName = "basic.exe";

	public static string BinaryPath;

	public static string CompilerVersion;

	private static int downloadRetries = 0;

	private Process process;

	private readonly Regex fileErrorRegex = new Regex("([\\w\\.]+)\\(\\d+\\,\\d+\\+?\\): error|error \\w+: Source file `[\\\\\\./]*([\\w\\.]+)", RegexOptions.Compiled);

	private ObjectStreamClient<CompilerMessage> client;

	private Hash<int, Compilation> compilations;

	private Queue<CompilerMessage> messageQueue;

	private volatile int lastId;

	private volatile bool ready;

	private Oxide.Core.Libraries.Timer.TimerInstance idleTimer;

	public static void CheckCompilerBinary()
	{
		BinaryPath = null;
		string rootDirectory = Interface.Oxide.RootDirectory;
		string text = Path.Combine(rootDirectory, FileName);
		if (File.Exists(text))
		{
			BinaryPath = text;
			return;
		}
		switch (Environment.OSVersion.Platform)
		{
		case PlatformID.Win32S:
		case PlatformID.Win32Windows:
		case PlatformID.Win32NT:
			FileName = "CSharpCompiler.exe";
			text = Path.Combine(rootDirectory, FileName);
			UpdateCheck();
			break;
		case PlatformID.Unix:
		case PlatformID.MacOSX:
			FileName = string.Format("CSharpCompiler.{0}", (IntPtr.Size != 8) ? "x86" : "x86_x64");
			text = Path.Combine(rootDirectory, FileName);
			UpdateCheck();
			try
			{
				if (Syscall.access(text, AccessModes.X_OK) == 0)
				{
					break;
				}
			}
			catch (Exception ex)
			{
				Interface.Oxide.LogError($"Unable to check {FileName} for executable permission");
				Interface.Oxide.LogError(ex.Message);
				Interface.Oxide.LogError(ex.StackTrace);
			}
			try
			{
				Syscall.chmod(text, FilePermissions.S_IRWXU);
			}
			catch (Exception ex2)
			{
				Interface.Oxide.LogError($"Could not set {FileName} as executable, please set manually");
				Interface.Oxide.LogError(ex2.Message);
				Interface.Oxide.LogError(ex2.StackTrace);
			}
			break;
		}
		BinaryPath = text;
	}

	private void DependencyTrace()
	{
		if (TraceRan || Environment.OSVersion.Platform != PlatformID.Unix)
		{
			return;
		}
		try
		{
			Interface.Oxide.LogWarning($"Running dependency trace for {FileName}");
			Process obj = new Process();
			obj.StartInfo.WorkingDirectory = Interface.Oxide.RootDirectory;
			obj.StartInfo.FileName = "/bin/bash";
			obj.StartInfo.Arguments = $"-c \"LD_TRACE_LOADED_OBJECTS=1 {BinaryPath}\"";
			obj.StartInfo.CreateNoWindow = true;
			obj.StartInfo.UseShellExecute = false;
			obj.StartInfo.RedirectStandardInput = true;
			obj.StartInfo.RedirectStandardOutput = true;
			obj.EnableRaisingEvents = true;
			obj.StartInfo.EnvironmentVariables["LD_LIBRARY_PATH"] = string.Format("{0}", Path.Combine(Interface.Oxide.ExtensionDirectory, (IntPtr.Size == 8) ? "x64" : "x86"));
			obj.ErrorDataReceived += delegate(object s, DataReceivedEventArgs e)
			{
				Interface.Oxide.LogError(e.Data.TrimStart());
			};
			obj.OutputDataReceived += delegate(object s, DataReceivedEventArgs e)
			{
				Interface.Oxide.LogError(e.Data.TrimStart());
			};
			obj.Start();
			obj.BeginOutputReadLine();
			obj.BeginErrorReadLine();
			obj.WaitForExit();
		}
		catch (Exception)
		{
		}
		TraceRan = true;
	}

	private static void DownloadCompiler(WebResponse response, string remoteHash)
	{
		try
		{
			Interface.Oxide.LogInfo($"Downloading {FileName} for .cs (C#) plugin compilation");
			Stream responseStream = response.GetResponseStream();
			FileStream fileStream = new FileStream(FileName, FileMode.Create, FileAccess.Write, FileShare.None);
			int num = 10000;
			byte[] buffer = new byte[num];
			while (true)
			{
				int num2 = responseStream.Read(buffer, 0, num);
				if (num2 == -1 || num2 == 0)
				{
					break;
				}
				fileStream.Write(buffer, 0, num2);
			}
			fileStream.Flush();
			fileStream.Close();
			responseStream.Close();
			response.Close();
			if (downloadRetries >= 3)
			{
				Interface.Oxide.LogInfo($"Couldn't download {FileName}! Please download manually from: https://github.com/OxideMod/CSharpCompiler/releases/download/latest/{FileName}");
				return;
			}
			string text = (File.Exists(BinaryPath) ? GetHash(BinaryPath, Algorithms.MD5) : "0");
			if (remoteHash != text)
			{
				Interface.Oxide.LogInfo($"Local hash did not match remote hash for {FileName}, attempting download again");
				CheckCompilerBinary();
				downloadRetries++;
			}
			else
			{
				Interface.Oxide.LogInfo($"Download of {FileName} completed successfully");
			}
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogError($"Couldn't download {FileName}! Please download manually from: https://github.com/OxideMod/CSharpCompiler/releases/download/latest/{FileName}");
			Interface.Oxide.LogError(ex.Message);
		}
	}

	private static void UpdateCheck()
	{
		try
		{
			string text = Path.Combine(Interface.Oxide.RootDirectory, FileName);
			HttpWebResponse httpWebResponse = (HttpWebResponse)((HttpWebRequest)WebRequest.Create($"https://github.com/OxideMod/CSharpCompiler/releases/download/latest/{FileName}")).GetResponse();
			int statusCode = (int)httpWebResponse.StatusCode;
			if (statusCode != 200)
			{
				Interface.Oxide.LogWarning($"Status code from download location was not okay (code {statusCode})");
			}
			string text2 = httpWebResponse.Headers[HttpResponseHeader.ETag].Trim('"');
			string text3 = (File.Exists(text) ? GetHash(text, Algorithms.MD5) : "0");
			Interface.Oxide.LogInfo($"Latest compiler MD5: {text2}");
			Interface.Oxide.LogInfo($"Local compiler MD5: {text3}");
			if (text2 != text3)
			{
				Interface.Oxide.LogInfo("Compiler hashes did not match, downloading latest");
				DownloadCompiler(httpWebResponse, text2);
			}
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogError($"Couldn't check for update to {FileName}");
			Interface.Oxide.LogError(ex.Message);
		}
	}

	private static void SetCompilerVersion()
	{
		FileVersionInfo versionInfo = FileVersionInfo.GetVersionInfo(BinaryPath);
		CompilerVersion = $"{versionInfo.FileMajorPart}.{versionInfo.FileMinorPart}.{versionInfo.FileBuildPart}.{versionInfo.FilePrivatePart}";
		RemoteLogger.SetTag("compiler version", CompilerVersion);
	}

	public PluginCompiler()
	{
		compilations = new Hash<int, Compilation>();
		messageQueue = new Queue<CompilerMessage>();
	}

	internal void Compile(CompilablePlugin[] plugins, Action<Compilation> callback)
	{
		int num = lastId++;
		Compilation compilation = new Compilation(num, callback, plugins);
		compilations[num] = compilation;
		compilation.Prepare(delegate
		{
			EnqueueCompilation(compilation);
		});
	}

	public void Shutdown()
	{
		ready = false;
		Process endedProcess = process;
		if (endedProcess != null)
		{
			endedProcess.Exited -= OnProcessExited;
		}
		process = null;
		if (client == null)
		{
			return;
		}
		client.Message -= OnMessage;
		client.Error -= OnError;
		client.PushMessage(new CompilerMessage
		{
			Type = CompilerMessageType.Exit
		});
		client.Stop();
		client = null;
		if (endedProcess == null)
		{
			return;
		}
		ThreadPool.QueueUserWorkItem(delegate
		{
			Thread.Sleep(5000);
			if (!endedProcess.HasExited)
			{
				endedProcess.Close();
			}
		});
	}

	private void EnqueueCompilation(Compilation compilation)
	{
		if (compilation.plugins.Count < 1)
		{
			return;
		}
		if (!CheckCompiler())
		{
			OnCompilerFailed($"compiler v{CompilerVersion} couldn't be started");
			return;
		}
		compilation.Started();
		List<CompilerFile> list = (from path in compilation.plugins.SelectMany((CompilablePlugin plugin) => plugin.IncludePaths).Distinct()
			select new CompilerFile(path)).ToList();
		list.AddRange(compilation.plugins.Select((CompilablePlugin plugin) => new CompilerFile($"{plugin.ScriptName}.cs", plugin.ScriptSource)));
		CompilerData data = new CompilerData
		{
			OutputFile = compilation.name,
			SourceFiles = list.ToArray(),
			ReferenceFiles = compilation.references.Values.ToArray()
		};
		CompilerMessage compilerMessage = new CompilerMessage
		{
			Id = compilation.id,
			Data = data,
			Type = CompilerMessageType.Compile
		};
		if (ready)
		{
			client.PushMessage(compilerMessage);
		}
		else
		{
			messageQueue.Enqueue(compilerMessage);
		}
	}

	private void OnMessage(ObjectStreamConnection<CompilerMessage, CompilerMessage> connection, CompilerMessage message)
	{
		if (message == null)
		{
			Interface.Oxide.NextTick(delegate
			{
				OnCompilerFailed($"compiler v{CompilerVersion} disconnected");
				DependencyTrace();
				Shutdown();
			});
			return;
		}
		switch (message.Type)
		{
		case CompilerMessageType.Assembly:
		{
			Compilation compilation = compilations[message.Id];
			if (compilation == null)
			{
				Interface.Oxide.LogWarning("Compiler compiled an unknown assembly");
				break;
			}
			compilation.endedAt = Interface.Oxide.Now;
			string text = (string)message.ExtraData;
			if (text != null)
			{
				string[] array = text.Split('\r', '\n');
				foreach (string text2 in array)
				{
					Match match = fileErrorRegex.Match(text2.Trim());
					for (int j = 1; j < match.Groups.Count; j++)
					{
						string value = match.Groups[j].Value;
						if (value.Trim() == string.Empty)
						{
							continue;
						}
						string text3 = value.Basename();
						string scriptName = text3.Substring(0, text3.Length - 3);
						CompilablePlugin compilablePlugin = compilation.plugins.SingleOrDefault((CompilablePlugin pl) => pl.ScriptName == scriptName);
						if (compilablePlugin == null)
						{
							Interface.Oxide.LogError($"Unable to resolve script error to plugin: {text2}");
							continue;
						}
						IEnumerable<string> enumerable = compilablePlugin.Requires.Where((string name) => !compilation.IncludesRequiredPlugin(name));
						if (enumerable.Any())
						{
							compilablePlugin.CompilerErrors = $"Missing dependencies: {enumerable.ToSentence()}";
						}
						else
						{
							compilablePlugin.CompilerErrors = text2.Trim().Replace(Interface.Oxide.PluginDirectory + Path.DirectorySeparatorChar, string.Empty);
						}
					}
				}
			}
			compilation.Completed((byte[])message.Data);
			compilations.Remove(message.Id);
			idleTimer?.Destroy();
			if (!AutoShutdown)
			{
				break;
			}
			Interface.Oxide.NextTick(delegate
			{
				idleTimer?.Destroy();
				if (AutoShutdown)
				{
					idleTimer = Interface.Oxide.GetLibrary<Oxide.Core.Libraries.Timer>().Once(60f, Shutdown);
				}
			});
			break;
		}
		case CompilerMessageType.Error:
			Interface.Oxide.LogError("Compilation error: {0}", message.Data);
			compilations[message.Id].Completed();
			compilations.Remove(message.Id);
			idleTimer?.Destroy();
			if (AutoShutdown)
			{
				Interface.Oxide.NextTick(delegate
				{
					idleTimer?.Destroy();
					idleTimer = Interface.Oxide.GetLibrary<Oxide.Core.Libraries.Timer>().Once(60f, Shutdown);
				});
			}
			break;
		case CompilerMessageType.Ready:
			connection.PushMessage(message);
			if (!ready)
			{
				ready = true;
				while (messageQueue.Count > 0)
				{
					connection.PushMessage(messageQueue.Dequeue());
				}
			}
			break;
		case CompilerMessageType.Compile:
		case CompilerMessageType.Exit:
			break;
		}
	}

	private static void OnError(Exception exception)
	{
		Interface.Oxide.LogException("Compilation error: ", exception);
	}

	private bool CheckCompiler()
	{
		CheckCompilerBinary();
		idleTimer?.Destroy();
		if (BinaryPath == null)
		{
			return false;
		}
		if (process != null && process.Handle != IntPtr.Zero && !process.HasExited)
		{
			return true;
		}
		SetCompilerVersion();
		PurgeOldLogs();
		Shutdown();
		string[] value = new string[2]
		{
			"/service",
			"/logPath:" + EscapePath(Interface.Oxide.LogDirectory)
		};
		try
		{
			process = new Process
			{
				StartInfo = 
				{
					FileName = BinaryPath,
					Arguments = string.Join(" ", value),
					CreateNoWindow = true,
					UseShellExecute = false,
					RedirectStandardInput = true,
					RedirectStandardOutput = true
				},
				EnableRaisingEvents = true
			};
			switch (Environment.OSVersion.Platform)
			{
			case PlatformID.Win32S:
			case PlatformID.Win32Windows:
			case PlatformID.Win32NT:
				process.StartInfo.EnvironmentVariables["PATH"] = string.Format("{0}", Path.Combine(Interface.Oxide.ExtensionDirectory, "x86"));
				break;
			case PlatformID.Unix:
			case PlatformID.MacOSX:
				process.StartInfo.EnvironmentVariables["LD_LIBRARY_PATH"] = string.Format("{0}", Path.Combine(Interface.Oxide.ExtensionDirectory, (IntPtr.Size == 8) ? "x64" : "x86"));
				break;
			}
			process.Exited += OnProcessExited;
			process.Start();
		}
		catch (Exception ex)
		{
			process?.Dispose();
			process = null;
			Interface.Oxide.LogException($"Exception while starting compiler v{CompilerVersion}: ", ex);
			if (BinaryPath.Contains("'"))
			{
				Interface.Oxide.LogWarning("Server directory path contains an apostrophe, compiler will not work until path is renamed");
			}
			else if (Environment.OSVersion.Platform == PlatformID.Unix)
			{
				Interface.Oxide.LogWarning("Compiler may not be set as executable; chmod +x or 0744/0755 required");
			}
			if (ex.GetBaseException() != ex)
			{
				Interface.Oxide.LogException("BaseException: ", ex.GetBaseException());
			}
			if (ex is Win32Exception ex2)
			{
				Interface.Oxide.LogError("Win32 NativeErrorCode: {0} ErrorCode: {1} HelpLink: {2}", ex2.NativeErrorCode, ex2.ErrorCode, ex2.HelpLink);
			}
		}
		if (process == null)
		{
			return false;
		}
		client = new ObjectStreamClient<CompilerMessage>(process.StandardOutput.BaseStream, process.StandardInput.BaseStream);
		client.Message += OnMessage;
		client.Error += OnError;
		client.Start();
		return true;
	}

	private void OnProcessExited(object sender, EventArgs eventArgs)
	{
		Interface.Oxide.NextTick(delegate
		{
			OnCompilerFailed($"compiler v{CompilerVersion} was closed unexpectedly");
			if (Environment.OSVersion.Platform == PlatformID.Unix)
			{
				Interface.Oxide.LogWarning("User running server may not have the proper permissions or install is missing files");
			}
			else
			{
				Interface.Oxide.LogWarning("Compiler may have been closed by interference from security software");
			}
			Shutdown();
		});
	}

	private void OnCompilerFailed(string reason)
	{
		foreach (Compilation value in compilations.Values)
		{
			foreach (CompilablePlugin plugin in value.plugins)
			{
				plugin.CompilerErrors = reason;
			}
			value.Completed();
		}
		compilations.Clear();
	}

	private static void PurgeOldLogs()
	{
		try
		{
			foreach (string item in from f in Directory.GetFiles(Interface.Oxide.LogDirectory, "*.txt")
				where Path.GetFileName(f)?.StartsWith("compiler_") ?? false
				select f)
			{
				File.Delete(item);
			}
		}
		catch (Exception)
		{
		}
	}

	private static string EscapePath(string path)
	{
		if (string.IsNullOrEmpty(path))
		{
			return "\"\"";
		}
		path = Regex.Replace(path, "(\\\\*)\"", "$1\\$0");
		path = Regex.Replace(path, "^(.*\\s.*?)(\\\\*)$", "\"$1$2$2\"");
		return path;
	}

	private static string GetHash(string filePath, HashAlgorithm algorithm)
	{
		using BufferedStream inputStream = new BufferedStream(File.OpenRead(filePath), 100000);
		return BitConverter.ToString(algorithm.ComputeHash(inputStream)).Replace("-", string.Empty).ToLower();
	}
}
