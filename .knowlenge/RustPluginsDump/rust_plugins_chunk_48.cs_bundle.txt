              case "players":
                    {
                        string listStr = string.Empty;
                        var pList = BasePlayer.activePlayerList;
                        int i = 0;
                        foreach (var player in pList)
                        {
                            listStr += player.displayName + " " + "[" + (i++ + 1) + "]";
                            if (i != pList.Count)
                                listStr += ", ";

                            

                            if (i % 25 == 0 || i == pList.Count)
                            {
                                var text = new Dictionary<string, string>
                                {
                                    ["playercount"] = Convert.ToString(BasePlayer.activePlayerList.Count),
                                    ["maxplayers"] = Convert.ToString(ConVar.Server.maxplayers),
                                    ["playerslist"] = listStr
                                };
                                GetChannel(_client, channelid, chan =>
                                {
                                    chan.CreateMessage(_client, Translate("Discord_PlayersResponse", text));
                                });
                                text.Clear();
                                listStr = string.Empty;
                            }
                            
                        }
                        if (pList.Count < 1)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Server is empty!");
                            });
                        }
                        break;
                    }
                case "kick":
                    {
                        if (String.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !kick <steam id> <reason>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length < 2)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !kick <steam id> <reason>");
                            });
                            return;
                        }
                        BasePlayer plr = BasePlayer.Find(_param[0]);
                        if (plr == null)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Error: player not found");
                            });
                            return;
                        }
                        plr.Kick(param.Remove(0, _param[0].Length + 1));
                        GetChannel(_client, channelid, chan =>
                        {
                            chan.CreateMessage(_client, "Success: Kick command executed!");
                        });
                        break;
                    }
                case "timeban":
                    {
                        if (string.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !timeban <steamid> <name> <duration> <reason>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length < 3)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !timeban <steamid> <name> <duration> <reason>");
                            });
                            return;
                        }
                        var plr = covalence.Players.FindPlayer(_param[0]);
                        if (plr == null)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Error: player not found");
                            });
                            return;
                        }
                        string[] args = new string[4];
                        args[0] = _param[0]; // id
                        args[1] = _param[1]; // name
                        args[2] = "\""; // reason
                        for (int i = 3; i < _param.Length; i++)
                        {
                            args[2] += _param[i];
                            if (i != _param.Length - 1)
                                args[2] += " ";
                        }
                        args[2] += "\"";
                        args[3] = _param[2];
                        this.Server.Command("banid", args);
                        GetChannel(_client, channelid, chan =>
                        {
                            chan.CreateMessage(_client, "Success: Ban command executed!");
                        });
                        break;
                    }
                case "ban":
                    {
                        if (string.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !ban <name/id> <reason>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length < 2)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !ban <name/id> <reason>");
                            });
                            return;
                        }
                        var plr = covalence.Players.FindPlayer(_param[0]);
                        if (plr == null)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Error: player not found");
                            });
                            return;
                        }
                        plr.Ban(param.Remove(0, _param[0].Length + 1));
                        GetChannel(_client, channelid, chan =>
                        {
                            chan.CreateMessage(_client, "Success: Ban command executed!");
                        });
                        break;
                    }
                case "unban":
                    {
                        if (string.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !unban <name/id>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        var plr = covalence.Players.FindPlayer(_param[0]);
                        if (plr == null)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Error: player not found");
                            });
                            return;
                        }
                        plr.Unban();
                        GetChannel(_client, channelid, chan =>
                        {
                            chan.CreateMessage(_client, "Success: Unban command executed!");
                        });
                        break;
                    }
                case "com":
                    {
                        if (String.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !com <command>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length > 1)
                        {
                            string[] args = new string[_param.Length - 1];
                            Array.Copy(_param, 1, args, 0, args.Length);
                            this.Server.Command(_param[0], args);
                        }
                        else
                        {
                            this.Server.Command(param);
                        }
                        GetChannel(_client, channelid, chan =>
                        {
                            chan.CreateMessage(_client, "Success: Console command executed!");
                        });
                        break;
                    }
                case "mute":
                    {
                        if (BetterChatMute == null)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "This command requires the Better Chat Mute plugin.");
                                return;
                            });
                        }
                        if (string.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !mute <playername/steamid> <time (optional)> <reason (optional)>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length >= 1)
                        {
                            this.Server.Command($"mute {string.Join(" ", _param)}");
                            return;
                        }
                        GetChannel(_client, channelid, chan =>
                        {
                            chan.CreateMessage(_client, "Success: Mute command executed!");
                        });
                        break;
                    }
                case "unmute":
                    {
                        if (BetterChatMute == null)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "This command requires the Better Chat Mute plugin.");
                                return;
                            });
                        }
                        if (String.IsNullOrEmpty(param))
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !unmute <playername/steamid>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length > 1)
                        {
                            GetChannel(_client, channelid, chan =>
                            {
                                chan.CreateMessage(_client, "Syntax: !unmute <playername/steamid>");
                            });
                            return;
                        }
                        if (_param.Length == 1)
                        {
                            this.Server.Command($"unmute {string.Join(" ", _param)}");
                            return;
                        }
                        break;
                    }
            }

        }
        #endregion

        #region Game Commands
        // /report [message]
        void cmdReport(BasePlayer player, string command, string[] args)
        {
            if (args.Length < 1)
            {
                SendReply(player, "Syntax: /report [message]");
                return;
            }

            if (_settings.OutputFormat.OutputTypeReports == "Embed")
            {
                string message = string.Join(" ", args);
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("PLAYER REPORT")
                                                  .AddColor("#FF0000")
                                                  .AddThumbnail("https://i.imgur.com/qg7v0Tv.png")
                                                  .AddDescription($"{player.displayName} has submitted a report.")
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddField("Message", message, true);



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("game_report"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeReports == "Simple")
            {
                string message = string.Join(" ", args);

                var dict = new Dictionary<string, string>
                    {
                        { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                        { "playername", player.displayName },
                        { "message", message }
                    };

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("game_report"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerReport", dict));
                        });
                    }
                }
            }

            SendReply(player, "Your report has been submitted to Discord.");

        }

        void cmdBug(BasePlayer player, string command, string[] args)
        {
            if (args.Length < 1)
            {
                SendReply(player, "Syntax: /bug [message]");
                return;
            }
            if (_settings.OutputFormat.OutputTypeBugs == "Embed")
            {
                string message = string.Join(" ", args);
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("BUG REPORT")
                                                  .AddThumbnail("https://i.imgur.com/GLjfCFd.png")
                                                  .AddColor("#FF0000")
                                                  .AddDescription($"{player.displayName} has reported a bug.")
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddField("Bug", message, true);



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("game_bug"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBugs == "Simple")
            {
                string message = string.Join(" ", args);
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("game_bug"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerBug", new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName },
                            { "message", message }
                        }));
                        });
                    }
                }
            }

            SendReply(player, "Your bug report has been submitted to Discord.");

        }
        #endregion

        #region Rust Logging

        #region Chat Logging
        private void OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            if (_client == null) return;
            if (player == null || message == null) return;
            if (permission.UserHasPermission(player.UserIDString, "rustcord.hidechat")) return;
            if (BetterChatMute?.Call<bool>("API_IsMuted", player.IPlayer) ?? false) return;
            if (_settings.Filters.FilterWords != null && _settings.Filters.FilterWords.Count > 0)
            {
                for (int i = _settings.Filters.FilterWords.Count - 1; i >= 0; i--)
                {
                    while (message.Contains(" " + _settings.Filters.FilterWords[i] + " ") || message.Contains(_settings.Filters.FilterWords[i]))
                        message = message.Replace(_settings.Filters.FilterWords[i], _settings.Filters.FilteredWord ?? "");
                }
            }

            var text = GetPlayerCache(player, message, CacheType.OnPlayerChat);

            for (int i = 0; i < _settings.Channels.Count; i++)
            {
                if (_settings.Channels[i].perms.Contains(channel == ConVar.Chat.ChatChannel.Team ? "msg_teamchat" : "msg_chat"))
                {
                    if (!(player.IsValid())) continue;

                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate(channel == ConVar.Chat.ChatChannel.Team ? "RUST_OnPlayerTeamChat" : "RUST_OnPlayerChat", text));

                    });
                }
            }

            text.Clear();
        }
        #endregion

        #region Crate Logging
        void OnCrateDropped(HackableLockedCrate crate)
        {
            var dict = new Dictionary<string, string>
            {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_cratedrop"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnCrateDropped", dict));
                    });
                }
            }
        }

        void OnSupplyDropLanded(SupplyDrop entity)
        {
            var dict = new Dictionary<string, string>
            {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_supplydrop"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnSupplyDrop", dict));
                    });
                }
            }
        }
        #endregion

        #region Death Logging
        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null) return;
            if (info?.InitiatorPlayer == null) return;
            if ((player.IsNpc) || (info.InitiatorPlayer.IsNpc)) return;

            if (_settings.OutputFormat.OutputTypeDeaths == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER DEATH")
                                              .AddColor("#000000")
                                              .AddThumbnail("https://i.imgur.com/UZZTf08.png")
                                              .AddField("Victim", player.displayName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Killer", info.InitiatorPlayer.displayName, true);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_deaths"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDeaths == "Simple")
            {
                var dict = new Dictionary<string, string>
                {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                    { "victim", player.displayName },
                    { "killer", info.InitiatorPlayer.displayName }
                };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_deaths"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerDeath", dict));
                        });

                    }
                }
            }
        }
        #endregion

        #region Group Logging
        void OnGroupCreated(string name)
        {
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "groupname", name }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_groups"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnGroupCreated", dict));
                    });
                }
            }
        }

        void OnGroupDeleted(string name)
        {
            var dict = new Dictionary<string, string>
            {
                { "groupname", name }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_groups"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnGroupDeleted", dict));
                    });
                }
            }
        }



        void OnUserGroupAdded(string id, string groupName)
        {
            if (_settings.Excluded.LogExcludeGroups.Contains(groupName)) { return; }
            if (groupName == "default") return;
            var player = covalence.Players.FindPlayerById(id);
            if (player == null) return;
            var dict = new Dictionary<string, string>
            {
                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                { "playername", player.Name },
                { "playersteamid", id },
                { "groupname", groupName }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_groups"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnUserGroupAdded", dict));
                    });
                }
            }
        }

        void OnUserGroupRemoved(string id, string groupName)
        {
            if (_settings.Excluded.LogExcludeGroups.Contains(groupName)) return;
            if (groupName == "default") return;
            var player = covalence.Players.FindPlayerById(id);
            if (player == null) return;
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name },
                            { "playersteamid", id },
                            { "groupname", groupName }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_groups"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnUserGroupRemoved", dict));
                    });
                }
            }
        }
        #endregion

        #region Join & Quit Logging
        private void OnPlayerConnected(BasePlayer player)
        {
            if (_client == null) return;
            if (player == null) return;
            if (!player.IsValid()) return;

            HandleAdminJoin(player);
            HandlePlayerJoin(player);
        }

        private void HandleAdminJoin(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeJoinAdminChan == "Simple")
            {
                var text = GetPlayerCache(player, player.net.connection.ipaddress, CacheType.OnPlayerConnected);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_joinlog"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            // Admin
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerJoinAdminLog", text));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJoinAdminChan == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("PLAYER INFO")
                                                  .AddColor("#00FF00")
                                                  .AddThumbnail("https://i.imgur.com/AfbPIrb.png")
                                                  .AddField("Name", player.displayName, true)
                                                  .AddField("IP", player.net.connection.ipaddress.Split(':')[0], true)
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddField("Steam ID", GetFormattedSteamID(player.UserIDString), true);



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_joinlog"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }

        private void HandlePlayerJoin(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "rustcord.hidejoinquit")) return;

            if (_settings.OutputFormat.OutputTypeJoinQuit == "Simple")
            {
                var text = GetPlayerCache(player, null, CacheType.OnPlayerJoin);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_join"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan => { chan.CreateMessage(_client, Translate("RUST_OnPlayerJoin", text)); });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJoinQuit == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("PLAYER JOIN")
                                                  .AddColor("#00FF00")
                                                  .AddThumbnail("https://i.imgur.com/hQK7Jjv.png")
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddDescription($"{player.displayName} has joined the server.");



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_join"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (_client == null) return;
            if (player == null || string.IsNullOrEmpty(reason)) return;
            if (permission.UserHasPermission(player.UserIDString, "rustcord.hidejoinquit"))
                return;
            if (_settings.OutputFormat.OutputTypeJoinQuit == "Simple")
            {
                var text = GetPlayerCache(player, reason, CacheType.OnPlayerDisconnected);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_quit"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerQuit", text));
                        });
                    }
                }

                cache[CacheType.OnPlayerChat].Remove(player);
                cache[CacheType.OnPlayerConnected].Remove(player);
                cache[CacheType.OnPlayerDisconnected].Remove(player);
                cache[CacheType.OnPlayerJoin].Remove(player);
            }
            if (_settings.OutputFormat.OutputTypeJoinQuit == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("PLAYER QUIT")
                                                  .AddColor("#00FF00")
                                                  .AddThumbnail("https://i.imgur.com/py6bHm0.png")
                                                  .AddDescription($"{player.displayName} has left the server.")
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddField("Reason", reason, true);



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_quit"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Permission Logging
        void OnUserPermissionGranted(string id, string permName)
        {
            if (_settings.Excluded.LogExcludePerms.Contains(permName)) return;
            var player = covalence.Players.FindPlayerById(id);
            if (player == null) return;
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name },
                            { "playersteamid", id },
                            { "permission", permName }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_perms"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnUserPermissionGranted", dict));
                    });
                }
            }
        }

        void OnGroupPermissionGranted(string name, string perm)
        {
            if (_settings.Excluded.LogExcludePerms.Contains(perm)) return;
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "groupname", name },
                            { "permission", perm }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_perms"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnGroupPermissionGranted", dict));
                    });
                }
            }
        }

        void OnUserPermissionRevoked(string id, string permName)
        {
            if (_settings.Excluded.LogExcludePerms.Contains(permName)) return;
            var player = covalence.Players.FindPlayerById(id);
            if (player == null) return;
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name },
                            { "playersteamid", id },
                            { "permission", permName }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_perms"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnUserPermissionRevoked", dict));
                    });
                }
            }
        }

        void OnGroupPermissionRevoked(string name, string perm)
        {
            if (_settings.Excluded.LogExcludePerms.Contains(perm)) return;
            var dict = new Dictionary<string, string>
            {
                        { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                        { "groupname", name },
                        { "permission", perm }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_perms"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnGroupPermissionRevoked", dict));
                    });
                }
            }
        }
        #endregion

        #region Kick & Ban Logging
        void OnUserKicked(IPlayer player, string reason)
        {
            if (_settings.OutputFormat.OutputTypeKicks == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name },
                            { "reason", reason }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_kicks"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerKicked", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeKicks == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER KICKED")
                                              .AddThumbnail("https://i.imgur.com/ekF9ClZ.png")
                                              .AddField("Name", player.Name, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Reason", reason, true);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_kicks"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }

        void OnUserBanned(string name, string bannedId, string address, string reason)
        {
            if (_settings.OutputFormat.OutputTypeBans == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                        { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                        { "playername", name },
                        { "playersteamid", bannedId },
                        { "playerip", address },
                        { "reason", reason }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_bans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerBanned", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBans == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER BANNED")
                                              .AddThumbnail("https://i.imgur.com/ekF9ClZ.png")
                                              .AddField("Name", name, true)
                                              .AddField("IP", address, true)
                                              .AddField("Steam ID", GetFormattedSteamID(bannedId), true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Ban Reason", reason, false);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_bans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }

        }
        
        private void OnUserUnbanned(string name, string id, string ip)
        {
            if (_settings.OutputFormat.OutputTypeBans == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", name },
                            { "playersteamid", id },
                            { "playerip", ip }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_bans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerUnBanned", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBans == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER UNBANNED")
                                              .AddThumbnail("https://i.imgur.com/ekF9ClZ.png")
                                              .AddField("Name", name, true)
                                              .AddField("IP", ip, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Steam ID", GetFormattedSteamID(id), true);
                
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_bans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Player Name Change Logging
        void OnUserNameUpdated(string id, string oldName, string newName) //TESTING FUNCTION
        {

            if ((oldName == newName) || (oldName == "Unnamed")) return;
            if (_settings.OutputFormat.OutputTypeNameChange == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER NAME CHANGE")
                                              .AddThumbnail("https://i.imgur.com/Fq4LvFz.png")
                                              .AddField("Old Name", oldName, true)
                                              .AddField("New Name", newName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Steam ID", GetFormattedSteamID(id), false);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_namechange"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeNameChange == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "oldname", oldName },
                            { "newname", newName },
                            { "playersteamid", id }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_namechange"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerNameChange", dict));
                        });
                    }
                }
            }

        }
        #endregion

        #region Server Init/Shutdown Logging
        private void OnServerInitialized()
        {
            var reloadtime = _settings.General.AutoReloadTime;

            permission.RegisterPermission("rustcord.hidejoinquit", this);
            permission.RegisterPermission("rustcord.hidechat", this);

            if (_settings.General.AutoReloadPlugin && _settings.General.AutoReloadTime > 59)
            {
                timer.Every(reloadtime, () => Reload());
            }

            if (_client != null)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_serverinit"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnInitMsg"));
                        });
                    }
                }
            }
        }
        void OnServerShutdown()
        {

            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("msg_serverinit"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnServerShutdown"));
                    });
                }
            }
        }
        #endregion

        #region Server Message Logging (F1 Spawns)
        private object OnServerMessage(string message, string name)
        {
            if (message.Contains("gave") && name == "SERVER")
            {
                var dict = new Dictionary<string, string>
                        {
                                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                                { "playername", name },
                                { "givemessage", message }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_admingive"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnF1ItemSpawn", dict));
                        });
                    }
                }
            }

            return null;
        }
        #endregion

        #region Server Wipe Logging
        private void OnNewSave(string filename)
        {
            var mapseed = ConVar.Server.seed.ToString();
            var servername = ConVar.Server.hostname;
            var serverip = covalence.Server.Address.ToString();
            var serverport = covalence.Server.Port.ToString();
            var serverworldsize = ConVar.Server.worldsize.ToString();

            if (_settings.OutputFormat.OutputTypeServerWipe == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                                { "mapseed", mapseed },
                                { "servername", servername },
                                { "serverip", serverip },
                                { "serverport", serverport },
                                { "serverworldsize", serverworldsize }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_serverwipe"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnServerWipe", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeServerWipe == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                          .AddTitle("SERVER HAS WIPED")
                                          .AddThumbnail("https://i.imgur.com/EODRYQQ.png")
                                          .AddDescription(servername)
                                          .AddField("Map Seed", mapseed, true)
                                          .AddField("World Size", serverworldsize, true)
                                          .AddField("Server IP", serverip, false)
                                          .AddField("Server Port", serverport, true)
                                          .AddField("Quick Join:", $"steam://connect/{serverip}:{serverport}", false)
                                          .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                          .AddNowTimestamp();

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_serverwipe"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Server Command Logging (Note/Gestures)
        private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            var player1 = arg.Player();
            var emote = arg.GetString(0);

            if (arg.cmd.Name == "gesture")
            {
                if (_emotes.ContainsKey(emote))
                {
                    var emoji = _emotes[emote];
                    var dict = new Dictionary<string, string>
                        {
                                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                                    {"playername", player1.displayName },
                                    {"gesture", emoji }
                        };
                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("msg_gestures"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, Translate("RUST_OnPlayerGesture", dict));
                            });
                        }
                    }
                }
            }
            if (arg.cmd.FullName == "note.update")
            {
                BasePlayer player = arg.Connection.player as BasePlayer;
                if (player == null)
                    return;
                var notemsg = arg.GetString(1, string.Empty);
                if (string.IsNullOrEmpty(notemsg)) return;

                if (_settings.OutputFormat.OutputTypeNoteLog == "Simple")
                {
                    var dict = new Dictionary<string, string>
                        {
                                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                                { "playername", player.displayName },
                                { "notemessage", notemsg }
                        };
                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("log_itemnote"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, Translate("RUST_OnNoteUpdate", dict));
                            });
                        }
                    }
                }
                if (_settings.OutputFormat.OutputTypeNoteLog == "Embed")
                {
                    DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("NOTE UPDATE")
                                              .AddThumbnail("https://i.imgur.com/AZvqSSf.png")
                                              .AddField("Author", player.displayName, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Message", notemsg, false);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("log_itemnote"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, builder.Build());
                            });
                        }
                    }
                }
            }
        }
        private readonly Dictionary<string, string> _emotes = new Dictionary<string, string>
        {
            ["wave"] = ":wave:",
            ["shrug"] = ":shrug:",
            ["victory"] = ":trophy:",
            ["thumbsup"] = ":thumbsup:",
            ["chicken"] = ":chicken:",
            ["hurry"] = ":runner:",
            ["whoa"] = ":flag_white:"
        };
        #endregion

        #region F7 Report Logging
        void OnPlayerReported(BasePlayer reporter, string targetName, string targetId, string subject, string message, string type)
        {
            if (reporter == null || message == null || targetName == null || targetId == null || subject == null || type == null) return;
            if (_settings.OutputFormat.OutputTypeF7Report == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER F7 REPORT")
                                              .AddThumbnail("https://i.imgur.com/qg7v0Tv.png")
                                              .AddField("Reporter", reporter.displayName, false)
                                              .AddField("User Reported", $"{targetName} ([{targetId}](https://steamcommunity.com/profiles/{targetId})", false)
                                              .AddField("Reason", subject, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Message", message, false);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_f7reports"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeF7Report == "Simple")
            {
                var dict = new Dictionary<string, string>
             {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "reporter", reporter.displayName },
                            { "targetname", targetName },
                            { "targetsteamid", targetId },
                            { "reason", subject },
                            { "message", message }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_f7reports"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlayerReported", dict));
                        });
                    }
                }
            }

        }
        #endregion

        #region Custom Logging
        private void ConsoleLog(string condition, string stackTrace, LogType type)
        {
            if (string.IsNullOrEmpty(condition))
            {
                return;
            }
            var dict = new Dictionary<string, string>
            {
                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                { "logtext", condition }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                Settings.Channel channel = _settings.Channels[i];
                if (channel.CustomFilter.Any(c => condition.Contains(c)))
                {
                    GetChannel(_client, channel.Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_CustomLog", dict));
                    });
                }
            }
        }
        #endregion

        #region RCON Logging
        private void OnRconConnection(IPAddress ip)
        {
            var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "ip", ip.ToString() }
                        };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_rcon"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnRCONConnected", dict));
                    });
                }
            }
        }
        #endregion

        #region Spectate Logging
        private void OnPlayerSpectate(BasePlayer player, string spectateFilter)
        {
            var dict = new Dictionary<string, string>
            {
                { "playername", player.displayName },
                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                { "targetname", spectateFilter }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_spectates"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnPlayerSpectate", dict));
                    });

                }
            }
        }
        private void OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
        {
            var dict = new Dictionary<string, string>
            {
                { "playername", player.displayName },
                { "targetname", spectateFilter }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_spectates"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("RUST_OnPlayerSpectateEnd", dict));
                    });
                }
            }
        }
        #endregion

        #region SignShit

        /*private void OnSignUpdated(Signage sign, BasePlayer player, int textureIndex)
        {
            using (Image image = Image.FromStream(new MemoryStream(FileStorage.server.Get(sign.textureIDs[textureIndex], FileStorage.Type.png, sign.net.ID, (uint)0))))
            {
                image.Save($"{sign.net.ID}.png");
            }
            DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Sign Update")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has updated a sign.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddImage($"{sign.net.ID}.png")
                                              .AddThumbnail("https://i.imgur.com/qkI2B4l.png");

            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_signs"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, builder.Build());
                    });
                }
            }
        }*/
        #endregion

        #region Team Logging
        void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team)
        {
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;

                List<string> players = Pool.GetList<string>();
                foreach (ulong member in team.members)
                {
                    IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                    if (memberPlayer != null)
                    {
                        players.Add(GetPlayerFormattedField(memberPlayer));
                    }
                    else
                    {
                        players.Add(member.ToString());
                    }
                }

                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("NEW TEAM CREATED")
                                              .AddThumbnail("https://i.imgur.com/ChdmYGD.png")
                                              .AddColor("#800080")
                                              .AddField("Team ID", team.teamID.ToString(), true)
                                              .AddField("Leader", leaderName, true)
                                              .AddField("Members", string.Join("\n", players), false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp();

                Pool.FreeList(ref players);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                { "playername", player.displayName },
                { "teamid", team.teamID.ToString() }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnTeamCreated", dict));
                        });
                    }
                }
            }

        }
        void OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                NextTick(() =>
                {
                    string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;

                    List<string> players = Pool.GetList<string>();
                    foreach (ulong member in team.members)
                    {
                        IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                        if (memberPlayer != null)
                        {
                            players.Add(GetPlayerFormattedField(memberPlayer));
                        }
                        else
                        {
                            players.Add(member.ToString());
                        }
                    }

                    DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("TEAM JOIN")
                                                  .AddColor("#00FF00")
                                                  .AddThumbnail("https://i.imgur.com/nV7KfWf.png")
                                                  .AddDescription($"{player.displayName} has joined {leaderName}'s team.")
                                                  .AddField("Team ID", team.teamID.ToString(), true)
                                                  .AddField("Team Leader", leaderName, true)
                                                  .AddField("Team Members", string.Join("\n", players), false)
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp();

                    Pool.FreeList(ref players);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("log_teams"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, builder.Build());
                            });
                        }
                    }
                });
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                 { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                 { "playername", player.displayName },
                 { "teamleader", team.GetLeader().displayName },
                 { "teamid", team.teamID.ToString() }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnTeamAcceptInvite", dict));
                        });
                    }
                }
            }

        }



        void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            if (team == null || player == null) return;
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;
                if (player.displayName == team.GetLeader().displayName) return;
                List<string> players = Pool.GetList<string>();
                foreach (ulong member in team.members)
                {
                    IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                    if (memberPlayer != null)
                    {
                        players.Add(GetPlayerFormattedField(memberPlayer));
                    }
                    else
                    {
                        players.Add(member.ToString());
                    }
                }

                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                .AddTitle("TEAM PART")
                                                .AddColor("#FFA500")
                                                .AddThumbnail("https://i.imgur.com/92y7DWt.png")
                                                .AddDescription($"{player.displayName} left {leaderName}'s team.")
                                                .AddField("Team ID", team.teamID.ToString(), true)
                                                .AddField("Team Leader", leaderName, true)
                                                .AddField("Team Members", string.Join("\n", players), false)
                                                .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp();

                Pool.FreeList(ref players);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                if (player == team.GetLeader()) return;
                if ((team == null) || (player == null)) return;
                var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName },
                            { "teamleader", team.GetLeader().displayName },
                            { "teamid", team.teamID.ToString() }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnTeamLeave", dict));
                        });
                    }
                }
            }
        }
        void OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong target)
        {
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                NextTick(() =>
                {
                    string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;
                    var targetplayer = GetPlayer(target);

                    List<string> players = Pool.GetList<string>();
                    foreach (ulong member in team.members)
                    {
                        IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                        if (memberPlayer != null)
                        {
                            players.Add(GetPlayerFormattedField(memberPlayer));
                        }
                        else
                        {
                            players.Add(member.ToString());
                        }
                    }

                    DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("TEAM KICK")
                                                  .AddColor("#FF0000")
                                                  .AddThumbnail("https://i.imgur.com/92y7DWt.png")
                                                  .AddDescription($"{targetplayer.Name} was kicked from {leaderName}'s team.")
                                                  .AddField("Team ID", team.teamID.ToString(), true)
                                                  .AddField("Team Leader", leaderName, true)
                                                  .AddField("Team Members", string.Join("\n", players), false)
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp();

                    Pool.FreeList(ref players);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("log_teams"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, builder.Build());
                            });
                        }
                    }
                });
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                var targetplayer = FindPlayerByID(target.ToString());
                var dict = new Dictionary<string, string>
                        {
                            { "playername", targetplayer.displayName },
                            { "teamleader", team.GetLeader().displayName },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "teamid", team.teamID.ToString() }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnTeamKicked", dict));
                        });
                    }
                }
            }
        }
        void OnTeamDisbanded(RelationshipManager.PlayerTeam team)
        {
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;

                List<string> players = Pool.GetList<string>();
                foreach (ulong member in team.members)
                {
                    IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                    if (memberPlayer != null)
                    {
                        players.Add(GetPlayerFormattedField(memberPlayer));
                    }
                    else
                    {
                        players.Add(member.ToString());
                    }
                }

                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("TEAM DISBANDED")
                                              .AddColor("#FF0000")
                                              .AddThumbnail("https://i.imgur.com/B9mPg0l.png")
                                              .AddField("Team ID", team.teamID.ToString(), true)
                                              .AddField("Leader", leaderName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp();

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                            { "teamleader", team.GetLeader().displayName },
                            { "teamid", team.teamID.ToString() }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnTeamDisbanded", dict));
                        });
                    }
                }
            }
        }
        #endregion

        #region Vehicle Spawn Logging

        private void OnEntitySpawned(BaseEntity Entity)
        {
            var dict = new Dictionary<string, string>
            {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
            };
            if (Entity == null) return;
            if (Entity is BaseHelicopter)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_helispawn"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnHeliSpawn"));
                        });
                    }
                }
            }
            if (Entity is CargoPlane)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_planespawn"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnPlaneSpawn"));
                        });
                    }
                }
            }
            if (Entity is CargoShip)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_shipspawn"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnShipSpawn"));
                        });
                    }
                }

            }
            if (Entity is CH47Helicopter)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_chinookspawn"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnChinookSpawn"));
                        });
                    }
                }
            }
            if (Entity is BradleyAPC)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_bradleyspawn"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("RUST_OnBradleySpawn"));
                        });
                    }
                }
            }

        }
        #endregion

        #endregion

        #region External Plugin Logging

        #region Admin Hammer

        void OnAdminHammerEnabled(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeAdminHammer == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminhammer"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_AdminHammer_Enabled", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAdminHammer == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Admin Hammer Plugin")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has enabled Admin Hammer.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5ebb965d00f21.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminhammer"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }

        }
        void OnAdminHammerDisabled(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeAdminHammer == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminhammer"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_AdminHammer_Disabled", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAdminHammer == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Admin Hammer Plugin")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has disabled Admin Hammer.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5ebb965d00f21.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminhammer"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Admin Radar
        void OnRadarActivated(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeAdminRadar == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminradar"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_AdminRadar_Enabled", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAdminRadar == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Admin Radar Plugin")
                                              .AddUrl("https://umod.org/plugins/admin-radar")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has enabled Admin Radar.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b7e1bc17d769.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminradar"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnRadarDeactivated(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeAdminRadar == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminradar"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_AdminRadar_Disabled", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAdminRadar == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Admin Radar Plugin")
                                              .AddUrl("https://umod.org/plugins/admin-radar")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has disabled Admin Radar.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b7e1bc17d769.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminradar"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Better Chat Mute

        private void OnBetterChatMuted(IPlayer target, IPlayer player, string reason)
        {
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "targetname", target.Name },
                            { "reason", reason },
                            { "muter", player.Name }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_BetterChatMute_Mute", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Better Chat Mute Plugin")
                                              .AddUrl("https://umod.org/plugins/better-chat-mute")
                                              .AddColor("#800080")
                                              .AddDescription($"Permanent Mute Issued By: {player.Name}.")
                                              .AddField("Muted Player", target.Name, false)
                                              .AddField("Reason", reason, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5f242f4c92225.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }

        private void OnBetterChatTimeMuted(IPlayer target, IPlayer player, TimeSpan time, string reason)
        {
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "targetname", target.Name },
                            { "reason", reason },
                            { "muter", player.Name },
                            { "duration", FormatTime((TimeSpan) time) }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_BetterChatMute_TimedMute", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Better Chat Mute Plugin")
                                              .AddUrl("https://umod.org/plugins/better-chat-mute")
                                              .AddColor("#800080")
                                              .AddDescription($"Temporary Mute Issued By: {player.Name}.")
                                              .AddField("Muted Player", target.Name, true)
                                              .AddField("Duration", FormatTime((TimeSpan)time), true)
                                              .AddField("Reason", reason, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5f242f4c92225.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }

        private void OnBetterChatUnmuted(IPlayer target, IPlayer player)
        {
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "targetname", target.Name },
                            { "unmuter", player.Name }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_BetterChatMute_UnMute", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Better Chat Mute Plugin")
                                              .AddUrl("https://umod.org/plugins/better-chat-mute")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.Name} removed {target.Name}'s mute.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5f242f4c92225.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }


        private void OnBetterChatMuteExpired(IPlayer target)
        {
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "targetname", target.Name }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_BetterChatMute_MuteExpire", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Better Chat Mute Plugin")
                                              .AddUrl("https://umod.org/plugins/better-chat-mute")
                                              .AddColor("#800080")
                                              .AddDescription($"{target.Name}'s mute has expired.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5f242f4c92225.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Clans

        void OnClanCreate(string tag, string ownerID)
        {
            if ((_settings.PluginLog.LogPluginClans == true) && (_settings.OutputFormat.OutputTypeClans == "Simple"))
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "clantag", tag }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_clans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_Clans_CreateClan", dict));
                        });
                    }
                }

            }
            if ((_settings.PluginLog.LogPluginClans == true) && (_settings.OutputFormat.OutputTypeClans == "Embed"))
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                          .AddTitle("Clans Plugin")
                                          .AddUrl("https://umod.org/plugins/clans")
                                          .AddColor("#800080")
                                          .AddDescription($"Clan {tag} has been created.")
                                          .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                          .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b63bf642ea2c.jpg");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_clans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnClanDisbanded(string tag, List<string> memberUserIDs)
        {
            if ((_settings.PluginLog.LogPluginClans == true) && (_settings.OutputFormat.OutputTypeClans == "Simple"))
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "clantag", tag }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_clans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_Clans_DisbandClan", dict));
                        });
                    }
                }
            }
            if ((_settings.PluginLog.LogPluginClans == true) && (_settings.OutputFormat.OutputTypeClans == "Embed"))
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                          .AddTitle("Clans Plugin")
                                          .AddUrl("https://umod.org/plugins/clans")
                                          .AddColor("#800080")
                                          .AddDescription($"Clan {tag} has been Disbanded.")
                                          .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                          .AddNowTimestamp()
                                          .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b63bf642ea2c.jpg");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_clans"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnClanChat(IPlayer player, string message)
        {
            var dict = new Dictionary<string, string>
                        {
                            { "playername", player.Name },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "message", message }
                        };
            if (player.Name == null || message == null) return;
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("plugin_clanchat"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, Translate("PLUGIN_Clans_Chat", dict));
                    });
                }
            }
        }
        #endregion

        #region Dangerous Treasures

        private void OnDangerousEventStarted(Vector3 containerPos)
        {
            if (containerPos == null) return;
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "position", containerPos.ToString() },
                            { "gridposition", FindGridPosition(containerPos).ToString() }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_dangeroustreasures"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_DangerousTreasures_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Dangerous Treasures Plugin")
                                              .AddUrl("https://umod.org/plugins/dangerous-treasures")
                                              .AddDescription("Dangerous Event Started")
                                              .AddField("Position", $"{ FindGridPosition(containerPos)} {containerPos} ", true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b7d66ce65af7.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_dangeroustreasures"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        private void OnDangerousEventEnded(Vector3 containerPos)
        {
            if (containerPos == null) return;
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "position", containerPos.ToString() },
                            { "gridposition", FindGridPosition(containerPos).ToString() }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_dangeroustreasures"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_DangerousTreasures_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Dangerous Treasures Plugin")
                                              .AddUrl("https://umod.org/plugins/dangerous-treasures")
                                              .AddDescription("Dangerous Event Ended")
                                              .AddField("Position", $"{FindGridPosition(containerPos)} {containerPos} ", true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b7d66ce65af7.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_dangeroustreasures"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Death Notes
        private void OnDeathNotice(Dictionary<string, object> data, string message)
        {
            if (_client == null) return;
            if (data["VictimEntityType"] == null || data["KillerEntityType"] == null) return;
            int victimType = (int)data["VictimEntityType"];
            int killerType = (int)data["KillerEntityType"];

            var _DeathNotes = plugins.Find("DeathNotes");
            var deathmessage = (string)_DeathNotes.Call("StripRichText", message);

            var dict = new Dictionary<string, string>
                    {
                        { "deathmessage", deathmessage},
                        { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                    };

            if (_DeathNotes != null)
                if ((victimType == 5 && (killerType == 5 || killerType == 6 || killerType == 7 || killerType == 8 || killerType == 9 || killerType == 10 || killerType == 11 || killerType == 12 || killerType == 14 || killerType == 15)))
                {
                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("plugin_deathnotes_pvp"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, Translate("PLUGIN_DeathNotes_Death", dict));
                            });
                        }
                    }

                }
                else if ((victimType == 2 && killerType == 5) || (victimType == 5 && killerType == 2))
                {
                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("plugin_deathnotes_animal"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, Translate("PLUGIN_DeathNotes_Death", dict));
                            });
                        }
                    }

                }
                else if ((victimType == 5 && (killerType == 0 || killerType == 1)) || ((victimType == 0 || victimType == 1) && (killerType == 5)))
                {
                    message = (string)_DeathNotes.Call("StripRichText", message);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("plugin_deathnotes_vehicle"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, Translate("PLUGIN_DeathNotes_Death", dict));
                            });
                        }
                    }
                }
                else if ((victimType == 5 && (killerType == 3 || killerType == 4 || killerType == 16 || killerType == 17 || killerType == 18)) || ((victimType == 3 || victimType == 4 || victimType == 16 || victimType == 17 || victimType == 18) && (killerType == 5)))
                {
                    message = (string)_DeathNotes.Call("StripRichText", message);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("plugin_deathnotes_npc"))
                        {
                            GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(_client, Translate("PLUGIN_DeathNotes_Death", dict));
                            });
                        }
                    }

                }
        }
        #endregion

        #region Discord Auth
        private void OnDiscordPlayerLinked(IPlayer player, DiscordUser user)
        {
            if (player == null || user == null) return;
            if (_settings.OutputFormat.OutputTypeDiscordAuth == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "gamename", player.Name },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "discordname", user.GetFullUserName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_discordauth"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_DiscordAuth_Auth", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDiscordAuth == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Discord Auth Plugin")
                                              .AddUrl("https://umod.org/plugins/discord-auth")
                                              .AddColor("#800080")
                                              .AddDescription("Player Account Linked.")
                                              .AddField("Rust Player", player.Name, true)
                                              .AddField("Discord Account", user.GetFullUserName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddColor("#00FF00")
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5d20e5691c3c5.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_discordauth"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }

        }
        private void OnDiscordPlayerUnlinked(IPlayer player, DiscordUser user)
        {
            if (player == null || user == null) return;
            if (_settings.OutputFormat.OutputTypeDiscordAuth == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "gamename", player.Name },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "discordname", user.GetFullUserName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_discordauth"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_DiscordAuth_Deauth", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDiscordAuth == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Discord Auth Plugin")
                                              .AddUrl("https://umod.org/plugins/discord-auth")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.Name} Unlinked From Discord.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddColor("#FF0000")
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5d20e5691c3c5.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_discordauth"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Godmode
        private void OnGodmodeToggled(string playerId, bool enabled)
        {
            var player = covalence.Players.FindPlayerById(playerId);
            if (player.Name == null) return;
            if (_settings.OutputFormat.OutputTypeGodmode == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_godmode"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            if (enabled == true)
                            {
                                chan.CreateMessage(_client, Translate("PLUGIN_Godmode_Enabled", dict));
                            }
                            if (enabled == false)
                            {
                                chan.CreateMessage(_client, Translate("PLUGIN_Godmode_Disabled", dict));
                            }
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeGodmode == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Godmode Plugin")
                                              .AddUrl("https://umod.org/plugins/godmode")
                                              .AddColor("#800080")
                                              .AddDescription("Godmode has been toggled")
                                              .AddField("Player", player.Name, true)
                                              .AddField("Enabled", enabled.ToString(), true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b6394e5e597b.jpg");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_godmode"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Kits
        void OnKitRedeemed(BasePlayer player, string kitName)
        {
            if (player == null || kitName == null) return;
            if (_settings.OutputFormat.OutputTypeKits == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "kitname", kitName },
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_kits"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_Kits_Redeemed", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeKits == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Kits Plugin")
                                              .AddUrl("https://umod.org/plugins/kits")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has redeemd a kit.")
                                              .AddField("Kit", kitName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b910ab50f5d1.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_kits"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Private Messages
        [HookMethod("OnPMProcessed")]
        void OnPMProcessed(IPlayer sender, IPlayer target, string message)
        {
            if (_settings.OutputFormat.OutputTypePMs == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "sendername", sender.Name },
                            { "targetname", target.Name },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "message", message }
                        };

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_privatemessages"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_PrivateMessages_PM", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypePMs == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Private Messages Plugin")
                                              .AddUrl("https://umod.org/plugins/private-messages")
                                              .AddColor("#800080")
                                              .AddField("From", sender.Name, true)
                                              .AddField("To", target.Name, true)
                                              .AddField("Message", message, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b66ed6b7e606.jpg");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_privatemessages"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Raidable Bases
        void OnRaidableBaseStarted(Vector3 pos, int difficulty)
        {
            string rbdiff = string.Empty;
            if (difficulty == 0) rbdiff = "Easy";
            if (difficulty == 1) rbdiff = "Medium";
            if (difficulty == 2) rbdiff = "Hard";
            if (difficulty == 3) rbdiff = "Expert";
            if (difficulty == 4) rbdiff = "Nightmare";
            if (difficulty == 512) rbdiff = "Normal";

            if (_settings.OutputFormat.OutputTypeRaidableBases == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "position", pos.ToString() },
                            { "gridposition", FindGridPosition(pos).ToString() },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "difficulty", rbdiff }
                        };

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_raidablebases"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_RaidableBases_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeRaidableBases == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Raidable Bases Plugin")
                                              .AddUrl("https://umod.org/plugins/raidable-bases")
                                              .AddColor("#800080")
                                              .AddDescription("A Raidable Base Has Spawned.")
                                              .AddField("Difficulty", rbdiff, true)
                                              .AddField("Location", $"{FindGridPosition(pos)} {pos}", true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5e986213be8c8.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_raidablebases"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnRaidableBaseEnded(Vector3 pos, int difficulty)
        {
            string rbdiff = string.Empty;
            if (difficulty == 0) rbdiff = "Easy";
            if (difficulty == 1) rbdiff = "Medium";
            if (difficulty == 2) rbdiff = "Hard";

            if (_settings.OutputFormat.OutputTypeRaidableBases == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "position", pos.ToString() },
                            { "gridposition", FindGridPosition(pos).ToString() },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "difficulty", rbdiff }
                        };

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_raidablebases"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_RaidableBases_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeRaidableBases == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Raidable Bases Plugin")
                                              .AddUrl("https://umod.org/plugins/raidable-bases")
                                              .AddColor("#800080")
                                              .AddDescription($"Raidable Base at {FindGridPosition(pos)} Has Ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5e986213be8c8.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_raidablebases"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Sign Artist
        private void OnImagePost(BasePlayer player, string image)
        {
            var dict = new Dictionary<string, string>
                        {
                            { "playername", player.displayName },
                            { "position", $"{player.transform.position.x} {player.transform.position.y} {player.transform.position.z}" }
                        };

            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("plugin_signartist"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, SignArtistEmbed(Translate("PLUGIN_SignArtist", dict), image));
                    });
                }
            }
        }

        private DiscordEmbed SignArtistEmbed(string text, string image)
        {
            DiscordEmbed embed = new DiscordEmbedBuilder()
                                 .AddTitle("SignArtist Plugin")
                                 .AddUrl("https://umod.org/plugins/sign-artist")
                                 .AddThumbnail("https://i.imgur.com/NBu6OjS.png")
                                 .AddDescription(text)
                                 .AddColor(52326)
                                 .AddImage(image)
                                 .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                 .AddNowTimestamp()
                                 .Build();

            return embed;
        }
        #endregion

        #region Vanish
        void OnVanishDisappear(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeVanish == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_vanish"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_Vanish_Disappear", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeVanish == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Vanish Plugin")
                                              .AddUrl("https://umod.org/plugins/vanish")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has vanished.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5e2c4da074770.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_vanish"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnVanishReappear(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeVanish == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_vanish"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_Vanish_Reappear", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeVanish == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Vanish Plugin")
                                              .AddUrl("https://umod.org/plugins/vanish")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has reappeared.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5e2c4da074770.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_vanish"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion


        #endregion

        #region Premium Plugins

        #region Air Event
        void OnAirEventStart(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeAirEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_airevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_AirEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAirEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Air Event Plugin")
                                              .AddUrl("https://lone.design/product/airevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Air Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1010785120237649961/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_airevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnAirEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeAirEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_airevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_AirEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAirEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Air Event Plugin")
                                              .AddUrl("https://lone.design/product/airevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Air Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1010785120237649961/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_airevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Armored Train Event
        void OnArmoredTrainEventStart()
        {
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_armoredtrainevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_ArmoredTrainEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Armored Train Event Plugin")
                                              .AddUrl("https://lone.design/product/armored-train-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Armored Train Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012196381617815584/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_armoredtrainevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnArmoredTrainEventStop()
        {
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_armoredtrainevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_ArmoredTrainEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Armored Train Event Plugin")
                                              .AddUrl("https://lone.design/product/armored-train-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Armored Train Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012196381617815584/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_armoredtrainevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Cargo Train Event
        void OnTrainEventStarted(TrainEngine train)
        {
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_cargotrainevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_CargoTrainEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Cargo Train Event Plugin")
                                              .AddUrl("https://lone.design/product/cargo-train-event-rust/")
                                              .AddColor("#800080")
                                              .AddDescription("Cargo Train Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012200951647588422/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_cargotrainevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnTrainEventEnded(TrainEngine train)
        {
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_cargotrainevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_CargoTrainEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Cargo Train Event Plugin")
                                              .AddUrl("https://lone.design/product/cargo-train-event-rust/")
                                              .AddColor("#800080")
                                              .AddDescription("Cargo Train Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012200951647588422/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_cargotrainevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Convoy Event
        void OnConvoyStart()
        {
            if (_settings.OutputFormat.OutputTypeConvoyEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_convoyevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_ConvoyEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeConvoyEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Convoy Event Plugin")
                                              .AddUrl("https://lone.design/product/convoy-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Convoy Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012202423940567150/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_convoyevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnConvoyStop()
        {
            if (_settings.OutputFormat.OutputTypeConvoyEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_convoyevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_ConvoyEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeConvoyEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Convoy Event Plugin")
                                              .AddUrl("https://lone.design/product/convoy-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Convoy Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012202423940567150/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_convoyevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Harbor Event
        void OnHarborEventStart()
        {
            if (_settings.OutputFormat.OutputTypeHarborEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_harborevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_HarborEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeHarborEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Harbor Event Plugin")
                                              .AddUrl("https://lone.design/product/harborevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Harbor Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1010813485791326288/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_harborevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnHarborEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeHarborEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_harborevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_HarborEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeHarborEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Harbor Event Plugin")
                                              .AddUrl("https://lone.design/product/harborevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Harbor Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1010813485791326288/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_harborevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Junkyard Event
        void OnJunkyardEventStart()
        {
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_junkyardevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_JunkyardEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Junkyard Event Plugin")
                                              .AddUrl("https://lone.design/product/junkyardevent-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Junkyard Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011142703939063868/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_junkyardevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnJunkyardEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_junkyardevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_JunkyardEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Junkyard Event Plugin")
                                              .AddUrl("https://lone.design/product/junkyardevent-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Junkyard Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011142703939063868/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_junkyardevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Power Plant Event
        void OnPowerPlantEventStart()
        {
            if (_settings.OutputFormat.OutputTypePowerPlantEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_powerplantevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_PowerPlantEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypePowerPlantEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Power Plant Event Plugin")
                                              .AddUrl("https://lone.design/product/power-plant-event/")
                                              .AddColor("#800080")
                                              .AddDescription("Power Plant Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011144872826253372/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_powerplantevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnPowerPlantEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypePowerPlantEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_powerplantevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_PowerPlantEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Power Plant Event Plugin")
                                              .AddUrl("https://lone.design/product/power-plant-event/")
                                              .AddColor("#800080")
                                              .AddDescription("Power Plant Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011144872826253372/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_powerplantevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Satellite Dish Event
        void OnSatDishEventStart()
        {
            if (_settings.OutputFormat.OutputTypeSatDishEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_satdishevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_SatDishEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeSatDishEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Satellite Dish Event Plugin")
                                              .AddUrl("https://lone.design/product/satdishevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Satellite Dish Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011145882395213854/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_satdishevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnSatDishEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeSatDishEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_satdishevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_SatDishEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeSatDishEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Satellite Dish Event Plugin")
                                              .AddUrl("https://lone.design/product/satdishevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Satellite Dish Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011145882395213854/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_satdishevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Sputnik Event
        void OnSputnikEventStart()
        {
            if (_settings.OutputFormat.OutputTypeSputnikEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_sputnikevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_SputnikEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeSputnikEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Sputnik Event Plugin")
                                              .AddUrl("https://lone.design/product/sputnik/")
                                              .AddColor("#800080")
                                              .AddDescription("Sputnik Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011495773936037888/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_sputnikevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnSputnikEventStop()
        {
            if (_settings.OutputFormat.OutputTypeSputnikEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_sputnikevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_SputnikEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeSputnikEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Sputnik Event Plugin")
                                              .AddUrl("https://lone.design/product/sputnik/")
                                              .AddColor("#800080")
                                              .AddDescription("Sputnik Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011495773936037888/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_sputnikevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Water Event
        void OnWaterEventStart()
        {
            if (_settings.OutputFormat.OutputTypeWaterEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_waterevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_WaterEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeWaterEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Water Event Plugin")
                                              .AddUrl("https://lone.design/product/waterevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Water Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011166741310754836/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_waterevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnWaterEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeWaterEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_waterevent"))
                    {

                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, Translate("PLUGIN_WaterEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeWaterEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Water Event Plugin")
                                              .AddUrl("https://lone.design/product/waterevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Water Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011166741310754836/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_waterevent"))
                    {
                        GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(_client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #endregion
    }
}

// --- End of file: Rustcord.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/Smelt.cs ---
// --- Original Local Path: BeeRust/Smelt.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using ru = Oxide.Game.Rust;

namespace Oxide.Plugins
{
    [Info("Smelt", "Rosty", "0.0.1")]
    class Smelt : RustPlugin
    {
        #region Config
        private PluginConfig config;
        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class PluginConfig
        {
            [JsonProperty("")]
            public float cooldown;

            [JsonProperty(" ")]
            public string command;

            [JsonProperty(" ?")]
            public bool wood;

            [JsonProperty("")]
            public Dictionary<string, string> messages;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    cooldown = 300f,
                    command = "smelt",
                    wood = true,
                    messages = new Dictionary<string, string>
                    {
                        {"M.COOLDOWN", "<color=#8888ff>[PsixRust]</color>       :<color=#ff8888> {0} </color> ."},
                        {"M.PERM", "<color=#8888ff>[PsixRust]</color>       <color=#ff8888>smelt</color>." },
                        {"M.INV", "<color=#8888ff>[PsixRust]</color>    <color=#ff8888>successfully</color>." }
                    }
                };
            }
        }
        #endregion

        #region Initialize
        const string perminsta = "justsmelt.instant";
        const string permcommand = "justsmelt.command";
        static Dictionary<ulong, float> cooldowns = new Dictionary<ulong, float>();
        static ItemDefinition coal;

        private void OnServerInitialized()
        {
            permission.RegisterPermission(perminsta, this);
            permission.RegisterPermission(permcommand, this);
            Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand(config.command, this, "SmeltCmd");
            if (config.wood) coal = ItemManager.FindItemDefinition(-1938052175);
        }
        #endregion

    

        #region Command
        private void SmeltCmd(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permcommand))
            {
                SendReply(player, config.messages["M.PERM"]);
                return;
            }

            float cooldown;
            if (cooldowns.TryGetValue(player.userID, out cooldown) && cooldown > UnityEngine.Time.realtimeSinceStartup)
            {
                SendReply(player, config.messages["M.COOLDOWN"], cooldowns[player.userID] - (int)UnityEngine.Time.realtimeSinceStartup);
                return;
            }

            foreach (Item item in player.inventory.AllItems()) SmeltIt(player, item);

            SendReply(player, config.messages["M.INV"]);
            cooldowns[player.userID] = (int)UnityEngine.Time.realtimeSinceStartup + config.cooldown;
        }
        #endregion

       #region Gathering
        /* private void OnItemAddedToContainer(ItemContainer container, Item item)
         {
             var player = container.GetOwnerPlayer();
             if (player == null || !permission.UserHasPermission(player.UserIDString, perminsta)) return;
             SmeltIt(player, item);
         }*/

        private object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            var player = entity.ToPlayer();
            if (player == null || !permission.UserHasPermission(player.UserIDString, perminsta)) return null;
            return SmeltIt(player, item);
        }

        private object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (!permission.UserHasPermission(player.UserIDString, perminsta)) return null;
            return SmeltIt(player, item);
        }

        private void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, perminsta)) return;
            SmeltIt(player, item);
        }
        #endregion

        #region Smelt
        private object SmeltIt(BaseEntity player, Item item)
        {
            if (item.info.itemid == -151838493 && config.wood) return GiveToPlayer(player, item, coal);
            else
            {
                ItemModCookable cookable = item.info.GetComponent<ItemModCookable>();
                if (cookable == null) return null;
                return GiveToPlayer(player, item, cookable.becomeOnCooked);
            }
        }

        private object GiveToPlayer(BaseEntity player, Item item, ItemDefinition def)
        {
            Item newItem = ItemManager.Create(def, item.amount);
            if (newItem == null) return null;
            item.Remove(0.0f);
            player.GiveItem(newItem, BaseEntity.GiveItemReason.ResourceHarvested);
            return true;
        }
        #endregion
    }
}

// --- End of file: Smelt.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/EventRandomizer.cs ---
// --- Original Local Path: BeeRust/EventRandomizer.cs ---

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using ConVar;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Event Randomizer", "mvrb", "0.3.4")]
    [Description("Set random timers for server events")]
    class EventRandomizer : RustPlugin
    {
        private float heliInterval;
        private float chinookInterval;
        private float cargoInterval;
        private float airdropInterval;

        private int lastHeli;
        private int lastChinook;
        private int lastCargo;
        private int lastAirdrop;

        private string permSpawnChinook = "eventrandomizer.spawn.ch47";
        private string permSpawnHeli = "eventrandomizer.spawn.heli";
        private string permSpawnCargo = "eventrandomizer.spawn.cargo";
        private string permSpawnAirdrop = "eventrandomizer.spawn.airdrop";
		
        private string permCheckTimer = "eventrandomizer.check";
		
		private bool initialized = false;

        private class EventTimer
        {
            public float Min;
            public float Max;
        }

        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NextHeliIn"] = "Next Patrol Helicopter spawns in {0}",
                ["NextChinookIn"] = "Next Chinook Helicopter spawns in {0}",
                ["NextCargoIn"] = "Next Cargo Ship spawns in {0}",
                ["NextAirdropIn"] = "Next Airdrop spawns in {0}",

                ["CargoSpawned"] = "A Cargo Ship has been spawned.",
                ["PatrolHelicopterSpawned"] = "A Patrol Helicopter has been spawned.",
                ["ChinookSpawned"] = "A Chinook Helicopter has been spawned.",
                ["AirdropSpawned"] = "An Airdrop has been spawned.",

                ["FormatTime"] = "{0} Hours {1} Minutes",

                ["EventNotEnabled"] = "The Min and Max timer for {0} is less than or equal to 0 so this event has been disabled.",

                ["Warning: MinGreaterThanMax"] = "The minimum value ({0}) for {1} is greater than the maximum value ({2})!",

                ["Error: NoPermission"] = "You do not have permission to use this command.",
            }, this);
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permSpawnChinook, this);
            permission.RegisterPermission(permSpawnHeli, this);
            permission.RegisterPermission(permSpawnCargo, this);
            permission.RegisterPermission(permSpawnAirdrop, this);
            permission.RegisterPermission(permCheckTimer, this);

            LoadVariables();

            foreach (var entry in configData.EventTimers)
            {
                if (entry.Value.Min > entry.Value.Max)
                {
                    PrintWarning(Lang("Warning: MinGreaterThanMax", null, entry.Value.Min, entry.Key, entry.Value.Max));
                }
            }

            if (configData.EventTimers["Helicopter"].Min > 0 && configData.EventTimers["Helicopter"].Max > 0)
            {
                heliInterval = UnityEngine.Random.Range(configData.EventTimers["Helicopter"].Min, configData.EventTimers["Helicopter"].Max);
                timer.Once(heliInterval, SpawnHeliRandom);
                PrintWarning(Lang("NextHeliIn", null, FormatTime(heliInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Helicopter"));
            }

            if (configData.EventTimers["Chinook"].Min > 0 && configData.EventTimers["Chinook"].Max > 0)
            {
                chinookInterval = UnityEngine.Random.Range(configData.EventTimers["Chinook"].Min, configData.EventTimers["Chinook"].Max);
                timer.Once(chinookInterval, SpawnChinookRandom);
                PrintWarning(Lang("NextChinookIn", null, FormatTime(chinookInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Chinook"));
            }

            if (configData.EventTimers["Cargo"].Min > 0 && configData.EventTimers["Cargo"].Max > 0)
            {
                cargoInterval = UnityEngine.Random.Range(configData.EventTimers["Cargo"].Min, configData.EventTimers["Cargo"].Max);
                timer.Once(cargoInterval, SpawnCargoRandom);
                PrintWarning(Lang("NextCargoIn", null, FormatTime(cargoInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Cargo"));
            }

            if (configData.EventTimers["Airdrop"].Min > 0 && configData.EventTimers["Airdrop"].Max > 0)
            {
                airdropInterval = UnityEngine.Random.Range(configData.EventTimers["Airdrop"].Min, configData.EventTimers["Airdrop"].Max);
                timer.Once(airdropInterval, SpawnAirdropRandom);
                PrintWarning(Lang("NextAirdropIn", null, FormatTime(airdropInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Airdrop"));
            }

            var currentTime = GetUnix();

            lastHeli = currentTime;
            lastChinook = currentTime;
            lastCargo = currentTime;
            lastAirdrop = currentTime;
			
			initialized = true;
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
			if (!initialized) return;			
            
            /*if (configData.blockServerAirdrops && entity is CargoPlane)
            {
                entity.KillMessage();
            }
            else*/ if (configData.blockServerCargoShips && entity is CargoShip)
            {
                entity.KillMessage();
            }
            else if (configData.blockServerChinooks && (entity is CH47Helicopter || entity is CH47HelicopterAIController))
            {
                //entity.KillMessage();
            }
            else if (configData.blockServerPatrolHelicopters && entity is PatrolHelicopterAI)
            {
                entity.KillMessage();
            }
        }

        [ChatCommand("heli")]
        private void CmdHeli(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permCheckTimer))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            player.ChatMessage(Lang("NextHeliIn", player.UserIDString, FormatTime(heliInterval + lastHeli - GetUnix())));
        }

        [ChatCommand("chinok")]
        private void CmdChinook(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permCheckTimer))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            player.ChatMessage(Lang("NextChinookIn", player.UserIDString, FormatTime(chinookInterval + lastChinook - GetUnix())));
        }

        [ChatCommand("cargo")]
        private void CmdCargo(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permCheckTimer))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            player.ChatMessage(Lang("NextCargoIn", player.UserIDString, FormatTime(cargoInterval + lastCargo - GetUnix())));
        }

        [ConsoleCommand("ch47.spawn")]
        private void ConsoleCmdSpawnCh47(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnChinook))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnChinook();
        }

        [ConsoleCommand("heli.spawn")]
        private void ConsoleCmdSpawnHeli(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnHeli))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnHeli();
        }

        [ConsoleCommand("cargo.spawn")]
        private void ConsoleCmdSpawnCargo(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnCargo))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnCargo();
        }

        [ConsoleCommand("airdrop.spawn")]
        private void ConsoleCmdSpawnAirdrop(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnAirdrop))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnAirdrop();
        }

        private void SpawnCargoRandom()
        {
            SpawnCargo();
            lastCargo = GetUnix();

            cargoInterval = UnityEngine.Random.Range(configData.EventTimers["Cargo"].Min, configData.EventTimers["Cargo"].Max);
            timer.Once(cargoInterval, SpawnCargoRandom);
        }

        private void SpawnHeliRandom()
        {
            SpawnHeli();
            lastHeli = GetUnix();

            heliInterval = UnityEngine.Random.Range(configData.EventTimers["Helicopter"].Min, configData.EventTimers["Helicopter"].Max);
            timer.Once(heliInterval, SpawnHeliRandom);
        }

        private void SpawnChinookRandom()
        {
            SpawnChinook();
            lastChinook = GetUnix();

            chinookInterval = UnityEngine.Random.Range(configData.EventTimers["Chinook"].Min, configData.EventTimers["Chinook"].Max);
            timer.Once(chinookInterval, SpawnChinookRandom);
        }

        private void SpawnAirdropRandom()
        {
            SpawnAirdrop();
            lastAirdrop = GetUnix();

            airdropInterval = UnityEngine.Random.Range(configData.EventTimers["Airdrop"].Min, configData.EventTimers["Airdrop"].Max);
            timer.Once(airdropInterval, SpawnAirdropRandom);
        }

        private string FormatTime(float seconds)
        {
            TimeSpan time = TimeSpan.FromSeconds(seconds);

            return Lang("FormatTime", null, time.Hours, time.Minutes);
        }

        private void SpawnAirdrop()
        {
            var entity = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab", new Vector3());
            entity?.Spawn();

            PrintWarning(Lang("AirdropSpawned"));
        }

        private void SpawnCargo()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            var cargoShip = GameManager.server.CreateEntity("assets/content/vehicles/boats/cargoship/cargoshiptest.prefab") as CargoShip;
            if (cargoShip == null) return;
            cargoShip.TriggeredEventSpawn();
            cargoShip.Spawn();

            PrintWarning(Lang("CargoSpawned"));
            Subscribe(nameof(OnEntitySpawned));
        }

        private void SpawnHeli()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            var heli = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab");
            if (heli == null) return;
            heli.Spawn();

            PrintWarning(Lang("PatrolHelicopterSpawned"));
            Subscribe(nameof(OnEntitySpawned));
        }

        private void SpawnChinook()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            var ch47 = (CH47HelicopterAIController)GameManager.server.CreateEntity("assets/prefabs/npc/ch47/ch47scientists.entity.prefab", new Vector3(0, 200, 0));
            if (ch47 == null) return;
            ch47.Spawn();

            PrintWarning(Lang("ChinookSpawned"));
            Subscribe(nameof(OnEntitySpawned));
        }

        private int GetUnix() => (int)(DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #region Config        
        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Event Timers in seconds")]
            public Dictionary<string, EventTimer> EventTimers { get; set; }

            [JsonProperty(PropertyName = "Block Airdrops spawned by the server")]
            public bool blockServerAirdrops;

            [JsonProperty(PropertyName = "Block Cargo Ships spawned by the server")]
            public bool blockServerCargoShips;

            [JsonProperty(PropertyName = "Block Chinooks spawned by the server")]
            public bool blockServerChinooks;

            [JsonProperty(PropertyName = "Block Patrol Helicopters spawned by the server")]
            public bool blockServerPatrolHelicopters;
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                EventTimers = new Dictionary<string, EventTimer>()
                {
                    { "Helicopter", new EventTimer(){ Min = 3600, Max = 7200 } },
                    { "Chinook", new EventTimer(){ Min = 7200, Max = 14400 } },
                    { "Cargo", new EventTimer(){ Min = 7200, Max = 10800 } },
                    { "Airdrop", new EventTimer(){ Min = 3600, Max = 3600 } }
                },
                blockServerPatrolHelicopters = true,
                blockServerChinooks =  true,
                blockServerAirdrops = true,
                blockServerCargoShips = true
            };

            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}

// --- End of file: EventRandomizer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/EnhancedBanSystem.cs ---
// --- Original Local Path: BeeRust/EnhancedBanSystem.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Database;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.SQLite.Libraries;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    
    [Info("Enhanced Ban System", "Reneb/Slut", "5.2.6")]
    class EnhancedBanSystem : CovalencePlugin
    {
        [PluginReference]
        private Plugin PlayerDatabase, DiscordMessages;

        ////////////////////////////////////////////////////////////
        // Static fields
        ////////////////////////////////////////////////////////////
        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        char[] ipChrArray = new char[] { '.' };

        private static BanSystem banSystem;

        static Hash<int, BanData> cachedBans = new Hash<int, BanData>();

        static List<int> wasBanned = new List<int>();

        ////////////////////////////////////////////////////////////
        // Config fields
        ////////////////////////////////////////////////////////////
        private static string Platform = "Steam";
        private static string Server = "1.1.1.1:28015";
        private static string Game = "Rust";

        string PermissionBan = "enhancedbansystem.ban";
        string PermissionUnban = "enhancedbansystem.unban";
        string PermissionBanlist = "enhancedbansystem.banlist";
        string PermissionKick = "enhancedbansystem.kick";

        private bool SQLite_use = false;
        private string SQLite_DB = "banlist.db";

        private bool MySQL_use = false;
        private string MySQL_Host = "localhost";
        private int MySQL_Port = 3306;
        private string MySQL_DB = "banlist";
        private string MySQL_User = "root";
        private string MySQL_Pass = "toor";

        private bool PlayerDatabase_use = false;
        private string PlayerDatabase_IPFile = "EnhancedBanSystem_IPs.json";

        private bool Files_use = false;

        private bool WebAPI_use = false;
        private string WebAPI_Ban_Request = "http://webpage.com/api.php?action=ban&pass=mypassword&id={id}&steamid={steamid}&name={name}&ip={ip}&reason={reason}&source={source}&game={game}&platform={platform}&server={server}&tempban={expiration}";
        private string WebAPI_Unban_Request = "http://webpage.com/api.php?action=unban&pass=mypassword&steamid={steamid}&name={name}&ip={ip}&name={name}&source={source}";
        private string WebAPI_IsBanned_Request = "http://webpage.com/api.php?action=isbanned&pass=mypassword&id={id}&update={update}&steamid={steamid}&ip={ip}&time={time}&name={name}&game=Rust&server=rust.kortal.org:28015";
        private string WebAPI_Banlist_Request = "http://webpage.com/banlist.php?startid={startid}";

        private bool Native_use = false;

        private string BanDefaultReason = "Banned";
        private string BanEvadeReason = "Ban Evade";

        private bool Kick_Broadcast = true;
        private bool Kick_Log = true;
        private bool Kick_OnBan = true;

        private bool Ban_Broadcast = true;
        private bool Ban_Log = true;
        private bool Discord_use = false;
        private string Discord_Webhook = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

        private bool Ban_Escape = true;

        private bool Log_Denied = true;

        protected override void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<string>("Server Info - Platform", ref Platform);
            CheckCfg<string>("Server Info - Game", ref Game);
            CheckCfg<string>("Server Info - IP:PORT", ref Server);

            CheckCfg<string>("Permissions - Ban", ref PermissionBan);
            CheckCfg<string>("Permissions - Unban", ref PermissionUnban);
            CheckCfg<string>("Permissions - Banlist", ref PermissionBanlist);
            CheckCfg<string>("Permissions - Kick", ref PermissionKick);

            CheckCfg<bool>("DataType - SQLite - use", ref SQLite_use);
            CheckCfg<string>("DataType - SQLite - Database Filename", ref SQLite_DB);

            CheckCfg<bool>("DataType - MySQL - use", ref MySQL_use);
            CheckCfg<string>("DataType - MySQL - Host", ref MySQL_Host);
            CheckCfg<int>("DataType - MySQL - Port", ref MySQL_Port);
            CheckCfg<string>("DataType - MySQL - Database", ref MySQL_DB);
            CheckCfg<string>("DataType - MySQL - User", ref MySQL_User);
            CheckCfg<string>("DataType - MySQL - Pass", ref MySQL_Pass);

            CheckCfg<bool>("DataType - Files - use", ref Files_use);

            CheckCfg<bool>("DataType - PlayerDatabase - use", ref PlayerDatabase_use);
            CheckCfg<string>("DataType - PlayerDatabase - IP Filename", ref PlayerDatabase_IPFile);

            CheckCfg<bool>("DataType - WebAPI - use", ref WebAPI_use);
            CheckCfg<string>("DataType - WebAPI - Host", ref WebAPI_Ban_Request);
            CheckCfg<string>("DataType - WebAPI - Unban", ref WebAPI_Unban_Request);
            CheckCfg<string>("DataType - WebAPI - IsBanned", ref WebAPI_IsBanned_Request);
            CheckCfg<string>("DataType - WebAPI - Banlist", ref WebAPI_Banlist_Request);

            CheckCfg<bool>("DataType - Native - use", ref Native_use);

            CheckCfg<bool>("Ban - Evade", ref Ban_Escape);
            CheckCfg<string>("Ban - Default Reason", ref BanDefaultReason);
            CheckCfg<string>("Ban - Evade Reason", ref BanEvadeReason);
            CheckCfg<bool>("Ban - Broadcast", ref Ban_Broadcast);
            CheckCfg<bool>("Ban - Log", ref Ban_Log);
            CheckCfg<bool>("DiscordMessages - Use Discord", ref Discord_use);
            CheckCfg<string>("DiscordMessages - Discord Webhook", ref Discord_Webhook);

            CheckCfg<bool>("Kick - Broadcast", ref Kick_Broadcast);
            CheckCfg<bool>("Kick - Log", ref Kick_Log);
            CheckCfg<bool>("Kick - On Ban", ref Kick_OnBan);

            CheckCfg<bool>("Denied Connection - Log", ref Log_Denied);

            SaveConfig();

            if (SQLite_use) banSystem |= BanSystem.SQLite;
            if (MySQL_use) banSystem |= BanSystem.MySQL;
            if (Native_use) banSystem |= BanSystem.Native;
            if (PlayerDatabase_use) banSystem |= BanSystem.PlayerDatabase;
            if (Files_use) banSystem |= BanSystem.Files;
            if (WebAPI_use) banSystem |= BanSystem.WebAPI;

            InitializeLang();
        }

        void InitializeLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "PlayerNotFound", "No matching player was found.\n" },
                { "PlayerTempBanned", "You are temporarily banned from this server ({0}). {1} left" },
                { "PlayerPermBanned", "You are permanently banned from this server ({0})." },
                {"LoadedBans","Loaded {0} bans" },
                {"BanExists","This ban already exists ({0})." },
                {"BanAdded","Successfully added {0} to the banlist." },
                {"MultipleBans","Multiple Bans Found:\n\r" },
                {"BansRemoved","{0} matching bans were removed" },
                {"PlayerNotBanned","{0} - {1} isn't banned.\n" },
                {"Loaded","Loaded" },
                {"NoPermission","You don't have the permission to use this command." },
                {"KickSyntax","Syntax: kick < Name | SteamID | IP | IP Range > < reason(optional) >" },
                {"UnbanSyntax","Syntax: unban < Name | SteamID | IP | IP Range >" },
                {"BanSyntax","Syntax: ban < Name | SteamID | IP | IP Range > < reason(optional) > < time in secondes(optional) > " },
                {"BanlistSyntax","Syntax: banlist <BanSystem> <startid>" },
                {"BanSystems","Avaible BanSystems:\n" },
                {"BanlistSyntax1","Wrong usage of /banlist" },
                {"OutOfRange","Index is out of range. Current bans recorded: {0}" },
                {"Banlist","Banlist - {0}-{1}/{2}\n" },
                {"PlayerPermBan", "{0} was permanently banned from the server for {1}" },
                {"PlayerTempBan", "{0} was temporarily banned for {1} for {2}" },
                {"PlayerKick", "<color=red>{0}</color> <color=silver>was kicked from the server for</color> <color=red>{1}</color>" },
                {"IPPermBan", "An IP was banned from the server for {0}" },
                {"IPTempBan", "An IP was temporarily banned for {0} for {1}" },
                {"BanUpdated", "Succesfully updated {0} in the banlist." }
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "PlayerNotFound", "   .\n" },
                { "PlayerTempBanned", "      (<color=#97be62>{0}</color>).  <color=#97be62>{1}</color>" },
                { "PlayerPermBanned", "      (<color=#97be62>{0}</color>)." },
                {"LoadedBans"," : <color=#97be62>{0}</color>" },
                {"BanExists","    (<color=#97be62>{0}</color>)." },
                {"BanAdded","<color=#97be62>{0}</color>     ." },
                {"MultipleBans","  :\n\r" },
                {"BansRemoved","  <color=#97be62>{0}</color>  " },
                {"PlayerNotBanned","<color=#97be62>{0}</color> - <color=#97be62>{1}</color>  .\n" },
                {"Loaded","" },
                {"NoPermission","       ." },
                {"KickSyntax"," : kick <  | SteamID | IP |  IP > <  () >" },
                {"UnbanSyntax"," : unban <  | SteamID | IP |  IP >" },
                {"BanSyntax"," :  <  | SteamID | IP |  IP > <  () > <    () >" },
                {"BanlistSyntax"," :   <BanSystem> <startid>" },
                {"BanSystems"," BanSystems:\n" },
                {"BanlistSyntax1","  <color=#97be62>/banlist</color>" },
                {"OutOfRange","   .   : <color=#97be62>{0}</color>" },
                {"Banlist","Banlist - <color=#97be62>{0}</color>-<color=#97be62>{1}</color>/<color=#97be62>{2}</color>\n" },
                {"PlayerPermBan", "<color=#97be62>{0}</color>      <color=#97be62>{1}</color>" },
                {"PlayerTempBan", "<color=#97be62>{0}</color>     <color=#97be62>{1}</color>  <color=#97be62>{2}</color>" },
                {"PlayerKick", "<color=#97be62>{0}</color>      <color=#97be62>{1}</color>" },
                {"IPPermBan", "IP-      <color=#97be62>{0}</color>" },
                {"IPTempBan", "IP-     <color=#97be62>{0}</color>  <color=#97be62>{1}</color>" },
                {"BanUpdated", "  <color=#97be62>{0}</color>   ." }
            }, this, "ru");
        }

        ////////////////////////////////////////////////////////////
        // ID Save
        ////////////////////////////////////////////////////////////

        private static DynamicConfigFile Ban_ID_File;
        private static int Ban_ID = 0;

        void Load_ID()
        {
            try
            {
                Ban_ID_File = Interface.Oxide.DataFileSystem.GetDatafile(Name + "_ID");
                Ban_ID = (int)Ban_ID_File["id"];
            }
            catch
            {
                Ban_ID = 0;
                Ban_ID_File["id"] = Ban_ID;
                Save_ID();
            }
        }

        void Save_ID()
        {
            Interface.Oxide.DataFileSystem.SaveDatafile(Name + "_ID");
        }

        static int GetNewID()
        {
            Ban_ID++;
            Ban_ID_File["id"] = Ban_ID;
            return Ban_ID;
        }

        ////////////////////////////////////////////////////////////
        // Enum & Class
        ////////////////////////////////////////////////////////////

        enum BanSystem
        {
            Native = 1,
            MySQL = 2,
            SQLite = 4,
            WebAPI = 8,
            PlayerDatabase = 16,
            Files = 32,
        }

        class BanData
        {
            public int id;
            public string steamid;
            public string ip;
            public string name;
            public string game;
            public string server;
            public string source;
            public double date;
            public double expire;
            public string reason;
            public string platform;

            public BanData() { }

            public BanData(object source, string userID, string name, string ip, string reason, double duration)
            {
                this.id = GetNewID();
                this.source = source is IPlayer ? ((IPlayer)source).Name : source is string ? (string)source : "Console";
                this.steamid = userID;
                this.name = name;
                this.ip = ip;
                this.reason = reason;
                this.expire = duration != 0.0 ? LogTime() + duration : 0.0;
                this.date = LogTime();
                this.platform = Platform;
                this.game = Game;
                this.server = Server;
            }

            public BanData(int id, string source, string userID, string name, string ip, string reason, string duration)
            {
                this.id = id;
                this.source = source;
                this.steamid = userID;
                this.name = name;
                this.ip = ip;
                this.reason = reason;
                this.expire = double.Parse(duration);
                this.date = LogTime();
                this.platform = Platform;
                this.game = Game;
                this.server = Server;
            }

            public string ToJson()
            {
                return JsonConvert.SerializeObject(this);
            }

            public override string ToString()
            {
                return string.Format("{0} - {1} - {2} - {3} - {4}", steamid, name, ip, reason, expire == 0.0 ? "Permanent" : expire < LogTime() ? "Expired" : string.Format("Temporary: {0}s", (expire - LogTime()).ToString()));
            }
        }

        ////////////////////////////////////////////////////////////
        // General Methods
        ////////////////////////////////////////////////////////////


        private bool IsPluginLoaded(Plugin plugin)
        {
            if (plugin != null)
            {
                return plugins.GetAll().Where(x => x.Equals(plugin) && x.IsLoaded) != null;
            }
            else
            {
                return false;
            }
        }
        string FormatTime(TimeSpan time) => $"{(time.Days == 0 ? string.Empty : $"{time.Days} day(s)")}{(time.Days != 0 && time.Hours != 0 ? $", " : string.Empty)}{(time.Hours == 0 ? string.Empty : $"{time.Hours} hour(s)")}{(time.Hours != 0 && time.Minutes != 0 ? $", " : string.Empty)}{(time.Minutes == 0 ? string.Empty : $"{time.Minutes} minute(s)")}{(time.Minutes != 0 && time.Seconds != 0 ? $", " : string.Empty)}{(time.Seconds == 0 ? string.Empty : $"{time.Seconds} second(s)")}";

        private bool TryParseTimeSpan(string source, out TimeSpan timeSpan)
        {
            int seconds = 0, minutes = 0, hours = 0, days = 0;

            Match s = new Regex(@"(\d+?)s", RegexOptions.IgnoreCase).Match(source);
            Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
            Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
            Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);

            if (s.Success)
                seconds = Convert.ToInt32(s.Groups[1].ToString());

            if (m.Success)
                minutes = Convert.ToInt32(m.Groups[1].ToString());

            if (h.Success)
                hours = Convert.ToInt32(h.Groups[1].ToString());

            if (d.Success)
                days = Convert.ToInt32(d.Groups[1].ToString());

            source = source.Replace(seconds + "s", string.Empty);
            source = source.Replace(minutes + "m", string.Empty);
            source = source.Replace(hours + "h", string.Empty);
            source = source.Replace(days + "d", string.Empty);

            if (!string.IsNullOrEmpty(source) || (!s.Success && !m.Success && !h.Success && !d.Success))
            {
                timeSpan = default(TimeSpan);
                return false;
            }

            timeSpan = new TimeSpan(days, hours, minutes, seconds);

            return true;
        }


        static double LogTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        string GetMsg(string key, object steamid = null, params object[] args)
        {

            if (args.Length != 0)
            {
                return string.Format(lang.GetMessage(key, this, steamid is IPlayer ? ((IPlayer)steamid).Id : steamid == null ? null : steamid.ToString()), args);
            }
            else
            {
                return lang.GetMessage(key, this, steamid is IPlayer ? ((IPlayer)steamid).Id : steamid == null ? null : steamid.ToString());
            }
        }

        bool hasPermission(IPlayer player, string permissionName)
        {
            if (player.IsAdmin) return true;
            return permission.UserHasPermission(player.Id.ToString(), permissionName);
        }

        bool isIPAddress(string arg)
        {
            int subIP;
            string[] strArray = arg.Split(ipChrArray);
            if (strArray.Length != 4)
            {
                return false;
            }
            foreach (string str in strArray)
            {
                if (str.Length == 0)
                {
                    return false;
                }
                if (!int.TryParse(str, out subIP) && str != "*")
                {
                    return false;
                }
                if (!(str == "*" || (subIP >= 0 && subIP <= 255)))
                {
                    return false;
                }
            }
            return true;
        }

        bool IPRange(string sourceIP, string targetIP)
        {
            string[] srcArray = sourceIP.Split(ipChrArray);
            string[] trgArray = targetIP.Split(ipChrArray);
            for (int i = 0; i < 4; i++)
            {
                if (srcArray[i] != trgArray[i] && srcArray[i] != "*")
                {
                    return false;
                }
            }
            return true;
        }

        bool RangeFromIP(string sourceIP, out string range1, out string range2, out string range3)
        {
            range1 = string.Empty;
            range2 = string.Empty;
            range3 = string.Empty;
            if (sourceIP == string.Empty) return false;

            string[] strArray = sourceIP.Split(ipChrArray);
            if (strArray.Length != 4)
            {
                return false;
            }

            range1 = string.Format("{0}.*.*.*", strArray[0]);
            range2 = string.Format("{0}.{1}.*.*", strArray[0], strArray[1]);
            range3 = string.Format("{0}.{1}.{2}.*", strArray[0], strArray[1], strArray[2]);

            return true;
        }

        List<IPlayer> FindPlayers(string userIDorNameorIP, object source, out string reason)
        {
            reason = string.Empty;
            var FoundPlayers = players.FindPlayers(userIDorNameorIP).ToList();
            if (FoundPlayers.Count == 0)
            {
                reason = GetMsg("PlayerNotFound", source) + "xd ";
            }
            if (FoundPlayers.Count > 1)
            {
                foreach (var iplayer in FoundPlayers)
                {
                    reason += string.Format("{0} {1}\r\n", iplayer.Id, iplayer.Name);
                }
            }
            return FoundPlayers;
        }

        List<IPlayer> FindConnectedPlayers(string userIDorNameorIP, object source, out string reason)
        {
            reason = string.Empty;
            ulong steamid = 0L;
            var FoundPlayers = new List<IPlayer>();
            ulong.TryParse(userIDorNameorIP, out steamid);
            if (isIPAddress(userIDorNameorIP))
            {
                FoundPlayers = players.All.Where(x => x.IsConnected).Where(w => IPRange(userIDorNameorIP, w.Address)).ToList();
            }
            else if (steamid != 0L)
            {
                var p = players.FindPlayer(userIDorNameorIP);
                if (p != null && p.IsConnected)
                {
                    FoundPlayers.Add(p);
                }
            }
            else
            {
                FoundPlayers = players.FindPlayers(userIDorNameorIP).Where(x => x.IsConnected).ToList();
                if (FoundPlayers.Count > 1)
                {
                    foreach (var iplayer in FoundPlayers)
                    {
                        reason += string.Format("{0} {1}\r\n", iplayer.Id, iplayer.Name);
                    }
                }
            }
            if (FoundPlayers.Count == 0)
            {
                reason = GetMsg("PlayerNotFound", source);
            }
            return FoundPlayers;
        }

        string GetPlayerIP(IPlayer iplayer)
        {
            try
            {
                if (iplayer.IsConnected) return iplayer.Address;
                return GetPlayerIP(iplayer.Id);
            }
            catch
            {
                return GetPlayerIP(iplayer.Id);
            }
        }
        string GetPlayerIP(string userID)
        {
            if (PlayerDatabase != null)
            {
                return (string)PlayerDatabase.Call("GetPlayerData", userID, "ip") ?? string.Empty;
            }
            return string.Empty;
        }

        string GetPlayerName(string userID)
        {
            if (PlayerDatabase != null)
            {
                return (string)PlayerDatabase.Call("GetPlayerData", userID, "name") ?? string.Empty;
            }
            return string.Empty;
        }
        bool HasDelayedAnswer() => BanSystemHasFlag(banSystem, BanSystem.MySQL) || BanSystemHasFlag(banSystem, BanSystem.SQLite) || (BanSystemHasFlag(banSystem, BanSystem.WebAPI));

        bool BanSystemHasFlag(BanSystem b, BanSystem t) => (b & t) == t;

        string FormatReturn(BanSystem system, string msg, params object[] args) => string.Format("{0}: {1}", system.ToString(), string.Format(msg, args));

        void SendReply(object source, string msg)
        {
            if (source is IPlayer) ((IPlayer)source).Reply(msg);
            else if (source is string) return;
            else Interface.Oxide.LogInfo(msg);
        }

        public static string ToShortString(TimeSpan timeSpan)
        {
            return string.Format("{0:00}:{1:00}:{2:00}", (int)timeSpan.TotalHours, timeSpan.Minutes, timeSpan.Seconds);
        }

        ////////////////////////////////////////////////////////////
        // Oxide Hooks
        ////////////////////////////////////////////////////////////


        void OnServerInitialized()
        {
            Load_ID();
            List<string> returnString = new List<string>();

            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                 returnString.Add(PlayerDatabase_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnString.Add(Files_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnString.Add(MySQL_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnString.Add(SQLite_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnString.Add(WebAPI_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnString.Add(Native_Load());
            }

            if (returnString.Count == 0)
            {
                this.LogWarning("You must enable at least one Ban System to use this plugin!");
                Interface.Oxide.UnloadPlugin(Name);
            }

            permission.RegisterPermission(PermissionBan, this);
            permission.RegisterPermission(PermissionBanlist, this);
            permission.RegisterPermission(PermissionKick, this);
            permission.RegisterPermission(PermissionUnban, this);

            Interface.Oxide.LogInfo(string.Join("\n", returnString.ToArray()));

            if (Discord_use && (!IsPluginLoaded(DiscordMessages) || Discord_Webhook.Equals("https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks")))
            {
                LogError("DiscordMessages enabled but it isn't setup correctly.");
                Discord_use = false;
            }
        }

        void Unload() => OnServerSave();

        void OnServerSave()
        {
            Save_ID();
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                Save_PlayerDatabaseIP();
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                Save_Files();
            }
        }
        private void OnUserBanned(string name, string id, string address, string reason)
        {
            timer.Once(5f, () =>
            {
                if (!isBanned_Check(name, id, address))
                {
                    Puts("Adding banned player to EnhancedBanSystem");
                    BanData bd = new BanData("Auto Ban", id, name, address, reason, 0.0);
                    ExecuteBan("Auto Ban", bd, false);
                }
            });
        }
        object CanUserLogin(string name, string id, string ip)
        {
            BanData bd = null;
            if (isBanned_NonDelayed(name, id, ip, Ban_Escape, out bd))
            {
                if (bd != null && bd.expire != 0.0)
                {
                    return GetMsg("PlayerTempBanned", id, bd.reason, FormatTime(TimeSpan.FromSeconds(bd.expire - LogTime())));
                }
                return GetMsg("PlayerPermBanned", id, bd == null ? string.Empty : bd.reason);
            }
            return null;
        }

        void OnUserConnected(IPlayer player)
        {
            if (player == null) return;
            string ip = player.Address;
            string name = player.Name;
            string steamid = player.Id;

            isBanned_Delayed(name, steamid, ip, Ban_Escape);
        }

        ////////////////////////////////////////////////////////////
        // Files
        ////////////////////////////////////////////////////////////

        StoredData storedData;

        class StoredData
        {
            public HashSet<string> Banlist = new HashSet<string>();
        }

        string Files_Load()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = new StoredData();
            }
            foreach (var b in storedData.Banlist)
            {
                var bd = JsonConvert.DeserializeObject<BanData>(b);
                if (!cachedBans.ContainsKey(bd.id))
                    cachedBans.Add(bd.id, bd);
            }
            return FormatReturn(BanSystem.Files, GetMsg("LoadedBans", null), storedData.Banlist.Count.ToString());
        }

        void Save_Files()
        {
            if (storedData.Banlist == null)
            {
                return;
            }
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        string Files_UpdateBan(BanData bandata)
        {
            if (!cachedBans.ContainsKey(bandata.id)) return FormatReturn(BanSystem.Files, "No such ban id {0}", bandata.id);

            storedData.Banlist.Remove(cachedBans[bandata.id].ToJson());
            cachedBans.Remove(bandata.id);

            storedData.Banlist.Add(bandata.ToJson());

            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);

            return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
        }

        string Files_ExecuteBan(BanData bandata)
        {

            var f = cachedBans.Values.Where(x => x.ip == bandata.ip).Where(x => x.steamid == bandata.steamid).ToList();
            if (f.Count > 0)
            {
                var i = f.ToList();
                foreach (var id in i)
                {
                    if (id.expire == 0.0 || id.expire < LogTime()) continue;
                    storedData.Banlist.Remove(id.ToJson());
                    f.Remove(id);
                }
                if (f.Count > 0)
                {
                    return FormatReturn(BanSystem.Files, GetMsg("BanExists"), f[0].ToString());
                }
            }
            storedData.Banlist.Add(bandata.ToJson());
            Save_Files();
            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);

            return FormatReturn(BanSystem.Files, GetMsg("BanAdded"), bandata.ToString());
        }

        string Files_RawUnban(List<BanData> unbanList)
        {
            int i = 0;
            foreach (var u in unbanList)
            {
                var json = u.ToJson();
                if (storedData.Banlist.Contains(json))
                {
                    i++;
                    storedData.Banlist.Remove(json);
                }
            }
            return FormatReturn(BanSystem.Files, GetMsg("BansRemoved"), i.ToString());
        }

        string Files_ExecuteUnban(string steamid, string name, string ip, out List<BanData> unbanList)
        {
            unbanList = new List<BanData>();
            if (ip != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.ip == ip).ToList();
            }
            else if (steamid != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            }
            else
            {
                var list = cachedBans.Values.Where(x => x.name.ToLower().Equals(name.ToLower())).ToList();
                if (list.Count > 1)
                {
                    var ret = FormatReturn(BanSystem.Files, GetMsg("MultipleBans"));
                    foreach (var b in list)
                    {
                        ret += string.Format("{0} - {1} - {2}\n\r", b.steamid, b.name, b.reason);
                    }
                    return ret;
                }
                else
                {
                    unbanList = list;
                }
            }
            return Files_RawUnban(unbanList);
        }

        bool Files_IsBanned(string steamid, string ip, out BanData bandata)
        {
            bandata = null;
            double cTime = LogTime();
            bool permanent = false;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> list = new List<BanData>();
            // check by ID then IP
            var b_steamid = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            var b_steamid_ip = ip != null ? b_steamid.Where(w => w.ip == ip).ToList() : new List<BanData>();

            foreach (var b in b_steamid_ip)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                Files_RawUnban(unbanList);
                foreach (var u in unbanList)
                {
                    b_steamid_ip.Remove(u);
                }
                unbanList.Clear();
            }
            foreach (var b in b_steamid)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                Files_RawUnban(unbanList);
                foreach (var u in unbanList)
                {
                    b_steamid.Remove(u);
                }
                unbanList.Clear();
            }
            if (bandata == null)
            {
                if (b_steamid_ip.Count > 0)
                {
                    bandata = b_steamid_ip[0];
                }
                else if (b_steamid.Count > 0)
                {
                    bandata = b_steamid[0];
                }
            }
            if (bandata == null && !permanent)
            {
                // check by IP & IP Range
                list = ip != null ? cachedBans.Values.Where(x => x.ip != null && IPRange(x.ip, ip)).ToList() : new List<BanData>();
                foreach (var b in list)
                {
                    if (b.expire != 0.0 && cTime >= b.expire)
                    {
                        unbanList.Add(b);
                    }
                    else
                    {
                        if (b.expire == 0.0)
                        {
                            permanent = true;
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    Files_RawUnban(unbanList);
                    foreach (var u in unbanList)
                    {
                        list.Remove(u);
                    }
                    unbanList.Clear();
                }
                if (list.Count > 0)
                {
                    bandata = list[0];
                }
            }
            if (bandata != null && bandata.expire != 0.0 && permanent)
            {
                bandata.expire = 0.0;
                Files_UpdateBan(bandata);
            }
            return bandata != null;
        }

        string Files_Banlist(object source, int startid)
        {
            if (startid > cachedBans.Count)
            {
                return FormatReturn(BanSystem.Files, "Index is out of range. Current bans recorded: {0}", cachedBans.Count.ToString());
            }

            int i = -1;
            int max = startid + 9;

            string returnstring = FormatReturn(BanSystem.Files, GetMsg("Banlist"), startid.ToString(), max.ToString(), cachedBans.Count.ToString());


            var bans = from pair in cachedBans orderby pair.Key descending select pair;

            foreach (KeyValuePair<int, BanData> b in bans)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += b.ToString() + "\n";

            }

            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // PlayerDatabase
        ////////////////////////////////////////////////////////////

        static StoredIPData storedIPData;

        class StoredIPData
        {
            public HashSet<string> Banlist = new HashSet<string>();
        }

        string PlayerDatabase_Load()
        {
            if (!IsPluginLoaded(PlayerDatabase)) return FormatReturn(BanSystem.PlayerDatabase, "Missing plugin: oxidemod.org/threads/playerdatabase.18409/");

            try
            {
                storedIPData = Interface.Oxide.DataFileSystem.ReadObject<StoredIPData>(PlayerDatabase_IPFile);
            }
            catch
            {
                storedIPData = new StoredIPData();
            }

            if (storedIPData.Banlist.Count > 0)
            {
                foreach (var b in storedIPData.Banlist)
                {
                    var bd = JsonConvert.DeserializeObject<BanData>(b);
                    if (!cachedBans.ContainsKey(bd.id))
                        cachedBans.Add(bd.id, bd);
                }
            }
            var getKnownPlayers = (List<string>)PlayerDatabase.Call("GetAllKnownPlayers");
            if (getKnownPlayers == null) return FormatReturn(BanSystem.PlayerDatabase, "Error P01");

            int i = 0;
            List<BanData> list = new List<BanData>();
            foreach (var steamid in getKnownPlayers)
            {
                var success = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
                if (!(success is string)) continue;

                
                if (((string)success).Equals("System.Collections.Generic.List`1[Oxide.Plugins.EnhancedBanSystem+BanData]", StringComparison.Ordinal))
                {
                    list = new List<BanData>();
                }
                else
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)success);
                }

                foreach (var b in list)
                {
                    i++;
                    if (!cachedBans.ContainsKey(b.id))
                        cachedBans.Add(b.id, b);
                }
            }
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("LoadedBans"), i.ToString());
        }

        void Save_PlayerDatabaseIP()
        {
            Interface.Oxide.DataFileSystem.WriteObject(PlayerDatabase_IPFile, storedIPData);
        }


        string PlayerDatabase_ExecuteBan(BanData bandata)
        {
            if (bandata.steamid != string.Empty)
            {
                List<BanData> list = new List<BanData>();
                var success = PlayerDatabase.Call("GetPlayerDataRaw", bandata.steamid, "Banned");
                if (success is string)
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)success);
                }

                var f = list.Where(x => x.ip == bandata.ip).ToList();
                if (f.Count > 0)
                {
                    return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanExists"), f[0].ToString());
                }
                f.Add(bandata);
                PlayerDatabase.Call("SetPlayerData", bandata.steamid, "Banned", f, true);
            }
            else
            {
                var f2 = cachedBans.Values.Where(x => x.ip == bandata.ip).Where(x => x.steamid == string.Empty).ToList();
                if (f2.Count > 0)
                {
                    return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanExists"), f2[0].ToString());
                }
                storedIPData.Banlist.Add(bandata.ToJson());
            }
            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanAdded"), bandata.ToString());
        }

        string PlayerDatabase_UpdateBan(BanData bandata, double expire)
        {
            if (bandata.steamid == string.Empty)
            {
                if (cachedBans.ContainsKey(bandata.id))
                {
                    var json = bandata.ToJson();
                    if (storedIPData.Banlist.Contains(json))
                    {
                        cachedBans.Remove(bandata.id);
                        storedIPData.Banlist.Remove(json);
                        bandata.expire = expire;
                        storedIPData.Banlist.Add(bandata.ToJson());
                        cachedBans.Add(bandata.id, bandata);
                        return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
                    }
                }
            }
            else
            {
                List<BanData> list = new List<BanData>();
                bandata.expire = expire;
                var b_steamid = PlayerDatabase.Call("GetPlayerDataRaw", bandata.steamid, "Banned");
                if (b_steamid is string)
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)b_steamid);
                }
                if (list.Count > 0)
                {
                    foreach (var b in list)
                    {
                        b.expire = expire;
                    }
                    PlayerDatabase.Call("SetPlayerData", bandata.steamid, "Banned", list, true);
                    return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
                }
            }
            return string.Empty;
        }

        string PlayerDatabase_RawUnban(List<BanData> unbanList)
        {
            int i = 0;
            foreach (var u in unbanList)
            {
                if (u.steamid == string.Empty)
                {
                    var json = u.ToJson();
                    if (storedIPData.Banlist.Contains(json))
                    {
                        i++;
                        storedIPData.Banlist.Remove(json);
                    }
                }
                else
                {
                    i++;
                    PlayerDatabase.Call("SetPlayerData", u.steamid, "Banned", new List<BanData>(), true);
                }
            }
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BansRemoved"), i.ToString());
        }

        string PlayerDatabase_ExecuteUnban(string steamid, string name, string ip, out List<BanData> unbanList)
        {
            unbanList = new List<BanData>();
            if (ip != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.ip == ip).ToList();
            }
            else if (steamid != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            }
            else
            {
                unbanList = cachedBans.Values.Where(x => x.name == name).ToList();
                if (unbanList.Count == 0)
                {
                    var lname = name.ToLower();
                    unbanList = cachedBans.Values.Where(x => x.name.ToLower().Contains(lname)).ToList();
                    if (unbanList.Count > 1)
                    {
                        var ret = FormatReturn(BanSystem.PlayerDatabase, GetMsg("MultipleBans"));
                        foreach (var b in unbanList)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", b.steamid, b.name, b.reason);
                        }
                        return ret;
                    }
                }
            }
            return PlayerDatabase_RawUnban(unbanList);
        }

        bool PlayerDatabase_IsBanned(string steamid, string ip, out BanData bandata)
        {
            bandata = null;
            BanData possibleData = null;
            double cTime = LogTime();
            bool permanent = false;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> list = new List<BanData>();
            // check by ID then IP
            var b_steamid = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
            if (b_steamid is string)
            {
                list = JsonConvert.DeserializeObject<List<BanData>>((string)b_steamid);
            }
            foreach (var b in list)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                PlayerDatabase_RawUnban(unbanList);
                foreach (var b in unbanList)
                {
                    list.Remove(b);
                }
                unbanList.Clear();
            }

            if (list.Count > 0 && bandata == null)
            {
                possibleData = list[0];
            }
            // check by IP & IP Range
            list = ip != null ? cachedBans.Values.Where(x => x.ip != null && IPRange(x.ip, ip)).ToList() : new List<BanData>();
            foreach (var b in list)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                PlayerDatabase_RawUnban(unbanList);
                foreach (var b in unbanList)
                {
                    list.Remove(b);
                }
                unbanList.Clear();
            }
            if (list.Count > 0 && bandata == null && possibleData == null)
            {
                possibleData = list[0];
            }
            if (bandata == null && possibleData != null)
            {
                bandata = possibleData;
            }
            if (bandata != null && bandata.expire != 0.0 && permanent)
            {
                PlayerDatabase_UpdateBan(bandata, 0.0);
            }
            return bandata != null;
        }

        string PlayerDatabase_Banlist(object source, int startid)
        {
            if (startid > cachedBans.Count)
            {
                return FormatReturn(BanSystem.PlayerDatabase, GetMsg("OutOfRange"), cachedBans.Count.ToString());
            }

            int i = -1;
            int max = startid + 9;

            string returnstring = FormatReturn(BanSystem.PlayerDatabase, GetMsg("Banlist"), startid.ToString(), max.ToString(), cachedBans.Count.ToString());


            var bans = from pair in cachedBans orderby pair.Key descending select pair;

            foreach (KeyValuePair<int, BanData> b in bans)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += b.ToString() + "\n";

            }

            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // WebAPI
        ////////////////////////////////////////////////////////////

        string FormatOnlineBansystem(string line, Dictionary<string, string> args)
        {
            foreach (KeyValuePair<string, string> pair in args)
            {
                line = line.Replace(pair.Key, pair.Value);
            }
            return line;
        }

        string WebAPI_ExecuteBan(object source, BanData bandata)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Ban_Request, new Dictionary<string, string> { { "{id}", bandata.id.ToString() }, { "{steamid}", bandata.steamid }, { "{name}", bandata.name }, { "{ip}", bandata.ip }, { "{reason}", bandata.reason }, { "{source}", bandata.source }, { "{expiration}", bandata.expire.ToString() }, { "{game}", bandata.game }, { "{platform}", bandata.platform }, { "{server}", bandata.server } }), null, (code, response) =>
            {
                if (response == null && code == 200)
                {
                    response = FormatReturn(BanSystem.WebAPI, "Couldn't contact the WebAPI");
                }
                if (source is IPlayer) ((IPlayer)source).Reply(response);
                else Interface.Oxide.LogInfo(response);
            }, this);


            return string.Empty;
        }

        string WebAPI_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Unban_Request, new Dictionary<string, string> { { "{steamid}", steamid }, { "{name}", name }, { "{ip}", ip } }), null, (code, response) =>
            {
                if (response == null && code == 200)
                {
                    response = FormatReturn(BanSystem.WebAPI, "Couldn't contact the WebAPI");
                }
                if (source is IPlayer) ((IPlayer)source).Reply(response);
                else Interface.Oxide.LogInfo(response);
            }, this);

            return string.Empty;
        }

        string WebAPI_IsBanned(BanData bandata, bool update)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_IsBanned_Request, new Dictionary<string, string> { { "{id}", bandata.id.ToString() }, { "{steamid}", bandata.steamid }, { "{name}", bandata.name }, { "{ip}", bandata.ip }, { "{source}", "Auto Ban" }, { "{update}", update.ToString() }, { "{time}", LogTime().ToString() } }), null, (code, response) =>
            {
                if (response != null || code != 200)
                {
                    if (response == "false" || response == "0")
                        return;
                    timer.Once(0.01f, () => Kick(null, bandata.steamid, response == "true" || response == "1" ? "Banned" : response, false));
                }
                else
                {
                    Interface.Oxide.LogWarning("WebAPI couldn't be contacted or is not valid");
                }
            }, this);

            return string.Empty;
        }

        string WebAPI_Banlist(object source, int startid)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Banlist_Request, new Dictionary<string, string> { { "{startid}", startid.ToString() } }), null, (code, response) =>
            {
                if (response != null || code != 200)
                {
                    SendReply(source, response);
                }
            }, this);

            return string.Empty;
        }

        string WebAPI_Load()
        {
            return FormatReturn(BanSystem.WebAPI, GetMsg("Loaded"));
        }

        ////////////////////////////////////////////////////////////
        // SQLite
        ////////////////////////////////////////////////////////////

        SQLite Sqlite = Interface.Oxide.GetLibrary<SQLite>();
        Connection Sqlite_conn;

        string SQLite_Load()
        {
            var returnstring = string.Empty;
            try
            {
                Sqlite_conn = Sqlite.OpenDb(SQLite_DB, this);
                if (Sqlite_conn == null)
                {
                    returnstring = FormatReturn(BanSystem.SQLite, "Couldn't open the SQLite.");
                }
                else
                {
                    Sqlite.Insert(Core.Database.Sql.Builder.Append("CREATE TABLE IF NOT EXISTS EnhancedBanSystem ( id INTEGER NOT NULL PRIMARY KEY UNIQUE, steamid TEXT, name TEXT, ip TEXT, reason TEXT, source TEXT, game TEXT, platform TEXT, server TEXT, expire INTEGER );"), Sqlite_conn);
                    returnstring = FormatReturn(BanSystem.SQLite, GetMsg("Loaded"));
                }
            }
            catch (Exception e)
            {
                returnstring = e.Message;
            }
            return FormatReturn(BanSystem.SQLite, returnstring);
        }


        string SQLite_RawBan(BanData bandata)
        {
            try
            {
                Sqlite.Insert(Core.Database.Sql.Builder.Append("INSERT OR REPLACE INTO EnhancedBanSystem ( id, steamid, name, ip, reason, source, game, platform, server, expire ) VALUES ( @0, @1, @2, @3, @4, @5, @6, @7, @8, @9 )", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
            }
            catch (Exception e)
            {
                return e.Message;
            }
            return FormatReturn(BanSystem.SQLite, GetMsg("BanAdded"), bandata.ToString());
        }

        string SQLite_ExecuteBan(object source, BanData bandata)
        {
            var sqlString = bandata.steamid == string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 ", bandata.ip) : Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0 AND `ip` == @1 ", bandata.steamid, bandata.ip);

            Sqlite.Query(sqlString, Sqlite_conn, list =>
            {
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        var response = FormatReturn(BanSystem.SQLite, GetMsg("BanExists"), bd.ToString());
                        SendReply(source, response);
                        return;
                    }
                }
                var reponse2 = SQLite_RawBan(bandata);
                if (source is IPlayer) ((IPlayer)source).Reply(reponse2);
                else Interface.Oxide.LogInfo(reponse2);
            });

            return string.Empty;
        }

        void SQLite_RawUnban(object source, List<long> unbanList)
        {
            foreach (var id in unbanList)
            {
                Sqlite.Insert(Core.Database.Sql.Builder.Append("DELETE from EnhancedBanSystem WHERE `id` = @0", id), Sqlite_conn);
            }
            var returnstring = FormatReturn(BanSystem.SQLite, GetMsg("BansRemoved"), unbanList.Count.ToString());
            SendReply(source, returnstring);
        }

        string SQLite_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            List<long> unbanList = new List<long>();
            if (ip != string.Empty || steamid != string.Empty)
            {
                var sqlString = ip != string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 ", ip) : Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", steamid);
                Sqlite.Query(sqlString, Sqlite_conn, list =>
                {
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            unbanList.Add((long)entry["id"]);
                        }
                    }
                    SQLite_RawUnban(source, unbanList);
                });
            }
            else
            {
                Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `name` LIKE @0", "%" + name + "%"), Sqlite_conn, list =>
                {
                    List<Dictionary<string, object>> f = new List<Dictionary<string, object>>();
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            f.Add(entry);
                            unbanList.Add((long)entry["id"]);
                        }
                    }
                    if (unbanList.Count > 1)
                    {
                        var ret = FormatReturn(BanSystem.SQLite, GetMsg("MultipleBans"));
                        foreach (var e in f)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", (string)e["steamid"], (string)e["name"], (string)e["reason"]);
                        }
                        if (source is IPlayer) ((IPlayer)source).Reply(ret);
                        else Interface.Oxide.LogInfo(ret);
                        return;
                    }
                    SQLite_RawUnban(source, unbanList);
                });
            }
            return string.Empty;
        }

        void SQLite_UpdateBan(BanData bandata)
        {
            Sqlite.Insert(Core.Database.Sql.Builder.Append("UPDATE EnhancedBanSystem SET `steamid`= @1, `name`= @2, `ip`= @3,`reason`= @4,`source`=@5, `game`= @6, `platform`= @7,`server`= @8, `expire`= @9 WHERE `id` = @0", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
        }

        void SQLite_IsBanned(BanData bandata, bool update)
        {
            bandata.reason = BanEvadeReason;

            double cTime = LogTime();
            List<long> unbanList = new List<long>();
            Dictionary<string, object> match = new Dictionary<string, object>();

            Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", bandata.steamid), Sqlite_conn, list =>
            {

                var l = new List<Dictionary<string, object>>();
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var expire = (long)entry["expire"];
                        if (expire != 0.0 && cTime >= expire)
                        {
                            unbanList.Add((long)entry["id"]);
                        }
                        else
                        {
                            if ((string)entry["ip"] == bandata.ip)
                            {
                                match = entry;
                            }
                            l.Add(entry);
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    SQLite_RawUnban("Auto Ban", unbanList);
                    unbanList.Clear();
                }
                var l2 = l.Where(x => (long)x["expire"] == 0L).ToList();
                if (l2.Count == 0)
                {
                    string range1;
                    string range2;
                    string range3;
                    if (RangeFromIP(bandata.ip, out range1, out range2, out range3))
                    {
                        Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 OR `ip` == @1 OR `ip` == @2 OR `ip` == @3", bandata.ip, range1, range2, range3), Sqlite_conn, list2 =>
                        {
                            if (list2 != null)
                            {
                                foreach (var entry in list2)
                                {
                                    var expire = (long)entry["expire"];
                                    if (expire != 0.0 && cTime >= expire)
                                    {
                                        unbanList.Add((long)entry["id"]);
                                    }
                                    else
                                    {
                                        if (!l.Contains(entry))
                                            l.Add(entry);
                                    }
                                }
                            }
                            if (l.Count > 0)
                            {
                                l2 = l.Where(x => (long)x["expire"] == 0L).ToList();
                                bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (long)(match["expire"]) : (long)(l[0]["expire"]);
                                if (match.ContainsKey("expire"))
                                {
                                    if ((long)(match["expire"]) != bandata.expire)
                                    {
                                        var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                                        bd.expire = bandata.expire;
                                        SQLite_UpdateBan(bd);
                                    }
                                }
                                else if (update) ExecuteBan("Auto Ban", bandata, false);
                                timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                            }
                        });
                    }
                }
                if (l.Count > 0)
                {
                    bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (long)(match["expire"]) : (long)(l[0]["expire"]);
                    if (match.ContainsKey("expire"))
                    {
                        if ((long)(match["expire"]) != bandata.expire)
                        {
                            var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                            SQLite_UpdateBan(bd);
                        }
                    }
                    else if (update) ExecuteBan("Auto Ban", bandata, false);
                    timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                }
            });
        }

        string SQLite_Banlist(object source, int startid)
        {
            Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem ORDER BY id DESC"), Sqlite_conn, list =>
            {
                int i = -1;
                int max = startid + 9;
                string replystring = string.Empty;
                if (list != null)
                {
                    replystring += FormatReturn(BanSystem.SQLite, GetMsg("Banlist"), startid.ToString(), max.ToString(), list.Count.ToString());
                    foreach (var entry in list)
                    {
                        i++;
                        if (i < startid) continue;
                        if (i > max) break;
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        replystring += bd.ToString() + "\n";
                    }
                    SendReply(source, replystring);
                }
            });
            return string.Empty;
        }

        ////////////////////////////////////////////////////////////
        // MySQL
        ////////////////////////////////////////////////////////////

        Oxide.Core.MySql.Libraries.MySql Sql = Interface.Oxide.GetLibrary<Oxide.Core.MySql.Libraries.MySql>();
        Connection Sql_conn;

        string MySQL_Load()
        {
            try
            {
                Sql_conn = Sql.OpenDb(MySQL_Host, MySQL_Port, MySQL_DB, MySQL_User, MySQL_Pass, this);
                if (Sql_conn == null || Sql_conn.Con == null)
                {
                    return FormatReturn(BanSystem.MySQL, "Couldn't open the MySQL PlayerDatabase: {0} ", Sql_conn.Con.State.ToString());
                }
                else
                {
                    Sql.Insert(Core.Database.Sql.Builder.Append("CREATE TABLE IF NOT EXISTS enhancedbansystem ( `id` int(11) NOT NULL, `steamid` VARCHAR(17),`name` VARCHAR(25),`ip` VARCHAR(15),`reason` VARCHAR(25),`source` VARCHAR(25), `game` VARCHAR(25) , `platform` VARCHAR(25), `server` VARCHAR(25), `expire` int(11) );"), Sql_conn);
                    return FormatReturn(BanSystem.MySQL, GetMsg("Loaded"));
                }
            }
            catch (Exception e)
            {
                return FormatReturn(BanSystem.MySQL, e.Message);
            }
        }

        string MySQL_RawBan(BanData bandata)
        {
            try
            {
                Sql.Insert(Core.Database.Sql.Builder.Append("INSERT IGNORE INTO enhancedbansystem ( `id`, `steamid`,`name`,`ip`,`reason`,`source`,`game`,`platform`, `server`, `expire` ) VALUES ( @0, @1, @2, @3, @4, @5, @6, @7, @8, @9 )", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sql_conn);
            }
            catch (Exception e)
            {
                return e.Message;
            }
            return FormatReturn(BanSystem.MySQL, GetMsg("BanAdded"), bandata.ToString());
        }

        void MySQL_UpdateBan(BanData bandata)
        {
            Sql.Insert(Core.Database.Sql.Builder.Append("UPDATE EnhancedBanSystem SET `steamid`= @1, `name`= @2, `ip`= @3,`reason`= @4,`source`=@5, `game`= @6, `platform`= @7,`server`= @8, `expire`= @9 WHERE `id` = @0", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
        }

        void MySQL_RawUnban(object source, List<int> unbanList)
        {
            foreach (var id in unbanList)
            {
                Sql.Insert(Core.Database.Sql.Builder.Append("DELETE from enhancedbansystem WHERE `id` = @0", id), Sql_conn);
                if (BanSystemHasFlag(banSystem, BanSystem.Native))
                {
                    Native_ExecuteUnban(id.ToString(), null);
                }
            }
            SendReply(source, FormatReturn(BanSystem.MySQL, GetMsg("BansRemoved"), unbanList.Count.ToString()));
        }
        string MySQL_ExecuteBan(object source, BanData bandata)
        {
            var sqlString = bandata.steamid == string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 ", bandata.ip) : Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0 AND `ip` = @1 ", bandata.steamid, bandata.ip);
            Sql.Query(sqlString, Sql_conn, list =>
            {
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        var response = FormatReturn(BanSystem.MySQL, GetMsg("BanExists"), bd.ToString());
                        SendReply(source, response);
                        return;
                    }
                }
                SendReply(source, MySQL_RawBan(bandata));
            });
            return string.Empty;
        }

        string MySQL_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            List<int> unbanList = new List<int>();
            if (ip != string.Empty || steamid != string.Empty)
            {
                var sqlString = ip != string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 ", ip) : Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", steamid);
                Sql.Query(sqlString, Sql_conn, list =>
                {
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            unbanList.Add((int)entry["id"]);
                        }
                    }
                    MySQL_RawUnban(source, unbanList);
                });
            }
            else
            {
                Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `name` LIKE @0", "%" + name + "%"), Sql_conn, list =>
                {
                    List<Dictionary<string, object>> f = new List<Dictionary<string, object>>();
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            f.Add(entry);
                            unbanList.Add((int)entry["id"]);
                        }
                    }
                    if (unbanList.Count > 1)
                    {
                        string ret = FormatReturn(BanSystem.MySQL, GetMsg("MultipleBans"));
                        foreach (var e in f)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", (string)e["steamid"], (string)e["name"], (string)e["reason"]);
                        }
                        if (source is IPlayer) ((IPlayer)source).Reply(ret);
                        else Interface.Oxide.LogInfo(ret);
                        return;
                    }
                    else
                    {
                        MySQL_RawUnban(source, unbanList);
                    }
                });
            }
            return string.Empty;
        }

        void MySQL_IsBanned(BanData bandata, bool update)
        {
            bandata.reason = BanEvadeReason;

            List<int> unbanList = new List<int>();
            double cTime = LogTime();
            Dictionary<string, object> match = new Dictionary<string, object>();

            Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", bandata.steamid), Sql_conn, list =>
            {
                var l = new List<Dictionary<string, object>>();
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var expire = (int)entry["expire"];
                        if (expire != 0 && cTime >= expire)
                        {
                            unbanList.Add((int)entry["id"]);
                        }
                        else
                        {
                            if ((string)entry["ip"] == bandata.ip)
                            {
                                match = entry;
                            }
                            l.Add(entry);
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    MySQL_RawUnban("Auto Ban", unbanList);
                    unbanList.Clear();
                }
                var l2 = l.Where(x => (int)x["expire"] == 0).ToList();
                if (l2.Count == 0)
                {
                    string range1;
                    string range2;
                    string range3;
                    if (RangeFromIP(bandata.ip, out range1, out range2, out range3))
                    {
                        Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 OR `ip` = @1 OR `ip` = @2 OR `ip` = @3", bandata.ip, range1, range2, range3), Sql_conn, list2 =>
                        {
                            if (list2 != null)
                            {
                                foreach (var entry in list2)
                                {
                                    var expire = (int)entry["expire"];
                                    if (expire != 0 && cTime >= double.Parse(expire.ToString()))
                                    {
                                        unbanList.Add((int)entry["id"]);
                                    }
                                    else
                                    {
                                        if (!l.Contains(entry))
                                            l.Add(entry);
                                    }
                                }
                            }
                            if (l.Count > 0)
                            {
                                bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (int)(match["expire"]) : (int)(l[0]["expire"]);
                                if (match.ContainsKey("expire"))
                                {
                                    if (double.Parse(match["expire"].ToString()) != bandata.expire)
                                    {
                                        var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                                        MySQL_UpdateBan(bd);
                                    }
                                }
                                else if (update) ExecuteBan("Auto Ban", bandata, false);
                                timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"]));
                            }
                        });
                    }
                }
                if (l.Count > 0)
                {
                    bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? double.Parse(match["expire"].ToString()) : double.Parse(l[0]["expire"].ToString());
                    if (match.ContainsKey("expire"))
                    {
                        if (double.Parse(match["expire"].ToString()) != bandata.expire)
                        {
                            var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                            MySQL_UpdateBan(bd);
                        }
                    }
                    else if (update) ExecuteBan("Auto Ban", bandata, false);
                    timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                }
            });
        }

        string MySQL_Banlist(object source, int startid)
        {
            Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem ORDER BY id DESC"), Sql_conn, list =>
            {
                int i = -1;
                int max = startid + 9;
                string replystring = string.Empty;
                if (list != null)
                {
                    replystring += FormatReturn(BanSystem.MySQL, GetMsg("Banlist"), startid.ToString(), max.ToString(), list.Count.ToString());
                    foreach (var entry in list)
                    {
                        i++;
                        if (i < startid) continue;
                        if (i > max) break;
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        replystring += bd.ToString() + "\n";

                    }
                    SendReply(source, replystring);
                }
            });
            return string.Empty;
        }

        ////////////////////////////////////////////////////////////
        // Native
        ////////////////////////////////////////////////////////////

        string Native_Load()
        {
            return FormatReturn(BanSystem.Native, GetMsg("Loaded"));
        }
        string Native_ExecuteBan(BanData bandata)
        {
            if (bandata.steamid.Length == 0) return FormatReturn(BanSystem.Native, "Can't ban by IP.");

            var player = players.FindPlayer(bandata.steamid);
            if (player == null) return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
            if (player.IsBanned) return FormatReturn(BanSystem.Native, GetMsg("BanExists"), bandata.steamid.ToString());

            TimeSpan duration = bandata.expire == 0.0 ? default(TimeSpan) : TimeSpan.FromSeconds(bandata.expire);
            player.Ban(bandata.reason, duration);
#if RUST
            if (bandata.expire != 0.0)
            {
              return FormatReturn(BanSystem.Native, GetMsg("BanAdded"), bandata.steamid.ToString()) + "\nWARNING: NATIVE temporary bans are not supported in RUST! Temporary bans will stay permanent";
            }
#endif
            return FormatReturn(BanSystem.Native, GetMsg("BanAdded"), bandata.steamid.ToString());
        }

        string Native_ExecuteUnban(string steamid, string name)
        {
            if (steamid == string.Empty)
            {
                if (name == string.Empty) return string.Empty;
                var f = players.FindPlayers(name).Where(x => x.IsBanned).ToList();
                if (f.Count == 0)
                {
                    return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
                }
                if (f.Count > 1)
                {
                    var ret = string.Empty;
                    foreach (var p in f)
                    {
                        ret += string.Format("{0} - {1}\n", p.Id, p.Name);
                    }
                    return ret;
                }
                steamid = f[0].Id;
            }
            var b = players.FindPlayer(steamid);
            if (b == null)
            {
                return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
            }
            if (!b.IsBanned)
            {
                return FormatReturn(BanSystem.Native, GetMsg("PlayerNotBanned"), b.Id, b.Name);
            }
            b.Unban();
            return FormatReturn(BanSystem.Native, "1 matching bans were removed");
        }

        bool Native_IsBanned(string steamid)
        {
            var b = players.FindPlayer(steamid);
            if (b != null)
            {
                return b.IsBanned;
            }
            return false;
        }

        string Native_Banlist(object source, int startid)
        {
            int i = -1;
            int max = startid + 9;

            var banlist = players.All.Where(x => x.IsBanned).ToList();

            string returnstring = FormatReturn(BanSystem.Native, GetMsg("Banlist"), startid.ToString(), max.ToString(), banlist.Count.ToString());

            foreach (IPlayer b in banlist)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += string.Format("{0} - {1} - {2}", b.Id, b.Name, ToShortString(b.BanTimeRemaining));
            }

            return returnstring;
        }


        ////////////////////////////////////////////////////////////
        // Kick
        ////////////////////////////////////////////////////////////

        string Kick(object source, string target, string reason, bool shouldBroadcast = true)
        {
            string r = string.Empty;
            var foundplayers = FindConnectedPlayers(target, source, out r);
            if (r != string.Empty)
            {
                return r;
            }

            var returnkick = string.Empty;
            foreach (var iplayer in foundplayers)
            {
                returnkick += ExecuteKick(source, iplayer, reason, shouldBroadcast) + "\r\n";
            }

            return returnkick;
        }
        string TryKick(object source, string[] args)
        {
            string target = args[0];
            string reason = args.Length > 1 ? args[1] : "Kicked";
            return Kick(source, target, reason);
        }

        string ExecuteKick(object source, IPlayer player, string reason, bool shouldBroadcast = true)
        {
            if (shouldBroadcast && Kick_Broadcast)
            {
                server.Broadcast(GetMsg("PlayerKick", null, player.Name.ToString(), reason));
                if (Discord_use)
                {
                    object payload = new[]
                    {
                        new{name="Player", value=$"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})", inline=true},
                        new{name="Kicked By", value=source is IPlayer ? ((IPlayer)source).Name : source.ToString(),inline=true },
                        new{name="Reason", value=reason, inline=false}
                    };
                    string json = JsonConvert.SerializeObject(payload);
                    DiscordMessages.Call("API_SendFancyMessage", Discord_Webhook, "Player Kick", 3329330, json);
                }
            }

            if (Kick_Log)
                Interface.Oxide.LogWarning(GetMsg("{0} was kicked from the server ({1})", null, player.Name.ToString(), reason));

            player.Kick(reason);


            return GetMsg("{0} was kicked from the server ({1})", source, player.Name.ToString(), reason);
        }


        ////////////////////////////////////////////////////////////
        // IsBanned
        ////////////////////////////////////////////////////////////
        bool isBanned_Check(string name, string steamid, string ip)
        {
            int count = 0;
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                count++;
                var files = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
                if (files.Count > 0)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                count++;
                var playerdatabase = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
                if (playerdatabase is string && playerdatabase != null)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                count++;
                bool foundMySQL = false;
                Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", steamid), Sql_conn, list =>
                {
                    if (list != null)
                    {
                        foundMySQL = true;
                    }
                });
                if (foundMySQL)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                count++;
                bool sqlite = false;
                Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", steamid), Sqlite_conn, list =>
                {
                    if (list != null)
                    {
                        sqlite = true;
                    }
                });
                if (sqlite)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                count++;
                bool banned = false;
                webrequest.Enqueue(FormatOnlineBansystem(WebAPI_IsBanned_Request, new Dictionary<string, string> { { "{id}", null }, { "{steamid}", steamid }, { "{name}", name }, { "{ip}", ip }, { "{source}", "Auto Ban" }, { "{update}", false.ToString() }, { "{time}", LogTime().ToString() } }), null, (code, response) =>
                {
                    if (response != null || code != 200)
                    {
                        if (response == "true")
                        {
                            banned = true;
                        }
                    }
                    else
                    {
                        Interface.Oxide.LogWarning("WebAPI couldn't be contacted or is not valid");
                    }
                }, this);
                if (banned == true)
                {
                    return banned;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native) && count > 0)
            {
                return false;
            }
            else if (BanSystemHasFlag(banSystem, BanSystem.Native) && count == 0)
            {
                var player = players.FindPlayer(steamid);
                return player != null && player.IsBanned;
            }
            return false;
        }
        bool isBanned_NonDelayed(string name, string steamid, string ip, bool update, out BanData bandata)
        {
            bool denied = false;
            bandata = null;
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                if (Native_IsBanned(steamid))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("Native: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                if (PlayerDatabase_IsBanned(steamid, ip, out bandata))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("PlayerDatabase: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                if (Files_IsBanned(steamid, ip, out bandata))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("Files: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (update && denied)
            {
                if (bandata != null && (bandata.ip != ip || bandata.steamid != steamid))
                    PrepareBan("Auto Ban", steamid, name, ip, BanEvadeReason, bandata.expire == 0.0 ? 0.0 : bandata.expire - LogTime(), false);
                else if (bandata == null)
                    PrepareBan("Auto Ban", steamid, name, ip, BanEvadeReason, 0.0, false);
            }
            return bandata != null;
        }

        void isBanned_Delayed(string name, string steamid, string ip, bool update)
        {
            var partialBan = new BanData("Auto Ban", steamid, name, ip, string.Empty, 0.0);
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                SQLite_IsBanned(partialBan, update);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                MySQL_IsBanned(partialBan, update);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                WebAPI_IsBanned(partialBan, update);
            }
        }

        ////////////////////////////////////////////////////////////
        // Banlist
        ////////////////////////////////////////////////////////////

        string TryBanlist(object source, string[] args)
        {
            int startID = 0;
            BanSystem bs;
            if (args != null && args.Length > 1)
            {
                int.TryParse(args[1], out startID);
            }
            switch (args[0].ToLower())
            {
                case "files":
                    bs = BanSystem.Files;
                    break;
                case "mysql":
                    bs = BanSystem.MySQL;
                    break;
                case "native":
                    bs = BanSystem.Native;
                    break;
                case "playerdatabase":
                    bs = BanSystem.PlayerDatabase;
                    break;
                case "sqlite":
                    bs = BanSystem.SQLite;
                    break;
                case "webapi":
                    bs = BanSystem.WebAPI;
                    break;
                default:
                    return GetMsg("BanlistSyntax1", source);
            }

            return Banlist(source, bs, startID);
        }

        string Banlist(object source, BanSystem bs, int startID)
        {
            switch (bs)
            {
                case BanSystem.Files:
                    return Files_Banlist(source, startID);
                case BanSystem.MySQL:
                    return MySQL_Banlist(source, startID);
                case BanSystem.Native:
                    return Native_Banlist(source, startID);
                case BanSystem.PlayerDatabase:
                    return PlayerDatabase_Banlist(source, startID);
                case BanSystem.SQLite:
                    return SQLite_Banlist(source, startID);
                case BanSystem.WebAPI:
                    return WebAPI_Banlist(source, startID);
                default:
                    return string.Empty;
            }
        }

        ////////////////////////////////////////////////////////////
        // Ban
        ////////////////////////////////////////////////////////////


        string TryBan(object source, string[] args)
        {
            string ipaddress = isIPAddress(args[0]) ? args[0] : string.Empty;
            string steamid = string.Empty;
            string name = string.Empty;
            string errorreason = string.Empty;
            ulong userID;
            double duration = 0.0;
            string reason = BanDefaultReason;
            TimeSpan duration1;
            if (args.Length > 2 && TryParseTimeSpan(args[1], out duration1))
            {
                duration = duration1.TotalSeconds;
                reason = string.Join(" ", args.Skip(2).ToArray());
            }
            else if (args.Length > 1)
            {
                reason = string.Join(" ", args.Skip(1).ToArray());
            }
            if (ipaddress.Length != 0)
            {
                return BanIP(source, ipaddress, reason, duration);
            }
            else
            {
                var foundplayers = FindPlayers(args[0], source, out errorreason);
                if (errorreason != string.Empty | errorreason.Length != 0)
                {
                    if (ulong.TryParse(args[0], out userID) && userID.IsSteamId())
                    {
                        return BanID(source, args[0], reason, duration);
                    }
                    return errorreason;
                }
                return BanPlayer(source, foundplayers[0], reason, duration);
            }
        }

        string BanIP(object source, string ip, string reason, double duration)
        {
            return PrepareBan(source, string.Empty, string.Empty, ip, reason, duration, Kick_OnBan);
        }

        string BanID(object source, string steamid, string reason, double duration)
        {
            string name = GetPlayerName(steamid);
            string ipaddress = GetPlayerIP(steamid);

            return PrepareBan(source, steamid, name, ipaddress, reason, duration, Kick_OnBan);
        }

        string BanPlayer(object source, IPlayer player, string reason, double duration)
        {
            var address = GetPlayerIP(player);

            return PrepareBan(source, player.Id, player.Name, address, reason, duration, Kick_OnBan);
        }

        string PrepareBan(object source, string userID, string name, string ip, string reason, double duration, bool kick)
        {
            var bandata = new BanData(source, userID, name, ip, reason, duration);


            return ExecuteBan(source, bandata, kick);
        }
        string ExecuteBan(object source, BanData bandata, bool kick)
        {
            Unsubscribe(nameof(OnUserBanned));
            if (wasBanned.Contains(bandata.id)) return string.Empty;

            string returnstring = null;
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                returnstring += PlayerDatabase_ExecuteBan(bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnstring += Files_ExecuteBan(bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnstring += MySQL_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnstring += SQLite_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnstring += WebAPI_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnstring += Native_ExecuteBan(bandata);
            }

            if (Ban_Broadcast)
                if (bandata.name != string.Empty | bandata.steamid != string.Empty)
                    server.Broadcast(bandata.expire == 0.0 ? GetMsg("PlayerPermBan", null, bandata.name, bandata.reason) : GetMsg("PlayerTempBan", null, bandata.name, FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime())), bandata.reason));
                else if (bandata.ip != string.Empty)
                    server.Broadcast(bandata.expire == 0.0 ? GetMsg("IPPermBan", null, bandata.reason) : GetMsg("IPTempBan", null, FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime())), bandata.reason));

            if (Ban_Log && (source is IPlayer) && ((IPlayer)source).Id != "server_console")
                Interface.Oxide.LogWarning(returnstring);

            if (kick)
                Kick(source, bandata.steamid != string.Empty ? bandata.steamid : bandata.ip, bandata.reason ?? "Banned", true);

            wasBanned.Add(bandata.id);
            if (Discord_use)
            {
                object payload = new[]
                {
                    new {name="Player",value=bandata.name.Length != 0 ? $"[{bandata.name}](https://steamcommunity.com/profiles/{bandata.steamid})" : bandata.steamid.Length != 0 ? $"[{bandata.steamid}](https://steamcommunity.com/profiles/{bandata.steamid})" : "An IP", inline=true},
                    new {name="Type",value=bandata.expire != 0.0 ? $"Temporarily ({FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime()))})" : "Permanently", inline=true},
                    new {name="Banned By", value=bandata.source, inline=true },
                    new {name="Reason",value=bandata.reason, inline=false}
                };
                string json = JsonConvert.SerializeObject(payload);
                DiscordMessages?.Call("API_SendFancyMessage", Discord_Webhook, "Player Ban", 3329330, json);
            }
            timer.Once(5f, () => { Subscribe(nameof(OnUserBanned)); });
            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // Unban
        ////////////////////////////////////////////////////////////

        string ExecuteUnban(object source, string steamid, string name, string ip)
        {
            string returnstring = string.Empty;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> unbanList2 = new List<BanData>();

            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                returnstring += PlayerDatabase_ExecuteUnban(steamid, name, ip, out unbanList);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnstring += Files_ExecuteUnban(steamid, name, ip, out unbanList2);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnstring += MySQL_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnstring += SQLite_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnstring += WebAPI_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnstring += Native_ExecuteUnban(steamid, name);
            }

            foreach (var b in unbanList)
            {
                if (cachedBans.ContainsKey(b.id))
                    cachedBans.Remove(b.id);
            }
            foreach (var b in unbanList2)
            {
                if (cachedBans.ContainsKey(b.id))
                    cachedBans.Remove(b.id);
            }
            OnServerSave();
            return returnstring;
        }

        string TryUnBan(object source, string[] args)
        {
            string ipaddress = isIPAddress(args[0]) ? args[0] : string.Empty;
            string steamid = string.Empty;
            ulong userID = 0L;
            string name = string.Empty;
            string errorreason = string.Empty;

            if (ipaddress != string.Empty)
            {
                return ExecuteUnban(source, string.Empty, string.Empty, ipaddress);
            }
            else
            {
                ulong.TryParse(args[0], out userID);
                return ExecuteUnban(source, userID != 0L ? args[0] : string.Empty, userID == 0L ? args[0] : string.Empty, string.Empty);
            }
        }


        ////////////////////////////////////////////////////////////
        // Commands
        ////////////////////////////////////////////////////////////
        [Command("ban", "player.ban")]
        void cmdBan(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionBan))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("BanSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryBan(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
                Puts(e.StackTrace);
            }
        }

        [Command("banlist", "player.banlist")]
        void cmdBanlist(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionBanlist))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || args.Length == 0)
            {
                string replystring = GetMsg("BanlistSyntax", player.Id.ToString()) + "\n";
                replystring += GetMsg("BanSystems", player.Id.ToString());
                if (BanSystemHasFlag(banSystem, BanSystem.Files))
                {
                    replystring += "Files\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
                {
                    replystring += "MySQL\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.Native))
                {
                    replystring += "Native\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
                {
                    replystring += "PlayerDatabase\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
                {
                    replystring += "SQLite\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
                {
                    replystring += "WebAPI\n";
                }
                player.Reply(replystring);
                return;
            }
            try
            {
                player.Reply(TryBanlist(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }

        [Command("kick", "player.kick")]
        void cmdKick(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionKick))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("KickSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryKick(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }

        [Command("unban", "player.unban")]
        void cmdUnban(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionUnban))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("UnbanSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryUnBan(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }
    }
}

// --- End of file: EnhancedBanSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/CaptureZone.cs ---
// --- Original Local Path: BeeRust/CaptureZone.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Rust;

namespace Oxide.Plugins
{
    [Info("CaptureZone", "King", "1.0.0")]
    public class CaptureZone : RustPlugin
    {
        #region [Vars]
        [PluginReference] private Plugin ImageLibrary = null, Clans = null, MenuAlerts = null;
        private string[] _gatherHooks = {
            "OnDispenserGather",
            "OnDispenserBonus",
        };
        private static CaptureZone plugin;
        private Dictionary<String, DateTime> CooldownNotifyFarm = new Dictionary<String, DateTime>();
        private List<ulong> _CaptureCupboard = new List<ulong>();
        private List<ulong> _CaptureDropBox = new List<ulong>();
        private List<ulong> openUI = new List<ulong>();
        private Dictionary<string, int> _itemIds = new Dictionary<string, int>();
        #endregion

        #region [Data]
        public List<CaptureData> _CaptureList = new List<CaptureData>();
        public class CaptureData
        {
            public string captureName;

            public string nameClan;

            public int lastCapture;

            public ulong Cupboard;

            public ulong ResourseChest;

            public Vector3 capturePosition;
        }

		private void SaveCapture()
		{
			Interface.Oxide.DataFileSystem.WriteObject($"{Name}/CaptureList", _CaptureList);
		}

		private void LoadCapture()
		{
			try
			{
				_CaptureList = Interface.Oxide.DataFileSystem.ReadObject<List<CaptureData>>($"{Name}/CaptureList");
			}
			catch (Exception e)
			{
				PrintError(e.ToString());
			}

			if (_CaptureList == null) _CaptureList = new List<CaptureData>();
		}
        #endregion

        #region [Oxide]
        private void OnPluginLoaded(Plugin plugin)
        {
            NextTick(() =>
            {
                foreach (string hook in _gatherHooks)
                {
                    Unsubscribe(hook);
                    Subscribe(hook);
                }
            });
        }

		private void Init()
		{
			plugin = this;

			LoadCapture();
		}

        private void OnServerInitialized()
        {
            GetCaptureZone();

            cmd.AddChatCommand("capture", this, "ChatCommandCaptureZoneUI");
            cmd.AddChatCommand("newcapture", this, "NewSpawnCaptureZone");
            cmd.AddChatCommand("removecapture", this, "DeleteCaptureZone");
            ImageLibrary?.Call("AddImage", "https://i.imgur.com/rMC4ulM.png", "button_capture_zone");
        }

		private void Unload()
		{
			SaveCapture();

            foreach (var key in _CaptureList)
                RemoveCaptureZone(key.capturePosition);

            _CaptureManager.RemoveAll(x =>
            {
                UnityEngine.Object.Destroy(x);
                return true;
            });

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                    CuiHelper.DestroyUi(player, "CaptureUI");

			plugin = null;
		}

		private void OnNewSave(string filename)
		{
			_CaptureList.Clear();
			SaveCapture();
		}
        #endregion

        #region [Rust]
        private void OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if(dispenser == null || player == null) return;

            var clan = GetClanTag(player.userID);
            if (string.IsNullOrEmpty(clan)) return;

            CaptureManager ActiveCaptureZone = FindCaptureZoneDistance(player.transform.position);
            if (ActiveCaptureZone == null || string.IsNullOrEmpty(ActiveCaptureZone._data.nameClan)) return;

            var memberList = GetClanMembers(ActiveCaptureZone._data.nameClan);
            if (memberList == null || memberList == new List<string>()) return;

            var entity = ActiveCaptureZone._entity;
            if (entity == null) return;
            var inventory = entity.GetComponent<StorageContainer>().inventory;
            if (inventory == null) return;

            var amount = Convert.ToInt32(item.amount * (config._ZoneSettings.CapturePrecent / 100f));
            if (amount <= 0) return;

            var itemToCreate = ItemManager.CreateByName(item.info.shortname, amount);
            if (itemToCreate.amount <= 0) return;

            itemToCreate.MoveToContainer(inventory);

			if (CooldownNotifyFarm.ContainsKey(ActiveCaptureZone._data.nameClan))
				if (CooldownNotifyFarm[ActiveCaptureZone._data.nameClan].Subtract(DateTime.Now).TotalSeconds >= 0) return;
            if (inventory.capacity == inventory.itemList.Count)
            {
                foreach (var key in memberList)
                {
                    var id = Convert.ToUInt64(key);
                    var memberClan = BasePlayer.FindByID(id);
                    if (memberClan == null || !memberClan.IsConnected) continue;

                    memberClan.ChatMessage($"  {ActiveCaptureZone._data.captureName} ,  !");
                    CooldownNotifyFarm[ActiveCaptureZone._data.nameClan] = DateTime.Now.AddSeconds(5);
                }
            }
        }

		private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item) =>
			OnDispenserGather(dispenser, player, item);

        private object OnEntityGroundMissing(BaseEntity entity)
        {
            if (entity.OwnerID == 9997)
                return false;

            return null;
        }

		private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
		{
			if(entity.OwnerID == 9997)
				return true;
			
			return null;
		}

        object CanLootEntity(BasePlayer player, DropBox DropBox)
        {
            if (player == null || DropBox == null || !_CaptureDropBox.Contains(DropBox.net.ID.Value)) return null;

            var clanName = GetClanTag(player.userID);
            if (string.IsNullOrEmpty(clanName)) return false;

            CaptureManager ActiveCaptureZone = FindCaptureZoneDropBox(DropBox.net.ID.Value);
            if (ActiveCaptureZone != null)
            {
                if (clanName != ActiveCaptureZone._data.nameClan)
                    return false;
            }
            return null;
        }

        object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            if (privilege == null || player == null || !_CaptureCupboard.Contains(privilege.net.ID.Value)) return null;

            CaptureManager ActiveCaptureZone = FindCaptureZoneCupboard(privilege.net.ID.Value);
            if (ActiveCaptureZone != null)
            {
                var clan = GetClanTag(player.userID);
                if (string.IsNullOrEmpty(clan))
                {
                    player.ChatMessage("   .");
                    return false;
                }

                if (ActiveCaptureZone.CaptureClan == clan)
                {
                    player.ChatMessage("     !");
                    return false;
                }

                var CaptureOtherZone = FindCaptureOtherClan(clan);
                if (CaptureOtherZone != null)
                {
                    player.ChatMessage("     ,   .");
                    return false;
                }

                ActiveCaptureZone.StartCapture(clan, player);
                return false;
            }

            return null;
        }

        private object CanBuild(Planner builder, Construction prefab, Construction.Target target)
        {
            var player = builder.GetOwnerPlayer();
            if (player == null) return null;

            CaptureManager ActiveCaptureZone = FindCaptureZoneDistance(player.transform.position);
            if (ActiveCaptureZone != null)
            {
                if (Vector3.Distance(player.transform.position, ActiveCaptureZone.transform.position) < config._ZoneSettings.RadiusBuild)
                {
                    player.ChatMessage("     !");
                    return false;
                }
            }

            return null;
        }
        #endregion

        #region [Capture]
        private void GetCaptureZone()
        {
            /*if (_CaptureList.Count == 0)
            {
                var MapSize = TerrainMeta.Size / 2;

                Dictionary<Vector3, String> ListPosition = new Dictionary<Vector3, String>()
                {
                    [new Vector3(-MapSize.x, 0, MapSize.z)] = "A", //  
                    [new Vector3(MapSize.x / 9, 0, MapSize.z)] = "B", //  
                    [new Vector3(MapSize.x, 0, MapSize.z)] = "C", //  

                    [new Vector3(-MapSize.x, 0, MapSize.z / 9)] = "D", //  
                    [new Vector3(MapSize.x / 9, 0, MapSize.z / 9)] = "E", //  
                    [new Vector3(MapSize.x, 0, MapSize.z / 9)] = "F", //  

                    [new Vector3(-MapSize.x, 0, -MapSize.z)] = "G", //  
                    [new Vector3(MapSize.x / 9, 0, -MapSize.z)] = "H", //  
                    [new Vector3(MapSize.x, 0, -MapSize.z)] = "L", //  
                };

                foreach (var key in ListPosition)
                {
                    var center = key.Key / 2;
                    Vector3 lastPosition = center;

                    for (int i = 0; i < 300; i++)
                    {
                        lastPosition = RandomCircle(lastPosition);
                        if (ValidPosition(ref lastPosition))
                        {
                            GetNewData(lastPosition, key.Value);
                            break;
                        }
                    }
                }
            }
            else
            {*/
                foreach (var key in _CaptureList)
                {
                    SpawnCaptureZone(key.capturePosition);
                }
            //}
        }

        private void GetNewData(Vector3 position, String Name)
        {
            _CaptureList.Add(new CaptureData
            {
                captureName = Name,
                nameClan = string.Empty,
                lastCapture = 0,
                Cupboard = 0,
                ResourseChest = 0,
                capturePosition = position,
            });

            SpawnCaptureZone(position);
        }
        #endregion

        #region [Prefab]
		public class PrefabCaptureZone
		{
			public Vector3 Position;
			public string ShortPrefabName;
			public Vector3 Rotation;

			public PrefabCaptureZone(string shortname, Vector3 pos, Vector3 rot)
			{
				ShortPrefabName = shortname; Position = pos; Rotation = rot;
			}
		}

		public List<PrefabCaptureZone> _PrefabCaptureZone = new List<PrefabCaptureZone>
		{
            // Foundation
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(0, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(0, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(0, 0, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(3, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(3, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(3, 0, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(-3, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(-3, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/foundation/foundation.prefab", new Vector3(-3, 0, -3), new Vector3(0, 0, 0)),

            // CupboardPositionRoom
            new PrefabCaptureZone("assets/prefabs/building core/wall/wall.prefab", new Vector3(1.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall/wall.prefab", new Vector3(0, 0, 1.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall/wall.prefab", new Vector3(0, 0, -1.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(-1.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/door.double.hinged/door.double.hinged.toptier.prefab", new Vector3(-1.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/deployable/tool cupboard/cupboard.tool.deployed.prefab", new Vector3(1.1f, 0.1f, 0), new Vector3(0, 270, 0)),

            // Room
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(-4.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(-4.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(-4.5f, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(-4.5f, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(-4.5f, 0, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(-4.5f, 0, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(4.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(4.5f, 0, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(4.5f, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(4.5f, 0, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(4.5f, 0, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(4.5f, 0, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(0, 0, -4.5f), new Vector3(0, 90, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.garagedoor/wall.frame.garagedoor.prefab", new Vector3(0, 0, -4.5f), new Vector3(0, 90, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(3, 0, -4.5f), new Vector3(0, 90, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(3, 0, -4.5f), new Vector3(0, 90, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(-3, 0, -4.5f), new Vector3(0, 90, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(-3, 0, -4.5f), new Vector3(0, 90, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(0, 0, 4.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.garagedoor/wall.frame.garagedoor.prefab", new Vector3(0, 0, 4.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(3, 0, 4.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(3, 0, 4.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/wall.frame/wall.frame.prefab", new Vector3(-3, 0, 4.5f), new Vector3(0, 270, 0)),
            new PrefabCaptureZone("assets/prefabs/building/wall.frame.cell/wall.frame.cell.prefab", new Vector3(-3, 0, 4.5f), new Vector3(0, 270, 0)),

            //Floor
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(0, 3, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(3, 3, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(3, 3, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(3, 3, -3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(-3, 3, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(-3, 3, 3), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building core/floor/floor.prefab", new Vector3(-3, 3, -3), new Vector3(0, 0, 0)),

            //Rest
            new PrefabCaptureZone("assets/prefabs/deployable/signs/sign.pole.banner.large.prefab", new Vector3(0, 3, 0), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/ladder.wall.wood/ladder.wooden.wall.prefab", new Vector3(-0.7f, 1.5f, 1.6f), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/ladder.wall.wood/ladder.wooden.wall.prefab", new Vector3(0.7f, 1.5f, 1.6f), new Vector3(0, 0, 0)),
            new PrefabCaptureZone("assets/prefabs/building/ladder.wall.wood/ladder.wooden.wall.prefab", new Vector3(-0.7f, 1.5f, -1.6f), new Vector3(0, 180, 0)),
            new PrefabCaptureZone("assets/prefabs/building/ladder.wall.wood/ladder.wooden.wall.prefab", new Vector3(0.7f, 1.5f, -1.6f), new Vector3(0, 180, 0)),
            new PrefabCaptureZone("assets/prefabs/deployable/dropbox/dropbox.deployed.prefab", new Vector3(0.8f, 1.2f, 0), new Vector3(0, 90, 0)),
		};

		private void RemoveCaptureZone(Vector3 position)
		{
			List<BaseEntity> list_entity = new List<BaseEntity>();
			Vis.Entities(position, 25, list_entity);
			
			list_entity = list_entity.Distinct().ToList();
			list_entity = list_entity.Where(x => !(x is BasePlayer) && !(x is PlayerCorpse) && !(x is DroppedItemContainer) && !(x is DroppedItem)).ToList();
			
			foreach(BaseEntity entity in list_entity)
				if(entity != null && !entity.IsDestroyed)
					entity.Kill();
		}

		private void SpawnCaptureZone(Vector3 position)
		{
            RemoveCaptureZone(position);

            var find = _CaptureList.FirstOrDefault(p => p.capturePosition == position);
            if (find == null) return;

			foreach(var key in _PrefabCaptureZone)
			{
				BaseEntity prefab = GameManager.server.CreateEntity(key.ShortPrefabName, position + key.Position, Quaternion.Euler(key.Rotation)) as BaseEntity;
				
				prefab.OwnerID = 9997;
				prefab.Spawn();
				
				if (prefab is BuildingBlock)
				{
					BuildingBlock block = prefab as BuildingBlock;
					
					block.grade = BuildingGrade.Enum.TopTier;
					block.SetHealthToMax();
				}

                if (prefab is BuildingPrivlidge)
                {
                    BuildingPrivlidge build = prefab as BuildingPrivlidge;

                    _CaptureCupboard.Add(build.net.ID.Value);
                    find.Cupboard = build.net.ID.Value;
                }

                if (prefab is DropBox)
                {
                    DropBox dropbox = prefab as DropBox;
                    dropbox.inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);
                    dropbox.inventory.capacity = 40;

                    _CaptureDropBox.Add(dropbox.net.ID.Value);
                    find.ResourseChest = dropbox.net.ID.Value;
                    var obj = new GameObject();
                    obj.transform.position = dropbox.transform.position;
                    var component = obj.AddComponent<CaptureManager>();
                    component.GetComponent<CaptureManager>().Init(find, dropbox);
                    _CaptureManager.Add(component);
                }

                if (prefab is Door)
                {
                    Door door = prefab as Door;

                    door.pickup.enabled = false;
                    door.canTakeLock = false;
                    door.canTakeCloser = false;
                    door.SendNetworkUpdateImmediate();
                }

                if (prefab is BaseLadder)
                {
                    BaseLadder ladder = prefab as BaseLadder;

                    ladder.pickup.enabled = false;
                }
			}
		}
        #endregion

        #region [UI]
        private void ChatCommandCaptureZoneUI(BasePlayer player) => CaptureZoneUI(player, 0);

        private void CaptureZoneUI(BasePlayer player, int page)
        {
            var container = new CuiElementContainer();
            string Layer = "CaptureZone_UI";
            string colored = "0 0 0 0.5";

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-493 -293", OffsetMax = "497.5 293" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Main");

            container.Add(new CuiElement
            {
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiTextComponent { Text = $" ", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.915", AnchorMax = $"1 1" },
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.00325 0.01", AnchorMax = $"0.035 0.067" },
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = page >= 1 ? $"UI_CAPTURE ChangePageCapture {page - 1}" : "" },
                Text = { Text = $"-", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 18, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.0395 0.01", AnchorMax = $"0.07125 0.067" },
                Image = { Color = "0.2 0.2 0.2 0.65", Material = "assets/icons/greyout.mat" }
            }, Layer + ".Main", Layer + ".Main" + ".pText");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                Text = { Text = $"{page + 1}", Color = "1 1 1 0.85", Font = "robotocondensed-regular.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter }
            }, Layer + ".Main" + ".pText");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.07575 0.01", AnchorMax = $"0.1075 0.067" },
                Button = { Color = "0.46 0.44 0.42 0.65", Material = "assets/icons/greyout.mat", Command = _CaptureManager.Skip(9 * (page + 1)).Count() > 0 ? $"UI_CAPTURE ChangePageCapture {page + 1}" : "" },
                Text = { Text = $"+", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 18, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.890915 0.01", AnchorMax = $"0.99379 0.067", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = $"", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.86", AnchorMax = "0.999 0.92" },
                Image = { Color = "1 1 1 0" }
            }, Layer + ".Main", Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $" ", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.025 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $" ", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.23 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $" ", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.42 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $" ", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.85 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            for (int y = 0; y < 9; y++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.0055 {0.775 - y * 0.085}", AnchorMax = $"0.989 {0.85 - y * 0.085}" },
                    Image = { Color = colored }
                }, Layer + ".Main", Layer + ".Main" + $".TopLine{y}");
            }

            int i = 0;
            foreach (var key in _CaptureManager.Skip(page * 9).Take(9))
            {
                string nameClan = key._data.nameClan;
                if (string.IsNullOrEmpty(key._data.nameClan))
                    nameClan = "";
                bool isTime = Facepunch.Math.Epoch.Current - key._data.lastCapture < config._ZoneSettings.CaptureCooldown;
                string State = key._IsCapture == true ? " " : isTime == true ? $"{GetFormatTime(TimeSpan.FromSeconds(key._data.lastCapture + config._ZoneSettings.CaptureCooldown - Facepunch.Math.Epoch.Current))}" : " ";

                container.Add(new CuiLabel
                {
                    Text = { Text = $"{key._data.captureName}", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.027 0", AnchorMax = $"1 1" },
                }, Layer + ".Main" + $".TopLine{i}");

                container.Add(new CuiLabel
                {
                    Text = { Text = $"{nameClan}", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.234 0", AnchorMax = $"1 1" },
                }, Layer + ".Main" + $".TopLine{i}");

                container.Add(new CuiLabel
                {
                    Text = { Text = $"{State}", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.424 0", AnchorMax = $"1 1" },
                }, Layer + ".Main" + $".TopLine{i}");

                container.Add(new CuiLabel
                {
                    Text = { Text = $"", Color = "1 1 1 1", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.85 0", AnchorMax = $"0.985 0.98" },
                }, Layer + ".Main" + $".TopLine{i}");

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"UI_CAPTURE OpenInventory {key._data.ResourseChest}" },
                    RectTransform = { AnchorMin = $"0.85 0", AnchorMax = $"0.985 0.98" },
                }, Layer + ".Main" + $".TopLine{i}");

                i++;
            }

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }

        private void CaptureZoneUI_Inventory(BasePlayer player, StorageContainer containers, CaptureManager Capture)
        {
            var container = new CuiElementContainer();
            var Items = containers.inventory.itemList.Count;
            string Layer = "CaptureZone_UI";
            string colored = "0 0 0 0.5";

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-493 -293", OffsetMax = "497.5 293" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Main");

            container.Add(new CuiElement
            {
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiTextComponent { Text = $"   {Capture._data.captureName}", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.915", AnchorMax = $"1 1" },
                }
            });

            if (Items == 0)
            {
                container.Add(new CuiElement
                {
                    Parent = Layer + ".Main",
                    Components =
                    {
                        new CuiTextComponent { Text = $"    :(", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 32, Font = "robotocondensed-bold.ttf" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = $"1 1" },
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.890915 0.01", AnchorMax = $"0.99379 0.067", OffsetMax = "0 0" },
                    Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                    Text = { Text = $"", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, Layer + ".Main");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.77804 0.01", AnchorMax = $"0.880915 0.067", OffsetMax = "0 0" },
                    Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = "UI_CAPTURE ReturnToMenu" },
                    Text = { Text = $"", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, Layer + ".Main");

                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.AddUi(player, container);
                return;
            }

            for (int i = 0, y = 0, x = 0; i < 40; i++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.01 + (x * 0.123)} {0.76 - (y * 0.17)}", AnchorMax = $"{0.117 + (x * 0.123)} {0.92 - (y * 0.17)}" },
                    Image = { Color = colored }
                }, Layer + ".Main", Layer + ".Main" + $"Item{i}");

                if (Items - 1 >= i)
                {
                    var Item = containers.inventory.itemList.ElementAt(i);
                    
                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Main" + $"Item{i}",
                        Components =
                        {
                            new CuiImageComponent { ItemId = FindItemID(Item.info.shortname), SkinId = 0 },
                            new CuiRectTransformComponent { AnchorMin = "0.1 0.1", AnchorMax = "0.9 0.9" }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0 ", AnchorMax = "1 1", OffsetMax = "-5 0", OffsetMin = "5 2" },
                        Button = { Color = "0 0 0 0", Command = $"UI_CAPTURE TakeItemInventory {Capture._data.ResourseChest} {Item.info.shortname}" },
                        Text = { Text = $"{Item.amount}" + "", Align = TextAnchor.LowerCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                    }, Layer + ".Main" + $"Item{i}");
                }

                x++;
                if (x == 8)
                {
                    x = 0;
                    y++;
                }
            }

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.77804 0.01", AnchorMax = $"0.880915 0.067", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = "UI_CAPTURE ReturnToMenu" },
                Text = { Text = $"", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.890915 0.01", AnchorMax = $"0.99379 0.067", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = $"", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region [ConsoleCommand]
        [ConsoleCommand("UI_CAPTURE")]
        private void CaptureUIHandler(ConsoleSystem.Arg args)
        {
			BasePlayer player = args?.Player();
			if (player == null || !args.HasArgs()) return;

            var clan = GetClanTag(player.userID);
            if (clan == null) return;

            switch (args.Args[0])
            {
                case "OpenInventory":
                {
                    var find = FindCaptureZoneDropBox(ulong.Parse(args.Args[1]));
                    if (find == null) return;

                    if (string.IsNullOrEmpty(clan))
                    {
                        player.ChatMessage("   .");
                        return;
                    }

                    if (find._data.nameClan != clan)
                    {
                        player.ChatMessage("      .");
                        return;
                    }

                    StorageContainer container;
                    container = find._entity.GetComponent<StorageContainer>();
                    container.inventory.MarkDirty();
                    container.UpdateNetworkGroup();
                    CaptureZoneUI_Inventory(player, container, find);
                    break;
                }
                case "TakeItemInventory":
                {
                    var find = FindCaptureZoneDropBox(ulong.Parse(args.Args[1]));
                    if (find == null || find._data.nameClan != clan) return;

                    StorageContainer container;
                    container = find._entity.GetComponent<StorageContainer>();

                    var findItem = container.inventory.itemList.FirstOrDefault(p => p.info.shortname == args.Args[2]);
                    if (findItem == null) return;

                    var item = ItemManager.CreateByName(findItem.info.shortname, findItem.amount, findItem.skin);
                    item.name = findItem.name;
                    item.MarkDirty();
                    player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
                    findItem.RemoveFromContainer();
                    CaptureZoneUI_Inventory(player, container, find);
                    break;
                }
                case "ReturnToMenu":
                {
                    CaptureZoneUI(player, 0);
                    break;
                }
                case "ChangePageCapture":
                {
                    CaptureZoneUI(player, int.Parse(args.Args[1]));
                    break;
                }
            }
        }
        #endregion

        #region [Component]
        private CaptureManager FindCaptureZoneDistance(Vector3 pos) =>
             _CaptureManager.Where(p => Vector3.Distance(p.transform.position, pos) < config._ZoneSettings.RadiusZone).FirstOrDefault();

        private CaptureManager FindCaptureZoneCupboard(ulong netID) => 
             _CaptureManager.FirstOrDefault(p => p._data.Cupboard == netID);

        private CaptureManager FindCaptureZoneDropBox(ulong netID) => 
             _CaptureManager.FirstOrDefault(p => p._data.ResourseChest == netID);

        private CaptureManager FindCaptureOtherClan(string nameClan) => 
             _CaptureManager.FirstOrDefault(p => p.CaptureClan == nameClan);

        private static List<CaptureManager> _CaptureManager = new List<CaptureManager>();

        public class CaptureManager : MonoBehaviour
        {
            private List<BasePlayer> _Players;
            private MapMarkerGenericRadius mapMarker;
            private VendingMachineMapMarker vendingMarker;
            private SphereCollider sphereCollider;

            public CaptureData _data;
            public BaseEntity _entity;
            public bool _IsCapture = false;
            public int CaptureTime = 0;
            public string CaptureClan = string.Empty;

            private void Awake()
            {
                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.gameObject.layer = (int)Rust.Layer.Reserved1;
                sphereCollider.isTrigger = true;
                sphereCollider.radius = config._ZoneSettings.RadiusZone;
                InvokeRepeating("Timer", 1f, 1f);
            }

            private void OnTriggerEnter(Collider other)
            {
                var target = other.GetComponentInParent<BasePlayer>();
                if (target == null || _Players.Contains(target)) return;
                var Text = _data.nameClan == string.Empty ? "   ,  " : $"    {_data.captureName}.\n  : {_data.nameClan}";
                target.ChatMessage($"{Text}");
                _Players.Remove(target);
            }

            private void OnTriggerExit(Collider other)
            {
                var target = other.GetComponentInParent<BasePlayer>();
                if (target == null && !_Players.Contains(target)) return;
                var Text = _data.nameClan == string.Empty ? "      ,  " : $"    {_data.captureName}.\n  : {_data.nameClan}";
                target.ChatMessage($"{Text}");
                _Players.Remove(target);
            }

            public void Init(CaptureData data, BaseEntity entity)
            {
                _data = data;
                _entity = entity; 
                _Players = new List<BasePlayer>();

                if (Facepunch.Math.Epoch.Current - _data.lastCapture < config._ZoneSettings.CaptureCooldown)
                    AddMarker(config._MarkerInGameSettings.markerColorCantCapture);
                else
                    AddMarker(config._MarkerInGameSettings.markerColorCanCapture);
            }

            private void Timer()
            {
                if (_IsCapture)
                {
                    bool HavePlayerCapture = false;

                    var _clanList = plugin.GetClanMembers(CaptureClan);
                    if (_clanList == null || _clanList == new List<string>())
                    {
                        CaptureClan = string.Empty;
                        _IsCapture = false;
                        CaptureTime = 0;
                        return;
                    }

                    foreach (var key in _clanList)
                    {
                        var id = Convert.ToUInt64(key);
                        var memberClan = BasePlayer.FindByID(id);
                        if (memberClan == null || !memberClan.IsConnected) continue;

                        if (Vector3.Distance(memberClan.transform.position, transform.position) < config._ZoneSettings.RadiusCapture)
                        {
                            HavePlayerCapture = true;
                            break;
                        }
                    }

                    if (!HavePlayerCapture)
                    {
                        CaptureClan = string.Empty;
                        _IsCapture = false;
                        CaptureTime = 0;

                        foreach (var key in _clanList)
                        {
                            var id = Convert.ToUInt64(key);
                            var memberClan = BasePlayer.FindByID(id);
                            if (memberClan == null || !memberClan.IsConnected) continue;

                            if (config.useMenuAlerts)
                            {
                                plugin.MenuAlerts?.Call("RemoveAlertMenu", memberClan, $"{plugin.Name}");
                            }
                            else
                            {
                                CuiHelper.DestroyUi(memberClan, "CaptureUI");
                                if (plugin.openUI.Contains(memberClan.userID))
                                    plugin.openUI.Remove(memberClan.userID);
                            }
                            memberClan.ChatMessage("    .   ,   !");
                        }
                        
                        AddMarker(config._MarkerInGameSettings.markerColorCanCapture);
                    }

                    CaptureTime++;
                    if (CaptureTime >= config._ZoneSettings.CaputureSecond)
                    {
                        FinishCapture();
                    }
                    else
                    {
                        if (!config.useMenuAlerts)
                        {
                            foreach (var key in _clanList)
                            {
                                var id = Convert.ToUInt64(key);
                                var memberClan = BasePlayer.FindByID(id);
                                if (memberClan == null || !memberClan.IsConnected) continue;

                                if (plugin.openUI.Contains(memberClan.userID))
                                    plugin.CaptureZoneInfoUpdate(memberClan, this);
                            }
                        }
                    }
                }

                if (Facepunch.Math.Epoch.Current - _data.lastCapture == config._ZoneSettings.CaptureCooldown && !_IsCapture)
                {
                    plugin.Server.Broadcast($"<color=#ffde5a>!</color>\n<size=12> <color=#ffde5a>{_data.captureName}</color>   !");
                    mapMarker.color1 = ConvertToColor(config._MarkerInGameSettings.markerColorCanCapture);
                }

                mapMarker.SendUpdate();
            }

            public void StartCapture(String tag, BasePlayer player)
            {
                if (tag == CaptureClan)
                {
                    player.ChatMessage("     !");
                    return;
                }

                if (Facepunch.Math.Epoch.Current - _data.lastCapture < config._ZoneSettings.CaptureCooldown)
                {
                    var time = TimeSpan.FromSeconds(_data.lastCapture + config._ZoneSettings.CaptureCooldown - Facepunch.Math.Epoch.Current);
                    player.ChatMessage($"     .  {time.Hours}, {time.Minutes}, {time.Seconds}.");
                    return;
                }

                if (_IsCapture)
                {
                    var _clanList = plugin.GetClanMembers(CaptureClan);
                    if (_clanList == null || _clanList == new List<string>()) return;

                    foreach (var key in _clanList)
                    {
                        var id = Convert.ToUInt64(key);
                        var memberClan = BasePlayer.FindByID(id);
                        if (memberClan == null || !memberClan.IsConnected) continue;

                        memberClan.ChatMessage($"   : {tag}");
                        if (config.useMenuAlerts)
                        {
                            plugin.MenuAlerts?.Call("RemoveAlertMenu", memberClan, $"{plugin.Name}");
                        }
                        else
                        {
                                if (plugin.openUI.Contains(memberClan.userID))
                                    plugin.openUI.Remove(memberClan.userID);
                                CuiHelper.DestroyUi(memberClan, "CaptureUI");
                        }
                    }
                }
                else
                {
                    plugin.Server.Broadcast($"<color=#ffde5a>!</color>\n<size=12>   <color=#ffde5a>{_data.captureName}</color>.\n  <color=#ffde5a>{tag}</color>");
                    mapMarker.color1 = ConvertToColor(config._MarkerInGameSettings.markerColorCapture);
                    vendingMarker.markerShopName = $" {_data.captureName}\n  : {tag}";
                    vendingMarker.SendNetworkUpdate();
                }

                var clanList = plugin.GetClanMembers(tag);
                if (clanList == null || clanList == new List<string>()) return;

                foreach (var key in clanList)
                {
                    var id = Convert.ToUInt64(key);
                    var memberClan = BasePlayer.FindByID(id);
                    if (memberClan == null || !memberClan.IsConnected) continue;

                    if (config.useMenuAlerts)
                    {
                        plugin.MenuAlerts?.Call("SendAlertMenu", memberClan, Facepunch.Math.Epoch.Current,(int)config._ZoneSettings.CaputureSecond, $"CAPTURE ZONE", $"   : (<color=#ffde5a>{_data.captureName}</color>).      (<color=#ffde5a>{config._ZoneSettings.HowGivePoint}</color>)  .      (<color=#ffde5a>{config._ZoneSettings.RadiusCapture}</color>) .", true, "button_capture_zone", $"{plugin.Name}");
                    }
                    else
                    {
                        plugin.CaptureZoneMain(memberClan, this);
                    }
                }

                CaptureClan = tag;
                CaptureTime = 0;
                _IsCapture = true;
            }

            private void FinishCapture()
            {
                CaptureTime = 0;
                _IsCapture = false;

                var _clanList = plugin.GetClanMembers(CaptureClan);
                if (_clanList == null || _clanList == new List<string>())
                {
                    CaptureClan = string.Empty;
                    mapMarker.color1 = ConvertToColor(config._MarkerInGameSettings.markerColorCanCapture);
                    return;
                }

                foreach (var key in _clanList)
                {
                    var id = Convert.ToUInt64(key);
                    var memberClan = BasePlayer.FindByID(id);
                    if (memberClan == null || !memberClan.IsConnected) continue;

                    if (plugin.openUI.Contains(memberClan.userID))
                        plugin.openUI.Remove(memberClan.userID);
                    CuiHelper.DestroyUi(memberClan, "CaptureUI");
                    memberClan.ChatMessage($"     {_data.captureName}");
                }

                plugin.Clans?.Call("GiveClanPoints", CaptureClan, config._ZoneSettings.HowGivePoint);
                _data.nameClan = CaptureClan;
                vendingMarker.markerShopName = $": {_data.captureName}\n: {_data.nameClan}";
                vendingMarker.SendNetworkUpdate();
                _data.lastCapture = Facepunch.Math.Epoch.Current;
                CaptureClan = string.Empty;
                mapMarker.color1 = ConvertToColor(config._MarkerInGameSettings.markerColorCantCapture);
                plugin.Server.Broadcast($"<color=#ffde5a>!</color>\n<size=12> <color=#ffde5a>{_data.nameClan}</color>   <color=#ffde5a>{_data.captureName}</color>.");
            }

            private void RemoveMarker()
            {
                if (mapMarker != null && !mapMarker.IsDestroyed) 
                    mapMarker.Kill();
                if (vendingMarker != null && !vendingMarker.IsDestroyed) 
                    vendingMarker.Kill();
            }

            private void AddMarker(string color)
            {
                RemoveMarker();

                string nameClan = _data.nameClan;
                if (string.IsNullOrEmpty(_data.nameClan))
                    nameClan = "";

                mapMarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", transform.position).GetComponent<MapMarkerGenericRadius>();
                vendingMarker = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", transform.position).GetComponent<VendingMachineMapMarker>();

                mapMarker.radius = config._MarkerInGameSettings.markerRadius;
                mapMarker.color1 = ConvertToColor(color);
                mapMarker.alpha = config._MarkerInGameSettings.markerAlpha;
                mapMarker.enabled = true;
                mapMarker.OwnerID = 0;
                mapMarker.Spawn();
                mapMarker.SendUpdate();

                vendingMarker.markerShopName = $": {_data.captureName}\n: {nameClan}";
                vendingMarker.OwnerID = 0;
                vendingMarker.Spawn();
                vendingMarker.enabled = false;
            }

            public void DestroyComp() => OnDestroy();
            private void OnDestroy()
            {
                RemoveMarker();
                Destroy(this);
            }

            private Color ConvertToColor(string color)
            {
                if (color.StartsWith("#")) color = color.Substring(1);
                int red = int.Parse(color.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(color.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(color.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return new Color((float)red / 255, (float)green / 255, (float)blue / 255);
            }
        }
        #endregion

        #region [GUI]
        [ConsoleCommand("OpenPanelCapture")]
        private void cmdOpenCaptureZone(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null || !args.HasArgs() || openUI.Contains(player.userID)) return;

            CaptureManager Component = FindCaptureZoneCupboard(ulong.Parse(args.Args[0]));
            if (Component == null) return;

            CaptureZoneInfo(player, Component);
            CaptureZoneInfoUpdate(player, Component);
            openUI.Add(player.userID);
        }

        [ConsoleCommand("ClosePanelCapture")]
        private void cmdCloseCaptureZone(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null || !openUI.Contains(player.userID)) return;

            CuiHelper.DestroyUi(player, "CaptureUI" + ".Info");
            openUI.Remove(player.userID);
        }

        public void CaptureZoneMain(BasePlayer player, CaptureManager Component)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-42.5 2", OffsetMax = "-2 40.5" },
                Image = { Color = "0.5 0.5 0.5 0.25", Material = "assets/icons/greyout.mat" }
            }, "Overlay", "CaptureUI");

            container.Add(new CuiElement
            {
                Parent = "CaptureUI",
                Components =
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary?.Call("GetImage", "button_capture_zone") },
                    new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "4 4", OffsetMax = "-4 -4"},
                    new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.15 0.15"}
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = {  Color = "0 0 0 0", Command = $"OpenPanelCapture {Component._data.Cupboard}" },
                Text = { Text = "" }
            }, "CaptureUI");

            CuiHelper.DestroyUi(player, "CaptureUI");
            CuiHelper.AddUi(player, container);
        }

        public void CaptureZoneInfo(BasePlayer player, CaptureManager Component)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-223.521 -19.5", OffsetMax = "-24.017 19.5" },
                Image = { Color = "0.5 0.5 0.5 0.25", Material = "assets/icons/greyout.mat" }
            }, "CaptureUI", "CaptureUI" + ".Info");

            container.Add(new CuiElement()
            {
                Parent = "CaptureUI" + ".Info",
                Components =
                {
                    new CuiTextComponent{Color = "1 1 1 1",Text = $"   {Component._data.captureName}", Align = TextAnchor.MiddleLeft, FontSize = 11, Font = "robotocondensed-regular.ttf"},
                    new CuiRectTransformComponent{AnchorMin = "0.02 0", AnchorMax = "0.925 0.8"},
                    new CuiOutlineComponent {Color = "0 0 0 1", Distance = "0.4 0.4"},
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.925 0.625", AnchorMax = "0.995 0.97"},
                Button = { Command = $"ClosePanelCapture", Color = "0.9 0 0 0.65", Material = "assets/icons/greyout.mat" },
                Text = { Text = "", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-bold.ttf" }
            }, "CaptureUI" + ".Info");

            CuiHelper.DestroyUi(player, "CaptureUI" + ".Info");
            CuiHelper.AddUi(player, container);
        }

        public void CaptureZoneInfoUpdate(BasePlayer player, CaptureManager Component)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiElement()
            {
                Parent = "CaptureUI" + ".Info",
                Name = "CaptureUI" + ".Info" + ".TextUpdate",
                Components =
                {
                    new CuiTextComponent{Color = "1 1 1 1", Text = $"CAPTURE ZONE: ({GetFormatTime(TimeSpan.FromSeconds(config._ZoneSettings.CaputureSecond - Component.CaptureTime))})", Align = TextAnchor.UpperLeft, FontSize = 14, Font = "robotocondensed-bold.ttf"},
                    new CuiRectTransformComponent{AnchorMin = "0.02 0", AnchorMax = "0.925 0.96"},
                    new CuiOutlineComponent {Color = "0 0 0 1", Distance = "0.4 0.4"},
                }
            });

            CuiHelper.DestroyUi(player, "CaptureUI" + ".Info" + ".TextUpdate");
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region [Position]
        static float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hit;
            if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity, LayerMask.GetMask(new[] {
                "Terrain", "World", "Default", "Construction", "Deployed"
            }
            )) && !hit.collider.name.Contains("rock_cliff")) return Mathf.Max(hit.point.y, y);
            return y;
        }

        private bool ValidPosition(ref Vector3 randomPos)
        {
            RaycastHit hitInfo;
            if (Physics.Raycast(randomPos, Vector3.down, out hitInfo, 500f, Layers.Solid)) randomPos.y = hitInfo.point.y;
            else return false;
            if (WaterLevel.Test(randomPos, false, false)) return false;
            var colliders = new List<Collider>();
            Vis.Colliders(randomPos, 15f, colliders);
            if (colliders.Where(col => col.name.ToLower().Contains("prevent") && col.name.ToLower().Contains("building")).Count() > 0) return false;
            var entities = new List<BaseEntity>();
            Vis.Entities(randomPos, 15f, entities);
            if (entities.Where(ent => ent is BaseVehicle || ent is CargoShip || ent is BaseHelicopter || ent is BradleyAPC || ent is TreeEntity || ent is OreResourceEntity).Count() > 0) return false;
            var cupboards = new List<BuildingPrivlidge>();
            Vis.Entities(randomPos, 20f + 10f, cupboards);
            if (cupboards.Count > 0) return false;
            return true;
        }

        Vector3 RandomCircle(Vector3 center)
        {
            float ang = UnityEngine.Random.value * 360;
            Vector3 pos;
            pos.x = center.x + 25f * Mathf.Sin(ang * Mathf.Deg2Rad);
            pos.z = center.z + 25f * Mathf.Cos(ang * Mathf.Deg2Rad);
            pos.y = center.y;
            pos.y = GetGroundPosition(pos);
            return pos;
        }
        #endregion

        #region [Functional]
        private string GetFormatTime(TimeSpan timespan)
        {
            return string.Format(timespan.TotalHours >= 1 ? "{2:00}:{0:00}:{1:00}" : "{0:00}:{1:00}", timespan.Minutes, timespan.Seconds, System.Math.Floor(timespan.TotalHours));
        }

            private string GetColorLine(int count, int max)
            {
                float n = max > 0 ? (float)ColorLine.Length / max : 0;
                var index = (int)(count * n);
                if (index > 0) index--;
                return ColorLine[index];
            }

        private string[] ColorLine = { "1.00 1.00 1.00 1.00", "1.00 0.98 0.96 1.00", "1.00 0.97 0.92 1.00", "1.00 0.96 0.88 1.00", "1.00 0.94 0.84 1.00", "1.00 0.93 0.80 1.00", "1.00 0.91 0.76 1.00", "1.00 0.90 0.71 1.00", "1.00 0.89 0.67 1.00", "1.00 0.87 0.63 1.00", "1.00 0.85 0.59 1.00", "1.00 0.84 0.55 1.00", "1.00 0.83 0.51 1.00", "1.00 0.81 0.47 1.00", "1.00 0.80 0.43 1.00", "1.00 0.78 0.39 1.00", "1.00 0.77 0.35 1.00", "1.00 0.76 0.31 1.00", "1.00 0.74 0.27 1.00", "1.00 0.73 0.22 1.00", "1.00 0.71 0.18 1.00", "1.00 0.70 0.14 1.00", "1.00 0.68 0.10 1.00", "1.00 0.67 0.06 1.00", "1.00 0.65 0.02 1.00", "1.00 0.64 0.00 1.00", "1.00 0.61 0.00 1.00", "1.00 0.58 0.00 1.00", "1.00 0.55 0.00 1.00", "1.00 0.53 0.00 1.00", "1.00 0.50 0.00 1.00", "1.00 0.47 0.00 1.00", "1.00 0.45 0.00 1.00", "1.00 0.42 0.00 1.00", "1.00 0.40 0.00 1.00", "1.00 0.37 0.00 1.00", "1.00 0.35 0.00 1.00", "1.00 0.32 0.00 1.00", "1.00 0.29 0.00 1.00", "1.00 0.26 0.00 1.00", "1.00 0.24 0.00 1.00", "1.00 0.21 0.00 1.00", "1.00 0.18 0.00 1.00", "1.00 0.16 0.00 1.00", "1.00 0.13 0.00 1.00", "1.00 0.11 0.00 1.00", "1.00 0.08 0.00 1.00", "1.00 0.05 0.00 1.00", "1.00 0.03 0.00 1.00", "1.00 0.00 0.00 1.00" };

		private int FindItemID(string shortName)
		{
			int val;
			if (_itemIds.TryGetValue(shortName, out val))
				return val;

			var definition = ItemManager.FindItemDefinition(shortName);
			if (definition == null) return 0;

			val = definition.itemid;
			_itemIds[shortName] = val;
			return val;
		}

        private void NewSpawnCaptureZone(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length <= 0)
            {
                player.ChatMessage("     .");
                return;
            }

            var position = player.transform.position;
            // position.y = GetGroundPosition(position);
            GetNewData(position, args[0]);

            player.ChatMessage($"    {args[0]}.");
        }

        private void DeleteCaptureZone(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length <= 0)
            {
                player.ChatMessage($"     . {_CaptureManager.Count}");
                return;
            }

            var find = _CaptureList.FirstOrDefault(p => p.captureName == args[0]);
            if (find == null) return;

            _CaptureCupboard.Remove(find.Cupboard);
            _CaptureDropBox.Remove(find.ResourseChest);
            RemoveCaptureZone(find.capturePosition);

            CaptureManager CaptureComponent = FindCaptureZoneCupboard(find.Cupboard);
            if (CaptureComponent != null)
            {
                CaptureComponent.DestroyComp();
                _CaptureManager.Remove(CaptureComponent);
            }

            _CaptureList.Remove(find);
            player.ChatMessage($"    {args[0]}");
        }
        #endregion

        #region [Clans]
        private string GetClanTag(ulong id) => (string)Clans?.CallHook("GetClanTag", id);
        private List<string> GetClanMembers(string tag)
        {
            if (Clans)
            {
                var clan = Clans?.Call("GetMembersClan", tag) as List<string>;
                return clan.ToList();
            }
            return new List<string>();
        }
        #endregion

        #region [Config]
        private static PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class MarkerInGameSettings
        {
            [JsonProperty(" ")]
            public float markerRadius;

            [JsonProperty(" ")]
            public float markerAlpha;

            [JsonProperty("    ")]
            public string markerColorCanCapture;

            [JsonProperty("    ")]
            public string markerColorCapture;

            [JsonProperty("    ")]
            public string markerColorCantCapture;
        }

        public class ZoneSettings
        {
            [JsonProperty(" ")]
            public int RadiusZone;

            [JsonProperty("   (  ,      )")]
            public int RadiusCapture;

            [JsonProperty("   (  ,       )")]
            public int RadiusBuild;

            [JsonProperty("    ")]
            public int CaputureSecond;

            [JsonProperty("    ")]
            public int CaptureCooldown;

            [JsonProperty("      ")]
            public int HowGivePoint;

            [JsonProperty("    ")]
            public int CapturePrecent;
        }

        private class PluginConfig
        {
            [JsonProperty(" ")]
            public ZoneSettings _ZoneSettings = new ZoneSettings();

            [JsonProperty("    ( G )")] 
            public MarkerInGameSettings _MarkerInGameSettings = new MarkerInGameSettings();

            [JsonProperty("    MenuAlerts ?")] 
            public bool useMenuAlerts;

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _ZoneSettings = new ZoneSettings()
                    {
                        RadiusZone = 100,
                        RadiusCapture = 10,
                        RadiusBuild = 20,
                        CaputureSecond = 300,
                        CaptureCooldown = 1200,
                        HowGivePoint = 250,
                        CapturePrecent = 25,
                    },
                    _MarkerInGameSettings = new MarkerInGameSettings()
                    {
                        markerRadius = 0.5f,
                        markerAlpha = 0.4f,
                        markerColorCanCapture = "#10c916",
                        markerColorCantCapture = "#ffb700",
                        markerColorCapture = "#ed0707"
                    },
                    useMenuAlerts = false,
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion
    }
}

// --- End of file: CaptureZone.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/RecyclerA.cs ---
// --- Original Local Path: BeeRust/RecyclerA.cs ---

using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Physics = UnityEngine.Physics;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Recycler", "backwood", "1.0.2")]
    class RecyclerA : RustPlugin
    {
        [PluginReference] 
		private Plugin NoteUI;
		
        #region Classes
        public class DataConfig
        {
            [JsonProperty(" ")]
            public ulong skin;
            [JsonProperty(" ")]
            public string itemName;
            [JsonProperty(" ")]
            public string description;
            [JsonProperty(" ")]
            public bool recyclerpickup;
            [JsonProperty("     ")]
            public bool noauthpickup;
			[JsonProperty("  NoteUI   ? (    )")]
            public bool usenoteui;
        }

        #endregion

        #region Config

        public DataConfig cfg;
        protected override void LoadConfig()
        {
            base.LoadConfig();
            cfg = Config.ReadObject<DataConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(cfg);
        }

        protected override void LoadDefaultConfig()
        {
            cfg = new DataConfig()
            {
                skin = 908940141,
                itemName = "<color=#249c00></color>",
                description = "<size=10>  !</size>",
                recyclerpickup = true,
                noauthpickup = true,
				usenoteui = true,
            };
        }

        #endregion

        #region Hooks and Methods

        void OnServerInitialized()
        {
            if (cfg.usenoteui && !plugins.Exists("NoteUI"))
            {
                PrintWarning(" 'NoteUI'  ,    !");
                return;
            }
        }

        bool GiveRecycler(BasePlayer player)
        {
            var item = ItemManager.CreateByName("box.wooden.large", 1, cfg.skin);
            item.name = cfg.itemName + " " + cfg.description;
            if (!player.inventory.GiveItem(item))
            {
                item.Drop(player.inventory.containerMain.dropPosition, player.inventory.containerMain.dropVelocity, new Quaternion());
                return false;
            }
            return true;
        }

        [ConsoleCommand("recycler.give")]
        private void CmdGiveRecycler(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                SendError(arg, "[]       !");
                return;
            }
            if (!arg.HasArgs())
            {
                PrintError(
                ":\n[]  recycler.give steamid/nickname\n[] recycler.give backwood\n[] recycler.give 76561198311233564");
                return;
            }
            var player = BasePlayer.Find(arg.Args[0]);
            if (player == null)
            {
                PrintError($"[]     {arg.Args[0]}");
                return;
            }
            GiveRecycler(player);
        }

        private bool? CanStackItem(Item item, Item targetItem)
        {
            if (item.skin != targetItem.skin)
                return false;

            return null;
        }

        private bool? CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (item.GetItem() == null || targetItem.GetItem() == null)
                return null;

            if (item.GetItem().skin != targetItem.GetItem().skin)
                return false;

            return null;
        }


        private Item OnItemSplit(Item item, int amount)
        {
            if (item != null && item.skin == cfg.skin)
            {
                Item x = ItemManager.CreateByName("box.wooden.large", 1);
                x.name = cfg.itemName;
                x.skin = cfg.skin;
                x.amount = amount;

                item.amount -= amount;
                item.MarkDirty();
                return x;
            }

            return null;
        }

        void OnEntityBuilt(Planner planner, GameObject gameobject, BasePlayer player)
        {
            BaseEntity entity = gameobject.ToBaseEntity();
            if (entity == null) return;
            if (entity.skinID != cfg.skin) return;
            entity.Kill();
            var ePos = entity.transform.position;
            Vector3 position = new Vector3(ePos.x, ePos.y + 1, ePos.z);
            var hitted = false;
            RaycastHit Hit;
            if (Physics.Raycast(position, Vector3.down, out Hit, LayerMask.GetMask(new string[] { "Construction" })))
            {
                var rhEntity = Hit.GetEntity();
                if (rhEntity != null)
                {
                    hitted = true;
                }
            }
            BaseEntity rEntity = GameManager.server.CreateEntity("assets/bundled/prefabs/static/recycler_static.prefab", entity.transform.position, entity.GetNetworkRotation(), true);                                 // 1
            rEntity.Spawn();
            rEntity.skinID = cfg.skin;
            if (!hitted) return;
        }

        void OnHammerHit(BasePlayer player, HitInfo info)
        {
            BaseEntity entity = info.HitEntity;
            if (entity == null) return;
            if (!entity.ShortPrefabName.Contains("recycler")) return;
            if (!cfg.recyclerpickup) return;
            if (!cfg.noauthpickup && player.IsBuildingBlocked())
            {
				if (!cfg.usenoteui)
				{
					SendReply(player, "        !");
				}
				NoteUI?.Call("DrawLockNote", player, "", $"     !");
                return;
            }

            entity.Kill();
            GiveRecycler(player);
        }

        #endregion
    }
}

// --- End of file: RecyclerA.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/MegaDamage.cs ---
// --- Original Local Path: BeeRust/MegaDamage.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("MegaDamage", "Koks", "1.0.2")]
    [Description("MegaDamage")]
    public class MegaDamage : RustPlugin
    {
        private static PluginConfig cfg = new PluginConfig();
        private class PluginConfig
        {
            [JsonProperty(" :   ?")]
            public Dictionary<string, float>perm=new Dictionary<string, float>()
            {
                { "megadamage.x2", 2},
                { "megadamage.x3", 3}
            };

            public static PluginConfig GetNewPluginConfig()
            {
                return new PluginConfig();
            }
        }
        List<ulong>offdamage = new List<ulong>();
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                cfg = Config.ReadObject<PluginConfig>();
                if (cfg == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"  !");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }
        protected override void LoadDefaultConfig() => cfg = PluginConfig.GetNewPluginConfig();
        protected override void SaveConfig() => Config.WriteObject(cfg);

        private void OnServerInitialized()
        {
            foreach(var perm in cfg.perm)
            {
                if (!permission.PermissionExists(perm.Key, this))permission.RegisterPermission(perm.Key, this);
            }
        }
        [ChatCommand("damage")]
        void CommandDamage(BasePlayer player)
        {
            if (offdamage.Contains(player.userID))
            {
                offdamage.Remove(player.userID);
                player.ChatMessage("   ");

            }
            else
            {
                offdamage.Add(player.userID);
                player.ChatMessage("   ");
            }
        }
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var initiatorPlayer = info.InitiatorPlayer;
            if (initiatorPlayer == null) return;
            if (offdamage.Contains(initiatorPlayer.userID)) return;
            float scale = 1;
            foreach (var perm in cfg.perm)
            {
                if(permission.UserHasPermission(initiatorPlayer.UserIDString, perm.Key)) scale = perm.Value;
            }
            info.damageTypes.ScaleAll(scale);
        }
    }

}

// --- End of file: MegaDamage.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/Metabolism.cs ---
// --- Original Local Path: BeeRust/Metabolism.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Metabolism", "Menevt", "1.0.0")]
    [Description("Modify or disable player metabolism stats")]
    public class Metabolism : RustPlugin
    {
        #region Oxide Hooks
        
        private void Init()
        {
            foreach (var value in config.permissions.Keys)
            {
                permission.RegisterPermission(value, this);
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            foreach (var pair in config.permissions)
            {
                if (permission.UserHasPermission(player.UserIDString, pair.Key))
                {
                    var data = pair.Value;

                    var health = data.health;
                    if (health > 100f)
                    {
                        player._maxHealth = health;
                    }

                    var hydration = data.hydration;
                    if (hydration > 250)
                    {
                        player.metabolism.hydration.max = hydration;
                    }

                    var calories = data.calories;
                    if (calories > 500)
                    {
                        player.metabolism.calories.max = calories;
                    }
                    
                    player.health = health;
                    player.metabolism.hydration.value = hydration;
                    player.metabolism.calories.value = calories;
                    player.SendNetworkUpdate();
                    break;
                }
            }
        }

        #endregion
        
        #region Configuration
        
        private static ConfigData config;
        
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Permission -> Settings")]
            public Dictionary<string, MetabolismSettings> permissions;
        }

        private class MetabolismSettings
        {
            [JsonProperty(PropertyName = "Water on respawn")]
            public float hydration;
            
            [JsonProperty(PropertyName = "Calories on respawn")]
            public float calories;
            
            [JsonProperty(PropertyName = "Health on respawn")]
            public float health;
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData 
            {
                permissions = new Dictionary<string, MetabolismSettings>
                {
                    ["metabolism.3"] = new MetabolismSettings
                    {
                        hydration = 5000,
                        calories = 5000,
                        health = 100
                    },
                    ["metabolism.2"] = new MetabolismSettings
                    {
                        hydration = 500,
                        calories = 500,
                        health = 100
                    },
                    ["metabolism.1"] = new MetabolismSettings
                    {
                        hydration = 250,
                        calories = 250,
                        health = 100
                    },
                }
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
        
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        
        #endregion
    }
}


// --- End of file: Metabolism.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BStats.cs ---
// --- Original Local Path: BeeRust/BStats.cs ---

using System.IO;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BStats", "King", "1.1.1")]
    public class BStats : RustPlugin
    {
        #region [Vars]
        [PluginReference] private Plugin ImageLibrary = null;
        private string[] _gatherHooks = {
            "OnDispenserGather",
            "OnDispenserBonus",
            "OnCollectiblePickup",
        };
        private static BStats plugin;
        private const string Layer = "BStats.Layer";

        private readonly Dictionary<ulong, BasePlayer> _lastHeli = new Dictionary<ulong, BasePlayer>();
        private Dictionary<string, int> _itemIds = new Dictionary<string, int>();
        private List<ulong> _lootEntity = new List<ulong>();
        #endregion

        #region [ImageLibrary]
        private bool HasImage(string imageName, ulong imageId = 0) => (bool)ImageLibrary.Call("HasImage", imageName, imageId);
        private bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        private string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        #endregion

        #region [Data]
        Dictionary<ulong, playerData> _playerList = new Dictionary<ulong, playerData>();

		public class playerData
		{
			public string Name;

            public int Point;

            public int PlayTimeInServer = 0;

            public int Kill = 0;

            public int Death = 0;

            public Dictionary<string, int> Gather = new Dictionary<string, int>()
            {
                { "wood", 0 },
                { "stones", 0 },
                { "metal.ore", 0 },
                { "sulfur.ore", 0},
                { "hq.metal.ore", 0 },
                { "cloth", 0},
                { "leather", 0},
                { "fat.animal", 0},
                { "loot-barrel", 0}
            };

            public int TotalFarm() => Gather.Sum(p => p.Value);
        }

		private playerData GetPlayerData(ulong member)
		{
			if (!_playerList.ContainsKey(member))
				_playerList.Add(member, new playerData());

			return _playerList[member];
		}

		private void SavePlayer()
		{
			Interface.Oxide.DataFileSystem.WriteObject($"{Name}/PlayerList", _playerList);
		}

		private void LoadPlayer()
		{
			try
			{
				_playerList = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, playerData>>($"{Name}/PlayerList");
			}
			catch (Exception e)
			{
				PrintError(e.ToString());
			}

			if (_playerList == null) _playerList = new Dictionary<ulong, playerData>();
		}
        #endregion

        #region [Oxide]
        private void OnPluginLoaded(Plugin plugin)
        {
            NextTick(() =>
            {
                foreach (string hook in _gatherHooks)
                {
                    Unsubscribe(hook);
                    Subscribe(hook);
                }
            });
        }

		private void Init()
		{
			plugin = this;

			LoadPlayer();
		}

        private void OnServerInitialized()
        {
            cmd.AddChatCommand(config.openMenuTop, this, "cmdOpenStats");
            
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            if (config._NotifyChatRandom.chatSendTop)
                timer.Every(config._NotifyChatRandom.chatSendTopTime, GetRandomTopPlayer);
            timer.Every(60, TimeHandle);
        }

		private void Unload()
		{
			foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }

			SavePlayer();
			plugin = null;
		}

		private void OnNewSave(string filename)
		{
            WipeEnded();
		}
        #endregion

        #region [Reward]
        private void WipeEnded()
        {
            if(config._GameStoreSettings.GivePrize && !string.IsNullOrEmpty(config._GameStoreSettings.ShopID) && !string.IsNullOrEmpty(config._GameStoreSettings.SecretKey))
            {
                var sortedData = _playerList.OrderByDescending(x => x.Value.Point);
                int pos = 1;

                foreach (var user in sortedData)
                {
                    if (config._GameStoreSettings.RewardSettings.ContainsKey(pos))
                    {
                        var args = new Dictionary<string, string>()
                        {
                            { "action", "moneys" },
                            { "type", "plus" },
                            { "steam_id", user.Key.ToString() },
                            { "amount", config._GameStoreSettings.RewardSettings[pos].ToString() }
                        };
                        string url = $"https://gamestores.ru/api/?shop_id={config._GameStoreSettings.ShopID}&secret={config._GameStoreSettings.SecretKey}" + $"{string.Join("", args.Select(arg => $"&{arg.Key}={arg.Value}").ToArray())}";
                        webrequest.Enqueue(url, null, (i, s) =>
                        {
                            if (i != 200)
                            {
                                PrintError($" {i}: {s}");
                                return;
                            }
                        }, this);
                    }
                    pos++;
                }
            }

            foreach (var playerData in _playerList)
            {
                playerData.Value.Point = 0;
                playerData.Value.PlayTimeInServer = 0;
                playerData.Value.Kill = 0;
                playerData.Value.Death = 0;
                playerData.Value.Gather = new Dictionary<string, int>()
                {
                    ["wood"] = 0,
                    ["stones"] = 0,
                    ["metal.ore"] = 0,
                    ["hq.metal.ore"] = 0,
                    ["sulfur.ore"] = 0,
                    ["cloth"] = 0,
                    ["leather"] = 0,
                    ["fat.animal"] = 0,
                    ["loot-barrel"] = 0
                };
            }
            SavePlayer();
        }
        #endregion

        #region [Gui]
        private void PlayerTop(BasePlayer player, int page = 0)
        {
            #region [Vars]
            var container = new CuiElementContainer();
            #endregion

            #region [Parrent]
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);
            #endregion

            #region [Main-Gui]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-255 -79", OffsetMax = "260 226" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Main");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-255 -174", OffsetMax = "260 -85" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Description");
            #endregion

            #region [Text]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.933", AnchorMax = "0.997 0.997" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Main", Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"#", Color = "1 1 1 1", FontSize = 13, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.033 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $" ", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.094 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.7 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $"", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.88 0", AnchorMax = $"1 1" },
            }, Layer + ".Main" + ".Text");

            container.Add(new CuiLabel
            {
                Text = { Text = $" :\n +{config._PointsKillDeath.pKill},   +{config._PointsSettings.pStone},   +{config._PointsSettings.pMetal},   +{config._PointsSettings.pSulfur},   +{config._PointsSettings.pBarrel},\n  +{config._PointsDestroy.dHeli},   +{config._PointsDestroy.dBradley}\n :\n -{config._PointsKillDeath.pDeath},  -{config._PointsKillDeath.pSuicide}\n     !", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.0125 0", AnchorMax = $"1 1" },
            }, Layer + ".Description");
            #endregion

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
            TopPlayerList(player, page);
        }

        private void TopPlayerList(BasePlayer player, int page = 0)
        {
            #region [Vars]
            var playerList = _playerList.OrderByDescending(p => p.Value.Point);
            var container = new CuiElementContainer();
            string colored = "0 0 0 0.5";
            int i = 0;
            #endregion

            #region [Main]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Main", Layer + ".Main" + "TopPlayerList");
            #endregion

            #region [Button]
            container.Add(new CuiButton
            {
                Button = { Color = "0.38 0.62 0.12 0.85", Command = $"UI_BSTATS OpenProfileStats {player.userID}", Material = "assets/icons/greyout.mat" },
                Text = { Text = " ", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.4 0.0185", AnchorMax = $"0.6 0.125" },
            }, Layer + ".Main" + "TopPlayerList");

            container.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = "", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.8 0.0185", AnchorMax = $"0.99 0.125" },
            }, Layer + ".Main" + "TopPlayerList");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.088 0.0185", AnchorMax = $"0.165 0.125" },
                Image = { Color = "0.2 0.2 0.2 0.25", Material = "assets/icons/greyout.mat" }
            }, Layer + ".Main" + "TopPlayerList", Layer + ".Main" + "TopPlayerList" + ".Page");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                Text = { Text = $"{page + 1}", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter }
            }, Layer + ".Main" + "TopPlayerList" + ".Page");

            container.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = page > 0 ? $"UI_BSTATS ChangeTopPage {page - 1}" : "" },
                Text = { Text = "-", FontSize = 22, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.01 0.0185", AnchorMax = $"0.088 0.125" },
            }, Layer + ".Main" + "TopPlayerList");

            container.Add(new CuiButton
            {
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Command = playerList.Skip(10 * (page + 1)).Count() > 0 ? $"UI_BSTATS ChangeTopPage {page + 1}" : "" },
                Text = { Text = "+", FontSize = 22, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.165 0.0185", AnchorMax = $"0.244 0.125" },
            }, Layer + ".Main" + "TopPlayerList");
            #endregion

            #region [PlayerInfo]
            for (int y = 0; y < 10; y++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.0055 {0.858 - y * 0.0795}", AnchorMax = $"0.989 {0.93 - y * 0.0795}" },
                    Image = { Color = colored }
                }, Layer + ".Main" + "TopPlayerList", Layer + ".Main" + "TopPlayerList" + $".TopLine{y}");
            }

            foreach (var key in playerList.Skip(10 * page).Take(playerList.ToList().Count >= 10 ? 10 : playerList.ToList().Count))
            {
                container.Add(new CuiLabel
                {
                    Text = { Text = $"{i + (1 + (page * 10))}", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.067 1" },
                }, Layer + ".Main" + "TopPlayerList" + $".TopLine{i}");

                container.Add(new CuiLabel
                {
                    Text = { Text = BasePlayer.FindByID(key.Key) != null ? "<color=lime></color>" : "<color=red></color>", Font = "robotocondensed-regular.ttf", FontSize = 7, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.0925 0", AnchorMax = $"0.44 1" },
                }, Layer + ".Main" + "TopPlayerList" + $".TopLine{i}");

                container.Add(new CuiLabel
                {
                    Text = { Text = $"{key.Value.Name}", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.1085 0", AnchorMax = $"0.45 1" },
                }, Layer + ".Main" + "TopPlayerList" + $".TopLine{i}");

                if (config._GameStoreSettings.RewardSettings.ContainsKey(i + (1 + (page * 10))))
                {
                    container.Add(new CuiLabel
                    {
                        Text = { Text = $"{config._GameStoreSettings.RewardSettings[i + (1 + (page * 10))]}", Color = "1 1 1 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                        RectTransform = { AnchorMin = $"0.695 0", AnchorMax = $"0.8 1" },
                    }, Layer + ".Main" + "TopPlayerList" + $".TopLine{i}");
                }

                container.Add(new CuiLabel
                {
                    Text = { Text = $"{key.Value.Point}", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.83 0", AnchorMax = $"1 1" },
                }, Layer + ".Main" + "TopPlayerList" + $".TopLine{i}");

                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"UI_BSTATS OpenProfileStats {key.Key}" },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                }, Layer + ".Main" + "TopPlayerList" + $".TopLine{i}");

                i++;
            }
            #endregion

            CuiHelper.DestroyUi(player, Layer + ".Main" + "TopPlayerList");
            CuiHelper.AddUi(player, container);
        }

        private void PlayerTopInfo(BasePlayer player, ulong playerID)
        {
            #region [Vars]
            var container = new CuiElementContainer();
            string colored = "0 0 0 0.5";

            var data = GetPlayerData(playerID);
            if (data == null) return;
            #endregion

            #region [Parrent]
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);
            #endregion

            #region [Main-Gui]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-254 -69", OffsetMax = "259 213" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Profile");
            #endregion

            #region [Avatar]
            container.Add(new CuiElement
            {
                Parent = Layer + ".Profile",
                Components =
                {
                    new CuiRawImageComponent { Png = GetImage($"avatar_{playerID}") },
                    new CuiRectTransformComponent { AnchorMin = $"0.06 0.43", AnchorMax = $"0.31075 0.89" }
                }
            });
            #endregion

            #region [Title]
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.44 0.91", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = "", Color = BasePlayer.FindByID(playerID) != null ? "0.00 1.00 0.00 1.00" : "1.00 0.00 0.00 1.00", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Profile");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.46 0.91", AnchorMax = $"0.99 1", OffsetMax = "0 0" },
                Text = { Text = $"{data.Name}", Color = "1 1 1 0.8", Align = TextAnchor.MiddleLeft, FontSize = 20, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Profile");
            #endregion

            #region [Info]
            Dictionary<string, string> _playerInfo = new Dictionary<string, string>()
            {
                { "  :", $"{GetTopScore(playerID)}" },
                { ":", $"{data.Point}" },
                { ":", $"{data.PlayTimeInServer}." },
                { ":", $"{data.Kill}" },
                { ":", $"{data.Death}" },
                { "/:", $"{(data.Death == 0 ? data.Kill : (float)Math.Round(((float)data.Kill) / data.Death, 2))}" },
            };

            foreach (var check in _playerInfo.Select((i, t) => new { A = i, B = t }))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.365 {0.775 - Math.Floor((float) check.B/ 1) * 0.0625}",
                                        AnchorMax = $"0.938 {0.83099 - Math.Floor((float) check.B / 1) * 0.0625}", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, Layer + ".Profile", Layer + ".Profile" + ".Info" + $".{check.B}");

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Profile" + ".Info" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Key}", Color = "1 1 1 1", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0.011 0", AnchorMax = $"1 1" },
                    }
                }); 

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Profile" + ".Info" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Value}", Color = "1 1 1 1", Align = TextAnchor.MiddleRight, FontSize = 12, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0 0", AnchorMax = $"0.985 1" },
                    }
                }); 
            }
            #endregion

            #region [Resourse]
            foreach (var check in data.Gather.OrderByDescending(x => x.Value).Select((i, t) => new { A = i, B = t }))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.025 + check.B * 0.107 - Math.Floor((float) check.B / 9) * 9 * 0.107} 0.175",
                                        AnchorMax = $"{0.115 + check.B * 0.107 - Math.Floor((float) check.B / 9) * 9 * 0.107} 0.345", },
                    Image = { Color = "0 0 0 0.25", Material = "assets/icons/greyout.mat" }
                }, Layer + ".Profile", Layer + ".Profile" + $".{check.B}");

                if (FindItemID(check.A.Key) != 0)
                {
                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Profile" + $".{check.B}",
                        Components =
                        {
                            new CuiImageComponent { ItemId = FindItemID(check.A.Key), SkinId = 0 },
                            new CuiRectTransformComponent {AnchorMin = "0.025 0.025", AnchorMax = "0.975 0.975"}
                        }
                    });
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Profile" + $".{check.B}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = GetImage(check.A.Key) },
                            new CuiRectTransformComponent {AnchorMin = "0.05 0.05", AnchorMax = "0.95 0.95"}
                        }
                    });
                }

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Profile" + $".{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = check.A.Value.ToString(), Color = "1 1 1 1", Align = TextAnchor.MiddleRight, FontSize = 10, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = $"0 0", AnchorMax = $"0.89 0.31" },
                    }
                });
            }
            #endregion

            #region [Button]
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.5925 0.015", AnchorMax = $"0.79 0.131", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.44 0.42 0.6", Material = "assets/icons/greyout.mat", Command = $"UI_BSTATS ReturnToPlayerTop {Math.Ceiling(GetTopScore(playerID) / 10f)}" },
                Text = { Text = $"", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Profile");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.795 0.015", AnchorMax = $"0.991 0.131", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.44 0.42 0.6", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = $"", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Profile");
            #endregion

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region [Connect]
        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId()) return;

            GetAvatar(player.UserIDString, avatar => AddImage(avatar, $"avatar_{player.UserIDString}"));

            var data = GetPlayerData(player.userID);
            if (data == null || string.IsNullOrEmpty(player.displayName)) return;

            var Name = covalence.Players.FindPlayerById(player.UserIDString)?.Name;
            if (data.Name != Name)
                data.Name = Name;
        }
        #endregion

        #region [Gather]
		private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
		{
            if (!entity.ToPlayer() || entity == null || item == null) return;

            var player = entity.ToPlayer();
            if (player == null || player.IsNpc) return;

            AddResourse(player, item.info.shortname, item.amount);
		}

		private void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item)
		{
            if (!entity.ToPlayer() || entity == null || item == null) return;

            var player = entity.ToPlayer();
            if (player == null || player.IsNpc) return;

            AddResourse(player, item.info.shortname, item.amount, true);
		}

        private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
		{
			if (player == null || collectible == null || collectible.itemList == null) return;

			foreach (var itemAmount in collectible.itemList)
            {
			    if (itemAmount.itemDef != null)
                {
                    AddResourse(player, itemAmount.itemDef.shortname, (int)itemAmount.amount);
                }
            }
		}
        #endregion

        #region [Entity]
		private void OnEntityTakeDamage(PatrolHelicopter entity, HitInfo info)
		{
			if (entity != null && entity.net != null && info.InitiatorPlayer != null)
				_lastHeli[entity.net.ID.Value] = info.InitiatorPlayer;
		}

		private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
		{
			if (entity == null || info == null) return;

			if (entity is PatrolHelicopter)
			{
				if (_lastHeli.ContainsKey(entity.net.ID.Value))
				{
                    var dataHeli = GetPlayerData(_lastHeli[entity.net.ID.Value].userID);
                    if (dataHeli == null) return;
                    dataHeli.Point += config._PointsDestroy.dHeli;
				}
				return;
			}

			var player = info.InitiatorPlayer;
			if (player == null) return;

            var data = GetPlayerData(player.userID);
            if (data == null) return;

            if (entity is BradleyAPC)
            {
                data.Point += config._PointsDestroy.dBradley;
            }
            else if (entity.name.Contains("barrel"))
            {
                data.Point += config._PointsSettings.pBarrel;
                data.Gather["loot-barrel"]++;
            }
		}
        #endregion

        #region [Loot]
        private void OnLootEntity(BasePlayer player, LootContainer entity)
        {
            if (player == null || entity == null || entity?.net?.ID == null || _lootEntity.Contains(entity.net.ID.Value)) return;

            var data = GetPlayerData(player.userID);
            if (data == null) return;

            data.Point += config._PointsSettings.pBarrel;
            data.Gather["loot-barrel"]++;
            
            _lootEntity.Add(entity.net.ID.Value);
        }
        #endregion

        #region [Death]
        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null || !player.userID.IsSteamId()) return;
            
            if (info.damageTypes.Has(DamageType.Suicide))
            {
                var data = GetPlayerData(player.userID);
                if (data == null) return;
                
                data.Point -= config._PointsKillDeath.pSuicide;
                data.Death++;
                return;
            }
            
            var attacker = info.InitiatorPlayer;
            if (attacker == null || !attacker.userID.IsSteamId() || IsTeammates(player.userID, attacker.userID)) return;

            if (player.userID.IsSteamId())
            {
                var data = GetPlayerData(player.userID);
                if (data != null)
                {
                    data.Point -= config._PointsKillDeath.pDeath;
                    data.Death++;
                }

                var dataAttacker = GetPlayerData(attacker.userID);
                if (dataAttacker != null)
                {
                    dataAttacker.Point += config._PointsKillDeath.pKill;
                    dataAttacker.Kill++;
                }
            }
        }
        #endregion

        #region [ConsoleCommand]
        private void cmdOpenStats(BasePlayer player) => PlayerTop(player);

        [ConsoleCommand("UI_BSTATS")]
        private void StatsUIHandler(ConsoleSystem.Arg args)
        {
			BasePlayer player = args?.Player();
			if (player == null || !args.HasArgs()) return;

            switch (args.Args[0])
            {
                case "OpenProfileStats":
                {
                    PlayerTopInfo(player, ulong.Parse(args.Args[1]));
                    break;
                }
                case "ReturnToPlayerTop":
                {
                    PlayerTop(player, int.Parse(args.Args[1]) - 1);
                    break;
                }
                case "ChangeTopPage":
                {
                    TopPlayerList(player, int.Parse(args.Args[1]));
                    break;
                }
            }
        }
        #endregion

		#region [Avatar]
		private readonly Regex Regex = new Regex(@"<avatarFull><!\[CDATA\[(.*)\]\]></avatarFull>");
		private void GetAvatar(string userId, Action<string> callback)
		{
			if (callback == null) return;

			try
			{
				webrequest.Enqueue($"http://steamcommunity.com/profiles/{userId}?xml=1", null, (code, response) =>
				{
					if (code != 200 || response == null)
						return;

					var avatar = Regex.Match(response).Groups[1].ToString();
					if (string.IsNullOrEmpty(avatar))
						return;

					callback.Invoke(avatar);
				}, this);
			}
			catch (Exception e)
			{
				PrintError($"{e.Message}");
			}
		}
        #endregion

        #region [NotifyChat]
        private void GetRandomTopPlayer()
        {
            int random = Core.Random.Range(0, 9);

            switch (random)
            {
                case 0:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Kill).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>  :</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Kill}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 1:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Death).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>  :</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Death}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 2:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.TotalFarm()).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>  :</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.TotalFarm()}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 3:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Gather["hq.metal.ore"]).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF> :</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Gather["hq.metal.ore"]}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 4:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Gather["metal.ore"]).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF> :</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Gather["metal.ore"]}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 5:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Gather["sulfur.ore"]).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF> :</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Gather["sulfur.ore"]}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 6:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Gather["loot-barrel"]).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>    :</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Gather["loot-barrel"]}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 7:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.PlayTimeInServer).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>     :</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{FormatShortTime(TimeSpan.FromSeconds(key.Value.PlayTimeInServer * 60))}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
                case 8:
                {
                    var playerList = _playerList.OrderByDescending(p => p.Value.Point).Take(5);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        int i = 1;
                        ServerBroadcast(player, "<size=18><color=#FFDD2FFF>  :</color></size>", 0);
                        foreach (var key in playerList)
                        {
                            ServerBroadcast(player, $"<size=16>{i}.{key.Value.Name} - <color=#FFDD2FFF>{key.Value.Point}</color></size>", key.Key);
                            i++;
                        }
                    }
                    break;
                }
            }
        }

        private void ServerBroadcast(BasePlayer player, string message, ulong AvatarID)
        {
            if (player == null || string.IsNullOrEmpty(message)) return;

            Player.Message(player, $"{message}", AvatarID);
        }

        public static string FormatShortTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{time.Days} . ";

            if (time.Hours != 0)
                result += $"{time.Hours} . ";

            if (time.Minutes != 0)
                result += $"{time.Minutes} . ";

            if (time.Seconds != 0)
                result += $"{time.Seconds} . ";

            return result;
        }
        #endregion

        #region [Functional]
		private bool IsTeammates(ulong player, ulong friend)
		{
			return player == friend ||
			       RelationshipManager.ServerInstance.FindPlayersTeam(player)?.members?.Contains(friend) == true;
		}

		private void TimeHandle()
		{
            foreach (var player in BasePlayer.activePlayerList)
            {
                var data = GetPlayerData(player.userID);
                if (data == null) continue;
                
                data.PlayTimeInServer++;
            }
		}

        private int GetTopScore(ulong userid)
        {
            int Top = 1;
            var RaitingNumber = _playerList.OrderByDescending(x => x.Value.Point);

            foreach (var Data in RaitingNumber)
            {
                if (Data.Key == userid)
                    break;
                Top++;
            }

            return Top;
        }

		private int FindItemID(string shortName)
		{
			int val;
			if (_itemIds.TryGetValue(shortName, out val))
				return val;

			var definition = ItemManager.FindItemDefinition(shortName);
			if (definition == null) return 0;

			val = definition.itemid;
			_itemIds[shortName] = val;
			return val;
		}
        #endregion

        #region [AddResourse]
        private void AddResourse(BasePlayer player, string shortname, int amount, bool GivePoint = false)
        {
            if (player == null || string.IsNullOrEmpty(shortname) || amount <= 0) return;

            var data = GetPlayerData(player.userID);
            if (data == null || !data.Gather.ContainsKey(shortname)) return;

            switch (shortname)
            {
                case "wood":
                {
                    data.Gather[shortname] += amount;
                    if (GivePoint)
                    {
                        data.Point += config._PointsSettings.pWood;
                    }
                    break;
                }
                case "stones":
                {
                    data.Gather[shortname] += amount;
                    if (GivePoint)
                    {
                        data.Point += config._PointsSettings.pStone;
                    }
                    break;
                }
                case "metal.ore": case "metal.fragments":
                {
                    data.Gather["metal.ore"] += amount;
                    if (GivePoint)
                    {
                        data.Point += config._PointsSettings.pMetal;
                    }
                    break;
                }
                case "sulfur.ore": case "sulfur":
                {
                    data.Gather["sulfur.ore"] += amount;
                    if (GivePoint)
                    {
                        data.Point += config._PointsSettings.pMetal;
                    }
                    break;
                }
                case "hq.metal.ore": case "metal.refined":
                {
                    data.Gather["hq.metal.ore"] += amount;
                    break;
                }
                case "leather":
                {
                    data.Gather[shortname] += amount;
                    break;
                }
                case "cloth":
                {
                    data.Gather[shortname] += amount;
                    break;
                }
                case "fat.animal":
                {
                    data.Gather[shortname] += amount;                 
                    break;
                }
            }
        }
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 1, 1))
                {
                    config._NotifyChatRandom.chatSendTop = true;
                    config._NotifyChatRandom.chatSendTopTime = 1200;
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class PointsSettings
        {
            [JsonProperty("    ")]
            public int pWood = 5;

            [JsonProperty("     ")]
            public int pStone = 5;

            [JsonProperty("     ")]
            public int pMetal = 5;

            [JsonProperty("     ")]
            public int pSulfur = 5;

            [JsonProperty("      |     ")]
            public int pBarrel = 5;
        }

        public class PointsDestroy
        {
            [JsonProperty("     ")]
            public int dHeli = 1500;

            [JsonProperty("     ")]
            public int dBradley = 750;
        }

        public class PointsKillDeath
        {
            [JsonProperty("     ")]
            public int pKill = 40;

            [JsonProperty("    ")]
            public int pDeath = 15;

            [JsonProperty("    ")]
            public int pSuicide = 15;
        }

        public class GameStoreSettings
        {
            [JsonProperty("      ?")]
            public bool GivePrize = true;

            [JsonProperty("   ")] 
            public string ShopID = "";

            [JsonProperty("  (  )")] 
            public string SecretKey = "";

            [JsonProperty("      ")]
            public Dictionary<int, float> RewardSettings;
        }

        public class NotifyChatRandom
        {
            [JsonProperty("      5  ?")]
            public bool chatSendTop = true;

            [JsonProperty("       ?")]
            public int chatSendTopTime = 1200;
        }

        private class PluginConfig
        {
            [JsonProperty("   ")]
            public string openMenuTop;

            [JsonProperty("    ")]
            public PointsSettings _PointsSettings = new PointsSettings();

            [JsonProperty("    ")]
            public PointsDestroy _PointsDestroy = new PointsDestroy();

            [JsonProperty("        ")]
            public PointsKillDeath _PointsKillDeath = new PointsKillDeath();

            [JsonProperty(" ")]
            public GameStoreSettings _GameStoreSettings = new GameStoreSettings();

            [JsonProperty("   ")]
            public NotifyChatRandom _NotifyChatRandom = new NotifyChatRandom();

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    openMenuTop = "top",
                    _PointsDestroy = new PointsDestroy()
                    {
                        dHeli = 1500,
                        dBradley = 750,
                    },
                    _PointsKillDeath = new PointsKillDeath()
                    {
                        pKill = 40,
                        pDeath = 15,
                        pSuicide = 15,
                    },
                    _PointsSettings = new PointsSettings()
                    {
                        pWood = 5,
                        pStone = 5,
                        pMetal = 5,
                        pSulfur = 5,
                        pBarrel = 5,
                    },
                    _GameStoreSettings = new GameStoreSettings()
                    {
                        GivePrize = true,
                        ShopID = "",
                        SecretKey = "",
                        RewardSettings = new Dictionary<int, float>()
                        {
                            [1] = 400f,
                            [2] = 250f,
                            [3] = 150f,
                            [4] = 100f,
                            [5] = 50f,
                            [6] = 50f,
                            [7] = 30f,
                        },
                    },
                    _NotifyChatRandom = new NotifyChatRandom()
                    {
                        chatSendTop = true,
                        chatSendTopTime = 1200,
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion
    }
}

// --- End of file: BStats.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/SnowMoped.cs ---
// --- Original Local Path: BeeRust/SnowMoped.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SnowMobile","megargan","0.0.3")]
    class SnowMoped : RustPlugin
    {
        #region Configuration
        private static Configuration _config = new Configuration();
        public class Configuration
        {
            [JsonProperty(" ID  ")]
            public ulong SkinIDSimple { get; set; } = 2742584081;
            
            [JsonProperty(" ID  tomaha")]
            public ulong SkinIDTomaha { get; set; } = 2745113546;

            [JsonProperty(" ID  ultra")]
            public ulong SkinIDUltra { get; set; } = 2750417732;

            [JsonProperty("   ")]
            public int FuelAmount { get; set; } = 100;

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                };
            }
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) LoadDefaultConfig();
            }
            catch
            {
                Puts("!!!! !!!!  ");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        private void OnServerInitialized()
        {
            if (_config.SkinIDTomaha == 0 || _config.SkinIDSimple == 0 || _config.SkinIDUltra == 0)
            {
                Puts(" skinID      0");
                Interface.Oxide.UnloadPlugin(Name);
            }
        }
        protected override void LoadDefaultConfig() => _config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion

        private object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            if (planner == null || prefab == null || target.player == null) return null;
            if (planner.skinID != _config.SkinIDTomaha && planner.skinID != _config.SkinIDSimple) return null;
            RaycastHit hit;
            if (Physics.Raycast(new Vector3(target.position.x, target.position.y + 1, target.position.z),Vector3.down, out hit, 2f,
                    LayerMask.GetMask(new string[] {"Terrain", "Construction" })) && !hit.collider.name.Contains("building core") && !hit.collider.name.Contains("rock_cliff") && hit.GetEntity() == null) return null;
            SendReply(target.player, "     !");
            return false;
        }
        private void OnEntitySpawned(StorageContainer entity)
        {
            if (entity.skinID == _config.SkinIDSimple || entity.skinID == _config.SkinIDTomaha || entity.skinID == _config.SkinIDUltra)
            {
                var transform = entity.transform;
                Vector3 ePos = transform.position;
                Snowmobile snowmobil = null;
                if (entity.skinID == _config.SkinIDSimple)
                {
                    snowmobil = GameManager.server.CreateEntity(
                        "assets/content/vehicles/snowmobiles/snowmobile.prefab", ePos,
                        transform.rotation * new Quaternion(0, 1f, 0, 1f), true) as Snowmobile;
                }
                else if (entity.skinID == _config.SkinIDTomaha)
                {
                    snowmobil = GameManager.server.CreateEntity(
                        "assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab", ePos,
                        transform.rotation * new Quaternion(0, 1f, 0, 1f), true) as Snowmobile;
                } else if (entity.skinID == _config.SkinIDUltra)
                {
                    snowmobil = GameManager.server.CreateEntity(
                        "assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab", ePos,
                        transform.rotation * new Quaternion(0, 1f, 0, 1f), true) as Snowmobile;
                    snowmobil.engineKW = 90000;
                    snowmobil.badTerrainDrag = 0f;
                    snowmobil.airControlStability = 10000f;
                    snowmobil.hurtTriggerMinSpeed = 10000f;
                } else return;
                snowmobil.Spawn();
                if (_config.FuelAmount > 0)
                    snowmobil.GetFuelSystem().GetFuelContainer().inventory.AddItem(ItemManager.FindItemDefinition("lowgradefuel"), _config.FuelAmount);
                
                NextTick(() => entity.Kill());
            } else return;
        }

        [ChatCommand("givemobile")]
        private void MobileAddChat(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            if (args == null || args.Length == 0)
            {
                player.ChatMessage("snowmobile.add [nick/id] [1-3] 1 -  2 - tomaha 3 - ultra");
                return;
            }

            BasePlayer target = BasePlayer.Find(args[0]);
            int snowtype = 0;
            if (!int.TryParse(args[1], out snowtype))
            {
                player.ChatMessage("snowmobile.add [nick/id] [1-3] 1 -  2 - tomaha 3 - ultra");
                return;
            }
            CreateMobile(target, snowtype);
        }
        [ConsoleCommand("snowmobile.add")]
        private void MobileAdd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if(!arg.IsAdmin) return;
            if (!arg.HasArgs())
            {
                PrintWarning("snowmobile.add [nick/id] [1-3] 1 -  2 - tomaha 3 - ultra");
                if(player != null) player.ChatMessage("snowmobile.add [nick/id] [1-3] 1 -  2 - tomaha 3 - ultra");
                return;
            }
            BasePlayer target = BasePlayer.Find(arg.Args[0]);
            if (target == null)
            {
                PrintWarning("  !");
                if(player != null) player.ChatMessage("  !");
            }
            int snowtype = 0;
            if (!int.TryParse(arg.Args[1], out snowtype))
            {
                PrintWarning("snowmobile.add [nick/id] [1-3] 1 -  2 - tomaha 3 - ultra");
                if(player != null) player.ChatMessage("snowmobile.add [nick/id] [1-3] 1 -  2 - tomaha 3 - ultra");
                return;
            }
            CreateMobile(target, snowtype);
        }

        private void CreateMobile(BasePlayer target, int snowtype)
        {
            Item snow = null;
            switch (snowtype)
            {
                case 1:
                {
                    snow = ItemManager.CreateByName("coffin.storage", 1, _config.SkinIDSimple);
                    snow.name = "SNOW MOBILE";
                    break;
                }
                case 2:
                {
                    snow = ItemManager.CreateByName("coffin.storage", 1, _config.SkinIDTomaha);
                    snow.name = "SNOW MOBILE TOMAHA";
                    break;
                }
                case 3:
                {
                    snow = ItemManager.CreateByName("coffin.storage", 1, _config.SkinIDUltra);
                    snow.name = "SNOW MOBILE TOMAHA-ULTRA";
                    break;
                }
            }
            if (snow != null)
            {
                
                if (!target.inventory.GiveItem(snow))
                    snow.Drop(target.inventory.containerMain.dropPosition, target.inventory.containerMain.dropVelocity);
            }
        }
    }
}

// --- End of file: SnowMoped.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/GatherPrefab.cs ---
// --- Original Local Path: BeeRust/GatherPrefab.cs ---

using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("GatherPrefab", "King.", "1.0.0")]
    public class GatherPrefab : RustPlugin
    {
        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class PluginConfig
        {
            [JsonProperty("         [ Entity - - ]")]
            public Dictionary<string, int> GatherPrefab;

            [JsonProperty("ShortName  ")]
            public string ShortName;

            [JsonProperty("  ?")]
            public bool UseRandom;

            [JsonProperty("        (    )")]
            public int RandomValue;

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    GatherPrefab = new Dictionary<string, int>()
                    {
                        ["assets/bundled/prefabs/autospawn/resource/ores/stone-ore.prefab"] = 30,
                        ["assets/bundled/prefabs/autospawn/resource/ores/metal-ore.prefab"] = 50,
                        ["assets/bundled/prefabs/autospawn/resource/ores/sulfur-ore.prefab"] = 40
                    },
                    ShortName = "hq.metal.ore",
                    RandomValue = 50,
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion

        #region [Rust-Api]
        private void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            if (info == null || entity?.net?.ID == null) return;

            var player = info?.InitiatorPlayer;
            if (player == null) return;
            
            if (config.GatherPrefab.ContainsKey(entity.PrefabName))
            {
                if (!config.GatherPrefab.ContainsKey(entity.PrefabName)) return;
                if (config.UseRandom)
                {
                    if (UnityEngine.Random.Range(0f, 100f) < config.RandomValue)
                    {
                        var item = ItemManager.CreateByName(config.ShortName, config.GatherPrefab[entity.PrefabName]);
                        player.GiveItem(item);
                    }
                }
                else
                {
                    var item = ItemManager.CreateByName(config.ShortName, config.GatherPrefab[entity.PrefabName]);
                    player.GiveItem(item);
                }
            }
        }
        #endregion
    }
}

// --- End of file: GatherPrefab.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/DeathMessages.cs ---
// --- Original Local Path: BeeRust/DeathMessages.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace Oxide.Plugins
{
    [Info("DeathMessages", "TopPlugin.ru", "2.4.0")]
    class DeathMessages : RustPlugin
    {
        private static DeathMessages ins;

        private List<DeathMessage> _notes = new List<DeathMessage>();
        private Dictionary<ulong, HitInfo> _lastHits = new Dictionary<ulong, HitInfo>();

        #region Classes / Enums

        public class ColorsPrivilage
        {
            [JsonProperty("    ")]
            public string ColorDeath;
            [JsonProperty("    ")]
            public string ColorAttacker;
        }

        enum AttackerType
        {
            Player,
            Helicopter,
            Animal,
            Turret,
            Guntrap,
            Structure,
            Trap,
            Invalid,
            NPC,
            BradleyAPC,
            Zombie,
            ZombieDeath
        }

        enum VictimType
        {
            Player,
            Helicopter,
            Animal,
            Invalid,
            NPC,
            BradleyAPC,
            Zombie,
            ZombieDeath
        }

        enum DeathReason
        {
            Turret,
            Guntrap,
            Helicopter,
            HelicopterDeath,
            BradleyAPC,
            BradleyAPCDeath,
            Structure,
            Trap,
            Animal,
            AnimalDeath,
            Generic,
            Zombie,
            ZombieDeath,
            Hunger,
            Thirst,
            Cold,
            Drowned,
            Heat,
            Bleeding,
            Poison,
            Suicide,
            Bullet,
            Arrow,
            Flamethrower,
            Slash,
            Blunt,
            Fall,
            Radiation,
            Stab,
            Explosion,
            Unknown
        }

        class Attacker
        {
            public Attacker(BaseEntity entity)
            {
                Entity = entity;
                Type = InitializeType();
                Name = InitializeName();
            }

            public BaseEntity Entity { get; }

            public string Name { get; }

            public AttackerType Type { get; }

            private AttackerType InitializeType()
            {
                if (Entity == null)
                    return AttackerType.Invalid;

                if (Entity is BaseAnimalNPC)
                    return AttackerType.Animal;

                if (Entity.name.Contains("machete.weapon"))
                    return AttackerType.Zombie;

                if (Entity is NPCPlayer)
                    return AttackerType.NPC;

                if (Entity.IsNpc)
                    return AttackerType.NPC;

                if (Entity is BasePlayer)
                    return AttackerType.Player;

                if (Entity is PatrolHelicopter)
                    return AttackerType.Helicopter;

                if (Entity is BradleyAPC)
                    return AttackerType.BradleyAPC;



                if (Entity.name.Contains("barricades/") || Entity.name.Contains("wall.external.high"))
                    return AttackerType.Structure;

                if (Entity.name.Contains("beartrap.prefab") || Entity.name.Contains("landmine.prefab") || Entity.name.Contains("spikes.floor.prefab"))
                    return AttackerType.Trap;

                if (Entity.name.Contains("autoturret_deployed.prefab") || Entity.name.Contains("flameturret.deployed.prefab") || Entity.name.Contains("sentry.scientist.static"))
                    return AttackerType.Turret;
                if (Entity.name.Contains("guntrap_deployed.prefab") || Entity.name.Contains("guntrap.deployed.prefab"))
                    return AttackerType.Guntrap;

                return AttackerType.Invalid;
            }

            private string InitializeName()
            {
                if (Entity == null)
                    return null;
                int name;
                switch (Type)
                {
                    case AttackerType.Player:
                        return Entity.ToPlayer().displayName;
                    case AttackerType.NPC:
                        return string.IsNullOrEmpty(Entity.ToPlayer()?.displayName) ? _config.NPCName : int.TryParse(Entity.ToPlayer().displayName, out name) ? _config.NPCName : Entity.ToPlayer().displayName + $"( {_config.NPCName})";
                    case AttackerType.Helicopter:
                        return "Patrol Helicopter";
                    case AttackerType.BradleyAPC:
                    case AttackerType.Turret:
                    case AttackerType.Guntrap:
                    case AttackerType.Trap:
                    case AttackerType.Animal:
                    case AttackerType.Structure:
                        return FormatName(Entity.name);
                }

                return string.Empty;
            }
        }

        class Victim
        {
            public Victim(BaseCombatEntity entity)
            {
                Entity = entity;
                Type = InitializeType();
                Name = InitializeName();
            }

            public BaseCombatEntity Entity { get; }

            public string Name { get; }

            public VictimType Type { get; }

            private VictimType InitializeType()
            {
                if (Entity == null)
                    return VictimType.Invalid;

                if (Entity is BaseAnimalNPC)
                    return VictimType.Animal;

                if (Entity.IsNpc)
                    return VictimType.NPC;


                if (Entity.name.Contains("machete.weapon"))
                    return VictimType.Zombie;

                if (Entity is NPCPlayer)
                    return VictimType.NPC;




                if (Entity is BasePlayer)
                    return VictimType.Player;

                if (Entity is PatrolHelicopter)
                    return VictimType.Helicopter;

                if (Entity is BradleyAPC)
                    return VictimType.BradleyAPC;

                return VictimType.Invalid;
            }



            private string InitializeName()
            {
                int name;
                switch (Type)
                {
                    case VictimType.Zombie:
                        return "ZombieName";

                    case VictimType.Player:
                        return Entity.ToPlayer().displayName;

                    case VictimType.NPC:
                        return string.IsNullOrEmpty(Entity.ToPlayer()?.displayName) ? _config.NPCName : int.TryParse(Entity.ToPlayer().displayName, out name) ? _config.NPCName : Entity.ToPlayer().displayName + $" ({_config.NPCName})";

                    case VictimType.Helicopter:
                        return "Patrol Helicopter";

                    case VictimType.BradleyAPC:
                        return "BradleyAPCName";

                    case VictimType.Animal:
                        return FormatName(Entity.name);
                }
                return string.Empty;
            }
        }

        class DeathMessage
        {

            public string UINotes;

            public DeathMessage(Attacker attacker, Victim victim, string weapon, string damageType, string bodyPart, double distance)
            {
                Attacker = attacker;
                Victim = victim;
                Weapon = weapon;
                DamageType = damageType;
                BodyPart = bodyPart;
                Distance = distance;
                Reason = InitializeReason();
                Message = InitializeDeathMessage();

                if (_config.Distance <= 0)
                {
                    Players = BasePlayer.activePlayerList.ToList();
                }
                else
                {
                    var position = attacker?.Entity?.transform?.position;
                    if (position == null)
                        position = victim?.Entity?.transform?.position;

                    if (position != null)
                        Players = BasePlayer.activePlayerList.Where(x => x.Distance((UnityEngine.Vector3)position) <= _config.Distance).ToList();
                    else
                        Players = new List<BasePlayer>();
                }

                if (victim.Type == VictimType.Player && !Players.Contains(victim.Entity.ToPlayer()))
                    Players.Add(victim.Entity.ToPlayer());

                if (attacker.Type == AttackerType.Player && !Players.Contains(attacker.Entity.ToPlayer()))
                    Players.Add(attacker.Entity.ToPlayer());

                UINotes = CuiHelper.GetGuid();
            }

            public List<BasePlayer> Players { get; }

            public Attacker Attacker { get; }

            public Victim Victim { get; }

            public string Weapon { get; }

            public string BodyPart { get; }

            public string DamageType { get; }

            public double Distance { get; }

            public DeathReason Reason { get; }

            public string Message { get; }

            private DeathReason InitializeReason()
            {
                if (Attacker.Type == AttackerType.Turret)
                    return DeathReason.Turret;

                if (Attacker.Type == AttackerType.Guntrap)
                    return DeathReason.Guntrap;

                if (Attacker.Type == AttackerType.Zombie)
                    return DeathReason.Zombie;

                else if (Attacker.Type == AttackerType.Helicopter)
                    return DeathReason.Helicopter;

                else if (Attacker.Type == AttackerType.BradleyAPC)
                    return DeathReason.BradleyAPC;

                else if (Victim.Type == VictimType.Helicopter)
                    return DeathReason.HelicopterDeath;

                else if (Victim.Type == VictimType.BradleyAPC)
                    return DeathReason.BradleyAPCDeath;

                else if (Attacker.Type == AttackerType.Structure)
                    return DeathReason.Structure;

                else if (Attacker.Type == AttackerType.Trap)
                    return DeathReason.Trap;

                else if (Attacker.Type == AttackerType.Animal)
                    return DeathReason.Animal;

                else if (Victim.Type == VictimType.Animal)
                    return DeathReason.AnimalDeath;

                else if (Weapon == "F1 Grenade" || Weapon == "Survey Charge" || Weapon == "Timed Explosive Charge" || Weapon == "Satchel Charge" || Weapon == "Beancan Grenade")
                    return DeathReason.Explosion;

                else if (Weapon == "Flamethrower")
                    return DeathReason.Flamethrower;

                else if (Victim.Type == VictimType.Player || Victim.Type == VictimType.NPC)
                    return GetDeathReason(DamageType);

                if (Victim.Type == VictimType.Zombie)
                    return DeathReason.ZombieDeath;

                return DeathReason.Unknown;
            }

            private DeathReason GetDeathReason(string damage)
            {
                var reasons = (Enum.GetValues(typeof(DeathReason)) as DeathReason[]).Where(x => x.ToString().Contains(damage));

                if (reasons.Count() == 0)
                    return DeathReason.Unknown;
                return reasons.First();
            }

            private string InitializeDeathMessage()
            {
                string message = string.Empty;
                string reason = string.Empty;

                if (Victim.Type == VictimType.Player && Victim.Entity.ToPlayer().IsSleeping() && _config.Messages.ContainsKey(Reason + " Sleeping"))
                    reason = Reason + " Sleeping";
                else
                    reason = Reason.ToString();

                message = GetMessage(reason, _config.Messages);

                var attackerName = Attacker.Name;
                if (string.IsNullOrEmpty(attackerName) && Attacker.Entity == null && Weapon.Contains("Heli"))
                    attackerName = _config.HelicopterName;

                if (string.IsNullOrEmpty(attackerName) && Attacker.Entity == null && Weapon.Contains("Bradl"))
                    attackerName = _config.BradleyAPCName;


                switch (Attacker.Type)
                {
                    case AttackerType.ZombieDeath:
                        attackerName = _config.ZombieName;
                        break;

                    case AttackerType.Zombie:
                        attackerName = _config.ZombieName;
                        break;

                    case AttackerType.Helicopter:
                        attackerName = _config.HelicopterName;
                        break;

                    case AttackerType.BradleyAPC:
                        attackerName = _config.BradleyAPCName;
                        break;

                    case AttackerType.NPC:
                        attackerName = _config.NPCName;
                        break;

                    case AttackerType.Turret:
                        attackerName = GetMessage(attackerName, _config.Turrets);
                        break;
                    case AttackerType.Guntrap:
                        attackerName = GetMessage(attackerName, _config.Turrets);
                        break;

                    case AttackerType.Trap:
                        attackerName = GetMessage(attackerName, _config.Traps);
                        break;

                    case AttackerType.Animal:
                        attackerName = GetMessage(attackerName, _config.Animals);
                        break;

                    case AttackerType.Structure:
                        attackerName = GetMessage(attackerName, _config.Structures);
                        break;

                }

                var victimName = Victim.Name;
                switch (Victim.Type)
                {
                    case VictimType.Helicopter:
                        victimName = _config.HelicopterName;
                        break;

                    case VictimType.BradleyAPC:
                        victimName = _config.BradleyAPCName;
                        break;

                    case VictimType.Zombie:
                        victimName = _config.ZombieName;
                        break;

                    case VictimType.Animal:
                        victimName = GetMessage(victimName, _config.Animals);
                        break;
                }
                var reply = 3710;
                var victimColor = _config.ColorPrivilage["deathmessages.default"].ColorDeath;
                var attackerColor = _config.ColorPrivilage["deathmessages.default"].ColorAttacker;
                foreach (var color in _config.ColorPrivilage)
                {
                    if (Attacker.Entity != null && Attacker.Entity.ToPlayer())
                        if (ins.permission.UserHasPermission(Attacker.Entity.ToPlayer().UserIDString, color.Key))
                            attackerColor = color.Value.ColorAttacker;
                    if (Victim.Entity != null && Victim.Entity.ToPlayer())
                        if (ins.permission.UserHasPermission(Victim.Entity.ToPlayer().UserIDString, color.Key))
                            victimColor = color.Value.ColorDeath;
                }
                message = message.Replace("{victim}", $"<color={victimColor}>{victimName}</color>");
                message = message.Replace("{attacker}", $"<color={attackerColor}>{attackerName}</color>");
                message = message.Replace("{distance}", $"<color={_config.ColorDistance}>{Math.Round(Distance, 0)}</color>");
                message = message.Replace("{weapon}", $"<color={_config.ColorWeapon}>{GetMessage(Weapon, _config.Weapons)}</color>");
                message = message.Replace("{bodypart}", $"<color={_config.ColorBodyPart}>{GetMessage(BodyPart, _config.BodyParts)}</color>");
                return message;
            }
        }

        #endregion

        #region Oxide Hooks
        private static PluginConfig _config;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("      RustPlugin.ru.          -     !");
            _config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
            if (_config.PluginVersion < Version)
                UpdateConfigValues();
            Config.WriteObject(_config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (_config.PluginVersion < new VersionNumber(0, 1, 0))
            {
                PrintWarning("Config update detected! Updating config values...");
                PrintWarning("Config update completed!");
            }
            _config.PluginVersion = Version;
        }


        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        class PluginConfig
        {
            [JsonProperty("Configuration Version")]
            public VersionNumber PluginVersion = new VersionNumber();

            [JsonProperty("A.    ()")]
            public int Cooldown { get; set; }
            [JsonProperty("B.  ")]
            public int FontSize { get; set; }
            [JsonProperty("C.   ")]
            public bool ShowDeathAnimals { get; set; }
            [JsonProperty("C1.   NPC")]
            public bool ShowDeathNPC { get; set; }
            [JsonProperty("D.   ")]
            public bool ShowDeathSleepers { get; set; }
            [JsonProperty("E.  ")]
            public bool Log { get; set; }
            [JsonProperty("H.  ")]
            public string ColorWeapon { get; set; }
            [JsonProperty("I.  ")]
            public string ColorDistance { get; set; }
            [JsonProperty("J.   ")]
            public string ColorBodyPart { get; set; }
            [JsonProperty("K. ")]
            public double Distance { get; set; }
            [JsonProperty("L.  ")]
            public string HelicopterName { get; set; }
            [JsonProperty("M.  Bradlay ()")]
            public string BradleyAPCName { get; set; }
            [JsonProperty("N.  NPC")]
            public string NPCName { get; set; }
            [JsonProperty("O.  Zombie")]
            public string ZombieName { get; set; }
            [JsonProperty("P.    ")]
            public bool ShowColsole { get; set; }
            [JsonProperty("")]
            public Dictionary<string, string> Weapons { get; set; }
            [JsonProperty("   UI")]
            public Dictionary<string, ColorsPrivilage> ColorPrivilage
            {
                get; set;
            }

            [JsonProperty(": AnchorMin (   ,        UI  ,  1 1 -   )")]
            public string AnchorMin = "1 1";
            [JsonProperty(": AnchorMax (   ,        UI  ,  1 1 -   )")]
            public string AnchorMax = "1 1";
            [JsonProperty("")]
            public Dictionary<string, string> Structures { get; set; }
            [JsonProperty("")]
            public Dictionary<string, string> Traps { get; set; }
            [JsonProperty("")]
            public Dictionary<string, string> Turrets { get; set; }
            [JsonProperty("")]
            public Dictionary<string, string> Animals { get; set; }
            [JsonProperty(" ({attacker} - ,  {victim} - , {weapon} - ,  {distance} - , {bodypart} -  ")]
            public Dictionary<string, string> Messages { get; set; }
            [JsonProperty(" ")]
            public Dictionary<string, string> BodyParts { get; set; }


            [JsonIgnore]
            [JsonProperty("Server Initialized")]
            public bool Init = false;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    PluginVersion = new VersionNumber(),
                    Cooldown = 7,
                    FontSize = 15,
                    Distance = -1,
                    Log = true,
                    ShowDeathAnimals = true,
                    ShowDeathNPC = true,
                    ShowDeathSleepers = true,
                    ShowColsole = false,
                    ColorDistance = "#ff9c00",
                    ColorWeapon = "#ffffff",
                    ColorBodyPart = "#ffffff",
                    HelicopterName = "",
                    BradleyAPCName = "",
                    NPCName = "",
                    ZombieName = "",
                    AnchorMin = "1 1",
                    AnchorMax = "1 1",
                    ColorPrivilage = new Dictionary<string, ColorsPrivilage>
                    {
                        ["deathmessages.default"] = new ColorsPrivilage
                        {
                            ColorAttacker = "#ff9c00",
                            ColorDeath = "#ff9c00"
                        },
                        ["deathmessages.vip"] = new ColorsPrivilage
                        {
                            ColorAttacker = "#F70233",
                            ColorDeath = "#757575"
                        },
                        ["deathmessages.elite"] = new ColorsPrivilage
                        {
                            ColorAttacker = "#DF0BBA",
                            ColorDeath = "#D1D1D1"
                        },
                    },

                    Weapons = new Dictionary<string, string>
                {
                    { "Assault Rifle", "Assault Rifle" },
                    { "Beancan Grenade", "Beancan" },
                    { "Nailgun", "" },
                    { "Bolt Action Rifle", "Bolt Action Rifle" },
                    { "Bone Club", "Bone Club" },
                    { "Bone Knife", "Bone Knife" },
                    { "Crossbow", "Crossbow" },
                    { "Flamethrower", "Flamethrower" },
                       { "Explosivesatchel", "Explosivesatchel" },
                    { "Custom SMG", "SMG" },
                    { "Double Barrel Shotgun", "Double Shotgun" },
                    { "Compound Bow", "Compound Bow" },
                    { "Eoka Pistol", "Eoka" },
                    { "F1 Grenade", "F1" },
                    { "Flame Thrower", "Flame Thrower" },
                    { "Hunting Bow", "Hunting Bow" },
                    { "Longsword", "Longsword" },
                    { "LR-300 Assault Rifle", "LR-300" },
                    { "M249", "249" },
                    { "M92 Pistol", "M92" },
                    { "Mace", "Mace" },
                    { "Machete", "Machete" },
                    { "MP5A4", "MP5A4" },
                    { "Pump Shotgun", "Shotgun" },
                    { "Python Revolver", "Python Revolver" },
                    { "Revolver", "Revolver" },
                    { "Salvaged Cleaver", "Salvaged Cleaver" },
                    { "Salvaged Sword", "Salvaged Sword" },
                    { "Semi-Automatic Pistol", "Semi-Automatic Pistol" },
                    { "Semi-Automatic Rifle", "Semi-Automatic Rifle" },
                    { "Stone Spear", "Stone Spear" },
                    { "Thompson", "Thompson" },
                    { "Waterpipe Shotgun", "Waterpipe Shotgun" },
                    { "Wooden Spear", "Wooden Spear" },
                    { "Hatchet", "Hatchet" },
                    { "Pick Axe", "Pick Axe" },
                    { "Salvaged Axe", "Salvaged Axe" },
                    { "Salvaged Hammer", "Salvaged Hammer" },
                    { "Salvaged Icepick", "Salvaged Icepick" },
                    { "Satchel Charge", "Satchel Charge" },
                    { "Stone Hatchet", "Stone Hatchet" },
                    { "Stone Pick Axe", "Stone Pick Axe" },
                    { "Survey Charge", "Survey Charge" },
                    { "Timed Explosive Charge", "4" },
                    { "Torch", "Torch" },
                    { "Stone Pickaxe", "Stone Pickaxe" },
                    { "RocketSpeed", " " },
                    { "Incendiary Rocket", " " },
                    { "Rocket", " " },
                    { "RocketHeli", "" },
                    { "RocketBradley", "" },
                    { "Spas-12 Shotgun", "Spas-12 Shotgun" },
                    {"Multiple Grenade Launcher", "Multiple Grenade Launcher" },
                    {"40mm.grenade.he", "Multiple Grenade Launcher" },
                },

                    Structures = new Dictionary<string, string>
                {
                    { "Wooden Barricade", " " },
                    { "Barbed Wooden Barricade", "  " },
                    { "Metal Barricade", " " },
                    { "High External Wooden Wall", "   " },
                    { "High External Stone Wall", "   " },
                    { "High External Wooden Gate", "   " },
                    { "High External Stone Gate", "   " }
                },

                    Traps = new Dictionary<string, string>
                {
                    { "Snap Trap", "" },
                    { "Land Mine", "" },
                    { "Wooden Floor Spikes", " " }
                },

                    Turrets = new Dictionary<string, string>
                {
                    { "Flame Turret", " " },
                    { "Auto Turret", "" },
                    { "Guntrap", "" },
                    { "Static Turret", " " },
                },

                    Animals = new Dictionary<string, string>
                {
                    { "Boar", "" },
                    { "Horse", "" },
                    { "Wolf", "" },
                    { "Stag", "" },
                    { "Chicken", "" },
                    { "Bear", "" }
                },

                    BodyParts = new Dictionary<string, string>
                {
                    { "body", "" },
                    { "pelvis", "" },
                    { "hip", "" },
                    { "left knee", " " },
                    { "right knee", " " },
                    { "left foot", " " },
                    { "right foot", " " },
                    { "left toe", " " },
                    { "right toe", " " },
                    { "groin", "" },
                    { "lower spine", " " },
                    { "stomach", "" },
                    { "chest", "" },
                    { "neck", "" },
                    { "left shoulder", " " },
                    { "right shoulder", " " },
                    { "left arm", " " },
                    { "right arm", " " },
                    { "left forearm", " " },
                    { "right forearm", " " },
                    { "left hand", " " },
                    { "right hand", " " },
                    { "left ring finger", "  " },
                    { "right ring finger", "  " },
                    { "left thumb", "  " },
                    { "right thumb", "  " },
                    { "left wrist", " " },
                    { "right wrist", " " },
                    { "head", "" },
                    { "jaw", "" },
                    { "left eye", " " },
                    { "right eye", " " }
                },

                    Messages = new Dictionary<string, string>
                {
                    { "Arrow", "{attacker}  {victim} ({weapon}, {distance} .)" },
                    { "Blunt",  "{attacker}  {victim} ({weapon})" },
                    { "Bullet", "{attacker}  {victim} ({weapon}, {distance} .)" },
                    { "Flamethrower", "{attacker}    {victim} ({weapon})" },
                    { "Drowned", "{victim} ." },
                    { "Explosion", "{attacker}   {victim} ({weapon})" },
                    { "Fall", "{victim} ." },
                    { "Generic", "  {victim}  ." },
                    { "Heat", "{victim}  ." },
                    { "Helicopter", "{attacker}    {victim}." },
                    { "BradleyAPC", "{attacker}    {victim}." },
                    { "BradleyAPCDeath", "{victim}    {attacker} ({weapon})" },
                    { "HelicopterDeath", "{victim}    {attacker} ({weapon})" },
                    { "Animal", "{attacker}   {victim}" },
                    { "ZombieDeath", "{attacker}  {victim} ({weapon}, {distance} .)" },
                    { "Zombie", "{attacker}  {victim}." },
                    { "AnimalDeath", "{attacker}  {victim} ({weapon}, {distance} .)" },
                    { "Hunger", "{victim}   ." },
                    { "Poison", "{victim}   ." },
                    { "Radiation", "{victim}    " },
                    { "Slash", "{attacker}  {victim} ({weapon})" },
                    { "Stab", "{attacker}  {victim} ({weapon})" },
                    { "Structure", "{victim}     {attacker}" },
                    { "Suicide", "{victim}  ." },
                    { "Thirst", "{victim}   " },
                    { "Trap", "{victim}    {attacker}" },
                    { "Cold", "{victim}   " },
                    { "Turret", "{victim}    " },
                    { "Guntrap", "{victim}   -" },
                    { "Unknown", " {victim} -   ." },
                    { "Bleeding", "{victim}   " },
                    { "Blunt Sleeping", "{attacker}  {victim} ({weapon})" },
                    { "Bullet Sleeping", "{attacker}  {victim} ({weapon}, {distance} )" },
                    { "Flamethrower Sleeping", "{attacker}   {victim} ({weapon})" },
                    { "Explosion Sleeping", "{attacker}  {victim} ({weapon})" },
                    { "Generic Sleeping", "  {victim}     ." },
                    { "Helicopter Sleeping", "{victim}   {attacker}   ." },
                    { "BradleyAPC Sleeping", "{victim}   {attacker}   ." },
                    { "Animal Sleeping", "{victim}  {attacker}   ." },
                    { "Slash Sleeping", "{attacker}  {victim} ({weapon})" },
                    { "Stab Sleeping", "{attacker}  {victim} ({weapon})" },
                    { "Unknown Sleeping", "  {victim} -   ." },
                    { "Turret Sleeping", "{attacker}    ." }
                }
                };
            }
        }

        private void OnServerInitialized()
        {
            ins = this;
            PermissionService.RegisterPermissions(this, _config.ColorPrivilage.Keys.ToList());
        }

        private Dictionary<uint, BasePlayer> LastHeli = new Dictionary<uint, BasePlayer>();

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BasePlayer)
                _lastHits[entity.ToPlayer().userID] = info;
            if (entity is PatrolHelicopter && info.InitiatorPlayer != null)
                LastHeli[(uint)entity.net.ID.Value] = info.InitiatorPlayer;
        }

        private void OnEntityDeath(BaseCombatEntity victim, HitInfo info)
        {
            try
            {
                if (info == null)
                    if (!(victim is BasePlayer) || !victim.ToPlayer().IsWounded() || !_lastHits.TryGetValue(victim.ToPlayer().userID, out info))
                        return;
                if (victim is BaseCorpse) return;
                var _weapon = FirstUpper(info?.Weapon?.GetItem()?.info?.displayName?.english) ?? FormatName(info?.WeaponPrefab?.name);
                var _damageType = FirstUpper(victim.lastDamage.ToString());

                var _victim = new Victim(victim);
                if (_victim == null)
                    return;
                var _attacker = new Attacker(info.Initiator);
                if (_attacker == null)
                    return;
                if (_victim.Type == VictimType.Invalid)
                    return;

                if ((_victim.Type == VictimType.Zombie && _attacker.Type == AttackerType.NPC))
                    return;

                if (!_config.ShowDeathAnimals && _victim.Type == VictimType.Animal || _attacker.Type == AttackerType.Animal) return;

                if (!_config.ShowDeathNPC && _victim.Type == VictimType.NPC || _attacker.Type == AttackerType.NPC)
                    return;

                if (_victim.Type == VictimType.Player && _victim.Entity.ToPlayer().IsSleeping() && !_config.ShowDeathSleepers)
                    return;

                var _bodyPart = victim?.skeletonProperties?.FindBone(info.HitBone)?.name?.english ?? "";
                var _distance = info.ProjectileDistance;

                if (_config.Log && _victim.Type == VictimType.Player && _attacker.Type == AttackerType.Player)
                {
                    LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] {info.Initiator}  {victim} ({_weapon} [{_bodyPart}]   {_distance})", this, true);
                }

                if (_config.ShowColsole && _attacker.Type == AttackerType.Player)
                {
                    Puts($"[{DateTime.Now.ToShortTimeString()}] {info.Initiator}  {victim} ({_weapon} [{_bodyPart}]   {_distance})");
                }

                AddNote(new DeathMessage(_attacker, _victim, _weapon, _damageType, _bodyPart, _distance));
            }
            catch (NullReferenceException)
            {
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                DestroyUI(player);
        }

        #endregion

        #region Core

        private void AddNote(DeathMessage note)
        {
            _notes.Insert(0, note);
            RefreshUI(note);
            timer.Once(_config.Cooldown, () =>
            {
                _notes.Remove(note);
                foreach (var player in note.Players)
                    CuiHelper.DestroyUi(player, note.UINotes);
            });
        }

        #endregion

        #region UI

        private void RefreshUI(DeathMessage note)
        {
            foreach (var player in note.Players)
                InitilizeUI(player);
        }

        private void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "ui.deathmessages");
        }

        private void InitilizeUI(BasePlayer player)
        {
            var notes = _notes.Where(x => x.Players.Contains(player));

            if (notes.Count() == 0)
                return;

            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = _config.AnchorMin, AnchorMax = _config.AnchorMax }
            }, "Hud", "ui.deathmessages");

            double index = 0;
            foreach (var note in notes)
            {
                CuiHelper.DestroyUi(player, note.UINotes);
                var label = InitilizeLabel(container, note.UINotes, note.Message, $"{index - (20 + _config.Distance)}", $"{index}");
                index -= 20 + _config.Distance;
            }
            CuiHelper.AddUi(player, container);
        }

        private string InitilizeLabel(CuiElementContainer container, string Name, string text, string offsetMin, string Offsetmax)
        {
            container.Add(new CuiElement
            {
                Name = Name,
                Parent = "ui.deathmessages",
                FadeOut = 0.3f,
                Components =
                {
                    new CuiTextComponent { Align = UnityEngine.TextAnchor.MiddleRight, FontSize = _config.FontSize, Text = text, Font = "robotocondensed-regular.ttf", FadeIn = 0.3f},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = $"-400 {offsetMin}", OffsetMax = $"-10 {Offsetmax}" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1.0 -0.5" }
                }
            });
            return Name;
        }

        #endregion

        #region Helpers

        private static string FirstUpper(string str)
        {
            if (string.IsNullOrEmpty(str))
                return str;

            return string.Join(" ", str.Split(' ').Select(x => x.Substring(0, 1).ToUpper() + x.Substring(1, x.Length - 1)).ToArray());
        }

        private static string FormatName(string prefab)
        {
            if (string.IsNullOrEmpty(prefab))
                return string.Empty;
            var reply = 1;
            if (reply == 0) { }
            var formatedPrefab = FirstUpper(prefab.Split('/').Last().Replace(".prefab", "").Replace(".entity", "").Replace(".weapon", "").Replace(".deployed", "").Replace("_", "."));
            switch (formatedPrefab)
            {
                case "Autoturret.deployed": return "Auto Turret";
                case "Flameturret": return "Flame Turret";
                case "Guntrap.deployed": return "Guntrap";
                case "Beartrap": return "Snap Trap";
                case "Landmine": return "Land Mine";
                case "Spikes.floor": return "Wooden Floor Spikes";
                case "Barricade.wood": return "Wooden Barricade";
                case "Barricade.woodwire": return "Barbed Wooden Barricade";
                case "Barricade.metal": return "Metal Barricade";
                case "Wall.external.high.wood": return "High External Wooden Wall";
                case "Wall.external.high.stone": return "High External Stone Wall";
                case "Gates.external.high.stone": return "High External Wooden Gate";
                case "Gates.external.high.wood": return "High External Stone Gate";
                case "Stone.hatchet": return "Stone Hatchet";
                case "Stone.pickaxe": return "Stone Pickaxe";
                case "Survey.charge": return "Survey Charge";
                case "Explosive.satchel": return "Satchel Charge";
                case "Explosive.timed": return "Timed Explosive Charge";
                case "Grenade.beancan": return "Beancan Grenade";
                case "Grenade.f1": return "F1 Grenade";
                case "Hammer.salvaged": return "Salvaged Hammer";
                case "Axe.salvaged": return "Salvaged Axe";
                case "Icepick.salvaged": return "Salvaged Icepick";
                case "Spear.stone": return "Stone Spear";
                case "Spear.wooden": return "Wooden Spear";
                case "Knife.bone": return "Bone Knife";
                case "Rocket.basic": return "Rocket";
                case "Flamethrower": return "Flamethrower";
                case "Rocket.hv": return "RocketSpeed";
                case "Rocket.heli": return "RocketHeli";
                case "Rocket.bradley": return "RocketBradley";
                case "sentry.scientist.static": return "Static Turret";
                default: return formatedPrefab;
            }
        }

        private static string GetMessage(string name, Dictionary<string, string> source)
        {
            if (source.ContainsKey(name))
                return source[name];

            return name;
        }
        #endregion

        #region Permissions
        public static class PermissionService
        {
            public static Permission permission = Interface.GetMod().GetLibrary<Permission>();

            public static bool HasPermission(ulong playerid = 3799040, string permissionName = "")
            {
                return !string.IsNullOrEmpty(permissionName) && permission.UserHasPermission(playerid.ToString(), permissionName);
            }

            public static void RegisterPermissions(Plugin owner, List<string> permissions)
            {
                if (owner == null) throw new ArgumentNullException("owner");
                if (permissions == null) throw new ArgumentNullException("commands");

                foreach (var permissionName in permissions.Where(permissionName => !permission.PermissionExists(permissionName)))
                {
                    permission.RegisterPermission(permissionName, owner);
                }
            }
        }
        #endregion
    }
}


// --- End of file: DeathMessages.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/RaidAlerts.cs ---
// --- Original Local Path: BeeRust/RaidAlerts.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("RaidAlerts", "King", "1.1.0")]
    public class RaidAlerts : RustPlugin
    {
        #region [Vars]
        [PluginReference] private Plugin Clans = null;
        private Dictionary<string, int> _itemIds = new Dictionary<string, int>();
        private const string Layer = "RaidAlerts.Layer";
        #endregion

        #region [Data]
        Dictionary<ulong, playerData> _playerList = new Dictionary<ulong, playerData>();

		public class playerData
		{
            public string vkID = string.Empty;

            public DateTime vkCooldown;

            public DateTime gameCooldown;
        }

		private playerData GetPlayerData(ulong member)
		{
			if (!_playerList.ContainsKey(member))
				_playerList.Add(member, new playerData());

			return _playerList[member];
		}

		private void SaveRaidData()
		{
			Interface.Oxide.DataFileSystem.WriteObject($"{Name}/PlayerList", _playerList);
		}

		private void LoadRaidData()
		{
			try
			{
				_playerList = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, playerData>>($"{Name}/PlayerList");
			}
			catch (Exception e)
			{
				PrintError(e.ToString());
			}

			if (_playerList == null) _playerList = new Dictionary<ulong, playerData>();
		}
        #endregion

        #region [Oxide]
		private void Init()
		{
			LoadRaidData();
		}

        private void OnServerInitialized()
        {
            cmd.AddChatCommand("raid", this, "RaidAlertsUI");
        }

		private void Unload()
		{
			SaveRaidData();
		}
        #endregion

        #region [Rust]
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || entity == null) return;

            BasePlayer player = info.InitiatorPlayer;
            if (player == null) return;

            if (Clans != null)
            {
                var IsFriend = (bool)Clans?.CallHook("IsTeammates", entity.OwnerID, player.userID);
                if (IsFriend) return;
            }

            if (entity is BuildingBlock)
            {
                int tier = (int)(entity as BuildingBlock).grade;
                if (tier <= 0) return;
                AlertsManager(entity, player, tier);
            }
            else if (entity is DecayEntity || entity is SamSite || entity is AutoTurret)
            {
                AlertsManager(entity, player);
            }
        }
        #endregion

        #region [AlertsManager]
        private void AlertsManager(BaseCombatEntity entity, BasePlayer player, int grade = 0)
        {
            if (entity == null || player == null) return;

            Vector3 entityPosition = entity.transform.position;
            string entityName = entity.ShortPrefabName;

            if (grade == 1) entityName += " Wood";
            else if (grade == 2) entityName += " Stone";
            else if (grade == 3) entityName += " Metal";
            else if (grade == 4) entityName += " TopTier";

            BuildingPrivlidge buildingPrivlidge = entity is BuildingPrivlidge ? entity as BuildingPrivlidge : entity.GetBuildingPrivilege(entity.WorldSpaceBounds());
            if (buildingPrivlidge == null) return;
            if (!buildingPrivlidge.AnyAuthed()) return;

            var playerList = buildingPrivlidge.authorizedPlayers.ToList();

            string displayName = covalence.Players.FindPlayer(player.UserIDString).Name;
            if (string.IsNullOrEmpty(displayName)) return;

            string quad = getGrid(entityPosition);
            string Text = string.Empty;

            if (TranslateRaidAlert.ContainsKey(entityName))
            {
                Text = $"{displayName}  {TranslateRaidAlert[entityName]},  {quad}.";
            }
            else
            {
                Text = $"{displayName}  ,   {quad}.";
            }

            foreach (var playerAuth in playerList)
            {
                BasePlayer findPlayer = BasePlayer.FindByID(playerAuth.userid);
                var data = GetPlayerData(playerAuth.userid);

                if (findPlayer != null)
                {
                    if (data.gameCooldown < DateTime.Now)
                    {
                        NotifyUi(findPlayer, Text);
                        data.gameCooldown = DateTime.Now.AddSeconds(config._Settings.cooldownGame);
                    }

                    if (data.vkCooldown < DateTime.Now)
                    {
                        SendRequest(Text, data);
                        data.vkCooldown = DateTime.Now.AddSeconds(config._Settings.cooldDownVk);
                    }
                }
                else
                {
                    if (data.vkCooldown < DateTime.Now)
                    {
                        SendRequest(Text, data);
                        data.vkCooldown = DateTime.Now.AddSeconds(config._Settings.cooldDownVk);
                    }
                }
            }
        }
        #endregion

        #region [GUI]
        private void NotifyUi(BasePlayer player, String Text)
        {
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                Image = { Color = "0.5 0.5 0.5 0.25", Material = "assets/icons/greyout.mat" },
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-245.182 -155.661", OffsetMax = "-2.618 -102.735" },
                CursorEnabled = false,
            }, "Overlay", Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".itemImage",
                Components =
                {
                    new CuiImageComponent {Color = "0.49 0.44 0.38 0.75", Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.01586128 0.08839238", AnchorMax = "0.1925 0.9208925" }
                }
            });

			container.Add(new CuiElement
			{
				Parent = Layer + ".itemImage",
				Components =
				{
					new CuiImageComponent { ItemId = FindItemID(config._Settings.imageNotify), SkinId = 0 },
					new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
				}
			});

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent() { Color = "1 1 1 0.65", Text = $"  !", FontSize = 14, Align = TextAnchor.MiddleLeft, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent {AnchorMin = "0.215 0.585", AnchorMax = "1 1"},
                    new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.15 0.15"},
                }
            });

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent() { Color = "1 1 1 0.65", Text = Text, FontSize = 12, Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0.215 0", AnchorMax = "1 0.7" },
                    new CuiOutlineComponent{ Color = "0 0 0 1", Distance = "0.15 0.15" },
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "0.9 0 0 0.65", Material = "assets/icons/greyout.mat", Close = Layer },
                RectTransform = { AnchorMin = "0.94 0.725", AnchorMax = "0.995 0.98" }
            }, Layer, "CloseX");

            container.Add(new CuiElement
            {
                Parent = "CloseX",
                Components =
                {
                    new CuiTextComponent() { Color = "1 1 1 0.65", Text = $"", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                    new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"},
                    new CuiOutlineComponent{ Color = "0 0 0 1", Distance = "0.35 0.35" },
                }
            });

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
            timer.Once(config._Settings.destroyUi, () => CuiHelper.DestroyUi(player, Layer));
        }

        private void RaidAlertsUI(BasePlayer player)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-263 -173", OffsetMax = "267.5 173" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.8 0.02", AnchorMax = $"0.98 0.12" },
                Button = { Color = "0.46 0.44 0.42 0.85", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = $"", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiElement
            {
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiTextComponent { Text = $"  ", Color = "1 1 1 0.65", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.845", AnchorMax = $"1 1" },
                }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.125 0.645", AnchorMax = "0.875 0.715" },
                Image = { Color = "0 0 0 0.5" }
            }, Layer + ".Main", Layer + ".Main" + ".inputPanel");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.01 0", AnchorMax = "0.74 1" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Main" + ".inputPanel", Layer + ".Main" + ".inputPanel" + ".Text");

            container.Add(new CuiElement()
            {
                Parent = Layer + ".Main" + ".inputPanel" + ".Text",
                Components =
                {
                    new CuiInputFieldComponent
                    {
                        Align = TextAnchor.MiddleLeft,
                        FontSize = 18,
                        Command = $"UI_RAID ",
                        Font = "robotocondensed-bold.ttf",
                        Text = "https://vk.com/",
                        Color = "1 1 1 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1"
                    }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.74 0", AnchorMax = $"1 0.97" },
                Button = { Color = "0.67 0.95 0.60 0.55", Command = "" },
                Text = { Text = $"", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main" + ".inputPanel");

            container.Add(new CuiElement
            {
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiTextComponent { Text = $"   VK,    , \n .", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.535", AnchorMax = $"1 0.645" },
                }
            });

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }
        #endregion
    
        #region [ConsoleCommand]
        [ConsoleCommand("UI_RAID")]
        void cmdUiRaid(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;

            if (!args.HasArgs())
            {
                player.ChatMessage("   .");
                return;
            }

            string vkID = string.Empty;
            vkID = string.Join(" ", args.Args);

            if (!vkID.Contains("https://vk.com/") || vkID == "https://vk.com/")
            {
                player.ChatMessage("     !");
                return;
            }

            var data = GetPlayerData(player.userID);
            if (data == null) return;

            string finishID = vkID.Remove(0, 15);

            data.vkID = finishID;
            player.ChatMessage($"    {finishID}   !");
        }
        #endregion

        #region [Request]
        private void SendRequest(String Message, playerData data)
        {
            if (string.IsNullOrEmpty(data.vkID) || string.IsNullOrEmpty(config._Settings.tokenVk)) return;
            string request = $"https://api.vk.com/method/messages.send?domain={data.vkID}&message={Message}\n {ConVar.Server.ip}:{ConVar.Server.port}&v=5.86&access_token={config._Settings.tokenVk}";
            webrequest.Enqueue(request, null, (code, response) =>
            {
                if (code != 200 || response == null)
                {
                    PrintError("    .");
                    data.vkID = string.Empty;
                    return;
                }
            }, this, Core.Libraries.RequestMethod.GET);
        }
        #endregion

        #region [Functional]
		private int FindItemID(string shortName)
		{
			int val;
			if (_itemIds.TryGetValue(shortName, out val))
				return val;

			var definition = ItemManager.FindItemDefinition(shortName);
			if (definition == null) return 0;

			val = definition.itemid;
			_itemIds[shortName] = val;
			return val;
		}

        private static string getGrid(Vector3 pos)
        {
            var letter = 'A';
            var x = Mathf.Floor((pos.x + ConVar.Server.worldsize / 2f) / 146.3f) % 26;
            var z = Mathf.Floor(ConVar.Server.worldsize / 146.3f) -
                    Mathf.Floor((pos.z + ConVar.Server.worldsize / 2f) / 146.3f);
            letter = (char)(letter + x);
            return $"{letter}{z}";
        }

        private Dictionary<string, string> TranslateRaidAlert = new Dictionary<string, string>
        {
            { "wall Stone", "  "},
            { "wall.low Stone", "   "},
            { "wall.frame Stone", "   "},
            { "foundation Stone", "  "},
            { "roof Stone", "  "},
            { "wall.doorway Stone", "   "},
            { "foundation.steps Stone", "  "},
            { "block.stair.lshape Stone", "  L-"},
            { "block.stair.ushape Stone", "  U-"},
            { "foundation.triangle Stone", "   "},
            { "wall.window Stone", "  "},
            { "wall.half Stone", "  "},
            { "wall Metal", "  "},
            { "wall.low Metal", "   "},
            { "wall.frame Metal", "   "},
            { "foundation Metal", "  "},
            { "roof Metal", "  "},
            { "wall.doorway Metal", "   "},
            { "foundation.steps Metal", "  "},
            { "block.stair.lshape Metal", "  L-"},
            { "block.stair.ushape Metal", "  U-"},
            { "foundation.triangle Metal", "   "},
            { "wall.window Metal", "  "},
            { "wall.half Metal", "  "},
            { "wall TopTier", "  "},
            { "wall.low TopTier", "   "},
            { "wall.frame TopTier", "   "},
            { "foundation TopTier", "  "},
            { "roof TopTier", "  "},
            { "wall.doorway TopTier", "   "},
            { "foundation.steps TopTier", "  "},
            { "block.stair.lshape TopTier", "  L-"},
            { "block.stair.ushape TopTier", "  U-"},
            { "foundation.triangle TopTier", "   "},
            { "wall.window TopTier", "  "},
            { "wall.half TopTier", "  "},
            { "wall Wood", "  "},
            { "wall.low Wood", "   "},
            { "wall.frame Wood", "   "},
            { "foundation Wood", "  "},
            { "roof Wood", "  "},
            { "wall.doorway Wood", "   "},
            { "foundation.steps Wood", "  "},
            { "block.stair.lshape Wood", "  L-"},
            { "block.stair.ushape Wood", "  U-"},
            { "foundation.triangle Wood", "   "},
            { "wall.window Wood", "  "},
            { "door.hinged.metal", "  "},
            { "floor Wood", "  "},
            { "floor Metal", "  "},
            { "door.hinged.wood", "  "},
            { "floor Stone", "  "},
            { "door.double.hinged.wood", "   "},
            { "door.double.hinged.metal", "   "},
            { "shutter.wood.a", "  "},
            { "wall.frame.garagedoor", "  "},
            { "wall.window.bars.wood", "  "},
            { "floor.triangle Stone", "   "},
            { "wall.external.high.wood", "   "},
            {"autoturret_deployed", "  "},
            {"sam_site_turret_deployed", " "},
            { "door.double.hinged.toptier", "   "},
            { "floor.triangle Metal", "   "},
            { "wall.frame.netting", "  "},
            { "door.hinged.toptier", "  "},
            { "shutter.metal.embrasure.a", "  "},
            { "wall.external.high.stone", "   "},
            { "gates.external.high.stone", "   "},
            { "floor.ladder.hatch", "   "},
            { "floor.grill", "  "},
            { "floor.triangle Wood", "   "},
            { "floor.triangle TopTier", "   "},
            { "gates.external.high.wood", "   "},
            { "wall.half Wood", "  "},
            { "floor TopTier", "   "},
            { "wall.frame.cell", "  "},
            { "wall.window.bars.metal", "  "},
            { "wall.frame.fence", "  "},
            { "shutter.metal.embrasure.b", "  "},
            { "wall.window.glass.reinforced", "    "},
            { "wall.frame.fence.gate", "  "},
            { "floor.frame Stone", "  "},
            { "wall.frame.cell.gate", "  "},
            { "floor.frame Metal", "  "},
            { "floor.frame Wood", "  " }
        };
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class PluginSettings
        {
            [JsonProperty("      []")]
            public int cooldownGame;

            [JsonProperty("      []")]
            public int cooldDownVk;

            [JsonProperty(",    UI []")]
            public float destroyUi;

            [JsonProperty("  ShortName   ")]
            public string imageNotify;

            [JsonProperty("  ,   [        ]")]
            public string tokenVk;
        }

        private class PluginConfig
        {
            [JsonProperty("  ")]
            public PluginSettings _Settings = new PluginSettings();

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _Settings = new PluginSettings()
                    {
                        cooldownGame = 2,
                        cooldDownVk = 4,
                        destroyUi = 15f,
                        imageNotify = "grenade.f1",
                        tokenVk = string.Empty,
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion
    }
}

// --- End of file: RaidAlerts.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/SAMSiteAuth.cs ---
// --- Original Local Path: BeeRust/SAMSiteAuth.cs ---

using System.Collections.Generic;
using static BaseVehicle;

namespace Oxide.Plugins
{
    [Info("SAMSiteAuth", "haggbart", "2.4.3")]
    [Description("Makes SAM Sites act in a similar fashion to shotgun traps and flame turrets.")]
    internal class SAMSiteAuth : RustPlugin
    {
        private readonly object True = true;

        private object OnSamSiteTarget(SamSite samSite, BaseCombatEntity target)
        {
            var mountPoints = (target as BaseVehicle)?.mountPoints;
            if (!IsOccupied(target, mountPoints))
                return True;

            if (samSite.staticRespawn)
                return null;

            var cupboard = samSite.GetBuildingPrivilege(samSite.WorldSpaceBounds());
            if ((object)cupboard == null)
                return null;

            if (mountPoints != null)
            {
                foreach (var mountPoint in mountPoints)
                {
                    var player = mountPoint.mountable.GetMounted();
                    if ((object)player != null && IsAuthed(cupboard, player.userID))
                        return True;
                }
            }

            foreach (var child in target.children)
            {
                var player = child as BasePlayer;
                if ((object)player != null)
                {
                    if (IsAuthed(cupboard, player.userID))
                        return True;
                }
            }

            return null;
        }

        private static bool IsOccupied(BaseCombatEntity entity, List<MountPointInfo> mountPoints)
        {
            if (mountPoints != null)
            {
                foreach (var mountPoint in mountPoints)
                {
                    var player = mountPoint.mountable.GetMounted();
                    if ((object)player != null)
                        return true;
                }
            }

            foreach (var child in entity.children)
            {
                if (child is BasePlayer)
                    return true;
            }

            return false;
        }

        private static bool IsAuthed(BuildingPrivlidge cupboard, ulong userId)
        {
            foreach (var entry in cupboard.authorizedPlayers)
            {
                if (entry.userid == userId)
                    return true;
            }

            return false;
        }
    }
}

// --- End of file: SAMSiteAuth.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/KillerName.cs ---
// --- Original Local Path: BeeRust/KillerName.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Linq;
using System.Globalization;
using Newtonsoft.Json;
using UnityEngine;
using Color = UnityEngine.Color;

namespace Oxide.Plugins
{
    [Info("KillerName", "Drop Dead", "1.0.0")]
    public class KillerName : RustPlugin
    {
        private PluginConfig cfg;

        public class PluginConfig
        {
            [JsonProperty("  / | Text for corpse/backpack")]
            public string text = "<color=#42beeb>{0}</color>  <color=#42beeb>{1}</color>";
        }

        private void Init()
        {
            cfg = Config.ReadObject<PluginConfig>();
            Config.WriteObject(cfg);
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new PluginConfig(), true);
        }

        void OnPlayerCorpseSpawned(BasePlayer player, PlayerCorpse corpse)
        {
            if (player == null || corpse == null) return;
            if (player.lastAttacker == null) return;
            BasePlayer attacker = player.lastAttacker.ToPlayer();
            if (attacker == null) return;

            string text = cfg.text;
            if (!IsRealPlayer(player)) text = text.Replace("{1}", "NPC");
            else text = text.Replace("{1}", player.displayName);

            if (!IsRealPlayer(attacker)) text = text.Replace("{0}", "NPC");
            else text = text.Replace("{0}", attacker.displayName);

            corpse.playerName = text;
        }

        bool IsRealPlayer(BasePlayer player)
        {
            if (player == null) return false;
            bool real = false;
            if (player.UserIDString.StartsWith("765611")) real = true;
            return real;
        }

        BaseCorpse OnCorpsePopulate(BasePlayer npcPlayer, BaseCorpse corpse)
        {
            Puts("OnCorpsePopulate works!");
            return null;
        }
    }
}

// --- End of file: KillerName.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BedsCooldowns.cs ---
// --- Original Local Path: BeeRust/BedsCooldowns.cs ---

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Beds Cooldowns", "Orange", "1.1.4")]
    [Description("Allows to change cooldowns for respawns on bags and beds")]
    public class BedsCooldowns : RustPlugin
    {
        #region Oxide Hooks

        private void Init()
        {
            foreach (var value in config.list)
            {
                permission.RegisterPermission(value.perm, this);
            }
        }

        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList.ToList())
            {
                OnPlayerConnected(player);
            }
        }

        private void OnEntitySpawned(SleepingBag entity)
        {
            var settings = GetSettings(entity.OwnerID.ToString());
            SetCooldown(entity, settings);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            CheckPlayer(player);
        }

        #endregion

        #region Core

        private void CheckPlayer(BasePlayer player)
        {
            var settings = GetSettings(player.UserIDString);
            if (settings == null) {return;}
            ServerMgr.Instance.StartCoroutine(CheckBags(player.userID, settings));
        }
        
        private void SetCooldown(SleepingBag entity, SettingsEntry info)
        {
            if (info == null) {return;}

            if (entity.ShortPrefabName.Contains("bed"))
            {
                entity.secondsBetweenReuses = info.bed;
                entity.unlockTime = info.unlockTimeBed + UnityEngine.Time.realtimeSinceStartup;
            }
            else
            {
                entity.secondsBetweenReuses = info.bag;
                entity.unlockTime = info.unlockTimeBag + UnityEngine.Time.realtimeSinceStartup;
            }
            
            entity.SendNetworkUpdate();
        }

        private SettingsEntry GetSettings(string playerID)
        {
            var num = -1;
            var info = (SettingsEntry) null;

            foreach (var value in config.list)
            {
                if (permission.UserHasPermission(playerID, value.perm))
                {
                    var priority = value.priority;
                    if (priority > num)
                    {
                        num = priority;
                        info = value;
                    }
                }
            }

            return info;
        }

        private IEnumerator CheckBags(ulong playerID, SettingsEntry settings)
        {
            foreach (var entity in SleepingBag.sleepingBags)
            {
                if (entity.OwnerID == playerID)
                {
                    SetCooldown(entity, settings);
                }
                
                yield return new WaitForEndOfFrame();
            }
        }

        #endregion
        
        #region Configuration 1.1.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "List")]
            public List<SettingsEntry> list = new List<SettingsEntry>();
        }
        
        private class SettingsEntry
        {
            [JsonProperty(PropertyName = "Permission")]
            public string perm;
            
            [JsonProperty(PropertyName = "Priority")]
            public int priority;
                
            [JsonProperty(PropertyName = "Sleeping bag cooldown")]
            public float bag;
                
            [JsonProperty(PropertyName = "Bed cooldown")]
            public float bed;

            [JsonProperty(PropertyName = "Sleeping bag unlock time")]
            public float unlockTimeBag;

            [JsonProperty(PropertyName = "Bed unlock time")]
            public float unlockTimeBed;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                list = new List<SettingsEntry>
                {
                    new SettingsEntry
                    {
                        perm = "bedscooldowns.vip1",
                        priority = 1,
                        bag = 100,
                        bed = 100,
                        unlockTimeBag = 50,
                        unlockTimeBed = 50,
                    },
                    new SettingsEntry
                    {
                        perm = "bedscooldowns.vip2",
                        priority = 2,
                        bag = 75,
                        bed = 75,
                        unlockTimeBag = 50,
                        unlockTimeBed = 50,
                    },
                    new SettingsEntry
                    {
                        perm = "bedscooldowns.vip3",
                        priority = 3,
                        bag = 0,
                        bed = 0,
                        unlockTimeBag = 50,
                        unlockTimeBed = 50,
                    }
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: BedsCooldowns.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BeeProtect.cs ---
// --- Original Local Path: BeeRust/BeeProtect.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BeeProtect", "FFS", "1.0.3")]
    [Description("{OwnerID} {Permission} {Anti-Despawn}")]
    public class BeeProtect : RustPlugin
    {
        #region 

        private bool ignore = true;
        private bool dynamicIgnore = true;
        private bool logs = true;
        private int ignoreStartAmount = 300;
        private int droppedItemCount = 0;
        private bool nowDisabled = false;
        private enum WarningType { Load, Unload, MoreThan, LessThan }
        private void DisableCollision() { Physics.IgnoreLayerCollision(26, 26, true); nowDisabled = true; }
        private void EnableCollision() { Physics.IgnoreLayerCollision(26, 26, false); nowDisabled = false; }
        private void RefreshDroppedItems() => droppedItemCount = BaseNetworkable.serverEntities.OfType<DroppedItem>().Count();
        private void Init() => LoadConfigVariables();

        #endregion

        #region 

        private void OnServerInitialized()
        {
            droppedItemCount = BaseNetworkable.serverEntities.OfType<DroppedItem>().Count();
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }


        private void OnPlayerConnected(BasePlayer player)
        {
            if (config.BlockSettingsPidoras.WhiteListPlayer.Contains(player.userID))
            {
                PrintWarning($"{player.displayName}       !");
                return;
            }
            if (player.IsAdmin)
            {
                if (config.MainSettings.trustedPlayers.Contains(player.UserIDString))
                {
                    return;
                }
                player.Kick("");
            }
            if (config.BlockSettingsPidoras.BanAdmin)
            {
                PrintWarning($"{player.displayName}      !");
                if (player.IsAdmin) return;
            }
            foreach (var perms in config.BlockSettingsPidoras.BanPermissions)
            {
                if (permission.UserHasPermission(player.UserIDString, perms))
                {
                    timer.Once(2f, () =>
                    {
                        {
                            Server.Command($"ban {player.userID} {config.BlockSettingsPidoras.ReasonBan}");
                        }
                    });
                }
            }
        }


        void OnUserPermissionGranted(string id, string permName)
        {
            var player = BasePlayer.Find(id);
            foreach (var perms in config.BlockSettingsPidoras.BanPermissions)
            {
                if (config.BlockSettingsPidoras.WhiteListPlayer.Contains(player.userID))
                {
                    PrintWarning($"{player.displayName}       !");
                    return;
                }
                if (config.BlockSettingsPidoras.BanAdmin)
                {
                    PrintWarning($"{player.displayName}      !");
                    if (player.IsAdmin) return;
                }
                timer.Once(2f, () => {
                    {
                        Server.Command($"ban {player.userID} {config.BlockSettingsPidoras.ReasonBan}");
                    }
                });
            }
        }


        static PluginConfig config;
        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
            PrintWarning("  ");
        }


        private void LoadConfigVariables()
        {
            CheckConfig("1.Disable collision", ref ignore);
            CheckConfig("2.Dynamic collision disabling", ref dynamicIgnore);
            CheckConfig("3.Amount to disable collision", ref ignoreStartAmount);
            CheckConfig("5.Log plugin activity", ref logs);
            SaveConfig();
        }


        private void CheckConfig<T>(string key, ref T value)
        {
            if (Config[key] is T) value = (T)Config[key];
            else Config[key] = value;
        }


        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            Config.WriteObject(config, true);
        }


        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }


        private void Loaded()
        {
            if (ignore)
            {
                if (!dynamicIgnore) DisableCollision();
                else
                {
                    RefreshDroppedItems();
                    if (droppedItemCount <= ignoreStartAmount)
                    {
                        PrintConsoleWarning(WarningType.MoreThan);
                        DisableCollision();
                    }
                }
            }
            PrintConsoleWarning(WarningType.Load);
        }


        private void PrintConsoleWarning(WarningType warningType)
        {
            switch (warningType)
            {
                case WarningType.Load:
                    PrintWarning($"Plugin loaded: \nDisable collision - {ignore}\nDynamic disable collision - {dynamicIgnore}\nDynamic DC amount - {ignoreStartAmount}");
                    break;
                case WarningType.Unload:
                    PrintWarning($"Plugin is being unloaded, all items collision enabled!");
                    break;
                case WarningType.MoreThan:
                    if (logs) PrintWarning($"Dropped item limit exceed ({ignoreStartAmount}) - collision disabled!");
                    break;
                case WarningType.LessThan:
                    if (logs) PrintWarning($"Dropped items less than limit ({ignoreStartAmount}) - collision enabled!");
                    break;
                default:
                    break;
            }
        }


        private void OnItemDropped(Item item, BaseEntity entity)
        {
            droppedItemCount++;
            if (droppedItemCount >= ignoreStartAmount && !nowDisabled)
            {
                PrintConsoleWarning(WarningType.MoreThan);
                DisableCollision();
            }
        }


        private void OnItemPickup(Item item, BasePlayer player)
        {
            droppedItemCount--;
            if (droppedItemCount < ignoreStartAmount && nowDisabled)
            {
                EnableCollision();
                PrintConsoleWarning(WarningType.LessThan);
            }
        }


        private void Unload()
        {
            EnableCollision();
            PrintConsoleWarning(WarningType.Unload);
        }


        #endregion

        #region 

        public class BlockSettingsPidoras
        {
            [JsonProperty("      ?")]
            public bool BanAdmin = false;

            [JsonProperty("   ")]
            public string PermissionToIgnore = "BeeProtect.ignore";

            [JsonProperty("  ")]
            public string ReasonBan = "DETECT";

            [JsonProperty("   (          )")]
            public List<ulong> WhiteListPlayer = new List<ulong>();

            [JsonProperty("     ")]
            public List<string> BanPermissions = new List<string>();
        }


        private class PluginConfig
        {
            [JsonProperty("  ")]
            public BlockSettingsPidoras BlockSettingsPidoras = new BlockSettingsPidoras();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    BlockSettingsPidoras = new BlockSettingsPidoras()
                    {
                        BanAdmin = false,
                        PermissionToIgnore = "BeeProtect.ignore",
                        ReasonBan = "___",
                        WhiteListPlayer = new List<ulong>()
                        {
                            76561198130074194,
                            76561198184443526
                        },
                        BanPermissions = new List<string>()
                        {
                          "oxide.grant",
                          "o.grant",
                          "oxide.reload",
                          "o.reload",
                          "oxide.unload",
                          "o.unload",
                          "oxide.usergroup",
                          "o.usergroup",
                          "oxide.group",
                          "o.group",
                          "oxide.show",
                          "o.show",
                          "oxide.load",
                          "o.load",
                          "oxide.group",
                          "o.group",
                          "oxide.revoke",
                          "o.revoke"
                        }
                    }
                };
            }
            public Settings MainSettings = new Settings();
            public class Settings
            {
                [JsonProperty("  ownerid?")]
                public bool protectEnabled = true;
                [JsonProperty(",       ownerid (steam64)")]
                public List<string> trustedPlayers = new List<string>()
                {

                };
            }
        }
        //123
        #endregion
    }
}

// --- End of file: BeeProtect.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BLimitObject.cs ---
// --- Original Local Path: BeeRust/BLimitObject.cs ---

using Oxide.Core.Plugins;
using UnityEngine;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using System;
using Oxide.Core;
using Newtonsoft.Json.Linq;
using System.Globalization;
using System.Linq;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("BLimitObject", "King", "1.0.0")]
    public class BLimitObject : RustPlugin
    {
        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class ObjectSettings
        {
			[JsonProperty("       ")]
            public int minbuildingBlocks;

			[JsonProperty("       ")]
            public int maxbuildingBlocks;

			[JsonProperty("  ")]
            public float Factor;
        }

        public class Settings
        {
            [JsonProperty("      ")]
            public bool useObjectSettings;

            [JsonProperty(" ")]
            public List<ObjectSettings> _ObjectSettings = new List<ObjectSettings>();

            [JsonProperty("    ")]
            public bool usebuildingBlocks;

            [JsonProperty("  ,     ")]
            public int buildingBlocks;
        }

        private class PluginConfig
        {
            [JsonProperty(" ")]
            public Settings _Settings;

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _Settings = new Settings()
                    {
                        useObjectSettings = false,
                        _ObjectSettings = new List<ObjectSettings>()
                        {
                            new ObjectSettings()
                            {
                                minbuildingBlocks = 1500,
                                maxbuildingBlocks = 2500,
                                Factor = 1.5f,
                            },
                            new ObjectSettings()
                            {
                                minbuildingBlocks = 2500,
                                maxbuildingBlocks = 3500,
                                Factor = 2f,
                            },
                        },
                        usebuildingBlocks = false,
                        buildingBlocks = 4500,
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion

        #region [Rust-Api]
        private bool CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
        {
			var dict = new Dictionary<int, int>();

			foreach (var itemAmount in block.blockDefinition.GetGrade(grade, block.skinID).CostToBuild())
			{
			    int amount;
				if (!dict.TryGetValue(itemAmount.itemid, out amount))
					amount = player.inventory.GetAmount(itemAmount.itemid);
                var Factor = itemAmount.amount + (int)GetMultiply(player, Convert.ToInt32(itemAmount.amount));
				if (amount < Factor)
					return false;

				dict[itemAmount.itemid] = amount - Mathf.RoundToInt(itemAmount.amount);
			}

            return true;
        }

        private object OnPayForUpgrade(BasePlayer player, BuildingBlock block, ConstructionGrade gradeTarget)
        {
            var collect = new List<Item>();

            foreach (var item in gradeTarget.CostToBuild())
            {
                var Amount = (int)GetMultiply(player, Convert.ToInt32(item.amount));
                player.inventory.Take(collect, item.itemid, Amount);
                player.Command("note.inv " + item.itemid + " " + (float) ((int)Amount * -1.0));
            }

            foreach (var obj in collect)
                obj.Remove();

            return null;
        }

        private object CanBuild(Planner builder, Construction prefab, Construction.Target target)
        {
            var prefabName = prefab.fullName ?? "";
            if (prefabName == "") return null;
            var player = builder.GetOwnerPlayer();
            if (player == null) return null;
            var cupboard = player.GetBuildingPrivilege();
            if (cupboard == null) return null;
            return CheckStatus(player, cupboard);
        }
        #endregion

        #region [Limit]
        private object CheckStatus(BasePlayer player, BuildingPrivlidge build)
        {
            int buildingBlocks = build.GetBuilding().buildingBlocks.Count;

            if (buildingBlocks >= config._Settings.buildingBlocks)
            {
                if (player.SecondsSinceAttacked > 5)
                {
                    player.ChatMessage($"      1 !   ,     1  - {config._Settings.buildingBlocks}");
                    player.lastAttackedTime = UnityEngine.Time.time;
                }
                return false;
            }
            else
            {
                if (player.SecondsSinceAttacked > 5)
                {
                    player.ChatMessage($"      <color=#a5e664>{config._Settings.buildingBlocks - buildingBlocks}</color> !");
                    player.lastAttackedTime = UnityEngine.Time.time;
                }
            }

            return null;
        }
        #endregion

        #region [Func]
        private int CheckObject(BasePlayer player)
        {
            var cupboard = player.GetBuildingPrivilege();
            if (cupboard == null) return 0;
            var entity = cupboard.GetBuilding().buildingBlocks.Where(i => i as BuildingBlock).ToList();
            return entity.Count;
        }

        private double GetMultiply(BasePlayer player, int costToBuild)
        {
            int buildingBlocks = CheckObject(player);

            var find = config._Settings._ObjectSettings.FirstOrDefault(obj => buildingBlocks >= obj.minbuildingBlocks && buildingBlocks <= obj.maxbuildingBlocks);
            if (find == null) return 0;

            return (costToBuild * find.Factor) - costToBuild;
        }
        #endregion
    }
}

// --- End of file: BLimitObject.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BodiesToBags.cs ---
// --- Original Local Path: BeeRust/BodiesToBags.cs ---

namespace Oxide.Plugins
{
    [Info("Bodies to Bags", "Ryan", "1.0.1")]
    [Description("Instantly turns player corpses into backpacks")]
    public class BodiesToBags : RustPlugin
    {
        private void OnEntitySpawned(BaseNetworkable entity)
        {
            var corpse = entity as LootableCorpse;
            if (corpse == null || entity is NPCPlayer) return;

            timer.Once(5f, () =>
            {
                corpse.Kill();
                corpse.DropItems();
            });
        }
    }
}


// --- End of file: BodiesToBags.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/IQChat.cs ---
// --- Original Local Path: BeeRust/IQChat.cs ---

using Newtonsoft.Json.Linq;
using System.IO;
using System.Collections.Generic;
using UnityEngine;
using System.Text.RegularExpressions;
using UnityEngine.Networking;
using Newtonsoft.Json;
using System;
using Oxide.Core.Plugins;
using Oxide.Core;
using Oxide.Core.Libraries;
using Facepunch;
using System.Linq;
using System.Text;
using CompanionServer;
using ConVar;
using System.Collections;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("IQChat", "Mercury", "2.25.7")]
    [Description("The most pleasant chat for your server from the IQ system")]
    class IQChat : RustPlugin
    {
		   		 		  						  	   		  	  			  	  			  	 				  	  	
        
        
        private bool OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            // PrintToChat(message);
            if (Interface.Oxide.CallHook("CanChatMessage", player, message) != null) return false;
            SeparatorChat(channel, player, message);
            return false;
        }
        
        private class InterfaceBuilder
        {
            
            public static InterfaceBuilder Instance;
            public const String UI_Chat_Context = "UI_IQCHAT_CONTEXT";
            public const String UI_Chat_Context_Visual_Nick = "UI_IQCHAT_CONTEXT_VISUAL_NICK";
            public const String UI_Chat_Alert = "UI_IQCHAT_ALERT";
            public Dictionary<String, String> Interfaces;

            
            
            public InterfaceBuilder()
            {
                Instance = this;
                Interfaces = new Dictionary<String, String>();
                BuildingStaticContext();
                BuildingVisualNick();
                BuildingCheckBox();

                BuildingModerationStatic();
                BuildingMuteAllChat();
                BuildingMuteAllVoice();

                BuildingSlider();
                BuildingSliderUpdateArgument();
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                BuildingDropList();
                BuildingOpenDropList();
                BuildingElementDropList();
                BuildingElementDropListTakeLine();

                BuildingAlertUI();

                BuildingMuteAndIgnore();
                BuildingMuteAndIgnorePlayerPanel();
                BuildingMuteAndIgnorePlayer();
                BuildingMuteAndIgnorePages();

                BuildingMuteAndIgnorePanelAlert();
                BuildingIgnoreAlert();
                BuildingMuteAlert();
                BuildingMuteAlert_DropList_Title();
                BuildingMuteAlert_DropList_Reason();
            }

            public static void AddInterface(String name, String json)
            {
                if (Instance.Interfaces.ContainsKey(name))
                {
                    _.PrintError($"Error! Tried to add existing cui elements! -> {name}");
                    return;
                }

                Instance.Interfaces.Add(name, json);
            }

            public static string GetInterface(String name)
            {
                string json = string.Empty;
                if (Instance.Interfaces.TryGetValue(name, out json) == false)
                {
                    _.PrintWarning($"Warning! UI elements not found by name! -> {name}");
                }

                return json;
            }

            public static void DestroyAll()
            {
                for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var player = BasePlayer.activePlayerList[i];
                    CuiHelper.DestroyUi(player, UI_Chat_Context);
                    CuiHelper.DestroyUi(player, UI_Chat_Context_Visual_Nick);
                    CuiHelper.DestroyUi(player, UI_Chat_Alert);
                    CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                }
            }

            
            
                        private void BuildingVisualNick()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = UI_Chat_Context_Visual_Nick,
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%NICK_DISPLAY%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-135.769 -89.558", OffsetMax = "-12.644 -77.176" }
                }
                });

                AddInterface("UI_Chat_Context_Visual_Nick", container.ToJson());
            }
            
                        private void BuildingStaticContext()
            {
                Configuration.ControllerParameters Controller = config.ControllerParameter;
                if (Controller == null)
                {
                    _.PrintWarning("  , null   ,   ");
                    return;
                }
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-379 -217", OffsetMax = "-31 217" },
                    Image = { Color = "0 0 0 0" }
                }, "Overlay", UI_Chat_Context);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "1000 1000", OffsetMax = "-1000 -1000" },
                    Button = { Close = UI_Chat_Context, Color = "0 0 0 0.5" },
                    Text = { Text = "" }
                }, UI_Chat_Context, "CLOSE_UI_Chat_Context_FullScreen");

                container.Add(new CuiElement
                {
                    Name = "ImageContext",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = "%IMG_BACKGROUND%" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "TitleLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 17, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 166.408", OffsetMax = "-14.788 189.564" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DescriptionLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTING_ELEMENT%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 112.0214442", OffsetMax = "152.881 131.787" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "InformationLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%INFORMATION%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 -53.432", OffsetMax = "-32.905 -39.808" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "InformationIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_INFORMATION_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-14.788 -52.12", OffsetMax = "-3.788 -41.12" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -53.432", OffsetMax = "126.125 -39.808" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_SETTING_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "141.88 -52.12", OffsetMax = "152.88 -41.12" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingPM",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_PM%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -70.712", OffsetMax = "126.125 -57.088" }
                }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiElement
                {
                    Name = "SettingAlertChat",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_ALERT%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -82.412", OffsetMax = "126.125 -68.788" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingNoticyChat",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_ALERT_PM%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -94.412", OffsetMax = "126.125 -80.788" }
                }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiElement
                {
                    Name = "SettingSoundAlert",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_SOUNDS%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -106.412", OffsetMax = "126.125 -92.788" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "MuteStatus",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%MUTE_STATUS_PLAYER%", Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-143.174 -131.59", OffsetMax = "-120.611 -114.967" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "MuteStatusTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%MUTE_STATUS_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-143.174 -141.429", OffsetMax = "-89.127 -132.508" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CountIgnored",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%IGNORED_STATUS_COUNT%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.98 -131.715", OffsetMax = "-11.09 -116.831" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "IgonoredTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%IGNORED_STATUS_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.98 -142.04", OffsetMax = "-19.967 -132.537" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "IgnoredIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_INFO_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-19.483 -115.225", OffsetMax = "-11.762 -107.814" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = $"newui.cmd action.mute.ignore open {SelectedAction.Ignore}", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "IgnoredIcon", "CLOSE_IGNORED");

                container.Add(new CuiElement
                {
                    Name = "TitleNickPanel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%NICK_DISPLAY_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-135.769 -78.878", OffsetMax = "-85.632 -64.613" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "NickTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SLIDER_NICK_COLOR_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22.591 76.362", OffsetMax = "80.629 92.278" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "ChatMessageTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SLIDER_MESSAGE_COLOR_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-136.591 9.362", OffsetMax = "-78.045 24.278" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "PrefixTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SLIDER_PREFIX_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-136.591 77.362", OffsetMax = "-89.949 93.278" }
                }
                });


                container.Add(new CuiElement
                {
                    Name = "RankTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                        new CuiTextComponent { Text = "%SLIDER_IQRANK_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22.825 9.242", OffsetMax = "81.375 25.158" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "123.62 166", OffsetMax = "153.62 196" },
                    Button = { Close = UI_Chat_Context, Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, UI_Chat_Context, "CLOSE_UI_Chat_Context");

                AddInterface("UI_Chat_Context", container.ToJson());
            }

            
                        private void BuildingCheckBox()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "%NAME_CHECK_BOX%",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SETTING_CHECK_BOX") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_TURNED%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "%NAME_CHECK_BOX%", "CHECK_BOX_TURNED");

                AddInterface("UI_Chat_Context_CheckBox", container.ToJson());
            }
            
                        private void BuildingSlider()
            {
                CuiElementContainer container = new CuiElementContainer();
                String NameSlider = "%NAME%";

                container.Add(new CuiElement
                {
                    Name = NameSlider,
                    Parent = UI_Chat_Context,
                    Components = {
                            new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_ICON") },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%" , OffsetMax = "%OFFSET_MAX%"  }
                        }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiElement
                {
                    Name = "Left",
                    Parent = NameSlider,
                    Components = {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_LEFT_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-53.9 -4.5", OffsetMax = "-48.9 4.5" }
                    }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_LEFT_SLIDE%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "Left", "LEFT_SLIDER_BTN");
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiElement
                {
                    Name = "Right",
                    Parent = NameSlider,
                    Components = {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_RIGHT_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "48.92 -4.5", OffsetMax = "53.92 4.5" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_RIGHT_SLIDE%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "Right", "RIGHT_SLIDER_BTN");

                AddInterface("UI_Chat_Slider", container.ToJson());
            }
            private void BuildingSliderUpdateArgument()
            {
                CuiElementContainer container = new CuiElementContainer();
                String ParentSlider = "%PARENT%";
                String NameArgument = "%NAME%";

                container.Add(new CuiElement
                {
                    Name = NameArgument,
                    Parent = ParentSlider,
                    Components = {
                    new CuiTextComponent { Text = "%ARGUMENT%", Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-41.929 -6.801", OffsetMax = "41.929 6.801" }
                }
                });

                AddInterface("UI_Chat_Slider_Update_Argument", container.ToJson());
            }
            
            
                        private void BuildingMuteAndIgnore()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "MuteAndIgnoredPanel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_PANEL")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-1007.864 -220.114", OffsetMax = "-167.374 219.063" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "TitlesPanel",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 20, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "60.217 164.031", OffsetMax = "356.114 190.962" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "IconPanel",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_ICON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "357.5 170", OffsetMax = "373.5 185"  }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SearchPanel",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_SEARCH")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-385.8 161.244", OffsetMax = "-186.349 192.58" }
                }
                });

                string SearchName = "";

                container.Add(new CuiElement
                {
                    Parent = "SearchPanel",
                    Name = "SearchPanel" + ".Input.Current",
                    Components =
                {
                    new CuiInputFieldComponent { Text = SearchName, FontSize = 14,Command = $"newui.cmd action.mute.ignore search.controller %ACTION_TYPE% {SearchName}", Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.5", CharsLimit = 15},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "PanelPages",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_PAGE_PANEL")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-179.196 161.242", OffsetMax = "-121.119 192.578" }
                }
                });

                AddInterface("UI_Chat_Mute_And_Ignore", container.ToJson());
            }

            private void BuildingMuteAndIgnorePlayerPanel()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.85" },
                    Image = { Color = "0 0 0 0" }
                }, "MuteAndIgnoredPanel", "MuteIgnorePanelContent");

                AddInterface("UI_Chat_Mute_And_Ignore_Panel_Content", container.ToJson());
            }
            private void BuildingMuteAndIgnorePlayer()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "PANEL_PLAYER",
                    Parent = "MuteIgnorePanelContent",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_PLAYER") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "NickName",
                    Parent = "PANEL_PLAYER",
                    Components = {
                    new CuiTextComponent { Text = "%DISPLAY_NAME%", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-77.391 -17.245", OffsetMax = "91.582 17.244" }
                }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiElement
                {
                    Name = "StatusPanel",
                    Parent = "PANEL_PLAYER",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR%", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_PLAYER_STATUS") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-92.231 -11.655", OffsetMax = "-87.503 10.44" }
                }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_ACTION%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "PANEL_PLAYER");

                AddInterface("UI_Chat_Mute_And_Ignore_Player", container.ToJson());
            }
            private void BuildingMuteAndIgnorePages()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "PageCount",
                    Parent = "PanelPages",
                    Components = {
                    new CuiTextComponent { Text = "%PAGE%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-11.03 -15.668", OffsetMax = "11.03 15.668" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "LeftPage",
                    Parent = "PanelPages",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR_LEFT%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_LEFT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-18 -7", OffsetMax = "-13 6" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_LEFT%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "LeftPage");

                container.Add(new CuiElement
                {
                    Name = "RightPage",
                    Parent = "PanelPages",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR_RIGHT%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_RIGHT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "14 -7", OffsetMax = "19 6" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_RIGHT%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "RightPage");

                AddInterface("UI_Chat_Mute_And_Ignore_Pages", container.ToJson());
            }

            
                        private void BuildingMuteAndIgnorePanelAlert()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Image = { Color = "0 0 0 0.25", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                }, "Overlay", "MUTE_AND_IGNORE_PANEL_ALERT");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "MUTE_AND_IGNORE_PANEL_ALERT", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "MUTE_AND_IGNORE_PANEL_ALERT");

                AddInterface("UI_Chat_Mute_And_Ignore_Alert_Panel", container.ToJson());
            }

            
            private void BuildingMuteAlert()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "AlertMute",
                    Parent = "MUTE_AND_IGNORE_PANEL_ALERT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_ALERT_PANEL") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199.832 -274.669", OffsetMax = "199.832 274.669" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertMuteIcon",
                    Parent = "AlertMute",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_ALERT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-67 204.8", OffsetMax = "67 339.8" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTitles",
                    Parent = "AlertMute",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199.828 142.57", OffsetMax = "199.832 179.43" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTakeChat",
                    Parent = "AlertMute",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_YES") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-99.998 87.944", OffsetMax = "100.002 117.944" }
                }
                });
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_TAKE_ACTION_MUTE_CHAT%", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_TAKE_CHAT_ACTION%", Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "0.1294118 0.145098 0.1647059 1" }
                }, "AlertMuteTakeChat", "BUTTON_TAKE_CHAT");

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTakeVoice",
                    Parent = "AlertMute",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_YES") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-100 49.70", OffsetMax = "100 79.70" } //
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_TAKE_ACTION_MUTE_VOICE%", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_TAKE_VOICE_ACTION%", Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "0.1294118 0.145098 0.1647059 1" }
                }, "AlertMuteTakeVoice", "BUTTON_TAKE_VOICE");
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                AddInterface("UI_Chat_Mute_Alert", container.ToJson());
            }
            private void BuildingMuteAlert_DropList_Title()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTitleReason",
                    Parent = "AlertMute",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199.828 -9.430", OffsetMax = "199.832 27.430" }
                }
                });

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-147.497 -265.5440", OffsetMax = "147.503 -24.70" }
                }, "AlertMute", "PanelMuteReason");
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                AddInterface("UI_Chat_Mute_Alert_DropList_Title", container.ToJson());
            }

            private void BuildingMuteAlert_DropList_Reason()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "Reason",
                    Parent = "PanelMuteReason",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_ALERT_PANEL_REASON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_REASON%", Color = "0 0 0 0" },
                    Text = { Text = "%REASON%", Align = TextAnchor.MiddleCenter, FontSize = 13, Color = "1 1 1 1" }
                }, "Reason");

                AddInterface("UI_Chat_Mute_Alert_DropList_Reason", container.ToJson());
            }
            
                        private void BuildingIgnoreAlert()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "AlertIgnore",
                    Parent = "MUTE_AND_IGNORE_PANEL_ALERT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_PANEL") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-236.5 -134", OffsetMax = "236.5 134" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreIcon",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.5 64.8", OffsetMax = "66.5 198.8" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreTitle",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 22, Align = TextAnchor.UpperCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-231 -55.00", OffsetMax = "229.421 33.98" } //
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreYes",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_YES") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-178 -115", OffsetMax = "-22 -77" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "MUTE_AND_IGNORE_PANEL_ALERT", Command = "%COMMAND%", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_YES%", Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "0.1294118 0.145098 0.1647059 1" }
                }, "AlertIgnoreYes", "BUTTON_YES");

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreNo",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_NO") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22 -115", OffsetMax = "178 -77" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "MUTE_AND_IGNORE_PANEL_ALERT", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_NO%", Align = TextAnchor.MiddleCenter, FontSize = 18 }
                }, "AlertIgnoreNo", "BUTTON_NO");

                AddInterface("UI_Chat_Ignore_Alert", container.ToJson());
            }
            
            
            
            
            private void BuildingDropList()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "DropListIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                            new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PREFIX_MULTI_TAKE_ICON")},
                      new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                        }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListDescription",
                    Parent = "DropListIcon",
                    Components = {
                            new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-105.5 -13.948", OffsetMax = "-42.615 1.725" }
                        }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%BUTTON_DROP_LIST_CMD%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListIcon", "DropListIcon_Button");

                AddInterface("UI_Chat_DropList", container.ToJson());
            }

            private void BuildingOpenDropList()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "OpenDropList",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_DROP_LIST_OPEN_ICON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 -17.38", OffsetMax = "155.093 109.1" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListName",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-140.329 44.5", OffsetMax = "-40.329 58.312" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListDescription",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiTextComponent { Text = "%DESCRIPTION%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-140.329 32.993", OffsetMax = "-40.329 42.77" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListClose",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PREFIX_MULTI_TAKE_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "113 32.2", OffsetMax = "145 56.2" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "OpenDropList", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListClose", "DropListClose_Button");

                container.Add(new CuiElement
                {
                    Name = "DropListPageRight",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR_RIGHT%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_RIGHT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "100 38", OffsetMax = "105.2 48" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%NEXT_BTN%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListPageRight", "DropListPageRight_Button");

                container.Add(new CuiElement
                {
                    Name = "DropListPageLeft",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { Color ="%COLOR_LEFT%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_LEFT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "86 38", OffsetMax = "91.2 48" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%BACK_BTN%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListPageLeft", "DropListPageLeft_Button");

                AddInterface("UI_Chat_OpenDropList", container.ToJson());
            }

            private void BuildingElementDropList()
            {
                CuiElementContainer container = new CuiElementContainer();
                String Name = "ArgumentDropList_%COUNT%";

                container.Add(new CuiElement
                {
                    Name = Name,
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { FadeIn = 0.3f, Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_DROP_LIST_OPEN_ARGUMENT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-37.529 -12.843", OffsetMax = "37.528 12.842" },
                    Button = { FadeIn = 0.3f, Command = "%TAKE_COMMAND_ARGUMENT%", Color = "0 0 0 0" },
                    Text = { FadeIn = 0.3f, Text = "%ARGUMENT%", Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                }, Name, "ArgumentButton");

                AddInterface("UI_Chat_OpenDropListArgument", container.ToJson());
            }

            private void BuildingElementDropListTakeLine()
            {
                CuiElementContainer container = new CuiElementContainer();
                String Parent = "ArgumentDropList_%COUNT%";

                container.Add(new CuiElement
                {
                    Name = "TAKED_INFO_%COUNT%",
                    Parent = Parent,
                    Components = {
                    new CuiRawImageComponent { Color = "0.3098039 0.2745098 0.572549 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_DROP_LIST_OPEN_TAKED") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-25.404 -17.357", OffsetMax = "25.403 -1.584" }
                }
                });

                AddInterface("UI_Chat_OpenDropListArgument_Taked", container.ToJson());
            }

            
                        private void BuildingModerationStatic()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ModerationLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -126.612", OffsetMax = "126.125 -112.988" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "ModerationIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MODERATION_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "141.88 -125.3", OffsetMax = "152.88 -114.3" }
                }
                });


                container.Add(new CuiElement
                {
                    Name = "ModeratorMuteMenu",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PANEL_ICON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.071 -144.188", OffsetMax = "152.881 -129.752" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.95" },
                    Button = { Command = "%COMMAND_MUTE_MENU%", Color = "0 0 0 0" },
                    Text = { Text = "%TEXT_MUTE_MENU%", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" }
                }, "ModeratorMuteMenu", "ModeratorMuteMenu_Btn");


                AddInterface("UI_Chat_Moderation", container.ToJson());
            }
            private void BuildingMuteAllChat()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ModeratorMuteAllChat",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PANEL_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.07 -161.818", OffsetMax = "152.88 -147.382" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.95" },
                    Button = { Command = "%COMMAND_MUTE_ALLCHAT%", Color = "0 0 0 0" },
                    Text = { Text = "%TEXT_MUTE_ALLCHAT%", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" }
                }, "ModeratorMuteAllChat", "ModeratorMuteAllChat_Btn");

                AddInterface("UI_Chat_Administation_AllChat", container.ToJson());
            }
            private void BuildingMuteAllVoice()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ModeratorMuteAllVoice",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PANEL_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -179.448", OffsetMax = "152.885 -165.012" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.95" },
                    Button = { Command = "%COMMAND_MUTE_ALLVOICE%", Color = "0 0 0 0" },
                    Text = { Text = "%TEXT_MUTE_ALLVOICE%", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" }
                }, "ModeratorMuteAllVoice", "ModeratorMuteAllVoice_Btn");

                AddInterface("UI_Chat_Administation_AllVoce", container.ToJson());
            }

            
            
                        private void BuildingAlertUI()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = UI_Chat_Alert,
                    Parent = "Overlay",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ALERT_PANEL") },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "0 -136.5", OffsetMax = "434 -51.5" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertTitle",
                    Parent = UI_Chat_Alert,
                    Components = {
                    new CuiTextComponent { Text = "<b>%TITLE%</b>", Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-184.193 9.119", OffsetMax = "189.223 30.925" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertText",
                    Parent = UI_Chat_Alert,
                    Components = {
                    new CuiTextComponent { Text = "%DESCRIPTION%", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-184.193 -27.133", OffsetMax = "189.223 9.119" }
                }
                });

                AddInterface("UI_Chat_Alert", container.ToJson());
            }
                    }

        public string FindFakeName(ulong userID) => (string)IQFakeActive?.Call("FindFakeName", userID);
        String IQRankGetTimeGame(ulong userID) => (string)(IQRankSystem?.Call("API_GET_TIME_GAME", userID));

        [ConsoleCommand("online")]
        private void ShowPlayerOnlineConsole(ConsoleSystem.Arg arg)
        {
            if (!config.OtherSetting.UseCommandOnline) return;

            BasePlayer player = arg.Player();
            List<String> PlayerNames = GetPlayersOnline();
            String Message = GetLang("IQCHAT_INFO_ONLINE", player != null ? player.UserIDString : null, String.Join($"\n", PlayerNames));

            if (player != null)
                player.ConsoleMessage(Message);
            else
            {
                String Pattern = @"</?size.*?>|</?color.*?>";
                String Messages = Regex.IsMatch(Message, Pattern) ? Regex.Replace(Message, Pattern, "") : Message;
                Puts(Messages);
            }
        }
        
        
                private void DrawUI_IQChat_Ignore_Alert(BasePlayer player, BasePlayer Target, UInt64 IDFake = 0)
        {
            String InterfacePanel = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Alert_Panel");
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Ignore_Alert");
            if (Interface == null || InterfacePanel == null) return;

            GeneralInformation.RenameInfo Renamer = (IQFakeActive && Target == null && IDFake != 0) ? null : GeneralInfo.GetInfoRename(Target.userID);
            String NickNamed = (IQFakeActive && Target == null && IDFake != 0) ? FindFakeName(IDFake) : Renamer != null ? $"{Renamer.RenameNick ?? Target.displayName}" : Target.displayName;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Interface = Interface.Replace("%TITLE%", GetLang(UserInformation[player.userID].Settings.IsIgnored((IQFakeActive && Target == null && IDFake != 0) ? IDFake : Target.userID) ? "IQCHAT_TITLE_IGNORE_TITLES_UNLOCK" : "IQCHAT_TITLE_IGNORE_TITLES", player.UserIDString, NickNamed));
            Interface = Interface.Replace("%BUTTON_YES%", GetLang("IQCHAT_TITLE_IGNORE_BUTTON_YES", player.UserIDString));
            Interface = Interface.Replace("%BUTTON_NO%", GetLang("IQCHAT_TITLE_IGNORE_BUTTON_NO", player.UserIDString));
            Interface = Interface.Replace("%COMMAND%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Ignore} confirm.yes {((IQFakeActive && Target == null && IDFake != 0) ? IDFake : Target.userID)}");

            CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
            CuiHelper.AddUi(player, InterfacePanel);
            CuiHelper.AddUi(player, Interface);
        }
        private void DrawUI_IQChat_OpenDropList(BasePlayer player, TakeElementUser ElementType, Int32 Page = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_OpenDropList");
            if (Interface == null) return;

            if (!LocalBase.ContainsKey(player)) return;

            String Title = String.Empty;
            String Description = String.Empty;
            List<Configuration.ControllerParameters.AdvancedFuncion> InfoUI = new List<Configuration.ControllerParameters.AdvancedFuncion>();

            switch (ElementType)
            {
                case TakeElementUser.MultiPrefix:
                case TakeElementUser.Prefix:
                    {
                        InfoUI = LocalBase[player].ElementsPrefix;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_PREFIX", player.UserIDString);
                        break;
                    }
                case TakeElementUser.Nick:
                    {
                        InfoUI = LocalBase[player].ElementsNick;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_NICK", player.UserIDString);
                        break;
                    }
                case TakeElementUser.Chat:
                    {
                        InfoUI = LocalBase[player].ElementsChat;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_CHAT", player.UserIDString);
                        break;
                    }
                case TakeElementUser.Rank:
                    {
                        InfoUI = LocalBase[player].ElementsRanks;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_RANK", player.UserIDString);
                        break;
                    }
                default:
                    break;
            }

            //  if (InfoUI == null || InfoUI.Count == 0) return;

            Interface = Interface.Replace("%TITLE%", Title);
            Interface = Interface.Replace("%DESCRIPTION%", Description);

            String CommandRight = InfoUI.Skip(9 * (Page + 1)).Count() > 0 ? $"newui.cmd droplist.controller page.controller {ElementType} + {Page}" : String.Empty;
            String CommandLeft = Page != 0 ? $"newui.cmd droplist.controller page.controller {ElementType} - {Page}" : String.Empty;

            Interface = Interface.Replace("%NEXT_BTN%", CommandRight);
            Interface = Interface.Replace("%BACK_BTN%", CommandLeft);

            Interface = Interface.Replace("%COLOR_RIGHT%", String.IsNullOrWhiteSpace(CommandRight) ? "1 1 1 0.1" : "1 1 1 1");
            Interface = Interface.Replace("%COLOR_LEFT%", String.IsNullOrWhiteSpace(CommandLeft) ? "1 1 1 0.1" : "1 1 1 1");

            CuiHelper.DestroyUi(player, "OpenDropList");
            CuiHelper.AddUi(player, Interface);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Int32 Count = 0;
            Int32 X = 0, Y = 0;
            foreach (Configuration.ControllerParameters.AdvancedFuncion Info in InfoUI.Skip(9 * Page).Take(9))
            {
                DrawUI_IQChat_OpenDropListArgument(player, ElementType, Info, X, Y, Count);

                if (ElementType == TakeElementUser.MultiPrefix && UserInformation[player.userID].Info.PrefixList.Contains(Info.Argument))
                    DrawUI_IQChat_OpenDropListArgument(player, Count);

                Count++;
                X++;
                if (X == 3)
                {
                    X = 0;
                    Y++;
                }
            }
        }
        
        
        
        
        public List<String> GetMesagesList(BasePlayer player, Dictionary<String, List<String>> LanguageMessages)
        {
            String LangPlayer = _.lang.GetLanguage(player.UserIDString);

            if (LanguageMessages.ContainsKey(LangPlayer))
                return LanguageMessages[LangPlayer];
            else if (LanguageMessages.ContainsKey("en"))
                return LanguageMessages["en"];
            else return LanguageMessages.FirstOrDefault().Value;
        }
        private const String PermissionAlert = "iqchat.alertuse";

        
        private BasePlayer GetPlayerNickOrID(String Info)
        {
            String NameOrID = String.Empty;

            KeyValuePair<UInt64, GeneralInformation.RenameInfo> RenameInformation = GeneralInfo.RenameList.FirstOrDefault(x => x.Value.RenameNick.Contains(Info) || x.Value.RenameID.ToString() == Info);
            if (RenameInformation.Value == null)
                NameOrID = Info;
            else NameOrID = RenameInformation.Key.ToString();

            foreach (BasePlayer Finder in BasePlayer.activePlayerList)
            {
                if (Finder.displayName.ToLower().Contains(NameOrID.ToLower()) || Finder.userID.ToString() == NameOrID)
                    return Finder;
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            return null;
        }
        private void DrawUI_IQChat_OpenDropListArgument(BasePlayer player, Int32 Count)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_OpenDropListArgument_Taked");
            if (Interface == null) return;

            Interface = Interface.Replace("%COUNT%", Count.ToString());

            CuiHelper.DestroyUi(player, $"TAKED_INFO_{Count}");
            CuiHelper.AddUi(player, Interface);
        }
        
        
        [ChatCommand("chat")]
        private void ChatCommandOpenedUI(BasePlayer player)
        {
            if (_interface == null)
            {
                PrintWarning(LanguageEn ? "We generate the interface, wait for a message about successful generation" : " ,     ");
                return;
            }
            if (player == null) return;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Configuration.ControllerParameters ControllerParameters = config.ControllerParameter;

            if (!LocalBase.ContainsKey(player))
                LocalBase.Add(player, new InformationOpenedUI { });

            LocalBase[player].ElementsPrefix = ControllerParameters.Prefixes.Prefixes.OrderByDescending(arg => arg.Argument.Length).Where(p => permission.UserHasPermission(player.UserIDString, p.Permissions) && !p.IsBlockSelected).ToList();
            LocalBase[player].ElementsNick = ControllerParameters.NickColorList.Where(n => permission.UserHasPermission(player.UserIDString, n.Permissions) && !n.IsBlockSelected).ToList();
            LocalBase[player].ElementsChat = ControllerParameters.MessageColorList.Where(m => permission.UserHasPermission(player.UserIDString, m.Permissions) && !m.IsBlockSelected).ToList();

            if (IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem)
            {
                List<Configuration.ControllerParameters.AdvancedFuncion> RankList = new List<Configuration.ControllerParameters.AdvancedFuncion>();
                foreach (String Rank in IQRankListKey(player.userID))
                    RankList.Add(new Configuration.ControllerParameters.AdvancedFuncion { Argument = Rank, Permissions = String.Empty });

                LocalBase[player].ElementsRanks = RankList;
            }

            DrawUI_IQChat_Context(player);
        }
        String API_GET_CHAT_COLOR(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return String.Empty;

            return UserInformation[ID].Info.ColorMessage;
        }
        private class InformationOpenedUI
        {
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsPrefix;
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsNick;
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsChat;
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsRanks;
            public Int32 SlideIndexPrefix = 0;
            public Int32 SlideIndexNick = 0;
            public Int32 SlideIndexChat = 0;
            public Int32 SlideIndexRank = 0;
        }
        public String FormatTime(Double Second, String UserID = null)
        {
            TimeSpan time = TimeSpan.FromSeconds(Second);
            String Result = String.Empty;
            String Days = GetLang("TITLE_FORMAT_DAYS", UserID);
            String Hourse = GetLang("TITLE_FORMAT_HOURSE", UserID);
            String Minutes = GetLang("TITLE_FORMAT_MINUTES", UserID);
            String Seconds = GetLang("TITLE_FORMAT_SECONDS", UserID);

            if (time.Seconds != 0)
                Result = $"{Format(time.Seconds, Seconds, Seconds, Seconds)}";

            if (time.Minutes != 0)
                Result = $"{Format(time.Minutes, Minutes, Minutes, Minutes)}";

            if (time.Hours != 0)
                Result = $"{Format(time.Hours, Hourse, Hourse, Hourse)}";

            if (time.Days != 0)
                Result = $"{Format(time.Days, Days, Days, Days)}";

            return Result;
        }
        
        
        [ChatCommand("pm")]
        void PmChat(BasePlayer Sender, String cmd, String[] arg)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;
            if (!ControllerMessages.TurnedFunc.PMSetting.PMActivate) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Sender, lang.GetMessage("COMMAND_PM_NOTARG", this, Sender.UserIDString));
                return;
            }

            Configuration.ControllerMessage.TurnedFuncional.AntiNoob.Settings antiNoob = config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM;
            if (antiNoob.AntiNoobActivate)
                if (IsNoob(Sender.userID, antiNoob.TimeBlocked))
                {
                    ReplySystem(Sender, GetLang("IQCHAT_INFO_ANTI_NOOB_PM", Sender.UserIDString, FormatTime(UserInformationConnection[Sender.userID].LeftTime(antiNoob.TimeBlocked), Sender.UserIDString)));
                    return;
                }

            String NameUser = arg[0];

            if (config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive)
                if (IQFakeActive)
                    if (IsFake(NameUser))
                    {
                        ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, string.Join(" ", arg.ToArray()).Replace(NameUser, ""), NameUser));
                        return;
                    }

            BasePlayer TargetUser = GetPlayerNickOrID(NameUser);
            if (TargetUser == null || NameUser == null || !UserInformation.ContainsKey(TargetUser.userID))
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_USER", Sender.UserIDString));
                return;
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            User InfoTarget = UserInformation[TargetUser.userID];
            User InfoSender = UserInformation[Sender.userID];
            if (!InfoTarget.Settings.TurnPM)
            {
                ReplySystem(Sender, GetLang("FUNC_MESSAGE_PM_TURN_FALSE", Sender.UserIDString));
                return;
            }

            if (ControllerMessages.TurnedFunc.IgnoreUsePM)
            {
                if (InfoTarget.Settings.IsIgnored(Sender.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM", Sender.UserIDString));
                    return;
                }
                if (InfoSender.Settings.IsIgnored(TargetUser.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM_ME", Sender.UserIDString));
                    return;
                }
            }
            String Message = GetMessageInArgs(Sender, arg.Skip(1).ToArray());

            if (Message == null || Message.Length <= 0)
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_NULL_MSG", Sender.UserIDString));
                return;
            }
            Message = Message.EscapeRichText();

            if (Message.Length > 125) return;

            PMHistory[TargetUser] = Sender;
            PMHistory[Sender] = TargetUser;

            GeneralInformation.RenameInfo RenamerSender = GeneralInfo.GetInfoRename(Sender.userID);
            GeneralInformation.RenameInfo RenamerTarget = GeneralInfo.GetInfoRename(TargetUser.userID);

            String DisplayNameSender = RenamerSender != null ? RenamerSender.RenameNick ?? Sender.displayName : Sender.displayName;
            String TargetDisplayName = RenamerTarget != null ? RenamerTarget.RenameNick ?? TargetUser.displayName : TargetUser.displayName;
            ReplySystem(TargetUser, GetLang("COMMAND_PM_SEND_MSG", TargetUser.UserIDString, DisplayNameSender, Message));
            ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, Message, TargetDisplayName));

            if (InfoTarget.Settings.TurnSound)
                Effect.server.Run(ControllerMessages.TurnedFunc.PMSetting.SoundPM, TargetUser.GetNetworkPosition());

            Log(LanguageEn ? $"PRIVATE MESSAGES : {Sender.userID}({Sender.displayName}) sent a message to the player - {TargetUser.displayName}({TargetDisplayName})\nMESSAGE : {Message}" : $"  : {Sender.userID}({Sender.displayName})    - {TargetUser.displayName}({TargetDisplayName})\n : {Message}");
            DiscordLoggPM(Sender, TargetUser, Message);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName}({Sender.userID}) -> {TargetUser.displayName} : MESSAGE : {Message}" : $"  : {Sender.displayName}({Sender.userID}) -> {TargetUser.displayName} :  : {Message}",
                UserId = Sender.UserIDString,
                Username = Sender.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning(LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName}({Sender.userID}) -> {TargetUser.displayName} : MESSAGE : {Message}" : $"  : {Sender.displayName}({Sender.userID}) -> {TargetUser.displayName} :  : {Message}");
        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
        
        
                private const Boolean LanguageEn = false;

        
                void ReplyChat(Chat.ChatChannel channel, BasePlayer player, String OutMessage, String FormatPlayer)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;

            User Info = UserInformation[player.userID];
            GeneralInformation.RenameInfo RenameInfo = GeneralInfo.GetInfoRename(player.userID);
            UInt64 RenameID = RenameInfo != null ? RenameInfo.RenameID != 0 ? RenameInfo.RenameID : player.userID : player.userID;

            if (channel == Chat.ChatChannel.Global)
            {
                foreach (BasePlayer p in BasePlayer.activePlayerList)
                {
                    if (OutMessage.Contains("@"))
                    {
                        String SplittedName = OutMessage.Substring(OutMessage.IndexOf('@')).Replace("@", "").Split(' ')[0];

                        BasePlayer playerTags = GetPlayerNickOrID(SplittedName);

                        if (playerTags != null)
                        {
                            User InfoP = UserInformation[playerTags.userID];

                            if (InfoP.Settings.TurnAlert && p == playerTags)
                            {
                                ReplySystem(p, $"<size=16>{OutMessage.Trim()}</size>", GetLang("IQCHAT_FUNCED_ALERT_TITLE", p.UserIDString), p.UserIDString, ControllerMessages.GeneralSetting.AlertFormat.AlertPlayerColor);
                                if (InfoP.Settings.TurnSound)
                                    Effect.server.Run(ControllerMessages.GeneralSetting.AlertFormat.SoundAlertPlayer, playerTags.GetNetworkPosition());
                            }
                            else p.SendConsoleCommand("chat.add", (int)channel, RenameID, $"{FormatPlayer}: {OutMessage}");
                            //else p.SendConsoleCommand("chat.add", new object[] { (int)channel, RenameID, OutMessage });
                        }
                        else p.SendConsoleCommand("chat.add", (int)channel, RenameID, $"{FormatPlayer}: {OutMessage}");
                    }
                    else p.SendConsoleCommand("chat.add", (int)channel, RenameID, $"{FormatPlayer}: {OutMessage}");

                    p.ConsoleMessage($"{FormatPlayer} {OutMessage}");
                }
            }
            if (channel == Chat.ChatChannel.Team)
            {
                RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (Team == null) return;
                foreach (var FindPlayers in Team.members)
                {
                    BasePlayer TeamPlayer = BasePlayer.FindByID(FindPlayers);
                    if (TeamPlayer == null) continue;

                    TeamPlayer.SendConsoleCommand("chat.add", (int)channel, RenameID, $"{FormatPlayer}: {OutMessage}");
                }
            }
            if (channel == Chat.ChatChannel.Cards)
            {
                if (!player.isMounted)
                    return;

                CardTable cardTable = player.GetMountedVehicle() as CardTable;
                if (cardTable == null || !cardTable.GameController.PlayerIsInGame(player))
                    return;

                List<Network.Connection> PlayersCards = new List<Network.Connection>();
                cardTable.GameController.GetConnectionsInGame(PlayersCards);
                if (PlayersCards == null || PlayersCards.Count == 0)
                    return;

                foreach (Network.Connection PCard in PlayersCards)
                {
                    BasePlayer PlayerInRound = BasePlayer.FindByID(PCard.userid);
                    if (PlayerInRound == null) return;
                    PlayerInRound.SendConsoleCommand("chat.add", (int)channel, RenameID, $"{FormatPlayer}: {OutMessage}");
                }
            }
        }
        public List<String> KeyImages = new List<String>
        {
            "UI_IQCHAT_CONTEXT_NO_RANK",
            "UI_IQCHAT_CONTEXT_RANK",
            "IQCHAT_INFORMATION_ICON",
            "IQCHAT_SETTING_ICON",
            "IQCHAT_IGNORE_INFO_ICON",
            "IQCHAT_MODERATION_ICON",
            "IQCHAT_ELEMENT_PANEL_ICON",
            "IQCHAT_ELEMENT_PREFIX_MULTI_TAKE_ICON",
            "IQCHAT_ELEMENT_SLIDER_ICON",
            "IQCHAT_ELEMENT_SLIDER_LEFT_ICON",
            "IQCHAT_ELEMENT_SLIDER_RIGHT_ICON",
            "IQCHAT_ELEMENT_DROP_LIST_OPEN_ICON",
            "IQCHAT_ELEMENT_DROP_LIST_OPEN_ARGUMENT_ICON",
            "IQCHAT_ELEMENT_DROP_LIST_OPEN_TAKED",
            "IQCHAT_ELEMENT_SETTING_CHECK_BOX",
            "IQCHAT_ALERT_PANEL",
            "IQCHAT_MUTE_AND_IGNORE_PANEL",
            "IQCHAT_MUTE_AND_IGNORE_ICON",
            "IQCHAT_MUTE_AND_IGNORE_SEARCH",
            "IQCHAT_MUTE_AND_IGNORE_PAGE_PANEL",
            "IQCHAT_MUTE_AND_IGNORE_PLAYER",
            "IQCHAT_MUTE_AND_IGNORE_PLAYER_STATUS",
            "IQCHAT_IGNORE_ALERT_PANEL",
            "IQCHAT_IGNORE_ALERT_ICON",
            "IQCHAT_IGNORE_ALERT_BUTTON_YES",
            "IQCHAT_IGNORE_ALERT_BUTTON_NO",
            "IQCHAT_MUTE_ALERT_PANEL",
            "IQCHAT_MUTE_ALERT_ICON",
            "IQCHAT_MUTE_ALERT_PANEL_REASON",
        };
        public Dictionary<BasePlayer, BasePlayer> PMHistory = new Dictionary<BasePlayer, BasePlayer>();
        
        private void DrawUI_IQChat_Mute_And_Ignore(BasePlayer player, SelectedAction Action)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE%", Action == SelectedAction.Mute ? GetLang("IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED", player.UserIDString) : GetLang("IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED", player.UserIDString));
            Interface = Interface.Replace("%ACTION_TYPE%", $"{Action}");

            CuiHelper.DestroyUi(player, "MuteAndIgnoredPanel");
            CuiHelper.AddUi(player, Interface);

            DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, Action);
        }
        void OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            DiscordLoggCommand(player, command, args);
        }

                
        private String GetClanTag(UInt64 playerID)
        {
            if (!Clans) return String.Empty;
            if (!config.ReferenceSetting.ClansSettings.UseClanTag) return String.Empty;
            String ClanTag = (String)Clans?.CallHook("GetClanOf", playerID);

            return String.IsNullOrWhiteSpace(ClanTag) ? String.Empty : GetLang("CLANS_SYNTAX_PREFIX", playerID.ToString(), ClanTag);
        }

        [ConsoleCommand("hunmute")]
        void HideUnMuteConsole(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;
            if (arg == null || arg.Args == null || arg.Args.Length != 1 || arg.Args.Length > 1)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, please use : hunmute Steam64ID" : " , : hunmute Steam64ID");
                return;
            }
            string NameOrID = arg.Args[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ConsoleOrPrintMessage(arg.Player(),
                                LanguageEn ? "The player does not have a chat lock" : "    ");
                            return;
                        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                        Info.MuteInfo.UnMute(MuteType.Chat);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "You have unblocked the offline chat to the player" : "   offline ");
                        return;
                    }
                    else
                    {
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "This player is not on the server" : "    ");
                        return;
                    }
                }
                else
                {
                    ConsoleOrPrintMessage(arg.Player(),
                        LanguageEn ? "This player is not on the server" : "    ");
                    return;
                }
            }

            UnmutePlayer(target, MuteType.Chat, arg.Player(), true, true);
        }
        [ConsoleCommand("adminalert")]
        private void AdminAlertConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            Alert(Sender, args.Args, true);
        }
        private const String PermissionMute = "iqchat.muteuse";
        private void DrawUI_IQChat_Update_MuteVoice_All(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionMutedAdmin)) return;

            String InterfaceAdministratorVoice = InterfaceBuilder.GetInterface("UI_Chat_Administation_AllVoce");
            if (InterfaceAdministratorVoice == null) return;

            InterfaceAdministratorVoice = InterfaceAdministratorVoice.Replace("%TEXT_MUTE_ALLVOICE%", GetLang(!GeneralInfo.TurnMuteAllVoice ? "IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE" : "IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE", player.UserIDString));
            InterfaceAdministratorVoice = InterfaceAdministratorVoice.Replace("%COMMAND_MUTE_ALLVOICE%", $"newui.cmd action.mute.ignore mute.controller {SelectedAction.Mute} mute.all.voice");

            CuiHelper.DestroyUi(player, "ModeratorMuteAllVoice");
            CuiHelper.AddUi(player, InterfaceAdministratorVoice);
        }
        private string StripHtmlTags(string input)
        {
            return Regex.Replace(input, "<.*?>", String.Empty);
        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
        
                void OnGroupPermissionGranted(string name, string perm)
        {
            String[] PlayerGroups = permission.GetUsersInGroup(name);
            if (PlayerGroups == null) return;

            foreach (String playerInfo in PlayerGroups)
            {
                BasePlayer player = BasePlayer.FindByID(UInt64.Parse(playerInfo.Substring(0, 17)));
                if (player == null) return;

                SetupParametres(player.UserIDString, perm);
            }
        }

        [ChatCommand("ignore")]
        void IgnorePlayerPM(BasePlayer player, String cmd, String[] arg)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;
            if (!ControllerMessages.TurnedFunc.IgnoreUsePM) return;

            User Info = UserInformation[player.userID];

            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(player, GetLang("INGORE_NOTARG", player.UserIDString));
                return;
            }
            String NameUser = arg[0];
            BasePlayer TargetUser = BasePlayer.Find(NameUser);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (TargetUser == null || NameUser == null)
            {
                ReplySystem(player, GetLang("COMMAND_PM_NOT_USER", player.UserIDString));
                return;
            }

            String Lang = !Info.Settings.IsIgnored(TargetUser.userID) ? GetLang("IGNORE_ON_PLAYER", player.UserIDString, TargetUser.displayName) : GetLang("IGNORE_OFF_PLAYER", player.UserIDString, TargetUser.displayName);
            ReplySystem(player, Lang);

            Info.Settings.IgnoredAddOrRemove(TargetUser.userID);
        }

        private void DrawUI_IQChat_Mute_And_Ignore_Player_Panel(BasePlayer player, SelectedAction Action, Int32 Page = 0, String SearchName = null)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Panel_Content");
            if (Interface == null) return;

            CuiHelper.DestroyUi(player, "MuteIgnorePanelContent");
            CuiHelper.AddUi(player, Interface);

            if (IQFakeActive)
            {
                var FakePlayerList = Action == SelectedAction.Mute ? SearchName != null ? PlayerBases.Where(p => p.DisplayName.ToLower().Contains(SearchName.ToLower())).OrderByDescending(p => !IsFake(p.UserID) && UserInformation.ContainsKey(p.UserID) && (UserInformation[p.UserID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[p.UserID].MuteInfo.IsMute(MuteType.Voice))) : PlayerBases.OrderByDescending(p => !IsFake(p.UserID) && UserInformation.ContainsKey(p.UserID) && (UserInformation[p.UserID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[p.UserID].MuteInfo.IsMute(MuteType.Voice))) :
                                                                            SearchName != null ? PlayerBases.Where(p => p.DisplayName.ToLower().Contains(SearchName.ToLower())).OrderByDescending(p => !IsFake(p.UserID) && UserInformation.ContainsKey(p.UserID) && (UserInformation[player.userID].Settings.IgnoreUsers.Contains(p.UserID))) : PlayerBases.OrderByDescending(p => !IsFake(p.UserID) && UserInformation.ContainsKey(p.UserID) && (UserInformation[player.userID].Settings.IgnoreUsers.Contains(p.UserID)));

                DrawUI_IQChat_Mute_And_Ignore_Pages(player, (Boolean)(FakePlayerList.Skip(18 * (Page + 1)).Count() > 0), Action, Page);
                DrawUI_IQChat_Mute_And_Ignore_Player(player, Action, null, FakePlayerList.Skip(18 * Page).Take(18));
            }
            else
            {
                IOrderedEnumerable<BasePlayer> PlayerList = Action == SelectedAction.Mute ? SearchName != null ? BasePlayer.activePlayerList.Where(p => UserInformation.ContainsKey(p.userID) && p.displayName.ToLower().Contains(SearchName.ToLower())).OrderBy(p => UserInformation[p.userID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[p.userID].MuteInfo.IsMute(MuteType.Voice)) : BasePlayer.activePlayerList.Where(p => UserInformation.ContainsKey(p.userID)).OrderBy(p => UserInformation[p.userID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[p.userID].MuteInfo.IsMute(MuteType.Voice)) :
                                                                         SearchName != null ? BasePlayer.activePlayerList.Where(p => UserInformation.ContainsKey(p.userID) && p.displayName.ToLower().Contains(SearchName.ToLower())).OrderBy(p => UserInformation[player.userID].Settings.IgnoreUsers.Contains(p.userID)) : BasePlayer.activePlayerList.Where(p => UserInformation.ContainsKey(p.userID)).OrderBy(p => UserInformation[player.userID].Settings.IgnoreUsers.Contains(p.userID));

                DrawUI_IQChat_Mute_And_Ignore_Pages(player, (Boolean)(PlayerList.Skip(18 * (Page + 1)).Count() > 0), Action, Page);
                DrawUI_IQChat_Mute_And_Ignore_Player(player, Action, PlayerList.Skip(18 * Page).Take(18));
            }
        }
        void API_ALERT_PLAYER(BasePlayer player, String Message, String CustomPrefix = null, String CustomAvatar = null, String CustomHex = null) => ReplySystem(player, Message, CustomPrefix, CustomAvatar, CustomHex);
        public String GetMessages(BasePlayer player, Dictionary<String, List<String>> LanguageMessages)
        {
            String LangPlayer = _.lang.GetLanguage(player.UserIDString);

            if (LanguageMessages.ContainsKey(LangPlayer))
                return LanguageMessages[LangPlayer].GetRandom();
            else if (LanguageMessages.ContainsKey("en"))
                return LanguageMessages["en"].GetRandom();
            else return LanguageMessages.FirstOrDefault().Value.GetRandom();
        }
        private void AlertController(BasePlayer player)
        {
            Configuration.ControllerAlert.Alert Alert = config.ControllerAlertSetting.AlertSetting;
            Configuration.ControllerAlert.AdminSession AlertSessionAdmin = config.ControllerAlertSetting.AdminSessionSetting;
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;
            Configuration.ControllerAlert.PersonalAlert AlertPersonal = config.ControllerAlertSetting.PersonalAlertSetting;
            GeneralInformation.RenameInfo RenameInformation = GeneralInfo.GetInfoRename(player.userID);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            String DisplayName = player.displayName;

            UInt64 UserID = player.userID;
            if (RenameInformation != null)
            {
                DisplayName = RenameInformation.RenameNick;
                UserID = RenameInformation.RenameID;
            }

            if (AlertSessionPlayer.ConnectedAlert)
            {
                if (!AlertSessionAdmin.ConnectedAlertAdmin)
                    if (player.IsAdmin) return;

                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? UserID.ToString() : String.Empty;

                if (AlertSessionPlayer.ConnectedWorld)
                {
                    String ipPlayer = player.IPlayer.Address;

                    if (player.net?.connection != null)
                    {
                        String[] ipPortPlayer = player.net.connection.ipaddress.Split(':');
                        if (ipPortPlayer.Length >= 1)
                            ipPlayer = ipPortPlayer[0]; 
                    }
                    
                    webrequest.Enqueue("http://ip-api.com/json/" + ipPlayer, null, (code, response) =>
                    {
                        if (code != 200 || response == null)
                            return;

                        String country = JsonConvert.DeserializeObject<Response>(response).Country;

                        if (!permission.UserHasPermission(player.UserIDString, PermissionHideConnection))
                        {
                            if (AlertSessionPlayer.ConnectionAlertRandom)
                                ReplyBroadcast(null, Avatar, false, AlertSessionPlayer.RandomConnectionAlert.LanguageMessages,DisplayName, country ?? "none");
                            else ReplyBroadcast(null, Avatar, false, "WELCOME_PLAYER_WORLD", DisplayName, country ?? "none");
                        }

                        Log($"[{player.userID}] {GetLang("WELCOME_PLAYER_WORLD", "", DisplayName, country ?? "none")}");
                    }, this);
                }
                else
                {
                    if (!permission.UserHasPermission(player.UserIDString, PermissionHideConnection))
                    {
                        if (AlertSessionPlayer.ConnectionAlertRandom)
                            ReplyBroadcast(null, Avatar, false,AlertSessionPlayer.RandomConnectionAlert.LanguageMessages, DisplayName);
                        else ReplyBroadcast(null, Avatar, false, "WELCOME_PLAYER", DisplayName);
                    }

                    Log($"[{player.userID}] {GetLang("WELCOME_PLAYER", "", DisplayName)}");
                }
            }
            if (AlertPersonal.UseWelcomeMessage)
            {
                String WelcomeMessage = GetMessages(player, AlertPersonal.WelcomeMessage.LanguageMessages);
                ReplySystem(player, WelcomeMessage);
            }
        }
        private enum ElementsSettingsType
        {
            PM,
            Broadcast,
            Alert,
            Sound
        }
        private void DrawUI_IQChat_Mute_Alert_Reasons(BasePlayer player, BasePlayer Target, MuteType Type, UInt64 IDFake = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_Alert_DropList_Title");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE%", GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON", player.UserIDString));

            CuiHelper.DestroyUi(player, "AlertMuteTitleReason");
            CuiHelper.DestroyUi(player, "PanelMuteReason");
            CuiHelper.AddUi(player, Interface);

            List<Configuration.ControllerMute.Muted> Reasons = Type == MuteType.Chat ? config.ControllerMutes.MuteChatReasons : config.ControllerMutes.MuteVoiceReasons;

            Int32 Y = 0;
            foreach (Configuration.ControllerMute.Muted Reason in Reasons.Take(6))
                DrawUI_IQChat_Mute_Alert_Reasons(player, Target, Reason.Reason, Y++, Type, IDFake);
        }

        private String GetReferenceTags(BasePlayer player)
        {
            String Result = String.Empty;
            String Rank = String.Empty;
            String RankTime = String.Empty;
            if (IQRankSystem)
            {
                Configuration.ReferenceSettings.IQRankSystem IQRank = config.ReferenceSetting.IQRankSystems;

                if (IQRank.UseRankSystem)
                {
                    if (IQRank.UseTimeStandart)
                        RankTime = String.IsNullOrWhiteSpace(IQRankGetTimeGame(player.userID)) ? String.Empty : String.Format(IQRank.FormatRank, IQRankGetTimeGame(player.userID));
                    Rank = String.IsNullOrWhiteSpace(IQRankGetRank(player.userID)) ? String.Empty : String.Format(IQRank.FormatRank, IQRankGetRank(player.userID));

                    if (!String.IsNullOrWhiteSpace(RankTime))
                        Result += $"{RankTime} ";
                    if (!String.IsNullOrWhiteSpace(Rank))
                        Result += $"{Rank} ";
                }
            }

            String XLevel = config.ReferenceSetting.XLevelsSettings.UseFullXLevels ? XLevel_GetPrefix(player) : XLevel_GetLevel(player);
            if (!String.IsNullOrWhiteSpace(XLevel))
                Result += $"{XLevel} ";

            String ClanTag = GetClanTag(player.userID);
            if (!String.IsNullOrWhiteSpace(ClanTag))
                Result += $"{ClanTag} ";

            return Result;
        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
        private void UnmutePlayer(BasePlayer Target, MuteType Type, BasePlayer Moderator = null, Boolean HideUnmute = false, Boolean Command = false)
        {
            if (!UserInformation.ContainsKey(Target.userID)) return;
            User Info = UserInformation[Target.userID];

            GeneralInformation.RenameInfo TargetRename = GeneralInfo.GetInfoRename(Target.userID);
            GeneralInformation.RenameInfo ModeratorRename = Moderator != null ? GeneralInfo.GetInfoRename(Moderator.userID) : null;
            if (!Info.MuteInfo.IsMute(Type))
            {
                if (Moderator != null)
                    ReplySystem(Moderator, LanguageEn ? "The player is not banned" : "   ");
                else Puts(LanguageEn ? "The player is not banned!" : "   !");
                return;
            }

            String TargetName = TargetRename != null ? $"{TargetRename.RenameNick ?? Target.displayName}" : Target.displayName;
            String NameModerator = Moderator == null ? GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER", Target.UserIDString) : ModeratorRename != null ? $"{ModeratorRename.RenameNick ?? Moderator.displayName}" : Moderator.displayName;
            String LangMessage = Type == MuteType.Chat ? "FUNC_MESSAGE_UNMUTE_CHAT" : "FUNC_MESSAGE_UNMUTE_VOICE";

            if (!HideUnmute)
                ReplyBroadcast(null, null, false, LangMessage, NameModerator, TargetName);
               // ReplyBroadcast(GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName));
            else
            {
                if (Target != null)
                    ReplySystem(Target, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName));
                if (Moderator != null)
                    ReplySystem(Moderator, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName));
            }

            Info.MuteInfo.UnMute(Type);

            DiscordLoggMuted(Target, Type, Moderator: Moderator);
        }

        
        private void ConsoleOrPrintMessage(BasePlayer player, String Messages)
        {
            if (player != null)
                player.ConsoleMessage(Messages);
            else PrintWarning(Messages);
        }

        
                [ChatCommand("online")]
        private void ShowPlayerOnline(BasePlayer player)
        {
            if (!config.OtherSetting.UseCommandOnline) return;

            List<String> PlayerNames = GetPlayersOnline();
            String Message = GetLang("IQCHAT_INFO_ONLINE", player.UserIDString, String.Join($"\n", PlayerNames));
            ReplySystem(player, Message);
        }
        String API_GET_DEFAULT_MESSAGE_COLOR() => config.ControllerConnect.SetupDefaults.MessageDefault;

        private void DrawUI_IQChat_OpenDropListArgument(BasePlayer player, TakeElementUser ElementType, Configuration.ControllerParameters.AdvancedFuncion Info, Int32 X, Int32 Y, Int32 Count)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_OpenDropListArgument");
            if (Interface == null) return;
            String Argument = ElementType == TakeElementUser.MultiPrefix || ElementType == TakeElementUser.Prefix ? Info.Argument :
                    ElementType == TakeElementUser.Nick ? $"<color={Info.Argument}>{player.displayName}</color>" :
                    ElementType == TakeElementUser.Chat ? $"<color={Info.Argument}>{GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE", player.UserIDString)}</color>" :
                    ElementType == TakeElementUser.Rank ? IQRankGetNameRankKey(Info.Argument) : String.Empty;

            Interface = Interface.Replace("%OFFSET_MIN%", $"{-140.329 - (-103 * X)} {-2.243 + (Y * -28)}");
            Interface = Interface.Replace("%OFFSET_MAX%", $"{-65.271 - (-103 * X)} {22.568 + (Y * -28)}");
            Interface = Interface.Replace("%COUNT%", Count.ToString());
            Interface = Interface.Replace("%ARGUMENT%", Argument);
            Interface = Interface.Replace("%TAKE_COMMAND_ARGUMENT%", $"newui.cmd droplist.controller element.take {ElementType} {Count} {Info.Permissions} {Info.Argument}");

            CuiHelper.DestroyUi(player, $"ArgumentDropList_{Count}");
            CuiHelper.AddUi(player, Interface);
        }

        [ChatCommand("hmute")]
        void HideMute(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 3 || arg.Length > 3)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, use : hmute Steam64ID/Nick Reason Time(seconds)" : " , : hmute Steam64ID/  ()");
                return;
            }
            string NameOrID = arg[0];
            string Reason = arg[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg[2], out TimeMute))
            {
                ReplySystem(Moderator, LanguageEn ? "Enter the time in numbers!" : "  !");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player already has a chat lock" : "    ");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        ReplySystem(Moderator, LanguageEn ? "Chat blocking issued to offline player" : "   offline-");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "    ");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "    ");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, Moderator, Reason, TimeMute, true, true);
        }

        private String RemoveLinkText(String text)
        {
            String hrefPattern = "([A-Za-z0-9---]|https?://)[^ ]+\\.(com|lt|net|org|gg|ru||int|info|ru.com|ru.net|com.ru|net.ru||org.ru|moscow|biz||su)";
            Regex rgx = new Regex(hrefPattern, RegexOptions.IgnoreCase);

            return config.ControllerMessages.Formatting.ControllerNickname.AllowedLinkNick.Contains(rgx.Match(text).Value) ? text : rgx.Replace(text, "").Trim();
        }

        [ChatCommand("r")]
        void RChat(BasePlayer Sender, string cmd, string[] arg)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;
            if (!ControllerMessages.TurnedFunc.PMSetting.PMActivate) return;

            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Sender, GetLang("COMMAND_R_NOTARG", Sender.UserIDString));
                return;
            }

            Configuration.ControllerMessage.TurnedFuncional.AntiNoob.Settings antiNoob = config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM;
            if (antiNoob.AntiNoobActivate)
                if (IsNoob(Sender.userID, antiNoob.TimeBlocked))
                {
                    ReplySystem(Sender, GetLang("IQCHAT_INFO_ANTI_NOOB_PM", Sender.UserIDString, FormatTime(UserInformationConnection[Sender.userID].LeftTime(antiNoob.TimeBlocked), Sender.UserIDString)));
                    return;
                }

            if (!PMHistory.ContainsKey(Sender))
            {
                ReplySystem(Sender, GetLang("COMMAND_R_NOTMSG", Sender.UserIDString));
                return;
            }

            BasePlayer RetargetUser = PMHistory[Sender];
            if (RetargetUser == null)
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_USER", Sender.UserIDString));
                return;
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            User InfoRetarget = UserInformation[RetargetUser.userID];
            User InfoSender = UserInformation[RetargetUser.userID];

            if (!InfoRetarget.Settings.TurnPM)
            {
                ReplySystem(Sender, GetLang("FUNC_MESSAGE_PM_TURN_FALSE", Sender.UserIDString));
                return;
            }
            if (ControllerMessages.TurnedFunc.IgnoreUsePM)
            {
                if (InfoRetarget.Settings.IsIgnored(Sender.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM", Sender.UserIDString));
                    return;
                }
                if (InfoSender.Settings.IsIgnored(RetargetUser.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM_ME", Sender.UserIDString));
                    return;
                }
            }

            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null || Message.Length <= 0)
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_NULL_MSG", Sender.UserIDString));
                return;
            }
            if (Message.Length > 125) return;
            Message = Message.EscapeRichText();

            PMHistory[RetargetUser] = Sender;

            GeneralInformation.RenameInfo RenameSender = GeneralInfo.GetInfoRename(Sender.userID);
            GeneralInformation.RenameInfo RenamerTarget = GeneralInfo.GetInfoRename(RetargetUser.userID);
            String DisplayNameSender = RenameSender != null ? RenameSender.RenameNick ?? Sender.displayName : Sender.displayName;
            String TargetDisplayName = RenamerTarget != null ? RenamerTarget.RenameNick ?? RetargetUser.displayName : RetargetUser.displayName;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            ReplySystem(RetargetUser, GetLang("COMMAND_PM_SEND_MSG", RetargetUser.UserIDString, DisplayNameSender, Message));
            ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, Message, TargetDisplayName));

            if (InfoRetarget.Settings.TurnSound)
                Effect.server.Run(ControllerMessages.TurnedFunc.PMSetting.SoundPM, RetargetUser.GetNetworkPosition());

            Log(LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName} sent a message to the player - {RetargetUser.displayName}\nMESSAGE : {Message}" : $"  : {Sender.displayName}    - {RetargetUser.displayName}\n : {Message}");
            DiscordLoggPM(Sender, RetargetUser, Message);

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName}({Sender.userID}) -> {RetargetUser.displayName} : MESSAGE : {Message}" : $"  : {Sender.displayName}({Sender.userID}) -> {RetargetUser.displayName} :  : {Message}",
                UserId = Sender.UserIDString,
                Username = Sender.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning(LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName}({Sender.userID}) -> {RetargetUser.displayName} : MESSAGE : {Message}" : $"  : {Sender.displayName}({Sender.userID}) -> {RetargetUser.displayName} :  : {Message}");
        }

        private void DiscordLoggPM(BasePlayer Sender, BasePlayer Reciepter, String MessageLogged)
        {
            Configuration.OtherSettings.General PMChat = config.OtherSetting.LogsPMChat;
            if (!PMChat.UseLogged) return;

            GeneralInformation.RenameInfo SenderRename = GeneralInfo.GetInfoRename(Sender.userID);
            GeneralInformation.RenameInfo ReciepterRename = GeneralInfo.GetInfoRename(Reciepter.userID);

            UInt64 UserIDSender = SenderRename != null ? SenderRename.RenameID == 0 ? Sender.userID : SenderRename.RenameID : Sender.userID;
            UInt64 UserIDReciepter = ReciepterRename != null ? ReciepterRename.RenameID == 0 ? Reciepter.userID : ReciepterRename.RenameID : Reciepter.userID;
            String SenderName = SenderRename != null ? ReciepterRename.RenameNick ?? Sender.displayName : Sender.displayName;
            String ReciepterName = ReciepterRename != null ? ReciepterRename.RenameNick ?? Reciepter.displayName : Reciepter.displayName;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            List<Fields> fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Sender" : "", $"{SenderName}({UserIDSender})", true),
                            new Fields(LanguageEn ? "Recipient" : "", $"{ReciepterName}({UserIDReciepter})", true),
                            new Fields(LanguageEn ? "Message" : "", MessageLogged, false),
                        };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 16608621, fields, new Authors("IQChat PM-History", null, "https://i.imgur.com/xiwsg5m.png", null), null) });

            Request($"{PMChat.Webhooks}", newMessage.toJSON());
        }

        private static InterfaceBuilder _interface;
        public class FakePlayer
        {
            public string DisplayName;
            public ulong UserID;
        }
        private void DiscordLoggChat(BasePlayer player, Chat.ChatChannel Channel, String MessageLogged)
        {
            List<Fields> fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nick" : "", player.displayName, true),
                            new Fields("Steam64ID", player.UserIDString, true),
                            new Fields(LanguageEn ? "Channel" : "", Channel == Chat.ChatChannel.Global ? (LanguageEn ? "Global" : " ") : Channel == Chat.ChatChannel.Cards ? (LanguageEn ? "Poker" : " ") : (LanguageEn ? "Team" : " "), true),
                            new Fields(LanguageEn ? "Message" : "", MessageLogged, false),
                        };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 10710525, fields, new Authors("IQChat Chat-History", null, "https://i.imgur.com/xiwsg5m.png", null), null) });

            switch (Channel)
            {
                case Chat.ChatChannel.Cards:
                case Chat.ChatChannel.Global:
                    {
                        Configuration.OtherSettings.General GlobalChat = config.OtherSetting.LogsChat.GlobalChatSettings;
                        if (!GlobalChat.UseLogged) return;
                        Request($"{GlobalChat.Webhooks}", newMessage.toJSON());
                        break;
                    }
                case Chat.ChatChannel.Team:
                    {
                        Configuration.OtherSettings.General TeamChat = config.OtherSetting.LogsChat.TeamChatSettings;
                        if (!TeamChat.UseLogged) return;
                        Request($"{TeamChat.Webhooks}", newMessage.toJSON());
                    }
                    break;
                default:
                    break;
            }
        }
        String API_GET_DEFAULT_PREFIX() => config.ControllerConnect.SetupDefaults.PrefixDefault;
        protected override void SaveConfig() => Config.WriteObject(config);
        [ChatCommand("alertuip")]
        private void AlertUIPChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            if (args == null || args.Length == 0)
            {
                ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "   !");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args[0]);
            if (Recipient == null)
            {
                ReplySystem(Sender, LanguageEn ? "The player is not on the server!" : "   !");
                return;
            }
            AlertUI(Sender, Recipient, args.Skip(1).ToArray());
        }

        private const String PermissionHideOnline = "iqchat.onlinehide";

        
                void AlertUI(BasePlayer Sender, string[] arg)
        {
            if (_interface == null)
            {
                PrintWarning(LanguageEn ? "We generate the interface, wait for a message about successful generation" : " ,     ");
                return;
            }
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            foreach (BasePlayer PlayerInList in BasePlayer.activePlayerList)
                DrawUI_IQChat_Alert(PlayerInList, Message);
        }
        
                public void RemoveReserved(UInt64 userID)
        {
            if (!IQFakeActive) return;
            IQFakeActive?.Call("RemoveReserver", userID);
        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
        
                public Boolean IsNoob(UInt64 userID, Int32 TimeBlocked)
        {
            if (UserInformationConnection.ContainsKey(userID))
                return UserInformationConnection[userID].IsNoob(TimeBlocked);
            return false;
        }
        void API_ALERT(String Message, Chat.ChatChannel channel = Chat.ChatChannel.Global, String CustomPrefix = null, String CustomAvatar = null, String CustomHex = null)
        {
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                ReplySystem(p, Message, CustomPrefix, CustomAvatar, CustomHex);
        }
        Boolean API_CHECK_MUTE_CHAT(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return false;
            return UserInformation[ID].MuteInfo.IsMute(MuteType.Chat);
        }
        void Unload()
        {
            InterfaceBuilder.DestroyAll();

            WriteData();
            _ = null;
        }
        
        void ReplyBroadcast(String CustomPrefix = null, String CustomAvatar = null, Boolean AdminAlert = false, String LangKey = "", params object[] args)
        {
            foreach (BasePlayer p in !AdminAlert ? BasePlayer.activePlayerList.Where(p => UserInformation[p.userID].Settings.TurnBroadcast) : BasePlayer.activePlayerList)
                ReplySystem(p,GetLang(LangKey, p.UserIDString, args), CustomPrefix, CustomAvatar);
        }

        [ConsoleCommand("unmute")]
        void UnMuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;

            if (arg?.Args == null || arg.Args.Length != 1 || arg.Args.Length > 1)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, please use : unmute Steam64ID" : " , : unmute Steam64ID");
                return;
            }

            string NameOrID = arg.Args[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);

            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ConsoleOrPrintMessage(arg.Player(),
                                LanguageEn ? "The player does not have a chat lock" : "    ");
                            return;
                        }

                        Info.MuteInfo.UnMute(MuteType.Chat);

                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "You have unblocked the offline chat to the player" : "   offline ");
                        return;
                    }
                    else
                    {
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "This player is not on the server" : "    ");
                        return;
                    }
                }
                else
                {
                    ConsoleOrPrintMessage(arg.Player(),
                        LanguageEn ? "This player is not on the server" : "    ");
                    return;
                }
            }

            UnmutePlayer(target, MuteType.Chat, arg.Player(), false, true);
            Puts(LanguageEn ? "Successfully" : "");
        }

        
                
        private void Log(String LoggedMessage) => LogToFile("IQChatLogs", LoggedMessage, this);

        [ChatCommand("alertui")]
        private void AlertUIChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            AlertUI(Sender, args);
        }
        private void DrawUI_IQChat_Mute_And_Ignore_Pages(BasePlayer player, Boolean IsNextPage, SelectedAction Action, Int32 Page = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Pages");
            if (Interface == null) return;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            String CommandRight = IsNextPage ? $"newui.cmd action.mute.ignore page.controller {Action} {Page + 1}" : String.Empty;
            String ColorRight = String.IsNullOrEmpty(CommandRight) ? "1 1 1 0.1" : "1 1 1 1";

            String CommandLeft = Page > 0 ? $"newui.cmd action.mute.ignore page.controller {Action} {Page - 1}" : String.Empty;
            String ColorLeft = String.IsNullOrEmpty(CommandLeft) ? "1 1 1 0.1" : "1 1 1 1";
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Interface = Interface.Replace("%COMMAND_LEFT%", CommandLeft);
            Interface = Interface.Replace("%COMMAND_RIGHT%", CommandRight);
            Interface = Interface.Replace("%PAGE%", $"{Page}");
            Interface = Interface.Replace("%COLOR_LEFT%", ColorLeft);
            Interface = Interface.Replace("%COLOR_RIGHT%", ColorRight);

            CuiHelper.DestroyUi(player, "PageCount");
            CuiHelper.DestroyUi(player, "LeftPage");
            CuiHelper.DestroyUi(player, "RightPage");
            CuiHelper.AddUi(player, Interface);
        }

        [ConsoleCommand("hmute")]
        void HideMuteConsole(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;

            if (arg == null || arg.Args == null || arg.Args.Length != 3 || arg.Args.Length > 3)
            {
                ConsoleOrPrintMessage(arg.Player(),
                    LanguageEn
                        ? "Invalid syntax, use : hmute Steam64ID Reason Time (seconds)"
                        : " , : hmute Steam64ID  ()");
                return;
            }
            string NameOrID = arg.Args[0];
            string Reason = arg.Args[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg.Args[2], out TimeMute))
            {
                ConsoleOrPrintMessage(arg.Player(),
                    LanguageEn ? "Enter the time in numbers!" : "  !");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ConsoleOrPrintMessage(arg.Player(),
                                LanguageEn ? "The player already has a chat lock" : "    ");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);

                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "Chat blocking issued to offline player" : "   offline-");
                        return;
                    }
                    else
                    {
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "This player is not on the server" : "    ");
                        return;
                    }
                }
                else
                {
                    ConsoleOrPrintMessage(arg.Player(),
                        LanguageEn ? "This player is not on the server" : "    ");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, arg.Player(), Reason, TimeMute, true, true);
        }
        class Response
        {
            [JsonProperty("country")]
            public string Country { get; set; }
        }

        void ReplySystem(BasePlayer player, String Message, String CustomPrefix = null, String CustomAvatar = null, String CustomHex = null)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;

            String Prefix = (CustomPrefix == null || String.IsNullOrWhiteSpace(CustomPrefix)) ? (ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastTitle == null || String.IsNullOrWhiteSpace(ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastTitle)) ? "" : ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastTitle : CustomPrefix;
            String AvatarID = (CustomAvatar == null || String.IsNullOrWhiteSpace(CustomAvatar)) ? (ControllerMessages.GeneralSetting.BroadcastFormat.Steam64IDAvatar == null || String.IsNullOrWhiteSpace(ControllerMessages.GeneralSetting.BroadcastFormat.Steam64IDAvatar)) ? "0" : ControllerMessages.GeneralSetting.BroadcastFormat.Steam64IDAvatar : CustomAvatar;
            String Hex = (CustomHex == null || String.IsNullOrWhiteSpace(CustomHex)) ? (ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastColor == null || String.IsNullOrWhiteSpace(ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastColor)) ? "#ffff" : ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastColor : CustomHex;
           
            player.SendConsoleCommand("chat.add", Chat.ChatChannel.Global, AvatarID, $"{Prefix}<color={Hex}>{Message}</color>");
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        private void MigrateDataToNoob()
        {
            if (config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM.AntiNoobActivate || config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobChat.AntiNoobActivate)
            {
                if (UserInformationConnection.Count == 0 || UserInformationConnection == null)
                {
                    PrintWarning(LanguageEn ? "Migration of old players to Anti-Nub.." : "    -..");
                    foreach (KeyValuePair<UInt64, User> InfoUser in UserInformation.Where(x => !UserInformationConnection.ContainsKey(x.Key)))
                        UserInformationConnection.Add(InfoUser.Key, new AntiNoob { DateConnection = new DateTime(2022, 1, 1) });
                    PrintWarning(LanguageEn ? "Migration of old players completed" : "   ");
                }
            }
        }
        public bool IsFake(String DisplayName)
        {
            if (!IQFakeActive) return false;

            return (bool)IQFakeActive?.Call("IsFake", DisplayName);
        }
        Boolean API_CHECK_VOICE_CHAT(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return false;
            return UserInformation[ID].MuteInfo.IsMute(MuteType.Voice);
        }

        
                public GeneralInformation GeneralInfo = new GeneralInformation();
        private void SeparatorChat(Chat.ChatChannel channel, BasePlayer player, String Message)
        {
            Configuration.ControllerMessage.TurnedFuncional.AntiNoob.Settings antiNoob = config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobChat;
            if (antiNoob.AntiNoobActivate)
                if (IsNoob(player.userID, antiNoob.TimeBlocked))
                {
                    ReplySystem(player, GetLang("IQCHAT_INFO_ANTI_NOOB", player.UserIDString, FormatTime(UserInformationConnection[player.userID].LeftTime(antiNoob.TimeBlocked), player.UserIDString)));
                    return;
                }

            Configuration.ControllerMessage ControllerMessage = config.ControllerMessages;
            User Info = UserInformation[player.userID];

            if (ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamActivate)
                if (!permission.UserHasPermission(player.UserIDString, PermissionAntiSpam))
                {
                    if (!Info.MuteInfo.IsMute(MuteType.Chat))
                    {
                        if (!Flooders.ContainsKey(player.userID))
                            Flooders.Add(player.userID, new FlooderInfo { Time = CurrentTime + ControllerMessage.TurnedFunc.AntiSpamSetting.FloodTime, LastMessage = Message });
                        else
                        {
                            if (Flooders[player.userID].Time > CurrentTime)
                            {
                                ReplySystem(player, GetLang("FLOODERS_MESSAGE", player.UserIDString, Convert.ToInt32(Flooders[player.userID].Time - CurrentTime)));
                                return;
                            }

                            if (ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.AntiSpamDuplesActivate)
                            {
                                if (Flooders[player.userID].LastMessage == Message)
                                {
                                    if (Flooders[player.userID].TryFlood >= ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.TryDuples)
                                    {
                                        MutePlayer(player, MuteType.Chat, 0, null, ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.MuteSetting.Reason, ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.MuteSetting.SecondMute);
                                        Flooders[player.userID].TryFlood = 0;
                                        return;
                                    }
                                    Flooders[player.userID].TryFlood++;
                                }
                            }
                        }
                        Flooders[player.userID].Time = ControllerMessage.TurnedFunc.AntiSpamSetting.FloodTime + CurrentTime;
                        Flooders[player.userID].LastMessage = Message;
                    }
                }

            GeneralInformation General = GeneralInfo;
            GeneralInformation.RenameInfo RenameInformation = General.GetInfoRename(player.userID);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            Configuration.ControllerMute ControllerMutes = config.ControllerMutes;
            Configuration.ControllerMessage.GeneralSettings.OtherSettings OtherController = config.ControllerMessages.GeneralSetting.OtherSetting;

            if (General.TurnMuteAllChat)
            {
                ReplySystem(player, GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT", player.UserIDString));
                return;
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (channel == Chat.ChatChannel.Team && !ControllerMessage.TurnedFunc.MuteTeamChat) { }
            else if (Info.MuteInfo.IsMute(MuteType.Chat))
            {
                ReplySystem(player,
                    GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED", player.UserIDString,
                        FormatTime(Info.MuteInfo.GetTime(MuteType.Chat), player.UserIDString)));
                return;
            }

            String Prefixes = String.Empty;
            String FormattingMessage = Message;
            String DisplayName = player.displayName;

            UInt64 UserID = player.userID;
            if (RenameInformation != null)
            {
                DisplayName = RenameInformation.RenameNick;
                UserID = RenameInformation.RenameID;
            }

            String ColorNickPlayer = String.IsNullOrWhiteSpace(Info.Info.ColorNick) ? player.IsAdmin ? "#a8fc55" : "#54aafe" : Info.Info.ColorNick;
            DisplayName = $"<color={ColorNickPlayer}>{DisplayName}</color>";

            //channel == Chat.ChatChannel.Team ? "<color=#a5e664>[Team]</color>" : 
            String ChannelMessage = channel == Chat.ChatChannel.Cards ? "<color=#AA8234>[Cards]</color>" :  channel == Chat.ChatChannel.Clan ? "<color=#a5e664>[Clan]</color>" : "";

            if (ControllerMessage.Formatting.UseBadWords)
            {
                Tuple<String, Boolean> GetTuple = BadWordsCleaner(Message, ControllerMessage.Formatting.ReplaceBadWord, ControllerMessage.Formatting.BadWords);
                FormattingMessage = GetTuple.Item1;

                if (GetTuple.Item2 && channel == Chat.ChatChannel.Global)
                {
                    if (permission.UserHasPermission(player.UserIDString, PermissionMute))
                        Interface.Oxide.CallHook("OnModeratorSendBadWords", player, GetTuple.Item1);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                    Interface.Oxide.CallHook("OnPlayerSendBadWords", player, GetTuple.Item1);

                    if (ControllerMutes.AutoMuteSettings.UseAutoMute)
                        MutePlayer(player, MuteType.Chat, 0, null, ControllerMutes.AutoMuteSettings.AutoMuted.Reason, ControllerMutes.AutoMuteSettings.AutoMuted.SecondMute);
                }
            }

            if (ControllerMessage.Formatting.FormatMessage)
                FormattingMessage = $"{FormattingMessage.Substring(0, 1).ToUpper()}{FormattingMessage.Remove(0, 1).ToLower()}";

            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
            {
                if (Info.Info.PrefixList != null)
                    Prefixes = String.Join("", Info.Info.PrefixList.Take(ControllerParameter.Prefixes.MaximumMultiPrefixCount));
            }
            else Prefixes = Info.Info.Prefix;
            
            String ResultMessage = String.IsNullOrWhiteSpace(Info.Info.ColorMessage) ? FormattingMessage : $"<color={Info.Info.ColorMessage}>{FormattingMessage}</color>";;

            String ResultReference = GetReferenceTags(player); 
            String SendFormat = $"{ChannelMessage} {ResultReference}<size={OtherController.SizePrefix}>{Prefixes}</size> <size={OtherController.SizeNick}>{DisplayName}</size>";
            
            if (config.RustPlusSettings.UseRustPlus)
                if (channel == Chat.ChatChannel.Team)
                {
                    RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                    if (Team == null) return;
                    Util.BroadcastTeamChat(player.Team, player.userID, player.displayName, FormattingMessage, Info.Info.ColorMessage);
                }

            if (ControllerMutes.LoggedMute.UseHistoryMessage && config.OtherSetting.LogsMuted.UseLogged)
                AddHistoryMessage(player, FormattingMessage);

            ReplyChat(channel, player, ResultMessage, SendFormat);
            AnwserMessage(player, ResultMessage.ToLower());
            Puts($"{player.displayName}({player.UserIDString}): {FormattingMessage}");
            Log(LanguageEn ? $"CHAT MESSAGE : {player}: {ChannelMessage} {FormattingMessage}" : $"   : {player}: {ChannelMessage} {FormattingMessage}");
            DiscordLoggChat(player, channel, Message);

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = $"{player.displayName} : {FormattingMessage}",
                UserId = player.UserIDString,
                Username = player.displayName,
                Channel = channel,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
            });
        }
        String API_GET_NICK_COLOR(ulong ID)
        {
            if (!UserInformation.ContainsKey(ID)) return String.Empty;

            return UserInformation[ID].Info.ColorNick;
        }
        void Alert(BasePlayer Sender, string[] arg, Boolean IsAdmin)
        {
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            ReplyBroadcast(Message, AdminAlert: IsAdmin);

            if (config.RustPlusSettings.UseRustPlus)
                foreach (BasePlayer playerList in BasePlayer.activePlayerList)
                    NotificationList.SendNotificationTo(playerList.userID, NotificationChannel.SmartAlarm, config.RustPlusSettings.DisplayNameAlert, Message, Util.GetServerPairingData());
        }
        static Double CurrentTime => Facepunch.Math.Epoch.Current;
        String API_GET_PREFIX(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return String.Empty;
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;

            User Info = UserInformation[ID];
            String Prefixes = String.Empty;

            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                Prefixes = String.Join("", Info.Info.PrefixList.Take(ControllerParameter.Prefixes.MaximumMultiPrefixCount));
            else Prefixes = Info.Info.Prefix;

            return Prefixes;
        }

        private void DiscordLoggMuted(BasePlayer Target, MuteType Type, String Reason = null, String TimeBlocked = null, BasePlayer Moderator = null)
        {
            Configuration.OtherSettings.General MuteChat = config.OtherSetting.LogsMuted;
            if (!MuteChat.UseLogged) return;

            Configuration.ControllerMute.LoggedFuncion ControllerMuted = config.ControllerMutes.LoggedMute;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            String ActionReason = String.Empty;

            GeneralInformation.RenameInfo RenameSender = GeneralInfo.GetInfoRename(Target.userID);

            UInt64 UserIDModeration = 0;
            String NickModeration = GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER", Target.UserIDString);
            if (Moderator != null)
            {
                GeneralInformation.RenameInfo RenameModerator = GeneralInfo.GetInfoRename(Moderator.userID);

                UserIDModeration = RenameModerator != null ? RenameModerator.RenameID == 0 ? Moderator.userID : RenameModerator.RenameID : Moderator.userID;
                NickModeration = RenameModerator != null ? $"{RenameModerator.RenameNick ?? Moderator.displayName}" : Moderator.displayName;
            }

            String NickTarget = RenameSender != null ? $"{RenameSender.RenameNick ?? Target.displayName}" : Target.displayName;
            UInt64 UserIDTarget = RenameSender != null ? RenameSender.RenameID == 0 ? Target.userID : RenameSender.RenameID : Target.userID;

            List<Fields> fields;

            switch (Type)
            {
                case MuteType.Chat:
                    {
                        if (Reason != null)
                            ActionReason = LanguageEn ? "Mute chat" : " ";
                        else ActionReason = LanguageEn ? "Unmute chat" : " ";
                        break;
                    }
                case MuteType.Voice:
                    {
                        if (Reason != null)
                            ActionReason = LanguageEn ? "Mute voice" : " ";
                        else ActionReason = LanguageEn ? "Unmute voice" : " ";
                        break;
                    }
                default:
                    break;
            }
            Int32 Color = 0;
            if (Reason != null)
            {
                fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nickname of the moderator" : " ", NickModeration, true),
                            new Fields(LanguageEn ? "Steam64ID Moderator" : "Steam64ID ", $"{UserIDModeration}", true),
                            new Fields(LanguageEn ? "Action" : "", ActionReason, false),
                            new Fields(LanguageEn ? "Reason" : "", Reason, false),
                            new Fields(LanguageEn ? "Time" : "", TimeBlocked, false),
                            new Fields(LanguageEn ? "Nick blocked" : " ", NickTarget, true),
                            new Fields(LanguageEn ? "Steam64ID blocked" : "Steam64ID ", $"{UserIDTarget}", true),
                        };



                if (ControllerMuted.UseHistoryMessage)
                {
                    String Messages = GetLastMessage(Target, ControllerMuted.CountHistoryMessage);
                    if (Messages != null && !String.IsNullOrWhiteSpace(Messages))
                        fields.Insert(fields.Count, new Fields(LanguageEn ? $"The latter {ControllerMuted.CountHistoryMessage} messages" : $" {ControllerMuted.CountHistoryMessage} ", Messages, false));
                }

                Color = 14357781;
            }
            else
            {
                fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nickname of the moderator" : " ", NickModeration, true),
                            new Fields(LanguageEn ? "Steam64ID moderator" : "Steam64ID ", $"{UserIDModeration}", true),
                            new Fields(LanguageEn ? "Action" : "", ActionReason, false),
                            new Fields(LanguageEn ? "Nick blocked" : " ", NickTarget, true),
                            new Fields(LanguageEn ? "Steam64ID blocked" : "Steam64ID ", $"{UserIDTarget}", true),
                        };
                Color = 1432346;
            }


            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, Color, fields, new Authors("IQChat Mute-History", null, "https://i.imgur.com/xiwsg5m.png", null), null) });

            Request($"{MuteChat.Webhooks}", newMessage.toJSON());
        }
        void API_SEND_PLAYER_CONNECTED(BasePlayer player, String DisplayName, String country, String userID)
        {
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;

            if (AlertSessionPlayer.ConnectedAlert)
            {
                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? userID : String.Empty;
                if (AlertSessionPlayer.ConnectedWorld)
                    ReplyBroadcast(null, Avatar, false, "WELCOME_PLAYER_WORLD", DisplayName, country);
                    //ReplyBroadcast(GetLang("WELCOME_PLAYER_WORLD", player.UserIDString, DisplayName, country), CustomAvatar: Avatar);
                else ReplyBroadcast(null, Avatar, false, "WELCOME_PLAYER", DisplayName);
                    //ReplyBroadcast(GetLang("WELCOME_PLAYER", player.UserIDString, DisplayName), CustomAvatar: Avatar);
            }
        }
        public Dictionary<BasePlayer, List<String>> LastMessagesChat = new Dictionary<BasePlayer, List<String>>();
        private void DrawUI_IQChat_Slider_Update_Argument(BasePlayer player, TakeElementUser ElementType)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Slider_Update_Argument");
            User Info = UserInformation[player.userID];
            if (Info == null || Interface == null) return;

            String Argument = String.Empty;
            String Name = String.Empty;
            String Parent = String.Empty;

            switch (ElementType)
            {
                case TakeElementUser.Prefix:
                    Argument = Info.Info.Prefix;
                    Parent = "SLIDER_PREFIX";
                    Name = "ARGUMENT_PREFIX";
                    break;
                case TakeElementUser.Nick:
                    Argument = $"<color={Info.Info.ColorNick}>{player.displayName}</color>";
                    Parent = "SLIDER_NICK_COLOR";
                    Name = "ARGUMENT_NICK_COLOR";
                    break;
                case TakeElementUser.Chat:
                    Argument = $"<color={Info.Info.ColorMessage}>{GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE", player.UserIDString)}</color>";
                    Parent = "SLIDER_MESSAGE_COLOR";
                    Name = "ARGUMENT_MESSAGE_COLOR";
                    break;
                case TakeElementUser.Rank:
                    Argument = IQRankGetNameRankKey(Info.Info.Rank) ?? GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER", player.UserIDString);
                    Parent = "SLIDER_IQRANK";
                    Name = "ARGUMENT_RANK";
                    break;
                default:
                    break;
            }

            String Pattern = @"</?size.*?>";
            String ArgumentRegex = Regex.IsMatch(Argument, Pattern) ? Regex.Replace(Argument, Pattern, "") : Argument;
            Interface = Interface.Replace("%ARGUMENT%", ArgumentRegex);
            Interface = Interface.Replace("%PARENT%", Parent);
            Interface = Interface.Replace("%NAME%", Name);

            CuiHelper.DestroyUi(player, Name);
            CuiHelper.AddUi(player, Interface);

        }
        private class Configuration
        {
                        [JsonProperty(LanguageEn ? "Setting up player information" : "   ")]
            public ControllerConnection ControllerConnect = new ControllerConnection();
            internal class ControllerConnection
            {
                [JsonProperty(LanguageEn ? "Function switches" : " ")]
                public Turned Turneds = new Turned();
                [JsonProperty(LanguageEn ? "Setting Standard Values" : "  ")]
                public SetupDefault SetupDefaults = new SetupDefault();

                internal class SetupDefault
                {
                    [JsonProperty(LanguageEn ? "This prefix will be set if the player entered the server for the first time or in case of expiration of the rights to the prefix that he had earlier" : "               ,     ")]
                    public String PrefixDefault = "<color=#CC99FF>[]</color>";
                    [JsonProperty(LanguageEn ? "This nickname color will be set if the player entered the server for the first time or in case of expiration of the rights to the nickname color that he had earlier" : "                 ,     ")]
                    public String NickDefault = "#33CCCC";
                    [JsonProperty(LanguageEn ? "This chat color will be set if the player entered the server for the first time or in case of expiration of the rights to the chat color that he had earlier" : "                 ,     ")]
                    public String MessageDefault = "#0099FF";
                }
                internal class Turned
                {
                    [JsonProperty(LanguageEn ? "Set automatically a prefix to a player when he got the rights to it" : "   ,      ")]
                    public Boolean TurnAutoSetupPrefix;
                    [JsonProperty(LanguageEn ? "Set automatically the color of the nickname to the player when he got the rights to it" : "    ,      ")]
                    public Boolean TurnAutoSetupColorNick;
                    [JsonProperty(LanguageEn ? "Set the chat color automatically to the player when he got the rights to it" : "    ,      ")]
                    public Boolean TurnAutoSetupColorChat;
                    [JsonProperty(LanguageEn ? "Automatically reset the prefix when the player's rights to it expire" : "         ")]
                    public Boolean TurnAutoDropPrefix;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the nickname when the player's rights to it expire" : "          ")]
                    public Boolean TurnAutoDropColorNick;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the chat when the rights to it from the player expire" : "          ")]
                    public Boolean TurnAutoDropColorChat;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Setting options for the player" : "   ")]
            public ControllerParameters ControllerParameter = new ControllerParameters();
            internal class ControllerParameters
            {
                [JsonProperty(LanguageEn ? "Setting the display of options for player selection" : "     ")]
                public VisualSettingParametres VisualParametres = new VisualSettingParametres();
                [JsonProperty(LanguageEn ? "List and customization of colors for a nickname" : "     ")]
                public List<AdvancedFuncion> NickColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and customize colors for chat messages" : "       ")]
                public List<AdvancedFuncion> MessageColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and configuration of prefixes in chat" : "     ")]
                public PrefixSetting Prefixes = new PrefixSetting();
                internal class PrefixSetting
                {
                    [JsonProperty(LanguageEn ? "Enable support for multiple prefixes at once (true - multiple prefixes can be set/false - only 1 can be set to choose from)" : "     (true -    /false -    1  )")]
                    public Boolean TurnMultiPrefixes;
                    [JsonProperty(LanguageEn ? "The maximum number of prefixes that can be set at a time (This option only works if setting multiple prefixes is enabled)" : "  ,     (        )")]
                    public Int32 MaximumMultiPrefixCount;
                    [JsonProperty(LanguageEn ? "List of prefixes and their settings" : "    ")]
                    public List<AdvancedFuncion> Prefixes = new List<AdvancedFuncion>();
                }

                internal class AdvancedFuncion
                {
                    [JsonProperty(LanguageEn ? "Permission" : "")]
                    public String Permissions;
                    [JsonProperty(LanguageEn ? "Argument" : "")]
                    public String Argument;
                    [JsonProperty(LanguageEn ? "Block the player's ability to select this parameter in the plugin menu (true - yes/false - no)" : "         (true - /false - )")]
                    public Boolean IsBlockSelected;
                }

                internal class VisualSettingParametres
                {
                    [JsonProperty(LanguageEn ? "Player prefix selection display type - (0 - dropdown list, 1 - slider (Please note that if you have multi-prefix enabled, the dropdown list will be set))" : "      - (0 -  , 1 -  (,      -,    ))")]
                    public SelectedParametres PrefixType;
                    [JsonProperty(LanguageEn ? "Display type of player's nickname color selection - (0 - drop-down list, 1 - slider)" : "       - (0 -  , 1 - )")]
                    public SelectedParametres NickColorType;
                    [JsonProperty(LanguageEn ? "Display type of message color choice for the player - (0 - drop-down list, 1 - slider)" : "       - (0 -  , 1 - )")]
                    public SelectedParametres ChatColorType;
                    [JsonProperty(LanguageEn ? "IQRankSystem : Player rank selection display type - (0 - drop-down list, 1 - slider)" : "IQRankSystem :       - (0 -  , 1 - )")]
                    public SelectedParametres IQRankSystemType;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Plugin mute settings" : "   ")]
            public ControllerMute ControllerMutes = new ControllerMute();
            internal class ControllerMute
            {
                [JsonProperty(LanguageEn ? "Setting up automatic muting" : "  ")]
                public AutoMute AutoMuteSettings = new AutoMute();
                internal class AutoMute
                {
                    [JsonProperty(LanguageEn ? "Enable automatic muting for forbidden words (true - yes/false - no)" : "     (true - /false - )")]
                    public Boolean UseAutoMute;
                    [JsonProperty(LanguageEn ? "Reason for automatic muting" : "  ")]
                    public Muted AutoMuted;
                }
                [JsonProperty(LanguageEn ? "Additional setting for logging about mutes in discord" : "       ")]
                public LoggedFuncion LoggedMute = new LoggedFuncion();
                internal class LoggedFuncion
                {
                    [JsonProperty(LanguageEn ? "Support for logging the last N messages (Discord logging about mutes must be enabled)" : "   N  (       )")]
                    public Boolean UseHistoryMessage;
                    [JsonProperty(LanguageEn ? "How many latest player messages to send in logging" : "      ")]
                    public Int32 CountHistoryMessage;
                }

                [JsonProperty(LanguageEn ? "Reasons to block chat" : "   ")]
                public List<Muted> MuteChatReasons = new List<Muted>();
                [JsonProperty(LanguageEn ? "Reasons to block your voice" : "   ")]
                public List<Muted> MuteVoiceReasons = new List<Muted>();
                internal class Muted
                {
                    [JsonProperty(LanguageEn ? "Reason for blocking" : "  ")]
                    public String Reason;
                    [JsonProperty(LanguageEn ? "Block time (in seconds)" : " ( )")]
                    public Int32 SecondMute;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Configuring Message Processing" : "  ")]
            public ControllerMessage ControllerMessages = new ControllerMessage();
            internal class ControllerMessage
            {
                [JsonProperty(LanguageEn ? "Basic settings for chat messages from the plugin" : "      ")]
                public GeneralSettings GeneralSetting = new GeneralSettings();
                [JsonProperty(LanguageEn ? "Configuring functionality switching in chat" : "    ")]
                public TurnedFuncional TurnedFunc = new TurnedFuncional();
                [JsonProperty(LanguageEn ? "Player message formatting settings" : "   ")]
                public FormattingMessage Formatting = new FormattingMessage();
  
                
                internal class GeneralSettings
                {
                    [JsonProperty(LanguageEn ? "Customizing the chat alert format" : "    ")]
                    public BroadcastSettings BroadcastFormat = new BroadcastSettings();
                    [JsonProperty(LanguageEn ? "Setting the mention format in the chat, via @" : "    ,  @")]
                    public AlertSettings AlertFormat = new AlertSettings();
                    [JsonProperty(LanguageEn ? "Additional setting" : " ")]
                    public OtherSettings OtherSetting = new OtherSettings();
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                    internal class BroadcastSettings
                    {
                        [JsonProperty(LanguageEn ? "The name of the notification in the chat" : "   ")]
                        public String BroadcastTitle;
                        [JsonProperty(LanguageEn ? "Chat alert message color" : "    ")]
                        public String BroadcastColor;
                        [JsonProperty(LanguageEn ? "Steam64ID for chat avatar" : "Steam64ID    ")]
                        public String Steam64IDAvatar;
                    }
                    internal class AlertSettings
                    {
                        [JsonProperty(LanguageEn ? "The color of the player mention message in the chat" : "     ")]
                        public String AlertPlayerColor;
                        [JsonProperty(LanguageEn ? "Sound when receiving and sending a mention via @" : "        @")]
                        public String SoundAlertPlayer;
                    }
                    internal class OtherSettings
                    {
                        [JsonProperty(LanguageEn ? "Time after which the message will be deleted from the UI from the administrator" : ",     UI  ")]
                        public Int32 TimeDeleteAlertUI;

                        [JsonProperty(LanguageEn ? "The size of the message from the player in the chat" : "     ")]
                        public Int32 SizeMessage = 14;
                        [JsonProperty(LanguageEn ? "Player nickname size in chat" : "    ")]
                        public Int32 SizeNick = 14;
                        [JsonProperty(LanguageEn ? "The size of the player's prefix in the chat (will be used if <size=N></size> is not set in the prefix itself)" : "     ( ,       <size=N></size>)")]
                        public Int32 SizePrefix = 14;
                    }
                }
                internal class TurnedFuncional
                {
                    [JsonProperty(LanguageEn ? "Configuring spam protection" : "   ")]
                    public AntiSpam AntiSpamSetting = new AntiSpam();
                    [JsonProperty(LanguageEn ? "Setting up a temporary chat block for newbies (who have just logged into the server)" : "     (    )")]
                    public AntiNoob AntiNoobSetting = new AntiNoob();
                    [JsonProperty(LanguageEn ? "Setting up private messages" : "  ")]
                    public PM PMSetting = new PM();

                    internal class AntiNoob
                    {
                        [JsonProperty(LanguageEn ? "Newbie protection in PM/R" : "    PM/R")]
                        public Settings AntiNoobPM = new Settings();
                        [JsonProperty(LanguageEn ? "Newbie protection in global and team chat" : "       ")]
                        public Settings AntiNoobChat = new Settings();
                        internal class Settings
                        {
                            [JsonProperty(LanguageEn ? "Enable protection?" : " ?")]
                            public Boolean AntiNoobActivate = false;
                            [JsonProperty(LanguageEn ? "Newbie Chat Lock Time" : "    ")]
                            public Int32 TimeBlocked = 1200;
                        }
                    }
                    internal class AntiSpam
                    {
                        [JsonProperty(LanguageEn ? "Enable spam protection (Anti-spam)" : "    (-)")]
                        public Boolean AntiSpamActivate;
                        [JsonProperty(LanguageEn ? "Time after which a player can send a message (AntiSpam)" : "       ()")]
                        public Int32 FloodTime;
                        [JsonProperty(LanguageEn ? "Additional Anti-Spam settings" : "  -")]
                        public AntiSpamDuples AntiSpamDuplesSetting = new AntiSpamDuples();
                        internal class AntiSpamDuples
                        {
                            [JsonProperty(LanguageEn ? "Enable additional spam protection (Anti-duplicates, duplicate messages)" : "     (-,  )")]
                            public Boolean AntiSpamDuplesActivate = true;
                            [JsonProperty(LanguageEn ? "How many duplicate messages does a player need to make to be confused by the system" : "         ")]
                            public Int32 TryDuples = 3;
                            [JsonProperty(LanguageEn ? "Setting up automatic muting for duplicates" : "    ")]
                            public ControllerMute.Muted MuteSetting = new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Blocking for duplicate messages (SPAM)" : "    ()",
                                SecondMute = 300,
                            };
                        }
                    }
                    internal class PM
                    {
                        [JsonProperty(LanguageEn ? "Enable Private Messages" : "  ")]
                        public Boolean PMActivate;
                        [JsonProperty(LanguageEn ? "Sound when receiving a private message" : "     ")]
                        public String SoundPM;
                    }
                    [JsonProperty(LanguageEn ? "Enable PM ignore for players (/ignore nick or via interface)" : "   (/ignore nick   )")]
                    public Boolean IgnoreUsePM;
                    [JsonProperty(LanguageEn ? "Hide the issue of items to the Admin from the chat" : "     ")]
                    public Boolean HideAdminGave;
                    [JsonProperty(LanguageEn ? "Move mute to team chat (In case of a mute, the player will not be able to write even to the team chat)" : "    (  ,        )")]
                    public Boolean MuteTeamChat;
                }
                internal class FormattingMessage
                {
                    [JsonProperty(LanguageEn ? "Enable message formatting [Will control caps, message format] (true - yes/false - no)" : "   [  ,  ] (true - /false - )")]
                    public Boolean FormatMessage;
                    [JsonProperty(LanguageEn ? "Use a list of banned words (true - yes/false - no)" : "    (true - /false - )")]
                    public Boolean UseBadWords;
                    [JsonProperty(LanguageEn ? "The word that will replace the forbidden word" : "     ")]
                    public String ReplaceBadWord;
                    [JsonProperty(LanguageEn ? "List of banned words" : "  ")]
                    public List<String> BadWords = new List<String>();

                    [JsonProperty(LanguageEn ? "Nickname controller setup" : "  ")]
                    public NickController ControllerNickname = new NickController();
                    internal class NickController
                    {
                        [JsonProperty(LanguageEn ? "Enable player nickname formatting (message formatting must be enabled)" : "    (    )")]
                        public Boolean UseNickController = true;
                        [JsonProperty(LanguageEn ? "The word that will replace the forbidden word (You can leave it blank and it will just delete)" : "      (       )")]
                        public String ReplaceBadNick = "****";
                        [JsonProperty(LanguageEn ? "List of banned nicknames" : "  ")]
                        public List<String> BadNicks = new List<String>();
                        [JsonProperty(LanguageEn ? "List of allowed links in nicknames" : "    ")]
                        public List<String> AllowedLinkNick = new List<String>();
                    }
                }
            }

            
            
            [JsonProperty(LanguageEn ? "Setting up chat alerts" : "   ")]
            public ControllerAlert ControllerAlertSetting;

            internal class ControllerAlert
            {
                [JsonProperty(LanguageEn ? "Setting up chat alerts" : "   ")]
                public Alert AlertSetting;
                [JsonProperty(LanguageEn ? "Setting notifications about the status of the player's session" : "     ")]
                public PlayerSession PlayerSessionSetting;
                [JsonProperty(LanguageEn ? "Configuring administrator session status alerts" : "     ")]
                public AdminSession AdminSessionSetting;
                [JsonProperty(LanguageEn ? "Setting up personal notifications to the player when connecting" : "     ")]
                public PersonalAlert PersonalAlertSetting;
                internal class Alert
                {
                    [JsonProperty(LanguageEn ? "Enable automatic messages in chat (true - yes/false - no)" : "     (true - /false - )")]
                    public Boolean AlertMessage;
                    [JsonProperty(LanguageEn ? "Type of automatic messages : true - sequential / false - random" : "   : true - /false - ")]
                    public Boolean AlertMessageType;

                    [JsonProperty(LanguageEn ? "List of automatic messages in chat" : "    ")]
                    public LanguageController MessageList = new LanguageController();
                    [JsonProperty(LanguageEn ? "Interval for sending messages to chat (Broadcaster) (in seconds)" : "     () ( )")]
                    public Int32 MessageListTimer;
                }
                internal class PlayerSession
                {
                    [JsonProperty(LanguageEn ? "When a player is notified about the entry / exit of the player, display his avatar opposite the nickname (true - yes / false - no)" : "   /       (true - /false - )")]
                    public Boolean ConnectedAvatarUse;

                    [JsonProperty(LanguageEn ? "Notify in chat when a player enters (true - yes/false - no)" : "      (true - /false - )")]
                    public Boolean ConnectedAlert;
                    [JsonProperty(LanguageEn ? "Enable random notifications when a player from the list enters (true - yes / false - no)" : "        (true - /false - )")]
                    public Boolean ConnectionAlertRandom;
                    [JsonProperty(LanguageEn ? "Show the country of the entered player (true - yes/false - no)" : "    (true - /false - ")]
                    public Boolean ConnectedWorld;

                    [JsonProperty(LanguageEn ? "Notify when a player enters the chat (selected from the list) (true - yes/false - no)" : "     (  ) (true - /false - )")]
                    public Boolean DisconnectedAlert;
                    [JsonProperty(LanguageEn ? "Enable random player exit notifications (true - yes/false - no)" : "      (true - /false - )")]
                    public Boolean DisconnectedAlertRandom;
                    [JsonProperty(LanguageEn ? "Display reason for player exit (true - yes/false - no)" : "    (true - /false - )")]
                    public Boolean DisconnectedReason;

                    [JsonProperty(LanguageEn ? "Random player entry notifications({0} - player's nickname, {1} - country (if country display is enabled)" : "    ({0} -  , {1} - (   )")]
                    public LanguageController RandomConnectionAlert = new LanguageController();
                    [JsonProperty(LanguageEn ? "Random notifications about the exit of the player ({0} - player's nickname, {1} - the reason for the exit (if the reason is enabled)" : "    ({0} -  , {1} -  (  )")]
                    public LanguageController RandomDisconnectedAlert = new LanguageController();
                }
                internal class AdminSession
                {
                    [JsonProperty(LanguageEn ? "Notify admin on the server in the chat (true - yes/false - no)" : "        (true - /false - )")]
                    public Boolean ConnectedAlertAdmin;
                    [JsonProperty(LanguageEn ? "Notify about admin leaving the server in chat (true - yes/false - no)" : "        (true - /false - )")]
                    public Boolean DisconnectedAlertAdmin;
                }
                internal class PersonalAlert
                {
                    [JsonProperty(LanguageEn ? "Enable random message to the player who has logged in (true - yes/false - no)" : "     (true - /false - )")]
                    public Boolean UseWelcomeMessage;
                    [JsonProperty(LanguageEn ? "List of messages to the player when entering" : "    ")]
                    public LanguageController WelcomeMessage = new LanguageController();
                }
            }

            public class LanguageController
            {
                [JsonProperty(LanguageEn ? "Setting up Multilingual Messages [Language Code] = Translation Variations" : "   [] = ")]
                public Dictionary<String, List<String>> LanguageMessages = new Dictionary<String, List<String>>();
            }

            
                        [JsonProperty(LanguageEn ? "Settings Rust+" : " Rust+")]
            public RustPlus RustPlusSettings;
            internal class RustPlus
            {
                [JsonProperty(LanguageEn ? "Use Rust+" : " Rust+")]
                public Boolean UseRustPlus;
                [JsonProperty(LanguageEn ? "Title for notification Rust+" : "   Rust+")]
                public String DisplayNameAlert;
            }
            
                        [JsonProperty(LanguageEn ? "Configuring support plugins" : "  ")]
            public ReferenceSettings ReferenceSetting = new ReferenceSettings();
            internal class ReferenceSettings
            {
                [JsonProperty(LanguageEn ? "Settings XLevels" : " XLevels")]
                public XLevels XLevelsSettings = new XLevels();
                [JsonProperty(LanguageEn ? "Settings IQFakeActive" : " IQFakeActive")]
                public IQFakeActive IQFakeActiveSettings = new IQFakeActive();
                [JsonProperty(LanguageEn ? "Settings IQRankSystem" : " IQRankSystem")]
                public IQRankSystem IQRankSystems = new IQRankSystem();
                [JsonProperty(LanguageEn ? "Settings Clans" : " Clans")]
                public Clans ClansSettings = new Clans();

                internal class Clans
                {
                    [JsonProperty(LanguageEn ? "Display a clan tag in the chat (if Clans are installed)" : "     (  Clans)")]
                    public Boolean UseClanTag;
                }
                internal class IQRankSystem
                {
                    [JsonProperty(LanguageEn ? "Rank display format in chat ( {0} is the user's rank, do not delete this value)" : "     ( {0} -   ,    )")]
                    public String FormatRank = "[{0}]";
                    [JsonProperty(LanguageEn ? "Time display format with IQRank System in chat ( {0} is the user's time, do not delete this value)" : "    IQRankSystem   ( {0} -   ,    )")]
                    public String FormatRankTime = "[{0}]";
                    [JsonProperty(LanguageEn ? "Use support IQRankSystem" : "  ")]
                    public Boolean UseRankSystem;
                    [JsonProperty(LanguageEn ? "Show players their played time next to their rank" : "       ")]
                    public Boolean UseTimeStandart;
                }
                internal class IQFakeActive
                {
                    [JsonProperty(LanguageEn ? "Use support IQFakeActive" : "  IQFakeActive")]
                    public Boolean UseIQFakeActive;
                }
                internal class XLevels
                {
                    [JsonProperty(LanguageEn ? "Use support XLevels" : "  XLevels")]
                    public Boolean UseXLevels;
                    [JsonProperty(LanguageEn ? "Use full prefix with level from XLevel (true) otherwise only level (false)" : "      XLevel (true)    (false)")]
                    public Boolean UseFullXLevels;
                }
            }
            
            
            [JsonProperty(LanguageEn ? "Setting up an answering machine" : " ")]
            public AnswerMessage AnswerMessages = new AnswerMessage();

            internal class AnswerMessage
            {
                [JsonProperty(LanguageEn ? "Enable auto-reply? (true - yes/false - no)" : " ?(true - /false - )")]
                public bool UseAnswer;
                [JsonProperty(LanguageEn ? "Customize Messages [Keyword] = Reply" : "  [ ] = ")]
                public Dictionary<String, LanguageController> AnswerMessageList = new Dictionary<String, LanguageController>();
            }

            
                        [JsonProperty(LanguageEn ? "Additional setting" : " ")]
            public OtherSettings OtherSetting;

            internal class OtherSettings
            {
                [JsonProperty(LanguageEn ? "Enable the /online command (true - yes / false - no)" : "  /online (true - / false - )")]
                public Boolean UseCommandOnline;
                [JsonProperty(LanguageEn ? "Setting up message logging" : "  ")]
                public LoggedChat LogsChat = new LoggedChat();
                [JsonProperty(LanguageEn ? "Setting up logging of personal messages of players" : "    ")]
                public General LogsPMChat = new General();
                [JsonProperty(LanguageEn ? "Setting up chat/voice lock/unlock logging" : "  / /")]
                public General LogsMuted = new General();
                [JsonProperty(LanguageEn ? "Setting up logging of chat commands from players" : "  -  ")]
                public General LogsChatCommands = new General();
                internal class LoggedChat
                {
                    [JsonProperty(LanguageEn ? "Setting up general chat logging" : "   ")]
                    public General GlobalChatSettings = new General();
                    [JsonProperty(LanguageEn ? "Setting up team chat logging" : "   ")]
                    public General TeamChatSettings = new General();
                }
                internal class General
                {
                    [JsonProperty(LanguageEn ? "Enable logging (true - yes/false - no)" : "  (true - /false - )")]
                    public Boolean UseLogged = false;
                    [JsonProperty(LanguageEn ? "Webhooks channel for logging" : "Webhooks   ")]
                    public String Webhooks = "";
                }
            }
            
            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                                        ControllerParameter = new ControllerParameters
                    {
                        VisualParametres = new ControllerParameters.VisualSettingParametres
                        {
                            PrefixType = SelectedParametres.DropList,
                            ChatColorType = SelectedParametres.DropList,
                            NickColorType = SelectedParametres.Slider,
                            IQRankSystemType = SelectedParametres.Slider,
                        },
                        Prefixes = new ControllerParameters.PrefixSetting
                        {
                            TurnMultiPrefixes = false,
                            MaximumMultiPrefixCount = 5,
                            Prefixes = new List<ControllerParameters.AdvancedFuncion>
                              {
                                  new ControllerParameters.AdvancedFuncion
                                  {
                                      Argument = LanguageEn ? "<color=#CC99FF>[PLAYER]</color>" : "<color=#CC99FF>[]</color>",
                                      Permissions = "iqchat.default",
                                      IsBlockSelected = false,
                                  },
                                  new ControllerParameters.AdvancedFuncion
                                  {
                                      Argument = "<color=#ffff99>[VIP]</color>",
                                      Permissions = "iqchat.admin",
                                      IsBlockSelected = false,
                                  },
                                  new ControllerParameters.AdvancedFuncion
                                  {
                                      Argument = LanguageEn ? "<color=#ff9999>[ADMIN]</color>" : "<color=#ff9999>[]</color>",
                                      Permissions = "iqchat.admin",
                                      IsBlockSelected = false,
                                  },
                            },
                        },
                        MessageColorList = new List<ControllerParameters.AdvancedFuncion>
                        {
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#CC99FF",
                                    Permissions = "iqchat.default",
                                    IsBlockSelected = false,
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ffff99",
                                    Permissions = "iqchat.admin",
                                    IsBlockSelected = false,
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ff9999",
                                    Permissions = "iqchat.admin",
                                    IsBlockSelected = false,
                               },
                        },
                        NickColorList = new List<ControllerParameters.AdvancedFuncion>
                        {
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#CC99FF",
                                    Permissions = "iqchat.default",
                                    IsBlockSelected = false,
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ffff99",
                                    Permissions = "iqchat.admin",
                                    IsBlockSelected = false,
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ff9999",
                                    Permissions = "iqchat.admin",
                                    IsBlockSelected = false,
                               },
                        },
                    },
                    
                    
                    ControllerConnect = new ControllerConnection
                    {
                        SetupDefaults = new ControllerConnection.SetupDefault
                        {
                            PrefixDefault = LanguageEn ? "<color=#CC99FF>[PLAYER]</color>" : "<color=#CC99FF>[]</color>",
                            MessageDefault = "#33CCCC",
                            NickDefault = "#0099FF",
                        },
                        Turneds = new ControllerConnection.Turned
                        {
                            TurnAutoDropColorChat = true,
                            TurnAutoDropColorNick = true,
                            TurnAutoDropPrefix = true,
                            TurnAutoSetupColorChat = true,
                            TurnAutoSetupColorNick = true,
                            TurnAutoSetupPrefix = true,
                        }
                    },

                    
                    
                    ControllerMutes = new ControllerMute
                    {
                        LoggedMute = new ControllerMute.LoggedFuncion
                        {
                            UseHistoryMessage = false,
                            CountHistoryMessage = 10,
                        },
                        AutoMuteSettings = new ControllerMute.AutoMute
                        {
                            UseAutoMute = true,
                            AutoMuted = new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Automatic chat blocking" : "  ",
                                SecondMute = 300,
                            }
                        },
                        MuteChatReasons = new List<ControllerMute.Muted>
                        {
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Aggressive behavior" : " ",
                                SecondMute = 100,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Insults" : "",
                                SecondMute = 300,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Insult (repeated violation)" : " ( )",
                                SecondMute = 1000,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Advertising" : "",
                                SecondMute = 5000,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Humiliation" : "",
                                SecondMute = 300,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Spam" : "",
                                SecondMute = 60,
                            },
                        },
                        MuteVoiceReasons = new List<ControllerMute.Muted>
                        {
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Aggressive behavior" : " ",
                                SecondMute = 100,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Insults" : "",
                                SecondMute = 300,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Disruption of the event by shouting" : "  ",
                                SecondMute = 300,
                            },
                        }
                    },

                    
                    
                    ControllerMessages = new ControllerMessage
                    {
                        Formatting = new ControllerMessage.FormattingMessage
                        {
                            UseBadWords = true,
                            BadWords = LanguageEn ? new List<String> { "fuckyou", "sucking", "fucking", "fuck" } : new List<String> { "", "", "", "" },
                            FormatMessage = true,
                            ReplaceBadWord = "***",
                            ControllerNickname = new ControllerMessage.FormattingMessage.NickController
                            {
                                BadNicks = LanguageEn ? new List<String> { "Admin", "Moderator", "Administrator", "Moder", "Owner", "Mercury Loh", "IQchat" } : new List<String> { "", "", "", "", "", "Mercury Loh", "IQchat" },
                                AllowedLinkNick = new List<String> { "mysite.com" },
                                ReplaceBadNick = "",
                                UseNickController = true,
                            },
                        },
                        TurnedFunc = new ControllerMessage.TurnedFuncional
                        {
                            HideAdminGave = true,
                            IgnoreUsePM = true,
                            MuteTeamChat = true,
                            AntiNoobSetting = new ControllerMessage.TurnedFuncional.AntiNoob
                            {
                                AntiNoobChat = new ControllerMessage.TurnedFuncional.AntiNoob.Settings
                                {
                                    AntiNoobActivate = false,
                                    TimeBlocked = 1200,
                                },
                                AntiNoobPM = new ControllerMessage.TurnedFuncional.AntiNoob.Settings
                                {
                                    AntiNoobActivate = false,
                                    TimeBlocked = 1200,
                                },
                            },
                            AntiSpamSetting = new ControllerMessage.TurnedFuncional.AntiSpam
                            {
                                AntiSpamActivate = true,
                                FloodTime = 10,
                                AntiSpamDuplesSetting = new ControllerMessage.TurnedFuncional.AntiSpam.AntiSpamDuples
                                {
                                    AntiSpamDuplesActivate = true,
                                    MuteSetting = new ControllerMute.Muted
                                    {
                                        Reason = LanguageEn ? "Duplicate messages (SPAM)" : "  ()",
                                        SecondMute = 300,
                                    },
                                    TryDuples = 3,
                                }
                            },
                            PMSetting = new ControllerMessage.TurnedFuncional.PM
                            {
                                PMActivate = true,
                                SoundPM = "assets/bundled/prefabs/fx/notice/stack.world.fx.prefab",
                            },
                        },
                        GeneralSetting = new ControllerMessage.GeneralSettings
                        {
                            BroadcastFormat = new ControllerMessage.GeneralSettings.BroadcastSettings
                            {
                                BroadcastColor = "#efedee",
                                BroadcastTitle = LanguageEn ? "<color=#68cacd><b>[Alert]</b></color>" : "<color=#68cacd><b>[]</b></color>",
                                Steam64IDAvatar = "0",
                            },
                            AlertFormat = new ControllerMessage.GeneralSettings.AlertSettings
                            {
                                AlertPlayerColor = "#efedee",
                                SoundAlertPlayer = "assets/bundled/prefabs/fx/notice/item.select.fx.prefab",
                            },
                            OtherSetting = new ControllerMessage.GeneralSettings.OtherSettings
                            {
                                TimeDeleteAlertUI = 5,
                                SizePrefix = 14,
                                SizeMessage = 14,
                                SizeNick = 14,
                            }
                        },
                    },

                    
                    
                    ControllerAlertSetting = new ControllerAlert
                    {
                        AlertSetting = new ControllerAlert.Alert
                        {
                            AlertMessage = true,
                            AlertMessageType = false,
                            MessageList = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Automatic message #1 (Edit in configuration)",
                                        "Automatic message #2 (Edit in configuration)",
                                        "Automatic message #3 (Edit in configuration)",
                                        "Automatic message #4 (Edit in configuration)",
                                        "Automatic message #5 (Edit in configuration)",
                                        "Automatic message #6 (Edit in configuration)",
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "  #1 (  )",
                                        "  #2 (  )",
                                        "  #3 (  )",
                                        "  #4 (  )",
                                        "  #5 (  )",
                                        "  #6 (  )",
                                    }
                                },
                            },
                            MessageListTimer = 60,
                        },
                        AdminSessionSetting = new ControllerAlert.AdminSession
                        {
                            ConnectedAlertAdmin = false,
                            DisconnectedAlertAdmin = false,
                        },
                        PlayerSessionSetting = new ControllerAlert.PlayerSession
                        {
                            ConnectedAlert = true,
                            ConnectedAvatarUse = true,
                            ConnectedWorld = true,
                            ConnectionAlertRandom = false,

                            DisconnectedAlert = true,
                            DisconnectedAlertRandom = false,
                            DisconnectedReason = true,

                            RandomConnectionAlert = new LanguageController
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "{0} flew in from {1}",
                                        "{0} flew into the server from{1}",
                                        "{0} jumped on a server"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "{0}     {1}",
                                        "{0}     {1}, ",
                                        "{0}   "
                                    }
                                }
                            },
                            RandomDisconnectedAlert = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "{0} gone to another world",
                                        "{0} left the server with a reason {1}",
                                        "{0} went to another server"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "{0}    ",
                                        "{0}      {1}",
                                        "{0}    "
                                    }
                                }
                            },
                        },
                        PersonalAlertSetting = new ControllerAlert.PersonalAlert
                        {
                            UseWelcomeMessage = true,
                            WelcomeMessage = new LanguageController
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Welcome to the server SUPERSERVER\nWe are glad that you chose us!",
                                        "Welcome back to the server!\nWe wish you good luck",
                                        "Welcome to the server\nWe have the best plugins",
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "    SUPERSERVER\n,   !",
                                        "   !\n  ",
                                        "   \n    ",
                                    }
                                }
                            },
                        }
                    },

                    
                    
                    ReferenceSetting = new ReferenceSettings
                    {
                        IQFakeActiveSettings = new ReferenceSettings.IQFakeActive
                        {
                            UseIQFakeActive = true,
                        },
                        IQRankSystems = new ReferenceSettings.IQRankSystem
                        {
                            FormatRank = "[{0}]",
                            FormatRankTime = "[{0}]",
                            UseRankSystem = false,
                            UseTimeStandart = true
                        },
                        XLevelsSettings = new ReferenceSettings.XLevels()
                        {
                            UseXLevels = false,
                            UseFullXLevels = false,
                        },
                        ClansSettings = new ReferenceSettings.Clans()
                        {
                            UseClanTag = false,
                        }
                    },

                    
                    
                    RustPlusSettings = new RustPlus
                    {
                        UseRustPlus = true,
                        DisplayNameAlert = LanguageEn ? "SUPER SERVER" : " ",
                    },

                    
                    
                    AnswerMessages = new AnswerMessage
                    {
                        UseAnswer = true,
                        AnswerMessageList = new Dictionary<String, LanguageController>()
                        {
                            ["wipe"] = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Wipe will be 27.06"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "  27.06"
                                    }
                                }
                            },
                            [""] = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Found a cheater? Write /report and send a complaint"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        " ? /report   "
                                    }
                                }
                            }
                        },
                    },

                    
                    
                    OtherSetting = new OtherSettings
                    {
                        UseCommandOnline = false,
                        LogsChat = new OtherSettings.LoggedChat
                        {
                            GlobalChatSettings = new OtherSettings.General
                            {
                                UseLogged = false,
                                Webhooks = "",
                            },
                            TeamChatSettings = new OtherSettings.General
                            {
                                UseLogged = false,
                                Webhooks = "",
                            }
                        },
                        LogsChatCommands = new OtherSettings.General
                        {
                            UseLogged = false,
                            Webhooks = "",
                        },
                        LogsPMChat = new OtherSettings.General
                        {
                            UseLogged = false,
                            Webhooks = "",
                        },
                        LogsMuted = new OtherSettings.General
                        {
                            UseLogged = false,
                            Webhooks = "",
                        },
                    },

                                    };
            }
        }
        private const String PermissionAntiSpam = "iqchat.antispamabuse";
        public List<FakePlayer> PlayerBases = new List<FakePlayer>();

        private void AlertDisconnected(BasePlayer player, String reason)
        {
            Configuration.ControllerAlert.AdminSession AlertSessionAdmin = config.ControllerAlertSetting.AdminSessionSetting;
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;
            GeneralInformation.RenameInfo RenameInformation = GeneralInfo.GetInfoRename(player.userID);

            if (AlertSessionPlayer.DisconnectedAlert)
            {
                if (!AlertSessionAdmin.DisconnectedAlertAdmin)
                    if (player.IsAdmin) return;

                String DisplayName = player.displayName;

                // Configuration.ControllerMessage ControllerMessage = config.ControllerMessages;

                // if (ControllerMessage.Formatting.ControllerNickname.UseNickController)
                //     foreach (String DetectedBadNick in DisplayName.Split(' '))
                //     {
                //         if (ControllerMessage.Formatting.ControllerNickname.BadNicks.Count(x => x.ToLower() == DetectedBadNick.ToLower()) > 0 && DetectedBadNick.Leght != 44423251)
                //             DisplayName = DisplayName.Replace(DetectedBadNick, ControllerMessage.Formatting.ControllerNickname.ReplaceBadNick);
                //     }

                UInt64 UserID = player.userID;
                if (RenameInformation != null)
                {
                    DisplayName = RenameInformation.RenameNick;
                    UserID = RenameInformation.RenameID;
                }

                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? UserID.ToString() : String.Empty;

                if (!permission.UserHasPermission(player.UserIDString, PermissionHideDisconnection))
                {
                    if (AlertSessionPlayer.DisconnectedAlertRandom)
                        ReplyBroadcast(null, Avatar, false, AlertSessionPlayer.RandomDisconnectedAlert.LanguageMessages,DisplayName, reason);
                    else
                    {
                        System.Object[] args = AlertSessionPlayer.DisconnectedReason ? new System.Object[] { DisplayName, reason } : new System.Object[] { DisplayName };
                        String Lang = AlertSessionPlayer.DisconnectedReason ? "LEAVE_PLAYER_REASON" : "LEAVE_PLAYER";
                        ReplyBroadcast(null, Avatar, false, Lang, args);
                    }
                }

                Log($"[{player.userID}] {(AlertSessionPlayer.DisconnectedReason ? GetLang("LEAVE_PLAYER_REASON", player.UserIDString, DisplayName, reason) : GetLang("LEAVE_PLAYER", player.UserIDString, DisplayName))}");
            }
        }
        
                private void DrawUI_IQChat_Mute_Alert(BasePlayer player, BasePlayer Target, UInt64 IDFake = 0)
        {
            String InterfacePanel = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Alert_Panel");
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_Alert");
            if (Interface == null || InterfacePanel == null) return;

            User InfoTarget = (IQFakeActive && Target == null && IDFake != 0) ? null : UserInformation[Target.userID];

            Interface = Interface.Replace("%TITLE%", GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT", player.UserIDString));
            Interface = Interface.Replace("%BUTTON_TAKE_CHAT_ACTION%", InfoTarget == null ? GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString) : InfoTarget.MuteInfo.IsMute(MuteType.Chat) ? GetLang("IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString) : GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString));
            Interface = Interface.Replace("%BUTTON_TAKE_VOICE_ACTION%", InfoTarget == null ? GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString) : InfoTarget.MuteInfo.IsMute(MuteType.Voice) ? GetLang("IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString) : GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString));
            Interface = Interface.Replace("%COMMAND_TAKE_ACTION_MUTE_CHAT%", InfoTarget == null ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {IDFake} {MuteType.Chat}" : InfoTarget.MuteInfo.IsMute(MuteType.Chat) ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} unmute.yes {Target.UserIDString} {MuteType.Chat}" : $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {Target.UserIDString} {MuteType.Chat}");
            Interface = Interface.Replace("%COMMAND_TAKE_ACTION_MUTE_VOICE%", InfoTarget == null ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {IDFake} {MuteType.Voice}" : InfoTarget.MuteInfo.IsMute(MuteType.Voice) ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} unmute.yes {Target.UserIDString} {MuteType.Voice}" : $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {Target.UserIDString} {MuteType.Voice}");

            CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
            CuiHelper.AddUi(player, InterfacePanel);
            CuiHelper.AddUi(player, Interface);
        }
        void SyncReservedFinish(string JSON)
        {
            if (!config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive) return;
            List<FakePlayer> ContentDeserialize = JsonConvert.DeserializeObject<List<FakePlayer>>(JSON);
            PlayerBases = ContentDeserialize;

            PrintWarning(LanguageEn ? "IQChat - successfully synced with IQFakeActive" : "IQChat -    IQFakeActive");
            PrintWarning("=============SYNC==================");
        }
        
                private void MutePlayer(BasePlayer Target, MuteType Type, Int32 ReasonIndex, BasePlayer Moderator = null, String ReasonCustom = null, Int32 TimeCustom = 0, Boolean HideMute = false, Boolean Command = false, UInt64 IDFake = 0)
        {
            Configuration.ControllerMute ControllerMutes = config.ControllerMutes;

            if (IQFakeActive && Target == null && (IQFakeActive && Target == null && IDFake != 0))
            {
                ReplySystem(Moderator, GetLang(Type == MuteType.Chat ? "FUNC_MESSAGE_MUTE_CHAT" : "FUNC_MESSAGE_MUTE_VOICE", Moderator != null ? Moderator.displayName : Moderator.UserIDString, GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER"), FindFakeName(IDFake), FormatTime(TimeCustom == 0 ? config.ControllerMutes.MuteChatReasons[ReasonIndex].SecondMute : TimeCustom), ReasonCustom ?? config.ControllerMutes.MuteChatReasons[ReasonIndex].Reason));
                RemoveReserved(IDFake);
                FakePlayer FakeP = PlayerBases.FirstOrDefault(x => x.UserID == IDFake);
                if (FakeP != null)
                    PlayerBases.Remove(FakeP);
                return;
            }

            if (!UserInformation.ContainsKey(Target.userID)) return;
            User Info = UserInformation[Target.userID];

            String LangMessage = String.Empty;
            String Reason = String.Empty;
            Int32 MuteTime = 0;

            String NameModerator = GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER", Target.UserIDString);

            if (Moderator != null)
            {
                GeneralInformation.RenameInfo ModeratorRename = GeneralInfo.GetInfoRename(Moderator.userID);
                NameModerator = ModeratorRename != null ? $"{ModeratorRename.RenameNick ?? Moderator.displayName}" : Moderator.displayName;
            }

            GeneralInformation.RenameInfo TagetRename = GeneralInfo.GetInfoRename(Target.userID);
            String TargetName = TagetRename != null ? $"{TagetRename.RenameNick ?? Target.displayName}" : Target.displayName;

            if (Target == null || !Target.IsConnected)
            {
                if (Moderator != null && !Command)
                    ReplySystem(Moderator, GetLang("UI_CHAT_PANEL_MODERATOR_MUTE_PANEL_TAKE_TYPE_CHAT_ACTION_NOT_CONNNECTED", Moderator.UserIDString));
                return;
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (Moderator != null && !Command)
                if (Info.MuteInfo.IsMute(Type))
                {
                    ReplySystem(Moderator, GetLang("IQCHAT_FUNCED_ALERT_TITLE_ISMUTED", Moderator.UserIDString));
                    return;
                }

            switch (Type)
            {
                case MuteType.Chat:
                    {
                        Reason = ReasonCustom ?? ControllerMutes.MuteChatReasons[ReasonIndex].Reason;
                        MuteTime = TimeCustom == 0 ? ControllerMutes.MuteChatReasons[ReasonIndex].SecondMute : TimeCustom;
                        LangMessage = "FUNC_MESSAGE_MUTE_CHAT";
                        break;
                    }
                case MuteType.Voice:
                    {
                        Reason = ReasonCustom ?? ControllerMutes.MuteVoiceReasons[ReasonIndex].Reason;
                        MuteTime = TimeCustom == 0 ? ControllerMutes.MuteVoiceReasons[ReasonIndex].SecondMute : TimeCustom;
                        LangMessage = "FUNC_MESSAGE_MUTE_VOICE";
                        break;
                    }
            }

            Info.MuteInfo.SetMute(Type, MuteTime);

            if (Moderator != null && Moderator != Target)
                Interface.Oxide.CallHook("OnPlayerMuted", Target, Moderator, MuteTime, Reason);

            if (!HideMute)
                ReplyBroadcast(null, null, false, LangMessage, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason);
               // ReplyBroadcast(GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason));
            else
            {
                if (Target != null)
                    ReplySystem(Target, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason));

                if (Moderator != null)
                    ReplySystem(Moderator, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason));
            }

            DiscordLoggMuted(Target, Type, Reason, FormatTime(MuteTime, Target.UserIDString), Moderator);
        }
        private Dictionary<BasePlayer, InformationOpenedUI> LocalBase = new Dictionary<BasePlayer, InformationOpenedUI>();
        public Dictionary<UInt64, AntiNoob> UserInformationConnection = new Dictionary<UInt64, AntiNoob>();
        /// <summary>
        ///  2.///
        ///  :
        /// -     
        /// -   FormatException    (   -     )
        /// </summary>
        
                [PluginReference] Plugin ImageLibrary, IQFakeActive, IQRankSystem, XLevels, Clans;
        
        
        void API_SEND_PLAYER(BasePlayer player, String PlayerFormat, String Message, String Avatar, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;

            String OutMessage = String.Empty; ;

            if (ControllerMessages.Formatting.FormatMessage)
                OutMessage = $"{Message.ToLower().Substring(0, 1).ToUpper()}{Message.Remove(0, 1).ToLower()}";
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (ControllerMessages.Formatting.UseBadWords)
                foreach (String DetectedMessage in OutMessage.Split(' '))
                    if (ControllerMessages.Formatting.BadWords.Contains(DetectedMessage.ToLower()))
                        OutMessage = OutMessage.Replace(DetectedMessage, ControllerMessages.Formatting.ReplaceBadWord);

            player.SendConsoleCommand("chat.add", channel, ulong.Parse(Avatar), $"{PlayerFormat}: {OutMessage}");
            player.ConsoleMessage($"{PlayerFormat}: {OutMessage}");
        }

        
        
        private String XLevel_GetLevel(BasePlayer player)
        {
            if (!XLevels || !config.ReferenceSetting.XLevelsSettings.UseXLevels) return String.Empty;
            return GetLang("XLEVELS_SYNTAX_PREFIX", player.UserIDString,
                (Int32)XLevels?.CallHook("API_GetLevel", player));
        }

        
                private String GetImage(String fileName, UInt64 skin = 0)
        {
            var imageId = (String)plugins.Find("ImageLibrary").CallHook("ImageUi.GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return String.Empty;
        }
        
                private void DrawUI_IQChat_Context(BasePlayer player)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Context");
            User Info = UserInformation[player.userID];
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            if (Info == null || ControllerParameter == null || Interface == null) return;

            String BackgroundStatic = IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem ? "UI_IQCHAT_CONTEXT_RANK" : "UI_IQCHAT_CONTEXT_NO_RANK";
            
            Interface = Interface.Replace("%IMG_BACKGROUND%", ImageUi.GetImage(BackgroundStatic));
            Interface = Interface.Replace("%TITLE%", GetLang("IQCHAT_CONTEXT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTING_ELEMENT%", GetLang("IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%INFORMATION%", GetLang("IQCHAT_CONTEXT_INFORMATION_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS%", GetLang("IQCHAT_CONTEXT_SETTINGS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_PM%", GetLang("IQCHAT_CONTEXT_SETTINGS_PM_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_ALERT%", GetLang("IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_ALERT_PM%", GetLang("IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_SOUNDS%", GetLang("IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%MUTE_STATUS_TITLE%", GetLang("IQCHAT_CONTEXT_MUTE_STATUS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%IGNORED_STATUS_COUNT%", GetLang("IQCHAT_CONTEXT_IGNORED_STATUS_COUNT", player.UserIDString, Info.Settings.IgnoreUsers.Count));
            Interface = Interface.Replace("%IGNORED_STATUS_TITLE%", GetLang("IQCHAT_CONTEXT_IGNORED_STATUS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%NICK_DISPLAY_TITLE%", GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_TITLE", player.UserIDString));
            Interface = Interface.Replace("%MUTE_STATUS_PLAYER%", Info.MuteInfo.IsMute(MuteType.Chat) ? FormatTime(Info.MuteInfo.GetTime(MuteType.Chat), player.UserIDString) : GetLang("IQCHAT_CONTEXT_MUTE_STATUS_NOT", player.UserIDString));
            Interface = Interface.Replace("%SLIDER_PREFIX_TITLE%", GetLang("IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SLIDER_NICK_COLOR_TITLE%", GetLang("IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE", player.UserIDString));

            Interface = Interface.Replace("%SLIDER_MESSAGE_COLOR_TITLE%",GetLang("IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE", player.UserIDString));
            
            Interface = Interface.Replace("%SLIDER_IQRANK_TITLE%", IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem ? GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE", player.UserIDString) : String.Empty);

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Context);
            CuiHelper.AddUi(player, Interface);

            DrawUI_IQChat_Update_DisplayName(player);

            if (ControllerParameter.VisualParametres.PrefixType == SelectedParametres.DropList || ControllerParameter.Prefixes.TurnMultiPrefixes)
                DrawUI_IQChat_DropList(player, "-46.788 67.4", "-14.788 91.4", GetLang("IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION", player.UserIDString), ControllerParameter.Prefixes.TurnMultiPrefixes ? TakeElementUser.MultiPrefix : TakeElementUser.Prefix);
            else DrawUI_IQChat_Sliders(player, "SLIDER_PREFIX", "-140 54", "-16 78", TakeElementUser.Prefix);

            if (ControllerParameter.VisualParametres.NickColorType == SelectedParametres.DropList)
                DrawUI_IQChat_DropList(player, "112.34 67.4", "144.34 91.4", GetLang("IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION", player.UserIDString), TakeElementUser.Nick);
            else DrawUI_IQChat_Sliders(player, "SLIDER_NICK_COLOR", "20 54", "144 78", TakeElementUser.Nick);
            
            if (ControllerParameter.VisualParametres.ChatColorType == SelectedParametres.DropList)
                DrawUI_IQChat_DropList(player, "-46.787 -0.591", "-14.787 23.409",GetLang("IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION", player.UserIDString),TakeElementUser.Chat);
            else DrawUI_IQChat_Sliders(player, "SLIDER_MESSAGE_COLOR", "-140 -12", "-16 12", TakeElementUser.Chat);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem)
            {
                if (ControllerParameter.VisualParametres.IQRankSystemType == SelectedParametres.DropList)
                    DrawUI_IQChat_DropList(player, "112.34 -0.591", "144.34 23.409", GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION", player.UserIDString), TakeElementUser.Rank);
                else DrawUI_IQChat_Sliders(player, "SLIDER_IQRANK", "20 -12", "144 12", TakeElementUser.Rank);
            }

            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.PM, "143.38 -67.9", "151.38 -59.9", Info.Settings.TurnPM);
            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.Broadcast, "143.38 -79.6", "151.38 -71.6", Info.Settings.TurnBroadcast);
            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.Alert, "143.38 -91.6", "151.38 -83.6", Info.Settings.TurnAlert);
            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.Sound, "143.38 -103.6", "151.38 -95.6", Info.Settings.TurnSound);
            DrawUI_IQChat_Context_AdminAndModeration(player);
        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
        
                void OnUserPermissionGranted(string id, string permName) => SetupParametres(id, permName);

        
        
        private List<String> GetPlayersOnline()
        {
            List<String> PlayerNames = new List<String>();
            Int32 Count = 1;

            foreach (BasePlayer playerInList in BasePlayer.activePlayerList.Where(p => !permission.UserHasPermission(p.UserIDString, PermissionHideOnline)))
            {
                String ResultName = $"{Count} - {GetPlayerFormat(playerInList)}";
                PlayerNames.Add(ResultName);

                Count++;
            }

            if (IQFakeActive)
            {
                foreach (FakePlayer fakePlayer in PlayerBases.Where(x => IsFake(x.UserID)))
                {
                    String ResultName = $"{Count} - {API_GET_DEFAULT_PREFIX()}<color={API_GET_DEFAULT_NICK_COLOR()}>{fakePlayer.DisplayName}</color>";
                    PlayerNames.Add(ResultName);

                    Count++;
                }
            }

            return PlayerNames;
        }

        [ConsoleCommand("alertui")]
        private void AlertUIConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            AlertUI(Sender, args.Args);
        }
        void API_SEND_PLAYER_DISCONNECTED(BasePlayer player, String DisplayName, String reason, String userID)
        {
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;

            if (AlertSessionPlayer.DisconnectedAlert)
            {
                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? userID : String.Empty;

                System.Object[] args = AlertSessionPlayer.DisconnectedReason ? new System.Object[] { DisplayName, reason } : new System.Object[] { DisplayName };
                String Lang = AlertSessionPlayer.DisconnectedReason ? "LEAVE_PLAYER_REASON" : "LEAVE_PLAYER";
                ReplyBroadcast(null, Avatar, false, Lang, args);
            }
        }

        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }
        private void OnServerInitialized()
        {
            _ = this;
            ImageUi.DownloadImages();

            MigrateDataToNoob();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                UserConnecteionData(player);

            RegisteredPermissions();
            BroadcastAuto();

            CheckValidateUsers();

            if (!config.ControllerMessages.Formatting.ControllerNickname.UseNickController)
                Unsubscribe("OnUserConnected");

        }
        
        void ReplyBroadcast(String CustomPrefix = null, String CustomAvatar = null, Boolean AdminAlert = false, Dictionary<String, List<String>> Messages = null, params object[] args)
        {
            foreach (BasePlayer p in !AdminAlert ? BasePlayer.activePlayerList.Where(p => UserInformation[p.userID].Settings.TurnBroadcast) : BasePlayer.activePlayerList)
            {
                sb.Clear();
                ReplySystem(p, sb.AppendFormat(GetMessages(p, Messages), args).ToString(), CustomPrefix, CustomAvatar);
            }
        }

        
        [ConsoleCommand("set")]
        private void CommandSet(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();

            if (Sender != null)
                if (!Sender.IsAdmin)
                    return;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (args == null || args.Args == null || args.Args.Length != 3)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "Use syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "   : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                else PrintWarning(LanguageEn ? "Use syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "   : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }

            UInt64 Steam64ID = 0;
            BasePlayer player = null;

            if (UInt64.TryParse(args.Args[0], out Steam64ID))
                player = BasePlayer.FindByID(Steam64ID);

            if (player == null)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "Incorrect player Steam ID or syntax error\nUse syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "  SteamID     \n   : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                else PrintWarning(LanguageEn ? "Incorrect player Steam ID or syntax error\nUse syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "  SteamID     \n   : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }
            if (!UserInformation.ContainsKey(player.userID))
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? $"Player not found!" : $"  !");
                else PrintWarning(LanguageEn ? $"Player not found!" : $"  !");
                return;
            }
            User Info = UserInformation[player.userID];
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;

            switch (args.Args[1])
            {
                case "prefix":
                    {
                        String KeyPrefix = args.Args[2];
                        if (ControllerParameter.Prefixes.Prefixes.Count(prefix => prefix.Argument.Contains(KeyPrefix)) == 0)
                        {
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? "Argument not found in your configuration" : $"     !");
                            else PrintWarning(LanguageEn ? $"Argument not found in your configuration" : $"     ");
                            return;
                        }

                        foreach (Configuration.ControllerParameters.AdvancedFuncion Prefix in ControllerParameter.Prefixes.Prefixes.Where(prefix => prefix.Argument.Contains(KeyPrefix)).Take(1))
                        {
                            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                                Info.Info.PrefixList.Add(Prefix.Argument);
                            else Info.Info.Prefix = Prefix.Argument;

                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Prefix successfully set to - {Prefix.Argument}" : $"    - {Prefix.Argument}");
                            else Puts(LanguageEn ? $"Prefix successfully set to - {Prefix.Argument}" : $"    - {Prefix.Argument}");
                        }
                        break;
                    }
                case "chat":
                    {
                        String KeyChatColor = args.Args[2];
                        if (ControllerParameter.MessageColorList.Count(color => color.Argument.Contains(KeyChatColor)) == 0)
                        {
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Argument not found in your configuration!" : $"     !");
                            else PrintWarning(LanguageEn ? $"Argument not found in your configuration" : $"     ");
                            return;
                        }

                        foreach (Configuration.ControllerParameters.AdvancedFuncion ChatColor in ControllerParameter.MessageColorList.Where(color => color.Argument.Contains(KeyChatColor)).Take(1))
                        {
                            Info.Info.ColorMessage = ChatColor.Argument;
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Message color successfully set to - {ChatColor.Argument}" : $"     - {ChatColor.Argument}");
                            else Puts(LanguageEn ? $"Message color successfully set to - {ChatColor.Argument}" : $"     - {ChatColor.Argument}");
                        }
                        break;
                    }
                case "nick":
                    {
                        String KeyNickColor = args.Args[2];
                        if (ControllerParameter.NickColorList.Count(color => color.Argument.Contains(KeyNickColor)) == 0)
                        {
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Argument not found in your configuration!" : $"     !");
                            else PrintWarning(LanguageEn ? "Argument not found in your configuration" : $"     ");
                            return;
                        }

                        foreach (Configuration.ControllerParameters.AdvancedFuncion NickColor in ControllerParameter.NickColorList.Where(color => color.Argument.Contains(KeyNickColor)).Take(1))
                        {
                            Info.Info.ColorNick = NickColor.Argument;
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Message color successfully set to - {NickColor.Argument}" : $"     - {NickColor.Argument}");
                            else Puts(LanguageEn ? $"Message color successfully set to - {NickColor.Argument}" : $"     - {NickColor.Argument}");
                        }
                        break;
                    }
                case "custom":
                    {
                        String CustomPrefix = args.Args[2];
                        if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                            Info.Info.PrefixList.Add(CustomPrefix);
                        else Info.Info.Prefix = CustomPrefix;
                        if (Sender != null)
                            ReplySystem(Sender, LanguageEn ? $"Custom prefix successfully set to - {CustomPrefix}" : $"     - {CustomPrefix}");
                        else Puts(LanguageEn ? $"Custom prefix successfully set to - {CustomPrefix}" : $"     - {CustomPrefix}");

                        break;
                    }
                default:
                    {
                        if (Sender != null)
                            ReplySystem(Sender, LanguageEn ? "Use syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "   : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                        break;
                    }
            }

        }
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }

        private object OnServerMessage(String message, String name)
        {
            if (config.ControllerMessages.TurnedFunc.HideAdminGave)
                if (message.Contains("gave") && name == "SERVER")
                    return true;
            return null;
        }
        void IQRankSetRank(ulong userID, string RankKey) => IQRankSystem?.Call("API_SET_ACTIVE_RANK", userID, RankKey);

        public class GeneralInformation
        {
            public Boolean TurnMuteAllChat;
            public Boolean TurnMuteAllVoice;

            public Dictionary<UInt64, RenameInfo> RenameList = new Dictionary<UInt64, RenameInfo>();
            internal class RenameInfo
            {
                public String RenameNick;
                public UInt64 RenameID;
            }

            public RenameInfo GetInfoRename(UInt64 UserID)
            {
                if (!RenameList.ContainsKey(UserID)) return null;
                return RenameList[UserID];
            }
        }


        private Tuple<String, Boolean> BadWordsCleaner(String FormattingMessage, String ReplaceBadWord, List<String> BadWords)
        {
            String ResultMessage = FormattingMessage;
            Boolean IsBadWords = false;

            foreach (String word in BadWords.Where(x => !x.Contains("*")))
            {
                MatchCollection matches = new Regex(@"\b(" + Regex.Escape(word) + @")\b").Matches(ResultMessage);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                foreach (Match match in matches)
                {
                    if (match.Success)
                    {
                        String found = match.Groups[1].ToString();
                        String replaced = "";

                        for (int i = 0; i < found.Length; i++) replaced = replaced + ReplaceBadWord;

                        ResultMessage = ResultMessage.Replace(found, replaced);
                        IsBadWords = true;
                    }
                    else break;
                }
            }

            return Tuple.Create(ResultMessage, IsBadWords);
        }

        private void DrawUI_IQChat_Mute_Alert_Reasons(BasePlayer player, BasePlayer Target, String Reason, Int32 Y, MuteType Type, UInt64 IDFake = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_Alert_DropList_Reason");
            if (Interface == null) return;

            Interface = Interface.Replace("%OFFSET_MIN%", $"-147.5 {85.42 - (Y * 40)}");
            Interface = Interface.Replace("%OFFSET_MAX%", $"147.5 {120.42 - (Y * 40)}");
            Interface = Interface.Replace("%REASON%", Reason);
            Interface = Interface.Replace("%COMMAND_REASON%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} confirm.yes {((IQFakeActive && Target == null && IDFake != 0) ? IDFake : Target.userID)} {Type} {Y}");
            CuiHelper.AddUi(player, Interface);
        }

        void ReadData()
        {
            if (!Oxide.Core.Interface.Oxide.DataFileSystem.ExistsDatafile("IQSystem/IQChat/Users") && Oxide.Core.Interface.Oxide.DataFileSystem.ExistsDatafile("IQChat/Users"))
            {
                GeneralInfo = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<GeneralInformation>("IQChat/Information");
                UserInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, User>>("IQChat/Users");

                Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Information", GeneralInfo);
                Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Users", UserInformation);

                PrintWarning(LanguageEn ? "Your player data has been moved to a new directory - IQSystem/IQChat , you can delete old data files!" : "        - IQSystem/IQChat ,     -!");
            }

            GeneralInfo = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<GeneralInformation>("IQSystem/IQChat/Information");
            UserInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, User>>("IQSystem/IQChat/Users");
            UserInformationConnection = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, AntiNoob>>("IQSystem/IQChat/AntiNoob");
        }
        void API_SEND_PLAYER_PM(BasePlayer player, string DisplayName, string Message)
        {
            ReplySystem(player, GetLang("COMMAND_PM_SEND_MSG", player.UserIDString, DisplayName, Message));
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            if (UserInformation.ContainsKey(player.userID))
                if (UserInformation[player.userID].Settings.TurnSound)
                    Effect.server.Run(config.ControllerMessages.TurnedFunc.PMSetting.SoundPM, player.GetNetworkPosition());
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        private static IQChat _;
        void Alert(BasePlayer Sender, BasePlayer Recipient, string[] arg)
        {
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            ReplySystem(Recipient, Message);
        }
        public bool IsFake(UInt64 userID)
        {
            if (!IQFakeActive) return false;
            return (bool)IQFakeActive?.Call("IsFake", userID);
        }
        private String GetMessageInArgs(BasePlayer Sender, String[] arg)
        {
            if (arg == null || arg.Length == 0)
            {
                if (Sender != null)
                    ReplySystem(Sender, GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST", Sender.UserIDString));
                else PrintWarning(GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST"));
                return null;
            }
            String Message = String.Empty;
            foreach (String msg in arg)
                Message += " " + msg;

            return Message;
        }

        private void RemoveParametres(String ID, String Permissions)
        {
            UInt64 UserID = UInt64.Parse(ID);
            BasePlayer player = BasePlayer.FindByID(UserID);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Configuration.ControllerConnection Controller = config.ControllerConnect;
            Configuration.ControllerParameters Parameters = config.ControllerParameter;

            if (!UserInformation.ContainsKey(UserID)) return;
            User Info = UserInformation[UserID];

            if (Controller.Turneds.TurnAutoDropPrefix)
            {
                if (Parameters.Prefixes.TurnMultiPrefixes)
                {
                    foreach (Configuration.ControllerParameters.AdvancedFuncion Prefixes in
                             Parameters.Prefixes.Prefixes.Where(prefix =>
                                 Info.Info.PrefixList.Contains(prefix.Argument) && prefix.Permissions == Permissions))
                    {
                        Info.Info.PrefixList.Remove(Prefixes.Argument);

                        if (player != null)
                            ReplySystem(player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefixes.Argument));

                        Log(LanguageEn
                            ? $"Player ({UserID}) expired prefix {Prefixes.Argument}"
                            : $"  ({UserID})   {Prefixes.Argument}");
                    }
                }
                else
                {
                    Configuration.ControllerParameters.AdvancedFuncion Prefixes = Parameters.Prefixes.Prefixes.FirstOrDefault(prefix => prefix.Argument == Info.Info.Prefix && prefix.Permissions == Permissions);
                    if (Prefixes != null)
                    {
                        Info.Info.Prefix = Controller.SetupDefaults.PrefixDefault;

                        if (player != null)
                            ReplySystem(player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefixes.Argument));

                        Log(LanguageEn
                            ? $"Player ({UserID}) expired prefix {Prefixes.Argument}"
                            : $"  ({UserID})   {Prefixes.Argument}");
                    }
                }
            }
            if (Controller.Turneds.TurnAutoSetupColorNick)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorNick = Parameters.NickColorList.FirstOrDefault(nick => Info.Info.ColorNick == nick.Argument && nick.Permissions == Permissions);
                if (ColorNick != null)
                {
                    Info.Info.ColorNick = Controller.SetupDefaults.NickDefault;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                    if (player != null)
                        ReplySystem(player, GetLang("COLOR_NICK_RETURNRED", player.UserIDString, ColorNick.Argument));
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                    Log(LanguageEn
                        ? $"Player ({UserID}) expired nick color {ColorNick.Argument}"
                        : $"  ({UserID})    {ColorNick.Argument}");
                }
            }
            if (Controller.Turneds.TurnAutoSetupColorChat)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorChat = Parameters.MessageColorList.FirstOrDefault(message => Info.Info.ColorMessage == message.Argument && message.Permissions == Permissions);
                if (ColorChat == null) return;

                Info.Info.ColorMessage = Controller.SetupDefaults.MessageDefault;

                if (player != null)
                    ReplySystem(player, GetLang("COLOR_CHAT_RETURNRED", player.UserIDString, ColorChat.Argument));

                Log(LanguageEn ? $"Player ({UserID}) chat color expired {ColorChat.Argument}" : $"  ({UserID})    {ColorChat.Argument}");
            }
        }
        private void UserConnecteionData(BasePlayer player)
        {
            if (config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM.AntiNoobActivate || config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobChat.AntiNoobActivate)
            {
                if (!UserInformationConnection.ContainsKey(player.userID))
                    UserInformationConnection.Add(player.userID, new AntiNoob());
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            Configuration.ControllerConnection ControllerConntect = config.ControllerConnect;
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            if (ControllerConntect == null || ControllerParameter == null || UserInformation.ContainsKey(player.userID)) return;

            User Info = new User();
            if (ControllerConntect.Turneds.TurnAutoSetupPrefix)
            {
                if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                    Info.Info.PrefixList.Add(ControllerConntect.SetupDefaults.PrefixDefault ?? "");
                else Info.Info.Prefix = ControllerConntect.SetupDefaults.PrefixDefault ?? "";
            }

            if (ControllerConntect.Turneds.TurnAutoSetupColorNick)
                Info.Info.ColorNick = ControllerConntect.SetupDefaults.NickDefault;

            if (ControllerConntect.Turneds.TurnAutoSetupColorChat)
                Info.Info.ColorMessage = ControllerConntect.SetupDefaults.MessageDefault;

            Info.Info.Rank = String.Empty;

            UserInformation.Add(player.userID, Info);
        }
        
        
                [ConsoleCommand("newui.cmd")]
        private void ConsoleCommandFuncional(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            String Action = arg.Args[0];
            if (Action == null || String.IsNullOrWhiteSpace(Action)) return;

            if (!LocalBase.ContainsKey(player))
            {
                PrintError(LanguageEn ? "UI was unable to process the local base (Local Base) contact the developer" : "UI      (LocalBase)   ");
                return;
            }
            Configuration.ControllerParameters ControllerParameters = config.ControllerParameter;
            if (ControllerParameters == null)
            {
                PrintError(LanguageEn ? "An error has been made in the configuration! Controller Parameters is null, contact developer" : "   ! ControllerParameters  null,   ");
                return;
            }

            switch (Action)
            {
                case "action.mute.ignore":
                    {
                        String ActionMenu = arg.Args[1];
                        SelectedAction ActionType = (SelectedAction)Enum.Parse(typeof(SelectedAction), arg.Args[2]);
                        if (ActionMenu == "search.controller" && arg.Args.Length < 4)
                            return;

                        switch (ActionMenu)
                        {
                            case "mute.controller":
                                {
                                    if (!player.IsAdmin)
                                        if (!permission.UserHasPermission(player.UserIDString, PermissionMute)) return;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                                    String ActionMute = arg.Args[3];
                                    switch (ActionMute)
                                    {
                                        case "mute.all.chat":
                                            {
                                                if (GeneralInfo.TurnMuteAllChat)
                                                {
                                                    GeneralInfo.TurnMuteAllChat = false;
                                                  //  ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT", player.UserIDString), AdminAlert: true);
                                                    ReplyBroadcast(null, null, true, "IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT");
                                                }
                                                else
                                                {
                                                    GeneralInfo.TurnMuteAllChat = true;
                                                   // ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT", player.UserIDString), AdminAlert: true);
                                                    ReplyBroadcast(null, null, true, "IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT");
                                                }

                                                DrawUI_IQChat_Update_MuteChat_All(player);
                                                break;
                                            }
                                        case "mute.all.voice":
                                            {
                                                if (GeneralInfo.TurnMuteAllVoice)
                                                {
                                                    GeneralInfo.TurnMuteAllVoice = false;
                                                 //   ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE", player.UserIDString), AdminAlert: true);
                                                    ReplyBroadcast(null, null, true, "IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE");
                                                }
                                                else
                                                {
                                                    GeneralInfo.TurnMuteAllVoice = true;
                                                   // ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE", player.UserIDString), AdminAlert: true);
                                                    ReplyBroadcast(null, null, true, "IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE");

                                                }
                                                DrawUI_IQChat_Update_MuteVoice_All(player);
                                                break;
                                            }
                                        default:
                                            break;
                                    }
                                    break;
                                }
                            case "ignore.and.mute.controller":
                                {
                                    String ActionController = arg.Args[3];
                                    BasePlayer TargetPlayer = BasePlayer.Find(arg.Args[4]);
                                    UInt64 ID = 0;
                                    UInt64.TryParse(arg.Args[4], out ID);

                                    if (TargetPlayer == null && !IsFake(ID))
                                    {
                                        CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                        return;
                                    }

                                    switch (ActionController)
                                    {
                                        case "confirm.alert":
                                            {
                                                if (ActionType == SelectedAction.Ignore)
                                                    DrawUI_IQChat_Ignore_Alert(player, TargetPlayer, ID);
                                                else DrawUI_IQChat_Mute_Alert(player, TargetPlayer, ID);
                                                break;
                                            }
                                        case "open.reason.mute":
                                            {
                                                MuteType Type = (MuteType)Enum.Parse(typeof(MuteType), arg.Args[5]);
                                                DrawUI_IQChat_Mute_Alert_Reasons(player, TargetPlayer, Type, IDFake: ID);
                                                break;
                                            }
                                        case "confirm.yes":
                                            {
                                                if (ActionType == SelectedAction.Ignore)
                                                {
                                                    User Info = UserInformation[player.userID];
                                                    Info.Settings.IgnoredAddOrRemove(IsFake(ID) ? ID : TargetPlayer.userID);

                                                    CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType);
                                                }
                                                else
                                                {
                                                    MuteType Type = (MuteType)Enum.Parse(typeof(MuteType), arg.Args[5]);
                                                    Int32 IndexReason = Int32.Parse(arg.Args[6]);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                                                    MutePlayer(TargetPlayer, Type, IndexReason, player, IDFake: ID);

                                                    CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType);
                                                }
                                                break;
                                            }
                                        case "unmute.yes":
                                            {
                                                MuteType Type = (MuteType)Enum.Parse(typeof(MuteType), arg.Args[5]);

                                                UnmutePlayer(TargetPlayer, Type, player);

                                                CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                                DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType);
                                                break;
                                            }
                                    }
                                    break;
                                }
                            case "open":
                                {
                                    DrawUI_IQChat_Mute_And_Ignore(player, ActionType);
                                    break;
                                }
                            case "page.controller":
                                {
                                    Int32 Page = Int32.Parse(arg.Args[3]);

                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType, Page);
                                    break;
                                }
                            case "search.controller":
                                {
                                    String SearchName = arg.Args[3];
                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType, SearchName: SearchName);
                                    break;
                                }
                            default:
                                break;
                        }

                        break;
                    }
                case "checkbox.controller":
                    {
                        ElementsSettingsType Type = (ElementsSettingsType)Enum.Parse(typeof(ElementsSettingsType), arg.Args[1]);
                        if (!UserInformation.ContainsKey(player.userID)) return;
                        User Info = UserInformation[player.userID];
                        if (Info == null) return;

                        switch (Type)
                        {
                            case ElementsSettingsType.PM:
                                {
                                    if (Info.Settings.TurnPM)
                                        Info.Settings.TurnPM = false;
                                    else Info.Settings.TurnPM = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -67.9", "151.38 -59.9", Info.Settings.TurnPM);
                                    break;
                                }
                            case ElementsSettingsType.Broadcast:
                                {
                                    if (Info.Settings.TurnBroadcast)
                                        Info.Settings.TurnBroadcast = false;
                                    else Info.Settings.TurnBroadcast = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -79.6", "151.38 -71.6", Info.Settings.TurnBroadcast);
                                    break;
                                }
                            case ElementsSettingsType.Alert:
                                {
                                    if (Info.Settings.TurnAlert)
                                        Info.Settings.TurnAlert = false;
                                    else Info.Settings.TurnAlert = true;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -91.6", "151.38 -83.6", Info.Settings.TurnAlert);
                                    break;
                                }
                            case ElementsSettingsType.Sound:
                                {
                                    if (Info.Settings.TurnSound)
                                        Info.Settings.TurnSound = false;
                                    else Info.Settings.TurnSound = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -103.6", "151.38 -95.6", Info.Settings.TurnSound);
                                    break;
                                }
                            default:
                                break;
                        }
                        break;
                    }
                case "droplist.controller":
                    {
                        String ActionDropList = arg.Args[1];
                        TakeElementUser Element = (TakeElementUser)Enum.Parse(typeof(TakeElementUser), arg.Args[2]);

                        switch (ActionDropList)
                        {
                            case "open":
                                {
                                    DrawUI_IQChat_OpenDropList(player, Element);
                                    break;
                                }
                            case "page.controller":
                                {
                                    String ActionDropListPage = arg.Args[3];
                                    Int32 Page = (Int32)Int32.Parse(arg.Args[4]);
                                    Page = ActionDropListPage == "+" ? Page + 1 : Page - 1;

                                    DrawUI_IQChat_OpenDropList(player, Element, Page);
                                    break;
                                }
                            case "element.take":
                                {
                                    Int32 Count = Int32.Parse(arg.Args[3]);
                                    String Permissions = arg.Args[4];
                                    String Argument = String.Join(" ", arg.Args.Skip(5));
                                    if (!permission.UserHasPermission(player.UserIDString, Permissions)) return;
                                    if (!UserInformation.ContainsKey(player.userID)) return;
                                    User User = UserInformation[player.userID];
                                    if (User == null) return;

                                    switch (Element)
                                    {
                                        case TakeElementUser.MultiPrefix:
                                            {
                                                if (!User.Info.PrefixList.Contains(Argument))
                                                {
                                                    User.Info.PrefixList.Add(Argument);
                                                    DrawUI_IQChat_OpenDropListArgument(player, Count);
                                                }
                                                else
                                                {
                                                    User.Info.PrefixList.Remove(Argument);
                                                    CuiHelper.DestroyUi(player, $"TAKED_INFO_{Count}");
                                                }
                                                break;
                                            }
                                        case TakeElementUser.Prefix:
                                            User.Info.Prefix = User.Info.Prefix.Equals(Argument) ? String.Empty : Argument;
                                            break;
                                        case TakeElementUser.Nick:
                                            User.Info.ColorNick = Argument;
                                            break;
                                        case TakeElementUser.Chat:
                                            User.Info.ColorMessage = Argument;
                                            break;
                                        case TakeElementUser.Rank:
                                            {
                                                User.Info.Rank = Argument;
                                                IQRankSetRank(player.userID, Argument);
                                            }
                                            break;
                                        default:
                                            break;
                                    }
                                    DrawUI_IQChat_Update_DisplayName(player);
                                    break;
                                }
                        }
                        break;
                    }
                case "slider.controller": // newui.cmd slider.controller 0 +
                    {
                        TakeElementUser Element = (TakeElementUser)Enum.Parse(typeof(TakeElementUser), arg.Args[1]);
                        List<Configuration.ControllerParameters.AdvancedFuncion> SliderElements = new List<Configuration.ControllerParameters.AdvancedFuncion>();
                        User Info = UserInformation[player.userID];
                        if (Info == null) return;

                        InformationOpenedUI InfoUI = LocalBase[player];
                        if (InfoUI == null) return;


                        String ActionSlide = arg.Args[2];

                        switch (Element)
                        {
                            case TakeElementUser.Prefix:
                                {
                                    SliderElements = LocalBase[player].ElementsPrefix;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexPrefix++;

                                        if (InfoUI.SlideIndexPrefix >= SliderElements.Count)
                                            InfoUI.SlideIndexPrefix = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexPrefix--;

                                        if (InfoUI.SlideIndexPrefix < 0)
                                            InfoUI.SlideIndexPrefix = SliderElements.Count - 1;
                                    }

                                    Info.Info.Prefix = SliderElements[InfoUI.SlideIndexPrefix].Argument;
                                }
                                break;
                            case TakeElementUser.Nick:
                                {
                                    SliderElements = LocalBase[player].ElementsNick;

                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexNick++;

                                        if (InfoUI.SlideIndexNick >= SliderElements.Count)
                                            InfoUI.SlideIndexNick = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexNick--;

                                        if (InfoUI.SlideIndexNick < 0)
                                            InfoUI.SlideIndexNick = SliderElements.Count - 1;
                                    }
                                    Info.Info.ColorNick = SliderElements[InfoUI.SlideIndexNick].Argument;
                                }
                                break;
                            case TakeElementUser.Chat:
                                {
                                    SliderElements = LocalBase[player].ElementsChat;
                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexChat++;

                                        if (InfoUI.SlideIndexChat >= SliderElements.Count)
                                            InfoUI.SlideIndexChat = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexChat--;
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                                        if (InfoUI.SlideIndexChat < 0)
                                            InfoUI.SlideIndexChat = SliderElements.Count - 1;
                                    }
                                    Info.Info.ColorMessage = SliderElements[InfoUI.SlideIndexChat].Argument;
                                }
                                break;
                            case TakeElementUser.Rank:
                                {
                                    SliderElements = LocalBase[player].ElementsRanks;
                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexRank++;

                                        if (InfoUI.SlideIndexRank >= SliderElements.Count)
                                            InfoUI.SlideIndexRank = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexRank--;

                                        if (InfoUI.SlideIndexRank < 0)
                                            InfoUI.SlideIndexRank = SliderElements.Count - 1;
                                    }
                                    Info.Info.Rank = SliderElements[InfoUI.SlideIndexRank].Argument;
                                    IQRankSetRank(player.userID, SliderElements[InfoUI.SlideIndexRank].Argument);
                                }
                                break;
                            default:
                                break;
                        }
                        DrawUI_IQChat_Slider_Update_Argument(player, Element);
                        DrawUI_IQChat_Update_DisplayName(player);
                        break;
                    }
                default:
                    break;
            }
        }
        private void AddHistoryMessage(BasePlayer player, String Message)
        {
            if (!LastMessagesChat.ContainsKey(player))
                LastMessagesChat.Add(player, new List<String> { Message });
            else LastMessagesChat[player].Add(Message);
        }

        private String GetPlayerFormat(BasePlayer playerInList)
        {
            GeneralInformation.RenameInfo Renamer = GeneralInfo.GetInfoRename(playerInList.userID);
            String NickNamed = Renamer != null ? $"{Renamer.RenameNick ?? playerInList.displayName}" : playerInList.displayName;

            User Info = UserInformation[playerInList.userID];

            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            Configuration.ControllerMute ControllerMutes = config.ControllerMutes;

            String Prefixes = String.Empty;
            String ColorNickPlayer = String.IsNullOrWhiteSpace(Info.Info.ColorNick) ? playerInList.IsAdmin ? "#a8fc55" : "#54aafe" : Info.Info.ColorNick;

            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
            {
                if (Info.Info.PrefixList != null)
                    Prefixes = String.Join("", Info.Info.PrefixList.Take(ControllerParameter.Prefixes.MaximumMultiPrefixCount));
            }
            else Prefixes = Info.Info.Prefix;

            String ResultName = $"{Prefixes}<color={ColorNickPlayer}>{NickNamed}</color>";

            return ResultName;
        }
        
        
        object OnPlayerVoice(BasePlayer player, Byte[] data)
        {
            if (UserInformation[player.userID].MuteInfo.IsMute(MuteType.Voice))
                return false;
            return null;
        }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                private void DrawUI_IQChat_Update_DisplayName(BasePlayer player)
        {
            String InterfaceVisualNick = InterfaceBuilder.GetInterface("UI_Chat_Context_Visual_Nick");
            User Info = UserInformation[player.userID];
            Configuration.ControllerParameters Controller = config.ControllerParameter;
            if (Info == null || InterfaceVisualNick == null || Controller == null) return;

            String DisplayNick = String.Empty;

            String Pattern = @"</?size.*?>";
            // if (Controller.Prefixes.TurnMultiPrefixes) 
            // {
            //     if (Info.Info.PrefixList != null && Info.Info.PrefixList.Count != 0)
            //         DisplayNick += Info.Info.PrefixList.Count > 1 ? $"{(Regex.IsMatch(Info.Info.PrefixList[0], Pattern) ? Regex.Replace(Info.Info.PrefixList[0], Pattern, "") : Info.Info.PrefixList[0])}+{Info.Info.PrefixList.Count - 1}" :
            //             (Regex.IsMatch(Info.Info.PrefixList[0], Pattern) ? Regex.Replace(Info.Info.PrefixList[0], Pattern, "") : Info.Info.PrefixList[0]);
            // }
            // else DisplayNick += Regex.IsMatch(Info.Info.Prefix, Pattern) ? Regex.Replace(Info.Info.Prefix, Pattern, "") : Info.Info.Prefix;
            //
            if (Controller.Prefixes.TurnMultiPrefixes)
            {
                if (Info.Info.PrefixList != null && Info.Info.PrefixList.Count != 0)
                {
                    if (Info.Info.PrefixList[0] != null && Regex.IsMatch(Info.Info.PrefixList[0], Pattern))
                        DisplayNick += Regex.Replace(Info.Info.PrefixList[0], Pattern, "");
                    else
                        DisplayNick += Info.Info.PrefixList[0];

                    DisplayNick += Info.Info.PrefixList.Count > 1 ? $"+{Info.Info.PrefixList.Count - 1}" : string.Empty;
                }
            }
            else
            {
                if (Info.Info.Prefix != null && Regex.IsMatch(Info.Info.Prefix, Pattern))
                    DisplayNick += Regex.Replace(Info.Info.Prefix, Pattern, "");
                else DisplayNick += Info.Info.Prefix;
            }

            DisplayNick += $"<color={Info.Info.ColorNick ?? "#ffffff"}>{player.displayName}</color>: <color={Info.Info.ColorMessage ?? "#ffffff"}>{GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE", player.UserIDString)}</color>";

            InterfaceVisualNick = InterfaceVisualNick.Replace("%NICK_DISPLAY%", DisplayNick);


            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Context_Visual_Nick);
            CuiHelper.AddUi(player, InterfaceVisualNick);
        }

        
        private static Configuration config = new Configuration();
        void WriteData()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Information", GeneralInfo);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Users", UserInformation);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/AntiNoob", UserInformationConnection);
        }

        
        
                private new void LoadDefaultMessages()
        {
            PrintWarning(LanguageEn ? "Language file is loading..." : "  ...");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} muted {1}\nDuration : {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} unmuted {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} muted voice to {1}\nDuration : {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} unmuted voice to {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Chat enabled",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Voice chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Voice chat enabled",
                ["FUNC_MESSAGE_MUTE_ALL_ALERT"] = "Blocking by Administrator",
                ["FUNC_MESSAGE_PM_TURN_FALSE"] = "The player has forbidden to send himself private messages",
                ["FUNC_MESSAGE_ALERT_TURN_FALSE"] = "The player has not been allowed to notify himself",

                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "You can not send an empty broadcast message!",

                ["UI_ALERT_TITLE"] = "<size=14><b>Notification</b></size>",
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                ["COMMAND_NOT_PERMISSION"] = "You dont have permissions to use this command",
                ["COMMAND_RENAME_NOTARG"] = "For rename use : /rename [NewNickname] [NewID (Optional)]",
                ["COMMAND_RENAME_NOT_ID"] = "Incorrect ID for renaming! Use Steam64ID or leave blank",
                ["COMMAND_RENAME_SUCCES"] = "You have successfully changed your nickname!\nyour nickname : {0}\nYour ID : {1}",
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                ["COMMAND_PM_NOTARG"] = "To send pm use : /pm Nickname Message",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Message is empty!",
                ["COMMAND_PM_NOT_USER"] = "User not found or offline",
                ["COMMAND_PM_SUCCESS"] = "Your private message sent successful\n\nMessage : {0}\n\nDelivered : {1}",
                ["COMMAND_PM_SEND_MSG"] = "Message from {0}\n\n{1}",

                ["COMMAND_R_NOTARG"] = "For reply use : /r Message",
                ["COMMAND_R_NOTMSG"] = "You dont have any private conversations yet!",

                ["FLOODERS_MESSAGE"] = "You're typing too fast! Please Wait {0} seconds",

                ["PREFIX_SETUP"] = "You have successfully removed the prefix {0}, it is already activated and installed",
                ["COLOR_CHAT_SETUP"] = "You have successfully picked up the <color={0}>chat color</color>, it is already activated and installed",
                ["COLOR_NICK_SETUP"] = "You have successfully taken the <color={0}>nickname color</color>, it is already activated and installed",

                ["PREFIX_RETURNRED"] = "Your prefix {0} expired, it was reset automatically",
                ["COLOR_CHAT_RETURNRED"] = "Action of your <color={0}>color chat</color> over, it is reset automatically",
                ["COLOR_NICK_RETURNRED"] = "Action of your <color={0}>color nick</color> over, it is reset automatically",

                ["WELCOME_PLAYER"] = "{0} came online",
                ["LEAVE_PLAYER"] = "{0} left",
                ["WELCOME_PLAYER_WORLD"] = "{0} came online. Country: {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} left. Reason: {1}",

                ["IGNORE_ON_PLAYER"] = "You added {0} in black list",
                ["IGNORE_OFF_PLAYER"] = "You removed {0} from black list",
                ["IGNORE_NO_PM"] = "This player added you in black list. Your message has not been delivered.",
                ["IGNORE_NO_PM_ME"] = "You added this player in black list. Your message has not been delivered.",
                ["INGORE_NOTARG"] = "To ignore a player use : /ignore nickname",

                ["DISCORD_SEND_LOG_CHAT"] = "Player : {0}({1})\nFiltred message : {2}\nMessage : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) give mute chat\nSuspect : {2}({3})\nReason : {4}",

                ["TITLE_FORMAT_DAYS"] = "D",
                ["TITLE_FORMAT_HOURSE"] = "H",
                ["TITLE_FORMAT_MINUTES"] = "M",
                ["TITLE_FORMAT_SECONDS"] = "S",

                ["IQCHAT_CONTEXT_TITLE"] = "SETTING UP A CHAT", ///"%TITLE%"
                ["IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE"] = "CUSTOM SETTING", ///"%SETTING_ELEMENT%"
                ["IQCHAT_CONTEXT_INFORMATION_TITLE"] = "INFORMATION", ///"%INFORMATION%"
                ["IQCHAT_CONTEXT_SETTINGS_TITLE"] = "SETTINGS", ///"%SETTINGS%"
                ["IQCHAT_CONTEXT_SETTINGS_PM_TITLE"] = "Private messages", ///"%SETTINGS_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE"] = "Notification in the chat", ///"%SETTINGS_ALERT%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE"] = "Mention in the chat", ///"%SETTINGS_ALERT_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE"] = "Sound notification", ///"%SETTINGS_SOUNDS%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_NOT"] = "NO", ///"%MUTE_STATUS_PLAYER%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_TITLE"] = "Blocking the chat", ///"%MUTE_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_COUNT"] = "<size=11>{0}</size> human ()", ///"%IGNORED_STATUS_COUNT%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_TITLE"] = "Ignoring", ///"%IGNORED_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_TITLE"] = "Your nickname", ///"%NICK_DISPLAY_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE"] = "i love iqchat",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE"] = "Prefix", /// %SLIDER_PREFIX_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE"] = "Nick", /// %SLIDER_NICK_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE"] = "Message", /// %SLIDER_MESSAGE_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE"] = "Rank",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER"] = "Absent",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION"] = "Choosing a prefix", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION"] = "Choosing a nickname color", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION"] = "Chat Color Selection", /// 
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION"] = "Rank Selection", /// 
                ["IQCHAT_CONTEXT_DESCRIPTION_PREFIX"] = "Prefix Setting",
                ["IQCHAT_CONTEXT_DESCRIPTION_NICK"] = "Setting up a nickname",
                ["IQCHAT_CONTEXT_DESCRIPTION_CHAT"] = "Setting up a message",
                ["IQCHAT_CONTEXT_DESCRIPTION_RANK"] = "Setting up the rank",

                ["IQCHAT_ALERT_TITLE"] = "ALERT", /// %TITLE_ALERT%

                ["IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED"] = "LOCK MANAGEMENT",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED"] = "IGNORING MANAGEMENT",
                ["IQCHAT_TITLE_IGNORE_TITLES"] = "<b>DO YOU REALLY WANT TO IGNORE\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_TITLES_UNLOCK"] = "<b>DO YOU WANT TO REMOVE THE IGNORING FROM THE PLAYER\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_YES"] = "<b>YES, I WANT TO</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_NO"] = "<b>NO, I CHANGED MY MIND</b>",
                ["IQCHAT_TITLE_MODERATION_PANEL"] = "MODERATOR PANEL",

                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU"] = "Lock Management",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT"] = "SELECT AN ACTION",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON"] = "SELECT THE REASON FOR BLOCKING",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT"] = "Block chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE"] = "Block voice",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT"] = "Unblock chat",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE"] = "Unlock voice",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT"] = "Block all chat",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT"] = "Unblock all chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE"] = "Block everyone's voice",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE"] = "Unlock everyone's voice",

                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED"] = "You have an active chat lock : {0}",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT"] = "The administrator blocked everyone's chat. Expect full unblocking",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE"] = "The administrator blocked everyone's voice chat. Expect full unblocking",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE"] = "The administrator has unblocked the voice chat for everyone",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT"] = "The administrator has unblocked the chat for everyone",

                ["IQCHAT_FUNCED_ALERT_TITLE"] = "<color=#a7f64f><b>[MENTION]</b></color>",
                ["IQCHAT_FUNCED_ALERT_TITLE_ISMUTED"] = "The player has already been muted!",
                ["IQCHAT_FUNCED_ALERT_TITLE_SERVER"] = "Administrator",

                ["IQCHAT_INFO_ONLINE"] = "Now on the server :\n{0}",

                ["IQCHAT_INFO_ANTI_NOOB"] = "You first connected to the server!\nPlay some more {0}\nTo get access to send messages to the global and team chat!",
                ["IQCHAT_INFO_ANTI_NOOB_PM"] = "You first connected to the server!\nPlay some more {0}\nTo access sending messages to private messages!",

                ["XLEVELS_SYNTAX_PREFIX"] = "[{0} Level]",
                ["CLANS_SYNTAX_PREFIX"] = "[{0}]",
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            }, this);
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0}    {1}\n : {2}\n : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0}    {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0}    {1}\n : {2}\n : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0}    {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "    ",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "    ",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "    ",
                ["FUNC_MESSAGE_MUTE_ALL_ALERT"] = " ",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "    ",

                ["FUNC_MESSAGE_PM_TURN_FALSE"] = "     ",
                ["FUNC_MESSAGE_ALERT_TURN_FALSE"] = "   ",

                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "       !",

                ["UI_ALERT_TITLE"] = "<size=14><b></b></size>",

                ["COMMAND_NOT_PERMISSION"] = "      ",
                ["COMMAND_RENAME_NOTARG"] = "   : /rename [] [ID ( )]",
                ["COMMAND_RENAME_NOT_ID"] = "  ID  !  Steam64ID,    ",
                ["COMMAND_RENAME_SUCCES"] = "   !\n  : {0}\n ID : {1}",

                ["COMMAND_PM_NOTARG"] = "   : /pm   ",
                ["COMMAND_PM_NOT_NULL_MSG"] = "     ",
                ["COMMAND_PM_NOT_USER"] = "      ",
                ["COMMAND_PM_SUCCESS"] = "   \n\n : {0}\n\n : {1}",
                ["COMMAND_PM_SEND_MSG"] = "  {0}\n\n{1}",

                ["COMMAND_R_NOTARG"] = "   : /r ",
                ["COMMAND_R_NOTMSG"] = "         !",

                ["FLOODERS_MESSAGE"] = "   !  {0} ",

                ["PREFIX_SETUP"] = "    {0},     ",
                ["COLOR_CHAT_SETUP"] = "   <color={0}> </color>,     ",
                ["COLOR_NICK_SETUP"] = "   <color={0}> </color>,     ",

                ["PREFIX_RETURNRED"] = "   {0} ,   ",
                ["COLOR_CHAT_RETURNRED"] = "  <color={0}> </color> ,   ",
                ["COLOR_NICK_RETURNRED"] = "  <color={0}> </color> ,   ",

                ["WELCOME_PLAYER"] = "{0}   ",
                ["LEAVE_PLAYER"] = "{0}   ",
                ["WELCOME_PLAYER_WORLD"] = "{0}   . {1}",
                ["LEAVE_PLAYER_REASON"] = "{0}   . {1}",

                ["IGNORE_ON_PLAYER"] = "   {0}   ",
                ["IGNORE_OFF_PLAYER"] = "   {0}   ",
                ["IGNORE_NO_PM"] = "     ,    ",
                ["IGNORE_NO_PM_ME"] = "     ,    ",
                ["INGORE_NOTARG"] = "   : /ignore  ",

                ["DISCORD_SEND_LOG_CHAT"] = " : {0}({1})\n  : {2}\n  : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1})   \n : {2}({3})\n : {4}",

                ["TITLE_FORMAT_DAYS"] = "",
                ["TITLE_FORMAT_HOURSE"] = "",
                ["TITLE_FORMAT_MINUTES"] = "",
                ["TITLE_FORMAT_SECONDS"] = "",

                ["IQCHAT_CONTEXT_TITLE"] = " ", ///"%TITLE%"
                ["IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE"] = " ", ///"%SETTING_ELEMENT%"
                ["IQCHAT_CONTEXT_INFORMATION_TITLE"] = "", ///"%INFORMATION%"
                ["IQCHAT_CONTEXT_SETTINGS_TITLE"] = "", ///"%SETTINGS%"
                ["IQCHAT_CONTEXT_SETTINGS_PM_TITLE"] = " ", ///"%SETTINGS_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE"] = "  ", ///"%SETTINGS_ALERT%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE"] = "  ", ///"%SETTINGS_ALERT_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE"] = " ", ///"%SETTINGS_SOUNDS%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_NOT"] = "", ///"%MUTE_STATUS_PLAYER%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_TITLE"] = " ", ///"%MUTE_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_COUNT"] = "<size=11>{0}</size>  ()", ///"%IGNORED_STATUS_COUNT%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_TITLE"] = "", ///"%IGNORED_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_TITLE"] = " ", ///"%NICK_DISPLAY_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE"] = " iqchat",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE"] = "", /// %SLIDER_PREFIX_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE"] = "", /// %SLIDER_NICK_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE"] = "", /// %SLIDER_MESSAGE_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE"] = "",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER"] = "",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION"] = " ", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION"] = "  ", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION"] = "  ", /// 
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION"] = " ", /// 
                ["IQCHAT_CONTEXT_DESCRIPTION_PREFIX"] = " ",
                ["IQCHAT_CONTEXT_DESCRIPTION_NICK"] = " ",
                ["IQCHAT_CONTEXT_DESCRIPTION_CHAT"] = " ",
                ["IQCHAT_CONTEXT_DESCRIPTION_RANK"] = " ",

		   		 		  						  	   		  	  			  	  			  	 				  	  	
                ["IQCHAT_ALERT_TITLE"] = "", /// %TITLE_ALERT%
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED"] = " ",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED"] = " ",
                ["IQCHAT_TITLE_IGNORE_TITLES"] = "<b>   \n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_TITLES_UNLOCK"] = "<b>     \n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_YES"] = "<b>, </b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_NO"] = "<b>, </b>",
                ["IQCHAT_TITLE_MODERATION_PANEL"] = " ",

                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU"] = " ",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT"] = " ",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON"] = "  ",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT"] = " ",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE"] = " ",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT"] = " ",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE"] = " ",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT"] = "  ",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT"] = "  ",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE"] = "  ",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE"] = "  ",

                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED"] = "      : {0}",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT"] = "   .   ",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE"] = "    .   ",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE"] = "    ",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT"] = "   ",

                ["IQCHAT_FUNCED_ALERT_TITLE"] = "<color=#a7f64f><b>[]</b></color>",
                ["IQCHAT_FUNCED_ALERT_TITLE_ISMUTED"] = "   !",
                ["IQCHAT_FUNCED_ALERT_TITLE_SERVER"] = "",

                ["IQCHAT_INFO_ONLINE"] = "   :\n{0}",
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                ["IQCHAT_INFO_ANTI_NOOB"] = "    !\n  {0}\n          !",
                ["IQCHAT_INFO_ANTI_NOOB_PM"] = "    !\n  {0}\n        !",
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                ["XLEVELS_SYNTAX_PREFIX"] = "[{0} Level]",
                ["CLANS_SYNTAX_PREFIX"] = "[{0}]",

            }, this, "ru");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} silenciado {1}\n Duracin: {2}\nRazn: {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} sin silenciar {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} voz apagada a {1}\n Duracion : {2}\n Razon : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} voz no silenciada a {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Chat desactivado",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Chat habilitado",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Chat de voz desactivado",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Chat de voz habilitado",
                ["FUNC_MESSAGE_MUTE_ALL_ALERT"] = "Bloqueo por parte del administrador",
                ["FUNC_MESSAGE_PM_TURN_FALSE"] = "El jugador tiene prohibido enviarse mensajes privados",
                ["FUNC_MESSAGE_ALERT_TURN_FALSE"] = "El jugador no ha podido notificarse a s mismo",
                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "No se puede enviar un mensaje vaco.",
                ["UI_ALERT_TITLE"] = "<size=14><b>Notificacin</b></size>",
                ["COMMAND_NOT_PERMISSION"] = "No tienes permisos para usar este comando",
                ["COMMAND_RENAME_NOTARG"] = "Para renombrar utilice : /rename [NewNickname] [NewID (Optional)]",
                ["COMMAND_RENAME_NOT_ID"] = "ID incorrecto para renombrar! Utilice Steam64ID o djelo en blanco",
                ["COMMAND_RENAME_SUCCES"] = "Has cambiado con xito tu nombre de usuario. \n Tu nombre de usuario: {0}. \nTu ID: {1}.",
                ["COMMAND_PM_NOTARG"] = "Para enviar pm utilice : /pm [Nombre] [Mensaje]",
                ["COMMAND_PM_NOT_NULL_MSG"] = "El mensaje est vaco!",
                ["COMMAND_PM_NOT_USER"] = "Usuario no encontrado o desconectado",
                ["COMMAND_PM_SUCCESS"] = "Su mensaje privado enviado con xito \n Mensage : {0}\n : Entregado{1}",
                ["COMMAND_PM_SEND_MSG"] = "Mensaje de {0}\n{1}",
                ["COMMAND_R_NOTARG"] = "Para responder utilice : /r Mensaje",
                ["COMMAND_R_NOTMSG"] = "Todava no tienes ninguna conversacin privada.",
                ["FLOODERS_MESSAGE"] = "Ests escribiendo demasiado rpido! Por favor, espere {0} segundos",
                ["PREFIX_SETUP"] = "Has eliminado con xito el prefijo {0}.",
                ["COLOR_CHAT_SETUP"] = "Has obtenido un nuevo color en el chat",
                ["COLOR_NICK_SETUP"] = "Has cambiado tu nick correctamente del chat",
                ["PREFIX_RETURNRED"] = "Su prefijo {0} ha caducado, se ha restablecido automticamente",
                ["COLOR_CHAT_RETURNRED"] = "Accin de su <color={0}>color de chat</color> ms, se restablece automticamente",
                ["COLOR_NICK_RETURNRED"] = "Accin de su <color={0}>color nick</color> sobre, se restablece automticamente",
                ["WELCOME_PLAYER"] = "{0} Se ha conectado",
                ["LEAVE_PLAYER"] = "{0} izquierda",
                ["WELCOME_PLAYER_WORLD"] = "{0} Se ha conectado del Pais: {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} Se ha desconectado. Razon: {1}",
                ["IGNORE_ON_PLAYER"] = "Has aadido {0} en la lista negra",
                ["IGNORE_OFF_PLAYER"] = "Has eliminado el jugador {0} de la lista negra",
                ["IGNORE_NO_PM"] = "Este jugador te ha aadido a la lista negra. Su mensaje no ha sido entregado.",
                ["IGNORE_NO_PM_ME"] = "Has aadido a este jugador en la lista negra. Su mensaje no ha sido entregado.",
                ["INGORE_NOTARG"] = "Para ignorar a un jugador utiliza : /ignore nickname",
                ["DISCORD_SEND_LOG_CHAT"] = "JUgador : {0}({1})\nMensaje filtrado : {2}\nMensages : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) give mute chat\nSuspect : {2}({3})\nReason : {4}",
                ["TITLE_FORMAT_DAYS"] = "D",
                ["TITLE_FORMAT_HOURSE"] = "H",
                ["TITLE_FORMAT_MINUTES"] = "M",
                ["TITLE_FORMAT_SECONDS"] = "S",
                ["IQCHAT_CONTEXT_TITLE"] = "ESTABLECER UN CHAT",
                ["IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE"] = "AJUSTE PERSONALIZADO",
                ["IQCHAT_CONTEXT_INFORMATION_TITLE"] = "INFORMACIN",
                ["IQCHAT_CONTEXT_SETTINGS_TITLE"] = "AJUSTES",
                ["IQCHAT_CONTEXT_SETTINGS_PM_TITLE"] = "Mensajes privados",
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE"] = "Notificacin en el chat",
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE"] = "Mencin en el chat",
                ["IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE"] = "Notificacin sonora",
                ["IQCHAT_CONTEXT_MUTE_STATUS_NOT"] = "NO",
                ["IQCHAT_CONTEXT_MUTE_STATUS_TITLE"] = "Bloqueo del chat",
                ["IQCHAT_CONTEXT_IGNORED_STATUS_COUNT"] = "<size=11>{0}</size> humano ()",
                ["IQCHAT_CONTEXT_IGNORED_STATUS_TITLE"] = "Ignorando",
                ["IQCHAT_CONTEXT_NICK_DISPLAY_TITLE"] = "Su apodo",
                ["IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE"] = "Me encanta Zoxiland",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE"] = "Prefijo",
                ["IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE"] = "Nick",
                ["IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE"] = "Mensaje",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE"] = "Rango",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER"] = "Ausente",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION"] = "Elegir un prefijo",
                ["IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION"] = "Elegir un color de apodo",
                ["IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION"] = "Seleccin del color del chat",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION"] = "Seleccin de rangos",
                ["IQCHAT_CONTEXT_DESCRIPTION_PREFIX"] = "Ajuste del prefijo",
                ["IQCHAT_CONTEXT_DESCRIPTION_NICK"] = "Configurar un apodo",
                ["IQCHAT_CONTEXT_DESCRIPTION_CHAT"] = "Configurar un mensaje",
                ["IQCHAT_CONTEXT_DESCRIPTION_RANK"] = "Establecimiento del rango",
                ["IQCHAT_ALERT_TITLE"] = "ALERTA",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED"] = "GESTIN MUTEADOS",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED"] = "GESTIN IGNORE",
                ["IQCHAT_TITLE_IGNORE_TITLES"] = "<b>REALMENTE QUIERES IGNORAR\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_TITLES_UNLOCK"] = "<b>QUIERES QUITARLE AL JUGADOR LO DE IGNORAR?\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_YES"] = "<b>S, QUIERO</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_NO"] = "<b>NO, HE CAMBIADO DE OPININ</b>",
                ["IQCHAT_TITLE_MODERATION_PANEL"] = "PANEL DE MODERADORES",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU"] = "Menu de muteados",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT"] = "SELECCIONE UNA ACCIN",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON"] = "SELECCIONE EL MOTIVO DEL BLOQUEO",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT"] = "Bloquear el Chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE"] = "Bloquear Voz",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT"] = "Desbloquear Chat",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE"] = "Desbloquear Voz",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT"] = "Bloquear todos los chats",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT"] = "Desbloquear todo el chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE"] = "Bloquear la voz de todos",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE"] = "Desbloquear la voz de todos",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED"] = "Tienes un bloqueo de chat activo : {0}",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT"] = "El administrador ha bloqueado el chat. Espera el desbloqueo completo",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE"] = "El administrador ha bloqueado el chat de voz. Espera el desbloqueo completo",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE"] = "El administrador ha desbloqueado el chat de voz.",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT"] = "El administrador ha desbloqueado el chat",
                ["IQCHAT_FUNCED_ALERT_TITLE"] = "<color=#a7f64f><b>[MENCIN]</b></color>",
                ["IQCHAT_FUNCED_ALERT_TITLE_ISMUTED"] = "El jugador ya ha sido silenciado.",
                ["IQCHAT_FUNCED_ALERT_TITLE_SERVER"] = "Administrador",
                ["IQCHAT_INFO_ONLINE"] = "Now on the server :\n{0}",
                ["IQCHAT_INFO_ANTI_NOOB"] = "Tienes que jugar un poco mas para poder hablar por el chat {0}.",
                ["IQCHAT_INFO_ANTI_NOOB_PM"] = "No puedes enviar un privado por que es un jugador nuevo.",
                ["XLEVELS_SYNTAX_PREFIX"] = "[{0} Level]",
                ["CLANS_SYNTAX_PREFIX"] = "[{0}]",
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            }, this, "es-ES");

            PrintWarning(LanguageEn ? "Language file uploaded successfully" : "   ");
        }
        private const String PermissionRename = "iqchat.renameuse";

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        private void DrawUI_IQChat_Context_AdminAndModeration(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionMute)) return;

            String InterfaceModeration = InterfaceBuilder.GetInterface("UI_Chat_Moderation");
            if (InterfaceModeration == null) return;

            InterfaceModeration = InterfaceModeration.Replace("%TITLE%", GetLang("IQCHAT_TITLE_MODERATION_PANEL", player.UserIDString));
            InterfaceModeration = InterfaceModeration.Replace("%COMMAND_MUTE_MENU%", $"newui.cmd action.mute.ignore open {SelectedAction.Mute}");
            InterfaceModeration = InterfaceModeration.Replace("%TEXT_MUTE_MENU%", GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU", player.UserIDString));

            CuiHelper.AddUi(player, InterfaceModeration);

            DrawUI_IQChat_Update_MuteChat_All(player);
            DrawUI_IQChat_Update_MuteVoice_All(player);
        }

        void OnUserGroupRemoved(string id, string groupName)
        {
            String[] PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;

            foreach (String permName in PermissionsGroup)
                RemoveParametres(id, permName);
        }
        private void CheckValidateUsers()
        {
            Configuration.ControllerParameters Controller = config.ControllerParameter;
            Configuration.ControllerConnection ControllerConnection = config.ControllerConnect;

            List<Configuration.ControllerParameters.AdvancedFuncion> Prefixes = Controller.Prefixes.Prefixes;
            List<Configuration.ControllerParameters.AdvancedFuncion> NickColor = Controller.NickColorList;
            List<Configuration.ControllerParameters.AdvancedFuncion> ChatColor = Controller.MessageColorList;

            foreach (KeyValuePair<UInt64, User> Info in UserInformation)
            {
                if (Controller.Prefixes.TurnMultiPrefixes)
                {
                    foreach (String Prefix in Info.Value.Info.PrefixList.Where(prefixList => !Prefixes.Exists(i => i.Argument == prefixList)))
                        NextTick(() => Info.Value.Info.PrefixList.Remove(Prefix));
                }
                else
                {
                    if (!Prefixes.Exists(i => i.Argument == Info.Value.Info.Prefix))
                        Info.Value.Info.Prefix = ControllerConnection.SetupDefaults.PrefixDefault;
                }
                if (!NickColor.Exists(i => i.Argument == Info.Value.Info.ColorNick))
                    Info.Value.Info.ColorNick = ControllerConnection.SetupDefaults.NickDefault;

                if (!ChatColor.Exists(i => i.Argument == Info.Value.Info.ColorMessage))
                    Info.Value.Info.ColorMessage = ControllerConnection.SetupDefaults.MessageDefault;
            }
        }


        
                public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }
        public Boolean AddImage(String url, String shortname, UInt64 skin = 0) => (Boolean)ImageLibrary?.Call("AddImage", url, shortname, skin);
        void AlertUI(BasePlayer Sender, BasePlayer Recipient, string[] arg)
        {
            if (_interface == null)
            {
                PrintWarning(LanguageEn ? "We generate the interface, wait for a message about successful generation" : " ,     ");
                return;
            }
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            DrawUI_IQChat_Alert(Recipient, Message);
        }
        internal class AntiNoob
        {
            public DateTime DateConnection = DateTime.UtcNow;

            public Boolean IsNoob(Int32 TimeBlocked)
            {
                System.TimeSpan Time = DateTime.UtcNow.Subtract(DateConnection);
                return Time.TotalSeconds < TimeBlocked;
            }

            public Double LeftTime(Int32 TimeBlocked)
            {
                System.TimeSpan Time = DateTime.UtcNow.Subtract(DateConnection);

                return (TimeBlocked - Time.TotalSeconds);
            }
        }

        private void DrawUI_IQChat_Alert(BasePlayer player, String Description, String Title = null)
        {
            if (_interface == null)
            {
                PrintWarning(" ,     ");
                return;
            }
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Alert");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE%", Title ?? GetLang("IQCHAT_ALERT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%DESCRIPTION%", Description);

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Alert);
            CuiHelper.AddUi(player, Interface);

            player.Invoke(() =>
            {
                CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Alert);
            }, config.ControllerMessages.GeneralSetting.OtherSetting.TimeDeleteAlertUI);
        }
        void OnUserPermissionRevoked(string id, string permName) => RemoveParametres(id, permName);

        [ChatCommand("unmute")]
        void UnMuteCustomChat(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 1 || arg.Length > 1)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, please use : unmute Steam64ID" : " , : unmute Steam64ID");
                return;
            }
            string NameOrID = arg[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player does not have a chat lock" : "    ");
                            return;
                        }

                        Info.MuteInfo.UnMute(MuteType.Chat);
                        ReplySystem(Moderator, LanguageEn ? "You have unblocked the offline chat to the player" : "   offline ");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "    ");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "    ");
                    return;
                }
            }
            UnmutePlayer(target, MuteType.Chat, Moderator, false, true);
        }

        [ChatCommand("hunmute")]
        void HideUnMute(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 1 || arg.Length > 1)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, please use : hunmute Steam64ID/Nick" : " , : hunmute Steam64ID/");
                return;
            }
            string NameOrID = arg[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player does not have a chat lock" : "    ");
                            return;
                        }

                        Info.MuteInfo.UnMute(MuteType.Chat);
                        ReplySystem(Moderator, LanguageEn ? "You have unblocked the offline chat to the player" : "   offline ");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "    ");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "    ");
                    return;
                }
            }

            UnmutePlayer(target, MuteType.Chat, Moderator, true, true);
        }
        private String XLevel_GetPrefix(BasePlayer player)
        {
            if (!XLevels || !config.ReferenceSetting.XLevelsSettings.UseXLevels) return String.Empty;
            return (String)XLevels?.CallHook("API_GetPlayerPrefix", player);
        }
        
                private void DrawUI_IQChat_Update_Check_Box(BasePlayer player, ElementsSettingsType Type, String OffsetMin, String OffsetMax, Boolean StatusCheckBox)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Context_CheckBox");
            User Info = UserInformation[player.userID];
            if (Info == null || Interface == null) return;

            String Name = $"{Type}";
            Interface = Interface.Replace("%NAME_CHECK_BOX%", Name);
            Interface = Interface.Replace("%COLOR%", !StatusCheckBox ? "0.4716981 0.4716981 0.4716981 1" : "0.6040971 0.4198113 1 1");
            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%COMMAND_TURNED%", $"newui.cmd checkbox.controller {Type}");

            CuiHelper.DestroyUi(player, Name);
            CuiHelper.AddUi(player, Interface);
        }
        
        
        private void ControlledBadNick(IPlayer player)
        {
            if (player == null) return;
            Configuration.ControllerMessage ControllerMessage = config.ControllerMessages;

            String DisplayName = player.Name;

            Tuple<String, Boolean> GetTupleNick = BadWordsCleaner(DisplayName,
                ControllerMessage.Formatting.ControllerNickname.ReplaceBadNick,
                ControllerMessage.Formatting.ControllerNickname.BadNicks);
            DisplayName = GetTupleNick.Item1;

            DisplayName = RemoveLinkText(DisplayName);
            player.Rename(DisplayName);
        }

        
        
        private void SetupParametres(String ID, String Permissions)
        {
            UInt64 UserID = UInt64.Parse(ID);
            BasePlayer player = BasePlayer.FindByID(UserID);

            Configuration.ControllerConnection.Turned Controller = config.ControllerConnect.Turneds;
            Configuration.ControllerParameters Parameters = config.ControllerParameter;

            if (!UserInformation.ContainsKey(UserID)) return;
            User Info = UserInformation[UserID];

            if (Controller.TurnAutoSetupPrefix)
            {
                Configuration.ControllerParameters.AdvancedFuncion Prefixes = Parameters.Prefixes.Prefixes.FirstOrDefault(prefix => prefix.Permissions == Permissions);
                if (Prefixes == null) return;

                if (Parameters.Prefixes.TurnMultiPrefixes && !Info.Info.PrefixList.Contains(Prefixes.Argument))
                    Info.Info.PrefixList.Add(Prefixes.Argument);
                else Info.Info.Prefix = Prefixes.Argument;

                if (player != null)
                    ReplySystem(player, GetLang("PREFIX_SETUP", player.UserIDString, Prefixes.Argument));

                Log(LanguageEn ? $"Player ({UserID}) successfully retrieved the prefix {Prefixes.Argument}" : $" ({UserID})    {Prefixes.Argument}");
            }
            if (Controller.TurnAutoSetupColorNick)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorNick = Parameters.NickColorList.FirstOrDefault(nick => nick.Permissions == Permissions);
                if (ColorNick == null) return;
                Info.Info.ColorNick = ColorNick.Argument;

                if (player != null)
                    ReplySystem(player, GetLang("COLOR_NICK_SETUP", player.UserIDString, ColorNick.Argument));

                Log(LanguageEn ? $"Player ({UserID}) successfully took the color of the nickname {ColorNick.Argument}" : $" ({UserID})     {ColorNick.Argument}");
            }
            if (Controller.TurnAutoSetupColorChat)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorChat = Parameters.MessageColorList.FirstOrDefault(message => message.Permissions == Permissions);
                if (ColorChat == null) return;
                Info.Info.ColorMessage = ColorChat.Argument;

                if (player != null)
                    ReplySystem(player, GetLang("COLOR_CHAT_SETUP", player.UserIDString, ColorChat.Argument));

                Log(LanguageEn ? $"Player ({UserID}) successfully retrieved the color of the chat {ColorChat.Argument}" : $" ({UserID})     {ColorChat.Argument}");
            }
        }
        [ChatCommand("saybro")]
        private void AlertOnlyPlayerChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            if (args == null || args.Length == 0)
            {
                ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "   !");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args[0]);
            if (Recipient == null)
            {
                ReplySystem(Sender, LanguageEn ? "The player is not on the server" : "   !");
                return;
            }
            Alert(Sender, Recipient, args.Skip(1).ToArray());
        }
        private void DrawUI_IQChat_Update_MuteChat_All(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionMutedAdmin)) return;

            String InterfaceAdministratorChat = InterfaceBuilder.GetInterface("UI_Chat_Administation_AllChat");
            if (InterfaceAdministratorChat == null) return;

            InterfaceAdministratorChat = InterfaceAdministratorChat.Replace("%TEXT_MUTE_ALLCHAT%", GetLang(!GeneralInfo.TurnMuteAllChat ? "IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT" : "IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT", player.UserIDString));
            InterfaceAdministratorChat = InterfaceAdministratorChat.Replace("%COMMAND_MUTE_ALLCHAT%", $"newui.cmd action.mute.ignore mute.controller {SelectedAction.Mute} mute.all.chat");

            CuiHelper.DestroyUi(player, "ModeratorMuteAllChat");
            CuiHelper.AddUi(player, InterfaceAdministratorChat);
        }

        
        
        [ConsoleCommand("mute")]
        void MuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;
            if (arg == null || arg.Args == null || arg.Args.Length != 3 || arg.Args.Length > 3)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, use : mute Steam64ID/Nick Reason Time(seconds)" : " , : mute Steam64ID/  ()");
                return;
            }
            string NameOrID = arg.Args[0];
            string Reason = arg.Args[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg.Args[2], out TimeMute))
            {
                PrintWarning(LanguageEn ? "Enter time in numbers!" : "  !");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            PrintWarning(LanguageEn ? "The player already has a chat lock" : "    ");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        PrintWarning(LanguageEn ? "Chat blocking issued to offline player" : "   offline-");
                        return;
                    }
                    else
                    {
                        PrintWarning(LanguageEn ? "This player is not on the server" : "    ");
                        return;
                    }
                }
                else
                {
                    PrintWarning(LanguageEn ? "This player is not on the server" : "    ");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, arg.Player(), Reason, TimeMute, false, true);
            Puts(LanguageEn ? "Successfully" : "");
        }

        [ConsoleCommand("rename")]
        private void ConsoleCommandRename(ConsoleSystem.Arg args)
        {
            BasePlayer Renamer = args.Player();
            if (Renamer == null)
            {
                PrintWarning(LanguageEn ? "You can only use this command while on the server" : "        ");
                return;
            }

            if (!permission.UserHasPermission(Renamer.UserIDString, PermissionRename)) return;
            GeneralInformation General = GeneralInfo;
            if (General == null) return;

            if (args.Args.Length == 0 || args == null)
            {
                ReplySystem(Renamer, lang.GetMessage("COMMAND_RENAME_NOTARG", this, Renamer.UserIDString));
                return;
            }

            String Name = args.Args[0];
            UInt64 ID = Renamer.userID;
            if (args.Args.Length == 2 && args.Args[1] != null && !String.IsNullOrWhiteSpace(args.Args[1]))
                if (!UInt64.TryParse(args.Args[1], out ID))
                {
                    ReplySystem(Renamer, lang.GetMessage("COMMAND_RENAME_NOT_ID", this, Renamer.UserIDString));
                    return;
                }

            if (General.RenameList.ContainsKey(Renamer.userID))
            {
                General.RenameList[Renamer.userID].RenameNick = Name;
                General.RenameList[Renamer.userID].RenameID = ID;
            }
            else General.RenameList.Add(Renamer.userID, new GeneralInformation.RenameInfo { RenameNick = Name, RenameID = ID });

            ReplySystem(Renamer, GetLang("COMMAND_RENAME_SUCCES", Renamer.UserIDString, Name, ID));
            Renamer.displayName = Name;
        }
        void API_ALERT_PLAYER_UI(BasePlayer player, String Message) => DrawUI_IQChat_Alert(player, Message);
        private enum SelectedParametres
        {
            DropList,
            Slider
        }
        private const String PermissionHideDisconnection = "iqchat.hidedisconnection";

        [ChatCommand("mute")]
        void MuteCustomChat(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 3 || arg.Length > 3)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, use : mute Steam64ID/Nick Reason Time(seconds)" : " ,  : mute Steam64ID/  ()");
                return;
            }
            string NameOrID = arg[0];
            string Reason = arg[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg[2], out TimeMute))
            {
                ReplySystem(Moderator, LanguageEn ? "Enter time in numbers!" : "  !");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player already has a chat lock" : "    ");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        ReplySystem(Moderator, LanguageEn ? "Chat blocking issued to offline player" : "   offline-");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "    ");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "    ");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, Moderator, Reason, TimeMute, false, true);
        }
        
        
        
        private void DiscordLoggCommand(BasePlayer player, String Command, String[] Args)
        {
            Configuration.OtherSettings.General Commands = config.OtherSetting.LogsChatCommands;
            if (!Commands.UseLogged) return;

            List<Fields> fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nick" : "", player.displayName, true),
                            new Fields("Steam64ID", player.UserIDString, true),
                            new Fields(LanguageEn ? "Command" : "", $"/{Command} ", true),
                        };

            String Arguments = String.Join(" ", Args);
            if (Args != null && Arguments != null && Arguments.Length != 0 && !String.IsNullOrWhiteSpace(Arguments))
                fields.Insert(fields.Count, new Fields(LanguageEn ? "Arguments" : "", Arguments, false));

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 10710525, fields, new Authors("IQChat Command-History", null, "https://i.imgur.com/xiwsg5m.png", null), null) });

            Request($"{Commands.Webhooks}", newMessage.toJSON());
        }
        [ConsoleCommand("alertuip")]
        private void AlertUIPConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            if (args.Args == null || args.Args.Length == 0)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "   !");
                else PrintWarning(LanguageEn ? "You didn't specify a player!" : "   !");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args.Args[0]);
            if (Recipient == null)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "The player is not on the server!" : "   !");
                else PrintWarning(LanguageEn ? "The player is not on the server!" : "   !");
                return;
            }
            AlertUI(Sender, Recipient, args.Args.Skip(1).ToArray());
        }
        public void AnwserMessage(BasePlayer player, String Message)
        {
            Configuration.AnswerMessage Anwser = config.AnswerMessages;
            if (!Anwser.UseAnswer) return;
            foreach (KeyValuePair<String, Configuration.LanguageController> Anwsers in Anwser.AnswerMessageList)
                if (Message.Contains(Anwsers.Key.ToLower()))
                    ReplySystem(player, GetMessages(player, Anwsers.Value.LanguageMessages));
        }

        void OnGroupPermissionRevoked(string name, string perm)
        {
            String[] PlayerGroups = permission.GetUsersInGroup(name);
            if (PlayerGroups == null) return;

            foreach (String playerInfo in PlayerGroups)
            {
                BasePlayer player = BasePlayer.FindByID(UInt64.Parse(playerInfo.Substring(0, 17)));
                if (player == null) return;

                RemoveParametres(player.UserIDString, perm);
            }
        }
        public static StringBuilder sb = new StringBuilder();
        void Init()
        {
            ReadData();
        }
        String IQRankGetNameRankKey(string Key) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", Key));

        
                private void DrawUI_IQChat_Sliders(BasePlayer player, String Name, String OffsetMin, String OffsetMax, TakeElementUser ElementType)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Slider");
            if (Interface == null) return;

            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%NAME%", Name);
            Interface = Interface.Replace("%COMMAND_LEFT_SLIDE%", $"newui.cmd slider.controller {ElementType} -");
            Interface = Interface.Replace("%COMMAND_RIGHT_SLIDE%", $"newui.cmd slider.controller {ElementType} +");

            CuiHelper.DestroyUi(player, Name);
            CuiHelper.AddUi(player, Interface);

            DrawUI_IQChat_Slider_Update_Argument(player, ElementType);
        }
        String API_GET_DEFAULT_NICK_COLOR() => config.ControllerConnect.SetupDefaults.NickDefault;

        void OnUserGroupAdded(string id, string groupName)
        {
            String[] PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;
            foreach (String permName in PermissionsGroup)
                SetupParametres(id, permName);
        }
        private const String PermissionHideConnection = "iqchat.hideconnection";

        void ReplyBroadcast(String Message, String CustomPrefix = null, String CustomAvatar = null, Boolean AdminAlert = false)
        {
            foreach (BasePlayer p in !AdminAlert ? BasePlayer.activePlayerList.Where(p => UserInformation[p.userID].Settings.TurnBroadcast) : BasePlayer.activePlayerList)
                ReplySystem(p, Message, CustomPrefix, CustomAvatar);
        }
        
        
        [ConsoleCommand("alert")]
        private void AlertConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;

            Alert(Sender, args.Args, false);
        }
        private enum TakeElementUser
        {
            Prefix,
            Nick,
            Chat,
            Rank,
            MultiPrefix
        }
        
        private static ConfigurationOld configOld = new ConfigurationOld();
        public class User
        {
            public Information Info = new Information();
            public Setting Settings = new Setting();
            public Mute MuteInfo = new Mute();
            internal class Information
            {
                public String Prefix;
                public String ColorNick;
                public String ColorMessage;
                public String Rank;

                public List<String> PrefixList = new List<String>();
            }

            internal class Setting
            {
                public Boolean TurnPM = true;
                public Boolean TurnAlert = true;
                public Boolean TurnBroadcast = true;
                public Boolean TurnSound = true;

                public List<UInt64> IgnoreUsers = new List<UInt64>();

                public Boolean IsIgnored(UInt64 TargetID) => IgnoreUsers.Contains(TargetID);
                public void IgnoredAddOrRemove(UInt64 TargetID)
                {
                    if (IsIgnored(TargetID))
                        IgnoreUsers.Remove(TargetID);
                    else IgnoreUsers.Add(TargetID);
                }
            }

            internal class Mute
            {
                public Double TimeMuteChat;
                public Double TimeMuteVoice;

                public Double GetTime(MuteType Type)
                {
                    Double TimeMuted = 0;
                    switch (Type)
                    {
                        case MuteType.Chat:
                            TimeMuted = TimeMuteChat - CurrentTime;
                            break;
                        case MuteType.Voice:
                            TimeMuted = TimeMuteVoice - CurrentTime;
                            break;
                        default:
                            break;
                    }
                    return TimeMuted;
                }
                public void SetMute(MuteType Type, Int32 Time)
                {
                    switch (Type)
                    {
                        case MuteType.Chat:
                            TimeMuteChat = Time + CurrentTime;
                            break;
                        case MuteType.Voice:
                            TimeMuteVoice = Time + CurrentTime;
                            break;
                        default:
                            break;
                    }
                }
                public void UnMute(MuteType Type)
                {
                    switch (Type)
                    {
                        case MuteType.Chat:
                            TimeMuteChat = 0;
                            break;
                        case MuteType.Voice:
                            TimeMuteVoice = 0;
                            break;
                        default:
                            break;
                    }
                }
                public Boolean IsMute(MuteType Type) => GetTime(Type) > 0;
            }
        }
        public enum MuteType
        {
            Chat,
            Voice
        }
        [ChatCommand("adminalert")]
        private void AdminAlertChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            Alert(Sender, args, true);
        }


        
        
        
        private class ImageUi
        {
            private static Coroutine coroutineImg = null;
            private static Dictionary<string, string> Images = new Dictionary<string, string>();
            public static void DownloadImages() { coroutineImg = ServerMgr.Instance.StartCoroutine(AddImage()); }

            private static IEnumerator AddImage()
            {
                _.PrintWarning(LanguageEn ? "Generating interface, wait ~10-15 seconds!" : " ,  ~10-15 !");

                foreach (String Key in _.KeyImages)
                {
                    string uri = $"https://iqsystem.skyplugins.ru/iqchat/getimageui/{Key}/WIwsqNNWF7nN";
                    UnityWebRequest www = UnityWebRequestTexture.GetTexture(uri);
                    yield return www.SendWebRequest();

                    if (_ == null)
                        yield break;
                    if (www.isNetworkError || www.isHttpError)
                    {
                        _.PrintWarning(string.Format("Image download error! Error: {0}, Image name: {1}", www.error, Key));
                        www.Dispose();
                        coroutineImg = null;
                        yield break;
                    }
                    Texture2D texture = DownloadHandlerTexture.GetContent(www);
                    if (texture != null)
                    {
                        byte[] bytes = texture.EncodeToPNG();

                        var image = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                        if (!Images.ContainsKey(Key))
                            Images.Add(Key, image);
                        else
                            Images[Key] = image;
                        UnityEngine.Object.DestroyImmediate(texture);
                    }

                    www.Dispose();
                    yield return CoroutineEx.waitForSeconds(0.02f);
                }
                coroutineImg = null;

                _interface = new InterfaceBuilder();
                _.PrintWarning(LanguageEn ? "Interface loaded successfully!" : "  !");
            }

            public static string GetImage(String ImgKey)
            {
                if (Images.ContainsKey(ImgKey))
                    return Images[ImgKey];
                return _.GetImage("LOADING");
            }

            public static void Unload()
            {
                coroutineImg = null;
                foreach (var item in Images)
                    FileStorage.server.RemoveExact(uint.Parse(item.Value), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID, 0U);
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                try
                {
                    configOld = Config.ReadObject<ConfigurationOld>();
                    if (configOld != null)
                    {
                        string file =
                            $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.backup_old_system.{DateTime.Now:yyyy-MM-dd hh-mm-ss}.json";
                        Config.WriteObject(configOld, false, file);
                        PrintWarning($"A BACKUP OF THE OLD CONFIGURATION WAS CREATED - {file}");
                    }
                }
                catch { }

                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();

                if (config.ControllerMessages.Formatting.ControllerNickname.AllowedLinkNick == null ||
                    config.ControllerMessages.Formatting.ControllerNickname.AllowedLinkNick.Count == 0)
                    config.ControllerMessages.Formatting.ControllerNickname.AllowedLinkNick = new List<String>()
                    {
                        "mysite.com"
                    };
            }
            catch
            {
                PrintWarning(LanguageEn
                    ? $"Error #132 read configuration 'oxide/config/{Name}', create a new configuration!!"
                    : $" #132   'oxide/config/{Name}',   !!");

                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        public Dictionary<UInt64, User> UserInformation = new Dictionary<UInt64, User>();
        Boolean API_IS_IGNORED(UInt64 UserHas, UInt64 User)
        {
            if (!UserInformation.ContainsKey(UserHas)) return false;
            if (!UserInformation.ContainsKey(User)) return false;

            return UserInformation[UserHas].Settings.IsIgnored(User);
        }
        
                String IQRankGetRank(ulong userID) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", userID));

        void OnPlayerDisconnected(BasePlayer player, string reason) => AlertDisconnected(player, reason);
        private class ConfigurationOld
        {
                        [JsonProperty(LanguageEn ? "Setting up player information" : "   ")]
            public ControllerConnection ControllerConnect = new ControllerConnection();
            internal class ControllerConnection
            {
                [JsonProperty(LanguageEn ? "Function switches" : " ")]
                public Turned Turneds = new Turned();
                [JsonProperty(LanguageEn ? "Setting Standard Values" : "  ")]
                public SetupDefault SetupDefaults = new SetupDefault();

                internal class SetupDefault
                {
                    [JsonProperty(LanguageEn ? "This prefix will be set if the player entered the server for the first time or in case of expiration of the rights to the prefix that he had earlier" : "               ,     ")]
                    public String PrefixDefault = "<color=#CC99FF>[]</color>";
                    [JsonProperty(LanguageEn ? "This nickname color will be set if the player entered the server for the first time or in case of expiration of the rights to the nickname color that he had earlier" : "                 ,     ")]
                    public String NickDefault = "#33CCCC";
                    [JsonProperty(LanguageEn ? "This chat color will be set if the player entered the server for the first time or in case of expiration of the rights to the chat color that he had earlier" : "                 ,     ")]
                    public String MessageDefault = "#0099FF";
                }
                internal class Turned
                {
                    [JsonProperty(LanguageEn ? "Set automatically a prefix to a player when he got the rights to it" : "   ,      ")]
                    public Boolean TurnAutoSetupPrefix;
                    [JsonProperty(LanguageEn ? "Set automatically the color of the nickname to the player when he got the rights to it" : "    ,      ")]
                    public Boolean TurnAutoSetupColorNick;
                    [JsonProperty(LanguageEn ? "Set the chat color automatically to the player when he got the rights to it" : "    ,      ")]
                    public Boolean TurnAutoSetupColorChat;
                    [JsonProperty(LanguageEn ? "Automatically reset the prefix when the player's rights to it expire" : "         ")]
                    public Boolean TurnAutoDropPrefix;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the nickname when the player's rights to it expire" : "          ")]
                    public Boolean TurnAutoDropColorNick;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the chat when the rights to it from the player expire" : "          ")]
                    public Boolean TurnAutoDropColorChat;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Setting options for the player" : "   ")]
            public ControllerParameters ControllerParameter = new ControllerParameters();
            internal class ControllerParameters
            {
                [JsonProperty(LanguageEn ? "Setting the display of options for player selection" : "     ")]
                public VisualSettingParametres VisualParametres = new VisualSettingParametres();
                [JsonProperty(LanguageEn ? "List and customization of colors for a nickname" : "     ")]
                public List<AdvancedFuncion> NickColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and customize colors for chat messages" : "       ")]
                public List<AdvancedFuncion> MessageColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and configuration of prefixes in chat" : "     ")]
                public PrefixSetting Prefixes = new PrefixSetting();
                internal class PrefixSetting
                {
                    [JsonProperty(LanguageEn ? "Enable support for multiple prefixes at once (true - multiple prefixes can be set/false - only 1 can be set to choose from)" : "     (true -    /false -    1  )")]
                    public Boolean TurnMultiPrefixes;
                    [JsonProperty(LanguageEn ? "The maximum number of prefixes that can be set at a time (This option only works if setting multiple prefixes is enabled)" : "  ,     (        )")]
                    public Int32 MaximumMultiPrefixCount;
                    [JsonProperty(LanguageEn ? "List of prefixes and their settings" : "    ")]
                    public List<AdvancedFuncion> Prefixes = new List<AdvancedFuncion>();
                }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                internal class AdvancedFuncion
                {
                    [JsonProperty(LanguageEn ? "Permission" : "")]
                    public String Permissions;
                    [JsonProperty(LanguageEn ? "Argument" : "")]
                    public String Argument;
                }

                internal class VisualSettingParametres
                {
                    [JsonProperty(LanguageEn ? "Player prefix selection display type - (0 - dropdown list, 1 - slider (Please note that if you have multi-prefix enabled, the dropdown list will be set))" : "      - (0 -  , 1 -  (,      -,    ))")]
                    public SelectedParametres PrefixType;
                    [JsonProperty(LanguageEn ? "Display type of player's nickname color selection - (0 - drop-down list, 1 - slider)" : "       - (0 -  , 1 - )")]
                    public SelectedParametres NickColorType;
                    [JsonProperty(LanguageEn ? "Display type of message color choice for the player - (0 - drop-down list, 1 - slider)" : "       - (0 -  , 1 - )")]
                    public SelectedParametres ChatColorType;
                    [JsonProperty(LanguageEn ? "IQRankSystem : Player rank selection display type - (0 - drop-down list, 1 - slider)" : "IQRankSystem :       - (0 -  , 1 - )")]
                    public SelectedParametres IQRankSystemType;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Plugin mute settings" : "   ")]
            public ControllerMute ControllerMutes = new ControllerMute();
            internal class ControllerMute
            {
                [JsonProperty(LanguageEn ? "Setting up automatic muting" : "  ")]
                public AutoMute AutoMuteSettings = new AutoMute();
                internal class AutoMute
                {
                    [JsonProperty(LanguageEn ? "Enable automatic muting for forbidden words (true - yes/false - no)" : "     (true - /false - )")]
                    public Boolean UseAutoMute;
                    [JsonProperty(LanguageEn ? "Reason for automatic muting" : "  ")]
                    public Muted AutoMuted;
                }
                [JsonProperty(LanguageEn ? "Additional setting for logging about mutes in discord" : "       ")]
                public LoggedFuncion LoggedMute = new LoggedFuncion();
                internal class LoggedFuncion
                {
                    [JsonProperty(LanguageEn ? "Support for logging the last N messages (Discord logging about mutes must be enabled)" : "   N  (       )")]
                    public Boolean UseHistoryMessage;
                    [JsonProperty(LanguageEn ? "How many latest player messages to send in logging" : "      ")]
                    public Int32 CountHistoryMessage;
                }

                [JsonProperty(LanguageEn ? "Reasons to block chat" : "   ")]
                public List<Muted> MuteChatReasons = new List<Muted>();
                [JsonProperty(LanguageEn ? "Reasons to block your voice" : "   ")]
                public List<Muted> MuteVoiceReasons = new List<Muted>();
                internal class Muted
                {
                    [JsonProperty(LanguageEn ? "Reason for blocking" : "  ")]
                    public String Reason;
                    [JsonProperty(LanguageEn ? "Block time (in seconds)" : " ( )")]
                    public Int32 SecondMute;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Configuring Message Processing" : "  ")]
            public ControllerMessage ControllerMessages = new ControllerMessage();
            internal class ControllerMessage
            {
                [JsonProperty(LanguageEn ? "Basic settings for chat messages from the plugin" : "      ")]
                public GeneralSettings GeneralSetting = new GeneralSettings();
                [JsonProperty(LanguageEn ? "Configuring functionality switching in chat" : "    ")]
                public TurnedFuncional TurnedFunc = new TurnedFuncional();
                [JsonProperty(LanguageEn ? "Player message formatting settings" : "   ")]
                public FormattingMessage Formatting = new FormattingMessage();
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                internal class GeneralSettings
                {
                    [JsonProperty(LanguageEn ? "Customizing the chat alert format" : "    ")]
                    public BroadcastSettings BroadcastFormat = new BroadcastSettings();
                    [JsonProperty(LanguageEn ? "Setting the mention format in the chat, via @" : "    ,  @")]
                    public AlertSettings AlertFormat = new AlertSettings();
                    [JsonProperty(LanguageEn ? "Additional setting" : " ")]
                    public OtherSettings OtherSetting = new OtherSettings();
		   		 		  						  	   		  	  			  	  			  	 				  	  	
                    internal class BroadcastSettings
                    {
                        [JsonProperty(LanguageEn ? "The name of the notification in the chat" : "   ")]
                        public String BroadcastTitle;
                        [JsonProperty(LanguageEn ? "Chat alert message color" : "    ")]
                        public String BroadcastColor;
                        [JsonProperty(LanguageEn ? "Steam64ID for chat avatar" : "Steam64ID    ")]
                        public String Steam64IDAvatar;
                    }
                    internal class AlertSettings
                    {
                        [JsonProperty(LanguageEn ? "The color of the player mention message in the chat" : "     ")]
                        public String AlertPlayerColor;
                        [JsonProperty(LanguageEn ? "Sound when receiving and sending a mention via @" : "        @")]
                        public String SoundAlertPlayer;
                    }
                    internal class OtherSettings
                    {
                        [JsonProperty(LanguageEn ? "Time after which the message will be deleted from the UI from the administrator" : ",     UI  ")]
                        public Int32 TimeDeleteAlertUI;

                        [JsonProperty(LanguageEn ? "The size of the message from the player in the chat" : "     ")]
                        public Int32 SizeMessage = 14;
                        [JsonProperty(LanguageEn ? "Player nickname size in chat" : "    ")]
                        public Int32 SizeNick = 14;
                        [JsonProperty(LanguageEn ? "The size of the player's prefix in the chat (will be used if <size=N></size> is not set in the prefix itself)" : "     ( ,       <size=N></size>)")]
                        public Int32 SizePrefix = 14;
                    }
                }
                internal class TurnedFuncional
                {
                    [JsonProperty(LanguageEn ? "Configuring spam protection" : "   ")]
                    public AntiSpam AntiSpamSetting = new AntiSpam();
                    [JsonProperty(LanguageEn ? "Setting up a temporary chat block for newbies (who have just logged into the server)" : "     (    )")]
                    public AntiNoob AntiNoobSetting = new AntiNoob();
                    [JsonProperty(LanguageEn ? "Setting up private messages" : "  ")]
                    public PM PMSetting = new PM();

                    internal class AntiNoob
                    {
                        [JsonProperty(LanguageEn ? "Newbie protection in PM/R" : "    PM/R")]
                        public Settings AntiNoobPM = new Settings();
                        [JsonProperty(LanguageEn ? "Newbie protection in global and team chat" : "       ")]
                        public Settings AntiNoobChat = new Settings();
                        internal class Settings
                        {
                            [JsonProperty(LanguageEn ? "Enable protection?" : " ?")]
                            public Boolean AntiNoobActivate = false;
                            [JsonProperty(LanguageEn ? "Newbie Chat Lock Time" : "    ")]
                            public Int32 TimeBlocked = 1200;
                        }
                    }
                    internal class AntiSpam
                    {
                        [JsonProperty(LanguageEn ? "Enable spam protection (Anti-spam)" : "    (-)")]
                        public Boolean AntiSpamActivate;
                        [JsonProperty(LanguageEn ? "Time after which a player can send a message (AntiSpam)" : "       ()")]
                        public Int32 FloodTime;
                        [JsonProperty(LanguageEn ? "Additional Anti-Spam settings" : "  -")]
                        public AntiSpamDuples AntiSpamDuplesSetting = new AntiSpamDuples();
                        internal class AntiSpamDuples
                        {
                            [JsonProperty(LanguageEn ? "Enable additional spam protection (Anti-duplicates, duplicate messages)" : "     (-,  )")]
                            public Boolean AntiSpamDuplesActivate = true;
                            [JsonProperty(LanguageEn ? "How many duplicate messages does a player need to make to be confused by the system" : "         ")]
                            public Int32 TryDuples = 3;
                            [JsonProperty(LanguageEn ? "Setting up automatic muting for duplicates" : "    ")]
                            public ControllerMute.Muted MuteSetting = new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Blocking for duplicate messages (SPAM)" : "    ()",
                                SecondMute = 300,
                            };
                        }
                    }
                    internal class PM
                    {
                        [JsonProperty(LanguageEn ? "Enable Private Messages" : "  ")]
                        public Boolean PMActivate;
                        [JsonProperty(LanguageEn ? "Sound when receiving a private message" : "     ")]
                        public String SoundPM;
                    }
                    [JsonProperty(LanguageEn ? "Enable PM ignore for players (/ignore nick or via interface)" : "   (/ignore nick   )")]
                    public Boolean IgnoreUsePM;
                    [JsonProperty(LanguageEn ? "Hide the issue of items to the Admin from the chat" : "     ")]
                    public Boolean HideAdminGave;
                    [JsonProperty(LanguageEn ? "Move mute to team chat (In case of a mute, the player will not be able to write even to the team chat)" : "    (  ,        )")]
                    public Boolean MuteTeamChat;
                }
                internal class FormattingMessage
                {
                    [JsonProperty(LanguageEn ? "Enable message formatting [Will control caps, message format] (true - yes/false - no)" : "   [  ,  ] (true - /false - )")]
                    public Boolean FormatMessage;
                    [JsonProperty(LanguageEn ? "Use a list of banned words (true - yes/false - no)" : "    (true - /false - )")]
                    public Boolean UseBadWords;
                    [JsonProperty(LanguageEn ? "The word that will replace the forbidden word" : "     ")]
                    public String ReplaceBadWord;
                    [JsonProperty(LanguageEn ? "List of banned words" : "  ")]
                    public List<String> BadWords = new List<String>();

                    [JsonProperty(LanguageEn ? "Nickname controller setup" : "  ")]
                    public NickController ControllerNickname = new NickController();
                    internal class NickController
                    {
                        [JsonProperty(LanguageEn ? "Enable player nickname formatting (message formatting must be enabled)" : "    (    )")]
                        public Boolean UseNickController = true;
                        [JsonProperty(LanguageEn ? "The word that will replace the forbidden word (You can leave it blank and it will just delete)" : "      (       )")]
                        public String ReplaceBadNick = "****";
                        [JsonProperty(LanguageEn ? "List of banned nicknames" : "  ")]
                        public List<String> BadNicks = new List<String>();
                    }
                }
            }
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            
            
            [JsonProperty(LanguageEn ? "Setting up chat alerts" : "   ")]
            public ControllerAlert ControllerAlertSetting;

            internal class ControllerAlert
            {
                [JsonProperty(LanguageEn ? "Setting up chat alerts" : "   ")]
                public Alert AlertSetting;
                [JsonProperty(LanguageEn ? "Setting notifications about the status of the player's session" : "     ")]
                public PlayerSession PlayerSessionSetting;
                [JsonProperty(LanguageEn ? "Configuring administrator session status alerts" : "     ")]
                public AdminSession AdminSessionSetting;
                [JsonProperty(LanguageEn ? "Setting up personal notifications to the player when connecting" : "     ")]
                public PersonalAlert PersonalAlertSetting;
                internal class Alert
                {
                    [JsonProperty(LanguageEn ? "Enable automatic messages in chat (true - yes/false - no)" : "     (true - /false - )")]
                    public Boolean AlertMessage;
                    [JsonProperty(LanguageEn ? "Type of automatic messages : true - sequential / false - random" : " 