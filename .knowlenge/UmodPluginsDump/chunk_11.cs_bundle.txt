oid Init() => delayedItems = new Dictionary<BasePlayer, List<Item>>();

		void OnServerInitialized()
		{
			// Warn if BotSpawn may cause unexpected behaviour
			if ((bool)Manager.GetPlugin("BotSpawn"))
				PrintWarning($"BotSpawn plugin found! Some ammo and loot might not be handled correctly!");
		}

		void OnEntityDeath(BasePlayer player)
		{
			if (player is NPCPlayer)
			{
				DoSpawns(player);
			}
		}

		void OnCorpsePopulate(BasePlayer player, PlayerCorpse corpse)
		{
			if (!player || !corpse || !delayedItems.ContainsKey(player))
			{
				return;
			}

			if (settings.RemoveDefault)
			{
				for (int i = 0; i < corpse.containers.Length; i++)
				{
					corpse.containers[i].Clear();
				}
			}

			var list = delayedItems[player];

			for (int i = 0; i < list.Count; i++)
			{
				var item = list[i];
				if (!item.MoveToContainer(corpse.containers[0]) && !item.MoveToContainer(corpse.containers[2]))
                {
                    if (settings.DropNearFull)
                        ApplyVelocity(DropNearPosition(item, corpse.transform.position + new Vector3(0, 0.3f)));
					else item.Remove();
				}
            }

			Pool.FreeList(ref list);

			delayedItems.Remove(player);
		}

		#endregion

		#region Core

		void DoSpawns(BasePlayer player)
		{
			delayedItems[player] = Pool.GetList<Item>();

			if (Random.Range(0.0f, 1.0f) <= settings.Meds.DropChance)
			{
				var meds = SpawnMeds();

				if (meds != null)
				{
					delayedItems[player].Add(meds);
				}
			}

			var definition = player.inventory?.containerBelt?.FindItemByUID(player.svActiveItemID)?.info;

			if (definition == null)
			{
				return;
			}

			var itemWeapon = ItemManager.Create(definition, 1, settings.Guns.RandomSkin ? GetRandomSkin(definition) : 0uL);

			if (itemWeapon == null)
			{
				return;
			}

			var condition = Random.Range(settings.Guns.Condition.Min, settings.Guns.Condition.Max);

			itemWeapon.conditionNormalized = condition / 100;

			var heldEnt = itemWeapon.GetHeldEntity();

			if (heldEnt is BaseProjectile && Random.Range(0.0f, 1.0f) <= settings.Ammo.DropChance)
			{
				var ammo = SpawnAmmo(heldEnt as BaseProjectile);

				if (ammo != null)
				{
					delayedItems[player].Add(ammo);
				}
			}

			if (Random.Range(0.0f, 1.0f) <= settings.Guns.DropChance)
			{
				SetAttachments(itemWeapon);

				if (settings.GunIntoCorpse || !player.eyes || !heldEnt)
				{
					delayedItems[player].Add(itemWeapon);
				}
				else
				{
					ApplyVelocity(DropNearPosition(itemWeapon, player.eyes.position));
				}
			}
		}

		Item SpawnMeds()
		{
			int amount = Random.Range((int)settings.Meds.Amount.Min, (int)settings.Meds.Amount.Max);

			return amount < 1 ? null : ItemManager.CreateByName("syringe.medical", amount);
		}

		Item SpawnAmmo(BaseProjectile weapon)
		{
			if (!weapon.primaryMagazine.ammoType)
			{
				return null;
			}

			int amount = Random.Range((int)settings.Ammo.Amount.Min, (int)settings.Ammo.Amount.Max);

			return amount < 1 ? null : ItemManager.Create(weapon.primaryMagazine.ammoType, amount);
		}

		Item SetAttachments(Item item)
		{
			if (settings.Guns.Attachments.Length < 1 || item.contents == null)
			{
				return item;
			}

			var attachmentCount = Random.Range(settings.Guns.AttachmentCount.Min, settings.Guns.AttachmentCount.Max);

			for (int i = 0; i < attachmentCount; i++)
			{
				var attachment = settings.Guns.Attachments.GetRandom();

				var attachmentItem = ItemManager.CreateByPartialName(attachment);

				if (attachmentItem == null || !item.contents.CanAccept(attachmentItem))
				{
					continue;
				}

				attachmentItem.MoveToContainer(item.contents);
			}

			return item;
		}

		BaseEntity DropNearPosition(Item item, Vector3 pos) => item.CreateWorldObject(pos);

		BaseEntity ApplyVelocity(BaseEntity entity)
		{
			entity.SetVelocity(new Vector3(Random.Range(-4f, 4f), Random.Range(-0.3f, 2f), Random.Range(-4f, 4f)));
			entity.SetAngularVelocity(
				new Vector3(Random.Range(-10f, 10f),
				Random.Range(-10f, 10f),
				Random.Range(-10f, 10f))
			);
			entity.SendNetworkUpdateImmediate();
			return entity;
		}

		ulong GetRandomSkin(ItemDefinition idef)
		{
			if (!idef)
				return 0;

			List<int> skins = Pool.GetList<int>();

			if (idef.skins != null && idef.skins.Length > 0)
			{
				skins.AddRange(from skin in idef.skins select skin.id);
			}

			if (idef.skins2 != null && idef.skins2.Length > 0)
			{
				skins.AddRange(from skin in idef.skins2 where skin != null select skin.DefinitionId);
			}

			var randomSkin = skins.GetRandom();

			Pool.FreeList(ref skins);

			return randomSkin == 0 ? 0 : ItemDefinition.FindSkin(idef.itemid, randomSkin);
		}

		#endregion

		#region Configuration

		protected override void LoadDefaultConfig()
		{
			settings = Settings.Default;
			SaveConfig();
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				settings = Config.ReadObject<Settings>();

				if (settings == null)
				{
					throw new Exception();
				}
			}
			catch
			{
				LoadDefaultConfig();
			}
		}

		protected override void SaveConfig() => Config.WriteObject(settings);

		class Settings
		{
			public GunSettings Guns { get; set; }
			public OtherSettings Ammo { get; set; }
			public OtherSettings Meds { get; set; }

			[JsonProperty("Put weapon into corpse")]
			public bool GunIntoCorpse { get; set; }
			[JsonProperty("Remove default loot from corpse")]
			public bool RemoveDefault { get; set; }
			[JsonProperty("Drop spawned items near corpse (otherwise just delete them)")]
			public bool DropNearFull { get; set; }

			public static Settings Default => new Settings
			{
				Guns = new GunSettings
				{
					DropChance = 1.0f,
					AttachmentCount = new RangeSettings
					{
						Min = 0,
						Max = 2
					},
					Condition = new RangeSettings
					{
						Min = 5,
						Max = 95
					},
					RandomSkin = true,
					Attachments = new[]
					{
						"weapon.mod.8x.scope",
						"weapon.mod.flashlight",
						"weapon.mod.holosight",
						"weapon.mod.lasersight",
						"weapon.mod.muzzleboost",
						"weapon.mod.muzzlebrake",
						"weapon.mod.silencer",
						"weapon.mod.simplesight",
						"weapon.mod.small.scope"
					}
				},
				Ammo = new OtherSettings
				{
					DropChance = 0.8f,
					Amount = new RangeSettings
					{
						Min = 10,
						Max = 55
					}
				},
				Meds = new OtherSettings
				{
					DropChance = 0.4f,
					Amount = new RangeSettings
					{
						Min = 1,
						Max = 3
					}
				},
				DropNearFull = true,
				GunIntoCorpse = false,
				RemoveDefault = false
			};

			public class GunSettings : DropChanceSettings
			{
				[JsonProperty("Gun condition")]
				public RangeSettings Condition { get; set; }
				[JsonProperty("Attachment count")]
				public RangeSettings AttachmentCount { get; set; }
				[JsonProperty("Attachment list")]
				public string[] Attachments { get; set; }
				[JsonProperty("Assign random skin")]
				public bool RandomSkin { get; set; }
			}

			public class DropChanceSettings
			{
				[JsonProperty("Drop chance")]
				public float DropChance { get; set; }
			}

			public class OtherSettings : DropChanceSettings
			{
				[JsonProperty("Amount to drop")]
				public RangeSettings Amount { get; set; }
			}

			public class RangeSettings
			{
				public uint Min { get; set; }
				public uint Max { get; set; }
			}
		}

		#endregion
	}
}


// --- End of file: NPCDropGun.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/need-for-speed ---
// --- Original File Path: N/NeedForSpeed/NeedForSpeed.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Need For Speed", "SwenenzY", "1.0.5")]
    [Description("Changes Speed / Mechanical of minicopter, scrap copter ")]
    public class NeedForSpeed : RustPlugin
    {
        
        #region Config

        private static ConfigData config;
        
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Permission -> Settings")]
            public Dictionary<string, PluginSettings> permissions;
        }

        private class PluginSettings
        {
            // MiniCopter
            [JsonProperty(PropertyName = "MiniCopter: Torque Scale Pitch")]
            public float mTSP;
            [JsonProperty(PropertyName = "MiniCopter: Torque Scale Yaw")]
            public float mTSY;
            [JsonProperty(PropertyName = "MiniCopter: Torque Scale Roll")] 
            public float mTSR;
            [JsonProperty(PropertyName = "MiniCopter: Maximum Rotor Speed")]
            public float mMRS;
            [JsonProperty(PropertyName = "MiniCopter: Time Until Maximum Rotor Speed")]
            public float mTUMRS;
            [JsonProperty(PropertyName = "MiniCopter: Rotor Blur Threshold")] 
            public float mRBT;
            [JsonProperty(PropertyName = "MiniCopter: Motor Force Constant")]
            public float mMFC;
            [JsonProperty(PropertyName = "MiniCopter: Brake Force Constant")]
            public float mBFC;
            [JsonProperty(PropertyName = "MiniCopter: Fuel Per Second")] 
            public float mFPS;
            [JsonProperty(PropertyName = "MiniCopter: Thwop Gain Min")]
            public float mTGMi;
            [JsonProperty(PropertyName = "MiniCopter: Thwop Gain Max")]
            public float mTGMa;
            [JsonProperty(PropertyName = "MiniCopter: Lift Fraction")]
            public float mLF;
            // ScrapCopter
            [JsonProperty(PropertyName = "ScrapCopter: Torque Scale Pitch")]
            public float cTSP;
            [JsonProperty(PropertyName = "ScrapCopter: Torque Scale Yaw")]
            public float cTSY;
            [JsonProperty(PropertyName = "ScrapCopter: Torque Scale Roll")] 
            public float cTSR;
            [JsonProperty(PropertyName = "ScrapCopter: Maximum Rotor Speed")]
            public float cMRS;
            [JsonProperty(PropertyName = "ScrapCopter: Time Until Maximum Rotor Speed")]
            public float cTUMRS;
            [JsonProperty(PropertyName = "ScrapCopter: Rotor Blur Threshold")] 
            public float cRBT;
            [JsonProperty(PropertyName = "ScrapCopter: Motor Force Constant")]
            public float cMFC;
            [JsonProperty(PropertyName = "ScrapCopter: Brake Force Constant")]
            public float cBFC;
            [JsonProperty(PropertyName = "ScrapCopter: Fuel Per Second")] 
            public float cFPS;
            [JsonProperty(PropertyName = "ScrapCopter: Thwop Gain Min")]
            public float cTGMi;
            [JsonProperty(PropertyName = "ScrapCopter: Thwop Gain Max")]
            public float cTGMa;
            [JsonProperty(PropertyName = "ScrapCopter: Lift Fraction")]
            public float cLF;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData 
            {
                permissions = new Dictionary<string, PluginSettings>
                {
                    ["needforspeed.3"] = new PluginSettings
                    {

                        mTSP = 400f,
                        mTSY = 400f,
                        mTSR = 400f,
                        mMRS = 10f,
                        mTUMRS = 7f,
                        mRBT = 8f,
                        mMFC = 150f,
                        mBFC = 500f,
                        mFPS = 0.50f,
                        mTGMi = 0.50f,
                        mTGMa = 1f,
                        mLF = 0.25f,

                        cTSP = 1600f,
                        cTSY = 1600f,
                        cTSR = 1600f,
                        cMRS = 10f,
                        cTUMRS = 7f,
                        cRBT = 8f,
                        cMFC = 150f,
                        cBFC = 500f,
                        cFPS = 0.50f,
                        cTGMi = 0.50f,
                        cTGMa = 1f,
                        cLF = 0.25f
                    },
                    ["needforspeed.2"] = new PluginSettings
                    {

                        mTSP = 400f,
                        mTSY = 400f,
                        mTSR = 400f,
                        mMRS = 10f,
                        mTUMRS = 7f,
                        mRBT = 8f,
                        mMFC = 150f,
                        mBFC = 500f,
                        mFPS = 0.50f,
                        mTGMi = 0.50f,
                        mTGMa = 1f,
                        mLF = 0.25f,

                        cTSP = 1600f,
                        cTSY = 1600f,
                        cTSR = 1600f,
                        cMRS = 10f,
                        cTUMRS = 7f,
                        cRBT = 8f,
                        cMFC = 150f,
                        cBFC = 500f,
                        cFPS = 0.50f,
                        cTGMi = 0.50f,
                        cTGMa = 1f,
                        cLF = 0.25f
                    },
                    ["needforspeed.1"] = new PluginSettings
                    {

                        mTSP = 400f,
                        mTSY = 400f,
                        mTSR = 400f,
                        mMRS = 10f,
                        mTUMRS = 7f,
                        mRBT = 8f,
                        mMFC = 150f,
                        mBFC = 500f,
                        mFPS = 0.50f,
                        mTGMi = 0.50f,
                        mTGMa = 1f,
                        mLF = 0.25f,

                        cTSP = 1600f,
                        cTSY = 1600f,
                        cTSR = 1600f,
                        cMRS = 10f,
                        cTUMRS = 7f,
                        cRBT = 8f,
                        cMFC = 150f,
                        cBFC = 500f,
                        cFPS = 0.50f,
                        cTGMi = 0.50f,
                        cTGMa = 1f,
                        cLF = 0.25f
                    },
                }
            };
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
        
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
            

        #endregion
        private void Init()
        {
            foreach (var value in config.permissions.Keys)
            {
                permission.RegisterPermission(value, this);
            }
        }

        private void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            if (entity != null)
            {
                foreach (var pair in config.permissions)
                {
                    if (permission.UserHasPermission(player.UserIDString, pair.Key))
                    {
                        PluginSettings data = pair.Value;
                        var vehicle = player.GetMountedVehicle();
                        BasePlayer driver = vehicle.GetDriver();
                        if (driver == null) return;
                        if (vehicle == null) return;
                        if (driver.userID != player.userID) return;
                        if (vehicle as ScrapTransportHelicopter)
                        {
                            var scrap = vehicle as ScrapTransportHelicopter;
                            if (scrap == null) return;
                            var torqueScalePitch = data.cTSP;
                            var torqueScaleYaw = data.cTSY;
                            var torqueScaleRoll = data.cTSR;
                            scrap.torqueScale = new Vector3(torqueScalePitch, torqueScaleYaw, torqueScaleRoll);
                            scrap.maxRotorSpeed = data.cMRS;
                            scrap.timeUntilMaxRotorSpeed = data.cTUMRS;
                            scrap.rotorBlurThreshold = data.cRBT;
                            scrap.motorForceConstant = data.cMFC;
                            scrap.brakeForceConstant = data.cBFC;
                            scrap.fuelPerSec = data.cFPS;
                            scrap.thwopGainMin = data.cTGMi;
                            scrap.thwopGainMax = data.cTGMa;
                            scrap.liftFraction = data.cLF;
                            scrap.SendNetworkUpdate();
                        }
                        else if (vehicle as MiniCopter)
                        {
                            var copter = vehicle as MiniCopter;
                            if (copter == null) return;
                            var torqueScalePitch = data.mTSP;
                            var torqueScaleYaw = data.mTSY;
                            var torqueScaleRoll = data.mTSR;
                            copter.torqueScale = new Vector3(torqueScalePitch, torqueScaleYaw, torqueScaleRoll);
                            copter.maxRotorSpeed = data.mMRS;
                            copter.timeUntilMaxRotorSpeed = data.mTUMRS;
                            copter.rotorBlurThreshold = data.mRBT;
                            copter.motorForceConstant = data.mMFC;
                            copter.brakeForceConstant = data.mBFC;
                            copter.fuelPerSec = data.mFPS;
                            copter.thwopGainMin = data.mTGMi;
                            copter.thwopGainMax = data.mTGMa;
                            copter.liftFraction = data.mLF;
                            copter.SendNetworkUpdate();
                        }
                        break;
                    }
                }
            }
        }
      
    }
}


// --- End of file: NeedForSpeed.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-locks ---
// --- Original File Path: N/NoLocks/NoLocks.cs ---

using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/*
 * Rewritten from scratch and maintained to present by VisEntities
 * Originally created by Orange, up to version 1.0.0
 */

namespace Oxide.Plugins
{
    [Info("No Locks", "VisEntities", "3.0.0")]
    [Description("Blocks the deployment of key and code locks on certain entities.")]
    public class NoLocks : RustPlugin
    {
        #region Fields

        private static NoLocks _plugin;
        private static Configuration _config;
        private const int ITEM_ID_KEY_LOCK = -850982208;
        private const int ITEM_ID_CODE_LOCK = 1159991980;

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Remove Locks On Startup")]
            public bool RemoveLocksOnStartup { get; set; }

            [JsonProperty("Entity Groups")]
            public List<LockConfig> EntityGroups { get; set; }
        }

        private class LockConfig
        {
            [JsonProperty("Prefab Short Names")]
            public List<string> PrefabShortNames { get; set; }

            [JsonProperty("Allow Code Lock Deployment")]
            public bool AllowCodeLockDeployment { get; set; }

            [JsonProperty("Allow Key Lock Deployment")]
            public bool AllowKeyLockDeployment { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Config changes detected! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Config update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                RemoveLocksOnStartup = false,
                EntityGroups = new List<LockConfig>
                {
                    new LockConfig
                    {
                        PrefabShortNames = new List<string>
                        {
                            "cupboard.tool.deployed",
                            "box.wooden.large",
                            "woodbox_deployed"
                        },
                        AllowCodeLockDeployment = false,
                        AllowKeyLockDeployment = true
                    },
                    new LockConfig
                    {
                        PrefabShortNames = new List<string>
                        {
                            "wall.frame.garagedoor",
                            "door.hinged.metal"
                        },
                        AllowCodeLockDeployment = true,
                        AllowKeyLockDeployment = false
                    },
                    new LockConfig
                    {
                        PrefabShortNames = new List<string>
                        {
                            "locker.deployed",
                            "fridge.deployed"
                        },
                        AllowCodeLockDeployment = true,
                        AllowKeyLockDeployment = true
                    }
                }
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void Init()
        {
            _plugin = this;
            PermissionUtil.RegisterPermissions();
        }

        private void Unload()
        {
            CoroutineUtil.StopAllCoroutines();
            _config = null;
            _plugin = null;
        }

        private void OnServerInitialized(bool isStartup)
        {
            if (_config.RemoveLocksOnStartup)
            {
                CoroutineUtil.StartCoroutine(Guid.NewGuid().ToString(), RemoveLocksCoroutine());
            }
        }

        private object CanDeployItem(BasePlayer player, Deployer deployerItem, NetworkableId targetEntityId)
        {
            if (player == null || deployerItem == null)
                return null;

            if (PermissionUtil.HasPermission(player, PermissionUtil.BYPASS))
                return null;

            Deployable deployable = deployerItem.GetDeployable();
            if (deployable == null)
                return null;

            Item activeItem = player.GetActiveItem();
            if (activeItem == null)
                return null;

            BaseEntity targetEntity = BaseNetworkable.serverEntities.Find(targetEntityId) as BaseEntity;
            if (targetEntity == null)
                return null;

            LockConfig lockConfig = GetLockConfigForPrefab(targetEntity.ShortPrefabName);
            if (lockConfig == null)
                return null;

            int itemId = activeItem.info.itemid;
            switch (itemId)
            {
                case ITEM_ID_CODE_LOCK:
                    {
                        if (!lockConfig.AllowCodeLockDeployment)
                        {
                            SendMessage(player, Lang.DeployCodeLockBlocked);
                            return true;
                        }
                        break;
                    }
                case ITEM_ID_KEY_LOCK:
                    {
                        if (!lockConfig.AllowKeyLockDeployment)
                        {
                            SendMessage(player, Lang.DeployKeyLockBlocked);
                            return true;
                        }
                        break;
                    }
            }
        
            return null;
        }

        #endregion Oxide Hooks

        #region Locks Removal

        private IEnumerator RemoveLocksCoroutine()
        {
            foreach (BaseEntity entity in BaseNetworkable.serverEntities.OfType<BaseEntity>())
            {
                yield return CoroutineEx.waitForSeconds(0.1f);

                LockConfig lockConfig = GetLockConfigForPrefab(entity.ShortPrefabName);
                if (entity == null || lockConfig == null)
                    continue;

                BaseLock baseLock = GetEntityLock(entity);
                if (baseLock == null)
                    continue;
    
                bool shouldRemoveLock = false;

                if (baseLock is CodeLock && !lockConfig.AllowCodeLockDeployment)
                {
                    shouldRemoveLock = true;
                }
                else if (baseLock is KeyLock && !lockConfig.AllowKeyLockDeployment)
                {
                    shouldRemoveLock = true;
                }

                if (shouldRemoveLock)
                {
                    if (entity.OwnerID != 0)
                    {
                        BasePlayer ownerPlayer = FindPlayerById(entity.OwnerID);
                        if (ownerPlayer != null && PermissionUtil.HasPermission(ownerPlayer, PermissionUtil.BYPASS))
                            continue;
                    }
                    baseLock.Kill();
                }        
            }
        }

        #endregion Locks Removal

        #region Helper Functions

        private LockConfig GetLockConfigForPrefab(string prefabName)
        {
            foreach (var group in _config.EntityGroups)
            {
                if (group.PrefabShortNames.Contains(prefabName))
                    return group;
            }
            return null;
        }

        private static BaseLock GetEntityLock(BaseEntity entity)
        {
            return entity.GetSlot(BaseEntity.Slot.Lock) as BaseLock;
        }

        public static BasePlayer FindPlayerById(ulong playerId)
        {
            return RelationshipManager.FindByID(playerId);
        }

        #endregion Helper Functions

        #region Coroutine Util

        private static class CoroutineUtil
        {
            private static readonly Dictionary<string, Coroutine> _activeCoroutines = new Dictionary<string, Coroutine>();

            public static void StartCoroutine(string coroutineName, IEnumerator coroutineFunction)
            {
                StopCoroutine(coroutineName);

                Coroutine coroutine = ServerMgr.Instance.StartCoroutine(coroutineFunction);
                _activeCoroutines[coroutineName] = coroutine;
            }

            public static void StopCoroutine(string coroutineName)
            {
                if (_activeCoroutines.TryGetValue(coroutineName, out Coroutine coroutine))
                {
                    if (coroutine != null)
                        ServerMgr.Instance.StopCoroutine(coroutine);

                    _activeCoroutines.Remove(coroutineName);
                }
            }

            public static void StopAllCoroutines()
            {
                foreach (string coroutineName in _activeCoroutines.Keys.ToArray())
                {
                    StopCoroutine(coroutineName);
                }
            }
        }

        #endregion Coroutine Util

        #region Permission

        private static class PermissionUtil
        {
            public const string BYPASS = "nolocks.bypass";
            private static readonly List<string> _permissions = new List<string>
            {
                BYPASS,
            };

            public static void RegisterPermissions()
            {
                foreach (var permission in _permissions)
                {
                    _plugin.permission.RegisterPermission(permission, _plugin);
                }
            }

            public static bool HasPermission(BasePlayer player, string permissionName)
            {
                return _plugin.permission.UserHasPermission(player.UserIDString, permissionName);
            }
        }

        #endregion Permission

        #region Localization

        private class Lang
        {
            public const string DeployCodeLockBlocked = "DeployCodeLockBlocked";
            public const string DeployKeyLockBlocked = "DeployKeyLockBlocked";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.DeployCodeLockBlocked] = "Code locks cannot be deployed on this entity.",
                [Lang.DeployKeyLockBlocked] = "Key locks cannot be deployed on this entity.",
            }, this, "en");
        }
        
        private void SendMessage(BasePlayer player, string messageKey, params object[] args)
        {
            string message = lang.GetMessage(messageKey, this, player.UserIDString);
            if (args.Length > 0)
                message = string.Format(message, args);

            SendReply(player, message);
        }

        #endregion Localization
    }
}

// --- End of file: NoLocks.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-fireball-damage ---
// --- Original File Path: N/NoFireBallDamage/NoFireBallDamage.cs ---

﻿using Rust;
namespace Oxide.Plugins
{
    [Info("No FireBall Damage", "Lincoln", "1.0.2")]
    [Description("Prevent fireballs from damaging things.")]

    public class NoFireBallDamage : CovalencePlugin
    {
        void OnFireBallDamage(FireBall fire, BaseCombatEntity entity, HitInfo info)
        {
            if ((entity == null) || (info.damageTypes.GetMajorityDamageType() != DamageType.Heat)) return;
            info.damageTypes.ScaleAll(0f);
        }
    }
}

// --- End of file: NoFireBallDamage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-igniter-drain ---
// --- Original File Path: N/NoIgniterDrain/NoIgniterDrain.cs ---

namespace Oxide.Plugins
{
    [Info("No Igniter Drain", "Lincoln", "1.0.3")]
    [Description("Prevent Igniters from damaging themselves while in use.")]

    public class NoIgniterDrain : RustPlugin
    {
        private void OnServerInitialized()
        {
            permission.RegisterPermission("NoIgniterDrain.unlimited", this);

            foreach (var entity in UnityEngine.Object.FindObjectsOfType<Igniter>())
            {
                OnEntitySpawned(entity);
            }
        }

        private void OnEntitySpawned(Igniter entity)
        {
            var player = entity.OwnerID.ToString();
            if(!permission.UserHasPermission(player, "NoIgniterDrain.unlimited"))
            {
                return;
            }
            else
            {
                entity.SelfDamagePerIgnite = 0f;
            }
        }

        private void Unload()
        {
            foreach (var entity in UnityEngine.Object.FindObjectsOfType<Igniter>())
            {
                entity.SelfDamagePerIgnite = 0.5f;
            }
        }
    }
}

// --- End of file: NoIgniterDrain.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-server-cctv-cameras ---
// --- Original File Path: N/NoServerCCTV/NoServerCCTV.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("No Server CCTV Camaras", "NooBlet", "0.1.6")]
    [Description("Renames default Server CCTV camara identifiers")]
    public class NoServerCCTV : CovalencePlugin
    {
        #region Globel Varibles

       
        Dictionary<string, String> identifiers = new Dictionary<string, String>();

        #endregion Globel Varibles


        #region Hooks

        void OnServerInitialized()
        {
           
            SetServerCCTVs();
        }

        void Unload()
        {
            ResetServerCCTVnames();
        }

        #endregion Hooks


        #region Methods

      

        CCTV_RC[] GetCCTVs()
        {
            return GameObject.FindObjectsOfType<CCTV_RC>();
        }

        void SetServerCCTVs()
        {
            foreach (var item in GetCCTVs())
            {
                if (item.OwnerID == 0)
                {
                    var id = Guid.NewGuid().ToString();
                    identifiers[id] = item.GetIdentifier();
                    item.UpdateIdentifier(id);                 
                    
                }
               
            }
           
        }

        void ResetServerCCTVnames()
        {
            foreach (var item in GetCCTVs())
            {
                if (item.OwnerID == 0)
                {
                    item.UpdateIdentifier(identifiers[item.GetIdentifier()]);
                    item._name = identifiers[item.GetIdentifier()];
                }

            }

        }
        #endregion Methods

    }
}


// --- End of file: NoServerCCTV.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-build-on-road ---
// --- Original File Path: N/NoBuildOnRoad/NoBuildOnRoad.cs ---

using UnityEngine;
using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("No Build On Road", "supreme", "1.0.4")]
    [Description("Disallow building over road")]
    public class NoBuildOnRoad : RustPlugin
    {
        const string NoBuildOnRoadIgnore = "nobuildonroad.ignore";
        
        #region Lang
        
        protected override void LoadDefaultMessages() 
        {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            {"NoPermMsg", "Building on road is not allowed."}

        }, this, "en");

        lang.RegisterMessages(new Dictionary<string, string>
        {
            {"NoPermMsg", "Vous n'avez pas la permission de construire sur les routes."}
            
        }, this, "fr"); 
        }

    #endregion
    
    #region Configuration
    
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Prefix")]
        public string usedPrefix = "[NBOR]";
        
        [JsonProperty(PropertyName = "Prefix Color")]
        public string usedPrefixColor = "#ACFA58";
        
        [JsonProperty(PropertyName = "Chat Icon [SteamID64]")]
        public ulong chatIcon = 76561198278456562;
    }

    protected override void LoadConfig()
    {
        base.LoadConfig();
        try
        {
            _config = Config.ReadObject<Configuration>();
            if (_config == null) throw new Exception();
            SaveConfig();
        }
        catch
        {
            PrintError("Your configuration file contains an error. Using default configuration values.");
            LoadDefaultConfig();
        }
    }

    protected override void SaveConfig() => Config.WriteObject(_config);

    protected override void LoadDefaultConfig() => _config = new Configuration();
    
    #endregion

    #region Hooks
        
        void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (go == null) return;
            var player = plan.GetOwnerPlayer();
            var block = go.ToBaseEntity();
            bool ignore = permission.UserHasPermission(player.UserIDString, NoBuildOnRoadIgnore);
            if (ignore) return;
            bool incave = CheckRoad(block.transform.position);
            if (incave)
            {
                if (block == null) return;
                NextFrame( () => block.Kill());
                GiveRefund(block, player);
                Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)}", $"<color={_config.usedPrefixColor}>{_config.usedPrefix}</color>", _config.chatIcon);
            }
        }
        
        void GiveRefund(BaseEntity entity, BasePlayer player)
        {
            var name = entity.ShortPrefabName.Replace(".deployed", "").Replace("_deployed", "");
            if (name == "wall.external.high.wood")
            {
                name = name.Replace(".wood", "");
            }

            if (name == "refinery_small")
            {
                name = name.Replace("refinery_small", "small.oil.refinery");
            }

            if (name == "vendingmachine")
            {
                name = name.Replace("vendingmachine", "vending.machine");
            }

            if (name == "woodbox")
            {
                name = name.Replace("woodbox", "box.wooden");
            }

            if (name == "researchtable")
            {
                name = name.Replace("researchtable", "research.table");
            }
            
            if (name == "repairbench")
            {
                name = name.Replace("repairbench", "box.repair.bench");
            }

            if (name == "hitchtrough")
            {
                name = name.Replace("hitchtrough", "hitchtroughcombo");
            }

            if (name == "water_catcher_small")
            {
                name = name.Replace("water_catcher_small", "water.catcher.small");
            }
            
            if (name == "water_catcher_large")
            {
                name = name.Replace("water_catcher_large", "water.catcher.large");
            }
            
            if (name == "fireplace")
            {
                name = name.Replace("fireplace", "fireplace.stone");
            }
            
            if (name == "sleepingbag_leather")
            {
                name = name.Replace("sleepingbag_leather", "sleepingbag");
            }
            
            if (name == "waterbarrel")
            {
                name = name.Replace("waterbarrel", "water.barrel");
            }
            
            if (name == "sam_site_turret")
            {
                name = name.Replace("sam_site_turret", "samsite");
            }
            
            if (name == "beartrap")
            {
                name = name.Replace("beartrap", "trap.bear");
            }
            
            if (name == "landmine")
            {
                name = name.Replace("landmine", "trap.landmine");
            }
            
            if (name == "electric.windmill.small")
            {
                name = name.Replace("electric.windmill.small", "generator.wind.scrap");
            }
            
            var item = ItemManager.CreateByName(name);
            if (item != null)
            {
                player.GiveItem(item);
                return;
            }

            var block = entity.GetComponent<BaseCombatEntity>();
            if (block != null)
            {
                var cost = block.BuildCost();
                if (cost != null)
                {
                    foreach (var value in cost)
                    {
                        var x = ItemManager.Create(value.itemDef, Convert.ToInt32(value.amount * (entity.Health() / entity.MaxHealth())));
                        if (x == null) continue;
                        player.GiveItem(x);
                    }
                }
            }
        }
        
        void Init()
        {
            permission.RegisterPermission(NoBuildOnRoadIgnore, this);
        }
        
        #endregion
        
        #region Check for road layer
        
        bool CheckRoad(Vector3 Position)
        {
            RaycastHit hitInfo;
            if (!Physics.Raycast(Position, Vector3.down, out hitInfo, 66f, LayerMask.GetMask("Terrain", "World", "Construction", "Water"), QueryTriggerInteraction.Ignore) || hitInfo.collider == null) return false;
            if (hitInfo.collider.name.ToLower().Contains("road")) return true;
            return false;
        }
        
        #endregion
    }
}

// --- End of file: NoBuildOnRoad.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-corpse ---
// --- Original File Path: N/NoCorpse/NoCorpse.cs ---

namespace Oxide.Plugins
{
    [Info("No Corpse", "Erik", "1.0.2")]
    [Description("Simple plugin that will allow players with set permission to not spawn their corpse when they die.")]
    public class NoCorpse : RustPlugin
    {
        private const string permNoCorpse = "NoCorpse.include";

        private void Init()
        {
            permission.RegisterPermission(permNoCorpse, this);
        }

        object OnPlayerCorpseSpawn(BasePlayer player)
        {
            if (player == null || player.IPlayer == null)
            {
                return null;
            }

            if (player.IPlayer.HasPermission(permNoCorpse))
            {
                return false;
            }

            return null;
        }

    }
}

// --- End of file: NoCorpse.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/nuke-weapons ---
// --- Original File Path: N/NukeWeapons/NukeWeapons.cs ---

﻿using Facepunch;
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using System.IO;
using Rust;

namespace Oxide.Plugins
{
    [Info("NukeWeapons", "k1lly0u", "0.1.69")]
    [Description("Create nuclear ammo for a bunch of different ammo types, full GUI crafting menu and ammo gauge")]
    class NukeWeapons : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin LustyMap, ImageLibrary;

        private NukeData _nukeData;
        private ItemNames _itemNames;
        private DynamicConfigFile _data;        
        private DynamicConfigFile item_names;
                       
        private string dataDirectory = "file://" + Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + "NukeWeapons" + Path.DirectorySeparatorChar + "Icons" + Path.DirectorySeparatorChar;

        private readonly List<ZoneList> _radiationZones = new List<ZoneList>();

        private readonly Hash<ulong, NukeType> _activeUsers = new Hash<ulong, NukeType>();
        private Hash<ulong, Hash<NukeType, int>> _cachedAmmo = new Hash<ulong, Hash<NukeType, int>>();
        private readonly Hash<ulong, Hash<NukeType, double>> _craftingTimers = new Hash<ulong, Hash<NukeType, double>>();

        private readonly List<Timer> _timers = new List<Timer>();

        private Dictionary<string, ItemDefinition> _itemDefs;
        private Hash<string, string> _displayNames = new Hash<string, string>();

        private const int PlayerMask = 131072;

        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            _data = Interface.Oxide.DataFileSystem.GetFile("NukeWeapons/nukeweapon_data");
            item_names = Interface.Oxide.DataFileSystem.GetFile("NukeWeapons/itemnames");
            Interface.Oxide.DataFileSystem.SaveDatafile("NukeWeapons/Icons/foldercreator");
            lang.RegisterMessages(Messages, this);           
            InitializePlugin();
        }

        private void OnServerInitialized()
        {
            LoadData();
            
            _itemDefs = ItemManager.itemList.ToDictionary(i => i.shortname);
            
            if (_itemNames.displayNames == null || _itemNames.displayNames.Count < 1)
            {
                foreach (KeyValuePair<string, ItemDefinition> item in _itemDefs.Where(item => !_displayNames.ContainsKey(item.Key)))
                    _displayNames.Add(item.Key, item.Value.displayName.translated);

                SaveDisplayNames();
            }
            else _displayNames = _itemNames.displayNames;
            
            FindAllMines();
        }

        private void Unload()
        {
            for (int i = 0; i < _radiationZones.Count; i++)
            {
                _radiationZones[i].time.Destroy();
                UnityEngine.Object.Destroy(_radiationZones[i].zone.gameObject);
            }

            _radiationZones.Clear();

            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, UIMain);
                CuiHelper.DestroyUi(player, UIPanel);
                DestroyIconUI(player);
                DestroyCraftUI(player);
            }

            for (int i = 0; i < _timers.Count; i++)            
                _timers[i].Destroy();            

            SaveData();         
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            _activeUsers.Remove(player.userID);

            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.DestroyUi(player, UIPanel);
            
            DestroyIconUI(player);
            DestroyCraftUI(player);
        }

        private void OnEntityDeath(BasePlayer player, HitInfo hitInfo)
        {
            if (!player)
                return;

            _activeUsers.Remove(player.userID);
            
            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.DestroyUi(player, UIPanel);

            DestroyIconUI(player);
        }

        private void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            if (!_activeUsers.ContainsKey(player.userID) || _activeUsers[player.userID] != NukeType.Rocket) 
                return;
            
            if (HasUnlimitedAmmo(player) || HasAmmo(player.userID, NukeType.Rocket))
            {
                if (!HasUnlimitedAmmo(player))
                {
                    string itemname = "ammo.rocket.basic";
                    switch (entity.ShortPrefabName)
                    {
                        case "calledrocket_hv":
                            itemname = "ammo.rocket.hv";
                            break;
                        case "calledrocket_fire":
                            itemname = "ammo.rocket.fire";
                            break;
                        default:
                            break;
                    }
                    player.inventory.containerMain.AddItem(_itemDefs[itemname], 1);
                    _cachedAmmo[player.userID][NukeType.Rocket]--;
                }
                entity.gameObject.AddComponent<Nuke>().InitializeComponent(this, NukeType.Rocket, configData.Rockets.RadiationProperties);
            }
            else
            {
                _activeUsers.Remove(player.userID);
                SendMSG(player, $"{MSG("OOA", player.UserIDString)} {MSG("Rockets", player.UserIDString)}");
            }
            CreateAmmoIcons(player);
        }

        private void OnEntitySpawned(Landmine landmine)
        {
            if (!_activeUsers.ContainsKey(landmine.OwnerID) || _activeUsers[landmine.OwnerID] != NukeType.Mine) 
                return;
            
            BasePlayer player = BasePlayer.FindByID(landmine.OwnerID);
            if (!player) 
                return;
            
            if (HasUnlimitedAmmo(player) || HasAmmo(player.userID, NukeType.Mine))
            {
                if (!HasUnlimitedAmmo(player))
                {
                    player.inventory.containerMain.AddItem(_itemDefs["trap.landmine"], 1);
                    _cachedAmmo[player.userID][NukeType.Mine]--;
                }

                landmine.gameObject.AddComponent<Nuke>().InitializeComponent(this, NukeType.Mine, configData.Mines.RadiationProperties);
                _nukeData.Mines.Add(landmine.net.ID.Value);
            }
            else
            {
                _activeUsers.Remove(player.userID);
                SendMSG(player, $"{MSG("OOA", player.UserIDString)} {MSG("Mines", player.UserIDString)}");
            }

            CreateAmmoIcons(player);
        }

        private void OnEntityDeath(Landmine landmine, HitInfo info)
        {
            if (landmine && _nukeData.Mines.Contains(landmine.net.ID.Value))
                _nukeData.Mines.Remove(landmine.net.ID.Value);
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (!_activeUsers.ContainsKey(attacker.userID) || _activeUsers[attacker.userID] != NukeType.Bullet) 
                return;

            BaseEntity weapon = info?.Weapon ? info.Weapon.GetEntity() : null;
            if (!weapon) 
                return;
            
            BaseProjectile projectile = weapon.GetComponent<BaseProjectile>();
            if (!projectile) 
                return;
            
            ItemDefinition ammoType = projectile.primaryMagazine.ammoType;
            if (!ammoType)
                return;

            if (string.IsNullOrEmpty(ammoType.shortname)) 
                return;

            if (!ammoType.shortname.Contains("ammo.rifle")) 
                return;
            
            Vector3 hitPos = info.HitPositionWorld;
            
            ConfigData.NWType.RadiationStats radVar = configData.Bullets.RadiationProperties;
            if (HasUnlimitedAmmo(attacker) || HasAmmo(attacker.userID, NukeType.Bullet))
            {
                if (!HasUnlimitedAmmo(attacker))
                {
                    attacker.inventory.containerMain.AddItem(_itemDefs[ammoType.shortname], 1);
                    _cachedAmmo[attacker.userID][NukeType.Bullet]--;
                }
                InitializeZone(hitPos, radVar.Intensity, radVar.Duration, radVar.Radius, false);
            }
            else
            {
                _activeUsers.Remove(attacker.userID);
                SendMSG(attacker, $"{MSG("OOA", attacker.UserIDString)} {MSG("Bullets", attacker.UserIDString)}");
            }
            CreateAmmoIcons(attacker);
        }

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (entity.ShortPrefabName.Contains("explosive.timed"))
            {
                if (!_activeUsers.ContainsKey(player.userID) || _activeUsers[player.userID] != NukeType.Explosive)
                    return;
                
                if (HasUnlimitedAmmo(player) || HasAmmo(player.userID, NukeType.Explosive))
                {
                    if (!HasUnlimitedAmmo(player))
                    {
                        player.inventory.containerMain.AddItem(_itemDefs["explosive.timed"], 1);
                        _cachedAmmo[player.userID][NukeType.Explosive]--;
                    }

                    entity.gameObject.AddComponent<Nuke>().InitializeComponent(this, NukeType.Explosive, configData.Explosives.RadiationProperties);
                }
                else
                {
                    _activeUsers.Remove(player.userID);
                    SendMSG(player, $"{MSG("OOA", player.UserIDString)} {MSG("Explosives", player.UserIDString)}");
                }

                CreateAmmoIcons(player);
            }
            
            if (entity.ShortPrefabName.Contains("grenade.f1"))
            {
                if (!_activeUsers.ContainsKey(player.userID) || _activeUsers[player.userID] != NukeType.Grenade) 
                    return;
                
                if (HasUnlimitedAmmo(player) || HasAmmo(player.userID, NukeType.Grenade))
                {
                    if (!HasUnlimitedAmmo(player))
                    {
                        player.inventory.containerMain.AddItem(_itemDefs["grenade.f1"], 1);
                        _cachedAmmo[player.userID][NukeType.Grenade]--;
                    }
                    entity.gameObject.AddComponent<Nuke>().InitializeComponent(this, NukeType.Explosive, configData.Grenades.RadiationProperties);                        
                }
                else
                {
                    _activeUsers.Remove(player.userID);
                    SendMSG(player, $"{MSG("OOA", player.UserIDString)} {MSG("Grenades", player.UserIDString)}");
                }
                CreateAmmoIcons(player);
            }
        }
        #endregion

        #region Helpers
        private bool HasEnoughResources(BasePlayer player, int itemid, int amount) => player.inventory.GetAmount(itemid) >= amount;

        private void TakeResources(BasePlayer player, int itemid, int amount) => player.inventory.Take(null, itemid, amount);
        
        private double CurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private bool IsSelectedType(BasePlayer player, NukeType type) => _activeUsers.ContainsKey(player.userID) && _activeUsers[player.userID] == type;

        private T ParseType<T>(string type)
        {
            try
            {
                return (T)Enum.Parse(typeof(T), type, true);
            }
            catch
            {
                PrintError($"INVALID OPTION! The value \"{type}\" is an incorrect selection.\nAvailable options are: {Enum.GetNames(typeof(T)).ToSentence()}");
                return default(T);
            }
        }
        #endregion

        #region Functions
        private void FindAllMines()
        {
            List<BaseNetworkable> list = Pool.Get<List<BaseNetworkable>>();
            list.AddRange(BaseNetworkable.serverEntities.Where(x => x is Landmine));

            foreach (BaseNetworkable baseNetworkable in list)
            {
                if (_nukeData.Mines.Any(x=> x == baseNetworkable.net.ID.Value))
                    baseNetworkable.gameObject.AddComponent<Nuke>().InitializeComponent(this, NukeType.Mine, configData.Mines.RadiationProperties);
            }
            
            Pool.FreeUnmanaged(ref list);  
        }

        private bool CanCraftWeapon(BasePlayer player, NukeType type)
        {
            Dictionary<string, int> ingredients = GetCraftingComponents(type);

            foreach (KeyValuePair<string, int> item in ingredients)
            {
                if (HasEnoughResources(player, _itemDefs[item.Key].itemid, item.Value))
                    continue;
                
                return false;
            }
            
            return true;
        }

        private bool IsCrafting(BasePlayer player, NukeType type)
        {
            if (!_craftingTimers.TryGetValue(player.userID, out Hash<NukeType, double> craftingTimer)) 
                return false;

            if (!craftingTimer.TryGetValue(type, out double time)) 
                return false;
            
            return time > CurrentTime();
        }

        private string CraftTimeClock(BasePlayer player, double time)
        {
            if (!player)
                return "";

            TimeSpan dateDifference = TimeSpan.FromSeconds(time - CurrentTime());            
            int mins = dateDifference.Minutes;
            int secs = dateDifference.Seconds;
            return $"{mins:00}:{secs:00}";
        }

        private void StartCrafting(BasePlayer player, NukeType type)
        {
            ConfigData.NWType config = GetConfigFromType(type);

            Dictionary<string, int> ingredients = GetCraftingComponents(type);

            foreach (KeyValuePair<string, int> ing in ingredients)            
                TakeResources(player, _itemDefs[ing.Key].itemid, ing.Value);

            bool finished = FinishedCrafting(player);

            _craftingTimers[player.userID][type] = CurrentTime() + config.CraftTime;            
            CraftingElement(player, type);

            if (finished)
                CreateCraftTimer(player);
        }

        private void FinishCraftingItems(BasePlayer player, NukeType type)
        {
            ConfigData.NWType config = GetConfigFromType(type);  
                     
            _cachedAmmo[player.userID][type] += config.CraftAmount;

            if (_activeUsers.ContainsKey(player.userID))
                CreateAmmoIcons(player);
        }

        private bool FinishedCrafting(BasePlayer player)
        {
            if (!_craftingTimers.ContainsKey(player.userID))
            {
                CheckPlayerEntry(player);
                return true;
            }

            bool finished = true;

            foreach (KeyValuePair<NukeType, double> craft in _craftingTimers[player.userID])
            {
                if (craft.Value != -1)
                {
                    finished = false;
                    break;
                }
            }
            return finished;
        }
        #endregion

        #region External Calls        
        private void CloseMap(BasePlayer player)
        {
            if (LustyMap)
            {
                LustyMap.Call("DisableMaps", player);
            }
        }

        private void OpenMap(BasePlayer player)
        {
            if (LustyMap)
            {
                LustyMap.Call("EnableMaps", player);
            }
        }
        #endregion

        #region UI Creation
        private class NWUI
        {
            public static CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false, string parent = "Overlay")
            {
                CuiElementContainer NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = cursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return NewElement;
            }
            public static void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            public static void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 0f)
            {
                
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
            public static void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 0f)
            {
               
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = fadein },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }
            public static void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }            
            public static string CreateTextOverlay(ref CuiElementContainer container, string panelName, string textcolor, string text, int size, string distance, string olcolor, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                string name = CuiHelper.GetGuid();
                container.Add(new CuiElement
                {
                    Name = name,
                    Parent = panelName,
                    Components =
                        {
                            new CuiTextComponent { Color = textcolor, Text = text, FontSize = size, Align = align},
                            new CuiOutlineComponent { Distance = distance, Color = olcolor },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = aMin,
                                AnchorMax = aMax
                            }
                        }
                });
                return name;
            }
        }

        #region Colors
        private readonly Dictionary<string, string> _uiColors = new Dictionary<string, string>
        {
            {"dark", "0.1 0.1 0.1 0.98" },
            {"light", "0.7 0.7 0.7 0.3" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttonopen", "0.2 0.8 0.2 0.9" },
            {"buttoncompleted", "0 0.5 0.1 0.9" },
            {"buttonred", "0.85 0 0.35 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
            {"grey8", "0.8 0.8 0.8 1.0" }
        };
        #endregion
        #endregion

        #region NW UI
        private const string UIMain = "NWUIMain";

        private const string UIPanel = "NWUIPanel";

        private const string UIEntry = "NWUIEntry";

        private const string UIIcon = "NWUIIcon";
        
        private void OpenCraftingMenu(BasePlayer player)
        {
            CloseMap(player);

            CuiElementContainer container = NWUI.CreateElementContainer(UIMain, _uiColors["dark"], "0 0.92", "1 1");

            NWUI.CreatePanel(ref container, UIMain, _uiColors["light"], "0.01 0.05", "0.99 0.95", true);
            NWUI.CreateLabel(ref container, UIMain, "", $"{configData.Options.MSG_MainColor}{Title}</color>", 30, "0.05 0", "0.2 1");

            int number = 0;
            if (configData.Bullets.Enabled && HasPermission(player, NukeType.Bullet))
            {
                CreateMenuButton(ref container, UIMain, MSG("Bullets", player.UserIDString), "NWUI_ChangeElement bullet", number);
                number++;
            }

            if (configData.Explosives.Enabled && HasPermission(player, NukeType.Explosive))
            {
                CreateMenuButton(ref container, UIMain, MSG("Explosives", player.UserIDString), "NWUI_ChangeElement explosive", number);
                number++;
            }

            if (configData.Grenades.Enabled && HasPermission(player, NukeType.Grenade))
            {
                CreateMenuButton(ref container, UIMain, MSG("Grenades", player.UserIDString), "NWUI_ChangeElement grenade", number);
                number++;
            }

            if (configData.Mines.Enabled && HasPermission(player, NukeType.Mine))
            {
                CreateMenuButton(ref container, UIMain, MSG("Mines", player.UserIDString), "NWUI_ChangeElement mine", number);
                number++;
            }

            if (configData.Rockets.Enabled && HasPermission(player, NukeType.Rocket))
            {
                CreateMenuButton(ref container, UIMain, MSG("Rockets", player.UserIDString), "NWUI_ChangeElement rocket", number);
                number++;
            }

            CreateMenuButton(ref container, UIMain, MSG("Close", player.UserIDString), "NWUI_DestroyAll", number);

            CuiHelper.AddUi(player, container);
        }

        private void CraftingElement(BasePlayer player, NukeType type)
        {            
            CuiElementContainer container = NWUI.CreateElementContainer(UIPanel, _uiColors["dark"], "0 0", "1 0.92");

            NWUI.CreatePanel(ref container, UIPanel, _uiColors["light"], "0.01 0.02", "0.99 0.98", true);
            NWUI.LoadImage(ref container, UIPanel, GetImage("Background"), "0.01 0.02", "0.99 0.98");         

            NWUI.CreateLabel(ref container, UIPanel, "", $"{configData.Options.MSG_MainColor}{MSG("Required Ingredients", player.UserIDString)}</color>", 20, "0.1 0.85", "0.55 0.95");
            NWUI.CreateLabel(ref container, UIPanel, "", MSG("Item Name", player.UserIDString), 16, "0.1 0.75", "0.3 0.85", TextAnchor.MiddleLeft);
            NWUI.CreateLabel(ref container, UIPanel, "", MSG("Required Amount", player.UserIDString), 16, "0.3 0.75", "0.42 0.85");
            NWUI.CreateLabel(ref container, UIPanel, "", MSG("Your Supply", player.UserIDString), 16, "0.42 0.75", "0.54 0.85");
                        
            Dictionary<string, int> ingredients = GetCraftingComponents(type);

            int i = 0;
            foreach(KeyValuePair<string, int> item in ingredients)
            {
                ItemDefinition itemInfo = _itemDefs[item.Key];
                int plyrAmount = player.inventory.GetAmount(itemInfo.itemid);                
                CreateIngredientEntry(ref container, UIPanel, _displayNames[itemInfo.shortname], item.Value, plyrAmount, i);
                i++;
            }

            ConfigData.NWType config = GetConfigFromType(type);

            string command = null;            
            string text = $"{MSG("Craft", player.UserIDString)} {config.CraftAmount}x";

            if (CanCraftWeapon(player, type))
                command = $"NWUI_Craft {type.ToString()}";

            if (_cachedAmmo[player.userID][type] >= config.MaxAllowed)
            {
                text = MSG("Limit Reached", player.UserIDString);
                command = null;
            }
            if (IsCrafting(player, type))
            {
                text = MSG("Crafting...", player.UserIDString);
                command = null;                
            }
            if (HasUnlimitedAmmo(player))
            {
                text = MSG("Unlimited", player.UserIDString);
                command = null;
            }

            NWUI.CreateLabel(ref container, UIPanel, "", $"{configData.Options.MSG_MainColor}{MSG("Inventory Amount", player.UserIDString)}</color>", 20, "0.6 0.85", "0.9 0.95");

            if (HasUnlimitedAmmo(player))
                NWUI.CreateLabel(ref container, UIPanel, "", $"~ / {config.MaxAllowed}", 16, "0.6 0.75", "0.9 0.85");
            else NWUI.CreateLabel(ref container, UIPanel, "", $"{_cachedAmmo[player.userID][type]} / {config.MaxAllowed}", 16, "0.6 0.75", "0.9 0.85");

            NWUI.CreateButton(ref container, UIPanel, _uiColors["buttonbg"], text, 16, $"0.6 0.65", $"0.74 0.72", command);

            if (_cachedAmmo[player.userID][type] > 0 || HasUnlimitedAmmo(player))
            {
                if (IsSelectedType(player, type))
                    NWUI.CreateButton(ref container, UIPanel, _uiColors["buttonbg"], MSG("Disarm", player.UserIDString), 16, $"0.76 0.65", $"0.9 0.72", $"NWUI_DeactivateMenu {type.ToString()}");
                else NWUI.CreateButton(ref container, UIPanel, _uiColors["buttonbg"], MSG("Arm", player.UserIDString), 16, $"0.76 0.65", $"0.9 0.72", $"NWUI_Activate {type.ToString()}");
            }

            CuiHelper.DestroyUi(player, UIPanel);
            CuiHelper.AddUi(player, container);
        }

        private void CreateCraftTimer(BasePlayer player)
        {               
            CuiElementContainer container = NWUI.CreateElementContainer(UIEntry, "0 0 0 0", "0.2 0.11", "0.8 0.15");

            string message = "";

            List<NukeType> completedTypes = new List<NukeType>();

            foreach(KeyValuePair<NukeType, double> craft in _craftingTimers[player.userID])
            {
                if (craft.Value == -1)
                    continue;   
                
                if (craft.Value <= CurrentTime())                
                    completedTypes.Add(craft.Key); 
                else message += $"{craft.Key.ToString()}: {configData.Options.MSG_MainColor}{CraftTimeClock(player, craft.Value)}</color>     ";                              
            }

            foreach(NukeType type in completedTypes)
            {
                _craftingTimers[player.userID][type] = -1;
                FinishCraftingItems(player, type);
            }

            if (string.IsNullOrEmpty(message))
            {
                DestroyCraftUI(player);
                return;
            }
            
            message = $"{configData.Options.MSG_MainColor}{MSG("Crafting", player.UserIDString)} ::: </color> " + message;

            NWUI.CreateLabel(ref container, UIEntry, "", message, 16, $"0 0", $"1 1", TextAnchor.MiddleRight, 0f);

            CuiHelper.DestroyUi(player, UIEntry);
            CuiHelper.AddUi(player, container);

            timer.Once(1, () => CreateCraftTimer(player));
        }

        private void CreateIngredientEntry(ref CuiElementContainer container, string panel, string name, int amountreq, int plyrhas, int number)
        {
            Vector2 position = new Vector2(0.1f, 0.68f);
            Vector2 dimensions = new Vector2(0.4f, 0.06f);
            float offsetY = (0.004f + dimensions.y) * number;
            Vector2 offset = new Vector2(0, offsetY);
            Vector2 posMin = position - offset;
            Vector2 posMax = posMin + dimensions;
            string color;

            if (amountreq > plyrhas)
                color = "<color=red>";
            else color = configData.Options.MSG_MainColor;

            NWUI.CreateLabel(ref container, panel, "", $"{configData.Options.MSG_MainColor}{name}</color>", 16, $"{posMin.x} {posMin.y}", $"{posMin.x + 0.2f} {posMax.y}", TextAnchor.MiddleLeft);
            NWUI.CreateLabel(ref container, panel, "", $"{amountreq}", 16, $"{posMin.x + 0.2f} {posMin.y}", $"{posMin.x + 0.32f} {posMax.y}");
            NWUI.CreateLabel(ref container, panel, "", $"{color}{plyrhas}</color>", 16, $"{posMin.x + 0.32f} {posMin.y}", $"{posMin.x + 0.44f} {posMax.y}");                       
        }

        private void CreateAmmoIcons(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.DestroyUi(player, UIPanel);

            if (_cachedAmmo.ContainsKey(player.userID))
            {
                DestroyIconUI(player);
                int i = 0;
                if (HasPermission(player, NukeType.Bullet))
                {
                    if (_cachedAmmo[player.userID][NukeType.Bullet] > 0 || HasUnlimitedAmmo(player))
                    {
                        AmmoIcon(player, NukeType.Bullet, i); i++;
                    }
                }
                if (HasPermission(player, NukeType.Explosive))
                {
                    if (_cachedAmmo[player.userID][NukeType.Explosive] > 0 || HasUnlimitedAmmo(player))
                    {
                        AmmoIcon(player, NukeType.Explosive, i); i++;
                    }
                }
                if (HasPermission(player, NukeType.Grenade))
                {
                    if (_cachedAmmo[player.userID][NukeType.Grenade] > 0 || HasUnlimitedAmmo(player))
                    {
                        AmmoIcon(player, NukeType.Grenade, i); i++;
                    }
                }
                if (HasPermission(player, NukeType.Mine))
                {
                    if (_cachedAmmo[player.userID][NukeType.Mine] > 0 || HasUnlimitedAmmo(player))
                    {
                        AmmoIcon(player, NukeType.Mine, i); i++;
                    }
                }
                if (HasPermission(player, NukeType.Rocket))
                {
                    if (_cachedAmmo[player.userID][NukeType.Rocket] > 0 || HasUnlimitedAmmo(player))
                    {
                        AmmoIcon(player, NukeType.Rocket, i); i++;
                    }
                }
                AddButtons(player, i);
            }
        }

        private void AmmoIcon(BasePlayer player, NukeType type, int number)
        {      
            Vector2 position = new Vector2(0.92f, 0.2f);
            Vector2 dimensions = new Vector2(0.07f, 0.12f);
            Vector2 offset = new Vector2(0, (0.01f + dimensions.y) * number);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;

            string panelName = UIIcon + type.ToString();
            
            CuiElementContainer container = NWUI.CreateElementContainer(panelName, "0 0 0 0", $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", false, "Hud");

            string image = GetImage(type.ToString());
            if (IsSelectedType(player, type))
                image = GetImage($"{type.ToString()}Active");
            NWUI.LoadImage(ref container, panelName, image, "0 0", "1 1");

            string amount;
            if (HasUnlimitedAmmo(player))
                amount = "~";
            else amount = _cachedAmmo[player.userID][type].ToString();
            NWUI.CreateTextOverlay(ref container, panelName, "", $"{amount}", 30, "2 2", "0 0 0 1", "0 0", "1 1", TextAnchor.LowerCenter);

            if (IsSelectedType(player, type))
                NWUI.CreateButton(ref container, panelName, "0 0 0 0", "", 20, "0 0", "1 1", "NWUI_DeactivateButton");
            else NWUI.CreateButton(ref container, panelName, "0 0 0 0", "", 20, "0 0", "1 1", $"NWUI_Activate {type.ToString()}");
            
            CuiHelper.AddUi(player, container);
        }  
        
        private void AddButtons(BasePlayer player, int number)
        {
            Vector2 position = new Vector2(0.92f, 0.2f);
            Vector2 dimensions = new Vector2(0.07f, 0.12f);
            Vector2 offset = new Vector2(0, (0.01f + dimensions.y) * number);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;

            CuiElementContainer container = NWUI.CreateElementContainer(UIIcon, "0 0 0 0", $"{posMin.x} {posMin.y}", $"{posMax.x} {posMin.y + 0.1}", false, "Hud");
            NWUI.CreateButton(ref container, UIIcon, _uiColors["buttonbg"], MSG("Menu",player.UserIDString), 16, "0 0.55", "1 1", "NWUI_OpenMenu");
            NWUI.CreateButton(ref container, UIIcon, _uiColors["buttonbg"], MSG("Deactivate", player.UserIDString), 16, "0 0", "1 0.45", "NWUI_DeactivateIcons");

            CuiHelper.DestroyUi(player, UIIcon);
            CuiHelper.AddUi(player, container);
        }   
        
        #region UI Functions
        private void CreateMenuButton(ref CuiElementContainer container, string panelName, string buttonname, string command, int number)
        {
            Vector2 dimensions = new Vector2(0.1f, 0.6f);
            Vector2 origin = new Vector2(0.25f, 0.2f);
            Vector2 offset = new Vector2((0.01f + dimensions.x) * number, 0);

            Vector2 posMin = origin + offset;
            Vector2 posMax = posMin + dimensions;

            NWUI.CreateButton(ref container, panelName, _uiColors["buttonbg"], buttonname, 16, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", command);
        }                
        #endregion
        
        #region UI Commands
        [ConsoleCommand("NWUI_Craft")]
        private void cmdNWCraft(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (!player)
                return;

            NukeType nukeType = ParseType<NukeType>(arg.GetString(0));
            StartCrafting(player, nukeType);            
        }

        [ConsoleCommand("NWUI_DeactivateMenu")]
        private void cmdNWDeActivate(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (!player)
                return;

            _activeUsers.Remove(player.userID);

            NukeType nukeType = ParseType<NukeType>(arg.GetString(0));
            CraftingElement(player, nukeType);            
        }

        [ConsoleCommand("NWUI_DeactivateButton")]
        private void cmdNWDeActivateButton(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (!player)
                return;

            _activeUsers.Remove(player.userID);
            CreateAmmoIcons(player);       
        }

        [ConsoleCommand("NWUI_DeactivateIcons")]
        private void cmdNWDeactivateIcons(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (!player)
                return;

            _activeUsers.Remove(player.userID);
            DestroyIconUI(player);
        }

        [ConsoleCommand("NWUI_OpenMenu")]
        private void cmdNWOpenMenu(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (!player)
                return;

            if (HasPermission(player, NukeType.Bullet) || HasPermission(player, NukeType.Explosive) || HasPermission(player, NukeType.Grenade) || HasPermission(player, NukeType.Mine) || HasPermission(player, NukeType.Rocket))
            {
                CloseMap(player);
                CheckPlayerEntry(player);
                OpenCraftingMenu(player);
            }
        }

        [ConsoleCommand("NWUI_Activate")]
        private void cmdNWActivate(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (!player)
                return;

            NukeType nukeType = ParseType<NukeType>(arg.GetString(0));

            if (!_activeUsers.ContainsKey(player.userID))
                _activeUsers.Add(player.userID, nukeType);
            else _activeUsers[player.userID] = nukeType;

            SendMSG(player, MSG("activated", player.UserIDString).Replace("<type>", nukeType.ToString()));

            CreateAmmoIcons(player);
        }

        [ConsoleCommand("NWUI_ChangeElement")]
        private void cmdNWChangeElement(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (!player)
                return;

            NukeType nukeType = ParseType<NukeType>(arg.GetString(0));
            CraftingElement(player, nukeType);            
        }

        [ConsoleCommand("NWUI_DestroyAll")]
        private void cmdNWDestroyAll(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (!player)
                return;

            OpenMap(player);
            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.DestroyUi(player, UIPanel);            
        }

        private void DestroyCraftUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIEntry);            
        }

        private void DestroyIconUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIIcon + "Bullet");
            CuiHelper.DestroyUi(player, UIIcon + "Rocket");
            CuiHelper.DestroyUi(player, UIIcon + "Explosive");
            CuiHelper.DestroyUi(player, UIIcon + "Grenade");
            CuiHelper.DestroyUi(player, UIIcon + "Mine");
            CuiHelper.DestroyUi(player, UIIcon);
        }
        #endregion
        #endregion

        #region Functions
        private void InitializePlugin()
        {
            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission("nukeweapons.rocket", this);
            permission.RegisterPermission("nukeweapons.bullet", this);
            permission.RegisterPermission("nukeweapons.mine", this);
            permission.RegisterPermission("nukeweapons.explosive", this);
            permission.RegisterPermission("nukeweapons.grenade", this);
            permission.RegisterPermission("nukeweapons.all", this);
            permission.RegisterPermission("nukeweapons.unlimited", this);
        }

        private bool HasAmmo(ulong player, NukeType type) 
            => _cachedAmmo.TryGetValue(player, out Hash<NukeType, int> value) && value[type] > 0;

        private Dictionary<string, int> GetCraftingComponents(NukeType type)
        {
            return type switch
            {
                NukeType.Mine => configData.Mines.CraftingCosts,
                NukeType.Rocket => configData.Rockets.CraftingCosts,
                NukeType.Bullet => configData.Bullets.CraftingCosts,
                NukeType.Explosive => configData.Explosives.CraftingCosts,
                NukeType.Grenade => configData.Grenades.CraftingCosts,
                _ => null
            };
        }

        private ConfigData.NWType GetConfigFromType(NukeType type)
        {
            return type switch
            {
                NukeType.Mine => configData.Mines,
                NukeType.Rocket => configData.Rockets,
                NukeType.Bullet => configData.Bullets,
                NukeType.Explosive => configData.Explosives,
                NukeType.Grenade => configData.Grenades,
                _ => null
            };
        }

        private void CheckPlayerEntry(BasePlayer player)
        {
            if (!_cachedAmmo.ContainsKey(player.userID))
            {
                _cachedAmmo.Add(player.userID, new Hash<NukeType, int>
                {
                    {NukeType.Bullet, 0 },
                    {NukeType.Explosive, 0 },
                    {NukeType.Grenade, 0 },
                    {NukeType.Mine, 0 },
                    {NukeType.Rocket, 0 },
                });
            }
            if (!_craftingTimers.ContainsKey(player.userID))
            {
                _craftingTimers.Add(player.userID, new Hash<NukeType, double>
                {
                    {NukeType.Bullet, -1 },
                    {NukeType.Explosive, -1 },
                    {NukeType.Grenade, -1 },
                    {NukeType.Mine, -1 },
                    {NukeType.Rocket, -1 },
                });
            }
        }
        #endregion

        #region Radiation Control
        private void InitializeZone(Vector3 location, float intensity, float duration, float radius, bool explosionType = false)
        {
            if (!ConVar.Server.radiation)
                ConVar.Server.radiation = true;

            if (explosionType)
                Effect.server.Run("assets/prefabs/tools/c4/effects/c4_explosion.prefab", location);
            else Effect.server.Run("assets/prefabs/npc/patrol helicopter/effects/rocket_explosion.prefab", location);

            RadiationZone radiationZone = new GameObject().AddComponent<RadiationZone>();
            radiationZone.Activate(location, radius, intensity);

            ZoneList listEntry = new ZoneList { zone = radiationZone };
            listEntry.time = timer.Once(duration, () => DestroyZone(listEntry));

            _radiationZones.Add(listEntry);
        }

        private void DestroyZone(ZoneList zone)
        {
            if (!_radiationZones.Contains(zone)) 
                return;
            
            int index = _radiationZones.FindIndex(a => a.zone == zone.zone);
            _radiationZones[index].time.Destroy();
            UnityEngine.Object.Destroy(_radiationZones[index].zone.gameObject);
            _radiationZones.Remove(zone);
        }

        private class Nuke : MonoBehaviour
        {
            private NukeWeapons instance;
            public NukeType type;
            public ConfigData.NWType.RadiationStats stats;

            private void OnDestroy()
            {
                bool useExplosion = false;
                switch (type)
                {
                    case NukeType.Mine:
                        useExplosion = true;
                        break;
                    case NukeType.Rocket:
                        break;
                    case NukeType.Bullet:
                        break;
                    case NukeType.Explosive:
                        useExplosion = true;
                        break;
                    case NukeType.Grenade:
                        break;
                    default:
                        break;
                }
                instance.InitializeZone(transform.position, 30, 10, 20, useExplosion);
            }

            public void InitializeComponent(NukeWeapons ins, NukeType typ, ConfigData.NWType.RadiationStats sta)
            {
                instance = ins;
                type = typ;
                stats = sta;
            }
        }

        public class ZoneList
        {
            public RadiationZone zone;
            public Timer time;
        }

        internal class RadiationZone : MonoBehaviour
        {            
            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "radiation_zone";

                Rigidbody rigidbody = gameObject.AddComponent<Rigidbody>();
                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;
            }

            public void Activate(Vector3 pos, float radius, float amount)
            {
                transform.position = pos;

                SphereCollider sphereCollider = gameObject.GetComponent<SphereCollider>() ?? gameObject.AddComponent<SphereCollider>();
                sphereCollider.isTrigger = true;
                sphereCollider.radius = radius;

                TriggerRadiation triggerRadiation = gameObject.GetComponent<TriggerRadiation>() ?? gameObject.AddComponent<TriggerRadiation>();
                triggerRadiation.RadiationAmountOverride = amount;
                triggerRadiation.interestLayers = PlayerMask;
                triggerRadiation.enabled = true;

                gameObject.SetActive(true);
                enabled = true;
            }
        }

        #endregion
       
        #region Chat Commands
        [ChatCommand("nw")]
        private void cmdNukes(BasePlayer player, string command, string[] args)
        {
            if (HasPermission(player, NukeType.Bullet) || HasPermission(player, NukeType.Explosive) || HasPermission(player, NukeType.Grenade) || HasPermission(player, NukeType.Mine) || HasPermission(player, NukeType.Rocket))
            {
                CheckPlayerEntry(player);
                OpenCraftingMenu(player);
            }       
        }
        #endregion

        #region Permissions
        private bool HasPermission(BasePlayer player, NukeType type)
        {
            string perm = string.Empty;
            switch (type)
            {
                case NukeType.Mine:
                    perm = "nukeweapons.mine";
                    break;
                case NukeType.Rocket:
                    perm = "nukeweapons.rocket";
                    break;
                case NukeType.Bullet:
                    perm = "nukeweapons.bullet";
                    break;
                case NukeType.Explosive:
                    perm = "nukeweapons.explosive";
                    break;
                case NukeType.Grenade:
                    perm = "nukeweapons.grenade";
                    break;
                default:
                    break;
            }
            return permission.UserHasPermission(player.UserIDString, perm) || permission.UserHasPermission(player.UserIDString, "nukeweapons.all") || player.IsAdmin;
        } 
        
        private bool HasUnlimitedAmmo(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "nukeweapons.unlimited");
        #endregion

        #region Config        
        private ConfigData configData;

        private class ConfigData
        {            
            public NWType Mines { get; set; }
            public NWType Rockets { get; set; }
            public NWType Bullets { get; set; }
            public NWType Grenades { get; set; }
            public NWType Explosives { get; set; }
            public Option Options { get; set; }
            public Dictionary<string, string> URL_IconList { get; set; }

            public class NWType
            {
                public bool Enabled { get; set; }
                public int MaxAllowed { get; set; }
                public int CraftTime { get; set; }
                public int CraftAmount { get; set; }
                public Dictionary<string, int> CraftingCosts { get; set; }
                public RadiationStats RadiationProperties { get; set; }

                public class RadiationStats
                {
                    public float Intensity { get; set; }
                    public float Duration { get; set; }
                    public float Radius { get; set; }
                }
            }

            public class Option
            {
                public string MSG_MainColor { get; set; }
                public string MSG_SecondaryColor { get; set; }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Bullets = new ConfigData.NWType
                {
                    CraftAmount = 5,
                    CraftTime = 30,
                    CraftingCosts = new Dictionary<string, int>
                    {
                        {"ammo.rifle.explosive", 5 },
                        {"sulfur", 10 },
                        {"lowgradefuel", 10 }
                    },
                    Enabled = true,
                    MaxAllowed = 100,
                    RadiationProperties = new ConfigData.NWType.RadiationStats
                    {
                        Intensity = 15,
                        Duration = 3,
                        Radius = 5
                    }
                },
                Explosives = new ConfigData.NWType
                {
                    CraftAmount = 1,
                    CraftTime = 90,
                    CraftingCosts = new Dictionary<string, int>
                    {
                        {"explosive.timed", 1 },
                        {"sulfur", 150 },
                        {"lowgradefuel", 200 }
                    },
                    Enabled = true,
                    MaxAllowed = 3,
                    RadiationProperties = new ConfigData.NWType.RadiationStats
                    {
                        Intensity = 60,
                        Duration = 30,
                        Radius = 25
                    }
                },
                Grenades = new ConfigData.NWType
                {
                    CraftAmount = 1,
                    CraftTime = 45,
                    CraftingCosts = new Dictionary<string, int>
                    {
                        {"grenade.f1", 1 },
                        {"sulfur", 100 },
                        {"lowgradefuel", 100 }
                    },
                    Enabled = true,
                    MaxAllowed = 3,
                    RadiationProperties = new ConfigData.NWType.RadiationStats
                    {
                        Intensity = 35,
                        Duration = 15,
                        Radius = 15
                    }
                },
                Mines = new ConfigData.NWType
                {
                    CraftAmount = 1,
                    CraftTime = 60,
                    CraftingCosts = new Dictionary<string, int>
                    {
                        {"trap.landmine", 1 },
                        {"sulfur", 100 },
                        {"lowgradefuel", 150 }
                    },
                    Enabled = true,
                    MaxAllowed = 5,
                    RadiationProperties = new ConfigData.NWType.RadiationStats
                    {
                        Intensity = 70,
                        Duration = 25,
                        Radius = 20
                    }
                },
                Rockets = new ConfigData.NWType
                {
                    CraftAmount = 1,
                    CraftTime = 60,
                    CraftingCosts = new Dictionary<string, int>
                    {
                        {"ammo.rocket.basic", 1 },
                        {"sulfur", 150 },
                        {"lowgradefuel", 150 }
                    },
                    Enabled = true,
                    MaxAllowed = 3,
                    RadiationProperties = new ConfigData.NWType.RadiationStats
                    {
                        Intensity = 45,
                        Duration = 15,
                        Radius = 10
                    }
                },
                Options = new ConfigData.Option
                {
                    MSG_MainColor = "<color=#00CC00>",
                    MSG_SecondaryColor = "<color=#939393>"                    
                },
                URL_IconList = new Dictionary<string, string>
                {
                    {"BulletActive", "bulletactive.png" },
                    {"ExplosiveActive", "explosiveactive.png" },
                    {"GrenadeActive", "grenadeactive.png" },
                    {"MineActive", "landmineactive.png" },
                    {"RocketActive", "rocketactive.png" },
                    {"Bullet", "bullet.png" },
                    {"Explosive", "explosive.png" },
                    {"Grenade", "grenade.png" },
                    {"Mine", "landmine.png" },
                    {"Rocket", "rocket.png" },
                    {"Background", "background.png" }
                },
                Version = Version
            };
        }
        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Data Management
        private void SaveData()
        {
            _nukeData.ammo = _cachedAmmo;
            _data.WriteObject(_nukeData);
        }

        private void SaveDisplayNames()
        {
            _itemNames.displayNames = _displayNames;
            item_names.WriteObject(_itemNames);
        }

        private void LoadData()
        {
            try
            {
                _nukeData = _data.ReadObject<NukeData>();
                _cachedAmmo = _nukeData.ammo;
            }
            catch
            {
                _nukeData = new NukeData();
            }
            try
            {
                _itemNames = item_names.ReadObject<ItemNames>();
            }
            catch
            {
                Puts("Couldn't load item display name data, creating new datafile");
                _itemNames = new ItemNames();
            }
        }

        private class NukeData
        {
            public Hash<ulong, Hash<NukeType, int>> ammo = new Hash<ulong, Hash<NukeType, int>>();
            public List<ulong> Mines = new List<ulong>();
        }

        private class ItemNames
        {
            public Hash<string, string> displayNames = new Hash<string, string>();
        }

        private class PlayerAmmo
        {
            public int Rockets;
            public int Mines;
            public int Bullets;
            public int Explosives;
            public int Grenades;
        }

        private enum NukeType
        {
            Mine,
            Rocket,
            Bullet,
            Explosive,
            Grenade
        }
        #endregion

        #region Image Storage      
        [ConsoleCommand("nukeicons")]
        private void cmdNukeIcons(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) 
                return;
            
            PrintWarning("Storing icons to file storage...");     
            foreach (KeyValuePair<string, string> image in configData.URL_IconList)
                AddImage(image.Key, image.Value);
        }

        public void AddImage(string imageName, string fileName) => ImageLibrary.Call("AddImage", fileName.StartsWith("www") || fileName.StartsWith("http") ? fileName : dataDirectory + fileName, imageName);

        private string GetImage(string name) => (string)ImageLibrary.Call("GetImage", name);
        #endregion

        #region Messaging
        private void SendMSG(BasePlayer player, string message, string message2 = "") => SendReply(player, $"{configData.Options.MSG_MainColor}{message}</color>{configData.Options.MSG_SecondaryColor}{message2}</color>");

        private string MSG(string key, string playerid = null) => lang.GetMessage(key, this, playerid);

        private Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"Bullet", "Bullet" },
            {"Explosive", "Explosive" },
            {"Grenade", "Grenade" },
            {"Rocket", "Rocket" },
            {"Mine", "Mine" },
            {"Bullets", "Bullets" },
            {"Explosives", "Explosives" },
            {"Grenades", "Grenades" },
            {"Rockets", "Rockets" },
            {"Mines", "Mines" },
            {"activated", "You have activated Nuke <type>s" },
            {"Menu", "Menu" },
            {"Deactivate", "Deactivate" },
            {"Disarm", "Disarm" },
            {"Arm", "Arm" },
            {"Inventory Amount", "Inventory Amount" },
            {"Unlimited", "Unlimited" },
            {"Crafting...", "Crafting..." },
            {"Limit Reached", "Limit Reached" },
            {"Craft", "Craft" },
            {"Item Name", "Item Name" },
            {"Required Amount", "Required Amount" },
            {"Your Supply", "Your Supply" },
            {"Required Ingredients", "Required Ingredients" },
            {"Close", "Close" },
            {"OOA", "You have run out of Nuke" },
            {"Crafting", "Crafting" }
        };
        #endregion
    }
}


// --- End of file: NukeWeapons.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/night-vision ---
// --- Original File Path: N/NightVision/NightVision.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Network;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("NightVision", "Clearshot", "2.4.1")]
    [Description("Allows players to see at night")]
    class NightVision : CovalencePlugin
    {
        private PluginConfig _config;
        private Game.Rust.Libraries.Player _rustPlayer = Interface.Oxide.GetLibrary<Game.Rust.Libraries.Player>("Player");
        private EnvSync _envSync;
        private Dictionary<ulong, NVPlayerData> _playerData = new Dictionary<ulong, NVPlayerData>();
        private Dictionary<ulong, float> _playerTimes = new Dictionary<ulong, float>();
        private DateTime _nvDate;
        private List<ulong> _connected = new List<ulong>();

        private string PERM_ALLOWED = "nightvision.allowed";
        private string PERM_UNLIMITEDNVG = "nightvision.unlimitednvg";
        private string PERM_AUTO = "nightvision.auto";

        private bool API_blockEnvUpdates = false;

        private void SendChatMsg(BasePlayer pl, string msg, string prefix = null) =>
            _rustPlayer.Message(pl, msg, prefix != null ? prefix : lang.GetMessage("ChatPrefix", this, pl.UserIDString), Convert.ToUInt64(_config.chatIconID), Array.Empty<object>());

        private void Init()
        {
            permission.RegisterPermission(PERM_ALLOWED, this);
            permission.RegisterPermission(PERM_UNLIMITEDNVG, this);
            permission.RegisterPermission(PERM_AUTO, this);

            _playerTimes = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, float>>($"{Name}\\playerTimes");
        }

        private void OnServerInitialized()
        {
            _envSync = BaseNetworkable.serverEntities.OfType<EnvSync>().FirstOrDefault();

            timer.Every(5f, () => {
                if (!_envSync.limitNetworking)
                    _envSync.limitNetworking = true;

                List<Connection> subscribers = _envSync.net.group.subscribers;
                if (subscribers != null && subscribers.Count > 0)
                {
                    for (int i = 0; i < subscribers.Count; i++)
                    {
                        Connection connection = subscribers[i];
                        global::BasePlayer basePlayer = connection.player as global::BasePlayer;

                        if (!(basePlayer == null)) {
                            NVPlayerData nvPlayerData = GetNVPlayerData(basePlayer);

                            if (API_blockEnvUpdates && !nvPlayerData.timeLocked) continue;

                            if (connection != null)
                            {
                                var write = Net.sv.StartWrite();
                                connection.validate.entityUpdates = connection.validate.entityUpdates + 1;
                                BaseNetworkable.SaveInfo saveInfo = new global::BaseNetworkable.SaveInfo
                                {
                                    forConnection = connection,
                                    forDisk = false
                                };
                                write.PacketID(Message.Type.Entities);
                                write.UInt32(connection.validate.entityUpdates);
                                using (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())
                                {
                                    _envSync.Save(saveInfo);
                                    if (nvPlayerData.timeLocked)
                                    {
                                        saveInfo.msg.environment.dateTime = _nvDate.AddHours(nvPlayerData.time).ToBinary();
                                        saveInfo.msg.environment.fog = 0;
                                        saveInfo.msg.environment.rain = 0;
                                        saveInfo.msg.environment.clouds = 0;
										saveInfo.msg.environment.wind = 0;
                                    }
                                    if (saveInfo.msg.baseEntity == null)
                                    {
                                        LogError(this + ": ToStream - no BaseEntity!?");
                                    }
                                    if (saveInfo.msg.baseNetworkable == null)
                                    {
                                        LogError(this + ": ToStream - no baseNetworkable!?");
                                    }
                                    saveInfo.msg.ToProto(write);
                                    _envSync.PostSave(saveInfo);
                                    write.Send(new SendInfo(connection));
                                }
                            }
                        }
                    }
                }
            });
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player != null && !_connected.Contains(player.userID))
                _connected.Add(player.userID);
        }

        private void OnPlayerDisconnected(BasePlayer pl, string reason)
        {
            if (pl != null && _playerData.ContainsKey(pl.userID))
                _playerData.Remove(pl.userID);

            if (pl != null && _connected.Contains(pl.userID))
                _connected.Remove(pl.userID);
        }

        private void OnPlayerSleepEnded(BasePlayer pl)
        {
            if (pl == null)
                return;

            if (!_connected.Contains(pl.userID))
                return;

            if (permission.UserHasPermission(pl.UserIDString, PERM_AUTO))
                NightVisionCommand(pl.IPlayer, "nv", new string[] { _playerTimes.ContainsKey(pl.userID) ? _playerTimes[pl.userID].ToString() : "" });

            _connected.Remove(pl.userID);
        }

        private void Unload()
        {
            if (_envSync != null)
                _envSync.limitNetworking = false;
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject($"{Name}\\playerTimes", _playerTimes);
        }

        [Command("nightvision", "nv", "unlimitednvg", "unvg")]
        private void NightVisionCommand(IPlayer player, string command, string[] args)
        {
            if (player == null) return;
            BasePlayer pl = (BasePlayer)player.Object;
            if (pl == null) return;

            if (args.Length != 0 && args[0] == "help")
            {
                StringBuilder sb = new StringBuilder();
                sb.AppendLine(lang.GetMessage("HelpTitle", this, pl.UserIDString));
                sb.AppendLine(lang.GetMessage("Help1", this, pl.UserIDString));

                if (permission.UserHasPermission(pl.UserIDString, PERM_UNLIMITEDNVG))
                    sb.AppendLine(lang.GetMessage("Help2", this, pl.UserIDString));

                SendChatMsg(pl, sb.ToString(), "");
                return;
            }

            NVPlayerData nvpd;
            switch(command)
            {
                case "nightvision":
                case "nv":
                    if (!permission.UserHasPermission(pl.UserIDString, PERM_ALLOWED))
                    {
                        SendChatMsg(pl, lang.GetMessage("NoPerms", this, pl.UserIDString));
                        return;
                    }

                    nvpd = GetNVPlayerData(pl);
                    nvpd.timeLocked = !nvpd.timeLocked;
                    float time;
                    nvpd.time = args.Length > 0 && float.TryParse(args[0], out time) && time >= 0 && time <= 24 ? time : _config.time;

                    if (permission.UserHasPermission(pl.UserIDString, PERM_AUTO))
                    {
                        _playerTimes[pl.userID] = nvpd.time;
                        SaveData();
                    }

                    SendChatMsg(pl, string.Format(lang.GetMessage(nvpd.timeLocked ? "TimeLocked" : "TimeUnlocked", this, pl.UserIDString), nvpd.time));
                    break;
                case "unlimitednvg":
                case "unvg":
                    if (!permission.UserHasPermission(pl.UserIDString, PERM_UNLIMITEDNVG))
                    {
                        SendChatMsg(pl, lang.GetMessage("NoPerms", this, pl.UserIDString));
                        return;
                    }

                    List<Item> unvgInv = pl.inventory.containerWear.itemList.FindAll((Item x) => x.info.name == "hat.nvg.item");
                    if (unvgInv.Count > 0)
                    {
                        foreach(Item i in unvgInv)
                        {
                            if (i.condition == 1 && i.amount == 0)
                            {
                                i.SwitchOnOff(false);
                                i.Remove();
                            }
                        }

                        pl.inventory.containerWear.capacity = 7;
                        SendChatMsg(pl, lang.GetMessage("RemoveUNVG", this, pl.UserIDString));
                    }
                    else
                    {
                        var item = ItemManager.CreateByName("nightvisiongoggles", 1, 0UL);
                        if (item != null)
                        {
                            item.OnVirginSpawn();
                            item.SwitchOnOff(true);
                            item.condition = 1;
                            item.amount = 0;
                            pl.inventory.containerWear.capacity = 8;
                            item.MoveToContainer(pl.inventory.containerWear, 7);
                            SendChatMsg(pl, lang.GetMessage("EquipUNVG", this, pl.UserIDString));
                        }
                    }
                    break;
            }
        }

        private object CanWearItem(PlayerInventory inventory, Item item, int targetSlot)
        {
            if (item == null || inventory == null) return null;
            if (item.info.name == "hat.nvg.item" && item.condition == 1 && item.amount == 0) return null;

            NextTick(() =>
            {
                if (inventory != null && inventory.containerMain != null)
                {
                    foreach (Item i in inventory.containerMain.itemList.FindAll((Item x) => x.info.name == "hat.nvg.item"))
                    {
                        if (i != null && i.condition == 1 && i.amount == 0)
                        {
                            i.SwitchOnOff(false);
                            i.Remove();
                            inventory.containerWear.capacity = 7;
                        }
                    }
                }
                if (inventory != null && inventory.containerBelt != null)
                {
                    foreach (Item i in inventory.containerBelt.itemList.FindAll((Item x) => x.info.name == "hat.nvg.item"))
                    {
                        if (i != null && i.condition == 1 && i.amount == 0)
                        {
                            i.SwitchOnOff(false);
                            i.Remove();
                            inventory.containerWear.capacity = 7;
                        }
                    }
                }
                if (inventory != null && inventory.containerWear != null)
                {
                    foreach (Item i in inventory.containerWear.itemList.FindAll((Item x) => x.info.name == "hat.nvg.item"))
                    {
                        if (i != null && i.condition == 1 && i.amount == 0)
                        {
                            i.SwitchOnOff(false);
                            i.Remove();
                            inventory.containerWear.capacity = 7;
                        }
                    }
                }
            });
            return null;
        }

        private void OnItemDropped(Item item, BaseEntity entity)
        {
            if (item != null && item.info.name == "hat.nvg.item" && item.condition == 1 && item.amount == 0)
            {
                item.Remove();
            }
        }

        private NVPlayerData GetNVPlayerData(BasePlayer pl)
        {
            _playerData[pl.userID] = _playerData.ContainsKey(pl.userID) ? _playerData[pl.userID] : new NVPlayerData();
			_playerData[pl.userID].timeLocked = !(!_playerData[pl.userID].timeLocked || !permission.UserHasPermission(pl.UserIDString, PERM_ALLOWED));
            return _playerData[pl.userID];
        }

        #region Plugin-API

        [HookMethod("LockPlayerTime")]
        void LockPlayerTime_PluginAPI(BasePlayer player, float time)
        {
            var data = GetNVPlayerData(player);
            data.timeLocked = true;
            data.time = time;
        }

        [HookMethod("UnlockPlayerTime")]
        void UnlockPlayerTime_PluginAPI(BasePlayer player)
        {
            var data = GetNVPlayerData(player);
            data.timeLocked = false;
        }

        [HookMethod("IsPlayerTimeLocked")]
        bool IsPlayerTimeLocked_PluginAPI(BasePlayer player)
        {
            var data = GetNVPlayerData(player);
            return data.timeLocked;
        }

        [HookMethod("BlockEnvUpdates")]
        void BlockEnvUpdates_PluginAPI(bool blockEnv)
        {
            API_blockEnvUpdates = blockEnv;
        }

        #endregion

        #region Config
        private DateTime _defaultDate = new DateTime(2024, 1, 25);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ChatPrefix"] = "<color=#00ff00>[Night Vision]</color>",
                ["NoPerms"] = "You do not have permission to use this command!",
                ["TimeLocked"] = "Time locked to {0}",
                ["TimeUnlocked"] = "Time unlocked",
                ["HelpTitle"] = "<size=16><color=#00ff00>Night Vision</color> Help</size>\n",
                ["Help1"] = "<color=#00ff00>/nightvision <0-24>(/nv)</color> - Toggle time lock night vision with optional time 0-24",
                ["Help2"] = "<color=#00ff00>/unlimitednvg (/unvg)</color> - Equip/remove unlimited night vision goggles",
                ["EquipUNVG"] = "Equipped unlimited night vision goggles",
                ["RemoveUNVG"] = "Removed unlimited night vision goggles"
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            PluginConfig config = new PluginConfig();
            config.date = _defaultDate.ToString("M/d/yyyy");
            config.time = 12;
            return config;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();

            if (_config.time < 0 || _config.time > 24)
                _config.time = 12;

            if (!DateTime.TryParse(_config.date, out _nvDate))
            {
                _nvDate = _defaultDate;
                _config.date = _defaultDate.ToString("M/d/yyyy");

                if (_config.time == 0)
                    _config.time = 12;
            }

            Config.WriteObject(_config, true);
        }

        private class PluginConfig
        {
            public string chatIconID = "0";
            public string date;
            public float time;

        }
        #endregion

        private class NVPlayerData
        {
            public bool timeLocked = false;
            public float time = 12f;
        }
    }
}


// --- End of file: NightVision.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-give-notices ---
// --- Original File Path: N/NoGiveNotices/NoGiveNotices.cs ---

namespace Oxide.Plugins
{
    [Info("No Give Notices", "Wulf", "0.3.0")]
    [Description("Prevents F1 item giving notices from showing in the chat")]
    class NoGiveNotices : RustPlugin
    {
        private object OnServerMessage(string message, string name)
        {
            if (message.Contains("gave") && name == "SERVER")
            {
                return true;
            }

            return null;
        }
    }
}


// --- End of file: NoGiveNotices.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-decay ---
// --- Original File Path: N/NoDecay/NoDecay.cs ---

﻿using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;

using Facepunch;

using Rust;

using Newtonsoft.Json;

using Oxide.Core;

using ProtoBuf;

using Environment = System.Environment;

namespace Oxide.Plugins
{
    [Info("No Decay", "0x89A", "1.5.0")]
    [Description("Scales or disables decay of items and deployables")]
    class NoDecay : RustPlugin
    {
        private Configuration _config;

        private readonly Dictionary<ulong, BuildingPrivlidge> _cachedToolCupboards = new();

        private const int WoodItemId = -151838493;
        private const int StoneItemId = -2099697608;
        private const int MetalFragmentsItemId = 69511070;
        private const int HqMetalItemId = 317398316;
        
        private readonly uint _toolCupboardPrefabId = StringPool.Get("cupboard.tool.deployed");
        private readonly uint _retroToolCupboardPrefabId = StringPool.Get("cupboard.tool.retro.deployed");
        private readonly uint _shockByteToolCupboardPrefabId = StringPool.Get("cupboard.tool.shockbyte.deployed");

        private readonly ConcurrentQueue<string> _logQueue = new();
        private bool _logQueueRunning;

        private string _logFileName;

        private void Init()
        {
            if (_config.General.Output.logToFile)
            {
                string logDirectory = Path.Combine(Interface.Oxide.LogDirectory, Name);
            
                _logFileName = Path.Combine(logDirectory, $"{_config.General.Output.logFileName}_");
            
                if (!Directory.Exists(logDirectory))
                {
                    Directory.CreateDirectory(logDirectory);
                }
            }
            
            permission.RegisterPermission(_config.General.permission, this);
        }

        private void Output(string text)
        {
            if (_config.General.Output.rconOutput)
            {
                Puts(text);
            }
            
            if (_config.General.Output.logToFile)
            {
                if (!text.EndsWith(Environment.NewLine))
                {
                    text += Environment.NewLine;
                }
                
                _logQueue.Enqueue(text);

                if (!_logQueueRunning)
                {
                    _ = Task.Run(LogWorker);
                }
            }
        }

        private void LogWorker()
        {
            _logQueueRunning = true;

            string fileName = _logFileName + $"{DateTime.Now:yyyy-MM-dd}.txt";
            
            while (_logQueue.TryDequeue(out string message))
            {
                File.AppendAllText(fileName, message);
            }

            _logQueueRunning = false;
        }

        #region -Oxide Hooks-
        
        private object OnEntityTakeDamage(DecayEntity entity, HitInfo info)
        {
            if (info?.damageTypes == null || !info.damageTypes.Has(DamageType.Decay) || entity?.net == null)
            {
                return null;
            }

            ulong netId = entity.net.ID.Value;
            if (!_cachedToolCupboards.TryGetValue(netId, out BuildingPrivlidge toolCupboard) || toolCupboard == null)
            {
                toolCupboard = entity.GetBuildingPrivilege();
                _cachedToolCupboards[netId] = toolCupboard;
            }

            if (_config.General.usePermission)
            {
                // Block decaying if the entity has no owner player
                if (entity.OwnerID == 0)
                {
                    return !_config.General.decayNoOwner ? true : null;
                }

                // Block decay if owner has permission 
                if (permission.UserHasPermission(entity.OwnerID.ToString(), _config.General.permission)) 
                {
                    return true; 
                }

                if (_config.General.CupboardSettings.anyAuthed && CheckAllToolCupboardPlayers(toolCupboard))
                {
                    return true;
                }

                Output(string.Format(lang.GetMessage("NoPermission", this), entity.OwnerID));
            }
            
            // Don't block decay if out of range of a tool cupboard
            if (_config.General.CupboardSettings.requireTC && !AnyToolCupboards(entity))
            {
                Output(string.Format(lang.GetMessage("OutOfRange", this), entity.ShortPrefabName, entity.transform.position));
                return null;
            }

            if (_config.General.disableAll)
            {
                return true;
            }
            
            // Scale damage for building blocks
            if (entity is BuildingBlock block)
            {
                info.damageTypes.ScaleAll(_config.buildingMultipliers[(int)block.grade]);

                Output(string.Format(lang.GetMessage("DecayBlocked", this), block.ShortPrefabName, block.transform.position));
                
                // Prevent repair cooldown if no decay damage is done
                if (!info.hasDamage)
                {
                    return true;
                }

                return null;
            }

            string matchingKey = null;
            if (_config.multipliers.ContainsKey(entity.ShortPrefabName) || IsOfType(entity, out matchingKey))
            {
                if (_config.General.excludeOthers)
                {
                    return null;
                }
                
                info.damageTypes.ScaleAll(_config.multipliers[matchingKey ?? entity.ShortPrefabName]);

                Output(string.Format(lang.GetMessage("DecayBlocked", this), entity.ShortPrefabName, entity.transform.position));
                
                // Prevent repair cooldown if no decay damage is done
                if (!info.hasDamage)
                {
                    return true;
                }
            }
            
            return null;
        }

        private object CanMoveItem(Item item, PlayerInventory playerLoot, ItemContainerId targetContainer, int targetSlot, int amount)
        {
            BaseEntity entity = playerLoot.FindContainer(targetContainer)?.entityOwner;
            if (!IsToolCupboard(entity))
            {
                return null;
            }

            bool shouldBlock = item.info.itemid switch
            {
                WoodItemId => _config.General.CupboardSettings.blockWood,
                StoneItemId => _config.General.CupboardSettings.blockStone,
                MetalFragmentsItemId => _config.General.CupboardSettings.blockMetal,
                HqMetalItemId => _config.General.CupboardSettings.blockHighQ,
                _ => false
            };

            if (shouldBlock)
            {
                Output(lang.GetMessage("ItemMoveBlocked", this).Replace("{0}", item.info.shortname).Replace("{1}", $"{entity.ShortPrefabName}"));
                return true;
            }

            return null;
        }

        private bool AnyToolCupboards(BaseEntity entity)
        {
            BuildingManager.Building building = null;

            if (entity is BuildingBlock block)
            {
                building = block.GetBuilding();
            }
            else
            {
                OBB obb = entity.WorldSpaceBounds();

                List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
                Vis.Entities(obb.position, 16f + obb.extents.magnitude, list, 2097152);
            
                for (int index = 0; index < list.Count; ++index)
                {
                    BuildingBlock buildingBlock = list[index];
                    if (!(obb.Distance(buildingBlock.WorldSpaceBounds()) <= 16))
                    {
                        continue;
                    }

                    building = buildingBlock.GetBuilding();
                    break;
                }
                
                Pool.FreeUnmanaged(ref list);
            }
            
            if (building != null && building.HasBuildingPrivileges())
            {
                return true;
            }

            return false;
        }

        private bool CheckAllToolCupboardPlayers(BuildingPrivlidge toolCupboard)
        {
            if (toolCupboard == null || !toolCupboard.AnyAuthed())
            {
                return false;
            }

            foreach (PlayerNameID player in toolCupboard.authorizedPlayers)
            {
                if (player == null)
                {
                    continue;
                }
                
                if (permission.UserHasPermission(player.userid.ToString(), _config.General.permission))
                {
                    return true;
                }
            }

            return false;
        }

        private bool IsOfType(BaseEntity entity, out string matchingKey)
        {
            matchingKey = null;

            string typeName = entity.GetType().Name;

            foreach (string key in _config.multipliers.Keys)
            {
                if (string.Equals(key, typeName, StringComparison.OrdinalIgnoreCase))
                {
                    matchingKey = key;
                    return true;
                }
            }

            return false;
        }

        private bool IsToolCupboard(BaseEntity entity)
        {
            return entity != null && (entity.prefabID == _toolCupboardPrefabId || entity.prefabID == _retroToolCupboardPrefabId ||
                                      entity.prefabID == _shockByteToolCupboardPrefabId);
        }

        #endregion

        #region -Configuration-

        private class Configuration
        {
            [JsonProperty(PropertyName = "General")]
            public GeneralSettings General = new GeneralSettings();

            [JsonProperty(PropertyName = "Building grade multipliers")]
            public TierMultipliers BuildingTiers = new TierMultipliers();

            [JsonProperty(PropertyName = "Other multipliers")]
            public Dictionary<string, float> multipliers = new Dictionary<string, float>();

            #region -Classes-

            public class GeneralSettings
            {
                [JsonProperty(PropertyName = "Disable decay for all entities")]
                public bool disableAll = false;

                [JsonProperty(PropertyName = "Exclude \"Other Multipliers\"")]
                public bool excludeOthers = false;

                [JsonProperty(PropertyName = "Use permission")]
                public bool usePermission = true;

                [JsonProperty(PropertyName = "Decay if there is no owner (and perms enabled)")]
                public bool decayNoOwner = false;

                [JsonProperty(PropertyName = "Permission")]
                public string permission = "nodecay.use";

                [JsonProperty(PropertyName = "Output")]
                public OutputClass Output = new OutputClass();

                [JsonProperty(PropertyName = "Cupboard Settings")]
                public CupboardSettingsClass CupboardSettings = new CupboardSettingsClass();

                public class OutputClass
                {
                    [JsonProperty(PropertyName = "Output to server console")]
                    public bool rconOutput = false;

                    [JsonProperty(PropertyName = "Log to file")]
                    public bool logToFile = false;

                    [JsonProperty(PropertyName = "Log file name")]
                    public string logFileName = "NoDecay-Log";
                }

                public class CupboardSettingsClass
                {
                    [JsonProperty(PropertyName = "Disable No Decay if resources placed in TC")]
                    public bool disableOnResources = false;

                    [JsonProperty(PropertyName = "Require Tool Cupboard")]
                    public bool requireTC = false;

                    [JsonProperty(PropertyName = "Any authed on TC")]
                    public bool anyAuthed = false;

                    [JsonProperty(PropertyName = "Cupboard Range")]
                    public float cupboardRange = 30f;

                    [JsonProperty(PropertyName = "Block cupboard wood")]
                    public bool blockWood = false;

                    [JsonProperty(PropertyName = "Block cupboard stone")]
                    public bool blockStone = false;

                    [JsonProperty(PropertyName = "Block cupbard metal")]
                    public bool blockMetal = false;

                    [JsonProperty(PropertyName = "Block cupboard high quality")]
                    public bool blockHighQ = false;
                }
            }

            public class TierMultipliers
            {
                [JsonProperty(PropertyName = "Twig multiplier")]
                public float twig = 1f;

                [JsonProperty(PropertyName = "Wood multiplier")]
                public float wood = 0f;

                [JsonProperty(PropertyName = "Stone multiplier")]
                public float stone = 0f;

                [JsonProperty(PropertyName = "Sheet Metal multiplier")]
                public float metal = 0f;

                [JsonProperty(PropertyName = "Armoured multiplier")]
                public float armoured = 0f;
            }

            #endregion -Classes-

            [JsonIgnore]
            public float[] buildingMultipliers;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                _config.buildingMultipliers = new float[5] { _config.BuildingTiers.twig, _config.BuildingTiers.wood, _config.BuildingTiers.stone, _config.BuildingTiers.metal, _config.BuildingTiers.armoured };
                SaveConfig();
            }
            catch
            {
                PrintError("Error loading config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion -Configuration-

        #region -Localisation-

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "{0} does not have permission\n",
                ["ItemMoveBlocked"] = "{0} was blocked from being added to TC at {1}\n",
                ["DecayBlocked"] = "Decay was overriden on {0} at {1}\n",
                ["OutOfRange"] = "{0} was out of TC range, at {1}\n",
            }, this);
        }

        #endregion -Localisation-
    }
}

// --- End of file: NoDecay.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/nteleportation ---
// --- Original File Path: N/NTeleportation/NTeleportation.cs ---

//#define DEBUG
using Facepunch;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using Oxide.Plugins.NTeleportationExtensionMethods;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NTeleportation", "nivex", "1.8.9")]
    [Description("Multiple teleportation systems for admin and players")]
    class NTeleportation : RustPlugin
    {
        [PluginReference]
        private Plugin Clans, Economics, IQEconomic, ServerRewards, Friends, CompoundTeleport, ZoneManager, NoEscape, RaidBlock, PopupNotifications, BlockUsers;

        private Dictionary<string, BasePlayer> _codeToPlayer = new();
        private Dictionary<string, string> _playerToCode = new();

        private bool newSave;
        private const string NewLine = "\n";
        private const string TPA = "tpa";
        private static readonly string[] nullArg = { };
        private const string PermAdmin = "nteleportation.admin";
        private const string PermRestrictions = "nteleportation.norestrictions";
        private const string ConfigDefaultPermVip = "nteleportation.vip";
        private const string PermHome = "nteleportation.home";
        private const string PermWipeHomes = "nteleportation.wipehomes";
        private const string PermCraftHome = "nteleportation.crafthome";
        private const string PermCaveHome = "nteleportation.cavehome";
        private const string PermDeleteHome = "nteleportation.deletehome";
        private const string PermHomeHomes = "nteleportation.homehomes";
        private const string PermImportHomes = "nteleportation.importhomes";
        private const string PermRadiusHome = "nteleportation.radiushome";
        private const string PermCraftTpR = "nteleportation.crafttpr";
        private const string PermCaveTpR = "nteleportation.cavetpr";
        private const string PermTpR = "nteleportation.tpr";
        private const string PermTpA = "nteleportation.tpa";
        private const string PermTp = "nteleportation.tp";
        private const string PermDisallowTpToMe = "nteleportation.disallowtptome";
        private const string PermTpT = "nteleportation.tpt";
        private const string PermTpB = "nteleportation.tpb";
        private const string PermTpN = "nteleportation.tpn";
        private const string PermTpL = "nteleportation.tpl";
        private const string PermTpConsole = "nteleportation.tpconsole";
        private const string PermTpRemove = "nteleportation.tpremove";
        private const string PermTpSave = "nteleportation.tpsave";
        private const string PermExempt = "nteleportation.exemptfrominterruptcountdown";
        private const string PermFoundationCheck = "nteleportation.bypassfoundationcheck";
        private const string PermTpMarker = "nteleportation.tpmarker";
        private DynamicConfigFile dataConvert;
        private DynamicConfigFile dataDisabled;
        private DynamicConfigFile dataAdmin;
        private DynamicConfigFile dataHome;
        private DynamicConfigFile dataTPR;
        private DynamicConfigFile dataTPT;
        private Dictionary<ulong, AdminData> _Admin;
        private Dictionary<ulong, HomeData> _Home;
        private Dictionary<ulong, TeleportData> _TPR;
        private Dictionary<string, List<string>> TPT = new();
        private bool changedAdmin;
        private bool changedHome;
        private bool changedTPR;
        private bool changedTPT;
        private float boundary;
        private readonly Dictionary<ulong, float> TeleportCooldowns = new();
        private readonly Dictionary<ulong, TeleportTimer> TeleportTimers = new();
        private readonly Dictionary<ulong, Timer> PendingRequests = new();
        private readonly Dictionary<ulong, BasePlayer> PlayersRequests = new();
        private readonly Dictionary<int, string> ReverseBlockedItems = new();
        private readonly Dictionary<ulong, Vector3> teleporting = new();
        private SortedDictionary<string, Vector3> caves = new();
        private List<PrefabInfo> monuments = new();
        private bool outpostEnabled;
        private bool banditEnabled;

        private class PrefabInfo
        {
            public Quaternion rotation;
            public Vector2 positionXZ;
            public Vector3 position;
            public Vector3 extents;
            public string name;
            public string prefab;
            public bool sphere;
            public PrefabInfo() { }
            public PrefabInfo(Vector3 position, Quaternion rotation, Vector3 extents, float extra, string name, string prefab, bool sphere)
            {
                this.sphere = sphere;
                this.position = position;
                this.rotation = rotation;
                this.name = name;
                this.prefab = prefab;
                this.extents = extents + new Vector3(extra, extra, extra);
                positionXZ = position.XZ2D();
            }
            public bool IsInBounds(Vector3 a)
            {
                if (sphere)
                {
                    if (a.y > position.y + (extents.y * 1.75f))
                    {
                        return false;
                    }

                    return Vector3Ex.Distance2D(a, position) <= extents.Max();
                }

                Vector3 v = Quaternion.Inverse(rotation) * (a - position);

                return v.x <= extents.x && v.x > -extents.x && v.y <= extents.y && v.y > -extents.y && v.z <= extents.z && v.z > -extents.z;
            }
        }

        #region Configuration

        private static Configuration config;

        public class InterruptSettings
        {
            [JsonProperty(PropertyName = "Interrupt Teleport At Specific Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Monuments { get; set; } = new List<string>();

            [JsonProperty(PropertyName = "Above Water")]
            public bool AboveWater { get; set; } = true;

            [JsonProperty(PropertyName = "Under Water")]
            public bool UnderWater { get; set; }

            [JsonProperty(PropertyName = "Balloon")]
            public bool Balloon { get; set; } = true;

            [JsonProperty(PropertyName = "Boats")]
            public bool Boats { get; set; }

            [JsonProperty(PropertyName = "Cargo Ship")]
            public bool Cargo { get; set; } = true;

            [JsonProperty(PropertyName = "Cold")]
            public bool Cold { get; set; } = false;

            [JsonProperty(PropertyName = "Excavator")]
            public bool Excavator { get; set; } = false;

            [JsonProperty(PropertyName = "Hot")]
            public bool Hot { get; set; } = false;

            [JsonProperty(PropertyName = "Hostile")]
            public bool Hostile { get; set; } = false;

            [JsonProperty(PropertyName = "Hostile Includes Towns")]
            public bool IncludeHostileTown { get; set; } = true;

            [JsonProperty(PropertyName = "Hurt")]
            public bool Hurt { get; set; } = true;

            [JsonProperty(PropertyName = "Junkpiles")]
            public bool Junkpiles { get; set; }

            [JsonProperty(PropertyName = "Lift")]
            public bool Lift { get; set; } = true;

            [JsonProperty(PropertyName = "Monument")]
            public bool Monument { get; set; } = false;

            [JsonProperty(PropertyName = "Ignore Monument Marker Prefab")]
            public bool BypassMonumentMarker { get; set; } = false;

            [JsonProperty(PropertyName = "Mounted")]
            public bool Mounted { get; set; } = true;

            [JsonProperty(PropertyName = "Oil Rig")]
            public bool Oilrig { get; set; } = false;

            [JsonProperty(PropertyName = "Safe Zone")]
            public bool Safe { get; set; } = true;

            [JsonProperty(PropertyName = "Swimming")]
            public bool Swimming { get; set; } = false;
        }

        private void OnPlayerSleep(BasePlayer player)
        {
            DelayedTeleportHome(player);
        }

        private List<(Vector3 position, float sqrDistance)> safeZones = new();

        private bool IsSafeZone(Vector3 a, float extra = 0f) // SetUserTargetHitPos
        {
            if (safeZones.Count == 0)
            {
                foreach (var triggerSafeZone in TriggerSafeZone.allSafeZones)
                {
                    float radius = (triggerSafeZone.triggerCollider == null ? 25f : ColliderEx.GetRadius(triggerSafeZone.triggerCollider, triggerSafeZone.transform.localScale)) + extra;
                    Vector3 center = triggerSafeZone.triggerCollider?.bounds.center ?? triggerSafeZone.transform.position;
                    safeZones.Add((center, radius * radius));
                }
            }
            return safeZones.Exists(zone => (zone.position - a).sqrMagnitude <= zone.sqrDistance);
        }

        public bool IsAuthed(BasePlayer player, BuildingPrivlidge priv) => (priv.OwnerID == player.userID && config.Home.UsableIntoBuildingBlocked) || config.Home.UsableIntoBuildingBlocked || priv.IsAuthed(player);

        private List<ulong> delayedTeleports = new();

        public void DelayedTeleportHome(BasePlayer player)
        {
            ulong userid = player.userID;
            if (delayedTeleports.Contains(userid))
            {
                return;
            }
            delayedTeleports.Add(userid);
            timer.Once(0.2f, () =>
            {
                if (player.IsKilled() || player.IsDead() || player.IsConnected || !IsSafeZone(player.transform.position))
                {
                    delayedTeleports.Remove(userid);
                    return;
                }
                timer.Once(config.Settings.TeleportHomeSafeZone, () =>
                {
                    if (player.IsKilled() || player.IsDead() || player.IsConnected || !IsSafeZone(player.transform.position) || !delayedTeleports.Remove(userid))
                    {
                        return;
                    }
                    var homes = new List<(Vector3 position, BuildingManager.Building building, string home)>();
                    foreach (var (home, position) in GetPlayerHomes(player))
                    {
                        var priv = player.GetBuildingPrivilege(new OBB(position, player.transform.rotation, player.bounds));
                        if (priv.IsKilled() || !IsAuthed(player, priv))
                        {
                            continue;
                        }
                        var building = priv.GetBuilding();
                        if (building == null || !building.HasDecayEntities())
                        {
                            continue;
                        }
                        homes.Add((position, building, home));
                    }
                    if (homes.Count == 0)
                    {
                        foreach (var bed in SleepingBag.FindForPlayer(userid, true))
                        {
                            var building = bed.GetBuilding();
                            if (building == null || !building.HasDecayEntities())
                            {
                                continue;
                            }
                            homes.Add((bed.transform.position, building, bed.niceName));
                        }
                    }
                    if (homes.Count > 0)
                    {
                        homes.Sort((x, y) => x.building.decayEntities.Count.CompareTo(y.building.decayEntities.Count));
                        Puts($"Teleporting {player.displayName} ({player.userID}) in safe zone from {player.transform.position} to home ({homes[0].home}) at {homes[0].position}");
                        Teleport(player, homes[0].position, "home", 0uL, false, false, true, true, true);
                    }
                });
            });
        }

        private object OnPlayerRespawn(BasePlayer player)
        {
            if (player == null) return null;

            var settings = GetSettings("outpost");

            if (settings == null || settings.Location == Vector3.zero) return null;

            if (Interface.Oxide.CallHook("CanTeleport", player, settings.Location) != null) return null;

            if (player.State.unHostileTimestamp > TimeEx.currentTimestamp)
            {
                player.State.unHostileTimestamp = TimeEx.currentTimestamp;
                player.DirtyPlayerState();
                player.ClientRPC(RpcTarget.Player("SetHostileLength", player), 0f);
            }

            if (player.unHostileTime > UnityEngine.Time.realtimeSinceStartup)
            {
                player.unHostileTime = UnityEngine.Time.realtimeSinceStartup;
            }

            return new BasePlayer.SpawnPoint { pos = settings.Location, rot = Quaternion.identity };
        }

        public class PluginSettings
        {
            [JsonProperty(PropertyName = "Delay Saving Data On Server Save")]
            public double SaveDelay { get; set; } = 4.0;

            [JsonProperty("TPB")]
            public TPBSettings TPB = new TPBSettings();

            [JsonProperty(PropertyName = "Interrupt TP")]
            public InterruptSettings Interrupt { get; set; } = new InterruptSettings();

            [JsonProperty(PropertyName = "Auto Wake Up After Teleport")]
            public bool AutoWakeUp { get; set; }

            [JsonProperty(PropertyName = "Seconds Until Teleporting Home Offline Players Within SafeZones")]
            public float TeleportHomeSafeZone { get; set; }

            [JsonProperty(PropertyName = "Respawn Players At Outpost")]
            public bool RespawnOutpost { get; set; }

            [JsonProperty(PropertyName = "Block Teleport (NoEscape)")]
            public bool BlockNoEscape { get; set; }

            [JsonProperty(PropertyName = "Block Teleport (RaidBlock)")]
            public bool RaidBlock { get; set; }

            [JsonProperty(PropertyName = "Block Teleport (ZoneManager)")]
            public bool BlockZoneFlag { get; set; }

            [JsonProperty(PropertyName = "Block Map Marker Teleport (AbandonedBases)")]
            public bool BlockAbandoned { get; set; }

            [JsonProperty(PropertyName = "Block Map Marker Teleport (RaidableBases)")]
            public bool BlockRaidable { get; set; }

            [JsonProperty(PropertyName = "Chat Name")]
            public string ChatName { get; set; } = "<color=red>Teleportation</color> \n\n";

            [JsonProperty(PropertyName = "Chat Steam64ID")]
            public ulong ChatID { get; set; } = 76561199056025689;

            [JsonProperty(PropertyName = "Check Boundaries On Teleport X Y Z")]
            public bool CheckBoundaries { get; set; } = true;

            [JsonProperty(PropertyName = "Check Boundaries Min Height")]
            public float BoundaryMin { get; set; } = -100f;

            [JsonProperty(PropertyName = "Check Boundaries Max Height")]
            public float BoundaryMax { get; set; } = 2000f;

            [JsonProperty(PropertyName = "Check If Inside Rock")]
            public bool Rock { get; set; } = true;

            [JsonProperty(PropertyName = "Height To Prevent Teleporting To/From (0 = disabled)")]
            public float ForcedBoundary { get; set; }

            [JsonProperty(PropertyName = "Data File Directory (Blank = Default)")]
            public string DataFileFolder { get; set; } = string.Empty;

            [JsonProperty(PropertyName = "Draw Sphere On Set Home")]
            public bool DrawHomeSphere { get; set; } = true;

            [JsonProperty(PropertyName = "Homes Enabled")]
            public bool HomesEnabled { get; set; } = true;

            [JsonProperty(PropertyName = "TPR Enabled")]
            public bool TPREnabled { get; set; } = true;

            [JsonProperty(PropertyName = "Strict Foundation Check")]
            public bool StrictFoundationCheck { get; set; } = false;

            [JsonProperty(PropertyName = "Minimum Temp")]
            public float MinimumTemp { get; set; } = 0f;

            [JsonProperty(PropertyName = "Maximum Temp")]
            public float MaximumTemp { get; set; } = 40f;

            [JsonProperty(PropertyName = "Blocked Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, string> BlockedItems { get; set; } = new(StringComparer.OrdinalIgnoreCase);
            //{
            //    ["explosive.timed"] = "You cannot teleport with C4!",
            //    ["gunpowder"] = "You cannot teleport with gun powder!",
            //    ["explosives"] = "You cannot teleport with explosives!",
            //};

            [JsonProperty(PropertyName = "Blocked Town Prefabs", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> BlockedPrefabs { get; set; } = new();

            [JsonProperty(PropertyName = "Bypass CMD")]
            public string BypassCMD { get; set; } = "pay";

            [JsonProperty(PropertyName = "Use Economics")]
            public bool UseEconomics { get; set; } = false;

            [JsonProperty(PropertyName = "Use Server Rewards")]
            public bool UseServerRewards { get; set; } = false;

            [JsonProperty(PropertyName = "Wipe On Upgrade Or Change")]
            public bool WipeOnUpgradeOrChange { get; set; } = true;

            [JsonProperty(PropertyName = "Auto Generate Outpost Location")]
            public bool AutoGenOutpost { get; set; } = true;

            [JsonProperty(PropertyName = "Outpost Map Prefab", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Outpost { get; set; } = new List<string> { "outpost", "compound" };

            [JsonProperty(PropertyName = "Auto Generate Bandit Location")]
            public bool AutoGenBandit { get; set; } = true;

            [JsonProperty(PropertyName = "Bandit Map Prefab", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Bandit { get; set; } = new List<string> { "bandit_town" };

            [JsonProperty(PropertyName = "Show Time As Seconds Instead")]
            public bool UseSeconds { get; set; } = false;

            [JsonProperty(PropertyName = "Use Quick Teleport")]
            public bool Quick { get; set; } = true;

            [JsonProperty(PropertyName = "Chat Command Color")]
            public string ChatCommandColor = "#FFFF00";

            [JsonProperty(PropertyName = "Chat Command Argument Color")]
            public string ChatCommandArgumentColor = "#FFA500";

            [JsonProperty("Enable Popup Support")]
            public bool UsePopup = false;

            [JsonProperty("Send Messages To Player")]
            public bool SendMessages = true;

            [JsonProperty("Block All Teleporting From Inside Authorized Base")]
            public bool BlockAuthorizedTeleporting = false;

            [JsonProperty("Global Teleport Cooldown")]
            public float Global = 0f;

            [JsonProperty("Global VIP Teleport Cooldown")]
            public float GlobalVIP = 0f;

            [JsonProperty("Play Sounds Before Teleport")]
            public bool PlaySoundsBeforeTeleport = true;

            [JsonProperty("Sound Effects Before Teleport", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> DisappearEffects = new List<string>
            {
                "assets/prefabs/missions/portal/proceduraldungeon/effects/disappear.prefab"
            };

            [JsonProperty("Play Sounds After Teleport")]
            public bool PlaySoundsAfterTeleport = true;

            [JsonProperty("Sound Effects After Teleport", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> ReappearEffects = new List<string>
            {
                "assets/prefabs/missions/portal/proceduraldungeon/effects/appear.prefab"
            };
        }

        public class TPBSettings
        {
            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> Countdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 0 } };

            [JsonProperty("Countdown")]
            public int Countdown = 0;

            [JsonProperty("Available After X Seconds")]
            public int Time = 0;
        }

        public class AdminSettings
        {
            [JsonProperty(PropertyName = "Announce Teleport To Target")]
            public bool AnnounceTeleportToTarget { get; set; } = false;

            [JsonProperty(PropertyName = "Usable By Admins")]
            public bool UseableByAdmins { get; set; } = true;

            [JsonProperty(PropertyName = "Usable By Moderators")]
            public bool UseableByModerators { get; set; } = true;

            [JsonProperty(PropertyName = "Location Radius")]
            public int LocationRadius { get; set; } = 25;

            [JsonProperty(PropertyName = "Teleport Near Default Distance")]
            public int TeleportNearDefaultDistance { get; set; } = 30;

            [JsonProperty(PropertyName = "Extra Distance To Block Monument Teleporting")]
            public int ExtraMonumentDistance { get; set; }
        }

        public class HomesSettings
        {
            [JsonProperty(PropertyName = "Homes Limit")]
            public int HomesLimit { get; set; } = 2;

            [JsonProperty(PropertyName = "VIP Homes Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPHomesLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Allow Sethome At Specific Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> AllowedMonuments { get; set; } = new List<string> { "HQM Quarry", "Stone Quarry", "Sulfur Quarry", "Ice Lake", "Wild Swamp" };

            [JsonProperty(PropertyName = "Allow Sethome At All Monuments")]
            public bool AllowAtAllMonuments { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Sethome On Tugboats")]
            public bool AllowTugboats { get; set; } = true;

            [JsonProperty(PropertyName = "Allow TPB")]
            public bool AllowTPB { get; set; } = true;

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Location Radius")]
            public int LocationRadius { get; set; } = 25;

            [JsonProperty(PropertyName = "Force On Top Of Foundation")]
            public bool ForceOnTopOfFoundation { get; set; } = true;

            [JsonProperty(PropertyName = "Check Foundation For Owner")]
            public bool CheckFoundationForOwner { get; set; } = true;

            [JsonProperty(PropertyName = "Use Friends")]
            public bool UseFriends { get; set; } = true;

            [JsonProperty(PropertyName = "Use Clans")]
            public bool UseClans { get; set; } = true;

            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams { get; set; } = true;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Usable Into Building Blocked")]
            public bool UsableIntoBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Usable From Safe Zone Only")]
            public bool UsableFromSafeZoneOnly { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Cupboard Owner When Building Blocked")]
            public bool CupOwnerAllowOnBuildingBlocked { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Iceberg")]
            public bool AllowIceberg { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Above Foundation")]
            public bool AllowAboveFoundation { get; set; } = true;

            [JsonProperty(PropertyName = "Check If Home Is Valid On Listhomes")]
            public bool CheckValidOnList { get; set; } = false;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;

            [JsonProperty(PropertyName = "Hours Before Useable After Wipe")]
            public double Hours { get; set; } = 0;
        }

        public class TPTSettings
        {
            [JsonProperty(PropertyName = "Use Friends")]
            public bool UseFriends { get; set; }

            [JsonProperty(PropertyName = "Use Clans")]
            public bool UseClans { get; set; }

            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams { get; set; }

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }
            [JsonProperty(PropertyName = "Enabled Color")]
            public string EnabledColor { get; set; } = "green";

            [JsonProperty(PropertyName = "Disabled Color")]
            public string DisabledColor { get; set; } = "red";
        }

        // Added `TPR => Play Sounds To Request Target` (false)
        // Added `TPR => Play Sounds When Target Accepts` (false)

        public class DiscordSettings
        {
            [JsonProperty(PropertyName = "Webhook URL")]
            public string Webhook = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

            [JsonProperty(PropertyName = "Log When TPA To Non-Ally Players More Than X Times")]
            public int TPA = 3;
        }

        public class TPRSettings
        {
            [JsonProperty(PropertyName = "Discord")]
            public DiscordSettings Discord { get; set; } = new();

            [JsonProperty("Play Sounds To Request Target")]
            public bool PlaySoundsToRequestTarget;

            [JsonProperty("Teleport Request Sound Effects", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> TeleportRequestEffects = new List<string>
            {
                "assets/prefabs/missions/portal/proceduraldungeon/effects/disappear.prefab"
            };

            [JsonProperty("Play Sounds When Target Accepts")]
            public bool PlaySoundsWhenTargetAccepts;

            [JsonProperty("Teleport Accept Sound Effects", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> TeleportAcceptEffects = new List<string>
            {
                "assets/prefabs/missions/portal/proceduraldungeon/effects/appear.prefab"
            };

            [JsonProperty(PropertyName = "Require Player To Be Friend, Clan Mate, Or Team Mate")]
            public bool UseClans_Friends_Teams { get; set; }

            [JsonProperty(PropertyName = "Require nteleportation.tpa to accept TPR requests")]
            public bool RequireTPAPermission { get; set; }

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }

            [JsonProperty(PropertyName = "Allow TPB")]
            public bool AllowTPB { get; set; } = true;

            [JsonProperty(PropertyName = "Use Blocked Users")]
            public bool UseBlockedUsers { get; set; } = false;

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Enable Request UI")]
            public bool UI { get; set; }

            [JsonProperty(PropertyName = "Request Duration")]
            public int RequestDuration { get; set; } = 30;

            [JsonProperty(PropertyName = "Block TPA On Ceiling")]
            public bool BlockTPAOnCeiling { get; set; } = true;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Usable Into Building Blocked")]
            public bool UsableIntoBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Cupboard Owner When Building Blocked")]
            public bool CupOwnerAllowOnBuildingBlocked { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = false;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;

            [JsonProperty(PropertyName = "Hours Before Useable After Wipe")]
            public double Hours { get; set; } = 0;
        }

        public class TownSettings
        {
            [JsonProperty(PropertyName = "Command Enabled")]
            public bool Enabled { get; set; } = true;

            [JsonProperty(PropertyName = "Set Position From Monument Marker Name")]
            public string MonumentMarkerName { get; set; } = "";

            [JsonProperty(PropertyName = "Set Position From Monument Marker Name Offset")]
            public string MonumentMarkerNameOffset { get; set; } = "0 0 0";

            [JsonProperty(PropertyName = "Allow TPB")]
            public bool AllowTPB { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Location")]
            public Vector3 Location { get; set; } = Vector3.zero;

            [JsonProperty(PropertyName = "Locations", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Vector3> Locations { get; set; } = new List<Vector3>();

            [JsonProperty(PropertyName = "Teleport To Random Location")]
            public bool Random { get; set; } = true;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = false;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;

            [JsonProperty(PropertyName = "Hours Before Useable After Wipe")]
            public double Hours { get; set; } = 0;

            public bool CanCraft(BasePlayer player, string command)
            {
                return AllowCraft || player.IPlayer.HasPermission($"nteleportation.craft{command.ToLower()}");
            }

            public bool CanCave(BasePlayer player, string command)
            {
                return AllowCave || player.IPlayer.HasPermission($"nteleportation.cave{command.ToLower()}");
            }

            [JsonIgnore]
            public StoredData Teleports = new StoredData();

            [JsonIgnore]
            public string Command { get; set; }
        }

        private class Configuration
        {
            [JsonProperty(PropertyName = "Settings")]
            public PluginSettings Settings = new PluginSettings();

            [JsonProperty(PropertyName = "Admin")]
            public AdminSettings Admin = new AdminSettings();

            [JsonProperty(PropertyName = "Home")]
            public HomesSettings Home = new HomesSettings();

            [JsonProperty(PropertyName = "TPT")]
            public TPTSettings TPT = new TPTSettings();

            [JsonProperty(PropertyName = "TPR")]
            public TPRSettings TPR = new TPRSettings();

            [JsonProperty(PropertyName = "Dynamic Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, TownSettings> DynamicCommands { get; set; } = DefaultCommands;
        }

        private static Dictionary<string, TownSettings> DefaultCommands = new Dictionary<string, TownSettings>
        {
            ["Town"] = new TownSettings() { Random = false },
            ["Island"] = new TownSettings() { AllowTPB = false },
            ["Outpost"] = new TownSettings(),
            ["Bandit"] = new TownSettings(),
        };

        public void InitializeDynamicCommands()
        {
            foreach (var entry in config.DynamicCommands)
            {
                if (!entry.Value.Enabled)
                {
                    continue;
                }
                else if (entry.Key.Equals("bandit", StringComparison.OrdinalIgnoreCase))
                {
                    if (CompoundTeleport == null || Convert.ToBoolean(CompoundTeleport?.Call("umodversion")))
                    {
                        banditEnabled = true;
                    }
                    else continue;
                }
                else if (entry.Key.Equals("outpost", StringComparison.OrdinalIgnoreCase))
                {
                    if (CompoundTeleport == null || Convert.ToBoolean(CompoundTeleport?.Call("umodversion")))
                    {
                        outpostEnabled = true;
                    }
                    else continue;
                }

                entry.Value.Command = entry.Key;
                RegisterCommand(entry.Key, nameof(CommandCustom));
            }

            RegisterCommand("ntp", nameof(CommandDynamic));
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            canSaveConfig = false;
            try
            {
                Config.Settings.Converters = new JsonConverter[] { new UnityVector3Converter() };
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                canSaveConfig = true;
                SaveConfig();
            }
            catch (JsonException ex)
            {
                Puts(ex.ToString());
                LoadDefaultConfig();
            }
            config.Settings.ReappearEffects.Remove("");
            config.Settings.DisappearEffects.Remove("");
            config.TPR.TeleportRequestEffects.Remove("");
            config.TPR.TeleportAcceptEffects.Remove("");
        }

        private bool canSaveConfig = true;

        protected override void SaveConfig()
        {
            if (canSaveConfig)
            {
                Config.WriteObject(config);
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();
            Puts("Loaded default configuration.");
        }

        #endregion

        private class DisabledData
        {
            [JsonProperty("List of disabled commands")]
            public List<string> DisabledCommands = new List<string>();

            public DisabledData() { }
        }

        private DisabledData DisabledCommandData = new();

        private class AdminData
        {
            [JsonProperty("t")]
            public bool Town { get; set; }

            [JsonProperty("u")]
            public ulong UserID { get; set; }

            [JsonProperty("d")]
            public string Home { get; set; }

            [JsonProperty("pl")]
            public Vector3 PreviousLocation { get; set; }

            [JsonProperty("b")]
            public bool BuildingBlocked { get; set; }

            [JsonProperty("c")]
            public bool AllowCrafting { get; set; }

            [JsonProperty("cv")]
            public bool AllowCave { get; set; }

            [JsonProperty("l")]
            public Dictionary<string, Vector3> Locations { get; set; } = new(StringComparer.OrdinalIgnoreCase);
        }

        private class HomeData
        {
            public class Entry
            {
                public Vector3 Position;
                public BaseNetworkable Entity;
                public bool isEntity => !Entity.IsKilled();
                public bool wasEntity;
                public Entry() { }
                public Entry(Vector3 Position)
                {
                    this.Position = Position;
                }
                public Vector3 Get()
                {
                    if (isEntity)
                    {
                        return Entity.transform.position + Position;
                    }
                    return Position;
                }
            }

            public class Boat
            {
                public ulong Value;
                public Vector3 Offset;
                public Boat() { }
                public Boat(Entry entry)
                {
                    Offset = entry.Position;
                    Value = entry.Entity.net.ID.Value;
                }
            }

            [JsonProperty("l")]
            public Dictionary<string, Vector3> buildings { get; set; } = new Dictionary<string, Vector3>(StringComparer.OrdinalIgnoreCase);

            [JsonProperty("b")]
            public Dictionary<string, Boat> boats { get; set; } = new Dictionary<string, Boat>(StringComparer.OrdinalIgnoreCase);

            [JsonProperty("t")]
            public TeleportData Teleports { get; set; } = new TeleportData();

            [JsonIgnore]
            private Dictionary<string, Entry> Cache = new Dictionary<string, Entry>();

            [JsonIgnore]
            public Dictionary<string, Entry> Locations
            {
                get
                {
                    if (Cache.Count == 0)
                    {
                        InitializeBuildings();
                        InitializeBoats();
                    }
                    return Cache;
                }
            }

            private void InitializeBuildings()
            {
                foreach (var pair in buildings)
                {
                    Cache[pair.Key] = new Entry(pair.Value);
                }
            }

            private void InitializeBoats()
            {
                foreach (var (key, boat) in boats.ToList())
                {
                    var entity = BaseNetworkable.serverEntities.Find(new NetworkableId(boat.Value));
                    if (entity.IsKilled()) continue;
                    Cache[key] = new Entry
                    {
                        Position = boat.Offset,
                        wasEntity = true,
                        Entity = entity
                    };
                }
            }

            public bool TryGetValue(string key, out Entry homeEntry)
            {
                return Locations.TryGetValue(key, out homeEntry);
            }

            public void Set(string key, Entry homeEntry)
            {
                Locations[key] = homeEntry;
                if (homeEntry.isEntity)
                {
                    boats[key] = new Boat(homeEntry);
                }
                else buildings[key] = homeEntry.Get();
            }

            public bool Remove(string key)
            {
                bool removed = boats.Remove(key) || buildings.Remove(key);
                return Locations.Remove(key) || removed;
            }
        }

        public class TeleportData
        {
            [JsonProperty("a")]
            public int Amount { get; set; }

            [JsonProperty("d")]
            public string Date { get; set; }

            [JsonProperty("t")]
            public int Timestamp { get; set; }
        }

        private class TeleportTimer
        {
            public string Town { get; set; } = "";
            public ulong UserID { get; set; }
            public string Home { get; set; } = "";
            public Timer Timer { get; set; }
            public BasePlayer OriginPlayer { get; set; }
            public BasePlayer TargetPlayer { get; set; }
        }

        private List<string> GetMonumentMessages()
        {
            return new List<string>
            {
                "Abandoned Cabins",
                "Abandoned Supermarket",
                "Abandoned Military Base",
                "Airfield",
                "Arctic Research Base",
                "Bandit Camp",
                "Barn",
                "Crow's Nest",
                "Ferry Terminal",
                "Fishing Village",
                "Gas Station",
                "Giant Excavator Pit",
                "Harbor",
                "HQM Quarry",
                "Ice Lake",
                "Junkyard",
                "Large Barn",
                "Large Fishing Village",
                "Launch Site",
                "Lighthouse",
                "Military Tunnel",
                "Mining Outpost",
                "Missile Silo",
                "Mountain",
                "Oil Rig",
                "Large Oil Rig",
                "Outpost",
                "Oxum's Gas Station",
                "Power Plant",
                "Ranch",
                "Radtown",
                "Satellite Dish",
                "Sewer Branch",
                "Stone Quarry",
                "Substation",
                "Sulfur Quarry",
                "The Supermarket",
                "The Dome",
                "Train Tunnel",
                "Train Yard",
                "Underwater Lab",
                "Water Treatment Plant",
                "Water Well",
                "Wild Swamp",
            };
        }

        protected override void LoadDefaultMessages()
        {
            if (!_cmcCompleted)
            {
                timer.Once(1f, LoadDefaultMessages);
                return;
            }

            var monumentMessages = GetMonumentMessages();

            var en = new Dictionary<string, string>
            {
                {"ErrorTPR", "Teleporting to {0} is blocked ({1})"},
                {"AdminTP", "You teleported to {0}!"},
                {"AdminTPTarget", "{0} teleported to you!"},
                {"AdminTPPlayers", "You teleported {0} to {1}!"},
                {"AdminTPPlayer", "{0} teleported you to {1}!"},
                {"AdminTPPlayerTarget", "{0} teleported {1} to you!"},
                {"AdminTPCoordinates", "You teleported to {0}!"},
                {"AdminTPTargetCoordinates", "You teleported {0} to {1}!"},
                {"AdminTPOutOfBounds", "You tried to teleport to a set of coordinates outside the map boundaries!"},
                {"AdminTPBoundaries", "X and Z values need to be between -{0} and {0} while the Y value needs to be between -100 and 2000!"},
                {"AdminTPLocation", "You teleported to {0}!"},
                {"AdminTPLocationSave", "You have saved the current location!"},
                {"AdminTPLocationRemove", "You have removed the location {0}!"},
                {"AdminLocationList", "The following locations are available:"},
                {"AdminLocationListEmpty", "You haven't saved any locations!"},
                {"AdminTPBack", "You've teleported back to your previous location!"},
                {"AdminTPBackSave", "Your previous location has been saved, use /tpb to teleport back!"},
                {"AdminTPTargetCoordinatesTarget", "{0} teleported you to {1}!"},
                {"AdminTPConsoleTP", "You were teleported to {0}"},
                {"AdminTPConsoleTPPlayer", "You were teleported to {0}"},
                {"AdminTPConsoleTPPlayerTarget", "{0} was teleported to you!"},
                {"HomeTP", "You teleported to your home '{0}'!"},
                {"HomeAdminTP", "You teleported to {0}'s home '{1}'!"},
                {"HomeIce", "You can't use home on ice!"},
                {"HomeSave", "You have saved the current location as your home!"},
                {"HomeNoFoundation", "You can only use a home location on a foundation!"},
                {"HomeFoundationNotOwned", "You can't use home on someone else's house."},
                {"HomeFoundationUnderneathFoundation", "You can't use home on a foundation that is underneath another foundation."},
                {"HomeFoundationNotFriendsOwned", "You or a friend need to own the house to use home!"},
                {"HomeRemovedInvalid", "Your home '{0}' was removed because not on a foundation or not owned!"},
                {"HighWallCollision", "High Wall Collision!"},
                {"HomeRemovedDestroyed", "Your home '{0}' was removed because it no longer exists!"},
                {"HomeRemovedInsideBlock", "Your home '{0}' was removed because inside a foundation!"},
                {"HomeRemove", "You have removed your home {0}!"},
                {"HomeDelete", "You have removed {0}'s home '{1}'!"},
                {"HomeList", "The following homes are available:"},
                {"HomeListEmpty", "You haven't saved any homes!"},
                {"HomeMaxLocations", "Unable to set your home here, you have reached the maximum of {0} homes!"},
                {"HomeQuota", "You have set {0} of the maximum {1} homes!"},
                {"HomeTugboatNotAllowed", "You are not allowed to sethome on tugboats."},
                {"HomeTPStarted", "Teleporting to your home {0} in {1} seconds!"},
                {"PayToTown", "Standard payment of {0} applies to all {1} teleports!"},
                {"PayToTPR", "Standard payment of {0} applies to all tprs!"},
                {"HomeTPCooldown", "Your teleport is currently on cooldown. You'll have to wait {0} for your next teleport."},
                {"HomeTPCooldownBypass", "Your teleport was currently on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"HomeTPCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds - {0} - to bypass."},
                {"HomeTPCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"HomeTPCooldownBypassP2", "Type /home NAME {0}." },
                {"HomeTPLimitReached", "You have reached the daily limit of {0} teleports today!"},
                {"HomeTPAmount", "You have {0} home teleports left today!"},
                {"HomesListWiped", "You have wiped all the saved home locations!"},
                {"HomeTPBuildingBlocked", "You can't set your home if you are not allowed to build in this zone!"},
                {"HomeTPSwimming", "You can't set your home while swimming!"},
                {"HomeTPCrafting", "You can't set your home while crafting!"},
                {"Request", "You've requested a teleport to {0}!"},
                {"RequestUI", "<size=14><color=#FFA500>TP Request:\n</color> {0}</size>"},
                {"RequestTarget", "{0} requested to be teleported to you! Use '/tpa' to accept!"},
                {"RequestTargetOff", "Your request has been cancelled as the target is offline now." },
                {"RequestAccept", "<size=12>Accept</size>" },
                {"RequestReject", "<size=12>Reject</size>" },
                {"TPR_NoClan_NoFriend_NoTeam", "This command is only available to friends or teammates or clanmates!"},
                {"PendingRequest", "You already have a request pending, cancel that request or wait until it gets accepted or times out!"},
                {"PendingRequestTarget", "The player you wish to teleport to already has a pending request, try again later!"},
                {"NoPendingRequest", "You have no pending teleport request!"},
                {"Accept", "{0} has accepted your teleport request! Teleporting in {1} seconds!"},
                {"AcceptTarget", "You've accepted the teleport request of {0}!"},
                {"AcceptToggleOff", "You've disabled automatic /tpa!"},
                {"AcceptToggleOn", "You've enabled automatic /tpa!"},
                {"NotAllowed", "You are not allowed to use this command!"},
                {"Success", "You teleported to {0}!"},
                {"SuccessTarget", "{0} teleported to you!"},
                {"BlockedTeleportTarget", "You can't teleport to user \"{0}\", they have you teleport blocked!"},
                {"Cancelled", "Your teleport request to {0} was cancelled!"},
                {"CancelledTarget", "{0} teleport request was cancelled!"},
                {"TPCancelled", "Your teleport was cancelled!"},
                {"TPCancelledTarget", "{0} cancelled teleport!"},
                {"TPYouCancelledTarget", "You cancelled {0} teleport!"},
                {"TimedOut", "{0} did not answer your request in time!"},
                {"TimedOutTarget", "You did not answer {0}'s teleport request in time!"},
                {"TargetDisconnected", "{0} has disconnected, your teleport was cancelled!"},
                {"TPRCooldown", "Your teleport requests are currently on cooldown. You'll have to wait {0} to send your next teleport request."},
                {"TPRCooldownBypass", "Your teleport request was on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"TPRCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds - {0} - to bypass."},
                {"TPRCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"TPMoney", "{0} deducted from your account!"},
                {"TPNoMoney", "You do not have {0} in any account!"},
                {"TPRCooldownBypassP2", "Type /tpr {0}." },
                {"TPRCooldownBypassP2a", "Type /tpr NAME {0}." },
                {"TPRLimitReached", "You have reached the daily limit of {0} teleport requests today!"},
                {"TPRAmount", "You have {0} teleport requests left today!"},
                {"TPRTarget", "Your target is currently not available!"},
                {"TPRNoCeiling", "You cannot teleport while your target is on a ceiling!"},
                {"TPDead", "You can't teleport while being dead!"},
                {"TPWounded", "You can't teleport while wounded!"},
                {"TPTooCold", "You're too cold to teleport!"},
                {"TPTooHot", "You're too hot to teleport!"},
                {"TPBoat", "You can't teleport while on a boat!"},
                {"TPTugboat", "You can't teleport while on a tugboat!"},
                {"TPHostile", "Can't teleport to outpost or bandit when hostile!"},
                {"TPJunkpile", "You can't teleport from a junkpile!"},
                {"HostileTimer", "Teleport available in {0} minutes."},
                {"TPMounted", "You can't teleport while seated!"},
                {"TPBuildingBlocked", "You can't teleport while in a building blocked area!"},
                {"TPAboveWater", "You can't teleport while above water!"},
                {"TPUnderWater", "You can't teleport while under water!"},
                {"TPTargetBuildingBlocked", "You can't teleport into a building blocked area!"},
                {"TPTargetInsideBlock", "You can't teleport into a foundation!"},
                {"TPTargetInsideEntity", "You can't teleport into another entity!"},
                {"TPTargetInsideRock", "You can't teleport into a rock!"},
                {"TPSwimming", "You can't teleport while swimming!"},
                {"TPCargoShip", "You can't teleport from the cargo ship!"},
                {"TPOilRig", "You can't teleport from the oil rig!"},
                {"TPExcavator", "You can't teleport from the excavator!"},
                {"TPHotAirBalloon", "You can't teleport to or from a hot air balloon!"},
                {"TPLift", "You can't teleport while in an elevator or bucket lift!"},
                {"TPBucketLift", "You can't teleport while in a bucket lift!"},
                {"TPRegLift", "You can't teleport while in an elevator!"},
                {"TPSafeZone", "You can't teleport from a safezone!"},
                {"TPFlagZone", "You can't teleport from this zone!"},
                {"TPNoEscapeBlocked", "You can't teleport while blocked!"},
                {"TPCrafting", "You can't teleport while crafting!"},
                {"TPBlockedItem", "You can't teleport while carrying: {0}!"},
                {"TPHomeSafeZoneOnly", "You can only teleport home from within a safe zone!" },
                {"TooCloseToMon", "You can't teleport so close to the {0}!"},
                {"TooCloseToCave", "You can't teleport so close to a cave!"},
                {"HomeTooCloseToCave", "You can't set home so close to a cave!"},
                {"HomeTooCloseToMon", "You can't set home so close to a monument!"},
                {"CannotTeleportFromHome", "You must leave your base to be able to teleport!"},
                {"WaitGlobalCooldown", "You must wait {0} on your global teleport cooldown!" },
                {"DM_TownTP", "You teleported to {0}!"},
                {"DM_TownTPNoLocation", "<color=yellow>{0}</color> location is currently not set!"},
                {"DM_TownTPDisabled", "<color=yellow>{0}</color> is currently disabled in config file!"},
                {"DM_TownTPLocation", "You have set the <color=yellow>{0}</color> location to {1}!"},
                {"DM_TownTPCreated", "You have created the command: <color=yellow>{0}</color>"},
                {"DM_TownTPRemoved", "You have removed the command: <color=yellow>{0}</color>"},
                {"DM_TownTPDoesNotExist", "Command does not exist: <color=yellow>{0}</color>"},
                {"DM_TownTPExists", "Command <color=yellow>{0}</color> already exists!"},
                {"DM_TownTPLocationsCleared", "You have cleared all locations for {0}!"},
                {"DM_TownTPStarted", "Teleporting to {0} in {1} seconds!"},
                {"DM_TownTPCooldown", "Your teleport is currently on cooldown. You'll have to wait {0} for your next teleport."},
                {"DM_TownTPCooldownBypass", "Your teleport request was on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"DM_TownTPCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds ({0}) to bypass."},
                {"DM_TownTPCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"DM_TownTPCooldownBypassP2", "Type <color=yellow>/{0} {1}</color>" },
                {"DM_TownTPLimitReached", "You have reached the daily limit of {0} teleports today! You'll have to wait {1} for your next teleport."},
                {"DM_TownTPAmount", "You have {0} <color=yellow>{1}</color> teleports left today!"},

                { "Days", "Days" },
                { "Hours", "Hours" },
                { "Minutes", "Minutes" },
                { "Seconds", "Seconds" },

                {"BlockedMarkerTeleport", "You have been blocked from using the marker teleport!" },
                {"BlockedAuthMarkerTeleport", "You have been TC blocked from using the marker teleport!" },
                {"Interrupted", "Your teleport was interrupted!"},
                {"InterruptedTarget", "{0}'s teleport was interrupted!"},
                {"Unlimited", "Unlimited"},
                {
                    "TPInfoGeneral", string.Join(NewLine, new[]
                    {
                        "Please specify the module you want to view the info of.",
                        "The available modules are: ",
                    })
                },
                {
                    "TPHelpGeneral", string.Join(NewLine, new[]
                    {
                        "/tpinfo - Shows limits and cooldowns.",
                        "Please specify the module you want to view the help of.",
                        "The available modules are: ",
                    })
                },
                {
                    "TPHelpadmintp", string.Join(NewLine, new[]
                    {
                        "As an admin you have access to the following commands:",
                        "/tp \"targetplayer\" - Teleports yourself to the target player.",
                        "/tp \"player\" \"targetplayer\" - Teleports the player to the target player.",
                        "/tp x y z - Teleports you to the set of coordinates.",
                        "/tpl - Shows a list of saved locations.",
                        "/tpl \"location name\" - Teleports you to a saved location.",
                        "/tpsave \"location name\" - Saves your current position as the location name.",
                        "/tpremove \"location name\" - Removes the location from your saved list.",
                        "/tpb - Teleports you back to the place where you were before teleporting.",
                        "/home radius \"radius\" - Find all homes in radius.",
                        "/home delete \"player name|id\" \"home name\" - Remove a home from a player.",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player.",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "TPHelphome", string.Join(NewLine, new[]
                    {
                        "With the following commands you can set your home location to teleport back to:",
                        "/home add \"name\" - Saves your current position as the location name.",
                        "/home list - Shows you a list of all the locations you have saved.",
                        "/home remove \"name\" - Removes the location of your saved homes.",
                        "/home \"name\" - Teleports you to the home location."
                    })
                },
                {
                    "TPHelptpr", string.Join(NewLine, new[]
                    {
                        "With these commands you can request to be teleported to a player or accept someone else's request:",
                        "/tpr \"player name\" - Sends a teleport request to the player.",
                        "/tpa - Accepts an incoming teleport request.",
                        "/tpat - Toggle automatic /tpa on incoming teleport requests.",
                        "/tpc - Cancel teleport or request."
                    })
                },
                {
                    "TPSettingsGeneral", string.Join(NewLine, new[]
                    {
                        "Please specify the module you want to view the settings of. ",
                        "The available modules are:",
                    })
                },
                {
                    "TPSettingshome", string.Join(NewLine, new[]
                    {
                        "Home System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}",
                        "Amount of saved Home locations: {2}"
                    })
                },
                {
                    "TPSettingsbandit", string.Join(NewLine, new[]
                    {
                        "Bandit System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingsoutpost", string.Join(NewLine, new[]
                    {
                        "Outpost System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingstpr", string.Join(NewLine, new[]
                    {
                        "TPR System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingstown", string.Join(NewLine, new[]
                    {
                        "Town System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingsdynamic", string.Join(NewLine, new[]
                    {
                        "{0} System has the current settings enabled:",
                        "Time between teleports: {1}",
                        "Daily amount of teleports: {2}"
                    })
                },

                {"TPT_True", "enabled"},
                {"TPT_False", "disabled"},
                {"TPT_clan", "{1} clan has been {0}."},
                {"TPT_friend", "{1} friend has been {0}."},
                {"TPT_team", "{1} team has been {0}."},
                {"NotValidTPT", "Not valid, player is not"},
                {"NotValidTPTFriend", " a friend!"},
                {"NotValidTPTTeam", " on your team!"},
                {"NotValidTPTClan", " in your clan!"},
                {"TPTInfo", "{4} auto accepts teleport requests.\n<color={5}>Green</color> = <color={5}>Enabled</color>\n<color={6}>Red</color> = <color={6}>Disabled</color>\n\n/{0} <color={1}>clan</color> - Toggle {4} for clan members/allies.\n/{0} <color={2}>team</color> - Toggle {4} for teammates.\n/{0} <color={3}>friend</color> - Toggle {4} for friends."},

                {"PlayerNotFound", "The specified player couldn't be found please try again!"},
                {"MultiplePlayers", "Found multiple players: {0}"},
                {"CantTeleportToSelf", "You can't teleport to yourself!"},
                {"CantTeleportPlayerToSelf", "You can't teleport a player to himself!"},
                {"CantTeleportPlayerToYourself", "You can't teleport a player to yourself!"},
                {"TeleportPendingTPC", "You can't initiate another teleport while you have a teleport pending! Use /tpc to cancel this."},
                {"TeleportPendingTarget", "You can't request a teleport to someone who's about to teleport!"},
                {"LocationExists", "A location with this name already exists at {0}!"},
                {"LocationExistsNearby", "A location with the name {0} already exists near this position!"},
                {"LocationNotFound", "Couldn't find a location with that name!"},
                {"NoPreviousLocationSaved", "No previous location saved!"},
                {"HomeExists", "You have already saved a home location by this name!"},
                {"HomeExistsNearby", "A home location with the name {0} already exists near this position!"},
                {"HomeNotFound", "Couldn't find your home with that name!"},
                {"InvalidCoordinates", "The coordinates you've entered are invalid!"},
                {"InvalidHelpModule", "Invalid module supplied!"},
                {"InvalidCharacter", "You have used an invalid character, please limit yourself to the letters a to z and numbers."},
                {"NotUseable", "You must wait another {0}after the wipe to use this command." },
                {
                    "SyntaxCommandTP", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tp command as follows:",
                        "/tp \"targetplayer\" - Teleports yourself to the target player.",
                        "/tp \"player\" \"targetplayer\" - Teleports the player to the target player.",
                        "/tp x y z - Teleports you to the set of coordinates.",
                        "/tp \"player\" x y z - Teleports the player to the set of coordinates."
                    })
                },
                {
                    "SyntaxCommandTPL", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpl command as follows:",
                        "/tpl - Shows a list of saved locations.",
                        "/tpl \"location name\" - Teleports you to a saved location."
                    })
                },
                {
                    "SyntaxCommandTPSave", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpsave command as follows:",
                        "/tpsave \"location name\" - Saves your current position as 'location name'."
                    })
                },
                {
                    "SyntaxCommandTPRemove", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpremove command as follows:",
                        "/tpremove \"location name\" - Removes the location with the name 'location name'."
                    })
                },
                {
                    "SyntaxCommandTPN", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpn command as follows:",
                        "/tpn \"targetplayer\" - Teleports yourself the default distance behind the target player.",
                        "/tpn \"targetplayer\" \"distance\" - Teleports you the specified distance behind the target player."
                    })
                },
                {
                    "SyntaxCommandSetHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home add command as follows:",
                        "/home add \"name\" - Saves the current location as your home with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandRemoveHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home remove command as follows:",
                        "/home remove \"name\" - Removes the home location with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home command as follows:",
                        "/home \"name\" - Teleports yourself to your home with the name 'name'.",
                        "/home \"name\" pay - Teleports yourself to your home with the name 'name', avoiding cooldown by paying for it.",
                        "/home add \"name\" - Saves the current location as your home with the name 'name'.",
                        "/home list - Shows you a list of all your saved home locations.",
                        "/home remove \"name\" - Removes the home location with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandHomeAdmin", string.Join(NewLine, new[]
                    {
                        "/home radius \"radius\" - Shows you a list of all homes in radius(10).",
                        "/home delete \"player name|id\" \"name\" - Removes the home location with the name 'name' from the player.",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player.",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "SyntaxCommandTown", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /town command as follows:",
                        "/town - Teleports yourself to town.",
                        "/town pay - Teleports yourself to town, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandTownAdmin", string.Join(NewLine, new[]
                    {
                        "/town set - Saves the current location as town.",
                    })
                },
                {
                    "SyntaxCommandOutpost", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /outpost command as follows:",
                        "/outpost - Teleports yourself to the Outpost.",
                        "/outpost pay - Teleports yourself to the Outpost, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandOutpostAdmin", string.Join(NewLine, new[]
                    {
                        "/outpost set - Saves the current location as Outpost.",
                    })
                },
                {
                    "SyntaxCommandBandit", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /bandit command as follows:",
                        "/bandit - Teleports yourself to the Bandit Town.",
                        "/bandit pay - Teleports yourself to the Bandit Town, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandBanditAdmin", string.Join(NewLine, new[]
                    {
                        "/bandit set - Saves the current location as Bandit Town.",
                    })
                },
                {
                    "SyntaxCommandHomeDelete", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home delete command as follows:",
                        "/home delete \"player name|id\" \"name\" - Removes the home location with the name 'name' from the player."
                    })
                },
                {
                    "SyntaxCommandHomeAdminTP", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home tp command as follows:",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player."
                    })
                },
                {
                    "SyntaxCommandHomeHomes", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home homes command as follows:",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "SyntaxCommandListHomes", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home list command as follows:",
                        "/home list - Shows you a list of all your saved home locations."
                    })
                },
                {
                    "SyntaxCommandTPR", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpr command as follows:",
                        "/tpr \"player name\" - Sends out a teleport request to 'player name'."
                    })
                },
                {
                    "SyntaxCommandTPA", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpa command as follows:",
                        "/tpa - Accepts an incoming teleport request."
                    })
                },
                {
                    "SyntaxCommandTPC", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpc command as follows:",
                        "/tpc - Cancels an teleport request."
                    })
                },
                {
                    "SyntaxConsoleCommandToPos", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the teleport.topos console command as follows:",
                        " > teleport.topos \"player\" x y z"
                    })
                },
                {
                    "SyntaxConsoleCommandToPlayer", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the teleport.toplayer console command as follows:",
                        " > teleport.toplayer \"player\" \"target player\""
                    })
                },
                {"LogTeleport", "{0} teleported to {1}."},
                {"LogTeleportPlayer", "{0} teleported {1} to {2}."},
                {"LogTeleportBack", "{0} teleported back to previous location."},
                {"DiscordLogTPA", "{0} and {1} accepted TPA {2} times"}
            };

            foreach (var key in config.DynamicCommands.Keys)
            {
                en[key] = key;
            }

            foreach (var key in monumentMessages)
            {
                en[key] = key;
            }

            lang.RegisterMessages(en, this, "en");

            var ru = new Dictionary<string, string>
            {
                {"ErrorTPR", "Телепорт к {0} блокирован ({1})"},
                {"AdminTP", "Вы телепортированы к {0}!"},
                {"AdminTPTarget", "{0} телепортировал вас!"},
                {"AdminTPPlayers", "Вы телепортировали {0} к {1}!"},
                {"AdminTPPlayer", "{0} телепортировал вас к {1}!"},
                {"AdminTPPlayerTarget", "{0} телепортировал {1} к вам!"},
                {"AdminTPCoordinates", "Вы телепортированы к {0}!"},
                {"AdminTPTargetCoordinates", "Вы телепортировали {0} к {1}!"},
                {"AdminTPOutOfBounds", "Вы пытались телепортироваться к координатам вне границ карты!"},
                {"AdminTPBoundaries", "Значения X и Z должны быть между -{0} и {0}, а значение Y между -100 и 2000!"},
                {"AdminTPLocation", "Вы телепортированы к {0}!"},
                {"AdminTPLocationSave", "Вы сохранили текущее местоположение!"},
                {"AdminTPLocationRemove", "Вы удалили местоположение {0}!"},
                {"AdminLocationList", "Доступны следующие местоположения:"},
                {"AdminLocationListEmpty", "Вы не сохранили никаких местоположений!"},
                {"AdminTPBack", "Вы телепортированы назад, в ваше предыдущее местоположение!"},
                {"AdminTPBackSave", "Ваше предыдущее местоположение сохранено, используйте <color=yellow>/tpb</color>, чтобы телепортироваться назад!"},
                {"AdminTPTargetCoordinatesTarget", "{0} телепортировал вас к {1}!"},
                {"AdminTPConsoleTP", "Вы были телепортированы к {0}"},
                {"AdminTPConsoleTPPlayer", "Вы были телепортированы к {0}"},
                {"AdminTPConsoleTPPlayerTarget", "{0} был телепортирован к вам!"},
                {"HomeTP", "Вы телепортированы в ваш дом '{0}'!"},
                {"HomeAdminTP", "Вы телепортированы к дому '{1}' принадлежащему {0}!"},
                {"HomeIce", "Дома на замерзшем озере запрещены!"},
                {"HomeSave", "Вы сохранили текущее местоположение как ваш дом!"},
                {"HomeNoFoundation", "Использовать местоположение в качестве дома разрешено только на фундаменте!"},
                {"HomeFoundationNotOwned", "Вы не можете использовать команду home в чужом доме."},
                {"HomeFoundationUnderneathFoundation", "Вы не можете использовать команду home на фундаменте, который находится под другим фундаментом."},
                {"HomeFoundationNotFriendsOwned", "Вы, или ваш друг, должны быть владельцем дома, чтобы использовать команду home!"},
                {"HomeRemovedInvalid", "Ваш дом '{0}' был удалён потому, что не на фундаменте, или у фундамента новый владелец!"},
                {"HighWallCollision", "Столкновение Высоких Стен!"},
                {"HomeRemovedDestroyed", "Ваш дом '{0}' удален, так как его больше не существует!"},
                {"HomeRemovedInsideBlock", "Ваш дом '{0}' был удалён потому, что внутри фундамента!"},
                {"HomeRemove", "Вы удалили свой дом {0}!"},
                {"HomeDelete", "Вы удалили дом '{1}' принадлежащий {0}!"},
                {"HomeList", "Доступны следующие дома:"},
                {"HomeListEmpty", "Вы не сохранили ни одного дома!"},
                {"HomeMaxLocations", "Невозможно установить здесь ваш дом, вы достигли лимита в {0} домов!"},
                {"HomeQuota", "Вы установили {0} из {1} максимально возможных домов!"},
                {"HomeTugboatNotAllowed", "Установка дома на буксирах запрещена!"},
                {"HomeTPStarted", "Телепортация в ваш дом {0} через {1} секунд!"},
                {"PayToTown", "Стандартный платеж {0} распространяется на все телепорты в город!"},
                {"PayToTPR", "Стандартный платеж {0} распространяется на все tpr'ы!"},
                {"HomeTPCooldown", "Ваш телепорт перезаряжается. Вам необходимо подождать {0} до следующей телепортации."},
                {"HomeTPCooldownBypass", "Ваш телепорт был на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"HomeTPCooldownBypassF", "Ваш телепорт перезаряжается. У вас недостаточно средств - {0} - чтобы избежать ожидания."},
                {"HomeTPCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"HomeTPCooldownBypassP2", "Напишите <color=yellow>/home \"название дома\" {0}</color>." },
                {"HomeTPLimitReached", "Вы исчерпали ежедневный лимит {0} телепортаций сегодня!"},
                {"HomeTPAmount", "У вас осталось {0} телепортаций домой сегодня!"},
                {"HomesListWiped", "Вы очистили все местоположения, сохранённые как дом!"},
                {"HomeTPBuildingBlocked", "Вы не можете сохранить местоположение в качестве дома, если у вас нет прав на строительство в этой зоне!"},
                {"HomeTPSwimming", "Вы не можете устанавливать местоположение а качестве дома пока плывёте!"},
                {"HomeTPCrafting", "Вы не можете устанавливать местоположение а качестве дома в процессе крафта!"},
                {"Request", "Вы запросили телепортацию к {0}!"},
                {"RequestUI", "<size=14><color=#FFA500>TP Request:\n</color> {0}</size>"},
                {"RequestTarget", "{0} запросил телепортацию к вам! Используйте <color=yellow>/tpa</color>, чтобы принять!"},
                {"RequestTargetOff", "Ваш запрос был отменен, так как цель сейчас не в сети." },
                {"RequestAccept", "<size=12>Принять</size>" },
                {"RequestReject", "<size=12>Отказаться</size>" },
                {"TPR_NoClan_NoFriend_NoTeam", "Эта команда доступна только друзьям, участникам команды или клана!"},
                {"PendingRequest", "У вас уже есть активный запрос, отмените его, ожидайте подтверждения, либо отмены по таймауту!"},
                {"PendingRequestTarget", "У игрока, к которому вы хотите телепортироваться уже есть активный запрос, попробуйте позже!"},
                {"NoPendingRequest", "У вас нет активных запросов на телепортацию!"},
                {"Accept", "{0} принял ваш запрос! Телепортация через {1} секунд!"},
                {"AcceptTarget", "Вы приняли запрос на телепортацию {0}!"},
                {"AcceptToggleOff", "Вы отключили автоматическое /tpa!"},
                {"AcceptToggleOn", "Вы включили автоматическое /tpa!"},
                {"NotAllowed", "Вам не разрешено использовать эту команду!"},
                {"Success", "Вы телепортированы к {0}!"},
                {"SuccessTarget", "{0} телепортирован к вам!"},
                {"BlockedTeleportTarget", "You can't teleport to user \"{0}\", they have you teleport blocked!"},
                {"Cancelled", "Ваш запрос на телепортацию к {0} был отменён!"},
                {"CancelledTarget", "Запрос на телепортацию {0} был отменён!"},
                {"TPCancelled", "Ваша телепортация отменена!"},
                {"TPCancelledTarget", "{0} отменил телепортацию!"},
                {"TPYouCancelledTarget", "Вы отменили телепортацию {0}!"},
                {"TimedOut", "{0} не ответил на ваш запрос во время!"},
                {"TimedOutTarget", "Вы не ответили вовремя на запрос телепортации от {0}!"},
                {"TargetDisconnected", "{0} отключился, ваша телепортация отменена!"},
                {"TPRCooldown", "Ваши запросы на телепортацию в данный момент на перезарядке. Вам необходимо подождать {0} прежде чем отправить следующий запрос."},
                {"TPRCooldownBypass", "Ваши запросы на телепортацию были на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"TPRCooldownBypassF", "Ваши запросы на телепортацию в данный момент на перезарядке. У вас недостаточно средств - {0} - чтобы избежать ожидания."},
                {"TPRCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"TPMoney", "{0} списано с вашего аккаунта!"},
                {"TPNoMoney", "У вас нет {0} ни на одном аккаунте!"},
                {"TPRCooldownBypassP2", "Напишите <color=yellow>/tpr {0}</color>." },
                {"TPRCooldownBypassP2a", "Напишите <color=yellow>/tpr \"имя игрока\" {0}</color>." },
                {"TPRLimitReached", "Вы исчерпали ежедневный лимит {0} запросов на телепортацию сегодня!"},
                {"TPRAmount", "У вас осталось {0} запросов на телепортацию на сегодня!"},
                {"TPRTarget", "Ваша цель в данный момент не доступна!"},
                {"TPRNoCeiling", "Вы не можете телепортироваться, пока ваша цель находится на потолке!"},
                {"TPDead", "Вы не можете телепортироваться, пока мертвы!"},
                {"TPWounded", "Вы не можете телепортироваться, будучи раненым!"},
                {"TPTooCold", "Вам слишком холодно для телепортации!"},
                {"TPTooHot", "Вам слишком жарко для телепортации!"},
                {"TPTugboat", "Вы не можете телепортироваться на этой лодке!"},
                {"TPBoat", "Вы не можете телепортироваться находясь на лодке!"},
                {"TPHostile", "Вы не можете телепортироваться в Город NPC или Лагерь бандитов пока враждебны!"},
                {"TPJunkpile", "Вы не можете телепортироваться с кучи мусора"},
                {"HostileTimer", "Телепорт станет доступен через {0} минут."},
                {"TPMounted", "Вы не можете телепортироваться, когда сидите!"},
                {"TPBuildingBlocked", "Вы не можете телепортироваться, находясь в зоне блокировки строительства!"},
                {"TPAboveWater", "Вы не можете телепортироваться находясь над водой!"},
                {"TPUnderWater", "Вы не можете телепортироваться под водой!"},
                {"TPTargetBuildingBlocked", "Вы не можете телепортироваться в зону, где блокировано строительство!"},
                {"TPTargetInsideBlock", "Вы не можете телепортироваться в фундамент!"},
                {"TPTargetInsideRock", "Вы не можете телепортироваться в скалу!"},
                {"TPSwimming", "Вы не можете телепортироваться, пока плывёте!"},
                {"TPCargoShip", "Вы не можете телепортироваться с грузового корабля!"},
                {"TPOilRig", "Вы не можете телепортироваться с нефтяной вышки!"},
                {"TPExcavator", "Вы не можете телепортироваться с экскаватора!"},
                {"TPHotAirBalloon", "Вы не можете телепортироваться с, или на воздушный шар!"},
                {"TPLift", "Вы не можете телепортироваться находясь в лифте или подъемнике!"},
                {"TPBucketLift", "Вы не можете телепортироваться находясь в ковшевом подъемнике!"},
                {"TPRegLift", "Вы не можете телепортироваться находясь в лифте!"},
                {"TPSafeZone", "Вы не можете телепортироваться из безопасной зоны!"},
                {"TPFlagZone", "Вы не можете телепортироваться из этой зоны!"},
                {"TPNoEscapeBlocked", "Вы не можете телепортироваться пока активна блокировка!"},
                {"TPCrafting", "Вы не можете телепортироваться в процессе крафта!"},
                {"TPBlockedItem", "Вы не можете телепортироваться пока несёте: {0}!"},
                {"TooCloseToMon", "Вы не можете телепортироваться так близко к {0}!"},
                {"TPHomeSafeZoneOnly", "Вы можете телепортироваться домой только из безопасной зоны!" },
                {"TooCloseToCave", "Вы не можете телепортироваться так близко к пещере!"},
                {"HomeTooCloseToCave", "Вы не можете сохранить местоположение в качестве дома так близко к пещере!"},
                {"HomeTooCloseToMon", "Вы не можете сохранить местоположение в качестве дома так близко к монументу!"},
                {"CannotTeleportFromHome", "Вы должны выйти из вашей базы, прежде чем телепортироваться!"},
                {"WaitGlobalCooldown", "Вы должны подождать {0}, пока ваш глобальный телепорт перезаряжается!" },

                {"DM_TownTP", "Вы телепортированы в {0}!"},
                {"DM_TownTPNoLocation", "Местоположение <color=yellow>{0}</color> в данный момент не установлено!"},
                {"DM_TownTPDisabled", "<color=yellow>{0}</color> в данный момент отключен в файле настройек!"},
                {"DM_TownTPLocation", "Вы установили местоположение <color=yellow>{0}</color> в {1}!"},
                {"DM_TownTPCreated", "Вы создали команду: <color=yellow>{0}</color>"},
                {"DM_TownTPRemoved", "Вы удалили команду: <color=yellow>{0}</color>"},
                {"DM_TownTPDoesNotExist", "Команда не существует: <color=yellow>{0}</color>"},
                {"DM_TownTPExists", "Команда <color=yellow>{0}</color> уже сущуствует!"},
                {"DM_TownTPLocationsCleared", "Вы стерли все точки телепорта для {0}!"},
                {"DM_TownTPStarted", "Телепортация в {0} через {1} секунд!"},
                {"DM_TownTPCooldown", "Ваш телепорт перезаряжается. Вам необходимо подождать {0} до следующей телепортации."},
                {"DM_TownTPCooldownBypass", "Ваш телепорт был на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"DM_TownTPCooldownBypassF", "Ваш телепорт перезаряжается. У вас недостаточно средств ({0}) чтобы избежать ожидания."},
                {"DM_TownTPCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"DM_TownTPCooldownBypassP2", "Введите <color=yellow>/{0} {1}</color>" },
                {"DM_TownTPLimitReached", "Вы исчерпали ежедневный лимит {0} телепортаций сегодня! Вам необходимо подождать {1} до следующей телепортации."},
                {"DM_TownTPAmount", "У вас осталось {0} телепортаций <color=yellow>{1}</color> сегодня!"},

                {"Days", "дней" },
                {"Hours", "часов" },
                {"Minutes", "минут" },
                {"Seconds", "секунд" },

                {"BlockedMarkerTeleport", "Вам заблокировано использование маркера телепортации!" },
                {"BlockedAuthMarkerTeleport", "Вам заблокировано использование маркера телепортации! (TC)" },
                {"Interrupted", "Ваша телепортация была прервана!"},
                {"InterruptedTarget", "Телепортация {0} была прервана!"},
                {"Unlimited", "Не ограничено"},
                {
                    "TPInfoGeneral", string.Join(NewLine, new[]
                    {
                        "Пожалуйста, укажите модуль, о котором вы хотите просмотреть информацию.",
                        "Доступные модули: ",
                    })
                },
                {
                    "TPHelpGeneral", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/tpinfo</color> - Отображает лимиты и перезарядки.",
                        "Пожалуйста, укажите модуль, по которому вы хотите получить помощь.",
                        "Доступные модули: ",
                    })
                },
                {
                    "TPHelpadmintp", string.Join(NewLine, new[]
                    {
                        "Как админ, вы имеете доступ к следующим командам:",
                        "<color=yellow>/tp \"имя игрока\"</color> - Телепортирует вас к указанному игроку.",
                        "<color=yellow>/tp \"имя игрока\" \"имя игрока 2\"</color> - Телепортирует игрока с именем 'имя игрока' к игроку 'имя игрока 2'.",
                        "<color=yellow>/tp x y z</color> - Телепортирует вас к указанным координатам.",
                        "<color=yellow>/tpl</color> - Отображает список сохранённых местоположений.",
                        "<color=yellow>/tpl \"название местоположения\"</color> - Телепортирует вас в сохранённое местоположение.",
                        "<color=yellow>/tpsave \"название местоположения\"</color> - Сохраняет ваше текущее местоположение с указанным названием.",
                        "<color=yellow>/tpremove \"название местоположения\"</color> - Удаляет местоположение из списка сохранённых.",
                        "<color=yellow>/tpb</color> - Телепортирует вас назад на место, где вы были перед телепортацией.",
                        "<color=yellow>/home radius \"радиус\"</color> - Найти все дома в радиусе.",
                        "<color=yellow>/home delete \"имя игрока или ID\" \"название дома\"</color> - Удаляет дом с указанным именем принадлежащий указанному игроку.",
                        "<color=yellow>/home tp \"имя игрока или ID\" \"название дома\"</color> - Телепортирует вас в дом игрока с указанным названием принадлежащий указанному игроку.",
                        "<color=yellow>/home homes \"имя игрока или ID\"</color> - Отображает вам список всех домов, принадлежащих указанному игроку."
                    })
                },
                {
                    "TPHelphome", string.Join(NewLine, new[]
                    {
                        "Используя следующие команды, вы можете установить местоположение вашего дома, чтобы затем в него телепортироваться:",
                        "<color=yellow>/home add \"название дома\"</color> - Сохраняет ваше текущее местоположение как ваш дом с указанным названием.",
                        "<color=yellow>/home list</color> - Отображает список всех местоположений, сохранённых вами как дом.",
                        "<color=yellow>/home remove \"название дома\"</color> - Удаляет расположение сохранённого дома с указанным названием.",
                        "<color=yellow>/home \"название дома\"</color> - Телепортирует вас в местоположение дома с указанным названием."
                    })
                },
                {
                    "TPHelptpr", string.Join(NewLine, new[]
                    {
                        "Используя эти команды, вы можете отправить запрос на телепортацию к игроку, или принять чей-то запрос:",
                        "<color=yellow>/tpr \"имя игрока\"</color> - Отправляет запрос на телепортацию игроку с указанным именем.",
                        "<color=yellow>/tpa</color> - Принять входящий запрос на телепортацию.",
                        "<color=yellow>/tpat</color> - Вкл./Выкл. автоматическое принятие входящих запросов на телепортацию к вам /tpa.",
                        "<color=yellow>/tpc</color> - Отменить запрос на телепортацию."
                    })
                },
                {
                    "TPSettingsGeneral", string.Join(NewLine, new[]
                    {
                        "Пожалуйста, укажите модуль, настройки которого вы хотите просмотреть. ",
                        "Доступные модули:",
                    })
                },
                {
                    "TPSettingshome", string.Join(NewLine, new[]
                    {
                        "Система домов в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}",
                        "Количество сохранённых домов: {2}"
                    })
                },
                {
                    "TPSettingsbandit", string.Join(NewLine, new[]
                    {
                        "Система Лагерь бандитов в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingsoutpost", string.Join(NewLine, new[]
                    {
                        "Система Город NPC в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingstpr", string.Join(NewLine, new[]
                    {
                        "Система TPR в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingstown", string.Join(NewLine, new[]
                    {
                        "В Системе Городов включены следующие параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingsdynamic", string.Join(NewLine, new[]
                    {
                        "В Системе {0} включены следующие параметры:",
                        "Время между телепортами: {1}",
                        "Ежедневный лимит телепортаций: {2}"
                    })
                },

                {"TPT_True", "включено"},
                {"TPT_False", "выключено"},
                {"TPT_clan", "{1} clan теперь {0}."},
                {"TPT_friend", "{1} friend теперь {0}."},
                {"TPT_team", "{1} team теперь {0}."},
                {"NotValidTPT", "Неверно, игрок не"},
                {"NotValidTPTFriend", " друг!"},
                {"NotValidTPTTeam", " в вашей команде!"},
                {"NotValidTPTClan", " в вашем клане!"},

                {"TPTInfo", "{4} это авто-принятие запросов на телепортацию.\n<color={5}>Зелёный</color> = <color={5}>Включено</color>\n<color={6}>Красный</color> = <color={6}>Выключено</color>\n\n/{0} <color={1}>clan</color> - Включение/выключение {4} для членов клана или союзников.\n/{0} <color={2}>team</color> - Включение/выключение {4} для членов группы.\n/{0} <color={3}>friend</color> - Включение/выключение {4} для друзей."},
                {"PlayerNotFound", "Указанный игрок не обнаружен, пожалуйста попробуйте ещё раз!"},
                {"MultiplePlayers", "Найдено несколько игроков: {0}"},
                {"CantTeleportToSelf", "Вы не можете телепортироваться к самому себе!"},
                {"CantTeleportPlayerToSelf", "Вы не можете телепортровать игрока к самому себе!"},
                {"TeleportPendingTPC", "Вы не можете инициировать телепортацию, пока у вас есть активный запрос! Используйте <color=yellow>/tpc</color> чтобы отменить его."},
                {"TeleportPendingTarget", "Вы не можете отправить запрос к тому, кто в процессе телепортации!"},
                {"LocationExists", "Местоположение с таким названием уже существует в {0}!"},
                {"LocationExistsNearby", "Местоположение с названием {0} уже существует рядом с текущей позицией!"},
                {"LocationNotFound", "Не найдено местоположение с таким названием!"},
                {"NoPreviousLocationSaved", "Предыдущее местоположение не сохранено!"},
                {"HomeExists", "Вы уже сохранили дом с таким названием!"},
                {"HomeExistsNearby", "Дом с названием {0} уже существует рядом с текущей позицией!"},
                {"HomeNotFound", "Дом с таким названием не найден!"},
                {"InvalidCoordinates", "Вы указали неверные координаты!"},
                {"InvalidHelpModule", "Указан неверный модуль!"},
                {"InvalidCharacter", "Вы использовали недопустимый символ, ограничьтесь буквами от a до z и цифрами."},
                {
                    "SyntaxCommandTP", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tp</color> возможно только следующим образом:",
                        "<color=yellow>/tp \"имя игрока\"</color> - Телепортирует вас к указанному игроку.",
                        "<color=yellow>/tp \"имя игрока\" \"имя игрока 2\"</color> - Телепортирует игрока с именем 'имя игрока' к игроку 'имя игрока 2'.",
                        "<color=yellow>/tp x y z</color> - Телепортирует вас к указанным координатам.",
                        "<color=yellow>/tp \"имя игрока\" x y z</color> - Телепортирует игрока с именем 'имя игрока' к указанным координатам."
                    })
                },
                {
                    "SyntaxCommandTPL", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpl</color> возможно только следующим образом:",
                        "<color=yellow>/tpl</color> - Отображает список сохранённых местоположений.",
                        "<color=yellow>/tpl \"название местоположения\"</color> - Телепортирует вас в место с указанным названием."
                    })
                },
                {
                    "SyntaxCommandTPSave", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpsave</color> возможно только следующим образом:",
                        "<color=yellow>/tpsave \"название местоположения\"</color> - Сохраняет ваше текущее местоположение с указанным названием."
                    })
                },
                {
                    "SyntaxCommandTPRemove", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpremove</color> возможно только следующим образом:",
                        "<color=yellow>/tpremove \"название местоположения\"</color> - Удаляет местоположение с указанным названием."
                    })
                },
                {
                    "SyntaxCommandTPN", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpn</color> возможно только следующим образом:",
                        "<color=yellow>/tpn \"имя игрока\"</color> - Телепортирует вас на расстояние по умолчанию позади игрока с указанным именем.",
                        "<color=yellow>/tpn \"имя игрока\" \"расстояние\"</color> - Телепортирует вас на указанное расстояние позади игрока с указанным именем."
                    })
                },
                {
                    "SyntaxCommandSetHome", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home add</color> возможно только следующим образом:",
                        "<color=yellow>/home add \"название\"</color> - Сохраняет ваше текущее местоположение как ваш дом с указанным названием."
                    })
                },
                {
                    "SyntaxCommandRemoveHome", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home remove</color> возможно только следующим образом:",
                        "<color=yellow>/home remove \"название\"</color> - Удаляет местоположение дома с указанным названием."
                    })
                },
                {
                    "SyntaxCommandHome", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home</color> возможно только следующим образом:",
                        "<color=yellow>/home \"название\"</color> - Телепортирует вас в ваш дом с указанным названием.",
                        "<color=yellow>/home \"название\" pay</color> - Телепортирует вас в ваш дом с указанным названием, избегая перезарядки, заплатив за это.",
                        "<color=yellow>/home add \"название\"</color> - Сохраняет ваше текущее местоположение как ваш дом с указанным названием.",
                        "<color=yellow>/home list</color> - Отображает список всех местоположений, сохранённых вами как дом.",
                        "<color=yellow>/home remove \"название\"</color> - Удаляет местоположение дома с указанным названием."
                    })
                },
                {
                    "SyntaxCommandHomeAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/home radius \"радиус\"</color> - Отображает список всех домов в радиусе(10).",
                        "<color=yellow>/home delete \"имя игрока или ID\" \"название\"</color> - Удаляет дом с указанным названием, принадлежащий указанному игроку.",
                        "<color=yellow>/home tp \"имя игрока или ID\" \"название\"</color> - Телепортирует вас в дом с указанным названием, принадлежащий указанному игроку.",
                        "<color=yellow>/home homes \"имя игрока или ID\"</color> - Отображает вам список всех домов, принадлежащих указанному игроку."
                    })
                },
                {
                    "SyntaxCommandTown", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/town</color> возможно только следующим образом:",
                        "<color=yellow>/town</color> - Телепортирует вас в Город.",
                        "<color=yellow>/town pay</color> - Телепортирует вас в Город с оплатой штрафа."
                    })
                },
                {
                    "SyntaxCommandTownAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/town set</color> - Сохраняет текущее местоположение как Город.",
                    })
                },
                {
                    "SyntaxCommandOutpost", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/outpost</color> возможно только следующим образом:",
                        "<color=yellow>/outpost</color> - Телепортирует вас в Город NPC.",
                        "<color=yellow>/outpost pay</color> - Телепортирует вас в Город NPC с оплатой штрафа."
                    })
                },
                {
                    "SyntaxCommandOutpostAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/outpost set</color> - Сохраняет текущее местоположение как Город NPC.",
                    })
                },
                {
                    "SyntaxCommandBandit", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/bandit</color> возможно только следующим образом:",
                        "<color=yellow>/bandit</color> - Телепортирует вас в Лагерь бандитов.",
                        "<color=yellow>/bandit pay</color> - Телепортирует вас в Лагерь бандитов с оплатой штрафа."
                    })
                },
                {
                    "SyntaxCommandBanditAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/bandit set</color> - Сохраняет текущее местоположение как Лагерь бандитов.",
                    })
                },
                {
                    "SyntaxCommandHomeDelete", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home delete</color> возможно только следующим образом:",
                        "<color=yellow>/home delete \"имя игрока или ID\" \"название\"</color> - Удаляет дом с указанным названием, принадлежащий указанному игроку."
                    })
                },
                {
                    "SyntaxCommandHomeAdminTP", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home tp</color> возможно только следующим образом:",
                        "<color=yellow>/home tp \"имя игрока или ID\" \"название\"</color> - Телепортирует вас в дом игрока с указанным названием, принадлежащий указанному игроку."
                    })
                },
                {
                    "SyntaxCommandHomeHomes", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home homes</color> возможно только следующим образом:",
                        "<color=yellow>/home homes \"имя игрока или ID\"</color> - Отображает вам список всех домов, принадлежащих указанному игроку."
                    })
                },
                {
                    "SyntaxCommandListHomes", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home list</color> возможно только следующим образом:",
                        "<color=yellow>/home list</color> - Отображает список всех местоположений, сохранённых вами как дом."
                    })
                },
                {
                    "SyntaxCommandTPR", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpr</color> возможно только следующим образом:",
                        "<color=yellow>/tpr \"имя игрока или ID\"</color> - Отправляет указанному игроку запрос на телепортацию."
                    })
                },
                {
                    "SyntaxCommandTPA", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpa</color> возможно только следующим образом:",
                        "<color=yellow>/tpa</color> - Принять входящий запрос на телепортацию."
                    })
                },
                {
                    "SyntaxCommandTPC", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpc</color> возможно только следующим образом:",
                        "<color=yellow>/tpc</color> - Отменить запрос на телепортацию."
                    })
                },
                {
                    "SyntaxConsoleCommandToPos", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование консольной команды <color=orange>teleport.topos</color> возможно только следующим образом:",
                        " > <color=orange>teleport.topos \"имя игрока\" x y z</color>"
                    })
                },
                {
                    "SyntaxConsoleCommandToPlayer", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование консольной команды <color=orange>teleport.toplayer</color> возможно только следующим образом:",
                        " > <color=orange>teleport.toplayer \"имя игрока или ID\" \"имя игрока 2|id 2\"</color>"
                    })
                },
                {"LogTeleport", "{0} телепортирован к {1}."},
                {"LogTeleportPlayer", "{0} телепортировал {1} к {2}."},
                {"LogTeleportBack", "{0} телепортирован назад, в предыдущее местоположение."},
                {"DiscordLogTPA", "{0} and {1} accepted TPA {2} times"}
            };

            foreach (var key in config.DynamicCommands.Keys)
            {
                ru[key] = key;
            }

            foreach (var key in monumentMessages)
            {
                ru[key] = key;
            }

            lang.RegisterMessages(ru, this, "ru");

            var uk = new Dictionary<string, string>
            {
                {"ErrorTPR", "Телепорт до {0} блоковано ({1})"},
                {"AdminTP", "Ви телепортовані до {0}!"},
                {"AdminTPTarget", "{0} телепортував вас!"},
                {"AdminTPPlayers", "Ви телепортували {0} до {1}!"},
                {"AdminTPPlayer", "{0} телепортував вас до {1}!"},
                {"AdminTPPlayerTarget", "{0} телепортував {1} до вас!"},
                {"AdminTPCoordinates", "Ви телепортовані до {0}!"},
                {"AdminTPTargetCoordinates", "Ви телепортували {0} до {1}!"},
                {"AdminTPOutOfBounds", "Ви намагалися телепортуватися до координат поза межами карти!"},
                {"AdminTPBoundaries", "Значення X та Z повинні бути між -{0} та {0}, а значення Y між -100 та 2000!"},
                {"AdminTPLocation", "Ви телепортовані до {0}!"},
                {"AdminTPLocationSave", "Ви зберегли місцезнаходження!"},
                {"AdminTPLocationRemove", "Ви видалили розташування {0}!"},
                {"AdminLocationList", "Доступні такі розташування:"},
                {"AdminLocationListEmpty", "Ви не зберегли жодних місць!"},
                {"AdminTPBack", "Ви телепортовані назад, у ваше попереднє розташування!"},
                {"AdminTPBackSave", "Ваше попереднє місце збережено, використовуйте <color=yellow>/tpb</color>, щоб телепортуватися назад!"},
                {"AdminTPTargetCoordinatesTarget", "{0} телепортував вас до {1}!"},
                {"AdminTPConsoleTP", "Ви були телепортовані до {0}"},
                {"AdminTPConsoleTPPlayer", "Ви були телепортовані до {0}"},
                {"AdminTPConsoleTPPlayerTarget", "{0} був телепортований до вас!"},
                {"HomeTP", "Ви телепортовані до вашого будинку '{0}'!"},
                {"HomeAdminTP", "Ви телепортовані до будинку '{1}', що належить {0}!"},
                {"HomeIce", "Ви не можете зберегти місце розташування як будинок на крижаному озері!"},
                {"HomeSave", "Ви зберегли поточне розташування як ваш будинок!"},
                {"HomeNoFoundation", "Використовувати місцезнаходження як будинок дозволено тільки на фундаменті!"},
                {"HomeFoundationNotOwned", "Ви не можете використовувати команду home у чужому домі."},
                {"HomeFoundationUnderneathFoundation", "Ви не можете використовувати команду home на фундаменті, що знаходиться під іншим фундаментом."},
                {"HomeFoundationNotFriendsOwned", "Ви, або ваш друг, повинні бути власником будинку, щоб використати команду home!"},
                {"HomeRemovedInvalid", "Ваш будинок '{0}' був видалений тому, що не на фундаменті або у фундаменту новий власник!"},
                {"HighWallCollision", "Зіткнення Високих Стін!"},
                {"HomeRemovedDestroyed", "Ваш будинок '{0}' видалено, оскільки він більше не існує!"},
                {"HomeRemovedInsideBlock", "Ваш будинок '{0}' був видалений, тому що всередині фундаменту!"},
                {"HomeRemove", "Ви видалили свій будинок {0}!"},
                {"HomeDelete", "Ви видалили будинок '{1}', що належить {0}!"},
                {"HomeList", "Доступні такі будинки:"},
                {"HomeListEmpty", "Ви не зберегли жодного будинку!"},
                {"HomeMaxLocations", "Неможливо встановити тут ваш будинок, ви досягли ліміту в {0} будинків!"},
                {"HomeQuota", "Ви встановили {0} з {1} максимально можливих будинків!"},
                {"HomeTugboatNotAllowed", "You are not allowed to sethome on tugboats."},
                {"HomeTPStarted", "Телепортація до вашого будинку {0} через {1} секунд!"},
                {"PayToTown", "Стандартний платіж {0} поширюється на всі телепорти до міста!"},
                {"PayToTPR", "Стандартний платіж {0} поширюється на всі tpr'и!"},
                {"HomeTPCooldown", "Ваш телепорт перезаряджається. Вам необхідно почекати {0} до наступної телепортації."},
                {"HomeTPCooldownBypass", "Ваш телепорт був на перезарядженні. Ви обрали уникнути очікування, сплативши {0} з вашого балансу."},
                {"HomeTPCooldownBypassF", "Ваш телепорт перезаряджається. У вас недостатньо коштів - щоб уникнути очікування."},
                {"HomeTPCooldownBypassP", "Ви можете вибрати оплатити {0} щоб уникнути очікування перезаряджання." },
                {"HomeTPCooldownBypassP2", "Введіть <color=yellow>/home \"назва будинку\" {0}</color>." },
                {"HomeTPLimitReached", "Ви вичерпали щоденний ліміт {0} телепортацій сьогодні!"},
                {"HomeTPAmount", "У вас залишилось {0} телепортацій додому сьогодні!"},
                {"HomesListWiped", "Ви очистили всі місця, збережені як будинок!"},
                {"HomeTPBuildingBlocked", "Ви не можете зберегти місце розташування як будинок, якщо у вас немає прав на будівництво в цій зоні!"},
                {"HomeTPSwimming", "Ви не можете встановлювати місце розташування в якості будинку поки пливете!"},
                {"HomeTPCrafting", "Ви не можете встановлювати місце розташування як будинок в процесі крафту!"},
                {"Request", "Ви запросили телепортацію до {0}!"},
                {"RequestUI", "<size=14><color=#FFA500>TP Request:</color> {0}</size>"},
                {"RequestTarget", "{0} запросив телепортацію до вас! Використовуйте <color=yellow>/tpa</color>, щоб прийняти!"},
                {"RequestTargetOff", "Ваш запит було скасовано, оскільки ціль зараз не в мережі." },
                {"RequestAccept", "<size=12>Принять</size>" },
                {"RequestReject", "<size=12>Отказаться</size>" },
                {"TPR_NoClan_NoFriend_NoTeam", "Ця команда доступна лише друзям, учасникам команди або клану!"},
                {"PendingRequest", "У вас вже є активний запит, скасуйте його, чекайте на підтвердження, або скасування по таймууту!"},
                {"PendingRequestTarget", "У гравця, до якого ви хочете телепортуватися, вже є активний запит, спробуйте пізніше!"},
                {"NoPendingRequest", "Ви не маєте активних запитів на телепортацію!"},
                {"Accept", "{0} прийняв ваш запит! Телепортація через {1} секунд!"},
                {"AcceptTarget", "Ви отримали запит на телепортацію {0}!"},
                {"AcceptToggleOff", "Ви вимкнули автоматичне /tpa!"},
                {"AcceptToggleOn", "Ви ввімкнули автоматичне /tpa!"},
                {"NotAllowed", "Ви не можете використовувати цю команду!"},
                {"Success", "Ви телепортовані до {0}!"},
                {"SuccessTarget", "{0} телепортований до вас!"},
                {"BlockedTeleportTarget", "You can't teleport to user \"{0}\", they have you teleport blocked!"},
                {"Cancelled", "Ваш запит на телепортацію до {0} було скасовано!"},
                {"CancelledTarget", "Запит на телепортацію {0} було скасовано!"},
                {"TPCancelled", "Ваш телепорт скасовано!"},
                {"TPCancelledTarget", "{0} скасував телепортацію!"},
                {"TPYouCancelledTarget", "Ви скасували телепортацію {0}!"},
                {"TimedOut", "{0} не відповів на ваш запит під час!"},
                {"TimedOutTarget", "Ви не вчасно відповіли на запит телепортації від {0}!"},
                {"TargetDisconnected", "{0} відключився, ваша телепортація скасована!"},
                {"TPRCooldown", "Ваші запити на телепортацію на даний момент на перезарядці. Вам необхідно зачекати на {0}, перш ніж надіслати наступний запит."},
                {"TPRCooldownBypass", "Ваші запити на телепортацію були перезаряджені. Ви обрали уникнути очікування, сплативши {0} з вашого балансу."},
                {"TPRCooldownBypassF", "Ваші запити на телепортацію на даний момент на перезарядці. У вас недостатньо коштів - щоб уникнути очікування."},
                {"TPRCooldownBypassP", "Ви можете вибрати оплатити {0} щоб уникнути очікування перезаряджання." },
                {"TPMoney", "{0} списано з вашого облікового запису!"},
                {"TPNoMoney", "У вас немає жодного облікового запису {0}!"},
                {"TPRCooldownBypassP2", "Напишіть <color=yellow>/tpr {0}</color>." },
                {"TPRCooldownBypassP2a", "Напишіть <color=yellow>/tpr \"ім'я гравця\" {0}</color>." },
                {"TPRLimitReached", "Ви вичерпали щоденний ліміт {0} запитів на телепортацію сьогодні!"},
                {"TPRAmount", "У вас залишилось {0} запитів на телепортацію на сьогодні!"},
                {"TPRTarget", "Ваша мета зараз не доступна!"},
                {"TPRNoCeiling", "Ви не можете телепортуватися, поки ваша ціль знаходиться на стелі!"},
                {"TPDead", "Ви не можете телепортуватися, поки мертві!"},
                {"TPWounded", "Ви не можете телепортуватися, будучи пораненим!"},
                {"TPTooCold", "Вам надто холодно для телепортації!"},
                {"TPTooHot", "Вам дуже жарко для телепортації!"},
                {"TPTugboat", "Вы не можете телепортироваться на этой лодке!"},
                {"TPBoat", "Ви не можете телепортуватися, перебуваючи на човні!"},
                {"TPHostile", "Ви не можете телепортуватися в Місто NPC або Табір бандитів, поки ворожі!"},
                {"TPJunkpile", "Ви не можете телепортуватися з купи сміття"},
                {"HostileTimer", "Телепорт буде доступний через {0} хвилин."},
                {"TPMounted", "Ви не можете телепортуватись, коли сидите!"},
                {"TPBuildingBlocked", "Ви не можете телепортуватися, перебуваючи у зоні блокування будівництва!"},
                {"TPAboveWater", "Ви не можете телепортуватися, перебуваючи над водою!"},
                {"TPUnderWater", "Ви не можете телепортуватися під воду!"},
                {"TPTargetBuildingBlocked", "Ви не можете телепортуватися до зони, де блоковано будівництво!"},
                {"TPTargetInsideBlock", "Ви не можете телепортуватися у фундамент!"},
                {"TPTargetInsideRock", "Ви не можете телепортуватись у скелю!"},
                {"TPSwimming", "Ви не можете телепортуватися, поки пливете!"},
                {"TPCargoShip", "Ви не можете телепортуватись з вантажного корабля!"},
                {"TPOilRig", "Ви не можете телепортуватися з нафтової вежі!"},
                {"TPExcavator", "Ви не можете телепортувати з екскаватора!"},
                {"TPHotAirBalloon", "Ви не можете телепортуватися з, або на повітряну кулю!"},
                {"TPLift", "Ви не можете телепортуватися, перебуваючи в ліфті або підйомнику!"},
                {"TPBucketLift", "Ви не можете телепортуватися, перебуваючи в ковшовому підйомнику!"},
                {"TPRegLift", "Ви не можете телепортуватися, перебуваючи в ліфті!"},
                {"TPSafeZone", "Ви не можете телепортуватися із безпечної зони!"},
                {"TPFlagZone", "Ви не можете телепортуватися із цієї зони!"},
                {"TPNoEscapeBlocked", "Ви не можете телепортуватися поки активне блокування!"},
                {"TPCrafting", "Ви не можете телепортуватись у процесі крафту!"},
                {"TPBlockedItem", "Ви не можете телепортуватися поки що несете: {0}!"},
                {"TooCloseToMon", "Ви не можете телепортуватися так близько до {0}!"},
                {"TPHomeSafeZoneOnly", "Ви можете телепортуватися додому лише з безпечної зони!" },
                {"TooCloseToCave", "Ви не можете телепортуватись так близько до печери!"},
                {"HomeTooCloseToCave", "Ви не можете зберегти розташування як будинок так близько до печери!"},
                {"HomeTooCloseToMon", "Ви не можете зберегти розташування як будинок так близько до пам'ятника!"},
                {"CannotTeleportFromHome", "Ви повинні вийти з вашої бази, перш ніж телепортувати!"},
                {"WaitGlobalCooldown", "Ви повинні почекати, поки ваш глобальний телепорт перезаряджається!" },

                {"DM_TownTP", "Ви телепортовані в {0}!"},
                {"DM_TownTPNoLocation", "Розташування <color=yellow>{0}</color> на даний момент не встановлено!"},
                {"DM_TownTPDisabled", "<color=yellow>{0}</color> в даний момент вимкнено у файлі налаштувань!"},
                {"DM_TownTPLocation", "Ви встановили розташування <color=yellow>{0}</color> в {1}!"},
                {"DM_TownTPCreated", "Ви створили команду: <color=yellow>{0}</color>"},
                {"DM_TownTPRemoved", "Ви видалили команду: <color=yellow>{0}</color>"},
                {"DM_TownTPDoesNotExist", "Команда не існує: <color=yellow>{0}</color>"},
                {"DM_TownTPExists", "Команда <color=yellow>{0}</color> вже існує!"},
                {"DM_TownTPLocationsCleared", "Ви очистили всі місця для {0}!"},
                {"DM_TownTPStarted", "Телепортація в {0} через {1} секунд!"},
                {"DM_TownTPCooldown", "Ваш телепорт перезаряджається. Вам необхідно почекати {0} до наступної телепортації."},
                {"DM_TownTPCooldownBypass", "Ваш телепорт був на перезарядженні. Ви обрали уникнути очікування, сплативши {0} з вашого балансу."},
                {"DM_TownTPCooldownBypassF", "Ваш телепорт перезаряджається. У вас недостатньо коштів ({0}), щоб уникнути очікування."},
                {"DM_TownTPCooldownBypassP", "Ви можете вибрати оплатити {0} щоб уникнути очікування перезаряджання." },
                {"DM_TownTPCooldownBypassP2", "Введіть <color=yellow>/{0} {1}</color>" },
                {"DM_TownTPLimitReached", "Ви вичерпали щоденний ліміт {0} телепортацій сьогодні! Ви повинні почекати {1} до наступної телепортації."},
                {"DM_TownTPAmount", "У вас залишилось {0} телепортацій <color=yellow>{1}</color> сьогодні!"},

                {"Days", "днів" },
                {"Hours", "годин" },
                {"Minutes", "хвилин" },
                {"Seconds", "секунд" },

                {"BlockedMarkerTeleport", "Вам заблоковано використання маркера телепортації!" },
                {"BlockedAuthMarkerTeleport", "Вам заблоковано використання маркера телепортації! (TC)" },
                {"Interrupted", "Вашу телепортацію було перервано!"},
                {"InterruptedTarget", "Телепортація {0} була перервана!"},
                {"Unlimited", "Не обмежено"},
                {
                    "TPInfoGeneral", string.Join(NewLine, new[]
                    {
                        "Будь ласка, вкажіть модуль, про який ви хочете переглянути інформацію.",
                        "Доступні модулі: ",
                    })
                },
                {
                    "TPHelpGeneral", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/tpinfo</color> - Відображає ліміти та перезарядження.",
                        "Будь ласка, вкажіть модуль, за яким ви хочете отримати допомогу.",
                        "Доступні модулі: ",
                    })
                },
                {
                    "TPHelpadmintp", string.Join(NewLine, new[]
                    {
                        "Як адмін, ви маєте доступ до наступних команд:",
                        "<color=yellow>/tp \"ім'я гравця\"</color> - Телепортує вас до вказаного гравця.",
                        "<color=yellow>/tp \"ім'я гравця\" \"ім'я гравця 2\"</color> - Телепортує гравця з ім'ям 'ім'я гравця' до гравця 'ім'я гравця 2'.",
                        "<color=yellow>/tp x y z</color> - Телепортує вас до зазначених координат.",
                        "<color=yellow>/tpl</color> - Відображає список збережених позицій.",
                        "<color=yellow>/tpl \"назва розташування\"</color> - Телепортує вас у збережене місцезнаходження.",
                        "<color=yellow>/tpsave \"назва розташування\"</color> - Зберігає ваше поточне розташування з вказаною назвою.",
                        "<color=yellow>/tpremove \"назва розташування\"</color> - Видаляє розташування зі списку збережених.",
                        "<color=yellow>/tpb</color> - Телепортує вас назад на місце, де ви були перед телепортацією.",
                        "<color=yellow>/home radius \"радіус\"</color> - Знайти всі будинки в радіусі.",
                        "<color=yellow>/home delete \"ім'я гравця або ID\" \"назва будинку\"</color> - Видаляє будинок із вказаним ім'ям, що належить вказаному гравцю.",
                        "<color=yellow>/home tp \"ім'я гравця або ID\" \"назва будинку\"</color> - Телепортує вас до будинку гравця із зазначеною назвою, що належить вказаному гравцю.",
                        "<color=yellow>/home homes \"ім'я гравця або ID\"</color> - Відображає список усіх будинків, що належать зазначеному гравцеві."
                    })
                },
                {
                    "TPHelphome", string.Join(NewLine, new[]
                    {
                        "Використовуючи наступні команди, ви можете встановити місце розташування вашого будинку, щоб потім до нього телепортуватися:",
                        "<color=yellow>/home add \"назва будинку\"</color> - Зберігає ваше поточне розташування як ваш будинок із зазначеною назвою.",
                        "<color=yellow>/home list</color> - Відображає список усіх місць розташування, збережених вами як будинок.",
                        "<color=yellow>/home remove \"назва будинку\"</color> - Видаляє розташування збереженого будинку з вказаною назвою.",
                        "<color=yellow>/home \"назва будинку\"</color> - Телепортує вас у місцезнаходження будинку з вказаною назвою."
                    })
                },
                {
                    "TPHelptpr", string.Join(NewLine, new[]
                    {
                        "Використовуючи ці команди, ви можете надіслати запит на телепортацію до гравця або прийняти чийсь запит:",
                        "<color=yellow>/tpr \"ім'я гравця\"</color> - Надсилає запит на телепортацію гравцю із зазначеним ім'ям.",
                        "<color=yellow>/tpa</color> - Прийняти запит на телепортацію.",
                        "<color=yellow>/tpat</color> - Увімк./Вимк. автоматичне прийняття запитів на телепортацію до вас /tpa.",
                        "<color=yellow>/tpc</color> - Скасувати запит на телепортацію."
                    })
                },
                {
                    "TPSettingsGeneral", string.Join(NewLine, new[]
                    {
                        "Будь ласка, вкажіть модуль, налаштування якого потрібно переглянути.",
                        "Доступні модулі:",
                    })
                },
                {
                    "TPSettingshome", string.Join(NewLine, new[]
                    {
                        "Система будинків на даний момент має такі включені параметри:",
                        "Час між телепортами: {0}",
                        "Щоденний ліміт телепортацій: {1}",
                        "Кількість збережених будинків: {2}"
                    })
                },
                {
                    "TPSettingsbandit", string.Join(NewLine, new[]
                    {
                        "Система Табір бандитів наразі має такі включені параметри:",
                        "Час між телепортами: {0}",
                        "Щоденний ліміт телепортацій: {1}"
                    })
                },
                {
                    "TPSettingsoutpost", string.Join(NewLine, new[]
                    {
                        "Система Місто NPC в даний момент має наступні параметри:",
                        "Час між телепортами: {0}",
                        "Щоденний ліміт телепортацій: {1}"
                    })
                },
                {
                    "TPSettingstpr", string.Join(NewLine, new[]
                    {
                        "Система TPR в даний момент має наступні параметри:",
                        "Час між телепортами: {0}",
                        "Щоденний ліміт телепортацій: {1}"
                    })
                },
                {
                    "TPSettingstown", string.Join(NewLine, new[]
                    {
                        "У Системі Міст включені такі параметри:",
                        "Час між телепортами: {0}",
                        "Щоденний ліміт телепортацій: {1}"
                    })
                },
                {
                    "TPSettingsdynamic", string.Join(NewLine, new[]
                    {
                        "У системі {0} включені такі параметри:",
                        "Час між телепортами: {1}",
                        "Щоденний ліміт телепортацій: {2}"
                    })
                },

                {"TPT_True", "enabled"},
                {"TPT_False", "disabled"},
                {"TPT_clan", "{1} clan has been {0}."},
                {"TPT_friend", "{1} friend has been {0}."},
                {"TPT_team", "{1} team has been {0}."},
                {"NotValidTPT", "Not valid, player is not"},
                {"NotValidTPTFriend", " a friend!"},
                {"NotValidTPTTeam", " on your team!"},
                {"NotValidTPTClan", " in your clan!"},

                {"TPTInfo", "{4} auto accepts teleport requests.\n<color={5}>Green</color> = <color={5}>Enabled</color>\n<color={6}>Red</color> = <color={6}>Disabled</color>\n\n/{0} <color={1}>clan</color> - Toggle {4} for clan members/allies.\n/{0} <color={2}>team</color> - Toggle {4} for teammates.\n/{0} <color={3}>friend</color> - Toggle {4} for friends."},

                {"PlayerNotFound", "Вказаного гравця не виявлено, будь ласка, спробуйте ще раз!"},
                {"MultiplePlayers", "Знайдено декілька гравців: {0}"},
                {"CantTeleportToSelf", "Ви не можете телепортуватися до себе!"},
                {"CantTeleportPlayerToSelf", "Ви не можете телепортувати гравця до себе!"},
                {"TeleportPendingTPC", "Ви не можете ініціювати телепортацію, поки ви маєте активний запит! Використовуйте <color=yellow>/tpc</color>, щоб скасувати його."},
                {"TeleportPendingTarget", "Ви не можете надіслати запит до того, хто в процесі телепортації!"},
                {"LocationExists", "Розташування з такою назвою вже існує в {0}!"},
                {"LocationExistsNearby", "Розташування з назвою {0} вже існує поряд із поточною позицією!"},
                {"LocationNotFound", "Не знайдено місцезнаходження з такою назвою!"},
                {"NoPreviousLocationSaved", "Попереднє розташування не збережене!"},
                {"HomeExists", "Ви вже зберегли будинок із такою назвою!"},
                {"HomeExistsNearby", "Будинок з назвою {0} вже існує поряд із поточною позицією!"},
                {"HomeNotFound", "Будинок з такою назвою не знайдено!"},
                {"InvalidCoordinates", "Ви вказали неправильні координати!"},
                {"InvalidHelpModule", "Вказано неправильний модуль!"},
                {"InvalidCharacter", "Ви використовували неприпустимий символ, обмежтеся літерами від a до z та цифрами."},
                {
                    "SyntaxCommandTP", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/tp</color> можливе лише так:",
                        "<color=yellow>/tp \"ім'я гравця\"</color> - Телепортує вас до вказаного гравця.",
                        "<color=yellow>/tp \"ім'я гравця\" \"ім'я гравця 2\"</color> - Телепортує гравця з ім'ям 'ім'я гравця' до гравця 'ім'я гравця 2'.",
                        "<color=yellow>/tp x y z</color> - Телепортує вас до зазначених координат.",
                        "<color=yellow>/tp \"ім'я гравця\" x y z</color> - Телепортує гравця з ім'ям 'ім'я гравця' до зазначених координат."
                    })
                },
                {
                    "SyntaxCommandTPL", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpl</color> можливе лише так:",
                        "<color=yellow>/tpl</color> - Відображає список збережених позицій.",
                        "<color=yellow>/tpl \"назва розташування\"</color> - Телепортує вас у місце із зазначеною назвою."
                    })
                },
                {
                    "SyntaxCommandTPSave", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpsave</color> можливе лише так:",
                        "<color=yellow>/tpsave \"назва розташування\"</color> - Зберігає ваше поточне розташування з вказаною назвою."
                    })
                },
                {
                    "SyntaxCommandTPRemove", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpremove</color> можливе лише так:",
                        "<color=yellow>/tpremove \"назва розташування\"</color> - Видаляє розташування за вказаною назвою."
                    })
                },
                {
                    "SyntaxCommandTPN", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpn</color> можливе лише так:",
                        "<color=yellow>/tpn \"ім'я гравця\"</color> - Телепортує вас на відстань за замовчуванням позаду гравця із зазначеним ім'ям.",
                        "<color=yellow>/tpn \"ім'я гравця\" \"відстань\"</color> - Телепортує вас на вказану відстань позаду гравця із вказаним ім'ям."
                    })
                },
                {
                    "SyntaxCommandSetHome", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home add</color> можливе лише так:",
                        "<color=yellow>/home add \"назва\"</color> - Зберігає ваше поточне розташування як ваш будинок із зазначеною назвою."
                    })
                },
                {
                    "SyntaxCommandRemoveHome", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home remove</color> можливе лише так:",
                        "<color=yellow>/home remove \"назва\"</color> - Видаляє розташування будинку з вказаною назвою."
                    })
                },
                {
                    "SyntaxCommandHome", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home</color> можливе лише так:",
                        "<color=yellow>/home \"назва\"</color> - Телепортує вас у ваш будинок із зазначеною назвою.",
                        "<color=yellow>/home \"назва\" pay</color> - Телепортує вас у ваш будинок із зазначеною назвою, уникаючи перезарядки, заплативши за це.",
                        "<color=yellow>/home add \"назва\"</color> - Зберігає ваше поточне розташування як ваш будинок із зазначеною назвою.",
                        "<color=yellow>/home list</color> - Відображає список усіх місць розташування, збережених вами як будинок.",
                        "<color=yellow>/home remove \"назва\"</color> - Видаляє розташування будинку з вказаною назвою."
                    })
                },
                {
                    "SyntaxCommandHomeAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/home radius \"радіус\"</color> - Відображає список усіх будинків у радіусі(10).",
                        "<color=yellow>/home delete \"ім'я гравця або ID\" \"назва\"</color> - Видаляє будинок із зазначеною назвою, що належить вказаному гравцю.",
                        "<color=yellow>/home tp \"ім'я гравця або ID\" \"назва\"</color> - Телепортує вас до будинку із зазначеною назвою, що належить вказаному гравцю.",
                        "<color=yellow>/home homes \"ім'я гравця або ID\"</color> - Відображає список усіх будинків, що належать вказаному гравцю."
                    })
                },
                {
                    "SyntaxCommandTown", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/town</color> можливе лише так:",
                        "<color=yellow>/town</color> - Телепортує вас до міста.",
                        "<color=yellow>/town pay</color> - Телепортує вас до міста з оплатою штрафу."
                    })
                },
                {
                    "SyntaxCommandTownAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/town set</color> - Зберігає поточне розташування як Місто.",
                    })
                },
                {
                    "SyntaxCommandOutpost", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/outpost</color> можливе лише так:",
                        "<color=yellow>/outpost</color> - Телепортирует вас в Город NPC.",
                        "<color=yellow>/outpost pay</color> - Телепортує вас у Місто NPC з оплатою штрафу."
                    })
                },
                {
                    "SyntaxCommandOutpostAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/outpost set</color> - Зберігає поточне розташування як Місто NPC.",
                    })
                },
                {
                    "SyntaxCommandBandit", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/bandit</color> можливе лише так:",
                        "<color=yellow>/bandit</color> - Телепортує вас до Табору бандитів.",
                        "<color=yellow>/bandit pay</color> - Телепортує вас до Табору бандитів з оплатою штрафу."
                    })
                },
                {
                    "SyntaxCommandBanditAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/bandit set</color> - Зберігає поточне розташування як Табір бандитів.",
                    })
                },
                {
                    "SyntaxCommandHomeDelete", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home delete</color> можливе лише так:",
                        "<color=yellow>/home delete \"ім'я гравця або ID\" \"назва\"</color> - Видаляє будинок із зазначеною назвою, що належить вказаному гравцю."
                    })
                },
                {
                    "SyntaxCommandHomeAdminTP", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home tp</color> можливе лише так:",
                        "<color=yellow>/home tp \"ім'я гравця або ID\" \"назва\"</color> - Телепортує вас до будинку гравця із зазначеною назвою, що належить вказаному гравцю."
                    })
                },
                {
                    "SyntaxCommandHomeHomes", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home homes</color> можливе лише так:",
                        "<color=yellow>/home homes \"ім'я гравця або ID\"</color> - Відображає список усіх будинків, що належать вказаному гравцю."
                    })
                },
                {
                    "SyntaxCommandListHomes", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home list</color> можливе лише так:",
                        "<color=yellow>/home list</color> - Відображає список усіх місць розташування, збережених вами як будинок."
                    })
                },
                {
                    "SyntaxCommandTPR", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpr</color> можливе лише так:",
                        "<color=yellow>/tpr \"ім'я гравця або ID\"</color> - Надсилає вказаному гравцеві запит на телепортацію."
                    })
                },
                {
                    "SyntaxCommandTPA", string.Join(NewLine, new[]
                    {
                        "Відбулася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpa</color> можливе лише таким чином:",
                        "<color=yellow>/tpa</color> - Прийняти вхідний запит на телепортацію."
                    })
                },
                {
                    "SyntaxCommandTPC", string.Join(NewLine, new[]
                    {
                        "Відбулася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpc</color> можливе лише таким чином:",
                        "<color=yellow>/tpc</color> - Скасувати запит на телепортацію."
                    })
                },
                {
                    "SyntaxConsoleCommandToPos", string.Join(NewLine, new[]
                    {
                        "Відбулася синтаксична помилка!",
                        "Використання консольної команди <color=orange>teleport.topos</color> можливе лише таким чином:",
                        " > <color=orange>teleport.topos \"ім'я гравця\" x y z</color>"
                    })
                },
                {
                    "SyntaxConsoleCommandToPlayer", string.Join(NewLine, new[]
                    {
                        "Відбулася синтаксична помилка!",
                        "Використання консольної команди <color=orange>teleport.toplayer</color> можливе лише таким чином:",
                        " > <color=orange>teleport.toplayer \"ім'я гравця або ID\" \"ім'я гравця 2|id 2\"</color>"
                    })
                },
                {"LogTeleport", "{0} телепортовано до {1}."},
                {"LogTeleportPlayer", "{0} телепортував {1} до {2}."},
                {"LogTeleportBack", "{0} телепортований назад, до попереднього розташування."},
                {"DiscordLogTPA", "{0} and {1} accepted TPA {2} times"}
            };

            foreach (var key in config.DynamicCommands.Keys)
            {
                uk[key] = key;
            }

            foreach (var key in monumentMessages)
            {
                uk[key] = key;
            }

            lang.RegisterMessages(uk, this, "uk");
        }

        private void Init()
        {
            Unsubscribe(nameof(OnPlayerSleep));
            Unsubscribe(nameof(OnPlayerRespawn));
            Unsubscribe(nameof(OnPlayerViolation));
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(OnPlayerDisconnected));
            InitializeDynamicCommands();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player != null)
            {
                delayedTeleports.Remove(player.userID);
                GetPlayerCode(player);
            }
        }

        private string GetPlayerCode(BasePlayer player)
        {
            if (!_playerToCode.TryGetValue(player.UserIDString, out var code))
            {
                code = (player.userID % 90000 + 10000).ToString();
                _playerToCode[player.UserIDString] = code;
            }
            _codeToPlayer[code] = player;
            return code;
        }

        private Dictionary<string, StoredData> _DynamicData = new Dictionary<string, StoredData>();

        public class StoredData
        {
            public Dictionary<ulong, TeleportData> TPData = new Dictionary<ulong, TeleportData>();
            public bool Changed = true;
        }

        private void LoadDataAndPerms()
        {
            dataAdmin = GetFile("Admin");
            try { _Admin = dataAdmin.ReadObject<Dictionary<ulong, AdminData>>(); } catch (Exception ex) { Puts("Admin datafile: {0}", ex); }
            if (_Admin == null) { _Admin = new Dictionary<ulong, AdminData>(); changedAdmin = true; }

            dataHome = GetFile("Home");
            try { _Home = dataHome.ReadObject<Dictionary<ulong, HomeData>>(); } catch (Exception ex) { Puts("Home datafile: {0}", ex); }
            if (_Home == null) { _Home = new Dictionary<ulong, HomeData>(); changedHome = true; }
            if (!config.Home.AllowTugboats) _Home.Values.ToList().ForEach(homeData => { if (homeData?.boats?.Count > 0) { homeData.boats.Clear(); changedHome = true; } });

            dataTPT = GetFile("TPT");
            try { TPT = dataTPT.ReadObject<Dictionary<string, List<string>>>(); } catch { }
            if (TPT == null) { new Dictionary<string, List<string>>(); changedTPT = true; }

            foreach (var entry in config.DynamicCommands)
            {
                if (!entry.Value.Enabled) continue;

                var dcf = GetFile(entry.Key);
                Dictionary<ulong, TeleportData> data = null;

                try
                {
                    data = dcf.ReadObject<Dictionary<ulong, TeleportData>>();
                }
                catch
                {

                }

                if (data == null)
                {
                    data = new Dictionary<ulong, TeleportData>();
                }

                GetSettings(entry.Key).Teleports = _DynamicData[entry.Key] = new StoredData
                {
                    TPData = data,
                    Changed = true
                };
            }

            dataTPR = GetFile("TPR");
            try { _TPR = dataTPR.ReadObject<Dictionary<ulong, TeleportData>>(); } catch (Exception ex) { Puts("TPR: {0}", ex); }
            if (_TPR == null) { _TPR = new Dictionary<ulong, TeleportData>(); changedTPR = true; }

            dataDisabled = GetFile("DisabledCommands");
            try { DisabledCommandData = dataDisabled.ReadObject<DisabledData>(); } catch (Exception ex) { Puts("DC: {0}", ex); }
            if (DisabledCommandData == null) { DisabledCommandData = new DisabledData(); }

            permission.RegisterPermission("nteleportation.blocktpmarker", this);
            permission.RegisterPermission("nteleportation.skipwipewaittime", this);
            permission.RegisterPermission("nteleportation.locationradiusbypass", this);
            permission.RegisterPermission("nteleportation.ignoreglobalcooldown", this);
            permission.RegisterPermission("nteleportation.norestrictions", this);
            permission.RegisterPermission("nteleportation.globalcooldownvip", this);
            permission.RegisterPermission("nteleportation.tugboatsinterruptbypass", this);
            permission.RegisterPermission("nteleportation.tugboatssethomebypass", this);
            permission.RegisterPermission(PermAdmin, this);
            permission.RegisterPermission(PermFoundationCheck, this);
            permission.RegisterPermission(PermDeleteHome, this);
            permission.RegisterPermission(PermHome, this);
            permission.RegisterPermission(PermHomeHomes, this);
            permission.RegisterPermission(PermImportHomes, this);
            permission.RegisterPermission(PermRadiusHome, this);
            permission.RegisterPermission(PermDisallowTpToMe, this);
            permission.RegisterPermission(PermTp, this);
            permission.RegisterPermission(PermTpB, this);
            permission.RegisterPermission(PermTpR, this);
            permission.RegisterPermission(PermTpA, this);
            permission.RegisterPermission(PermTpConsole, this);
            permission.RegisterPermission(PermTpT, this);
            permission.RegisterPermission(PermTpN, this);
            permission.RegisterPermission(PermTpL, this);
            permission.RegisterPermission(PermTpRemove, this);
            permission.RegisterPermission(PermTpSave, this);
            permission.RegisterPermission(PermWipeHomes, this);
            permission.RegisterPermission(PermCraftHome, this);
            permission.RegisterPermission(PermCaveHome, this);
            permission.RegisterPermission(PermCraftTpR, this);
            permission.RegisterPermission(PermCaveTpR, this);
            permission.RegisterPermission(PermExempt, this);
            permission.RegisterPermission(PermTpMarker, this);

            CheckPerms(config.Home.VIPCooldowns);
            CheckPerms(config.Home.VIPCountdowns);
            CheckPerms(config.Home.VIPDailyLimits);
            CheckPerms(config.Home.VIPHomesLimits);
            CheckPerms(config.TPR.VIPCooldowns);
            CheckPerms(config.TPR.VIPCountdowns);
            CheckPerms(config.TPR.VIPDailyLimits);
            CheckPerms(config.Settings.TPB.Countdowns);

            foreach (var entry in config.DynamicCommands)
            {
                RegisterCommand(entry.Key, entry.Value, false);
            }
        }

        private bool CanBypassRestrictions(string userid) => permission.UserHasPermission(userid, "nteleportation.norestrictions");

        private void RegisterCommand(string command, string callback, string perm = null)
        {
            if (!string.IsNullOrEmpty(command) && !command.Equals("null", StringComparison.OrdinalIgnoreCase))
            {
                AddCovalenceCommand(command, callback, perm);
            }
        }

        private void UnregisterCommand(string command)
        {
            covalence.UnregisterCommand(command, this);
        }

        private void RegisterCommand(string key, TownSettings settings, bool justCreated)
        {
            CheckPerms(settings.VIPCooldowns);
            CheckPerms(settings.VIPCountdowns);
            CheckPerms(settings.VIPDailyLimits);

            string tpPerm = $"{Name}.tp{key}".ToLower();
            string craftPerm = $"{Name}.craft{key}".ToLower();
            string cavePerm = $"{Name}.cave{key}".ToLower();

            if (!permission.PermissionExists(tpPerm, this))
            {
                permission.RegisterPermission(tpPerm, this);
            }

            if (!permission.PermissionExists(craftPerm))
            {
                permission.RegisterPermission(craftPerm, this);
            }

            if (!permission.PermissionExists(cavePerm))
            {
                permission.RegisterPermission(cavePerm, this);
            }

            if (justCreated)
            {
                settings.Teleports = _DynamicData[key] = new();
            }
        }

        private DynamicConfigFile GetFile(string name)
        {
            var fileName = string.IsNullOrEmpty(config.Settings.DataFileFolder) ? $"{Name}{name}" : $"{config.Settings.DataFileFolder}{Path.DirectorySeparatorChar}{name}";
            var file = Interface.Oxide.DataFileSystem.GetFile(fileName);
            file.Settings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;
            file.Settings.Converters = new JsonConverter[] { new UnityVector3Converter(), new CustomComparerDictionaryCreationConverter<string>(StringComparer.OrdinalIgnoreCase) };
            return file;
        }

        private void SetGlobalCooldown(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "nteleportation.ignoreglobalcooldown"))
            {
                return;
            }
            if (config.Settings.GlobalVIP > 0f && permission.UserHasPermission(player.UserIDString, "nteleportation.globalcooldownvip"))
            {
                ulong userid = player.userID;
                TeleportCooldowns[userid] = Time.time + config.Settings.GlobalVIP;
                timer.Once(config.Settings.GlobalVIP, () => TeleportCooldowns.Remove(userid));
            }
            else if (config.Settings.Global > 0f)
            {
                ulong userid = player.userID;
                TeleportCooldowns[userid] = Time.time + config.Settings.Global;
                timer.Once(config.Settings.Global, () => TeleportCooldowns.Remove(userid));
            }
        }

        private float GetGlobalCooldown(BasePlayer player)
        {
            float cooldown;
            if (!TeleportCooldowns.TryGetValue(player.userID, out cooldown))
            {
                return 0f;
            }

            return cooldown - Time.time;
        }

        private bool IsEmptyMap()
        {
            foreach (var b in BuildingManager.server.buildingDictionary)
            {
                if (b.Value.HasDecayEntities() && b.Value.decayEntities.ToList().Exists(de => de != null && de.OwnerID.IsSteamId()))
                {
                    return false;
                }
            }
            return true;
        }

        private void CheckNewSave()
        {
            if (!newSave && !IsEmptyMap())
            {
                return;
            }

            bool changed = false;
            bool cleared = false;

            if (config.Settings.WipeOnUpgradeOrChange)
            {
                if (_Home.Count > 0)
                {
                    cleared = true;
                    _Home.Clear();
                    changedHome = true;
                }

                if (_TPR.Count > 0)
                {
                    cleared = true;
                    _TPR.Clear();
                    changedTPR = true;
                }

                foreach (var entry in config.DynamicCommands.ToList())
                {
                    if (entry.Value.Location != Vector3.zero || entry.Value.Locations.Count > 0)
                    {
                        entry.Value.Location = Vector3.zero;
                        entry.Value.Locations.Clear();
                        cleared = true;
                    }
                }

                if (cleared) Puts("Rust was upgraded or map changed - clearing homes and all locations!");
            }
            else
            {
                Puts("Rust was upgraded or map changed - homes, town, islands, outpost, bandit, etc may be invalid!");
            }

            foreach (var entry in config.DynamicCommands.ToList())
            {
                if (!string.IsNullOrEmpty(entry.Value.MonumentMarkerName))
                {
                    if (TrySetNewTownPosition(entry.Value))
                    {
                        changed = true;
                    }
                }
            }

            if (cleared || changed)
            {
                SaveConfig();
            }
        }

        bool TrySetNewTownPosition(TownSettings town)
        {
            foreach (var prefab in World.Serialization.world.prefabs)
            {
                if (prefab.id == 1724395471 && prefab.category == town.MonumentMarkerName)
                {
                    var pos = new Vector3(prefab.position.x, prefab.position.y, prefab.position.z);
                    try { pos += town.MonumentMarkerNameOffset.ToVector3(); } catch { }
                    if (pos.y < TerrainMeta.HeightMap.GetHeight(pos))
                    {
                        Puts("Invalid position set under the map for {0} {1}", prefab.category, pos);
                        Puts("You can specify an offset in the config to correct this:");
                        Puts("Set Position From Monument Marker Name Offset");
                        Puts("e.g: 0 15 0");
                        return false;
                    }
                    else
                    {
                        Puts($"Set {prefab.category} teleport position to: {pos}");
                        town.Locations.Clear();
                        town.Location = pos;
                        town.Locations.Add(pos);
                        return true;
                    }
                }
            }
            return false;
        }

        void OnServerInitialized()
        {
            if (config.Settings.Interrupt.Hurt || config.Settings.Interrupt.Cold || config.Settings.Interrupt.Hot)
            {
                Subscribe(nameof(OnEntityTakeDamage));
            }

            if (config.Settings.TeleportHomeSafeZone > 0f)
            {
                Subscribe(nameof(OnPlayerSleep));
            }

            if (config.Settings.RespawnOutpost)
            {
                Subscribe(nameof(OnPlayerRespawn));
            }

            Subscribe(nameof(OnPlayerSleepEnded));
            Subscribe(nameof(OnPlayerDisconnected));

            boundary = TerrainMeta.Size.x / 2;

            foreach (var item in config.Settings.BlockedItems)
            {
                var definition = ItemManager.FindItemDefinition(item.Key);
                if (definition == null)
                {
                    Puts("Blocked item not found: {0}", item.Key);
                    continue;
                }
                ReverseBlockedItems[definition.itemid] = item.Value;
            }

            LoadDataAndPerms();
            CheckNewSave();
            AddCovalenceCommands();
            foreach (var player in BasePlayer.activePlayerList) OnPlayerConnected(player);
            _cmc = ServerMgr.Instance.StartCoroutine(SetupMonuments());
        }

        private void AddCovalenceCommands()
        {
            AddCovalenceCommand("toggletpmarker", nameof(CommandBlockMapMarker));
            if (config.Settings.TPREnabled)
            {
                AddCovalenceCommand("tpr", nameof(CommandTeleportRequest));
            }
            if (config.Settings.HomesEnabled)
            {
                AddCovalenceCommand("home", nameof(CommandHome));
                AddCovalenceCommand("sethome", nameof(CommandSetHome));
                AddCovalenceCommand("listhomes", nameof(CommandListHomes));
                AddCovalenceCommand("removehome", nameof(CommandRemoveHome));
                AddCovalenceCommand("radiushome", nameof(CommandHomeRadius));
                AddCovalenceCommand("deletehome", nameof(CommandHomeDelete));
                AddCovalenceCommand("tphome", nameof(CommandHomeAdminTP));
                AddCovalenceCommand("homehomes", nameof(CommandHomeHomes));
            }
            AddCovalenceCommand("tnt", nameof(CommandToggle));
            AddCovalenceCommand("tp", nameof(CommandTeleport));
            AddCovalenceCommand("tpn", nameof(CommandTeleportNear));
            AddCovalenceCommand("tpl", nameof(CommandTeleportLocation));
            AddCovalenceCommand("tpsave", nameof(CommandSaveTeleportLocation));
            AddCovalenceCommand("tpremove", nameof(CommandRemoveTeleportLocation));
            AddCovalenceCommand("tpb", nameof(CommandTeleportBack));
            AddCovalenceCommand("tpa", nameof(CommandTeleportAccept));
            AddCovalenceCommand("tpat", nameof(CommandTeleportAcceptToggle));
            AddCovalenceCommand("tpt", nameof(CommandTeleportAcceptToggle));
            AddCovalenceCommand("atp", nameof(CommandTeleportAcceptToggle));
            AddCovalenceCommand("wipehomes", nameof(CommandWipeHomes));
            AddCovalenceCommand("tphelp", nameof(CommandTeleportHelp));
            AddCovalenceCommand("tpinfo", nameof(CommandTeleportInfo));
            AddCovalenceCommand("tpc", nameof(CommandTeleportCancel));
            AddCovalenceCommand("teleport.toplayer", nameof(CommandTeleportII));
            AddCovalenceCommand("teleport.topos", nameof(CommandTeleportII));
            AddCovalenceCommand("teleport.importhomes", nameof(CommandImportHomes));
            AddCovalenceCommand("spm", nameof(CommandSphereMonuments));
            AddCovalenceCommand("nteleportationinfo", nameof(CommandPluginInfo));
        }

        void OnNewSave(string strFilename)
        {
            newSave = true;
        }

        void OnServerSave()
        {
            if (config.Settings.SaveDelay > 0)
            {
                timer.Once((float)config.Settings.SaveDelay, SaveAllInstant);
            }
            else
            {
                SaveAllInstant();
            }
        }

        void SaveAllInstant()
        {
            SaveTeleportsAdmin();
            SaveTeleportsHome();
            SaveTeleportsTPR();
            SaveTeleportsTPT();
            SaveTeleportsTown();
        }

        void OnServerShutdown() => SaveAllInstant();

        void Unload()
        {
            SaveAllInstant();
            foreach (BasePlayer current in BasePlayer.activePlayerList)
            {
                DestroyTeleportRequestCUI(current);
            }
            if (_cmc != null)
            {
                ServerMgr.Instance.StopCoroutine(_cmc);
                _cmc = null;
            }
        }

        void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || player.IsNpc || !player.userID.IsSteamId() || hitInfo == null) return;
            if (teleporting.ContainsKey(player.userID) && (hitInfo.damageTypes.Has(DamageType.Fall) || hitInfo.damageTypes.Has(DamageType.Suicide)))
            {
                hitInfo.damageTypes = new DamageTypeList();
                RemoveProtections(player.userID);
                if (teleporting.Count == 0) Unsubscribe(nameof(OnPlayerViolation));
                return;
            }
            if (permission.UserHasPermission(player.userID.ToString(), PermExempt)) return;
            if (!TeleportTimers.TryGetValue(player.userID, out var teleportTimer)) return;
            DamageType major = hitInfo.damageTypes.GetMajorityDamageType();

            NextTick(() =>
            {
                if (player == null || !hitInfo.hasDamage) return;
                if (major == DamageType.Cold)
                {
                    if (config.Settings.Interrupt.Cold && player.metabolism.temperature.value <= config.Settings.MinimumTemp)
                    {
                        SendInterruptMessage(teleportTimer, player, "TPTooCold");
                    }
                }
                else if (major == DamageType.Heat)
                {
                    if (config.Settings.Interrupt.Hot && player.metabolism.temperature.value >= config.Settings.MaximumTemp)
                    {
                        SendInterruptMessage(teleportTimer, player, "TPTooHot");
                    }
                }
                else if (config.Settings.Interrupt.Hurt)
                {
                    SendInterruptMessage(teleportTimer, player, "Interrupted");
                }
            });
        }

        private void SendInterruptMessage(TeleportTimer teleportTimer, BasePlayer player, string key)
        {
            PrintMsgL(teleportTimer.OriginPlayer, key);
            if (teleportTimer.TargetPlayer != null)
            {
                PrintMsgL(teleportTimer.TargetPlayer, "InterruptedTarget", teleportTimer.OriginPlayer?.displayName);
            }
            teleportTimer.Timer.Destroy();
            TeleportTimers.Remove(player.userID);
            Interface.CallHook("OnTeleportInterrupted", player, teleportTimer.Home, teleportTimer.UserID, teleportTimer.Town);
        }

        object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (type == AntiHackType.InsideTerrain && teleporting.ContainsKey(player.userID))
            {
                return true;
            }

            return null;
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (player == null) return;
            delayedTeleports.Remove(player.userID);
            if (teleporting.ContainsKey(player.userID))
            {
                ulong userID = player.userID;
                timer.Once(3f, () =>
                {
                    RemoveProtections(userID);
                    if (teleporting.Count == 0) Unsubscribe(nameof(OnPlayerViolation));
                });
            }
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (player == null) return;
            if (config.Settings.TeleportHomeSafeZone > 0f)
            {
                DelayedTeleportHome(player);
            }
            if (PendingRequests.TryGetValue(player.userID, out var reqTimer))
            {
                var originPlayer = PlayersRequests[player.userID];
                if (originPlayer)
                {
                    PlayersRequests.Remove(originPlayer.userID);
                    PrintMsgL(originPlayer, "RequestTargetOff");
                }
                reqTimer.Destroy();
                PendingRequests.Remove(player.userID);
                PlayersRequests.Remove(player.userID);
            }
            if (TeleportTimers.TryGetValue(player.userID, out var teleportTimer))
            {
                teleportTimer.Timer.Destroy();
                TeleportTimers.Remove(player.userID);
            }
            RemoveProtections(player.userID);
        }

        private void SaveTeleportsAdmin()
        {
            if (_Admin == null || !changedAdmin) return;
            dataAdmin.WriteObject(_Admin);
            changedAdmin = false;
        }

        private void SaveTeleportsHome()
        {
            if (_Home == null || !changedHome) return;
            dataHome.WriteObject(_Home);
            changedHome = false;
        }

        private void SaveTeleportsTPR()
        {
            if (_TPR == null || !changedTPR) return;
            dataTPR.WriteObject(_TPR);
            changedTPR = false;
        }

        private void SaveTeleportsTPT()
        {
            if (TPT == null || !changedTPT) return;
            dataTPT.WriteObject(TPT);
            changedTPT = false;
        }

        private void SaveTeleportsTown()
        {
            foreach (var entry in _DynamicData.ToList())
            {
                if (entry.Value.Changed)
                {
                    var fileName = string.IsNullOrEmpty(config.Settings.DataFileFolder) ? $"{Name}{entry.Key}" : $"{config.Settings.DataFileFolder}{Path.DirectorySeparatorChar}{entry.Key}";
                    Interface.Oxide.DataFileSystem.WriteObject(fileName, entry.Value.TPData);
                    entry.Value.Changed = false;
                }
            }
        }

        private void SaveLocation(BasePlayer player, Vector3 position, string home, ulong uid, bool town, bool build = true, bool craft = true, bool cave = true)
        {
            if (player == null || _Admin == null || !IsAllowed(player, PermTpB)) return;
            if (!_Admin.TryGetValue(player.userID, out var adminData) || adminData == null)
                _Admin[player.userID] = adminData = new();
            adminData.PreviousLocation = position;
            adminData.BuildingBlocked = build;
            adminData.AllowCrafting = craft;
            adminData.AllowCave = cave;
            adminData.Town = town;
            adminData.Home = home;
            adminData.UserID = uid;
            changedAdmin = true;
            PrintMsgL(player, "AdminTPBackSave");
        }

        private void RemoveLocation(BasePlayer player)
        {
            if (!_Admin.TryGetValue(player.userID, out var adminData))
                return;
            adminData.PreviousLocation = Vector3.zero;
            changedAdmin = true;
        }

        private Coroutine _cmc;
        private bool _cmcCompleted;
        private List<PrefabInfo> PrefabVolumeInfo = new();

        public bool GetCustomMapPrefabRadius(Vector2 v, out float radius)
        {
            foreach (var info in PrefabVolumeInfo)
            {
                if ((v - info.positionXZ).magnitude > 1f)
                {
                    continue;
                }
                if (info.IsInBounds(v))
                {
                    radius = info.extents.Max();
                    return true;
                }
            }
            radius = 0f;
            return false;
        }

        public bool GetCustomMapPrefabName(ProtoBuf.PrefabData prefab, out string prefabName) => (prefabName = prefab.id switch
        {
            //79883367 => "assets/bundled/prefabs/modding/volumes_and_triggers/prevent_building_cylinder.prefab",
            //3073835983 => "assets/bundled/prefabs/modding/volumes_and_triggers/prevent_building_monument_cube.prefab",
            //131040489 => "assets/bundled/prefabs/modding/volumes_and_triggers/prevent_building_monument_sphere.prefab",
            //2208164178 => "assets/bundled/prefabs/modding/volumes_and_triggers/prevent_building_ramp.prefab",
            316558065u => "assets/bundled/prefabs/modding/volumes_and_triggers/safezonesphere.prefab",
            4190049974u => "assets/bundled/prefabs/modding/volumes_and_triggers/prevent_building_cube.prefab",
            3224970585u => "assets/bundled/prefabs/modding/volumes_and_triggers/prevent_building_sphere.prefab",
            _ => null
        }) != null;

        private void SetupVolumeOrTrigger(ProtoBuf.PrefabData prefab, string prefabName)
        {
            var extents = new Vector3(prefab.scale.x, prefab.scale.y, prefab.scale.z);
            if (extents.Max() <= 1f)
            {
                return;
            }
            var text = Utility.GetFileNameWithoutExtension(prefabName);
            var position = new Vector3(prefab.position.x, prefab.position.y, prefab.position.z);
            var rotation = new Quaternion(prefab.rotation.x, prefab.rotation.y, prefab.rotation.z, 0f);
            if (prefab.id == 316558065)
            {
                extents *= 2f;
            }
            PrefabVolumeInfo.Add(new PrefabInfo(position: position, rotation: rotation, extents: extents, extra: 0f, name: text, prefab: prefab.category, sphere: !text.Contains("cube")));
        }

        private IEnumerator SetupMonuments()
        {
            int checks = 0;
            foreach (var prefab in World.Serialization.world.prefabs)
            {
                if (GetCustomMapPrefabName(prefab, out var prefabName))
                {
                    SetupVolumeOrTrigger(prefab, prefabName);
                    continue;
                }
                if (prefab.id == 1724395471 && prefab.category != "IGNORE_MONUMENT" && prefab.category != "prevent_building_monument_sphere")
                {
                    yield return CalculateMonumentSize(new(prefab.position.x, prefab.position.y, prefab.position.z), new(prefab.rotation.x, prefab.rotation.y, prefab.rotation.z, 0f), default, prefab.category, "monument_marker");
                }
                if (++checks >= 1000)
                {
                    yield return CoroutineEx.waitForSeconds(0.0025f);
                    checks = 0;
                }
            }
            foreach (var monument in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                var objname = monument.name;
                if (objname.Contains("monument_marker") || objname.Contains("prevent_building_monument_sphere"))
                {
                    continue;
                }
                var position = monument.transform.position;
                var rotation = monument.transform.rotation;
                var name = monument.displayPhrase.english.Trim();
                if (name.Contains("Lake") || name.Contains("Canyon") || name.Contains("Oasis"))
                {
                    continue;
                }
                if (string.IsNullOrEmpty(name))
                {
                    if (objname.Contains("cave"))
                    {
                        name = objname.Contains("cave_small") ? "Small Cave" : objname.Contains("cave_medium") ? "Medium Cave" : "Large Cave";
                    }
                    else name = objname;
                }
                if (name.Contains('/'))
                {
                    name = Utility.GetFileNameWithoutExtension(objname);
                }
                if (name.Contains("Oil Rig"))
                {
                    boundary = Mathf.Max(boundary, monument.Distance(Vector3.zero) + 100f);
                }
                if (objname.Contains("cave"))
                {
                    name += UnityEngine.Random.Range(1000, 9999);
#if DEBUG
                    Puts($"Adding Cave: {name}, pos: {position}");
#endif
                    caves[name] = position;
                }
                else if (config.Settings.Outpost.Exists(objname.Contains))
                {
                    yield return SetupOutpost(monument);
                }
                else if (config.Settings.Bandit.Exists(objname.Contains))
                {
                    yield return SetupBandit(monument);
                }
                else
                {
                    yield return CalculateMonumentSize(position, rotation, monument.Bounds, string.IsNullOrEmpty(name) ? objname : name, objname);
                }
            }
            _cmcCompleted = true;
            _cmc = null;
        }

        private void RemoveNearBuildingBlocks(List<BaseEntity> ents)
        {
            List<Vector3> blocks = Pool.Get<List<Vector3>>();

            foreach (var ent in ents)
            {
                BuildingBlock block = ent as BuildingBlock;
                if (block != null && !block.IsDestroyed)
                {
                    blocks.Add(block.transform.position);
                }
            }

            for (int i = ents.Count - 1; i >= 0; i--)
            {
                BaseEntity entity = ents[i];

                if (entity.IsKilled())
                {
                    ents.RemoveAt(i);
                    continue;
                }

                bool shouldRemove = false;

                foreach (var blockPos in blocks)
                {
                    if (entity.Distance(blockPos) <= 3f)
                    {
                        shouldRemove = true;
                        break;
                    }
                }

                if (shouldRemove)
                {
                    ents.RemoveAt(i);
                    continue;
                }

                foreach (var other in ents)
                {
                    if (other.IsKilled() || other == entity || other is BaseChair)
                    {
                        continue;
                    }

                    if (entity.Distance(other.transform.position) <= 3f)
                    {
                        shouldRemove = true;
                        break;
                    }
                }

                if (shouldRemove)
                {
                    ents.RemoveAt(i);
                }
            }

            blocks.ResetToPool();
        }

        private IEnumerator SetupOutpost(PrefabInfo mi)
        {
            var outpost = GetSettings("outpost");

            if (outpost == null)
            {
                outpostEnabled = false;
                yield break;
            }

            var radius = mi.extents.Max();

            if (config.Settings.AutoGenOutpost && outpost.Location != Vector3.zero && outpost.Locations.Exists(a => OutOfRange(mi.position, a, radius, config.Settings.AutoGenOutpost)))
            {
#if DEBUG
                Puts("Invalid Outpost location detected");
#endif
                outpost.Location = Vector3.zero;
                outpost.Locations = new List<Vector3>();
            }
            if (config.Settings.AutoGenOutpost && outpost.Location == Vector3.zero)
            {
#if DEBUG
                Puts("  Looking for Outpost target");
#endif
                bool changedOutpost = false;
                var ents = Pool.Get<List<BaseEntity>>();
                Vis.Entities(mi.position, radius, ents);
                RemoveNearBuildingBlocks(ents);
                foreach (BaseEntity entity in ents)
                {
                    if (entity.IsKilled() || config.Settings.BlockedPrefabs.Contains(entity.ShortPrefabName) || config.Settings.BlockedPrefabs.Contains(entity.GetType().Name))
                    {
                        continue;
                    }
                    if (entity.OwnerID.IsSteamId() || OutOfRange(mi.position, entity.transform.position, radius, entity is BaseChair))
                    {
                        continue;
                    }
                    if (entity.prefabID == 3858860623 || entity.prefabID == 1729604075 || entity is NPCMissionProvider || entity is Workbench)
                    {
                        var position = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                        if (position.y < TerrainMeta.HeightMap.GetHeight(position))
                        {
                            continue;
                        }
                        outpost.Location = position;
                        if (!outpost.Locations.Contains(position)) outpost.Locations.Add(position);
                        changedOutpost = true;
#if DEBUG
                        Puts("  Adding Outpost target {0}", position);
#endif
                    }
                    else if (entity is BaseChair)
                    {
                        var position = (entity.transform.position + new Vector3(0f, 0.1f)) + entity.transform.right + new Vector3(0f, 1f, 0f);
                        if (position.y < TerrainMeta.HeightMap.GetHeight(position))
                        {
                            continue;
                        }
                        outpost.Location = position;
                        if (!outpost.Locations.Contains(position)) outpost.Locations.Add(position);
                        changedOutpost = true;
#if DEBUG
                        Puts("  Adding Outpost target {0}", position);
#endif
                    }
                }
                if (changedOutpost) SaveConfig();
                ents.ResetToPool();
            }

            if (outpost.Location == Vector3.zero)
            {
                outpostEnabled = false;
            }
            else if (!outpost.Locations.Contains(outpost.Location))
            {
                outpost.Locations.Add(outpost.Location);
            }

            yield return null;
        }

        private IEnumerator SetupOutpost(MonumentInfo monument)
        {
            var outpost = GetSettings("outpost");

            if (outpost == null)
            {
                outpostEnabled = false;
                yield break;
            }

            if (config.Settings.AutoGenOutpost && outpost.Location != Vector3.zero && outpost.Locations.Exists(a => OutOfRange(monument, a, config.Settings.AutoGenOutpost)))
            {
#if DEBUG
                Puts("Invalid Outpost location detected");
#endif
                outpost.Location = Vector3.zero;
                outpost.Locations = new List<Vector3>();
            }
            if (config.Settings.AutoGenOutpost && outpost.Location == Vector3.zero)
            {
#if DEBUG
                Puts("  Looking for Outpost target");
#endif
                bool changedOutpost = false;
                var ents = Pool.Get<List<BaseEntity>>();
                float radius = monument.Bounds.size.Max();
                Vis.Entities(monument.transform.position, radius, ents);
                RemoveNearBuildingBlocks(ents);
                foreach (BaseEntity entity in ents)
                {
                    if (entity.IsKilled() || config.Settings.BlockedPrefabs.Contains(entity.ShortPrefabName) || config.Settings.BlockedPrefabs.Contains(entity.GetType().Name))
                    {
                        continue;
                    }
                    if (entity.OwnerID.IsSteamId() || OutOfRange(monument, entity.transform.position, entity is BaseChair))
                    {
                        continue;
                    }
                    if (entity.prefabID == 3858860623 || entity.prefabID == 1729604075 || entity is NPCMissionProvider || entity is Workbench)
                    {
                        var position = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                        if (position.y < TerrainMeta.HeightMap.GetHeight(position))
                        {
                            continue;
                        }
                        outpost.Location = position;
                        if (!outpost.Locations.Contains(position)) outpost.Locations.Add(position);
                        changedOutpost = true;
#if DEBUG
                        Puts("  Adding Outpost target {0}", position);
#endif
                    }
                    else if (entity is BaseChair)
                    {
                        var position = (entity.transform.position + new Vector3(0f, 0.1f)) + entity.transform.right + new Vector3(0f, 1f, 0f);
                        if (position.y < TerrainMeta.HeightMap.GetHeight(position))
                        {
                            continue;
                        }
                        outpost.Location = position;
                        if (!outpost.Locations.Contains(position)) outpost.Locations.Add(position);
                        changedOutpost = true;
#if DEBUG
                        Puts("  Adding Outpost target {0}", position);
#endif
                    }
                }
                if (changedOutpost) SaveConfig();
                ents.ResetToPool();
            }

            if (outpost.Location == Vector3.zero)
            {
                outpostEnabled = false;
            }
            else if (!outpost.Locations.Contains(outpost.Location))
            {
                outpost.Locations.Add(outpost.Location);
            }

            yield return null;
        }

        private IEnumerator SetupBandit(PrefabInfo mi)
        {
            var bandit = GetSettings("bandit");

            if (bandit == null)
            {
                banditEnabled = false;
                yield break;
            }

            float radius = mi.extents.Max();

            if (config.Settings.AutoGenBandit && bandit.Location != Vector3.zero && bandit.Locations.Exists(a => OutOfRange(mi.position, a, radius, config.Settings.AutoGenBandit)))
            {
#if DEBUG
                Puts("Invalid Bandit location detected");
#endif
                bandit.Location = Vector3.zero;
                bandit.Locations = new List<Vector3>();
            }
            if (config.Settings.AutoGenBandit && bandit.Location == Vector3.zero)
            {
#if DEBUG
                Puts("  Looking for BanditTown target");
#endif
                bool changedBandit = false;
                var ents = Pool.Get<List<BaseEntity>>();
                Vis.Entities(mi.position, radius, ents);
                RemoveNearBuildingBlocks(ents);
                foreach (BaseEntity entity in ents)
                {
                    if (entity.IsKilled() || entity.OwnerID.IsSteamId() || OutOfRange(mi.position, entity.transform.position, radius, entity is BaseChair))
                    {
                        continue;
                    }
                    if (entity.prefabID == 3858860623 || entity.prefabID == 1729604075 || entity is NPCMissionProvider || entity is Workbench)
                    {
                        var position = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                        if (position.y < TerrainMeta.HeightMap.GetHeight(position))
                        {
                            continue;
                        }
                        bandit.Location = position;
                        if (!bandit.Locations.Contains(position)) bandit.Locations.Add(position);
                        changedBandit = true;

#if DEBUG
                        Puts("  Adding BanditTown target {0}", position);
#endif
                    }
                    else if (entity is BaseChair)
                    {
                        var position = (entity.transform.position + new Vector3(0f, 0.1f)) + entity.transform.forward + new Vector3(0f, 1f, 0f);
                        if (position.y < TerrainMeta.HeightMap.GetHeight(position))
                        {
                            continue;
                        }
                        bandit.Location = position;
                        if (!bandit.Locations.Contains(position)) bandit.Locations.Add(position);
                        changedBandit = true;
#if DEBUG
                        Puts("  Adding BanditTown target {0}", position);
#endif
                    }
                }
                ents.ResetToPool();
                if (changedBandit) SaveConfig();
            }

            if (bandit.Location == Vector3.zero)
            {
                banditEnabled = false;
            }
            else if (!bandit.Locations.Contains(bandit.Location))
            {
                bandit.Locations.Add(bandit.Location);
            }

            yield return null;
        }

        private IEnumerator SetupBandit(MonumentInfo monument)
        {
            var bandit = GetSettings("bandit");

            if (bandit == null)
            {
                banditEnabled = false;
                yield break;
            }

            float radius = monument.Bounds.size.Max();

            if (config.Settings.AutoGenBandit && bandit.Location != Vector3.zero && bandit.Locations.Exists(a => OutOfRange(monument, a, config.Settings.AutoGenBandit)))
            {
#if DEBUG
                Puts("Invalid Bandit location detected");
#endif
                bandit.Location = Vector3.zero;
                bandit.Locations = new List<Vector3>();
            }
            if (config.Settings.AutoGenBandit && bandit.Location == Vector3.zero)
            {
#if DEBUG
                Puts("  Looking for BanditTown target");
#endif
                bool changedBandit = false;
                var ents = Pool.Get<List<BaseEntity>>();
                Vis.Entities(monument.transform.position, radius, ents);
                RemoveNearBuildingBlocks(ents);
                foreach (BaseEntity entity in ents)
                {
                    if (entity.IsKilled() || entity.OwnerID.IsSteamId() || OutOfRange(monument, entity.transform.position, entity is BaseChair))
                    {
                        continue;
                    }
                    if (entity.prefabID == 3858860623 || entity.prefabID == 1729604075 || entity is NPCMissionProvider || entity is Workbench)
                    {
                        var position = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                        if (position.y < TerrainMeta.HeightMap.GetHeight(position))
                        {
                            continue;
                        }
                        bandit.Location = position;
                        if (!bandit.Locations.Contains(position)) bandit.Locations.Add(position);
                        changedBandit = true;

#if DEBUG
                        Puts("  Adding BanditTown target {0}", position);
#endif
                    }
                    else if (entity is BaseChair)
                    {
                        var position = (entity.transform.position + new Vector3(0f, 0.1f)) + entity.transform.forward + new Vector3(0f, 1f, 0f);
                        if (position.y < TerrainMeta.HeightMap.GetHeight(position))
                        {
                            continue;
                        }
                        bandit.Location = position;
                        if (!bandit.Locations.Contains(position)) bandit.Locations.Add(position);
                        changedBandit = true;
#if DEBUG
                        Puts("  Adding BanditTown target {0}", position);
#endif
                    }
                }
                ents.ResetToPool();
                if (changedBandit) SaveConfig();
            }

            if (bandit.Location == Vector3.zero)
            {
                banditEnabled = false;
            }
            else if (!bandit.Locations.Contains(bandit.Location))
            {
                bandit.Locations.Add(bandit.Location);
            }

            yield return null;
        }

        private T GetColliderFrom<T>(T expected, Vector3 a, string text) where T : Collider
        {
            List<T> colliders = Pool.Get<List<T>>();
            Vis.Colliders<T>(a, 5f, colliders, Layers.Mask.Prevent_Building, QueryTriggerInteraction.Collide);
            if (expected != null && colliders.Contains(expected))
            {
                colliders.ResetToPool();
                return expected;
            }
            T collider = null;
            float dist = float.MaxValue;
            foreach (var col in colliders)
            {
                float distance = Vector3.Distance(a, col.bounds.center);
                if (collider == null || distance < dist)
                {
                    dist = distance;
                    collider = col;
                }
            }
            colliders.ResetToPool();
            return collider;
        }

        public IEnumerator CalculateMonumentSize(Vector3 from, Quaternion rot, Bounds b, string text, string prefab)
        {
            Collider colliderFrom = GetColliderFrom<Collider>(null, from, text);
            bool sphere = colliderFrom is SphereCollider;
            int checks = 0;
            float x = 0f;
            float z = 0f;
            float radius = b == default || b.extents.Max() <= 1f ? 15f : Mathf.Min(b.extents.x, b.extents.z);
            if (sphere && GetCustomMapPrefabRadius(from.XZ2D(), out var xzr))
            {
                x = z = radius = xzr;
                goto exit;
            }
            bool hasTopology = false;
            List<Vector3> positions = new();
            Collider colliderTo = null;
            if (text == "Substation")
            {
                x = 25f;
                z = 25f;
                goto exit;
            }
            while (radius < World.Size / 2f)
            {
                int pointsOfInterest = 0;
                foreach (var to in GetCardinalPositions(from, rot, radius))
                {
                    if (colliderFrom != null)
                    {
                        colliderTo = GetColliderFrom<Collider>(colliderFrom, to, text);

                        if (colliderTo != null && colliderTo == colliderFrom)
                        {
                            positions.Add(to);
                            hasTopology = true;
                            pointsOfInterest = 4;
                        }
                    }
                    else if (ContainsTopology(TerrainTopology.Enum.Building | TerrainTopology.Enum.Monument, to, 5f))
                    {
                        positions.Add(to);
                        pointsOfInterest++;
                        hasTopology = true;
                    }
                    if (++checks >= 25)
                    {
                        yield return CoroutineEx.waitForSeconds(0.0025f);
                        checks = 0;
                    }
                }
                if (pointsOfInterest < 4)
                {
                    break;
                }
                radius += 5f;
            }
            CalculateFurthestDistances(text, positions, from, rot, out x, out z);
            if (!hasTopology && !sphere)
            {
                x = z = 75f;
            }
        exit:
            float y = Mathf.Min(100f, x, z);
            if (sphere)
            {
                x *= 0.75f;
                y *= 0.75f;
                z *= 0.75f;
            }
            if (text == "Launch Site")
            {
                x -= x * 0.20f;
                z -= z * 0.30f;
            }
            if (text == "Airfield")
            {
                x -= x * 0.25f;
                z -= z * 0.30f;
            }
            if (text == "Power Plant")
            {
                x -= x * 0.25f;
                z -= z * 0.25f;
            }
            if (x <= 0 && y <= 0 && z <= 0)
            {
                x = y = z = radius;
            }
            var mi = new PrefabInfo(from, rot, new Vector3(x, y, z), config.Admin.ExtraMonumentDistance, text, prefab, sphere);
            monuments.Add(mi);
#if DEBUG
            Puts($"Adding Monument: {text}, pos: {from}, size: {x} {y} {z}, radius: {radius}, bounds: {b.extents.Max()}");
#endif
            if (config.Settings.Outpost.Exists(text.Contains))
            {
                yield return SetupOutpost(mi);
            }
            else if (config.Settings.Bandit.Exists(text.Contains))
            {
                yield return SetupBandit(mi);
            }
        }

        public static List<Vector3> GetCardinalPositions(Vector3 center, Quaternion rotation, float radius)
        {
            List<Vector3> positions = new()
            {
                rotation * new Vector3(0f, 0f, radius) + center,
                rotation * new Vector3(0f, 0f, -radius) + center,
                rotation * new Vector3(radius, 0f, 0f) + center,
                rotation * new Vector3(-radius, 0f, 0f) + center
            };

            for (int i = 0; i < positions.Count; i++)
            {
                Vector3 a = positions[i];

                float y = TerrainMeta.HeightMap.GetHeight(a);

                positions[i] = a.WithY(y);
            }

            return positions;
        }

        public void CalculateFurthestDistances(string text, List<Vector3> positions, Vector3 center, Quaternion rot, out float x, out float z)
        {
            float north = 0f, south = 0f, east = 0f, west = 0f;
            foreach (var position in positions)
            {
                Vector3 localPosition = Quaternion.Inverse(rot) * (position - center);
                north = (localPosition.z > 0) ? Mathf.Max(north, Mathf.Abs(localPosition.z)) : north;
                south = (localPosition.z < 0) ? Mathf.Max(south, Mathf.Abs(localPosition.z)) : south;
                east = (localPosition.x > 0) ? Mathf.Max(east, Mathf.Abs(localPosition.x)) : east;
                west = (localPosition.x < 0) ? Mathf.Max(west, Mathf.Abs(localPosition.x)) : west;
            }
            x = Mathf.Min(east, west);
            x -= Mathf.Max(5f, x * 0.05f);
            z = Mathf.Min(north, south);
            z -= Mathf.Max(5f, z * 0.05f);
        }

        private static void DrawText(BasePlayer player, float duration, Color color, Vector3 from, object text) => player?.SendConsoleCommand("ddraw.text", duration, color, from, $"<size=24>{text}</size>");
        private static void DrawLine(BasePlayer player, float duration, Color color, Vector3 from, Vector3 to) => player?.SendConsoleCommand("ddraw.line", duration, color, from, to);
        private static void DrawSphere(BasePlayer player, float duration, Color color, Vector3 from, float radius) => player?.SendConsoleCommand("ddraw.sphere", duration, color, from, radius);

        private bool TeleportInForcedBoundary(params BasePlayer[] players)
        {
            if (config.Settings.ForcedBoundary != 0f)
            {
                foreach (var player in players)
                {
                    if (!CanBypassRestrictions(player.UserIDString) && player.transform.localPosition.y >= config.Settings.ForcedBoundary)
                    {
                        PrintMsgL(player, "TPFlagZone");
                        return false;
                    }
                }
            }
            return true;
        }

        private void TeleportRequestUI(BasePlayer player, string displayName)
        {
            if (!config.TPR.UI || string.IsNullOrEmpty(displayName)) return;
            var elements = new CuiElementContainer();
            elements.Add(new CuiPanel { CursorEnabled = false, Image = { Color = "0 0 0 0.75" }, RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-154.835 87.648", OffsetMax = "135.234 155.152" } }, "Overlay", "TPR_MAIN_UI", "TPR_MAIN_UI");
            elements.Add(new CuiElement { Name = "TPR_INFO_LBL", Parent = "TPR_MAIN_UI", DestroyUi = "TPR_INFO_LBL", Components = { new CuiTextComponent { Text = _("RequestUI", player, displayName), Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter }, new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-142.335 -3.676", OffsetMax = "142.335 30.076" } } });
            elements.Add(new CuiButton { Button = { Command = "ntp.accept", Color = "0 0.78 0 0.75" }, Text = { Text = _("RequestAccept", player), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }, RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-138.395 -28.883", OffsetMax = "-28.406 -8.589" } }, "TPR_MAIN_UI", "TPR_ACCEPT_BTN", "TPR_ACCEPT_BTN");
            elements.Add(new CuiButton { Button = { Command = "ntp.reject", Color = "0.78 0 0 0.75" }, Text = { Text = _("RequestReject", player), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }, RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "29.305 -28.883", OffsetMax = "139.295 -8.589" } }, "TPR_MAIN_UI", "TPR_REJECT_BTN", "TPR_REJECT_BTN");
            timer.Once(config.TPR.RequestDuration, () => DestroyTeleportRequestCUI(player));
            CuiHelper.AddUi(player, elements);
        }

        public void DestroyTeleportRequestCUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "TPR_MAIN_UI");
        }

        [ConsoleCommand("ntp.accept")]
        private void ccmdAccept(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            DestroyTeleportRequestCUI(player);
            CommandTeleportAccept(player.IPlayer, "tpa", new string[0]);
        }

        [ConsoleCommand("ntp.reject")]
        private void ccmdReject(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            DestroyTeleportRequestCUI(player);
            CommandTeleportCancel(player.IPlayer, "tpc", new string[0]);
        }

        private bool OutOfRange(MonumentInfo m, Vector3 a, bool checkHeight) => checkHeight && Mathf.Abs(a.y - TerrainMeta.HeightMap.GetHeight(a)) > 5f || m.Distance(a) > m.Bounds.extents.Max() * 0.5f;

        private bool OutOfRange(Vector3 m, Vector3 a, float r, bool checkHeight) => checkHeight && Mathf.Abs(a.y - TerrainMeta.HeightMap.GetHeight(a)) > 5f || (a - m).magnitude > r * 0.5f;

        private void CommandToggle(IPlayer user, string command, string[] args)
        {
            if (!user.IsAdmin) return;

            if (args.Length == 0)
            {
                user.Reply("tnt commandname");
                return;
            }

            string arg = args[0].ToLower();
            command = command.ToLower();

            if (arg == command) return;

            if (!DisabledCommandData.DisabledCommands.Contains(arg))
                DisabledCommandData.DisabledCommands.Add(arg);
            else DisabledCommandData.DisabledCommands.Remove(arg);

            dataDisabled.WriteObject(DisabledCommandData);
            user.Reply(string.Format("{0} {1}", DisabledCommandData.DisabledCommands.Contains(arg) ? "Disabled:" : "Enabled:", arg));
        }

        private void CommandTeleport(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!user.IsServer && (!IsAllowedMsg(player, PermTp) || !TeleportInForcedBoundary(player))) return;
            BasePlayer target;
            float x, y, z;
            switch (args.Length)
            {
                case 1:
                    if (player == null) return;
                    target = FindPlayersSingle(args[0], player);
                    if (target == null) return;
                    if (target == player)
                    {
#if DEBUG
                        Puts("Debug mode - allowing self teleport.");
#else
                        PrintMsgL(player, "CantTeleportToSelf");
                        return;
#endif
                    }
                    Teleport(player, target);
                    PrintMsgL(player, "AdminTP", target.displayName);
                    Puts(_("LogTeleport", null, player.displayName, target.displayName));
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPTarget", player.displayName);
                    break;
                case 2:
                    var origin = FindPlayersSingle(args[0], player);
                    target = FindPlayersSingle(args[1], player);
                    if (target == null && origin != null)
                    {
                        var loc = GetAdminLocation(args[1]);
                        if (loc != Vector3.zero)
                        {
                            Teleport(origin, loc, "", target.userID, town: false, allowTPB: true, build: true, craft: true, cave: true);
                            return;
                        }
                    }
                    if (origin == null || target == null) return;
                    if (target == origin)
                    {
                        PrintMsgL(player, "CantTeleportPlayerToSelf");
                        return;
                    }
                    if (permission.UserHasPermission(target.UserIDString, PermDisallowTpToMe))
                    {
                        PrintMsgL(player, "CantTeleportPlayerToYourself");
                        return;
                    }
                    Teleport(origin, target);
                    Puts(_("LogTeleportPlayer", null, user.Name, origin.displayName, target.displayName));
                    if (player == null) return;
                    PrintMsgL(player, "AdminTPPlayers", origin.displayName, target.displayName);
                    PrintMsgL(origin, "AdminTPPlayer", player.displayName, target.displayName);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPPlayerTarget", player.displayName, origin.displayName);
                    break;
                case 3:
                    if (player == null) return;
                    if (!float.TryParse(args[0].Replace(",", string.Empty), out x) || !float.TryParse(args[1].Replace(",", string.Empty), out y) || !float.TryParse(args[2], out z))
                    {
                        PrintMsgL(player, "InvalidCoordinates");
                        return;
                    }
                    if (config.Settings.CheckBoundaries && !CheckBoundaries(x, y, z))
                    {
                        PrintMsgL(player, "AdminTPOutOfBounds");
                        PrintMsgL(player, "AdminTPBoundaries", boundary);
                        return;
                    }
                    Teleport(player, x, y, z);
                    PrintMsgL(player, "AdminTPCoordinates", player.transform.position);
                    Puts(_("LogTeleport", null, player.displayName, player.transform.position));
                    break;
                case 4:
                    target = FindPlayersSingle(args[0], player);
                    if (target == null) return;
                    if (player != null && permission.UserHasPermission(target.UserIDString, PermDisallowTpToMe) && target != player)
                    {
                        PrintMsgL(player, "CantTeleportPlayerToYourself");
                        return;
                    }
                    if (!float.TryParse(args[1].Replace(",", string.Empty), out x) || !float.TryParse(args[2].Replace(",", string.Empty), out y) || !float.TryParse(args[3], out z))
                    {
                        PrintMsgL(player, "InvalidCoordinates");
                        return;
                    }
                    if (config.Settings.CheckBoundaries && !CheckBoundaries(x, y, z))
                    {
                        PrintMsgL(player, "AdminTPOutOfBounds");
                        PrintMsgL(player, "AdminTPBoundaries", boundary);
                        return;
                    }
                    Teleport(target, x, y, z);
                    if (player == null) return;
                    if (player == target)
                    {
                        PrintMsgL(player, "AdminTPCoordinates", player.transform.position);
                        Puts(_("LogTeleport", null, player.displayName, player.transform.position));
                    }
                    else
                    {
                        PrintMsgL(player, "AdminTPTargetCoordinates", target.displayName, player.transform.position);
                        if (config.Admin.AnnounceTeleportToTarget)
                            PrintMsgL(target, "AdminTPTargetCoordinatesTarget", player.displayName, player.transform.position);
                        Puts(_("LogTeleportPlayer", null, player.displayName, target.displayName, player.transform.position));
                    }
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTP");
                    break;
            }
        }

        private Vector3 GetAdminLocation(string value)
        {
            foreach (var adminData in _Admin.Values)
            {
                if (adminData.Locations.TryGetValue(value, out var loc))
                {
                    return loc;
                }
            }
            return Vector3.zero;
        }

        private void CommandTeleportNear(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpN)) return;
            switch (args.Length)
            {
                case 1:
                case 2:
                    var target = FindPlayersSingle(args[0], player);
                    if (target == null) return;
                    if (target == player)
                    {
#if DEBUG
                        Puts("Debug mode - allowing self teleport.");
#else
                        PrintMsgL(player, "CantTeleportToSelf");
                        return;
#endif
                    }
                    int distance = 0;
                    if (args.Length != 2 || !int.TryParse(args[1], out distance))
                        distance = config.Admin.TeleportNearDefaultDistance;
                    float x = UnityEngine.Random.Range(-distance, distance);
                    var z = (float)Math.Sqrt(Math.Pow(distance, 2) - Math.Pow(x, 2));
                    var destination = target.transform.position;
                    destination.x -= x;
                    destination.z -= z;
                    Teleport(player, GetGroundBuilding(destination), "", target.userID, town: false, allowTPB: true, build: true, craft: true, cave: true);
                    PrintMsgL(player, "AdminTP", target.displayName);
                    Puts(_("LogTeleport", null, player.displayName, target.displayName));
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPTarget", player.displayName);
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTPN");
                    break;
            }
        }

        private void CommandTeleportLocation(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpL)) return;
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData) || adminData.Locations.Count <= 0)
            {
                PrintMsgL(player, "AdminLocationListEmpty");
                return;
            }
            switch (args.Length)
            {
                case 0:
                    PrintMsgL(player, "AdminLocationList");
                    foreach (var location in adminData.Locations)
                        PrintMsgL(player, $"{location.Key} {location.Value}");
                    break;
                case 1:
                    if (!adminData.Locations.TryGetValue(args[0], out var loc))
                    {
                        PrintMsgL(player, "LocationNotFound");
                        return;
                    }
                    Teleport(player, loc, args[0], 0uL, town: false, allowTPB: true, build: true, craft: true, cave: true);
                    PrintMsgL(player, "AdminTPLocation", args[0]);
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTPL");
                    break;
            }
        }

        private void CommandSaveTeleportLocation(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpSave)) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandTPSave");
                return;
            }
            if (!_Admin.TryGetValue(player.userID, out var adminData))
                _Admin[player.userID] = adminData = new AdminData();
            if (adminData.Locations.TryGetValue(args[0], out var location))
            {
                PrintMsgL(player, "LocationExists", location);
                return;
            }
            var positionCoordinates = player.transform.position;
            if (!CanBypassRestrictions(player.UserIDString) && !permission.UserHasPermission(player.UserIDString, "nteleportation.locationradiusbypass"))
            {
                foreach (var loc in adminData.Locations)
                {
                    if ((positionCoordinates - loc.Value).magnitude < config.Admin.LocationRadius)
                    {
                        PrintMsgL(player, "LocationExistsNearby", loc.Key);
                        return;
                    }
                }
            }
            adminData.Locations[args[0]] = positionCoordinates;
            PrintMsgL(player, "AdminTPLocationSave");
            changedAdmin = true;
        }

        private void CommandRemoveTeleportLocation(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpRemove)) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandTPRemove");
                return;
            }
            if (!_Admin.TryGetValue(player.userID, out var adminData) || adminData.Locations.Count <= 0)
            {
                PrintMsgL(player, "AdminLocationListEmpty");
                return;
            }
            if (adminData.Locations.Remove(args[0]))
            {
                PrintMsgL(player, "AdminTPLocationRemove", args[0]);
                changedAdmin = true;
                return;
            }
            PrintMsgL(player, "LocationNotFound");
        }

        private void CommandTeleportBack(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpB)) return;
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPB");
                return;
            }
            if (!_Admin.TryGetValue(player.userID, out var adminData) || adminData.PreviousLocation == Vector3.zero)
            {
                PrintMsgL(player, "NoPreviousLocationSaved");
                return;
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            if (!TeleportInForcedBoundary(player))
            {
                return;
            }
            if (!CanBypassRestrictions(player.UserIDString))
            {
                var err = CanPlayerTeleport(player, adminData.PreviousLocation, player.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                if (!string.IsNullOrEmpty(adminData.Home))
                {
                    err = CanPlayerTeleportHome(player, adminData.PreviousLocation);
                    if (err != null)
                    {
                        SendReply(player, err);
                        return;
                    }
                }
                err = CheckPlayer(player, adminData.BuildingBlocked, adminData.AllowCrafting, true, "tpb", adminData.AllowCave);
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
            }
            var countdown = GetLower(player, config.Settings.TPB.Countdowns, config.Settings.TPB.Countdown);
            if (countdown > 0f)
            {
                TeleportBack(player, adminData, countdown);
                return;
            }
            Teleport(player, adminData.PreviousLocation, adminData.Home, adminData.UserID, adminData.Town, allowTPB: false, build: adminData.BuildingBlocked, craft: adminData.AllowCrafting, cave: adminData.AllowCave);
            adminData.PreviousLocation = Vector3.zero;
            changedAdmin = true;
            PrintMsgL(player, "AdminTPBack");
            Puts(_("LogTeleportBack", null, player.displayName));
        }

        private void TeleportBack(BasePlayer player, AdminData adminData, int countdown)
        {
            string err = null;
            var location = adminData.PreviousLocation;
            TeleportTimers[player.userID] = new TeleportTimer
            {
                UserID = adminData.UserID,
                Home = adminData.Home,
                OriginPlayer = player,

                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts("Calling CheckPlayer from cmdChatHomeTP");
#endif
                    if (!CanBypassRestrictions(player.UserIDString))
                    {
                        err = CheckPlayer(player, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player), true, "home", CanCaveHome(player));
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = CanPlayerTeleport(player, location, player.transform.position);
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        if (!string.IsNullOrEmpty(adminData.Home))
                        {
                            err = CanPlayerTeleportHome(player, location);
                            if (err != null)
                            {
                                PrintMsgL(player, "Interrupted");
                                SendReply(player, err);
                                TeleportTimers.Remove(player.userID);
                                return;
                            }
                        }
                        err = CheckItems(player);
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, "TPBlockedItem", err);
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = IsInsideEntity(location, player.userID, "tpb");
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        if (!TeleportInForcedBoundary(player))
                        {
                            return;
                        }
                    }
                    Teleport(player, location, adminData.Home, adminData.UserID, adminData.Town, false, adminData.BuildingBlocked, adminData.AllowCrafting, adminData.AllowCave);
                    adminData.PreviousLocation = Vector3.zero;
                    changedAdmin = true;
                    PrintMsgL(player, "AdminTPBack");
                    Puts(_("LogTeleportBack", null, player.displayName));
                    TeleportTimers.Remove(player.userID);
                })
            };
            if (countdown > 0)
            {
                PrintMsgL(player, "DM_TownTPStarted", location, countdown);
                Interface.CallHook("OnTeleportBackAccepted", player, location, countdown);
            }
        }

        private void CommandSetHome(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermHome)) return;
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandSetHome");
                return;
            }
            string err = null;
            if (!_Home.TryGetValue(player.userID, out var homeData))
                _Home[player.userID] = homeData = new HomeData();
            var limit = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);
            if (!args[0].Replace("_", "").All(char.IsLetterOrDigit))
            {
                PrintMsgL(player, "InvalidCharacter");
                return;
            }
            if (homeData.TryGetValue(args[0], out var homeEntry))
            {
                PrintMsgL(player, "HomeExists", homeEntry.Get());
                return;
            }
            var position = player.transform.position;
            if (!CanBypassRestrictions(player.UserIDString))
            {
                var getUseableTime = GetUseableTime(player, config.Home.Hours);
                if (getUseableTime > 0.0)
                {
                    PrintMsgL(player, "NotUseable", FormatTime(player, getUseableTime));
                    return;
                }
                err = CheckPlayer(player, false, CanCraftHome(player), true, "sethome", CanCaveHome(player));
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                if (!player.CanBuild())
                {
                    PrintMsgL(player, "HomeTPBuildingBlocked");
                    return;
                }
                if (limit > 0 && homeData.Locations.Count >= limit)
                {
                    PrintMsgL(player, "HomeMaxLocations", limit);
                    return;
                }
                if (config.Home.LocationRadius > 0 && !permission.UserHasPermission(player.UserIDString, "nteleportation.locationradiusbypass"))
                {
                    foreach (var loc in homeData.Locations)
                    {
                        if ((position - loc.Value.Get()).magnitude < config.Home.LocationRadius)
                        {
                            PrintMsgL(player, "HomeExistsNearby", loc.Key);
                            return;
                        }
                    }
                }
                err = CanPlayerTeleport(player, position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CheckFoundation(player.userID, position, "sethome");
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
            }
            if (player.IsAdmin && config.Settings.DrawHomeSphere) DrawSphere(player, 30f, Color.blue, position, 2.5f);
            var entity = player.GetParentEntity() as Tugboat;
            if (entity != null)
            {
                if (!config.Home.AllowTugboats && !permission.UserHasPermission(player.UserIDString, "nteleportation.tugboatssethomebypass") && !CanBypassRestrictions(player.UserIDString))
                {
                    PrintMsgL(player, "HomeTugboatNotAllowed");
                    return;
                }
                homeData.Set(args[0], new HomeData.Entry
                {
                    Position = position - entity.transform.position,
                    wasEntity = true,
                    Entity = entity
                });
            }
            else homeData.Set(args[0], new HomeData.Entry(position));
            changedHome = true;
            PrintMsgL(player, "HomeSave");
            PrintMsgL(player, "HomeQuota", homeData.Locations.Count, limit);
            Interface.CallHook("OnHomeAdded", player, position, args[0]);
        }

        private void CommandRemoveHome(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermHome)) return;
            if (player.IsAdmin && args.Length == 2 && args[0] == "all")
            {
                float radius;
                if (float.TryParse(args[1], out radius))
                {
                    int amount = 0;
                    foreach (var home in _Home.ToList())
                    {
                        foreach (var location in home.Value.Locations.ToList())
                        {
                            var position = location.Value.Get();
                            if (Vector3Ex.Distance2D(position, player.transform.position) < radius)
                            {
                                string username = covalence.Players.FindPlayerById(home.Key.ToString())?.Name ?? "N/A";
                                Puts("{0} ({1}) removed home from {2} ({3}) at {4}", player.displayName, player.userID, username, home.Key, position);
                                DrawText(player, 30f, Color.red, position, "X");
                                home.Value.Remove(location.Key);
                                amount++;
                            }
                        }
                    }

                    user.Reply($"Removed {amount} homes within {radius} meters");
                }
                else user.Reply("/removehome all <radius>");

                return;
            }
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandRemoveHome");
                return;
            }
            if (!_Home.TryGetValue(player.userID, out var homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            if (homeData.TryGetValue(args[0], out var homeEntry))
            {
                Interface.CallHook("OnHomeRemoved", player, homeEntry.Get(), args[0]);
                homeData.Remove(args[0]);
                changedHome = true;
                PrintMsgL(player, "HomeRemove", args[0]);
            }
            else PrintMsgL(player, "HomeNotFound");
        }

        private void CommandHome(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermHome)) return;
            if (args.Length == 0)
            {
                PrintMsgL(player, "SyntaxCommandHome");
                if (IsAllowed(player)) PrintMsgL(player, "SyntaxCommandHomeAdmin");
                return;
            }
            switch (args[0].ToLower())
            {
                case "add":
                    CommandSetHome(user, command, args.Skip(1));
                    break;
                case "list":
                    CommandListHomes(user, command, args.Skip(1));
                    break;
                case "remove":
                    CommandRemoveHome(user, command, args.Skip(1));
                    break;
                case "radius":
                    CommandHomeRadius(user, command, args.Skip(1));
                    break;
                case "delete":
                    CommandHomeDelete(user, command, args.Skip(1));
                    break;
                case "tp":
                    CommandHomeAdminTP(user, command, args.Skip(1));
                    break;
                case "homes":
                    CommandHomeHomes(user, command, args.Skip(1));
                    break;
                case "wipe":
                    CommandWipeHomes(user, command, args.Skip(1));
                    break;
                default:
                    cmdChatHomeTP(player, command, args);
                    break;
            }
        }

        private void CommandHomeRadius(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermRadiusHome)) return;
            float radius;
            if (args.Length != 1 || !float.TryParse(args[0], out radius)) radius = 10;
            var found = false;
            foreach (var homeData in _Home)
            {
                var toRemove = new List<string>();
                var target = RustCore.FindPlayerById(homeData.Key)?.displayName ?? homeData.Key.ToString();
                foreach (var location in homeData.Value.Locations)
                {
                    var position = location.Value.Get();
                    if ((player.transform.position - position).magnitude <= radius)
                    {
                        string err = null;
                        if (!location.Value.isEntity)
                        {
                            err = location.Value.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(homeData.Key, position, "radius");
                        }
                        if (err != null)
                        {
                            SendHomeError(player, toRemove, err, location.Key, position, err == "HomeRemovedDestroyed");
                            found = true;
                            continue;
                        }
                        if (player.IsAdmin)
                        {
                            var entity = GetFoundationOwned(position, homeData.Key);
                            if (entity == null)
                            {
                                DrawText(player, 30f, Color.blue, position, $"{target} - {location.Key} {position}");
                            }
                            else
                            {
                                DrawText(player, 30f, Color.blue, entity.CenterPoint() + new Vector3(0, .5f), $"{target} - {location.Key} {position}");
                                DrawMonument(player, entity.CenterPoint(), entity.bounds.extents, entity.transform.rotation, Color.blue, 30f);
                            }
                        }
                        PrintMsg(player, $"{target} - {location.Key} {position}");
                        found = true;
                    }
                }
                foreach (var key in toRemove)
                {
                    homeData.Value.Remove(key);
                    changedHome = true;
                }
            }
            if (!found)
                PrintMsgL(player, "HomeNoFound");
        }

        private void SendHomeError(BasePlayer player, List<string> toRemove, string err, string homeName, Vector3 position, bool wasEntity, bool send = true)
        {
            Interface.CallHook("OnHomeRemoved", player, position, homeName);
            if (toRemove != null)
            {
                toRemove.Add(homeName);
            }
            if (!send)
            {
                return;
            }
            if (!wasEntity)
            {
                PrintMsgL(player, "HomeRemovedInvalid", $"{homeName} {position} ({MapHelper.PositionToString(position)})");
                PrintMsgL(player, err);
            }
            else PrintMsgL(player, "HomeRemovedDestroyed", homeName);
        }

        private void CommandHomeDelete(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowed(player, PermDeleteHome)) return;
            if (args.Length != 2)
            {
                PrintMsgL(player, "SyntaxCommandHomeDelete");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            if (!_Home.TryGetValue(userId, out var targetHome) || !targetHome.Remove(args[1]))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }
            changedHome = true;
            PrintMsgL(player, "HomeDelete", args[0], args[1]);
        }

        private void CommandHomeAdminTP(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermAdmin)) return;
            if (args.Length != 2)
            {
                PrintMsgL(player, "SyntaxCommandHomeAdminTP");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            if (!_Home.TryGetValue(userId, out var targetHome) || !targetHome.TryGetValue(args[1], out var homeEntry))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }
            Teleport(player, homeEntry.Get(), "", userId, town: false, allowTPB: true, build: true, craft: true, cave: true);
            PrintMsgL(player, "HomeAdminTP", args[0], args[1]);
        }

        // Check that plugins are available and enabled for CheckEconomy()
        private bool UseEconomy()
        {
            return (config.Settings.UseEconomics && (Economics != null || IQEconomic != null)) || (config.Settings.UseServerRewards && ServerRewards != null);
        }

        // Check balance on multiple plugins and optionally withdraw money from the player
        private bool CheckEconomy(BasePlayer player, double bypass, bool withdraw = false, bool deposit = false)
        {
            if (player == null)
            {
                return false;
            }
            if (CanBypassRestrictions(player.UserIDString)) return true;
            bool foundmoney = false;
            // Check Economics first.  If not in use or balance low, check ServerRewards below
            if (config.Settings.UseEconomics)
            {
                if (Economics != null)
                {
                    var balance = Convert.ToDouble(Economics?.CallHook("Balance", (ulong)player.userID));

                    if (balance >= bypass)
                    {
                        foundmoney = true;
                        if (withdraw)
                        {
                            return Convert.ToBoolean(Economics?.CallHook("Withdraw", (ulong)player.userID, bypass));
                        }
                        else if (deposit)
                        {
                            Economics?.CallHook("Deposit", (ulong)player.userID, bypass);
                        }
                    }
                }
                else if (IQEconomic != null)
                {
                    var balance = Convert.ToInt32(IQEconomic?.CallHook("API_GET_BALANCE", (ulong)player.userID));
                    if (balance >= bypass)
                    {
                        foundmoney = true;
                        if (withdraw)
                        {
                            return Convert.ToBoolean(IQEconomic?.CallHook("API_REMOVE_BALANCE", (ulong)player.userID, (int)bypass));
                        }
                        else if (deposit)
                        {
                            IQEconomic?.CallHook("API_SET_BALANCE", (ulong)player.userID, (int)bypass);
                        }
                    }
                }
            }

            // No money via Economics, or plugin not in use.  Try ServerRewards.
            if (!foundmoney && config.Settings.UseServerRewards && ServerRewards != null)
            {
                var balance = Convert.ToDouble(ServerRewards?.Call("CheckPoints", (ulong)player.userID));
                if (balance >= bypass)
                {
                    foundmoney = true;
                    if (withdraw)
                    {
                        return Convert.ToBoolean(ServerRewards?.Call("TakePoints", (ulong)player.userID, (int)bypass));
                    }
                    else if (deposit)
                    {
                        ServerRewards?.Call("AddPoints", (ulong)player.userID, (int)bypass);
                    }
                }
            }

            // Just checking balance without withdrawal - did we find anything?
            return foundmoney;
        }

        private void cmdChatHomeTP(BasePlayer player, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { player.ChatMessage("Disabled command."); return; }
            if (!IsAllowedMsg(player, PermHome)) return;
            bool paidmoney = false;
            if (!config.Settings.HomesEnabled) { player.ChatMessage("Homes are not enabled in the config."); return; }
            if (args.Length < 1)
            {
                PrintMsgL(player, "SyntaxCommandHome");
                return;
            }
            if (!_Home.TryGetValue(player.userID, out var homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            if (!homeData.TryGetValue(args[0], out var homeEntry))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }
            int limit = 0;
            string err = null;
            var position = homeEntry.Get();
            var timestamp = Facepunch.Math.Epoch.Current;
            if (!CanBypassRestrictions(player.UserIDString))
            {
                if (!TeleportInForcedBoundary(player))
                {
                    return;
                }
                float globalCooldownTime = GetGlobalCooldown(player);
                if (globalCooldownTime > 0f)
                {
                    PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                    return;
                }
                if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                {
                    PrintMsgL(player, "CannotTeleportFromHome");
                    return;
                }
                err = CheckPlayer(player, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player), true, "home", CanCaveHome(player));
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                if (config.Settings.BlockNoEscape && Convert.ToBoolean(NoEscape?.Call("IsBlockedZone", position)))
                {
                    PrintMsgL(player, "TPNoEscapeBlocked");
                    return;
                }
                if (config.Settings.RaidBlock && RaidBlock != null && Convert.ToBoolean(RaidBlock?.Call("IsBlocked", player)))
                {
                    PrintMsgL(player, "TPNoEscapeBlocked");
                    return;
                }
                if (!homeEntry.isEntity)
                {
                    err = homeEntry.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(player.userID, position, "home");
                }
                if (err == null)
                {
                    err = CheckTargetLocation(player, position, config.Home.UsableIntoBuildingBlocked, config.Home.CupOwnerAllowOnBuildingBlocked);
                }
                if (err != null)
                {
                    SendHomeError(player, null, err, args[0], position, err == "HomeRemovedDestroyed");
                    homeData.Remove(args[0]);
                    changedHome = true;
                    return;
                }
                if (config.Settings.Interrupt.Monument)
                {
                    var monname = NearMonument(position, false, "");
                    if (!string.IsNullOrEmpty(monname))
                    {
                        if (monname.Contains(":")) monname = monname.Substring(0, monname.IndexOf(":"));
                        PrintMsgL(player, "TooCloseToMon", _(monname, player));
                        return;
                    }
                }
                var cooldown = GetLower(player, config.Home.VIPCooldowns, config.Home.Cooldown);
                var remain = cooldown - (timestamp - homeData.Teleports.Timestamp);
                if (cooldown > 0 && timestamp - homeData.Teleports.Timestamp < cooldown)
                {
                    var cmdSent = args.Length >= 2 ? args[1].ToLower() : string.Empty;

                    if (!string.IsNullOrEmpty(config.Settings.BypassCMD) && !paidmoney)
                    {
                        if (cmdSent == config.Settings.BypassCMD.ToLower() && config.Home.Bypass > -1)
                        {
                            bool foundmoney = CheckEconomy(player, config.Home.Bypass);

                            if (foundmoney)
                            {
                                CheckEconomy(player, config.Home.Bypass, true);
                                paidmoney = true;

                                if (config.Home.Bypass > 0)
                                {
                                    PrintMsgL(player, "HomeTPCooldownBypass", config.Home.Bypass);
                                }

                                if (config.Home.Pay > 0)
                                {
                                    PrintMsgL(player, "PayToHome", config.Home.Pay);
                                }
                            }
                            else
                            {
                                PrintMsgL(player, "HomeTPCooldownBypassF", config.Home.Bypass);
                                return;
                            }
                        }
                        else if (UseEconomy())
                        {
                            if (config.Home.Bypass > 0)
                            {
                                PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                                PrintMsgL(player, "HomeTPCooldownBypassP", config.Home.Bypass);
                                PrintMsgL(player, "HomeTPCooldownBypassP2", config.Settings.BypassCMD);
                                return;
                            }
                        }
                        else
                        {
                            PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                            return;
                        }
                    }
                    else
                    {
                        PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                        return;
                    }
                }
                var currentDate = DateTime.Now.ToString("d");
                if (homeData.Teleports.Date != currentDate)
                {
                    homeData.Teleports.Amount = 0;
                    homeData.Teleports.Date = currentDate;
                }
                limit = GetHigher(player, config.Home.VIPDailyLimits, config.Home.DailyLimit, true);
                if (limit > 0 && homeData.Teleports.Amount >= limit)
                {
                    PrintMsgL(player, "HomeTPLimitReached", limit);
                    return;
                }
                err = CanPlayerTeleport(player, position, player.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CanPlayerTeleportHome(player, position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CheckItems(player);
                if (err != null)
                {
                    PrintMsgL(player, "TPBlockedItem", err);
                    return;
                }
                if (config.Home.UsableFromSafeZoneOnly && !player.InSafeZone())
                {
                    PrintMsgL(player, "TPHomeSafeZoneOnly");
                    return;
                }
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            var countdown = GetLower(player, config.Home.VIPCountdowns, config.Home.Countdown);
            TeleportTimers[player.userID] = new TeleportTimer
            {
                Home = args[0],
                OriginPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts("Calling CheckPlayer from cmdChatHomeTP");
#endif
                    position = homeEntry.Get();
                    if (!CanBypassRestrictions(player.UserIDString))
                    {
                        if (!TeleportInForcedBoundary(player))
                        {
                            return;
                        }
                        err = CheckPlayer(player, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player), true, "home", CanCaveHome(player));
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            if (paidmoney)
                            {
                                paidmoney = false;
                                CheckEconomy(player, config.Home.Bypass, false, true);
                            }
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = CanPlayerTeleport(player, position, player.transform.position);
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            if (paidmoney)
                            {
                                paidmoney = false;
                                CheckEconomy(player, config.Home.Bypass, false, true);
                            }
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = CheckItems(player);
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, "TPBlockedItem", err);
                            if (paidmoney)
                            {
                                paidmoney = false;
                                CheckEconomy(player, config.Home.Bypass, false, true);
                            }
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        if (!homeEntry.isEntity)
                        {
                            err = homeEntry.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(player.userID, position, "home");
                        }
                        if (err == null)
                        {
                            err = CheckTargetLocation(player, position, config.Home.UsableIntoBuildingBlocked, config.Home.CupOwnerAllowOnBuildingBlocked);
                        }
                        if (err != null)
                        {
                            SendHomeError(player, null, err, args[0], position, err == "HomeRemovedDestroyed");
                            homeData.Remove(args[0]);
                            changedHome = true;
                            if (paidmoney)
                            {
                                paidmoney = false;
                                CheckEconomy(player, config.Home.Bypass, false, true);
                            }
                            return;
                        }
                        if (UseEconomy())
                        {
                            if (config.Home.Pay < 0)
                            {
                                TeleportTimers.Remove(player.userID);
                                PrintMsgL(player, "DM_TownTPDisabled", "/home");
                                return;
                            }
                            else if (config.Home.Pay > 0)
                            {
                                if (!CheckEconomy(player, config.Home.Pay))
                                {
                                    TeleportTimers.Remove(player.userID);
                                    PrintMsgL(player, "TPNoMoney", config.Home.Pay);
                                    return;
                                }

                                if (!paidmoney)
                                {
                                    PrintMsgL(player, "TPMoney", (double)config.Home.Pay);
                                }

                                paidmoney = CheckEconomy(player, config.Home.Pay, true);
                            }
                        }
                    }
                    Teleport(player, position, args[0], 0uL, town: false, allowTPB: config.Home.AllowTPB, build: config.Home.UsableOutOfBuildingBlocked, craft: CanCraftHome(player), cave: CanCaveHome(player));
                    homeData.Teleports.Amount++;
                    homeData.Teleports.Timestamp = timestamp;
                    changedHome = true;
                    PrintMsgL(player, "HomeTP", args[0]);
                    if (limit > 0) PrintMsgL(player, "HomeTPAmount", limit - homeData.Teleports.Amount);
                    TeleportTimers.Remove(player.userID);
                })
            };

            if (countdown > 0)
            {
                PrintMsgL(player, "HomeTPStarted", args[0], countdown);
                Interface.CallHook("OnHomeAccepted", player, args[0], countdown);
            }
        }

        private void CommandListHomes(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            if (!IsAllowedMsg(player, PermHome)) return;
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandListHomes");
                return;
            }
            if (!_Home.TryGetValue(player.userID, out var homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            PrintMsgL(player, "HomeList");
            ValidateHomes(player, homeData, true, false);
            foreach (var location in homeData.Locations)
                PrintMsgL(player, $"{location.Key} {location.Value.Get()} {MapHelper.PositionToString(location.Value.Get())}");
        }

        private void ValidateHomes(BasePlayer player, HomeData homeData, bool showRemoved, bool showLoc)
        {
            if (config.Home.CheckValidOnList)
            {
                string err = null;
                var toRemove = new List<string>();
                foreach (var location in homeData.Locations)
                {
                    var position = location.Value.Get();
                    if (!location.Value.isEntity)
                    {
                        err = location.Value.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(player.userID, position, "validate");
                    }
                    if (err != null)
                    {
                        SendHomeError(player, toRemove, err, location.Key, position, err == "HomeRemovedDestroyed", showRemoved);
                    }
                    else if (showLoc) PrintMsgL(player, $"{location.Key} {position} {MapHelper.PositionToString(position)}");
                }
                foreach (var key in toRemove)
                {
                    homeData.Remove(key);
                    changedHome = true;
                }
            }
        }

        private void CommandHomeHomes(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermHomeHomes)) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandHomeHomes");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            HomeData homeData;
            if (!_Home.TryGetValue(userId, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            PrintMsgL(player, "HomeList");
            var toRemove = new List<string>();
            foreach (var location in homeData.Locations)
            {
                var position = location.Value.Get();
                string err = null;
                if (!location.Value.isEntity)
                {
                    err = location.Value.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(userId, position, "homes");
                }
                if (err != null)
                {
                    SendHomeError(player, toRemove, err, location.Key, position, err == "HomeRemovedDestroyed");
                }
                else PrintMsgL(player, $"{location.Key} {position} ({MapHelper.PositionToString(position)})");
            }
            foreach (var key in toRemove)
            {
                homeData.Remove(key);
                changedHome = true;
            }
        }

        private void CommandTeleportAcceptToggle(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (player == null || !IsAllowedMsg(player, PermTpT)) { return; }
            if (Array.Exists(args, arg => arg == "friend" || arg == "clan" || arg == "team" || arg == "all"))
            {
                ToggleTPTEnabled(player, command, args);
            }
            string clan = IsEnabled(player.UserIDString, "clan") ? config.TPT.EnabledColor : config.TPT.DisabledColor;
            string team = IsEnabled(player.UserIDString, "team") ? config.TPT.EnabledColor : config.TPT.DisabledColor;
            string friend = IsEnabled(player.UserIDString, "friend") ? config.TPT.EnabledColor : config.TPT.DisabledColor;
            PrintMsgL(player, "TPTInfo", command, clan, team, friend, command.ToUpper(), config.TPT.EnabledColor, config.TPT.DisabledColor);
        }

        public bool IsOnSameTeam(ulong playerId, ulong targetId)
        {
            return RelationshipManager.ServerInstance.playerToTeam.TryGetValue(playerId, out var team) && team.members.Contains(targetId);
        }

        private bool AreFriends(string playerId, string targetId)
        {
            return Friends != null && Convert.ToBoolean(Friends?.Call("AreFriends", playerId, targetId));
        }

        private bool IsFriend(string playerId, string targetId)
        {
            return Friends != null && Convert.ToBoolean(Friends?.Call("IsFriend", playerId, targetId));
        }

        private bool IsInSameClan(string playerId, string targetId)
        {
            return Clans != null && Convert.ToBoolean(Clans?.Call("IsMemberOrAlly", playerId, targetId));
        }

        private bool InstantTeleportAccept(BasePlayer target, BasePlayer player)
        {
            if (!permission.UserHasPermission(target.UserIDString, PermTpT) || !permission.UserHasPermission(player.UserIDString, PermTpT))
            {
                return false;
            }

            if ((config.TPT.UseClans && IsInSameClan(player.UserIDString, target.UserIDString) && !TPT.ContainsKey(target.UserIDString))
                || (config.TPT.UseClans && IsEnabled(target.UserIDString, "clan") && IsInSameClan(player.UserIDString, target.UserIDString)))
            {
                CommandTeleportAccept(target.IPlayer, TPA, nullArg);
            }
            else if ((config.TPT.UseFriends && IsFriend(player.UserIDString, target.UserIDString) && !TPT.ContainsKey(target.UserIDString))
                     || (config.TPT.UseFriends && IsEnabled(target.UserIDString, "friend") && IsFriend(player.UserIDString, target.UserIDString)))
            {
                CommandTeleportAccept(target.IPlayer, TPA, nullArg);
            }
            else if ((config.TPT.UseTeams && IsOnSameTeam(player.userID, target.userID) && !TPT.ContainsKey(target.UserIDString))
                     || (config.TPT.UseTeams && IsEnabled(target.UserIDString, "team") && IsOnSameTeam(player.userID, target.userID)))
            {
                CommandTeleportAccept(target.IPlayer, TPA, nullArg);
            }

            return true;
        }

        private bool IsEnabled(string targetId, string value)
        {
            return TPT.TryGetValue(targetId, out var list) && list.Contains(value);
        }

        private void ToggleTPTEnabled(BasePlayer target, string command, string[] args)
        {
            if (args.Contains("all"))
            {
                args = new string[] { "friend", "clan", "team" };
            }
            if (!TPT.TryGetValue(target.UserIDString, out var list))
            {
                TPT[target.UserIDString] = list = new();
            }
            foreach (var arg in args)
            {
                if (!list.Remove(arg))
                {
                    list.Add(arg);
                }
            }
            if (list.IsEmpty())
            {
                TPT.Remove(target.UserIDString);
            }
            changedTPT = true;
        }

        private string GetMultiplePlayers(List<BasePlayer> players)
        {
            return string.Join(", ", players.Select(player => string.Format("<color={0}>{1}</color> - {2}", config.Settings.ChatCommandArgumentColor, GetPlayerCode(player), player.displayName)));
        }

        private double GetUseableTime(BasePlayer player, double hours) => hours <= 0.0 || permission.UserHasPermission(player.UserIDString, "nteleportation.skipwipewaittime") ? 0.0 : TimeSpan.FromHours(hours - DateTime.UtcNow.Subtract(SaveRestore.SaveCreatedTime).TotalHours).TotalSeconds;

        private void CommandTeleportRequest(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpR)) return;
            if (!config.Settings.TPREnabled) { user.Reply("TPR is not enabled in the config."); return; }
            if (args.Length == 0)
            {
                PrintMsgL(player, "SyntaxCommandTPR");
                return;
            }
            var targets = FindPlayers(args[0]);
            if (targets.Count <= 0)
            {
                PrintMsgL(player, "PlayerNotFound");
                return;
            }
            BasePlayer target = null;
            if (args.Length >= 2)
            {
                if (targets.Count > 1)
                {
                    PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                    return;
                }
                else target = targets[0];
            }
            else
            {
                if (targets.Count > 1)
                {
                    PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                    return;
                }

                target = targets[0];
            }

            if (target == player)
            {
#if DEBUG
                Puts("Debug mode - allowing self teleport.");
#else
                PrintMsgL(player, "CantTeleportToSelf");
                return;
#endif
            }
#if DEBUG
            Puts("Calling CheckPlayer from cmdChatTeleportRequest");
#endif
            if (!TeleportInForcedBoundary(player, target))
            {
                return;
            }

            if (IsBlockedUser(player.userID, target.userID))
            {
                PrintMsgL(player, "BlockedTeleportTarget", target.displayName.Sanitize());
                return;
            }
            if (!_TPR.TryGetValue(player.userID, out var tprData))
                _TPR[player.userID] = tprData = new();
            if (!CanBypassRestrictions(player.UserIDString))
            {
                var getUseableTime = GetUseableTime(player, config.TPR.Hours);
                if (getUseableTime > 0.0)
                {
                    PrintMsgL(player, "NotUseable", FormatTime(player, getUseableTime));
                    return;
                }
                string err = null;
                float globalCooldownTime = GetGlobalCooldown(player);
                if (globalCooldownTime > 0f)
                {
                    PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                    return;
                }
                if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                {
                    PrintMsgL(player, "CannotTeleportFromHome");
                    return;
                }
                err = CheckPlayer(player, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(player), true, "tpr", CanCaveTPR(player));
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                var err2 = CheckPlayer(target, config.TPR.UsableIntoBuildingBlocked, CanCraftTPR(target), true, "tpr", CanCaveTPR(target));
                if (err2 != null)
                {
                    string error = string.Format(lang.GetMessage("ErrorTPR", this, player.UserIDString), target.displayName, lang.GetMessage(err2, this, player.UserIDString));
                    PrintMsg(player, error);
                    return;
                }
                err = CheckTargetLocation(target, target.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                if (config.TPR.BlockTPAOnCeiling)
                {
                    if (IsStandingOnEntity(target.transform.position, 20f, Layers.Mask.Construction, out var entity, new string[2] { "floor", "roof" }) && IsCeiling(entity as DecayEntity))
                    {
                        PrintMsgL(player, "TPRNoCeiling");
                        return;
                    }
                    if (IsBlockedOnIceberg(target.transform.position))
                    {
                        PrintMsgL(player, "HomeIce");
                        return;
                    }
                }
                var timestamp = Facepunch.Math.Epoch.Current;
                var currentDate = DateTime.Now.ToString("d");

                if (tprData.Date != currentDate)
                {
                    tprData.Amount = 0;
                    tprData.Date = currentDate;
                }

                var cooldown = GetLower(player, config.TPR.VIPCooldowns, config.TPR.Cooldown);
                if (cooldown > 0 && timestamp - tprData.Timestamp < cooldown)
                {
                    var cmdSent = args.Length >= 2 ? args[1].ToLower() : string.Empty;

                    if (!string.IsNullOrEmpty(config.Settings.BypassCMD))
                    {
                        if (cmdSent == config.Settings.BypassCMD.ToLower() && config.TPR.Bypass > -1)
                        {
                            if (CheckEconomy(player, config.TPR.Bypass))
                            {
                                CheckEconomy(player, config.TPR.Bypass, true);

                                if (config.TPR.Bypass > 0)
                                {
                                    PrintMsgL(player, "TPRCooldownBypass", config.TPR.Bypass);
                                }

                                if (config.TPR.Pay > 0)
                                {
                                    PrintMsgL(player, "PayToTPR", config.TPR.Pay);
                                }
                            }
                            else
                            {
                                PrintMsgL(player, "TPRCooldownBypassF", config.TPR.Bypass);
                                return;
                            }
                        }
                        else if (UseEconomy())
                        {
                            var remain = cooldown - (timestamp - tprData.Timestamp);
                            PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                            if (config.TPR.Bypass > -1)
                            {
                                if (config.TPR.Bypass > 0)
                                {
                                    PrintMsgL(player, "TPRCooldownBypassP", config.TPR.Bypass);

                                    if (config.TPR.Pay > 0)
                                    {
                                        PrintMsgL(player, "PayToTPR", config.TPR.Pay);
                                    }

                                    PrintMsgL(player, "TPRCooldownBypassP2a", config.Settings.BypassCMD);
                                    return;
                                }
                            }
                            else return;
                        }
                        else
                        {
                            var remain = cooldown - (timestamp - tprData.Timestamp);
                            PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                            return;
                        }
                    }
                    else
                    {
                        var remain = cooldown - (timestamp - tprData.Timestamp);
                        PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                        return;
                    }
                }
                var limit = GetHigher(player, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                if (limit > 0 && tprData.Amount >= limit)
                {
                    PrintMsgL(player, "TPRLimitReached", limit);
                    return;
                }
                err = CanPlayerTeleport(player, player.transform.position, target.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CanPlayerTeleport(target, target.transform.position, player.transform.position);
                if (err != null)
                {
                    PrintMsgL(player, string.IsNullOrEmpty(err) ? "TPRTarget" : err);
                    return;
                }
                err = CheckItems(player);
                if (err != null)
                {
                    PrintMsgL(player, "TPBlockedItem", err);
                    return;
                }
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            if (TeleportTimers.ContainsKey(target.userID))
            {
                PrintMsgL(player, "TeleportPendingTarget");
                return;
            }
            if (PlayersRequests.ContainsKey(player.userID))
            {
                PrintMsgL(player, "PendingRequest");
                return;
            }
            if (PlayersRequests.ContainsKey(target.userID))
            {
                PrintMsgL(player, "PendingRequestTarget");
                return;
            }

            if (!config.TPR.UseClans_Friends_Teams || IsInSameClan(player.UserIDString, target.UserIDString) || AreFriends(player.UserIDString, target.UserIDString) || IsOnSameTeam(player.userID, target.userID) || CanBypassRestrictions(player.UserIDString))
            {
                PlayersRequests[player.userID] = target;
                PlayersRequests[target.userID] = player;
                PendingRequests[target.userID] = timer.Once(config.TPR.RequestDuration, () => { RequestTimedOut(player, target); });
                PrintMsgL(player, "Request", target.displayName);
                PrintMsgL(target, "RequestTarget", player.displayName);
                if (config.TPR.PlaySoundsToRequestTarget)
                {
                    SendEffect(target, config.TPR.TeleportRequestEffects);
                }
                if (Interface.CallHook("OnTeleportRequested", target, player) == null && !InstantTeleportAccept(target, player))
                {
                    TeleportRequestUI(target, player.displayName);
                }
            }
            else
            {
                PrintMsgL(player, "TPR_NoClan_NoFriend_NoTeam");
            }
        }

        private void CommandTeleportAccept(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            if (!config.Settings.TPREnabled) { user.Reply("TPR is not enabled in the config."); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, config.TPR.RequireTPAPermission ? PermTpA : PermTpR)) return;
            DestroyTeleportRequestCUI(player);
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPA");
                return;
            }
            if (!PendingRequests.TryGetValue(player.userID, out var reqTimer))
            {
                PrintMsgL(player, "NoPendingRequest");
                DestroyTeleportRequestCUI(player);
                return;
            }
#if DEBUG
            Puts("Calling CheckPlayer from cmdChatTeleportAccept");
#endif
            string err = null;
            var originPlayer = PlayersRequests[player.userID];
            if (originPlayer == null)
            {
                PrintMsgL(player, "NoPendingRequest");
                return;
            }
            if (!CanBypassRestrictions(player.UserIDString))
            {
                if (!TeleportInForcedBoundary(originPlayer, player))
                {
                    return;
                }
                err = CheckPlayer(player, config.TPR.UsableIntoBuildingBlocked, CanCraftTPR(player), false, "tpa", CanCaveTPR(player));
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                err = CheckPlayer(originPlayer, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(originPlayer), true, "tpa", CanCaveTPR(originPlayer));
                if (err != null)
                {
                    PrintMsgL(originPlayer, err);
                    return;
                }
                err = CheckTargetLocation(originPlayer, player.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                err = CanPlayerTeleport(player, originPlayer.transform.position, player.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                if (config.TPR.BlockTPAOnCeiling)
                {
                    if (IsStandingOnEntity(player.transform.position, 20f, Layers.Mask.Construction, out var entity, new string[2] { "floor", "roof" }) && IsCeiling(entity as DecayEntity))
                    {
                        PrintMsgL(player, "TPRNoCeiling");
                        return;
                    }
                    if (IsBlockedOnIceberg(player.transform.position))
                    {
                        PrintMsgL(player, "HomeIce");
                        return;
                    }
                }
                float globalCooldownTime = GetGlobalCooldown(player);
                if (globalCooldownTime > 0f)
                {
                    PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                    return;
                }
                if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                {
                    PrintMsgL(player, "CannotTeleportFromHome");
                    return;
                }
            }
            var countdown = GetLower(originPlayer, config.TPR.VIPCountdowns, config.TPR.Countdown);
            PrintMsgL(originPlayer, "Accept", player.displayName, countdown);
            PrintMsgL(player, "AcceptTarget", originPlayer.displayName);
            Interface.CallHook("OnTeleportAccepted", player, originPlayer, countdown);
            if (config.TPR.PlaySoundsWhenTargetAccepts)
            {
                SendEffect(originPlayer, config.TPR.TeleportAcceptEffects);
            }
            var timestamp = Facepunch.Math.Epoch.Current;
            TeleportTimers[originPlayer.userID] = new TeleportTimer
            {
                OriginPlayer = originPlayer,
                TargetPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts("Calling CheckPlayer from cmdChatTeleportAccept timer loop");
#endif
                    if (!CanBypassRestrictions(player.UserIDString))
                    {
                        if (!TeleportInForcedBoundary(originPlayer, player))
                        {
                            return;
                        }
                        if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                        {
                            PrintMsgL(player, "CannotTeleportFromHome");
                            return;
                        }
                        err = CheckPlayer(originPlayer, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(originPlayer), true, "tpa", CanCaveTPR(originPlayer)) ?? CheckPlayer(player, false, CanCraftTPR(player), true, "tpa", CanCaveTPR(player));
                        if (err != null)
                        {
                            PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                            PrintMsgL(originPlayer, "Interrupted");
                            PrintMsgL(originPlayer, err);
                            TeleportTimers.Remove(originPlayer.userID);
                            return;
                        }
                        err = CheckTargetLocation(originPlayer, player.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
                        if (err != null)
                        {
                            PrintMsgL(player, err);
                            PrintMsgL(originPlayer, "Interrupted");
                            PrintMsgL(originPlayer, err);
                            TeleportTimers.Remove(originPlayer.userID);
                            return;
                        }
                        err = CanPlayerTeleport(originPlayer, player.transform.position, originPlayer.transform.position);
                        if (err != null)
                        {
                            SendReply(player, err);
                            PrintMsgL(originPlayer, "Interrupted");
                            SendReply(originPlayer, err);
                            TeleportTimers.Remove(originPlayer.userID);
                            return;
                        }
                        err = CheckItems(originPlayer);
                        if (err != null)
                        {
                            PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                            PrintMsgL(originPlayer, "Interrupted");
                            PrintMsgL(originPlayer, "TPBlockedItem", err);
                            TeleportTimers.Remove(originPlayer.userID);
                            return;
                        }
                        if (UseEconomy())
                        {
                            if (config.TPR.Pay > -1)
                            {
                                if (!CheckEconomy(originPlayer, config.TPR.Pay))
                                {
                                    if (config.TPR.Pay > 0)
                                    {
                                        PrintMsgL(originPlayer, "TPNoMoney", config.TPR.Pay);
                                    }

                                    PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                                    TeleportTimers.Remove(originPlayer.userID);
                                    return;
                                }
                                else
                                {
                                    CheckEconomy(originPlayer, config.TPR.Pay, true);

                                    if (config.TPR.Pay > 0)
                                    {
                                        PrintMsgL(originPlayer, "TPMoney", (double)config.TPR.Pay);
                                    }
                                }
                            }
                        }
                    }
                    SendDiscordMessage(originPlayer, player);
                    Teleport(originPlayer, player.transform.position, "", player.userID, town: false, allowTPB: config.TPR.AllowTPB, build: config.TPR.UsableOutOfBuildingBlocked, craft: CanCraftTPR(player), CanCaveTPR(player));
                    var tprData = _TPR[originPlayer.userID];
                    tprData.Amount++;
                    tprData.Timestamp = timestamp;
                    changedTPR = true;
                    PrintMsgL(player, "SuccessTarget", originPlayer.displayName);
                    PrintMsgL(originPlayer, "Success", player.displayName);
                    var limit = GetHigher(originPlayer, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                    if (limit > 0) PrintMsgL(originPlayer, "TPRAmount", limit - tprData.Amount);
                    TeleportTimers.Remove(originPlayer.userID);
                    Interface.CallHook("OnTeleportRequestCompleted", player, originPlayer);
                })
            };
            reqTimer.Destroy();
            PendingRequests.Remove(player.userID);
            PlayersRequests.Remove(player.userID);
            PlayersRequests.Remove(originPlayer.userID);
        }

        private void CommandWipeHomes(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermWipeHomes)) return;
            if (_Home.Count > 0) Puts("{0} ({1}) wiped homes", player.displayName, player.userID);
            _Home.Clear();
            changedHome = true;
            PrintMsgL(player, "HomesListWiped");
        }

        private void CommandTeleportHelp(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (player == null || !player.IsConnected || player.IsSleeping()) return;
            if (!config.Settings.HomesEnabled && !config.Settings.TPREnabled && !IsAllowedMsg(player)) return;
            if (args.Length == 1)
            {
                var key = $"TPHelp{args[0].ToLower()}";
                var msg = _(key, player);
                if (key.Equals(msg))
                    PrintMsgL(player, "InvalidHelpModule");
                else
                    PrintMsg(player, msg);
            }
            else
            {
                var msg = _("TPHelpGeneral", player);
                if (IsAllowed(player))
                    msg += NewLine + "/tphelp AdminTP";
                if (config.Settings.HomesEnabled)
                    msg += NewLine + "/tphelp Home";
                if (config.Settings.TPREnabled)
                    msg += NewLine + "/tphelp TPR";
                PrintMsg(player, msg);
            }
        }

        private List<string> _tpid = new List<string> { "home", "bandit", "outpost", "tpr", "town" };

        private void CommandTeleportInfo(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (player == null || !player.IsConnected || player.IsSleeping() || !TeleportInForcedBoundary(player)) return;
            if (args.Length == 1)
            {
                var module = args[0].ToLower();
                var settings = GetSettings(module);
                var msg = _(_tpid.Contains(module) || settings == null ? $"TPSettings{module}" : "TPSettingsdynamic", player);
                var timestamp = Facepunch.Math.Epoch.Current;
                var currentDate = DateTime.Now.ToString("d");
                int limit;
                int cooldown;

                switch (module)
                {
                    case "home":
                        if (!IsAllowedMsg(player, PermHome)) return;
                        limit = GetHigher(player, config.Home.VIPDailyLimits, config.Home.DailyLimit, true);
                        cooldown = GetLower(player, config.Home.VIPCooldowns, config.Home.Cooldown);
                        int homeLimits = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);
                        PrintMsg(player, string.Format(msg, FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player), homeLimits));
                        HomeData homeData;
                        if (!_Home.TryGetValue(player.userID, out homeData))
                            _Home[player.userID] = homeData = new HomeData();
                        if (homeData.Teleports.Date != currentDate)
                        {
                            homeData.Teleports.Amount = 0;
                            homeData.Teleports.Date = currentDate;
                        }
                        if (limit > 0) PrintMsgL(player, "HomeTPAmount", limit - homeData.Teleports.Amount);
                        if (cooldown > 0 && timestamp - homeData.Teleports.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - homeData.Teleports.Timestamp);
                            PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                        }
                        break;
                    case "tpr":
                        if (!IsAllowedMsg(player, PermTpR)) return;
                        limit = GetHigher(player, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                        cooldown = GetLower(player, config.TPR.VIPCooldowns, config.TPR.Cooldown);
                        PrintMsg(player, string.Format(msg, FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        TeleportData tprData;
                        if (!_TPR.TryGetValue(player.userID, out tprData))
                            _TPR[player.userID] = tprData = new TeleportData();
                        if (tprData.Date != currentDate)
                        {
                            tprData.Amount = 0;
                            tprData.Date = currentDate;
                        }
                        if (limit > 0) PrintMsgL(player, "TPRAmount", limit - tprData.Amount);
                        if (cooldown > 0 && timestamp - tprData.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - tprData.Timestamp);
                            PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                        }
                        break;
                    default: // town island outpost bandit etc
                        if (settings == null)
                        {
                            PrintMsgL(player, "InvalidHelpModule");
                            break;
                        }

                        limit = GetHigher(player, settings.VIPDailyLimits, settings.DailyLimit, true);
                        cooldown = GetLower(player, settings.VIPCooldowns, settings.Cooldown);
                        if (_tpid.Contains(module)) PrintMsg(player, string.Format(msg, FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        else PrintMsg(player, string.Format(msg, module.SentenceCase(), FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        TeleportData tpData;
                        if (!settings.Teleports.TPData.TryGetValue(player.userID, out tpData))
                            settings.Teleports.TPData[player.userID] = tpData = new TeleportData();
                        if (tpData.Date != currentDate)
                        {
                            tpData.Amount = 0;
                            tpData.Date = currentDate;
                        }
                        var language = lang.GetMessage(settings.Command, this, user.Id);
                        if (limit > 0) PrintMsgL(player, "DM_TownTPAmount", limit - tpData.Amount, language);
                        if (!string.IsNullOrEmpty(config.Settings.BypassCMD) && cooldown > 0 && timestamp - tpData.Timestamp < cooldown)
                        {
                            if (Interface.CallHook("OnTeleportCooldownNotify", player) != null)
                            {
                                break;
                            }

                            var remain = cooldown - (timestamp - tpData.Timestamp);
                            PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));

                            if (settings.Bypass > 0)
                            {
                                PrintMsgL(player, "DM_TownTPCooldownBypassP", settings.Bypass);
                                PrintMsgL(player, "DM_TownTPCooldownBypassP2", language, config.Settings.BypassCMD);
                            }
                        }
                        break;
                }
            }
            else
            {
                var msg = _("TPInfoGeneral", player);
                if (config.Settings.HomesEnabled && IsAllowed(player, PermHome))
                    msg += NewLine + "/tpinfo Home";
                if (config.Settings.TPREnabled && IsAllowed(player, PermTpR))
                    msg += NewLine + "/tpinfo TPR";
                foreach (var entry in config.DynamicCommands)
                {
                    if (entry.Value.Enabled)
                    {
                        if (command == "bandit" && !banditEnabled) continue;
                        if (command == "outpost" && !outpostEnabled) continue;
                        if (!IsAllowed(player, $"{Name}.tp{entry.Key}")) continue;
                        msg += NewLine + $"/tpinfo {entry.Key}";
                    }
                }
                PrintMsgL(player, msg);
            }
        }

        private void CommandTeleportCancel(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            var player = user.Object as BasePlayer;
            if (player == null || !player.IsConnected || player.IsSleeping()) return;
            DestroyTeleportRequestCUI(player);
            if (TeleportTimers.TryGetValue(player.userID, out var teleportTimer))
            {
                teleportTimer.Timer?.Destroy();
                PrintMsgL(player, "TPCancelled");
                PrintMsgL(teleportTimer.TargetPlayer, "TPCancelledTarget", player.displayName);
                TeleportTimers.Remove(player.userID);
                Interface.CallHook("OnTeleportRejected", player, teleportTimer.TargetPlayer);
                return;
            }
            foreach (var keyValuePair in TeleportTimers)
            {
                if (keyValuePair.Value.TargetPlayer != player) continue;
                keyValuePair.Value.Timer?.Destroy();
                PrintMsgL(keyValuePair.Value.OriginPlayer, "TPCancelledTarget", player.displayName);
                PrintMsgL(player, "TPYouCancelledTarget", keyValuePair.Value.OriginPlayer.displayName);
                TeleportTimers.Remove(keyValuePair.Key);
                Interface.CallHook("OnTeleportRejected", player, keyValuePair.Value.OriginPlayer);
                return;
            }
            if (!PlayersRequests.TryGetValue(player.userID, out var target))
            {
                PrintMsgL(player, "NoPendingRequest");
                return;
            }
            if (PendingRequests.TryGetValue(player.userID, out var reqTimer))
            {
                reqTimer.Destroy();
                PendingRequests.Remove(player.userID);
            }
            else if (PendingRequests.TryGetValue(target.userID, out reqTimer))
            {
                reqTimer.Destroy();
                PendingRequests.Remove(target.userID);
                var temp = player;
                player = target;
                target = temp;
            }
            PlayersRequests.Remove(target.userID);
            PlayersRequests.Remove(player.userID);
            PrintMsgL(player, "Cancelled", target.displayName);
            PrintMsgL(target, "CancelledTarget", player.displayName);
            Interface.CallHook("OnTeleportRejected", player, target);
        }

        private void CommandDynamic(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (!user.HasPermission(PermAdmin) || args.Length != 2 || args[0].Equals("list", StringComparison.OrdinalIgnoreCase))
            {
                CommandTeleportInfo(user, command, args.Skip(1));
                return;
            }

            var value = args[1].ToLower();

            if (args[0].Equals("add", StringComparison.OrdinalIgnoreCase))
            {
                TownSettings settings;
                if (GetSettings(value) == null)
                {
                    config.DynamicCommands.Add(value, settings = new TownSettings());
                    RegisterCommand(value, settings, true);
                    RegisterCommand(value, nameof(CommandCustom));
                    PrintMsgL(user, "DM_TownTPCreated", value);
                    SaveConfig();
                }
                else PrintMsgL(user, "DM_TownTPExists", value);
            }
            else if (args[0].Equals("remove", StringComparison.OrdinalIgnoreCase))
            {
                var key = config.DynamicCommands.Keys.FirstOrDefault(x => x.Equals(value, StringComparison.OrdinalIgnoreCase));

                if (!string.IsNullOrEmpty(key))
                {
                    PrintMsgL(user, "DM_TownTPRemoved", key);
                    config.DynamicCommands.Remove(key);
                    UnregisterCommand(value);
                    SaveConfig();
                }
                else PrintMsgL(user, "DM_TownTPDoesNotExist", value);
            }
            else CommandTeleportInfo(user, command, args);
        }

        private void CommandCustom(IPlayer user, string command, string[] args)
        {
            CommandTown(user, command, args);
        }

        private TownSettings GetSettings(string command, ulong userid = 0uL)
        {
            if (command.Equals("home", StringComparison.OrdinalIgnoreCase) && _Home.ContainsKey(userid))
            {
                return new TownSettings
                {
                    VIPCooldowns = config.Home.VIPCooldowns,
                    Cooldown = config.Home.Cooldown,
                    Countdown = config.Home.Countdown,
                    VIPDailyLimits = config.Home.VIPDailyLimits,
                    DailyLimit = config.Home.DailyLimit,
                    Teleports = new StoredData
                    {
                        TPData = new Dictionary<ulong, TeleportData>
                        {
                            [userid] = _Home[userid].Teleports
                        }
                    }
                };
            }

            if (command.Equals("tpr", StringComparison.OrdinalIgnoreCase) && _TPR.ContainsKey(userid))
            {
                return new TownSettings
                {
                    VIPCooldowns = config.TPR.VIPCooldowns,
                    Cooldown = config.TPR.Cooldown,
                    Countdown = config.TPR.Countdown,
                    VIPDailyLimits = config.TPR.VIPDailyLimits,
                    DailyLimit = config.TPR.DailyLimit,
                    Teleports = new StoredData
                    {
                        TPData = new Dictionary<ulong, TeleportData>
                        {
                            [userid] = _TPR[userid]
                        }
                    }
                };
            }

            foreach (var x in config.DynamicCommands)
            {
                if (x.Key.Equals(command, StringComparison.OrdinalIgnoreCase))
                {
                    return x.Value;
                }
            }

            return null;
        }

        private bool IsServerCommand(IPlayer user, string command, string[] args)
        {
            if (!user.IsServer)
            {
                return false;
            }
            var settings = GetSettings(command);
            if (settings == null)
            {
                user.Reply($"Command '{command}' not found in config.");
                return false;
            }
            if (args.Length == 0)
            {
                string positions = string.Join(", ", settings.Locations.ToArray());
                user.Reply($"{command} locations: {positions}");
                return true;
            }
            if (args[0] == "clear")
            {
                settings.Location = Vector3.zero;
                settings.Locations.Clear();
                user.Reply($"{command} locations have been cleared.");
            }
            else
            {
                try
                {
                    var vector = string.Join(" ", args).ToVector3();
                    if (vector == Vector3.zero)
                    {
                        throw new InvalidCastException("zero");
                    }
                    if (Vector3.Distance(vector, Vector3.zero) < 50f)
                    {
                        throw new InvalidCastException("distance");
                    }
                    if (vector.y < TerrainMeta.HeightMap.GetHeight(vector))
                    {
                        throw new InvalidCastException("height");
                    }
                    if (!settings.Locations.Contains(vector))
                    {
                        settings.Locations.Insert(0, vector);
                        user.Reply($"{command} location manually set to: " + vector);
                    }
                    else user.Reply($"{command} location was already set to: " + vector);
                    settings.Location = vector;
                }
                catch
                {
                    user.Reply($"Invalid position specified ({string.Join(" ", args)})");
                    return true;
                }
            }
            if (command == "bandit")
            {
                banditEnabled = settings.Locations.Count > 0;
            }
            if (command == "outpost")
            {
                outpostEnabled = settings.Locations.Count > 0;
            }
            SaveConfig();
            return true;
        }

        private void CommandTown(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            if (IsServerCommand(user, command, args)) return;
            var player = user.Object as BasePlayer;
#if DEBUG
            Puts($"cmdChatTown: command={command}");
#endif
            if (!IsAllowedMsg(player, $"{Name}.tp{command}".ToLower()) || !TeleportInForcedBoundary(player)) return;

            if (!CanBypassRestrictions(player.UserIDString))
            {
                float globalCooldownTime = GetGlobalCooldown(player);
                if (globalCooldownTime > 0f)
                {
                    PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                    return;
                }

                if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                {
                    PrintMsgL(player, "CannotTeleportFromHome");
                    return;
                }
            }

            var settings = GetSettings(command);

            if (settings == null)
            {
                return;
            }

            var language = lang.GetMessage(settings.Command, this, user.Id);

            // For admin using set, add, clear or show command locations
            if (args.Length >= 1 && IsAllowed(player, PermAdmin))
            {
                var param = args[0].ToLower();

                if (param.Equals("clear"))
                {
                    settings.Location = Vector3.zero;
                    settings.Locations.Clear();
                    SaveConfig();
                    PrintMsgL(player, "DM_TownTPLocationsCleared", language);
                    return;
                }
                else if (param.Equals("set"))
                {
                    if (settings.Locations.Count > 0)
                    {
                        settings.Locations.RemoveAt(0);
                    }
                    var position = player.transform.position;
                    settings.Locations.Insert(0, settings.Location = position);
                    SaveConfig();
                    PrintMsgL(player, "DM_TownTPLocation", language, position);
                    return;
                }
                else if (param.Equals("add"))
                {
                    var position = player.transform.position;
                    int num = settings.Locations.RemoveAll(x => Vector3.Distance(position, x) < 25f);
                    settings.Locations.Add(position);
                    SaveConfig();
                    PrintMsgL(player, "DM_TownTPLocation", language, position);
                    return;
                }
                else if (args[0].Equals("show", StringComparison.OrdinalIgnoreCase))
                {
                    settings.Locations.ForEach(x => DrawText(player, 30f, Color.green, x, command));
                    return;
                }
            }

            bool paidmoney = false;

            // Is command usage enabled?
            if (!settings.Enabled)
            {
                PrintMsgL(player, "DM_TownTPDisabled", language.SentenceCase());
                return;
            }

            if (settings.Location != Vector3.zero && !settings.Locations.Contains(settings.Location))
            {
                settings.Locations.Add(settings.Location);
            }

            // Is location set?
            if (settings.Locations.Count == 0)
            {
                PrintMsgL(player, "DM_TownTPNoLocation", language.SentenceCase());
                return;
            }

            // Are they trying to bypass cooldown or did they just type something else?
            if (args.Length == 1 && !string.IsNullOrEmpty(config.Settings.BypassCMD) && args[0].ToLower() != config.Settings.BypassCMD.ToLower() && !args[0].All(char.IsDigit))
            {
                string com = command ?? "town";
                string msg = "SyntaxCommand" + char.ToUpper(com[0]) + com.Substring(1);
                PrintMsgL(player, msg);
                if (IsAllowed(player)) PrintMsgL(player, msg + "Admin");
                return;
            }

            if (!settings.Teleports.TPData.TryGetValue(player.userID, out var teleportData))
            {
                settings.Teleports.TPData[player.userID] = teleportData = new TeleportData();
            }
            int limit = 0;
            var timestamp = Facepunch.Math.Epoch.Current;
            var currentDate = DateTime.Now.ToString("d");
            var mode = command == "bandit" ? "bandit" : command == "outpost" ? "outpost" : "town";
            // Setup vars for checks below
            string err = null;
            if (!CanBypassRestrictions(player.UserIDString))
            {
                var getUseableTime = GetUseableTime(player, settings.Hours);
                if (getUseableTime > 0.0)
                {
                    PrintMsgL(player, "NotUseable", FormatTime(player, getUseableTime));
                    return;
                }
                err = CheckPlayer(player, settings.UsableOutOfBuildingBlocked, settings.CanCraft(player, command), true, mode, settings.CanCave(player, command));
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                var cooldown = GetLower(player, settings.VIPCooldowns, settings.Cooldown);

                if (teleportData.Date != currentDate)
                {
                    teleportData.Amount = 0;
                    teleportData.Date = currentDate;
                }
                limit = GetHigher(player, settings.VIPDailyLimits, settings.DailyLimit, true);
#if DEBUG
                Puts("Calling CheckPlayer from cmdChatTown");
#endif

                // Check and process cooldown, bypass, and payment for all modes
                if (cooldown > 0 && timestamp - teleportData.Timestamp < cooldown)
                {
                    var cmdSent = args.Length >= 1 ? args[0].ToLower() : string.Empty;

                    if (!string.IsNullOrEmpty(config.Settings.BypassCMD))
                    {
                        if (cmdSent == config.Settings.BypassCMD.ToLower() && settings.Bypass > -1)
                        {
                            bool foundmoney = CheckEconomy(player, settings.Bypass);

                            if (foundmoney)
                            {
                                CheckEconomy(player, settings.Bypass, true);
                                paidmoney = true;

                                if (settings.Bypass > 0)
                                {
                                    PrintMsgL(player, "DM_TownTPCooldownBypass", settings.Bypass);
                                }

                                if (settings.Pay > 0)
                                {
                                    PrintMsgL(player, "PayToTown", settings.Pay, language);
                                }
                            }
                            else
                            {
                                PrintMsgL(player, "DM_TownTPCooldownBypassF", settings.Bypass);
                                return;
                            }
                        }
                        else if (UseEconomy())
                        {
                            if (Interface.CallHook("OnTeleportCooldownNotify", player) != null)
                            {
                                return;
                            }
                            var remain = cooldown - (timestamp - teleportData.Timestamp);
                            PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));
                            if (settings.Bypass > -1)
                            {
                                PrintMsgL(player, "DM_TownTPCooldownBypassP", settings.Bypass);
                                PrintMsgL(player, "DM_TownTPCooldownBypassP2", language, config.Settings.BypassCMD);
                            }
                            return;
                        }
                        else
                        {
                            if (Interface.CallHook("OnTeleportCooldownNotify", player) != null)
                            {
                                return;
                            }
                            var remain = cooldown - (timestamp - teleportData.Timestamp);
                            PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));
                            return;
                        }
                    }
                    else
                    {
                        if (Interface.CallHook("OnTeleportCooldownNotify", player) != null)
                        {
                            return;
                        }
                        var remain = cooldown - (timestamp - teleportData.Timestamp);
                        PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));
                        return;
                    }
                }

                if (limit > 0 && teleportData.Amount >= limit)
                {
                    var left = FormatTime(player, (int)SecondsUntilTomorrow());
                    PrintMsgL(player, "DM_TownTPLimitReached", limit, left);
                    return;
                }
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }

            Vector3 location;
            if (args.Length == 1 && int.TryParse(args[0], out var index))
            {
                index = Mathf.Clamp(index, 0, settings.Locations.Count - 1);
                location = settings.Locations[index];
            }
            else if (settings.Random)
            {
                location = settings.Locations.GetRandom();
            }
            else if (Vector3.Distance(settings.Location, Vector3.zero) > 5f)
            {
                location = settings.Location;
            }
            else location = settings.Locations[0];

            if (!CanBypassRestrictions(player.UserIDString))
            {
                err = CanPlayerTeleport(player, location, player.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CheckItems(player);
                if (err != null)
                {
                    PrintMsgL(player, "TPBlockedItem", err);
                    return;
                }
            }
            int countdown = GetLower(player, settings.VIPCountdowns, settings.Countdown);
            TeleportTimers[player.userID] = new()
            {
                Town = command,
                OriginPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts($"Calling CheckPlayer from cmdChatTown {command} timer loop");
#endif
                    if (!CanBypassRestrictions(player.UserIDString))
                    {
                        if (!TeleportInForcedBoundary(player))
                        {
                            return;
                        }
                        if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                        {
                            PrintMsgL(player, "CannotTeleportFromHome");
                            return;
                        }
                        err = CheckPlayer(player, settings.UsableOutOfBuildingBlocked, settings.CanCraft(player, command), true, mode, settings.CanCave(player, command));
                        if (err != null)
                        {
                            Interrupt(player, paidmoney, settings.Bypass);
                            PrintMsgL(player, err);
                            return;
                        }
                        err = CanPlayerTeleport(player, location, player.transform.position);
                        if (err != null)
                        {
                            Interrupt(player, paidmoney, settings.Bypass);
                            PrintMsgL(player, err);
                            return;
                        }
                        err = CheckItems(player);
                        if (err != null)
                        {
                            Interrupt(player, paidmoney, settings.Bypass);
                            PrintMsgL(player, "TPBlockedItem", err);
                            return;
                        }
                        if (settings.Locations.Count == 0)
                        {
                            Interrupt(player, paidmoney, settings.Bypass);
                            return;
                        }
                        if (UseEconomy())
                        {
                            if (settings.Pay < 0)
                            {
                                return;
                            }
                            if (settings.Pay > 0 && !CheckEconomy(player, settings.Pay))
                            {
                                Interrupt(player, false, 0);
                                PrintMsgL(player, "TPNoMoney", settings.Pay);
                                return;
                            }
                            if (settings.Pay > -1 && !paidmoney)
                            {
                                CheckEconomy(player, settings.Pay, true);

                                if (settings.Pay > 0)
                                {
                                    PrintMsgL(player, "TPMoney", (double)settings.Pay);
                                }
                            }
                        }
                    }
                    Teleport(player, location, command, 0uL, town: true, allowTPB: settings.AllowTPB, build: settings.UsableOutOfBuildingBlocked, craft: settings.CanCraft(player, command), cave: settings.CanCave(player, command));
                    teleportData.Amount++;
                    teleportData.Timestamp = timestamp;
                    settings.Teleports.Changed = true;
                    PrintMsgL(player, "DM_TownTP", language);
                    if (limit > 0) PrintMsgL(player, "DM_TownTPAmount", limit - teleportData.Amount, language);
                    TeleportTimers.Remove(player.userID);
                })
            };

            if (countdown > 0)
            {
                PrintMsgL(player, "DM_TownTPStarted", language, countdown);
                Interface.CallHook("OnTownAccepted", player, language, countdown);
            }
        }

        private double SecondsUntilTomorrow()
        {
            var tomorrow = DateTime.Now.AddDays(1).Date;
            return (tomorrow - DateTime.Now).TotalSeconds;
        }

        private void Interrupt(BasePlayer player, bool paidmoney, double bypass)
        {
            PrintMsgL(player, "Interrupted");
            if (paidmoney)
            {
                CheckEconomy(player, bypass, false, true);
            }
            TeleportTimers.Remove(player.userID);
        }

        private void CommandTeleportII(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!user.IsAdmin && !IsAllowedMsg(player, PermTpConsole)) return;

            List<BasePlayer> players;
            switch (command)
            {
                case "teleport.topos":
                    if (args.Length < 4)
                    {
                        user.Reply(_("SyntaxConsoleCommandToPos", player));
                        return;
                    }
                    players = FindPlayers(args[0], true);
                    if (players.Count <= 0)
                    {
                        user.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        user.Reply(_("MultiplePlayers", player, GetMultiplePlayers(players)));
                        return;
                    }
                    var targetPlayer = players[0];
                    players.Clear();
                    float x;
                    if (!float.TryParse(args[1], out x)) x = -10000f;
                    float y;
                    if (!float.TryParse(args[2], out y)) y = -10000f;
                    float z;
                    if (!float.TryParse(args[3], out z)) z = -10000f;
                    if (!CheckBoundaries(x, y, z))
                    {
                        user.Reply(_("AdminTPOutOfBounds", player) + System.Environment.NewLine + _("AdminTPBoundaries", player, boundary));
                        return;
                    }
                    Teleport(targetPlayer, x, y, z);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(targetPlayer, "AdminTPConsoleTP", targetPlayer.transform.position);
                    user.Reply(_("AdminTPTargetCoordinates", player, targetPlayer.displayName, targetPlayer.transform.position));
                    Puts(_("LogTeleportPlayer", null, player?.displayName, targetPlayer.displayName, targetPlayer.transform.position));
                    break;
                case "teleport.toplayer":
                    if (args.Length < 2)
                    {
                        user.Reply(_("SyntaxConsoleCommandToPlayer", player));
                        return;
                    }
                    players = FindPlayers(args[0], true);
                    if (players.Count <= 0)
                    {
                        user.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        user.Reply(_("MultiplePlayers", player, GetMultiplePlayers(players)));
                        return;
                    }
                    var originPlayer = players[0];
                    players = FindPlayers(args[1], true);
                    if (players.Count <= 0)
                    {
                        user.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        user.Reply(_("MultiplePlayers", player, GetMultiplePlayers(players)));
                        players.Clear();
                        return;
                    }
                    targetPlayer = players[0];
                    if (targetPlayer == originPlayer)
                    {
                        players.Clear();
                        user.Reply(_("CantTeleportPlayerToSelf", player));
                        return;
                    }
                    players.Clear();
                    Teleport(originPlayer, targetPlayer);
                    user.Reply(_("AdminTPPlayers", player, originPlayer.displayName, targetPlayer.displayName));
                    PrintMsgL(originPlayer, "AdminTPConsoleTPPlayer", targetPlayer.displayName);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(targetPlayer, "AdminTPConsoleTPPlayerTarget", originPlayer.displayName);
                    Puts(_("LogTeleportPlayer", null, player?.displayName, originPlayer.displayName, targetPlayer.displayName));
                    break;
            }
        }

        private void CommandSphereMonuments(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (player == null || !player.IsAdmin) return;
            if (args.Contains("drawmonuments"))
            {
                var diameter = args.Length > 1 && float.TryParse(args[1], out var r) ? Mathf.Min(r, World.Size) : 200f;
                CommandDrawChecks(player, player.transform.position, diameter);
                return;
            }
            if (args.Contains("drawtopology"))
            {
                var diameter = args.Length > 1 && float.TryParse(args[1], out var r) ? Mathf.Min(r, World.Size) : 200f;
                CommandDrawTopology(player, player.transform.position, diameter);
                return;
            }
            foreach (var mi in monuments)
            {
                if (mi.sphere)
                {
                    DrawSphere(player, 30f, Color.black, mi.position, mi.extents.Max());
                }
                else DrawMonument(player, mi.position, mi.extents, mi.rotation, Color.blue, 30f);
                DrawText(player, 30f, Color.blue, mi.position, mi.name);
            }
            foreach (var (cave, vector) in caves)
            {
                string name = cave.Contains(':') ? cave[..cave.LastIndexOf(':')] : cave.TrimEnd();
                DrawSphere(player, 30f, Color.black, vector, 25f);
                DrawText(player, 30f, Color.cyan, vector, name);
            }
        }

        private void CommandDrawChecks(BasePlayer player, Vector3 a, float diameter)
        {
            int minPos = (int)(diameter / -2f);
            int maxPos = (int)(diameter / 2f);

            for (float x = minPos; x < maxPos; x += 5f)
            {
                for (float z = minPos; z < maxPos; z += 5f)
                {
                    var pos = new Vector3(a.x + x, 0f, a.z + z);

                    pos.y = TerrainMeta.HeightMap.GetHeight(pos);

                    var res = NearMonument(pos, false, "test") != null;

                    if (res) DrawText(player, 15f, Color.red, pos, "X");
                }
            }
        }

        private void CommandDrawTopology(BasePlayer player, Vector3 a, float diameter)
        {
            int minPos = (int)(diameter / -2f);
            int maxPos = (int)(diameter / 2f);

            for (float x = minPos; x < maxPos; x += 5f)
            {
                for (float z = minPos; z < maxPos; z += 5f)
                {
                    var pos = new Vector3(a.x + x, 0f, a.z + z);

                    pos.y = TerrainMeta.HeightMap.GetHeight(pos);

                    var res = IsMonument(pos); // ContainsTopology(TerrainTopology.Enum.Building | TerrainTopology.Enum.Monument, pos, 5f);

                    if (res) DrawText(player, 15f, Color.magenta, pos, "X");
                }
            }
        }

        private bool IsMonument(Vector3 v) => HasMonumentTopology(v) && !IsCave(v) && HasPreventBuildingCollider(v);

        private bool HasMonumentTopology(Vector3 v) => (TerrainMeta.TopologyMap.GetTopology(v, 5f) & (int)TerrainTopology.Enum.Monument) != 0;

        private bool IsCave(Vector3 v) => GamePhysics.CheckSphere<TerrainCollisionTrigger>(v, 5f, 262144, QueryTriggerInteraction.Collide);

        private bool HasPreventBuildingCollider(Vector3 v)
        {
            List<Collider> obj = Pool.Get<List<Collider>>();
            Vis.Colliders(v, 0f, obj, Layers.Mask.Prevent_Building | Layers.Mask.Trigger);
            bool preventbuilding = false;
            bool safezone = false;
            foreach (var collider in obj)
            {
                if (!preventbuilding && collider.gameObject.layer == (int)Layer.Prevent_Building)
                {
                    preventbuilding = true;
                }
                else if (!safezone && collider.GetComponent<TriggerSafeZone>() != null)
                {
                    safezone = true;
                }
            }
            Pool.FreeUnmanaged(ref obj);
            return preventbuilding && !safezone;
        }

        private void CommandImportHomes(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;

            if (!user.IsAdmin && !IsAllowedMsg(player, PermImportHomes))
            {
                user.Reply(_("NotAllowed", player));
                return;
            }
            var fileName = string.IsNullOrEmpty(config.Settings.DataFileFolder) ? "m-Teleportation" : $"{config.Settings.DataFileFolder}{Path.DirectorySeparatorChar}m-Teleportation";
            var datafile = Interface.Oxide.DataFileSystem.GetFile(fileName);
            if (!datafile.Exists())
            {
                user.Reply("No m-Teleportation.json exists.");
                return;
            }
            datafile.Load();
            var allHomeData = datafile["HomeData"] as Dictionary<string, object>;
            if (allHomeData == null)
            {
                user.Reply(_("HomeListEmpty", player));
                return;
            }
            var count = 0;
            foreach (var kvp in allHomeData)
            {
                var homeDataOld = kvp.Value as Dictionary<string, object>;
                if (homeDataOld == null) continue;
                if (!homeDataOld.ContainsKey("HomeLocations")) continue;
                var homeList = homeDataOld["HomeLocations"] as Dictionary<string, object>;
                if (homeList == null) continue;
                var userId = Convert.ToUInt64(kvp.Key);
                HomeData homeData;
                if (!_Home.TryGetValue(userId, out homeData))
                    _Home[userId] = homeData = new HomeData();
                var target = RustCore.FindPlayerById(userId);
                foreach (var kvp2 in homeList)
                {
                    var positionData = kvp2.Value as Dictionary<string, object>;
                    if (positionData == null) continue;
                    if (!positionData.ContainsKey("x") || !positionData.ContainsKey("y") || !positionData.ContainsKey("z")) continue;
                    var position = new Vector3(Convert.ToSingle(positionData["x"]), Convert.ToSingle(positionData["y"]), Convert.ToSingle(positionData["z"]));
                    homeData.Set(kvp2.Key, new HomeData.Entry(position));
                    changedHome = true;
                    count++;
                    Interface.CallHook("OnHomeAdded", target, position, kvp2.Key);
                }
            }
            user.Reply(string.Format("Imported {0} homes.", count));
            if (!user.IsServer) Puts("Imported {0} homes.", count);
        }

        private void RequestTimedOut(BasePlayer player, BasePlayer target)
        {
            PlayersRequests.Remove(player.userID);
            PlayersRequests.Remove(target.userID);
            PendingRequests.Remove(target.userID);
            PrintMsgL(player, "TimedOut", target.displayName);
            PrintMsgL(target, "TimedOutTarget", player.displayName);
        }

        private void CommandPluginInfo(IPlayer user, string command, string[] args)
        {
            command = command.ToLower();
            if (!user.IsServer) return;
            user.Reply($"01. {permission.GetPermissionGroups("nteleportation.tp").Length}");
            user.Reply($"02. {permission.GetPermissionGroups("nteleportation.admin").Length}");
            user.Reply($"03. {permission.GetPermissionUsers("nteleportation.tp").Length}");
            user.Reply($"04. {permission.GetPermissionUsers("nteleportation.admin").Length}");
            user.Reply($"05. {permission.GroupHasPermission("admin", "nteleportation.tp")}");
            user.Reply($"06. {permission.GroupHasPermission("admin", "nteleportation.admin")}");
            user.Reply($"07. {permission.GroupHasPermission("default", "nteleportation.tp")}");
            user.Reply($"08. {permission.GroupHasPermission("default", "nteleportation.admin")}");
            user.Reply($"09. {BasePlayer.activePlayerList.Count(x => x?.Connection?.authLevel > 0)}");
            user.Reply($"10. {BasePlayer.activePlayerList.Count(x => IsAllowed(x))}");
            user.Reply($"11. {BasePlayer.activePlayerList.Count}");
        }

        #region Util

        private readonly System.Text.StringBuilder _sb = new System.Text.StringBuilder();

        private string FormatTime(BasePlayer player, double seconds) // Credits MoNaH
        {
            if (config.Settings.UseSeconds) return $"{seconds} {_("Seconds", player)}";

            TimeSpan _ts = TimeSpan.FromSeconds(seconds);

            _sb.Length = 0;

            if (_ts.TotalDays >= 1)
            {
                _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Days}</color> {_("Days", player)} ");
            }

            if (_ts.TotalHours >= 1)
            {
                _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Hours}</color> {_("Hours", player)} ");
            }

            if (_ts.TotalMinutes >= 1)
            {
                _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Minutes}</color> {_("Minutes", player)} ");
            }

            _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Seconds}</color> {_("Seconds", player)} ");

            return _sb.ToString();
        }

        #endregion

        #region Teleport

        public void Teleport(BasePlayer player, BasePlayer target, bool build = true, bool craft = true, bool cave = true) => Teleport(player, target.transform.position, "", target.userID, town: false, allowTPB: true, build: build, craft: craft, cave: cave);

        public void Teleport(BasePlayer player, float x, float y, float z, bool build = true, bool craft = true, bool cave = true) => Teleport(player, new Vector3(x, y, z), "", 0uL, town: false, allowTPB: true, build: build, craft: craft, cave: cave);

        [HookMethod("Teleport")]
        public void Teleport(BasePlayer player, Vector3 newPosition, string home, ulong uid, bool town, bool allowTPB, bool build = true, bool craft = true, bool cave = true)
        {
            if (!player.IsValid())
            {
                return;
            }

            if (Vector3.Distance(newPosition, Vector3.zero) < 5f)
            {
                return;
            }

            if (allowTPB)
            {
                if (config.Settings.TPB.Time > 0)
                {
                    RemoveLocation(player);
                    Vector3 position = player.transform.position;
                    timer.In(config.Settings.TPB.Time, () => SaveLocation(player, position, home, uid, town, build, craft, cave));
                }
                else SaveLocation(player, player.transform.position, home, uid, town, build, craft, cave);
            }

            if (config.Settings.PlaySoundsBeforeTeleport)
            {
                SendEffect(player, config.Settings.DisappearEffects);
            }

            newPosition.y += 0.1f;

            teleporting[player.userID] = newPosition;

            Subscribe(nameof(OnPlayerViolation));

            var oldPosition = player.transform.position;

            // credits to @ctv and @Def for their assistance

            player.PauseFlyHackDetection(5f);
            player.PauseSpeedHackDetection(5f);
            player.UpdateActiveItem(default);
            player.EnsureDismounted();
            player.Server_CancelGesture();

            if (player.HasParent())
            {
                player.SetParent(null, true, true);
            }

            if (player.IsConnected)
            {
                StartSleeping(player);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
                player.ClientRPC(RpcTarget.Player(config.Settings.Quick ? "StartLoading_Quick" : "StartLoading", player), arg1: true);
            }

            player.Teleport(newPosition);

            if (player.IsConnected)
            {
                if (!player._limitedNetworking)
                {
                    player.UpdateNetworkGroup();
                    player.SendNetworkUpdateImmediate(false);
                }

                player.ClearEntityQueue(null);
                player.SendFullSnapshot();
                if (CanWake(player)) player.Invoke(() =>
                {
                    if (player && player.IsConnected)
                    {
                        if (player.limitNetworking) EndSleeping(player);
                        else player.EndSleeping();
                    }
                }, 0.5f);
            }

            if (!player._limitedNetworking)
            {
                player.ForceUpdateTriggers();
            }

            timer.Once(3f, () => RemoveProtections(player.userID));

            SetGlobalCooldown(player);

            if (config.Settings.PlaySoundsAfterTeleport)
            {
                SendEffect(player, config.Settings.ReappearEffects);
            }

            Interface.CallHook("OnPlayerTeleported", player, oldPosition, newPosition);
        }

        private bool CanWake(BasePlayer player)
        {
            if (!config.Settings.AutoWakeUp) return false;
            return player.IsOnGround() || player.limitNetworking || player.IsFlying || player.IsAdmin;
        }

        public void RemoveProtections(ulong userid)
        {
            teleporting.Remove(userid);
        }

        public void StartSleeping(BasePlayer player) // custom as to not cancel crafting, or remove player from vanish
        {
            if (!player.IsSleeping())
            {
                Interface.CallHook("OnPlayerSleep", player);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, b: true);
                player.sleepStartTime = Time.time;
                BasePlayer.sleepingPlayerList.Add(player);
                player.CancelInvoke("InventoryUpdate");
                player.CancelInvoke("TeamUpdate");
                player.inventory.loot.Clear();
                player.inventory.containerMain.OnChanged();
                player.inventory.containerBelt.OnChanged();
                player.inventory.containerWear.OnChanged();
                player.Invoke("TurnOffAllLights", 0f);
                if (!player._limitedNetworking)
                {
                    player.EnablePlayerCollider();
                    player.RemovePlayerRigidbody();
                }
                else player.RemoveFromTriggers();
                player.SetServerFall(wantsOn: true);
            }
        }

        private void EndSleeping(BasePlayer player)
        {
            if (player.IsSleeping())
            {
                if (player.IsRestrained)
                {
                    player.inventory.SetLockedByRestraint(flag: true);
                }
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, b: false);
                player.sleepStartTime = -1f;
                BasePlayer.sleepingPlayerList.Remove(player);
                player.CancelInvoke(player.ScheduledDeath);
                player.InvokeRepeating("InventoryUpdate", 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
                if (RelationshipManager.TeamsEnabled())
                {
                    player.InvokeRandomized(player.TeamUpdate, 1f, 4f, 1f);
                }
                player.InvokeRandomized(player.UpdateClanLastSeen, 300f, 300f, 60f);
                player.inventory.containerMain.OnChanged();
                player.inventory.containerBelt.OnChanged();
                player.inventory.containerWear.OnChanged();
                Interface.CallHook("OnPlayerSleepEnded", player);
                EACServer.LogPlayerSpawn(player);
                if (player.State?.pings?.Count > 0)
                {
                    player.SendPingsToClient();
                }
                if (TutorialIsland.ShouldPlayerBeAskedToStartTutorial(player))
                {
                    player.ClientRPC(RpcTarget.Player("PromptToStartTutorial", player));
                }
            }
        }

        [PluginReference] Plugin RaidableBases, AbandonedBases;

        private List<string> blockMapMarker = new();

        private void CommandBlockMapMarker(IPlayer user, string command, string[] args)
        {
            if (!blockMapMarker.Remove(user.Id))
            {
                blockMapMarker.Add(user.Id);
            }
        }

        private void OnMapMarkerAdded(BasePlayer player, ProtoBuf.MapNote note)
        {
            if (player.IsAlive() && !blockMapMarker.Contains(player.UserIDString))
            {
                if (permission.UserHasPermission(player.UserIDString, "nteleportation.blocktpmarker"))
                {
                    PrintMsgL(player, "BlockedMarkerTeleport");
                }
                else if (permission.UserHasPermission(player.UserIDString, PermTpMarker))
                {
                    float y = TerrainMeta.HeightMap.GetHeight(note.worldPosition);
                    if (player.IsFlying) y = Mathf.Max(y, player.transform.position.y);
                    if (config.Settings.CheckBoundaries && !CheckBoundaries(note.worldPosition.x, y, note.worldPosition.z))
                    {
                        PrintMsgL(player, "AdminTPOutOfBounds");
                        PrintMsgL(player, "AdminTPBoundaries", boundary);
                    }
                    else if (EventTerritory(note.worldPosition))
                    {
                        PrintMsgL(player, "BlockedMarkerTeleport");
                    }
                    else if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, PermAdmin) && player.IsBuildingBlocked(note.worldPosition, Quaternion.identity, player.bounds))
                    {
                        PrintMsgL(player, "BlockedAuthMarkerTeleport");
                    }
                    else player.Teleport(note.worldPosition + new Vector3(0f, y, 0f));
                }
            }
        }

        private bool EventTerritory(Vector3 worldPosition)
        {
            if (config.Settings.BlockAbandoned && AbandonedBases != null && Convert.ToBoolean(AbandonedBases?.Call("EventTerritory", worldPosition))) return true;
            if (config.Settings.BlockRaidable && RaidableBases != null && Convert.ToBoolean(RaidableBases?.Call("EventTerritory", worldPosition))) return true;
            return false;
        }

        #endregion

        #region Checks
        private string CanPlayerTeleport(BasePlayer player, params Vector3[] vectors)
        {
            if (CanBypassRestrictions(player.UserIDString)) return null;
            foreach (var to in vectors)
            {
                var err = Interface.Oxide.CallHook("CanTeleport", player, to) as string;
                if (!string.IsNullOrEmpty(err)) return err;
            }
            return null;
        }

        private string CanPlayerTeleportHome(BasePlayer player, Vector3 homePos)
        {
            if (CanBypassRestrictions(player.UserIDString)) return null;
            var err = Interface.Oxide.CallHook("CanTeleportHome", player, homePos) as string;
            if (!string.IsNullOrEmpty(err)) return err;
            return null;
        }

        private bool CanCraftHome(BasePlayer player)
        {
            return config.Home.AllowCraft || permission.UserHasPermission(player.UserIDString, PermCraftHome) || CanBypassRestrictions(player.UserIDString);
        }

        private bool CanCaveHome(BasePlayer player)
        {
            return config.Home.AllowCave || permission.UserHasPermission(player.UserIDString, PermCaveHome) || CanBypassRestrictions(player.UserIDString);
        }

        private bool CanCraftTPR(BasePlayer player)
        {
            return config.TPR.AllowCraft || permission.UserHasPermission(player.UserIDString, PermCraftTpR) || CanBypassRestrictions(player.UserIDString);
        }

        private bool CanCaveTPR(BasePlayer player)
        {
            return config.TPR.AllowCave || permission.UserHasPermission(player.UserIDString, PermCaveTpR) || CanBypassRestrictions(player.UserIDString);
        }

        private List<string> monumentExceptions = new() { "outpost", "bandit", "substation", "swamp", "compound.prefab" };

        private bool IsInAllowedMonument(Vector3 target, string mode)
        {
            foreach (var mi in monuments)
            {
                if (config.Settings.Interrupt.BypassMonumentMarker && mi.prefab.Contains("monument_marker"))
                {
                    continue;
                }
                if (mi.IsInBounds(target))
                {
                    if (monumentExceptions.Exists(mi.name.ToLower().Contains))
                    {
                        return true;
                    }
                    return !config.Settings.Interrupt.Monument || mode != "sethome" && config.Settings.Interrupt.Monuments.Exists(value => mi.name.Contains(value, CompareOptions.OrdinalIgnoreCase));
                }
            }
            return false;
        }

        private string NearMonument(Vector3 target, bool check, string mode)
        {
            Dictionary<string, float> data = new();
            foreach (var mi in monuments)
            {
                if (monumentExceptions.Exists(mi.name.ToLower().Contains)) continue;
                if (!check && config.Settings.Interrupt.BypassMonumentMarker && mi.prefab.Contains("monument_marker")) continue;

                float dist = Vector3Ex.Distance2D(target, mi.position);
#if DEBUG
                Puts($"Checking {mi.name} dist: {dist}, realdistance: {mi.extents.Max()}, size: {mi.extents.Max() * 2f}, isinbounds: {mi.IsInBounds(target)}");
#endif
                if (mi.IsInBounds(target))
                {
                    if (config.Home.AllowedMonuments.Exists(m => mi.name.Equals(m, StringComparison.OrdinalIgnoreCase)))
                    {
                        return null;
                    }

                    if (config.Settings.Interrupt.Monuments.Count > 0 && mode != "sethome")
                    {
                        if (config.Settings.Interrupt.Monuments.Exists(value => mi.name.Contains(value, CompareOptions.OrdinalIgnoreCase)))
                        {
#if DEBUG
                            Puts($"{target} in range of {mi.name} at {dist}m {mi.extents} {mi.sphere}");
#endif
                            data[mi.name] = dist;
                        }

                        if (data.Count > 0)
                        {
                            continue;
                        }
#if DEBUG
                        Puts($"{target} is not blocked from {mi.name}");
#endif
                        return null;
                    }
#if DEBUG
                    Puts($"{target} in range of {mi.name} at {dist}m");
#endif
                    data[mi.name] = dist;
                }
            }
            if (data.Count > 0)
            {
                var s = data.OrderByDescending(pair => pair.Value).Take(2).Select(pair => (Name: pair.Key, Distance: pair.Value)).ToList();
                return s.Count > 1 && s[0].Distance > s[1].Distance ? s[1].Name : s[0].Name;
            }
            return null;
        }

        private string CheckPlayer(BasePlayer player, bool build = false, bool craft = false, bool origin = true, string mode = "home", bool allowcave = true)
        {
            if (CanBypassRestrictions(player.UserIDString)) return null;
            if (config.Settings.Interrupt.Oilrig || config.Settings.Interrupt.Excavator || config.Settings.Interrupt.Monument || mode == "sethome")
            {
                string monname = !config.Settings.Interrupt.Safe && player.InSafeZone() ? null : NearMonument(player.transform.position, false, mode);

                if (!string.IsNullOrEmpty(monname))
                {
                    if (mode == "sethome")
                    {
                        if (config.Home.AllowAtAllMonuments || config.Home.AllowedMonuments.Exists(value => monname.Contains(value, CompareOptions.OrdinalIgnoreCase)))
                        {
                            return null;
                        }
                        //player.ChatMessage(monname);
                        return "HomeTooCloseToMon";
                    }
                    else
                    {
                        if (config.Settings.Interrupt.Oilrig && monname.Contains("Oil Rig"))
                        {
                            return "TPOilRig";
                        }

                        if (config.Settings.Interrupt.Excavator && monname.Contains("Excavator"))
                        {
                            return "TPExcavator";
                        }

                        if (config.Settings.Interrupt.Monument)
                        {
                            if (config.Home.AllowedMonuments.Exists(value => monname.Contains(value, CompareOptions.OrdinalIgnoreCase)))
                            {
                                return null;
                            }

                            if (monname.Contains(":")) monname = monname.Substring(0, monname.IndexOf(":"));
                            return _("TooCloseToMon", player, _(monname, player));
                        }
                    }
                }
            }

#if DEBUG
            Puts($"CheckPlayer(): called mode is {mode}");
#endif
            switch (mode)
            {
                case "tpt":
                    allowcave = config.TPT.AllowCave;
                    break;
                case "home":
                    allowcave = config.Home.AllowCave;
                    break;
                case "tpa":
                case "tpr":
                    allowcave = config.TPR.AllowCave;
                    break;
                default:
#if DEBUG
                    Puts("Skipping cave check...");
#endif
                    break;
            }
            if (!allowcave)
            {
#if DEBUG
                Puts("Checking cave distance...");
#endif
                if (IsInCave(player.transform.position))
                {
                    return "TooCloseToCave";
                }
            }

            if (config.Settings.Interrupt.Hostile && (mode == "bandit" || mode == "outpost" || config.Settings.Interrupt.IncludeHostileTown && mode == "town"))
            {
                if (player.State.unHostileTimestamp > TimeEx.currentTimestamp || player.unHostileTime > UnityEngine.Time.realtimeSinceStartup)
                {
                    return "TPHostile";
                }
            }

            if (config.Settings.Interrupt.Junkpiles && IsOnJunkPile(player))
            {
                return "TPJunkpile";
            }

            if (config.Settings.Interrupt.Hurt && origin && player.IsWounded())
            {
                return "TPWounded";
            }

            if (config.Settings.Interrupt.Cold && player.metabolism.temperature.value <= config.Settings.MinimumTemp)
            {
                return "TPTooCold";
            }

            if (config.Settings.Interrupt.Hot && player.metabolism.temperature.value >= config.Settings.MaximumTemp)
            {
                return "TPTooHot";
            }

            if (config.Settings.Interrupt.Swimming && player.IsSwimming())
            {
                return "TPSwimming";
            }

            if (config.Settings.Interrupt.Cargo && player.GetComponentInParent<CargoShip>())
            {
                return "TPCargoShip";
            }

            if (config.Settings.Interrupt.Balloon && player.GetComponentInParent<HotAirBalloon>())
            {
                return "TPHotAirBalloon";
            }

            if (config.Settings.Interrupt.Lift && player.GetComponentInParent<Lift>())
            {
                return "TPBucketLift";
            }

            if (config.Settings.Interrupt.Lift && GetLift(player.transform.position))
            {
                return "TPRegLift";
            }

            if (config.Settings.Interrupt.Safe && player.InSafeZone())
            {
                return "TPSafeZone";
            }

            if (!craft && player.inventory.crafting.queue.Count > 0)
            {
                return "TPCrafting";
            }

            if (player.IsDead())
            {
                return "TPDead";
            }

            if (!build && !player.CanBuild())
            {
                return "TPBuildingBlocked";
            }

            if (config.Settings.BlockZoneFlag && ZoneManager != null && Convert.ToBoolean(ZoneManager?.Call("PlayerHasFlag", player, "notp")))
            {
                return "TPFlagZone";
            }

            if (config.Settings.BlockNoEscape && NoEscape != null && Convert.ToBoolean(NoEscape?.Call("IsBlocked", player)))
            {
                return "TPNoEscapeBlocked";
            }

            if (config.Settings.RaidBlock && RaidBlock != null && Convert.ToBoolean(RaidBlock?.Call("IsBlocked", player)))
            {
                return "TPNoEscapeBlocked";
            }

            var entity = GetStandingOnEntity<BaseMountable>(player, 1f, Layers.Mask.Vehicle_Detailed | Layers.Mask.Vehicle_Large);

            if (entity is BaseMountable)
            {
                if (entity is Tugboat)
                {
                    return !config.Home.AllowTugboats && !permission.UserHasPermission(player.UserIDString, "nteleportation.tugboatsinterruptbypass") ? "TPTugboat" : null;
                }

                if (config.Settings.Interrupt.Boats && entity is BaseBoat)
                {
                    return "TPBoat";
                }

                if (config.Settings.Interrupt.Mounted)
                {
                    //var ent1 = player.HasParent() && FindEntity<BaseMountable>(player.GetParentEntity()) is BaseMountable m1 ? m1.ShortPrefabName : "N/A";
                    //var ent2 = player.isMounted && FindEntity<BaseMountable>(player.GetMounted()) is BaseMountable m2 ? m2.ShortPrefabName : "N/A";
                    //var ent3 = GetStandingOnEntity<BaseMountable>(player.transform.position, 1f, Layers.Mask.Vehicle_Detailed | Layers.Mask.Vehicle_Large) is BaseMountable m3 ? m3.ShortPrefabName : "N/A";

                    //return $"{_("TPMounted", player)} (parent: {ent1}, mount: {ent2}, stand: {ent3})";
                    return "TPMounted";
                }
            }

            if (IsWaterBlockedAbove(player, entity))
            {
                return "TPAboveWater";
            }

            if (config.Settings.Interrupt.UnderWater && Math.Round(player.transform.position.y, 2) < Math.Round(TerrainMeta.WaterMap.GetHeight(player.transform.position), 2) && !IsInAllowedMonument(player.transform.position, mode))
            {
                return "TPUnderWater";
            }

            return null;
        }

        private bool IsWaterBlockedAbove(BasePlayer player, BaseEntity entity)
        {
            if (!config.Settings.Interrupt.AboveWater || !AboveWater(player.transform.position))
            {
                return false;
            }
            if ((config.Home.AllowTugboats || permission.UserHasPermission(player.UserIDString, "nteleportation.tugboatsinterruptbypass")) && entity is Tugboat)
            {
                return false;
            }
            if (!config.Settings.Interrupt.Boats && entity != null && entity.ShortPrefabName != "tugboat" && entity is BaseBoat)
            {
                return false;
            }
            return true;
        }

        private string CheckTargetLocation(BasePlayer player, Vector3 targetLocation, bool usableIntoBuildingBlocked, bool cupOwnerAllowOnBuildingBlocked)
        {
            if (CanBypassRestrictions(player.UserIDString)) return null;
            // ubb == UsableIntoBuildingBlocked
            // obb == CupOwnerAllowOnBuildingBlocked
            bool denied = false;
            var entities = FindEntitiesOfType<BaseEntity>(targetLocation, 3f, Layers.Mask.Construction | Layers.Mask.Vehicle_Large);
            foreach (var entity in entities)
            {
                if (entity is Tugboat)
                {
                    entities.ResetToPool();
                    if (usableIntoBuildingBlocked || player.CanBuild(entity.WorldSpaceBounds())) return null;
                    return "TPTargetBuildingBlocked";
                }
                if (!(entity is BuildingBlock block))
                {
                    continue;
                }
                if (CheckCupboardBlock(block, player, cupOwnerAllowOnBuildingBlocked))
                {
                    denied = false;
#if DEBUG
                    Puts("Cupboard either owned or there is no cupboard");
#endif
                }
                else if (usableIntoBuildingBlocked && player.userID != block.OwnerID)
                {
                    denied = false;
#if DEBUG
                    Puts("Player does not own block, but UsableIntoBuildingBlocked=true");
#endif
                }
                else if (player.userID == block.OwnerID)
                {
#if DEBUG
                    Puts("Player owns block");
#endif

                    if (!player.IsBuildingBlocked(targetLocation, Quaternion.identity, block.bounds))
                    {
#if DEBUG
                        Puts("Player not BuildingBlocked. Likely unprotected building.");
#endif
                        denied = false;
                        break;
                    }
                    else if (usableIntoBuildingBlocked)
                    {
#if DEBUG
                        Puts("Player not blocked because UsableIntoBuildingBlocked=true");
#endif
                        denied = false;
                        break;
                    }
                    else
                    {
#if DEBUG
                        Puts("Player owns block but blocked by UsableIntoBuildingBlocked=false");
#endif
                        denied = true;
                        break;
                    }
                }
                else
                {
#if DEBUG
                    Puts("Player blocked");
#endif
                    denied = true;
                    break;
                }
            }
            entities.ResetToPool();
            return denied ? "TPTargetBuildingBlocked" : null;
        }

        // Check that a building block is owned by/attached to a cupboard, allow tp if not blocked unless allowed by config
        private bool CheckCupboardBlock(BuildingBlock block, BasePlayer player, bool cupOwnerAllowOnBuildingBlocked)
        {
            // obb == CupOwnerAllowOnBuildingBlocked
            var building = block.GetBuilding();
            if (building != null)
            {
#if DEBUG
                Puts("Found building, checking privileges...");
                Puts($"Building ID: {building.ID}");
#endif
                // cupboard overlap.  Check privs.
                if (building.buildingPrivileges == null)
                {
#if DEBUG
                    Puts("No cupboard found, allowing teleport");
#endif
                    return true;
                }

                foreach (var priv in building.buildingPrivileges)
                {
                    if (priv.IsAuthed(player))
                    {
#if DEBUG
                        Puts("Player is authorized to the cupboard");
#endif
                        return true;
                    }
                }

                if (player.userID == block.OwnerID)
                {
                    if (cupOwnerAllowOnBuildingBlocked)
                    {
#if DEBUG
                        // player set the cupboard and is allowed in by config
                        Puts("Player owns cupboard with no auth, but allowed by CupOwnerAllowOnBuildingBlocked=true");
#endif
                        return true;
                    }
#if DEBUG
                    // player set the cupboard but is blocked by config
                    Puts("Player owns cupboard with no auth, but blocked by CupOwnerAllowOnBuildingBlocked=false");
#endif
                    return false;
                }

#if DEBUG
                // player not authed
                Puts("Player does not own cupboard and is not authorized");
#endif
                return false;
            }
#if DEBUG
            Puts("No cupboard or building found - we cannot tell the status of this block");
#endif
            return true;
        }

        private string CheckItems(BasePlayer player)
        {
            var backpack = player.inventory.GetBackpackWithInventory();
            foreach (var blockedItem in ReverseBlockedItems)
            {
                if (player.inventory.FindItemByItemID(blockedItem.Key) != null)
                {
                    return blockedItem.Value;
                }
                if (backpack != null && backpack.contents.FindItemByItemID(blockedItem.Key) != null)
                {
                    return blockedItem.Value;
                }
            }
            return null;
        }

        private static List<T> FindEntitiesOfType<T>(Vector3 a, float n, int m = -1) where T : BaseEntity
        {
            List<T> entities = Pool.Get<List<T>>();
            entities.Clear();
            Vis.Entities(a, n, entities, m, QueryTriggerInteraction.Collide);
            entities.RemoveAll(x => x.IsKilled());
            return entities;
        }

        private bool IsInsideEntity(Vector3 a)
        {
            bool faces = Physics.queriesHitBackfaces;
            Physics.queriesHitBackfaces = true;
            RaycastHit hit;
            bool isHit = Physics.Raycast(a + new Vector3(0f, 0.015f, 0f), Vector3.up, out hit, 7f, Layers.Mask.Construction | Layers.Mask.Deployed, QueryTriggerInteraction.Ignore);
            Physics.queriesHitBackfaces = faces;
            if (isHit)
            {
                var e = hit.GetEntity();
                if (e == null || e.PrefabName.Contains(".grill") || e.PrefabName.Contains("hatch"))
                {
                    return false;
                }
                if (e is BuildingBlock)
                {
                    return e.ShortPrefabName.Contains("foundation");
                }
                if (e is SimpleBuildingBlock || e is IceFence || e is ElectricBattery || e is Door || e is BaseOven)
                {
                    return Math.Round(a.y, 2) < Math.Round(hit.point.y, 2);
                }
            }
            return false;
        }

        private string IsInsideEntity(Vector3 targetLocation, ulong userid, string mode)
        {
            if (IsInsideEntity(targetLocation))
            {
                return "TPTargetInsideEntity";
            }
            if (config.Settings.Rock && NearMonument(targetLocation, true, mode) == null && Exploits.TestInsideRock(targetLocation))
            {
                LogToFile("exploiters", $"{userid} sethome inside a rock at {targetLocation}", this, true);
                PrintMsgL(userid, "TPTargetInsideRock");
                return "TPTargetInsideRock";
            }
            return null;
        }

        private bool UnderneathFoundation(Vector3 a)
        {
            RaycastHit hit;
            if (Physics.Raycast(a + new Vector3(0f, 3f, 0f), Vector3.down, out hit, 5f, Layers.Mask.Construction, QueryTriggerInteraction.Ignore))
            {
                var e = hit.GetEntity();

                if (e is BuildingBlock && e.ShortPrefabName.Contains("foundation"))
                {
                    return Math.Round(a.y, 2) < Math.Round(hit.point.y, 2);
                }
            }
            return false;
        }

        private string CheckFoundation(ulong userid, Vector3 position, string mode)
        {
            if (CanBypassRestrictions(userid.ToString())) return null;
            string insideErr = IsInsideEntity(position, userid, mode);
            if (insideErr != null)
            {
                return insideErr;
            }
            if (IsBlockedOnIceberg(position))
            {
                return "HomeIce";
            }
            if (!config.Home.ForceOnTopOfFoundation || permission.UserHasPermission(userid.ToString(), PermFoundationCheck))
            {
                return null;
            }
            if (UnderneathFoundation(position))
            {
                return "HomeFoundationUnderneathFoundation";
            }
            if (!IsStandingOnEntity(position, 2f, Layers.Mask.Construction | Layers.Mask.Vehicle_Large, out var entity, !config.Home.AllowAboveFoundation ? new string[2] { "foundation", "tugboat" } : new string[3] { "floor", "foundation", "tugboat" }))
            {
                return "HomeNoFoundation";
            }
            if (!config.Home.CheckFoundationForOwner || entity is Tugboat || IsAlly(userid, entity.OwnerID, config.Home.UseTeams, config.Home.UseClans, config.Home.UseFriends))
            {
                return null;
            }
            return "HomeFoundationNotFriendsOwned";
        }

        private bool IsInTrainTunnels(Vector3 a) => EnvironmentManager.Check(a, EnvironmentType.TrainTunnels);

        private bool IsUnderground(Vector3 a) => EnvironmentManager.Check(a, EnvironmentType.Underground);

        private bool IsUnderwaterLab(Vector3 a) => EnvironmentManager.Check(a, EnvironmentType.UnderwaterLab, 1f);

        private bool IsInBounds(BuildingBlock block, Vector3 a)
        {
            OBB obb = new OBB(block.transform.position + new Vector3(0f, 1f), block.transform.lossyScale, block.transform.rotation, block.bounds);
            if (obb.Contains(a))
            {
                return true;
            }
            Matrix4x4 m = Matrix4x4.TRS(block.transform.position, block.transform.rotation, Vector3.one);
            Vector3 v = m.inverse.MultiplyPoint3x4(a);
            Vector3 extents = block.bounds.extents;
            return v.x <= extents.x && v.x > -extents.x && v.y <= extents.y && v.y > -extents.y && v.z <= extents.z && v.z > -extents.z;
        }

        private bool IsBlockedOnIceberg(Vector3 position)
        {
            if (config.Home.AllowIceberg) return false;
            if (!Physics.SphereCast(position + new Vector3(0f, 1f), 1f, Vector3.down, out var hit, 250f, Layers.Mask.Terrain | Layers.Mask.World)) return false;
            return hit.collider.name.Contains("ice_sheet") || hit.collider.name.Contains("iceberg");
        }

        private BuildingBlock GetFoundationOwned(Vector3 position, ulong userID)
        {
            if (!IsStandingOnEntity(position, 2f, Layers.Mask.Construction, out var entity, new string[1] { "foundation" }) || !PassesStrictCheck(entity, position)) return null;
            if (!config.Home.CheckFoundationForOwner || IsAlly(userID, entity.OwnerID, config.Home.UseTeams, config.Home.UseClans, config.Home.UseFriends)) return entity as BuildingBlock;
            return null;
        }

        private bool IsAlly(ulong playerId, ulong targetId, bool useTeams, bool useClans, bool useFriends)
        {
            if (playerId == targetId)
            {
                return true;
            }
            if (useTeams && RelationshipManager.ServerInstance.playerToTeam.TryGetValue(playerId, out var team) && team.members.Contains(targetId))
            {
                return true;
            }
            if (useClans && Clans != null && Clans.IsLoaded && Convert.ToBoolean(Clans?.Call("IsClanMember", playerId.ToString(), targetId.ToString())))
            {
                return true;
            }
            if (useFriends && Friends != null && Friends.IsLoaded && Convert.ToBoolean(Friends?.Call("AreFriends", playerId.ToString(), targetId.ToString())))
            {
                return true;
            }
            return false;
        }

        bool IsBlockedUser(ulong playerid, ulong targetid)
        {
            if (config.TPR.UseBlockedUsers && BlockUsers != null && BlockUsers.IsLoaded)
            {
#if DEBUG
                Puts("Is user blocked? {0} / {1}", playerid, targetid);
#endif
                if (Convert.ToBoolean(BlockUsers?.CallHook("IsBlockedUser", playerid, targetid)))
                {
#if DEBUG
                    Puts("  BlockUsers plugin returned true");
#endif
                    return true;
                }
#if DEBUG
                Puts("  BlockUsers plugin returned false");
#endif
            }
            return false;
        }

        private bool PassesStrictCheck(BaseEntity entity, Vector3 position)
        {
            if (!config.Settings.StrictFoundationCheck || entity is Tugboat)
            {
                return true;
            }
#if DEBUG
            Puts($"PassesStrictCheck() called for {entity.ShortPrefabName}");
#endif
            Vector3 center = entity.CenterPoint();

            if (IsExternalWallOverlapped(center, position)) return false;
#if DEBUG
            Puts($"  Checking block: {entity.name} @ center {center}, pos: {position}");
#endif
            if (entity.PrefabName.Contains("triangle.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.46f && Math.Abs(center.z - position.z) < 0.46f)
                {
#if DEBUG
                    Puts($"    Found: {entity.ShortPrefabName} @ center: {center}, pos: {position}");
#endif
                    return true;
                }
            }
            else if (entity.PrefabName.Contains("foundation.prefab") || entity.PrefabName.Contains("floor.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.7f && Math.Abs(center.z - position.z) < 0.7f)
                {
#if DEBUG
                    Puts($"    Found: {entity.ShortPrefabName} @ center: {center}, pos: {position}");
#endif
                    return true;
                }
            }

            return false;
        }

        private bool IsExternalWallOverlapped(Vector3 center, Vector3 position)
        {
            var walls = FindEntitiesOfType<BaseEntity>(center, 1.5f);
            foreach (var wall in walls)
            {
                if (wall.PrefabName.Contains("external.high"))
                {
#if DEBUG
                    Puts($"    Found: {wall.PrefabName} @ center {center}, pos {position}");
#endif
                    walls.ResetToPool();
                    return true;
                }
            }
            walls.ResetToPool();
            return false;
        }

        private T FindEntity<T>(BaseEntity entity) where T : BaseEntity
        {
            if (entity == null)
            {
                return null;
            }
            if (entity is T val)
            {
                return val;
            }
            if (!entity.HasParent())
            {
                return null;
            }
            var parent = entity.GetParentEntity();
            while (parent != null)
            {
                if (parent is T val2)
                {
                    return val2;
                }
                parent = parent.GetParentEntity();
            }
            return null;
        }

        private T GetStandingOnEntity<T>(BasePlayer player, float distance, int layerMask) where T : BaseEntity
        {
            if (player.HasParent())
            {
                var parent = FindEntity<T>(player.GetParentEntity());
                if (parent != null)
                {
                    return parent;
                }
            }
            if (player.isMounted)
            {
                var mounted = FindEntity<T>(player.GetMounted());
                if (mounted != null)
                {
                    return mounted;
                }
            }
            return GetStandingOnEntity<T>(player.transform.position, distance, layerMask);
        }

        private T GetStandingOnEntity<T>(Vector3 a, float distance, int layerMask) where T : BaseEntity
        {
            if (Physics.Raycast(a + new Vector3(0f, 0.1f, 0f), Vector3.down, out var hit, distance, layerMask, QueryTriggerInteraction.Ignore))
            {
                var entity = hit.GetEntity();
                if (entity is T n) return n;
            }
            if (layerMask != Layers.Mask.Construction)
            {
                var ents = FindEntitiesOfType<T>(a, distance, layerMask);
                T ent = ents.Count > 0 ? ents[0] : null;
                ents.ResetToPool();
                return ent;
            }
            return null;
        }

        private bool IsStandingOnEntity(Vector3 a, float distance, int layerMask, out BaseEntity entity, string[] prefabs)
        {
            entity = GetStandingOnEntity<BaseEntity>(a, distance, layerMask);
            if (entity == null || !PassesStrictCheck(entity, a)) return false;
            return Array.Exists(prefabs, entity.ShortPrefabName.Contains);
        }

        private bool IsCeiling(DecayEntity entity)
        {
            if (entity == null || entity.ShortPrefabName.Contains("roof"))
            {
                return true;
            }
            var building = entity.GetBuilding();
            if (building == null || !building.HasBuildingBlocks())
            {
                return true;
            }
            var data = new Dictionary<double, int>();
            foreach (var block in building.buildingBlocks)
            {
                if (block.IsKilled() || (!block.ShortPrefabName.Contains("floor") && !block.ShortPrefabName.Contains("roof")))
                {
                    continue;
                }
                var j = Math.Round(block.transform.position.y, 2);
                if (data.ContainsKey(j))
                {
                    data[j]++;
                }
                else
                {
                    data[j] = 1;
                }
            }
            var k = Math.Round(entity.transform.position.y, 2);
            var s = data.OrderByDescending(pair => pair.Value).Take(2).Select(pair => (Height: pair.Key, Count: pair.Value)).ToList();
            return s.Count == 0 || k >= (s.Count > 1 && s[1].Count > s[0].Count ? s[1].Height : s[0].Height);
        }

        private bool CheckBoundaries(float x, float y, float z)
        {
            return x <= boundary && x >= -boundary && y <= config.Settings.BoundaryMax && y >= config.Settings.BoundaryMin && z <= boundary && z >= -boundary;
        }

        private Vector3 GetGroundBuilding(Vector3 a)
        {
            a.y = TerrainMeta.HeightMap.GetHeight(a);
            RaycastHit hit;
            if (Physics.Raycast(a.WithY(200f), Vector3.down, out hit, Mathf.Infinity, Layers.Mask.Terrain | Layers.Mask.World | Layers.Mask.Construction | Layers.Mask.Deployed | Layers.Mask.Vehicle_Large, QueryTriggerInteraction.Ignore))
            {
                a.y = Mathf.Max(hit.point.y, a.y);
            }
            return a;
        }

        public bool AboveWater(Vector3 a)
        {
            return TerrainMeta.HeightMap.GetHeight(a) - TerrainMeta.WaterMap.GetHeight(a) < 0;
        }

        private static bool ContainsTopology(TerrainTopology.Enum mask, Vector3 position, float radius)
        {
            return (TerrainMeta.TopologyMap.GetTopology(position, radius) & (int)mask) != 0;
        }

        private bool IsInCave(Vector3 a)
        {
            return GamePhysics.CheckSphere<TerrainCollisionTrigger>(a, 5f, 262144, QueryTriggerInteraction.Collide) && ContainsTopology(TerrainTopology.Enum.Monument, a, 5f);
        }

        private bool GetLift(Vector3 position)
        {
            var lifts = FindEntitiesOfType<ProceduralLift>(position, 0.5f);
            bool result = lifts.Count > 0;
            lifts.ResetToPool();
            return result;
        }

        private bool IsOnJunkPile(BasePlayer player)
        {
            if (player.GetParentEntity() is JunkPile) return true;
            var junkpiles = FindEntitiesOfType<JunkPile>(player.transform.position, 3f, Layers.Mask.World);
            var result = junkpiles.Count > 0;
            junkpiles.ResetToPool();
            return result;
        }

        private bool IsAllowed(BasePlayer player, string perm = null)
        {
            if (player == null || !player.IsConnected)
            {
                return false;
            }

            if (!string.IsNullOrEmpty(perm) && permission.UserHasPermission(player.UserIDString, perm))
            {
                return !player.IsSleeping();
            }

            if (player.net.connection.authLevel == 1)
            {
                return config.Admin.UseableByModerators;
            }
            else if (player.net.connection.authLevel >= 2)
            {
                return config.Admin.UseableByAdmins;
            }

            return false;
        }

        private bool IsAllowedMsg(BasePlayer player, string perm = null)
        {
            if (IsAllowed(player, perm)) return true;
            PrintMsgL(player, "NotAllowed");
            return false;
        }

        private Effect reusableSoundEffectInstance = new Effect();

        private void SendEffect(BasePlayer player, List<string> effects)
        {
            if (effects.Count != 0)
            {
                reusableSoundEffectInstance.Init(Effect.Type.Generic, player, 0, Vector3.zero, Vector3.forward, player.limitNetworking ? player.Connection : null);
                reusableSoundEffectInstance.pooledString = effects.GetRandom();
                if (string.IsNullOrEmpty(reusableSoundEffectInstance.pooledString))
                {
                    return;
                }
                if (player.limitNetworking)
                {
                    EffectNetwork.Send(reusableSoundEffectInstance, player.Connection);
                }
                else EffectNetwork.Send(reusableSoundEffectInstance);
            }
        }

        private int GetHigher(BasePlayer player, Dictionary<string, int> limits, int limit, bool unlimited)
        {
            if (unlimited && limit == 0) return limit;

            foreach (var l in limits)
            {
                if (permission.UserHasPermission(player.UserIDString, l.Key))
                {
                    if (unlimited && l.Value == 0) return l.Value;

                    limit = Math.Max(l.Value, limit);
                }
            }
            return limit;
        }

        private int GetLower(BasePlayer player, Dictionary<string, int> times, int time)
        {
            foreach (var l in times)
            {
                if (permission.UserHasPermission(player.UserIDString, l.Key))
                {
                    time = Math.Min(l.Value, time);
                }
            }
            return time;
        }

        private void CheckPerms(Dictionary<string, int> limits)
        {
            foreach (var limit in limits)
            {
                if (!permission.PermissionExists(limit.Key))
                {
                    permission.RegisterPermission(limit.Key, this);
                }
            }
        }
        #endregion

        #region Message

        protected new static void Puts(string format, params object[] args)
        {
            if (!string.IsNullOrEmpty(format))
            {
                Interface.Oxide.LogInfo("[{0}] {1}", "NTeleportation", (args.Length != 0) ? string.Format(format, args) : format);
            }
        }

        private string _(string msgId, BasePlayer player, params object[] args)
        {
            var msg = lang.GetMessage(msgId, this, player?.UserIDString);
            return args.Length > 0 ? string.Format(msg, args) : msg;
        }

        private void PrintMsgL(IPlayer user, string msgId, params object[] args)
        {
            if (user.IsServer)
            {
                string msg = lang.GetMessage(msgId, this, user.Id);
                if (!string.IsNullOrEmpty(msg))
                {
                    user.Reply(string.Format(msg, args));
                }
            }
            else PrintMsgL(user.Object as BasePlayer, msgId, args);
        }

        private void PrintMsgL(BasePlayer player, string msgId, params object[] args)
        {
            if (player == null) return;
            PrintMsg(player, _(msgId, player, args));
        }

        private void PrintMsgL(ulong userid, string msgId, params object[] args)
        {
            var player = BasePlayer.FindAwakeOrSleeping(userid.ToString());
            if (player == null) return;
            PrintMsgL(player, msgId, args);
        }

        private void PrintMsg(BasePlayer player, string message)
        {
            if (player == null || string.IsNullOrEmpty(message)) return;
            if (config.Settings.UsePopup)
            {
                PopupNotifications?.Call("CreatePopupNotification", config.Settings.ChatName + message, player);
            }
            if (config.Settings.SendMessages)
            {
                Player.Message(player, $"{config.Settings.ChatName}{message}", config.Settings.ChatID);
            }
        }

        private void SendDiscordMessage(BasePlayer player, BasePlayer target)
        {
            if (config.TPR.Discord.TPA <= 0 || string.IsNullOrEmpty(config.TPR.Discord.Webhook) || config.TPR.Discord.Webhook == "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks")
            {
                return;
            }
            if (player.userID == target.userID || IsAlly(player.userID, target.userID, true, true, true))
            {
                return;
            }
            var key = ((ulong)player.userID).CompareTo((ulong)target.userID) < 0 ? (player.userID, target.userID) : (target.userID, player.userID);
            if (teleportCounts.ContainsKey(key))
            {
                teleportCounts[key]++;
            }
            else
            {
                teleportCounts[key] = 1;
            }
            if (teleportCounts[key] >= config.TPR.Discord.TPA)
            {
                string message = _("DiscordLogTPA", null, $"{target.displayName} ({target.userID})", $"{player.displayName} ({player.userID})", teleportCounts[key]);
                discordMessages.Add(message);
                if (discordMessages.Count == 1)
                {
                    timer.Once(1f, CheckDiscordMessages);
                }
            }
        }

        private void CheckDiscordMessages()
        {
            string text = discordMessages[0];
            discordMessages.RemoveAt(0);
            Puts(text);
            if (discordMessages.Count > 0) timer.Once(1f, CheckDiscordMessages);
            try
            {
                var headers = new Dictionary<string, string>() { { "Content-Type", "application/json" } };
                var body = new DiscordMessage(text).ToJson();
                webrequest.Enqueue(config.TPR.Discord.Webhook, body, (code, response) => { }, this, Core.Libraries.RequestMethod.POST, headers);
            }
            catch { }
        }

        private List<string> discordMessages = new();
        private Dictionary<(ulong, ulong), int> teleportCounts = new();

        public class DiscordMessage
        {
            public DiscordMessage(string content)
            {
                Content = content;
            }

            [JsonProperty("content")]
            public string Content { get; set; }

            public string ToJson() => JsonConvert.SerializeObject(this);
        }

        #endregion

        #region DrawMonument
        void DrawMonument(BasePlayer player, Vector3 center, Vector3 extents, Quaternion rotation, Color color, float duration)
        {
            Vector3[] boxVertices = new Vector3[8]
            {
                center + rotation * new Vector3(extents.x, extents.y, extents.z),
                center + rotation * new Vector3(-extents.x, extents.y, extents.z),
                center + rotation * new Vector3(extents.x, -extents.y, extents.z),
                center + rotation * new Vector3(-extents.x, -extents.y, extents.z),
                center + rotation * new Vector3(extents.x, extents.y, -extents.z),
                center + rotation * new Vector3(-extents.x, extents.y, -extents.z),
                center + rotation * new Vector3(extents.x, -extents.y, -extents.z),
                center + rotation * new Vector3(-extents.x, -extents.y, -extents.z)
            };

            //foreach (var vector in boxVertices)
            //{
            //    DrawText(player, 30f, Color.red, vector, "X");
            //}

            DrawLine(player, duration, color, boxVertices[0], boxVertices[1]);
            DrawLine(player, duration, color, boxVertices[0], boxVertices[1]);
            DrawLine(player, duration, color, boxVertices[1], boxVertices[3]);
            DrawLine(player, duration, color, boxVertices[3], boxVertices[2]);
            DrawLine(player, duration, color, boxVertices[2], boxVertices[0]);
            DrawLine(player, duration, color, boxVertices[4], boxVertices[5]);
            DrawLine(player, duration, color, boxVertices[5], boxVertices[7]);
            DrawLine(player, duration, color, boxVertices[7], boxVertices[6]);
            DrawLine(player, duration, color, boxVertices[6], boxVertices[4]);
            DrawLine(player, duration, color, boxVertices[0], boxVertices[4]);
            DrawLine(player, duration, color, boxVertices[1], boxVertices[5]);
            DrawLine(player, duration, color, boxVertices[2], boxVertices[6]);
            DrawLine(player, duration, color, boxVertices[3], boxVertices[7]);
        }
        #endregion DrawMonument

        #region FindPlayer
        private ulong FindPlayersSingleId(string nameOrIdOrIp, BasePlayer player)
        {
            var targets = FindPlayers(nameOrIdOrIp, true);
            if (targets.Count > 1)
            {
                PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                return 0;
            }
            ulong userId;
            if (targets.Count <= 0)
            {
                if (ulong.TryParse(nameOrIdOrIp, out userId)) return userId;
                PrintMsgL(player, "PlayerNotFound");
                return 0;
            }
            else
                userId = targets[0].userID;

            return userId;
        }

        private BasePlayer FindPlayersSingle(string value, BasePlayer player)
        {
            if (string.IsNullOrEmpty(value)) return null;
            BasePlayer target;
            if (_codeToPlayer.TryGetValue(value, out target) && target.IsValid())
            {
                return target;
            }
            var targets = FindPlayers(value, true);
            if (targets.Count <= 0)
            {
                PrintMsgL(player, "PlayerNotFound");
                return null;
            }
            if (targets.Count > 1)
            {
                PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                return null;
            }

            return targets[0];
        }

        private List<BasePlayer> FindPlayers(string arg, bool all = false)
        {
            var players = new List<BasePlayer>();

            if (string.IsNullOrEmpty(arg))
            {
                return players;
            }

            if (_codeToPlayer.TryGetValue(arg, out var player) && player.IsValid())
            {
                if (all || player.IsConnected)
                {
                    players.Add(player);
                    return players;
                }
            }

            foreach (var target in all ? BasePlayer.allPlayerList : BasePlayer.activePlayerList)
            {
                if (target == null || string.IsNullOrEmpty(target.displayName) || players.Contains(target))
                {
                    continue;
                }

                if (target.UserIDString == arg || target.displayName.Contains(arg, CompareOptions.OrdinalIgnoreCase))
                {
                    players.Add(target);
                }
            }

            return players;
        }
        #endregion



        private bool API_HavePendingRequest(BasePlayer player)
        {
            return PendingRequests.ContainsKey(player.userID) || PlayersRequests.ContainsKey(player.userID) || TeleportTimers.ContainsKey(player.userID);
        }

        private bool API_HaveAvailableHomes(BasePlayer player)
        {
            if (!_Home.TryGetValue(player.userID, out var homeData))
            {
                _Home[player.userID] = homeData = new();
            }
            ValidateHomes(player, homeData, false, false);
            var limit = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);
            var result = homeData.Locations.Count < limit || limit == 0;
            homeData.Locations.Clear();
            return result;
        }

        [HookMethod("API_GetHomes")]
        public Dictionary<string, Vector3> GetPlayerHomes(BasePlayer player)
        {
            if (!_Home.TryGetValue(player.userID, out var homeData))
            {
                _Home[player.userID] = homeData = new();
            }
            ValidateHomes(player, homeData, false, false);
            var result = homeData.Locations.ToDictionary(pair => pair.Key, pair => pair.Value.Get());
            homeData.Locations.Clear();
            return result;
        }

        private List<Vector3> API_GetLocations(string command)
        {
            return GetSettings(command)?.Locations ?? new();
        }

        private Dictionary<string, List<Vector3>> API_GetAllLocations()
        {
            return config.DynamicCommands.ToDictionary(pair => pair.Key, pair => pair.Value.Locations);
        }

        private int GetLimitRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type)) return -1;
            var settings = GetSettings(type, player.userID);
            if (settings == null) return -1;
            var currentDate = DateTime.Now.ToString("d");
            var limit = GetHigher(player, settings.VIPDailyLimits, settings.DailyLimit, true);
            if (!settings.Teleports.TPData.TryGetValue(player.userID, out var data))
            {
                settings.Teleports.TPData[player.userID] = data = new();
            }
            if (data.Date != currentDate)
            {
                data.Amount = 0;
                data.Date = currentDate;
            }
            return limit > 0 ? limit - data.Amount : 0;
        }

        private int GetCooldownRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type)) return -1;
            var settings = GetSettings(type, player.userID);
            if (settings == null) return -1;
            var currentDate = DateTime.Now.ToString("d");
            var timestamp = Facepunch.Math.Epoch.Current;
            var cooldown = GetLower(player, settings.VIPCooldowns, settings.Cooldown);
            if (!settings.Teleports.TPData.TryGetValue(player.userID, out var data))
            {
                settings.Teleports.TPData[player.userID] = data = new();
            }
            if (data.Date != currentDate)
            {
                data.Amount = 0;
                data.Date = currentDate;
            }
            return cooldown > 0 && timestamp - data.Timestamp < cooldown ? cooldown - (timestamp - data.Timestamp) : 0;
        }

        private int GetCountdownRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type))
            {
                return -1;
            }
            var settings = GetSettings(type, player.userID);
            return settings == null ? -1 : GetLower(player, settings.VIPCountdowns, settings.Countdown);
        }

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    var values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                var o = Newtonsoft.Json.Linq.JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }

        private class CustomComparerDictionaryCreationConverter<T> : CustomCreationConverter<IDictionary>
        {
            private readonly IEqualityComparer<T> comparer;

            public CustomComparerDictionaryCreationConverter(IEqualityComparer<T> comparer)
            {
                if (comparer == null)
                    throw new ArgumentNullException(nameof(comparer));
                this.comparer = comparer;
            }

            public override bool CanConvert(Type objectType)
            {
                return HasCompatibleInterface(objectType) && HasCompatibleConstructor(objectType);
            }

            private static bool HasCompatibleInterface(Type objectType)
            {
                return objectType.GetInterfaces().Where(i => HasGenericTypeDefinition(i, typeof(IDictionary<,>))).Exists(i => typeof(T).IsAssignableFrom(i.GetGenericArguments()[0]));
            }

            private static bool HasGenericTypeDefinition(Type objectType, Type typeDefinition)
            {
                return objectType.GetTypeInfo().IsGenericType && objectType.GetGenericTypeDefinition() == typeDefinition;
            }

            private static bool HasCompatibleConstructor(Type objectType)
            {
                return objectType.GetConstructor(new[] { typeof(IEqualityComparer<T>) }) != null;
            }

            public override IDictionary Create(Type objectType)
            {
                return Activator.CreateInstance(objectType, comparer) as IDictionary;
            }
        }

        public class Exploits
        {
            public static bool TestInsideRock(Vector3 a)
            {
                if (ContainsTopology(TerrainTopology.Enum.Monument, a, 25f))
                {
                    return false;
                }
                bool faces = Physics.queriesHitBackfaces;
                Physics.queriesHitBackfaces = true;
                bool flag = IsRockFaceUpwards(a);
                Physics.queriesHitBackfaces = faces;
                return flag || IsRockFaceDownwards(a);
            }

            private static bool IsRockFaceDownwards(Vector3 a)
            {
                Vector3 b = a + new Vector3(0f, 30f, 0f);
                Vector3 d = a - b;
                var hits = Physics.RaycastAll(b, d, d.magnitude, Layers.World);
                return Array.Exists(hits, hit => IsRock(hit.collider.name));
            }

            private static bool IsRockFaceUpwards(Vector3 point)
            {
                return Physics.Raycast(point, Vector3.up, out var hit, 30f, Layers.Mask.World) && IsRock(hit.collider.name);
            }

            private static bool IsRock(string name)
            {
                if (name.Contains("rock_formation_huge", CompareOptions.OrdinalIgnoreCase)) return false;
                return name.Contains("rock", CompareOptions.OrdinalIgnoreCase) || name.Contains("formation", CompareOptions.OrdinalIgnoreCase) || name.Contains("cliff", CompareOptions.OrdinalIgnoreCase);
            }
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            PrintMsgL(player, "<size=14>NTeleportation</size> by <color=#ce422b>Nogrod</color>\n<color=#ffd479>/sethome NAME</color> - Set home on current foundation\n<color=#ffd479>/home NAME</color> - Go to one of your homes\n<color=#ffd479>/home list</color> - List your homes\n<color=#ffd479>/town</color> - Go to town, if set\n/tpb - Go back to previous location\n/tpr PLAYER - Request teleport to PLAYER\n/tpa - Accept teleport request");
        }
    }
}

namespace Oxide.Plugins.NTeleportationExtensionMethods
{
    public static class ExtensionMethods
    {
        public static bool All<T>(this IEnumerable<T> a, Func<T, bool> b) { foreach (T c in a) { if (!b(c)) { return false; } } return true; }
        public static T FirstOrDefault<T>(this IEnumerable<T> a, Func<T, bool> b = null) { using (var c = a.GetEnumerator()) { while (c.MoveNext()) { if (b == null || b(c.Current)) { return c.Current; } } } return default(T); }
        public static IEnumerable<V> Select<T, V>(this IEnumerable<T> a, Func<T, V> b) { var c = new List<V>(); using (var d = a.GetEnumerator()) { while (d.MoveNext()) { c.Add(b(d.Current)); } } return c; }
        public static string[] Skip(this string[] a, int b) { if (a.Length == 0 || b >= a.Length) { return Array.Empty<string>(); } int n = a.Length - b; string[] c = new string[n]; Array.Copy(a, b, c, 0, n); return c; }
        public static List<T> Take<T>(this IList<T> a, int b) { var c = new List<T>(); for (int i = 0; i < a.Count; i++) { if (c.Count == b) { break; } c.Add(a[i]); } return c; }
        public static Dictionary<T, V> ToDictionary<S, T, V>(this IEnumerable<S> a, Func<S, T> b, Func<S, V> c) { var d = new Dictionary<T, V>(); using (var e = a.GetEnumerator()) { while (e.MoveNext()) { d[b(e.Current)] = c(e.Current); } } return d; }
        public static List<T> ToList<T>(this IEnumerable<T> a) => new(a);
        public static List<T> Where<T>(this IEnumerable<T> a, Func<T, bool> b) { List<T> c = new(a is ICollection<T> n ? n.Count : 4); foreach (var d in a) { if (b(d)) { c.Add(d); } } return c; }
        public static List<T> OrderByDescending<T, TKey>(this IEnumerable<T> a, Func<T, TKey> s) { List<T> m = new(a); m.Sort((x, y) => Comparer<TKey>.Default.Compare(s(y), s(x))); return m; }
        public static int Count<T>(this IEnumerable<T> a, Func<T, bool> b) { int c = 0; foreach (T d in a) { if (b(d)) { c++; } } return c; }
        public static bool IsKilled(this BaseNetworkable a) => a == null || a.IsDestroyed || !a.IsFullySpawned();
        public static void ResetToPool<T>(this List<T> obj) { if (obj == null) return; obj.Clear(); Pool.FreeUnmanaged(ref obj); }
    }
}


// --- End of file: NTeleportation.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/night-zombies ---
// --- Original File Path: N/NightZombies/NightZombies.cs ---

using System;
using System.Collections;
using System.Collections.Generic;

using UnityEngine;
using Random = UnityEngine.Random;
using Physics = UnityEngine.Physics;

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;

using ConVar;

using Pool = Facepunch.Pool;

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Night Zombies", "0x89A", "3.4.2")]
    [Description("Spawns and kills zombies at set times")]
    class NightZombies : RustPlugin
    {
        private const string DeathSound = "assets/prefabs/npc/murderer/sound/death.prefab";
        private const string RemoveMeMethodName = nameof(DroppedItemContainer.RemoveMe);
        private const int GrenadeItemId = 1840822026;
        
        private static NightZombies _instance;
        private static Configuration _config;
        private DynamicConfigFile _dataFile;

        [PluginReference("Kits")]
        private Plugin _kits;

        [PluginReference("Vanish")]
        private Plugin _vanish;

        private SpawnController _spawnController;
        
        #region -Init-
        
        private void Init()
        {
            _instance = this;

            _spawnController = new SpawnController();
            
            //Read saved number of days since last spawn
            _dataFile = Interface.Oxide.DataFileSystem.GetFile("NightZombies-daysSinceSpawn");

            try
            {
                _spawnController.DaysSinceLastSpawn = _dataFile.ReadObject<int>();
            }
            catch //Default to 0 if error reading or data broken
            {
                PrintWarning("Failed to load saved days since last spawn, defaulting to 0");
                _spawnController.DaysSinceLastSpawn = 0;
            }

            if (_config.Behaviour.SentriesAttackZombies)
            {
                Unsubscribe(nameof(OnTurretTarget));
            }

            if (_config.Destroy.SpawnLoot)
            {
                Unsubscribe(nameof(OnCorpsePopulate));
            }

            if (_config.Behaviour.Ignored.Count == 0 && !_config.Behaviour.IgnoreHumanNpc && _config.Behaviour.AttackSleepers)
            {
                Unsubscribe(nameof(OnNpcTarget));
            }
        }
        
        private void OnServerInitialized()
        {
            //Warn if kits is not loaded
            if (!_kits?.IsLoaded ?? false)
            {
                PrintWarning("Kits is not loaded, custom kits will not work");
            }
            
            //Start time check
            if (!_config.Spawn.AlwaysSpawned && _config.Spawn.SpawnTime >= 0 && _config.Spawn.DestroyTime >= 0)
            {
                TOD_Sky.Instance.Components.Time.OnMinute += _spawnController.TimeTick;
                TOD_Sky.Instance.Components.Time.OnDay += OnDay;
            }
        }
        
        private void Unload()
        {
            TOD_Sky.Instance.Components.Time.OnMinute -= _spawnController.TimeTick;
            TOD_Sky.Instance.Components.Time.OnDay -= OnDay;

            _dataFile.WriteObject(_spawnController.DaysSinceLastSpawn);

            _spawnController?.Shutdown();

            _config = null;
            _instance = null;
        }

        private void OnDay() => _spawnController.DaysSinceLastSpawn++;

        #endregion

        #region -Oxide Hooks-

        private object OnNpcTarget(ScarecrowNPC npc, BaseEntity target)
        {
            return CanAttack(target);
        }

        private object OnTurretTarget(NPCAutoTurret turret, ScarecrowNPC entity)
        {
            if (entity == null)
            {
                return null;
            }
            
            return true;
        }

        private object OnPlayerDeath(ScarecrowNPC scarecrow, HitInfo info)
        {
            Effect.server.Run(DeathSound, scarecrow.transform.position);
            _spawnController.ZombieDied(scarecrow);

            if (_config.Destroy.LeaveCorpseKilled)
            {
                return null;
            }
            
            NextTick(() =>
            {
                if (scarecrow == null || scarecrow.IsDestroyed)
                {
                    return;
                }

                scarecrow.AdminKill();
            });
                
            return true;
        }

        private BaseCorpse OnCorpsePopulate(ScarecrowNPC npcPlayer, NPCPlayerCorpse corpse)
        {
            return corpse;
        }

        private void OnEntitySpawned(NPCPlayerCorpse corpse)
        {
            if (corpse.playerName == "Scarecrow")
            {
                corpse.playerName = _config.Spawn.Zombies.DisplayName;
            }
        }
        
        private void OnEntitySpawned(DroppedItemContainer container)
        {
            if (!_config.Destroy.HalfBodybagDespawn)
            {
                return;
            }
            
            NextTick(() =>
            {
                if (container != null && container.playerName == _config.Spawn.Zombies.DisplayName)
                {
                    container.CancelInvoke(RemoveMeMethodName);
                    container.Invoke(RemoveMeMethodName, container.CalculateRemovalTime() / 2);
                }
            });
        }

        #endregion

        #region -Helpers-

        private object CanAttack(BaseEntity target)
        {
            if (_config.Behaviour.Ignored.Contains(target.ShortPrefabName) || 
                (_config.Behaviour.IgnoreHumanNpc && HumanNPCCheck(target)) || 
                (!_config.Behaviour.AttackSleepers && target is BasePlayer player && player.IsSleeping()))
            {
                return true;
            }
            
            return null;
        }

        private bool HumanNPCCheck(BaseEntity target)
        {
            return target is BasePlayer player && !player.userID.IsSteamId() && target is not ScientistNPC &&
                   target is not ScarecrowNPC;
        }

        #endregion

        #region -Classes-

        private class SpawnController
        {
            private const string _zombiePrefab = "assets/prefabs/npc/scarecrow/scarecrow.prefab";

            private readonly Configuration.SpawnSettings _spawnConfig;
            private readonly Configuration.SpawnSettings.ZombieSettings _zombiesConfig;
            
            private readonly int _spawnLayerMask = LayerMask.GetMask("Default", "Tree", "Construction", "World", "Vehicle_Detailed", "Deployed");
            private readonly WaitForSeconds _waitTenthSecond = new(0.1f);

            private bool IsSpawnTime => _spawnConfig.AlwaysSpawned || _spawnTime > _destroyTime
                                            ? Env.time >= _spawnTime || Env.time < _destroyTime
                                            : Env.time <= _spawnTime || Env.time > _destroyTime;

            private bool IsDestroyTime => _spawnTime > _destroyTime
                                              ? Env.time >= _destroyTime && Env.time < _spawnTime
                                              : Env.time <= _destroyTime && Env.time > _spawnTime;
            
            public int DaysSinceLastSpawn;
            
            private readonly float _spawnTime;
            private readonly float _destroyTime;
            private readonly bool _leaveCorpse;
            
            private bool _spawned;

            private Coroutine _currentCoroutine;
            
            private readonly List<ScarecrowNPC> _zombies = new();
            
            public SpawnController()
            {
                _spawnConfig = _config.Spawn;
                _zombiesConfig = _config.Spawn.Zombies;
                
                _spawnTime = _spawnConfig.SpawnTime;
                _destroyTime = _spawnConfig.DestroyTime;
                
                // These might not be available after the plugin is unloaded, will cause NRE if trying to access in RemoveZombies
                _leaveCorpse = _config.Destroy.LeaveCorpse;
            }

            private IEnumerator SpawnZombies()
            {
                if (_zombiesConfig.Population <= 0)
                {
                    yield break;
                }
                
                if (_currentCoroutine != null)
                {
                    ServerMgr.Instance.StopCoroutine(_currentCoroutine);
                }
                
                _spawned = true;

                for (int i = 0; i < _zombiesConfig.Population; i++)
                {
                    SpawnZombie();
                    yield return _waitTenthSecond;
                }
                
                if (_config.Broadcast.DoBroadcast && !_spawned)
                {
                    Broadcast("ChatBroadcast", _zombiesConfig.Population);
                }

                DaysSinceLastSpawn = 0;

                _currentCoroutine = null;
            }

            private IEnumerator RemoveZombies(bool shuttingDown = false)
            {
                if (_zombies.Count == 0)
                {
                    yield break;
                }

                if (_currentCoroutine != null)
                {
                    ServerMgr.Instance.StopCoroutine(_currentCoroutine);
                }
                
                foreach (ScarecrowNPC zombie in _zombies.ToArray())
                {
                    if (zombie == null || zombie.IsDestroyed)
                    {
                        continue;
                    }

                    if (_leaveCorpse && !shuttingDown)
                    {
                        zombie.Die();
                    }
                    else
                    {
                        zombie.AdminKill();
                    }

                    yield return !shuttingDown ? _waitTenthSecond : null;
                }

                _zombies?.Clear();
                _spawned = false;

                _currentCoroutine = null;
            }

            public void TimeTick()
            {
                if (CanSpawn())
                {
                    _currentCoroutine = ServerMgr.Instance.StartCoroutine(SpawnZombies());
                }
                else if (_zombies.Count > 0 && IsDestroyTime && _spawned)
                {
                    _currentCoroutine = ServerMgr.Instance.StartCoroutine(RemoveZombies());
                }
            }

            public void ZombieDied(ScarecrowNPC zombie)
            {
                _zombies.Remove(zombie);
                
                if (!IsSpawnTime)
                {
                    return;
                }

                SpawnZombie();
            }

            #region -Util-

            private void SpawnZombie()
            {
                if (_zombies.Count >= _zombiesConfig.Population)
                {
                    return;
                }

                Vector3 position = _spawnConfig.SpawnNearPlayers && BasePlayer.activePlayerList.Count >= _spawnConfig.MinNearPlayers && 
                                   GetRandomPlayer(out BasePlayer player) ? GetRandomPositionAroundPlayer(player) : GetRandomPosition();

                ScarecrowNPC zombie = GameManager.server.CreateEntity(_zombiePrefab, position) as ScarecrowNPC;
                if (!zombie)
                {
                    return;
                }
                
                zombie.Spawn();
                
                zombie.displayName = _zombiesConfig.DisplayName;

                if (zombie.TryGetComponent(out BaseNavigator navigator))
                {
                    navigator.ForceToGround();
                    navigator.PlaceOnNavMesh(0);
                }

                //Initialise health
                float health = _spawnConfig.Zombies.Health;
                zombie.SetMaxHealth(health);
                zombie.SetHealth(health);

                //Give kit
                if (_instance._kits != null && _zombiesConfig.Kits.Count > 0)
                {
                    zombie.inventory.containerWear.Clear();
                    ItemManager.DoRemoves();

                    _instance._kits.Call("GiveKit", zombie, _zombiesConfig.Kits.GetRandom());
                }

                if (!_config.Behaviour.ThrowGrenades)
                {
                    foreach (Item item in zombie.inventory.FindItemsByItemID(GrenadeItemId))
                    {
                        item.Remove();
                    }

                    ItemManager.DoRemoves();
                }

                _zombies.Add(zombie);
            }

            private bool GetRandomPlayer(out BasePlayer player)
            {
                List<BasePlayer> players = Pool.GetList<BasePlayer>();

                foreach (BasePlayer bplayer in BasePlayer.activePlayerList)
                {
                    if (bplayer.IsFlying || _instance._vanish?.Call<bool>("IsInvisible", bplayer) == true)
                    {
                        continue;
                    }

                    players.Add(bplayer);
                }

                player = players.GetRandom();

                Pool.FreeList(ref players);
                
                return player;
            }

            private Vector3 GetRandomPosition()
            {
                Vector3 position = Vector3.zero;

                for (int i = 0; i < 6; i++)
                {
                    float x = Random.Range(-TerrainMeta.Size.x / 2, TerrainMeta.Size.x / 2),
                          z = Random.Range(-TerrainMeta.Size.z / 2, TerrainMeta.Size.z / 2),
                          y = TerrainMeta.HeightMap.GetHeight(new Vector3(x, 0, z));

                    position = new Vector3(x, y + 0.5f, z);

                    // If valid position
                    if (!AntiHack.TestInsideTerrain(position) && !IsInObject(position) && !IsInOcean(position))
                    {
                        break;
                    }
                }

                if (position == Vector3.zero)
                {
                    position.y = TerrainMeta.HeightMap.GetHeight(0, 0);
                }

                return position;
            }

            private Vector3 GetRandomPositionAroundPlayer(BasePlayer player)
            {
                Vector3 playerPos = player.transform.position;
                Vector3 position = Vector3.zero;

                float maxDist = _spawnConfig.MaxDistance;
                
                for (int i = 0; i < 6; i++)
                {
                    position = new Vector3(Random.Range(playerPos.x - maxDist, playerPos.x + maxDist), 0, Random.Range(playerPos.z - maxDist, playerPos.z + maxDist));
                    position.y = TerrainMeta.HeightMap.GetHeight(position);

                    // If valid position
                    if (!AntiHack.TestInsideTerrain(position) && !IsInObject(position) && !IsInOcean(position) && 
                        Vector3.Distance(playerPos, position) > _spawnConfig.MinDistance)
                    {
                        break;
                    }
                }

                if (position == Vector3.zero)
                {
                    position = GetRandomPosition();
                }

                return position;
            } 

            private bool CanSpawn()
            {
                return !_spawned && DaysSinceLastSpawn >= _spawnConfig.Chance.Days && Random.Range(0f, 100f) < _spawnConfig.Chance.Chance && IsSpawnTime;
            }

            private bool IsInObject(Vector3 position)
            {
                return Physics.OverlapSphere(position, 0.5f, _spawnLayerMask).Length > 0;
            }

            private bool IsInOcean(Vector3 position)
            {
                return WaterLevel.GetWaterDepth(position, true, true) > 0.25f;
            }

            private void Broadcast(string key, params object[] values)
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    player.ChatMessage(string.Format(_instance.GetMessage(key, player.UserIDString), values));
                }
            }
            
            #endregion

            public void Shutdown()
            {
                ServerMgr.Instance.StartCoroutine(RemoveZombies(true));
            }
        }

        #endregion
        
        #region -Configuration-

        private class Configuration
        {
            [JsonProperty("Spawn Settings")]
            public SpawnSettings Spawn = new SpawnSettings();

            [JsonProperty("Destroy Settings")]
            public DestroySettings Destroy = new DestroySettings();

            [JsonProperty("Behaviour Settings")]
            public BehaviourSettings Behaviour = new BehaviourSettings();

            [JsonProperty("Broadcast Settings")]
            public ChatSettings Broadcast = new ChatSettings();

            public class SpawnSettings
            {
                [JsonProperty("Always Spawned")]
                public bool AlwaysSpawned = false;

                [JsonProperty("Spawn Time")]
                public float SpawnTime = 19.8f;

                [JsonProperty("Destroy Time")]
                public float DestroyTime = 7.3f;
                
                [JsonProperty("Spawn near players")]
                public bool SpawnNearPlayers = false;

                [JsonProperty("Min pop for near player spawn")]
                public int MinNearPlayers = 10;

                [JsonProperty("Min distance from player")]
                public float MinDistance = 40;

                [JsonProperty("Max distance from player")]
                public float MaxDistance = 80f;

                [JsonProperty("Zombie Settings")]
                public ZombieSettings Zombies = new ZombieSettings();

                public class ZombieSettings
                {
                    [JsonProperty("Display Name")] 
                    public string DisplayName = "Scarecrow";
                    
                    [JsonProperty("Scarecrow Population (total amount)")]
                    public int Population = 50;
                    
                    [JsonProperty("Scarecrow Health")]
                    public float Health = 200f;

                    [JsonProperty("Scarecrow Kits")]
                    public List<string> Kits = new List<string>();
                }

                [JsonProperty("Chance Settings")]
                public ChanceSetings Chance = new ChanceSetings();

                public class ChanceSetings
                {
                    [JsonProperty("Chance per cycle")]
                    public float Chance = 100f;
                    
                    [JsonProperty("Days betewen spawn")]
                    public int Days = 0;
                }
            }

            public class DestroySettings
            {
                [JsonProperty("Leave Corpse, when destroyed")]
                public bool LeaveCorpse = false;
                
                [JsonProperty("Leave Corpse, when killed by player")]
                public bool LeaveCorpseKilled = true;

                [JsonProperty("Spawn Loot")]
                public bool SpawnLoot = true;

                [JsonProperty("Half bodybag despawn time")]
                public bool HalfBodybagDespawn = true;
            }

            public class BehaviourSettings
            {
                [JsonProperty("Attack sleeping players")]
                public bool AttackSleepers = false;

                [JsonProperty("Zombies attacked by outpost sentries")]
                public bool SentriesAttackZombies = true;
                
                [JsonProperty("Throw Grenades")]
                public bool ThrowGrenades = true;

                [JsonProperty("Ignore Human NPCs")]
                public bool IgnoreHumanNpc = true;

                [JsonProperty("Ignored entities (full entity shortname)")]
                public List<string> Ignored = new List<string>();
            }

            public class ChatSettings
            {
                [JsonProperty("Broadcast spawn amount")]
                public bool DoBroadcast = false;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();

                if (_config.Spawn.SpawnTime >= 0 && _config.Spawn.DestroyTime >= 0)
                {
                    if (_config.Spawn.SpawnTime > 24 || _config.Spawn.SpawnTime < 0)
                    {
                        PrintWarning("Invalid spawn time (must be in 24 hour time)");
                        _config.Spawn.SpawnTime = 19.5f;
                    }
                    if (_config.Spawn.DestroyTime > 24 || _config.Spawn.DestroyTime < 0)
                    {
                        PrintWarning("Invalid destroy time (must be in 24 hour time)");
                        _config.Spawn.DestroyTime = 7f;
                    }
                }

                SaveConfig();
            }
            catch
            {
                PrintError("Failed to load _config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration
        {
            Behaviour = new Configuration.BehaviourSettings
            {
                Ignored = new List<string>
                {
                    "scientistjunkpile.prefab",
                    "scarecrow.prefab"
                }
            }
        };

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region -Localisation-

        private string GetMessage(string key, string userId = null)
        {
            return lang.GetMessage(key, this, userId);
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ChatBroadcast"] = "[Night Zombies] Spawned {0} zombies",
                ["ChatBroadcastSeparate"] = "[Night Zombies] Spawned {0} murderers | Spawned {1} scarecrows"
            }, this);
        }

        #endregion
    }
}

// --- End of file: NightZombies.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-compound ---
// --- Original File Path: N/NoCompound/NoCompound.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("No Compound", "Orange", "1.0.1")]
    [Description("Removing compound (outpost) and bandit camp components (turrets, bots, safe zones)")]
    public class NoCompound : RustPlugin
    {
        #region Vars

        private const float distance = 100f;
        private List<Vector3> banditTown = new List<Vector3>();
        private List<Vector3> compound = new List<Vector3>();
        private bool nearCompound(Vector3 pos) => compound.Any(x => Vector3.Distance(pos, x) < distance);
        private bool nearBanditTown(Vector3 pos) => banditTown.Any(x => Vector3.Distance(pos, x) < distance);
        
        #endregion

        #region Oxide Hooks

        private void Init()
        {
            if (config.removeHostileTimer == false)
            {
                Unsubscribe(nameof(OnEntityMarkHostile));
            }
        }

        private void OnServerInitialized()
        {
            CheckObjects();            
        }
        
        private void OnEntitySpawned(NPCPlayer player)
        {
            NextTick(() =>
            {
                CheckPlayer(player);
            });
        }
        
        private object OnEntityMarkHostile(BaseCombatEntity entity, float duration)
        {
            return true;
        }

        #endregion

        #region Core

        private void CheckObjects()
        {
            foreach (var obj in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                if (obj.name.Contains("compound"))
                {
                    compound.Add(obj.transform.position);
                }

                if (obj.name.Contains("bandit_town"))
                {
                    banditTown.Add(obj.transform.position);
                }
            }
            
            if (config.removeTurrets == true)
            {
                foreach (var obj in UnityEngine.Object.FindObjectsOfType<NPCAutoTurret>())
                {
                    if (obj.OwnerID == 0)
                    {
                        UnityEngine.Object.Destroy(obj);
                    }
                }
            }

            if (config.removeNPCCompound == true || config.removeNPCBanditTown == true)
            {
                foreach (var obj in UnityEngine.Object.FindObjectsOfType<NPCPlayer>())
                {
                    CheckPlayer(obj);
                }
            }

            if (config.removeBanditCampSZ == true || config.removeCompoundCampSZ == true)
            {
                foreach (var obj in UnityEngine.Object.FindObjectsOfType<TriggerSafeZone>())
                {
                    CheckSafeZone(obj);
                }
            }
        }

        private void CheckPlayer(NPCPlayer player)
        {
            if (player.IsValid() == false || player.IsDestroyed == true)
            {
                return;
            }

            if (player is VehicleVendor)
            {
                if (config.removeVehicleVendor == true)
                {
                    player.Kill();
                }
                
                return;
            }

            if (config.removeNPCCompound == true && nearCompound(player.transform.position))
            {
                player.Kill();
                return;
            }

            if (config.removeNPCBanditTown == true && nearBanditTown(player.transform.position))
            {
                player.Kill();
                return;
            }
        }

        private void CheckSafeZone(TriggerSafeZone trigger)
        {
            if (config.removeBanditCampSZ == true && nearBanditTown(trigger.transform.position))
            {
                UnityEngine.Object.Destroy(trigger);
                return;
            }
            
            if (config.removeCompoundCampSZ == true && nearCompound(trigger.transform.position))
            {
                UnityEngine.Object.Destroy(trigger);
                return;
            }
        }

        #endregion
        
        #region Configuration | 24.05.2020

        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Remove NPC Turrets")]
            public bool removeTurrets = false;
            
            [JsonProperty(PropertyName = "Remove vehicle vendors")]
            public bool removeVehicleVendor = false;
            
            [JsonProperty(PropertyName = "Remove Compound safe zone")]
            public bool removeCompoundCampSZ = false;

            [JsonProperty(PropertyName = "Remove Compound npc-s")]
            public bool removeNPCCompound = false;
            
            [JsonProperty(PropertyName = "Remove Bandit Camp safe zone")]
            public bool removeBanditCampSZ = false;
            
            [JsonProperty(PropertyName = "Remove Bandit Camp npc-s")]
            public bool removeNPCBanditTown = false;

            [JsonProperty(PropertyName = "Remove hostile timer")]
            public bool removeHostileTimer = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }
                
                LoadDefaultConfig();
                return;
            }

            ValidateConfig();
            SaveConfig();
        }

        private void ValidateConfig()
        {
            if (ConVar.Server.hostname.Contains("[DEBUG]") == true)
            {
                PrintWarning("Using default configuration on debug server");
                config = new ConfigData();
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: NoCompound.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-crash-flying-vehicles ---
// --- Original File Path: N/NoCrashFlyingVehicles/NoCrashFlyingVehicles.cs ---

namespace Oxide.Plugins
{
    [Info("No Crash Flying Vehicles", "MON@H", "2.0.0")]
    [Description("Prevents flying vehicles from crashing.")]
    public class NoCrashFlyingVehicles : RustPlugin
    {
        #region Class Fields

        private static readonly object _true = true;

        #endregion Class Fields

        #region Initialization

        private void Init() => Unsubscribe(nameof(OnEntityTakeDamage));

        private void OnServerInitialized() => Subscribe(nameof(OnEntityTakeDamage));

        #endregion Initialization

        #region Oxide Hooks

        private object OnEntityTakeDamage(BaseHelicopter entity, HitInfo info)
        {
            if (info != null
            && entity.IsValid()
            && info.Initiator.IsValid()
            && (info.Initiator is BaseHelicopter)
            && !info.damageTypes.Has(Rust.DamageType.Decay))
            {
                return _true;
            }

            return null;
        }

        #endregion Oxide Hooks
    }
}

// --- End of file: NoCrashFlyingVehicles.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/npc-loadouts ---
// --- Original File Path: N/NPCLoadouts/NPCLoadouts.cs ---

using Facepunch;
using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Random = UnityEngine.Random;

/*
 * Rewritten from scratch and maintained to present by VisEntities
 * Originally created by Orange, up to version 1.0.3
 */

namespace Oxide.Plugins
{
    [Info("NPC Loadouts", "VisEntities", "2.0.1")]
    [Description("Equip npcs with custom loadouts.")]
    public class NPCLoadouts : RustPlugin
    {
        #region Fields

        private static NPCLoadouts _plugin;
        private static Configuration _config;
        private Coroutine _coroutine;

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("NPC Groups")]
            public List<NPCGroupConfig> NPCGroups { get; set; }

            public void BuildLoadouts()
            {
                foreach (NPCGroupConfig npcGroup in NPCGroups)
                {
                    if (npcGroup.Enabled)
                        npcGroup.Loadout.BuildLoadout();
                }
            }
        }

        private class NPCGroupConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled { get; set; }

            [JsonProperty("NPC Short Prefab Names")]
            public string[] NPCShortPrefabNames { get; set; }

            [JsonProperty("Loadout")]
            public LoadoutConfig Loadout { get; set; }
        }

        private class LoadoutConfig
        {
            [JsonProperty("Randomize Active Weapon")]
            public bool RandomizeActiveWeapon { get; set; }

            [JsonProperty("Belt")]
            public List<ItemInfo> Belt { get; set; }

            [JsonProperty("Wear")]
            public List<ItemInfo> Wear { get; set; }

            [JsonIgnore]
            public PlayerInventoryProperties InventoryProperties { get; set; }

            public void BuildLoadout()
            {
                InventoryProperties = ScriptableObject.CreateInstance<PlayerInventoryProperties>();
                InventoryProperties.wear = new List<PlayerInventoryProperties.ItemAmountSkinned>();
                InventoryProperties.main = new List<PlayerInventoryProperties.ItemAmountSkinned>();
                InventoryProperties.belt = new List<PlayerInventoryProperties.ItemAmountSkinned>();

                foreach (ItemInfo itemInfo in Wear)
                {
                    ItemDefinition itemDef = ItemManager.FindItemDefinition(itemInfo.Shortname);
                    if (itemDef != null)
                    {
                        InventoryProperties.wear.Add(new PlayerInventoryProperties.ItemAmountSkinned
                        {
                            itemDef = itemDef,
                            amount = itemInfo.Amount,
                            skinOverride = itemInfo.SkinId
                        });
                    }
                }

                foreach (ItemInfo itemInfo in Belt)
                {
                    ItemDefinition itemDef = ItemManager.FindItemDefinition(itemInfo.Shortname);
                    if (itemDef != null)
                    {
                        InventoryProperties.belt.Add(new PlayerInventoryProperties.ItemAmountSkinned
                        {
                            itemDef = itemDef,
                            amount = itemInfo.Amount,
                            skinOverride = itemInfo.SkinId
                        });
                    }
                }
            }
        }

        public class ItemInfo
        {
            [JsonProperty("Shortname")]
            public string Shortname { get; set; }

            [JsonProperty("Skin Id")]
            public ulong SkinId { get; set; }

            [JsonProperty("Amount")]
            public int Amount { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Config changes detected! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Config update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                NPCGroups = new List<NPCGroupConfig>
                {
                    new NPCGroupConfig
                    {
                        Enabled = false,
                        NPCShortPrefabNames = new string[]
                        {
                            "scientistnpc_oilrig",
                        },
                        Loadout = new LoadoutConfig
                        {
                            RandomizeActiveWeapon = true,
                            Belt = new List<ItemInfo>
                            {
                                new ItemInfo
                                {
                                    Shortname = "shotgun.spas12",
                                    SkinId = 0,
                                    Amount = 1
                                },
                                new ItemInfo
                                {
                                    Shortname = "syringe.medical",
                                    SkinId = 0,
                                    Amount = 2
                                }
                            },
                           Wear = new List<ItemInfo>
                            {
                                new ItemInfo
                                {
                                    Shortname = "halloween.mummysuit",
                                    SkinId = 0,
                                    Amount = 1
                                }
                            }
                        }
                    },
                    new NPCGroupConfig
                    {
                        Enabled = false,
                        NPCShortPrefabNames = new string[]
                        {
                            "scientistnpc_cargo",
                            "scientistnpc_cargo_turret_lr300"
                        },
                        Loadout = new LoadoutConfig
                        {
                            RandomizeActiveWeapon = true,
                            Belt = new List<ItemInfo>
                            {
                                new ItemInfo
                                {
                                    Shortname = "rifle.ak",
                                    SkinId = 0,
                                    Amount = 1
                                },
                                new ItemInfo
                                {
                                    Shortname = "syringe.medical",
                                    SkinId = 0,
                                    Amount = 2
                                }
                            },
                           Wear = new List<ItemInfo>
                            {
                                new ItemInfo
                                {
                                    Shortname = "gingerbreadsuit",
                                    SkinId = 0,
                                    Amount = 1
                                }
                            }
                        }
                    }
                }
            };
        }

        #endregion Configuration

        #region Coroutine

        private void StartCoroutine()
        {
            _coroutine = ServerMgr.Instance.StartCoroutine(EquipLoadoutForAll());
        }

        private void StopCoroutine()
        {
            if (_coroutine != null)
            {
                ServerMgr.Instance.StopCoroutine(_coroutine);
                _coroutine = null;
            }
        }

        #endregion Coroutine

        #region Oxide Hooks

        private void Init()
        {
            _plugin = this;
            _config.BuildLoadouts();
        }

        private void Unload()
        {
            StopCoroutine();

            _config = null;
            _plugin = null;
        }

        private void OnServerInitialized()
        {
            StartCoroutine();
        }

        private void OnEntitySpawned(NPCPlayer npc)
        {
            if (npc != null && !npc.userID.IsSteamId())
            {
                foreach (NPCGroupConfig npcGroup in _config.NPCGroups)
                {
                    if (npcGroup.Enabled)
                    {
                        if (npcGroup.NPCShortPrefabNames.Contains(npc.ShortPrefabName))
                        {
                            EquipLoadout(npc, npcGroup.Loadout);
                            break;
                        }
                    }
                }
            }
        }

        #endregion Oxide Hooks

        #region Functions

        private IEnumerator EquipLoadoutForAll()
        {
            foreach (NPCPlayer npc in BaseNetworkable.serverEntities.OfType<NPCPlayer>())
            {
                if (npc != null && !npc.userID.IsSteamId())
                {
                    foreach (NPCGroupConfig npcGroup in _config.NPCGroups)
                    {
                        if (npcGroup.Enabled)
                        {
                            if (npcGroup.NPCShortPrefabNames.Contains(npc.ShortPrefabName))
                            {
                                EquipLoadout(npc, npcGroup.Loadout);
                                break;
                            }
                        }
                    }
                }

                yield return CoroutineEx.waitForSeconds(0.1f);
            }
        }

        private void EquipLoadout(NPCPlayer npc, LoadoutConfig loadout)
        {
            if (loadout.InventoryProperties != null)
            {
                StripInventory(npc);

                if (loadout.RandomizeActiveWeapon)
                {
                    var nonSyringeItems = loadout.InventoryProperties.belt.Where(item => !item.itemDef.shortname.Equals("syringe.medical", StringComparison.OrdinalIgnoreCase)).ToList();
                    if (nonSyringeItems.Count > 0)
                    {
                        int randomIndex = Random.Range(0, nonSyringeItems.Count);

                        var selectedWeapon = nonSyringeItems[randomIndex];
                        loadout.InventoryProperties.belt.Remove(selectedWeapon);
                        loadout.InventoryProperties.belt.Insert(0, selectedWeapon);
                    }
                }

                loadout.InventoryProperties.GiveToPlayer(npc);
                npc.EquipWeapon();
            }
        }

        public static void StripInventory(BasePlayer player)
        {
            List<Item> allItems = Pool.Get<List<Item>>();
            player.inventory.GetAllItems(allItems);

            for (int i = allItems.Count - 1; i >= 0; i--)
            {
                Item item = allItems[i];
                item.RemoveFromContainer();
                item.Remove();
            }

            Pool.FreeUnmanaged(ref allItems);
        }

        #endregion Functions
    }
}

// --- End of file: NPCLoadouts.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-mlg-water ---
// --- Original File Path: N/NoMlgWater/NoMlgWater.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("No MLG Water", "Polybro", "1.0.2")]
    [Description("Adds fall damage when falling into the water")]
    public class NoMlgWater : CovalencePlugin
    {
        #region Variables
        private static ConfigData config;
        List<ulong> pool = new List<ulong>();
        #endregion
        #region Hooks
        object OnPlayerTick(BasePlayer player, PlayerTick msg, bool wasPlayerStalled)
        {
            if ((!player.IsOnGround() && !(player.IsFlying || player.isMounted)) && (player.IsSwimming() && !pool.Contains(player.userID)))
            {
                ApplyFallDamage(player);
                pool.Add(player.userID);
            }
            if (!player.IsSwimming() && pool.Contains(player.userID)) pool.Remove(player.userID);
            return null;
        }
        private void Unload()
        {
            config = null;
        }
        #endregion
        #region Commands
        [Command("nmw.reload")]
        [Permission("nomlgwater.admin")]
        private void ReloadConfig(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer sender = (BasePlayer)iplayer.Object;
            try
            {
                LoadConfig();
                Respond(sender, "ReloadSuccess");
            }
            catch (Exception e)
            {
                PrintWarning($"Config loading error: {e.Message}");
            }
        }
        #endregion
        #region Calculations
        private void ApplyFallDamage(BasePlayer player)
        {
            float speed = player.estimatedSpeed;
            if (speed < config.MinimumSpeed) return;
            player.ApplyFallDamageFromVelocity((config.DecreaseEnterDamage && config.MinimumSpeed >= 15 == true ? Math.Abs(speed - Math.Abs(config.MinimumSpeed - 15)) : speed) * config.DamageExposure * -1);
            NextFrame(() =>
            {
                if (player.IsWounded() && !config.EnableWounded)
                {
                    player.Die();
                }
            });
        }
        #endregion
        #region Config
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<ConfigData>();
            config.DamageExposure = Math.Abs(config.DamageExposure);
            config.MinimumSpeed = Math.Abs(config.MinimumSpeed);
            if (config.MinimumSpeed < 15) config.DecreaseEnterDamage = false;
            Config.WriteObject(config, true);
        }
        protected override void SaveConfig() => Config.WriteObject(config, false);
        protected override void LoadDefaultConfig() => config = GetBaseConfig();
        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                DamageExposure = 0.75f,
                MinimumSpeed = 0.0f,
                DecreaseEnterDamage = false,
                EnableWounded = false
            };
        }
        public class ConfigData
        {
            [JsonProperty(PropertyName = "Damage Exposure")]
            public float DamageExposure { get; set; }
            [JsonProperty(PropertyName = "Minimum damage speed (>= 0)")]
            public float MinimumSpeed { get; set; }
            [JsonProperty(PropertyName = "Decrease enter damage (change only if minimum speed >= 15.0)")]
            public bool DecreaseEnterDamage { get; set; }
            [JsonProperty(PropertyName = "Allow wounded state after hitting the water too hard")]
            public bool EnableWounded { get; set; }
        }
        #endregion
        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string> { { "ReloadSuccess", "Successfully reloaded config." } }, this);
            lang.RegisterMessages(new Dictionary<string, string> { { "ReloadSuccess", "Configuración recargada con éxito." } }, this, "es");
            lang.RegisterMessages(new Dictionary<string, string> { { "ReloadSuccess", "Configuration rechargée avec succès." } }, this, "fr");
            lang.RegisterMessages(new Dictionary<string, string> { { "ReloadSuccess", "Konfiguration erfolgreich neu geladen." } }, this, "de");
            lang.RegisterMessages(new Dictionary<string, string> { { "ReloadSuccess", "Конфігурацію успішно перезавантажено." } }, this, "uk");
            lang.RegisterMessages(new Dictionary<string, string> { { "ReloadSuccess", "Pomyślnie załadowano ponownie konfigurację." } }, this, "pl");
            lang.RegisterMessages(new Dictionary<string, string> { { "ReloadSuccess", "Конфигурация успешно перезагружена." } }, this, "ru");
        }
        private void Respond(BasePlayer Player, string key) => Player.ChatMessage(lang.GetMessage(key, this, Player.UserIDString));
        #endregion
    }
}

// --- End of file: NoMlgWater.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-ammo-consumption ---
// --- Original File Path: N/NoAmmoConsumption/NoAmmoConsumption.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("No Ammo Consumtion", "KibbeWater", "0.1.6")]
    [Description("Blocks from consuming ammunition from your inventory")]
    class NoAmmoConsumption : RustPlugin
    {
        private PluginConfig _config;

        private string permissionUse = "noammoconsumption.use";

        private Dictionary<BaseProjectile, Timer> reloadingWeapons = new Dictionary<BaseProjectile, Timer>();

        private List<int> segmentLoadedWeapons = new List<int>() {
            1588298435, //Bolt action rile
            -1123473824, //Multiple Grenade Launcher
            795371088, //Pump Shotgun
            -41440462 //Spas Shotgun
        };

        #region Config
        protected override void LoadDefaultConfig() => _config = PluginConfig.DefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                PrintWarning("Loaded default config.");
                
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class PermissionInfo {
            public string permissionName;
            public List<int> ammoList;
        }

        private class PluginConfig
        {
            public List<PermissionInfo> allowedAmmoGroups = new List<PermissionInfo>();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    allowedAmmoGroups = new List<PermissionInfo>() {
                        new PermissionInfo() {
                            permissionName = "rifleAmmo",
                            ammoList = new List<int>() {
                                -1211166256, //ammo.rifle
                                1712070256 //ammo.rifle.hv
                            }
                        },
                        new PermissionInfo() {
                            permissionName = "pistolAmmo",
                            ammoList = new List<int>() {
                                785728077, //ammo.pistol
                                -1691396643 //ammo.pistol.hv
                            }
                        },
                        new PermissionInfo() {
                            permissionName = "shotgunAmmo",
                            ammoList = new List<int>() {
                                -1685290200, //ammo.shotgun
                                -727717969, //ammo.shotgun.slug
                                588596902 //ammo.handmade.shell
                            }
                        },
                        new PermissionInfo() {
                            permissionName = "bowArrows",
                            ammoList = new List<int>() {
                                215754713, //arrow.bone
                                -1234735557, //arrow.wooden
                                -1023065463 //arrow.hv
                            }
                        }
                    }
                };
            }
        }
        #endregion

        #region Methods
        public bool isAllowed(BasePlayer player, int ammoID) {
            if (!permission.UserHasPermission(player.UserIDString, permissionUse))
                return false;
            for (int i = 0; i < _config.allowedAmmoGroups.Count; i++)
                if (permission.UserHasPermission(player.UserIDString, "noammoconsumption." + _config.allowedAmmoGroups[i].permissionName)){
                    for (int x = 0; x < _config.allowedAmmoGroups[i].ammoList.Count; x++)
                        if (ammoID == _config.allowedAmmoGroups[i].ammoList[x])
                            return true;
                } else
                    return false;
            return false;
        }

        private bool IsSegmentedLoaded(BaseProjectile weapon) {
            return IsSegmentedLoaded(weapon.GetItem().info.itemid);
        }

        private bool IsSegmentedLoaded(int weponId) {
            foreach (var ID in segmentLoadedWeapons)
                if (ID == weponId)
                    return true;
            return false;
        }
        #endregion

        #region Hooks
        private void Init()
        {
            permission.RegisterPermission(permissionUse, this);
            for (int i = 0; i < _config.allowedAmmoGroups.Count; i++)
                permission.RegisterPermission("noammoconsumption." + _config.allowedAmmoGroups[i].permissionName, this);
        }

        object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
        {
            int itemID = projectile.primaryMagazine.ammoType.itemid;
            if (!isAllowed(player, itemID))
                return null;
            else {
                var mag = projectile.primaryMagazine;
                var newReloadTime = IsSegmentedLoaded(projectile) ? (mag.capacity - mag.contents) * (projectile.reloadTime / mag.capacity) : projectile.reloadTime;
                var reloadTimer = timer.Once(newReloadTime, () =>
                {
                    projectile.primaryMagazine.contents = projectile.primaryMagazine.capacity;
                    projectile.SendNetworkUpdateImmediate();
                    if (reloadingWeapons.ContainsKey(projectile))
                        reloadingWeapons.Remove(projectile);
                });

                if (!reloadingWeapons.ContainsKey(projectile)) //Prevent already added exceptions in console
                    reloadingWeapons.Add(projectile, reloadTimer);
                
                return true;
            }
        }

        object OnAmmoUnload(BaseProjectile projectile, Item item, BasePlayer player)
        {
            int itemID = projectile.primaryMagazine.ammoType.itemid;
            if (isAllowed(player, itemID)) {
                projectile.primaryMagazine.contents = 0;
                projectile.SendNetworkUpdateImmediate();
                return true;
            }
            return null;
        }

        object OnSwitchAmmo(BasePlayer player, BaseProjectile projectile)
        {
            int itemID = projectile.primaryMagazine.ammoType.itemid;
            if (isAllowed(player, itemID)) {
                projectile.primaryMagazine.contents = 0;
                projectile.SendNetworkUpdateImmediate();
            }
            return null;
        }

        void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            foreach (var weapon in reloadingWeapons)
                if (weapon.Key.GetItem() == oldItem) {
                    weapon.Value.Destroy();
                    reloadingWeapons.Remove(weapon.Key);
                    break;
                }
        }

        private void Unload()
        {
            reloadingWeapons.Clear();
        }
        #endregion
    }
}

// --- End of file: NoAmmoConsumption.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/noob-group ---
// --- Original File Path: N/NoobGroup/NoobGroup.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Noob Group", "Wulf", "2.0.0")]
    [Description("Adds new players to a temporary group, and permanent group on return")]
    public class NoobGroup : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        private class CustomGroup
        {
            public string Name;
            public string Title;
            public int Rank;

            public CustomGroup(string name, string title = "", int rank = 0)
            {
                Name = name;
                Title = string.IsNullOrEmpty(title) ? name.Humanize() : title;
                Rank = rank;
            }
        }

        private class Configuration
        {
            [JsonProperty("Noob group")]
            public CustomGroup NoobGroup = new CustomGroup("noob", "Newbie");

            [JsonProperty("Returning group")]
            public CustomGroup ReturningGroup = new CustomGroup("returning", "Returning");

#if HURTWORLD || RUST
            [JsonProperty("Reset on new save/map wipe")]
            public bool ResetOnWipe = false;
#endif

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandReset"] = "noobreset",
                ["GroupsReset"] = "All groups have been reset",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string permReset = "noobgroup.reset";

        private void Init()
        {
            AddLocalizedCommand(nameof(CommandReset));

            permission.RegisterPermission(permReset, this);
            GroupSetup();

            // TODO: Remove old group cleanup eventually
            if (!config.ReturningGroup.Name.Equals("returningplayers", StringComparison.OrdinalIgnoreCase))
            {
                foreach (string playerId in permission.GetUsersInGroup("returningplayers"))
                {
                    permission.AddUserGroup(CleanId(playerId), config.ReturningGroup.Name);
                    permission.RemoveUserGroup(CleanId(playerId), "returningplayers");
                }
            }

            // TODO: Remove old permission cleanup eventually
            foreach (string playerId in permission.GetPermissionUsers("noobgroup.return"))
            {
                permission.RevokeUserPermission(CleanId(playerId), "noobgroup.return");
            }

#if HURTWORLD || RUST
            if (!config.ResetOnWipe)
            {
                Unsubscribe(nameof(OnNewSave));
            }
#endif
        }

        #endregion Initialization

        private void OnUserConnected(IPlayer player)
        {
            if (!player.BelongsToGroup(config.NoobGroup.Name) && !player.BelongsToGroup(config.ReturningGroup.Name))
            {
                GroupSetup();
                permission.AddUserGroup(player.Id, config.NoobGroup.Name);
            }
            else if (player.BelongsToGroup(config.NoobGroup.Name) && !player.BelongsToGroup(config.ReturningGroup.Name))
            {
                GroupSetup();
                permission.AddUserGroup(player.Id, config.ReturningGroup.Name);
                permission.RemoveUserGroup(player.Id, config.NoobGroup.Name);
            }
        }

        #region Reset Handling

        private void GroupSetup(bool reset = false)
        {
            if (reset)
            {
                if (permission.RemoveGroup(config.NoobGroup.Name))
                {
                    Log($"Group '{config.NoobGroup} removed for reset");
                }
                if (permission.RemoveGroup(config.ReturningGroup.Name))
                {
                    Log($"Group '{config.ReturningGroup} removed for reset");
                }
            }
            if (permission.CreateGroup(config.NoobGroup.Name, config.NoobGroup.Title, config.NoobGroup.Rank))
            {
                Log($"Group '{config.NoobGroup} did not exist, created");
            }
            if (permission.CreateGroup(config.ReturningGroup.Name, config.ReturningGroup.Title, config.ReturningGroup.Rank))
            {
                Log($"Group '{config.ReturningGroup} did not exist, created");
            }
        }

        private void CommandReset(IPlayer player, string command)
        {
            if (!player.HasPermission(permReset))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            GroupSetup(true);
            Message(player, "GroupsReset");
        }

#if HURTWORLD || RUST
        private void OnNewSave() => GroupSetup(true);
#endif

        #endregion Reset Handling

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string CleanId(string playerId) => Regex.Replace(playerId, "[^0-9]", "");

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}


// --- End of file: NoobGroup.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/notes-monitor ---
// --- Original File Path: N/NotesMonitor/NotesMonitor.cs ---

﻿// ReSharper disable CheckNamespace

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Networking;

namespace Oxide.Plugins
{
    [Info( "Notes Monitor", "Mr. Blue", "1.0.3" )]
    [Description( "Send a message to discord with the content of a note set by the user" )]
    public class NotesMonitor : RustPlugin
    {
        #region Configuration

        private const string WEBHOOK_INTRO =
            "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

        private static int? _embedColor;

        private class PluginConfiguration
        {
            [JsonProperty( "Discord Webhook" )] public string DiscordWebhook;
            [JsonProperty( "Embed Color" )] public string EmbedColor;
        }

        private PluginConfiguration _config;

        private void Init()
        {
            _config = Config.ReadObject<PluginConfiguration>();
            _embedColor = FromHex( _config.EmbedColor );

            if( _config.DiscordWebhook == WEBHOOK_INTRO )
            {
                PrintWarning( $"Please set the discord webhook in the configuration file! ({WEBHOOK_INTRO})" );
                Unsubscribe( nameof( OnServerCommand ) );
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject( GetDefaultConfig(), true );
        }

        private PluginConfiguration GetDefaultConfig()
        {
            return new PluginConfiguration
            {
                DiscordWebhook = WEBHOOK_INTRO,
                EmbedColor = "#54a8fc"
            };
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages( new Dictionary<string, string>
            {
                ["EmbedTitle"] = "Note changed!",
                ["EmbedBody"] =
                    "**Player:**\n{playerName}\n{playerId}\n[Steam Profile](https://steamcommunity.com/profiles/{playerId})\n\n" +
                    "**Note content:**\nOld:```\n{oldText}```\nNew:```\n{newText}```\n" +
                    "**Server:\n**{serverName}"
            }, this );
        }

        private string FormatMessage( string key, BasePlayer player, string prevText, string newText )
        {
            return lang.GetMessage( key, this )
                .Replace( "{playerName}", player.displayName )
                .Replace( "{playerId}", player.UserIDString )
                .Replace( "{oldText}", prevText )
                .Replace( "{newText}", newText )
                .Replace( "{serverName}", covalence.Server.Name );
        }

        #endregion

        #region Signage Logic

        private const string NOTE_UPDATE_COMMAND = "note.update";

        private void OnServerCommand( ConsoleSystem.Arg arg )
        {
            if( arg.cmd.FullName != NOTE_UPDATE_COMMAND )
            {
                return;
            }

            if( !arg.HasArgs( 2 ) )
            {
                return;
            }

            var player = arg.Player();
            if( player == null )
            {
                return;
            }

            var id = arg.GetULong( 0 );
            var item = player.inventory.FindItemByUID( new ItemId( id ) );
            if( item == null )
            {
                return;
            }

            var str = arg.GetString( 1 );
            SendDiscordEmbed( player, item?.text ?? string.Empty, str.Truncate( 1024 ) );
        }

        private void SendDiscordEmbed( BasePlayer player, string prevText, string newText )
        {
            prevText = prevText.Replace( "`", "'" );
            newText = newText.Replace( "`", "'" );

            prevText = string.IsNullOrWhiteSpace( prevText ) ? " " : prevText;
            newText = string.IsNullOrWhiteSpace( newText ) ? " " : newText;

            var title = FormatMessage( "EmbedTitle", player, prevText, newText );
            var description = FormatMessage( "EmbedBody", player, prevText, newText );

            var payload = new
            {
                embeds = new[]
                {
                    new
                    {
                        title,
                        description,
                        color = _embedColor,
                        timestamp = DateTime.Now,
                    }
                }
            };

            var form = new WWWForm();
            form.AddField( "payload_json", JsonConvert.SerializeObject( payload ) );

            ServerMgr.Instance.StartCoroutine( HandleUpload( _config.DiscordWebhook, form ) );
        }

        private IEnumerator HandleUpload( string url, WWWForm data )
        {
            var www = UnityWebRequest.Post( url, data );
            yield return www.SendWebRequest();

            if( www.isNetworkError || www.isHttpError )
            {
                Puts( $"Failed to post sign image to discord: {www.error}" );
            }
        }

        #endregion

        #region Helpers

        private static int? FromHex( string value )
        {
            var match = Regex.Match( value, "#?([0-9a-f]{6})" );
            if( !match.Success )
            {
                return null;
            }

            return int.Parse( match.Groups[1].Value, System.Globalization.NumberStyles.HexNumber );
        }

        #endregion
    }
}

// --- End of file: NotesMonitor.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-suicide ---
// --- Original File Path: N/NoSuicide/NoSuicide.cs ---

﻿// TODO: Add option to only block suicide when downed, with optional timer

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("No Suicide", "Wulf/lukespragg", "0.1.5")]
    [Description("Stops players from suiciding/killing themselves")]
    public class NoSuicide : CovalencePlugin
    {
        #region Initialization

        private const string permExclude = "nosuicide.exclude";

        private void Init()
        {
            permission.RegisterPermission(permExclude, this);

            lang.RegisterMessages(new Dictionary<string, string> { ["NotAllowed"] = "Sorry, suicide is not an option!" }, this);
            lang.RegisterMessages(new Dictionary<string, string> { ["NotAllowed"] = "Désolé, le suicide n’est pas un choix !" }, this, "fr");
            lang.RegisterMessages(new Dictionary<string, string> { ["NotAllowed"] = "Es tut uns leid, ist Selbstmord keine Wahl!" }, this, "de");
            lang.RegisterMessages(new Dictionary<string, string> { ["NotAllowed"] = "К сожалению, самоубийство-это не вариант!" }, this, "ru");
            lang.RegisterMessages(new Dictionary<string, string> { ["NotAllowed"] = "Lo sentimos, el suicidio no es una opción!" }, this, "es");
        }

        #endregion Initialization

        #region Suicide Handling

        private bool CanSuicide(string id)
        {
            if (permission.UserHasPermission(id, permExclude))
            {
                return true;
            }

            players.FindPlayer(id)?.Message(lang.GetMessage("NotAllowed", this, id));
            return false;
        }

#if HURTWORLD
        private object OnPlayerSuicide(PlayerSession session) => CanSuicide(session.SteamId.ToString()) ? (object)null : true;
#elif RUST
        private object OnServerCommand(ConsoleSystem.Arg arg) => arg.cmd?.Name != "kill" || CanSuicide(arg.Connection?.userid.ToString()) ? (object)null : true;
#endif

        #endregion Suicide Handling
    }
}


// --- End of file: NoSuicide.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-deauth ---
// --- Original File Path: N/NoDeauth/NoDeauth.cs ---

using System.Collections.Generic;
using System.Text;
using Oxide.Core;
using UnityEngine;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

#region Changelogs and ToDo

/**********************************************************************
1.0.1   :   Blocked TC clearlist
**********************************************************************/

#endregion
namespace Oxide.Plugins
{
    [Info("No Deauth", "Krungh Crow", "1.0.1")]
    [Description("Prevent Deauthing from TC's")]

    class NoDeauth : RustPlugin
    {
        #region Variables

        const string Bypass_Perm = "nodeauth.bypass";

        #endregion

        #region Configuration
        void Init()
        {
            if (!LoadConfigVariables())
            {
                Puts("Config file issue detected. Please delete file, or check syntax and fix.");
                return;
            }
            permission.RegisterPermission(Bypass_Perm, this);
        }

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Global")]
            public SettingsGlobal CFG = new SettingsGlobal();
        }

        class SettingsGlobal
        {
            [JsonProperty(PropertyName = "Prevent deauthing")]
            public bool GlobalDA = true;
        }

        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
                return false;
            }
            SaveConf();
            return true;
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Fresh install detected Creating a new config file.");
            configData = new ConfigData();
            SaveConf();
        }

        void SaveConf() => Config.WriteObject(configData, true);
        #endregion

        #region LanguageAPI
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoDeauthMSG"] = "<color=red>Deauthing is Prohibited on this server!</color>",
                ["Prefix"] = "[<color=green>No Deauth</color>] ",
            }, this);
        }

        #endregion

        #region Hooks

        object OnCupboardDeauthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            if (player != null)
            if (permission.UserHasPermission(player.UserIDString, Bypass_Perm) || configData.CFG.GlobalDA == false) return null;
            {
                string prefix = lang.GetMessage("Prefix", this, player.UserIDString);
                player.ChatMessage(prefix + msg("NoDeauthMSG", player.UserIDString));
            }
            return true;
        }

        object OnCupboardClearList(BuildingPrivlidge privilege, BasePlayer player)
        {
            if (player != null)
            if (permission.UserHasPermission(player.UserIDString, Bypass_Perm) || configData.CFG.GlobalDA == false) return null;
            {
                string prefix = lang.GetMessage("Prefix", this, player.UserIDString);
                player.ChatMessage(prefix + msg("NoDeauthMSG", player.UserIDString));
            }
            return true;
        }
        #endregion

        #region Helpers

        string msg(string key, string id = null) => lang.GetMessage(key, this, id);

        #endregion
    }
}


// --- End of file: NoDeauth.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-vehicle-fuel ---
// --- Original File Path: N/NoVehicleFuel/NoVehicleFuel.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("No Vehicle Fuel", "birthdates", "2.0.3")]
    [Description("No fuel needed for boats and rhibs.")]
    public class NoVehicleFuel : RustPlugin
    {
        #region Variables
        private const string permission_boat = "novehiclefuel.boat";
        private const string permission_copter = "novehiclefuel.copter";
        public static NoVehicleFuel Ins;

        private readonly List<FuelVehicle> cachedVehicles = new List<FuelVehicle>();

        private readonly Dictionary<string, string> PrefabToPermission = new Dictionary<string, string>
        {
            {"assets/content/vehicles/boats/rowboat/rowboat.prefab", permission_boat},
            {"assets/content/vehicles/minicopter/minicopter.entity.prefab", permission_copter}
        };

        private class FuelVehicle : MonoBehaviour
        {

            private BaseEntity Vehicle;
            private StorageContainer FuelTank;

            private void Awake()
            {
                Vehicle = GetComponent<BaseEntity>();
                if (Vehicle == null) End();
                var Boat = Vehicle as MotorRowboat;
                var Copter = Vehicle as MiniCopter;
                if (Boat)
                {
                    FuelTank = Boat.GetFuelSystem()?.fuelStorageInstance.Get(true).GetComponent<StorageContainer>();
                }
                else if (Copter)
                {
                    FuelTank = Copter.GetFuelSystem()?.fuelStorageInstance.Get(true).GetComponent<StorageContainer>();
                }
                else End();
                Ins.cachedVehicles.Add(this);
                if (Ins.cachedVehicles.Count == 1)
                {
                    Ins.Subscribe("OnItemRemovedFromContainer");
                    Ins.Subscribe("OnEntityDismounted");
                    Ins.Subscribe("CanLootEntity");
                }
                if (FuelTank.inventory.GetSlot(0) == null) AddFuel();
            }

            public void AddFuel(int amount = 5)
            {
                ItemManager.CreateByName("lowgradefuel", amount)?.MoveToContainer(FuelTank.inventory);
            }

            public void End(bool remove = false)
            {
                FuelTank?.inventory?.Clear();
                if (remove)
                {
                    Ins.cachedVehicles.Remove(this);
                    if (Ins.cachedVehicles.Count < 1)
                    {
                        Ins.Unsubscribe("OnItemRemovedFromContainer");
                        Ins.Unsubscribe("OnEntityDismounted");
                        Ins.Unsubscribe("CanLootEntity");
                    }

                }
                Destroy(this);
            }

        }
        #endregion

        #region Hooks
        private void Init()
        {
            LoadConfig();
            permission.RegisterPermission(permission_boat, this);
            permission.RegisterPermission(permission_copter, this);
            Ins = this;
        }

        private void OnServerInitialized() => SetupMounted();

        private void SetupMounted()
        {
            foreach (var Entity in BaseNetworkable.serverEntities)
            {
                var Vehicle = Entity as BaseVehicle;
                if (Vehicle == null) continue;
                if (!Vehicle.HasDriver()) continue;
                var Mount = Vehicle.mountPoints[0].mountable;
                var Driver = Mount.GetMounted();
                if (Driver == null) continue;
                OnEntityMounted(Mount, Driver);
            }
        }

        private void Unload()
        {
            foreach (var Vehicle in cachedVehicles)
            {
                Vehicle.End();
            }
        }

        private void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            var Entity = entity.GetParentEntity();
            if (Entity == null) return;
            var Prefab = Entity.PrefabName;
            if (!PrefabToPermission.ContainsKey(Prefab)) return;

            if (_config.Disabled.Contains(Prefab)) return;
            var Permission = PrefabToPermission[Prefab];
            if (!permission.UserHasPermission(player.UserIDString, Permission)) return;
            Entity.gameObject.AddComponent<FuelVehicle>();
        }

        private void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            var FuelVehicle = entity.GetComponent<FuelVehicle>();
            if (!FuelVehicle) return;
            FuelVehicle.End(true);
        }

        private object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            var Parent = container.GetParentEntity();
            if (Parent == null) return null;

            if (Parent.GetComponent<FuelVehicle>()) return false;
            return null;
        }

        private void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            var Parent = container.entityOwner?.GetParentEntity();

            if (Parent == null) return;
            var FuelVehicle = Parent.GetComponent<FuelVehicle>();
            if (!FuelVehicle) return;

            FuelVehicle.AddFuel(item.amount == 0 ? 5 : item.amount);

        }
        #endregion

        #region Configuration & Language
        public ConfigFile _config;

        public class ConfigFile

        {
            [JsonProperty("Disabled Vehicles (Prefab)")]
            public List<string> Disabled;
            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile()
                {
                    Disabled = new List<string>
                    {
                        "assets/content/vehicles/minicopter/minicopter.entity.prefab"
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        #endregion
    }
}
//Generated with birthdates' Plugin Maker


// --- End of file: NoVehicleFuel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-mini ---
// --- Original File Path: N/NoMini/NoMini.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;


namespace Oxide.Plugins
{
    [Info("No Mini", "Sche1sseHund", 0.9)]
    [Description("Prevents users from using/buying mini and scrap transport helicopters")]
    class NoMini : RustPlugin
	{
		private ConfigFile CfgFile; 
        
        private const string PERMISSION_ALLOWMINI = "nomini.allowmini";	
        private const string PERMISSION_ALLOWATTACK = "nomini.allowattack";	
        private const string PERMISSION_ALLOWSCRAPPY = "nomini.allowscrappy";	
        private const string PERMISSION_ALLOWAIRWOLFVEND = "nomini.allowairwolf";	
        
        
        private const string PREFAB_MINICOPTER = "assets/content/vehicles/minicopter/minicopter.entity.prefab";        
        private const string PREFAB_SCRAPTRANSPORT = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab";               
        private const string PREFAB_ATTACKCOPTER = "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab";
		private const string PREFAB_BANDITNPC1="assets/prefabs/npc/bandit/shopkeepers/bandit_conversationalist.prefab";
        private const string PREFAB_BANDITNPC1_SHORT="bandit_conversationalist";
        
        
        void Init()
        {        	
			permission.RegisterPermission(PERMISSION_ALLOWMINI, this); 
            permission.RegisterPermission(PERMISSION_ALLOWSCRAPPY, this); 
            permission.RegisterPermission(PERMISSION_ALLOWATTACK, this);             
            permission.RegisterPermission(PERMISSION_ALLOWAIRWOLFVEND, this);   
           
        }        
        
        object OnEngineStart(BaseVehicle vehicle, BasePlayer driver)
		{	
        	
        	
            if((vehicle.name == PREFAB_MINICOPTER) && !permission.UserHasPermission(driver.UserIDString,PERMISSION_ALLOWMINI))
            {
            	PrintToChat(driver, lang.GetMessage("NoMini", this, driver.UserIDString));   
                return false;
            }   
                
            if((vehicle.name == PREFAB_SCRAPTRANSPORT) && !permission.UserHasPermission(driver.UserIDString,PERMISSION_ALLOWSCRAPPY))
            {                	
             	PrintToChat(driver, lang.GetMessage("NoScrappy", this, driver.UserIDString));   
				return false;
			}
                
            if((vehicle.name == PREFAB_ATTACKCOPTER) && !permission.UserHasPermission(driver.UserIDString,PERMISSION_ALLOWATTACK))
            {                	
             	PrintToChat(driver, lang.GetMessage("NoAttack", this, driver.UserIDString));   
				return false;
			}
            
    		return null;
		}
        
        
        void OnEntitySpawned(BaseVehicle entity)
		{
			
        	if((entity.name == PREFAB_MINICOPTER && CfgFile.KillMiniOnSpawn) || (entity.name == PREFAB_SCRAPTRANSPORT && CfgFile.KillScrappyOnSpawn)  || (entity.name == PREFAB_ATTACKCOPTER && CfgFile.KillAttackOnSpawn))
            {   
                    NextTick(() => { KillMini((BaseVehicle)  entity); });                    
            }
                
			
		}
        void KillMini(BaseVehicle entity)
        {           				
           
           if(CfgFile.ExplodeOnKill)            
				entity.DieInstantly();				
            else
            	entity.Kill();                     
                
		}
        
        object OnNpcConversationStart(NPCTalking npcTalking, BasePlayer player, ConversationData conversationData)
		{
        	//Puts(npcTalking.name);
            if((npcTalking.name == PREFAB_BANDITNPC1 || npcTalking.name == PREFAB_BANDITNPC1_SHORT) && CfgFile.DisableBanditVendor  && !permission.UserHasPermission(player.UserIDString,PERMISSION_ALLOWAIRWOLFVEND))
            {
            	PrintToChat(player, lang.GetMessage("NoVendor", this, player.UserIDString));   
        		return false; 
            }
             
    		return null;
		}
        #region Config
        
        public class ConfigFile
        {         	
        	public bool KillMiniOnSpawn { get; set; }
            public bool KillAttackOnSpawn { get; set; }
            public bool KillScrappyOnSpawn { get; set; }
            public bool ExplodeOnKill  { get; set; }
            public bool DisableBanditVendor  { get; set; }
        	
            public ConfigFile()
			{            	
                
            		KillMiniOnSpawn = true;
                    KillAttackOnSpawn = true;
                    KillScrappyOnSpawn = true;
                    ExplodeOnKill = true;
                    DisableBanditVendor =true;
	        }
        	
    	}
        
        protected override void LoadDefaultConfig()
        {
			PrintWarning("Creating a new default configuration file.");
        	CfgFile = new ConfigFile();
		}

        protected override void LoadConfig()
        {
			base.LoadConfig();
			try
	        {
        		CfgFile = Config.ReadObject<ConfigFile>();
				if(CfgFile == null) CreateNewConfig();
            }
			catch { CreateNewConfig(); }
        }

        protected override void SaveConfig() => Config.WriteObject(CfgFile);

        private void CreateNewConfig()
        {
	    	PrintWarning($"Configuration file is not valid. Creating a new one.");
			CfgFile = new ConfigFile();
	        SaveConfig();
		}
        
        #endregion
        
        #region Lang
        
        protected override void LoadDefaultMessages()
		{
			// English
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["NoMini"] = "You are not allowed to use minicopters on this server.",				
                ["NoScrappy"] = "You are not allowed to use scrap transport helicopters on this server.",	
                ["NoAttack"] = "You are not allowed to use personal attack helicopters on this server.",	
                ["NoVendor"] = "You are not allowed to talk to this vendor.",
			}, this, "en");
            
            // Espanol
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["NoMini"] = "No estÃƒÆ’Ã‚Â¡ permitido usar minicÃƒÆ’Ã‚Â³pteros en este servidor",				
                ["NoScrappy"] = "No estÃƒÆ’Ã‚Â¡ permitido usar helicÃƒÆ’Ã‚Â³pteros chatarra en este servidor",	
                ["NoAttack"] = "No está permitido utilizar helicópteros de ataque personales en este servidor",	
                ["NoVendor"] = "No tienes permitido hablar con esta tendera.",
			}, this, "es");
            
            // Deutsch
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["NoMini"] = "Auf diesem Server darfst du keine Minikopter benutzen",				
                ["NoScrappy"] = "Sie kÃƒÆ’Ã‚Â¶nnen auf diesem Server keine Schrott Helikopter verwenden",	
                ["NoAttack"] = "Der Einsatz persönlicher Kampfhubschrauber ist auf diesem Server nicht gestattet.",	
                ["NoVendor"] = "Sie dÃ¼rfen nicht mit diesem Ladenbesitzer sprechen.",
			}, this, "de");
		}
        
        #endregion
        
        
	}
}


// --- End of file: NoMini.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-pickup-penalty ---
// --- Original File Path: N/NoPickupPenalty/NoPickupPenalty.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;

/*
 * Rewritten from scratch and maintained to present by VisEntities
 * Originally created by Orange, up to version 1.1.1
 */

namespace Oxide.Plugins
{
    [Info("No Pickup Penalty", "VisEntities", "2.0.0")]
    [Description("Disables condition loss for deployables when picked up.")]
    public class NoPickupPenalty : RustPlugin
    {
        #region Fields

        private static NoPickupPenalty _plugin;
        private static Configuration _config;

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Unbreakable Entities")]
            public List<string> UnbreakableEntities { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Config changes detected! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Config update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                UnbreakableEntities = new List<string>()
                {
                    "furnace",
                    "composter",
                    "box.wooden.large",
                    "workbench1.deployed",
                    "workbench2.deployed",
                    "workbench3.deployed",
                    "woodbox_deployed"
                },
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void Init()
        {
            _plugin = this;
            PermissionUtil.RegisterPermissions();
        }

        private void Unload()
        {
            _config = null;
            _plugin = null;
        }

        private object CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
        {
            if (player != null && entity != null && PermissionUtil.HasPermission(player, PermissionUtil.USE))
            {
                if (_config.UnbreakableEntities.Contains(entity.ShortPrefabName))
                    entity.pickup.subtractCondition = 0f;
            }

            return null;
        }

        #endregion Oxide Hooks

        #region Permission

        private static class PermissionUtil
        {
            public const string USE = "nopickuppenalty.use";
            private static readonly List<string> _permissions = new List<string>
            {
                USE,
            };

            public static void RegisterPermissions()
            {
                foreach (var permission in _permissions)
                {
                    _plugin.permission.RegisterPermission(permission, _plugin);
                }
            }

            public static bool HasPermission(BasePlayer player, string permissionName)
            {
                return _plugin.permission.UserHasPermission(player.UserIDString, permissionName);
            }
        }

        #endregion Permission
    }
}

// --- End of file: NoPickupPenalty.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-heli-fire ---
// --- Original File Path: N/NoHeliFire/NoHeliFire.cs ---

﻿using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("No Heli Fire", "Tryhard", "1.2.6")]
    [Description("Optionally removes the explosion sound, gibs and fire effect from mini- and scrap helicopters")]
    public class NoHeliFire : RustPlugin
    {
        private ConfigData configData = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Disable minicopter gibs")]
            public bool mGibs = true;

            [JsonProperty(PropertyName = "Disable minicopter fire")]
            public bool mFire = true;

            [JsonProperty(PropertyName = "Disable minicopter explosion sound")]
            public bool mExplo = true;



            [JsonProperty(PropertyName = "Disable scraphelicopter gibs")]
            public bool sGibs = true;

            [JsonProperty(PropertyName = "Disable scraphelicopter explosion sound")]
            public bool sExplo = true;

            [JsonProperty(PropertyName = "Disable scraphelicopter fire ")]
            public bool sFire = true;



            [JsonProperty(PropertyName = "Disable attackhelicopter gibs")]
            public bool aGibs = true;

            [JsonProperty(PropertyName = "Disable attackhelicopter explosion sound")]
            public bool aExplo = true;

            [JsonProperty(PropertyName = "Disable attackhelicopter fire ")]
            public bool aFire = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                configData = Config.ReadObject<ConfigData>();

                if (configData == null) LoadDefaultConfig();
            }

            catch
            {
                PrintError("Configuration file is corrupt, check your config file at https://jsonlint.com/!");
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => configData = new ConfigData();

        protected override void SaveConfig() => Config.WriteObject(configData);


        private void OnEntitySpawned(ScrapTransportHelicopter entity)
        {

            if (configData.sExplo) entity.explosionEffect.guid = null;

            if (configData.sFire) entity.fireBall.guid = null;

            if (configData.sGibs) entity.serverGibs.guid = null;
        }

        private void OnEntitySpawned(Minicopter entity)
        {
            if (configData.mExplo) entity.explosionEffect.guid = null;

            if (configData.mFire) entity.fireBall.guid = null;

            if (configData.mGibs) entity.serverGibs.guid = null;
        }

        private void OnEntitySpawned(AttackHelicopter entity)
        {
            if (configData.aExplo) entity.explosionEffect.guid = null;

            if (configData.aFire) entity.fireBall.guid = null;

            if (configData.aGibs) entity.serverGibs.guid = null;
        }
    }
}

// --- End of file: NoHeliFire.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/noob-messages ---
// --- Original File Path: N/NoobMessages/NoobMessages.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("NoobMessages", "FastBurst", "2.0.3")]
    [Description("Displays a message when a player joins the server for the first time")]
    class NoobMessages : RustPlugin
    {
        #region Vars
        List<ulong> allplayers = new();
        List<BasePlayer> unAwake = new();
        private static NoobMessages ins { get; set; }
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            ins = this;
        }

        private void Loaded()
        {
            ins = this;
            lang.RegisterMessages(Messages, this);
            LoadData();

            foreach (var player in BasePlayer.activePlayerList)
                if (!allplayers.Contains(player.userID))
                    allplayers.Add(player.userID);
        }

        private void OnServerSave() => SaveData();

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!allplayers.Contains(player.userID))
            {
                allplayers.Add(player.userID);

                if (configData.General.Announce)
                    SendChatMessage("AnnounceAll", player.displayName);

                if (configData.General.Welcome)
                    unAwake.Add(player);
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (unAwake.Contains(player))
            {
                SendMessage(player, string.Format(msg("WelcomePlayer"), player.displayName));
                unAwake.Remove(player);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (unAwake.Contains(player))
                unAwake.Remove(player);
            SaveData();
        }

        private void Unload()
        {
            unAwake.Clear();
            SaveData();
        }
        #endregion

        #region Configuration
        private static ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "General Settings")]
            public GeneralOptions General { get; set; }

            public class GeneralOptions
            {
                [JsonProperty(PropertyName = "Announce to all players")]
                public bool Announce { get; set; }
                [JsonProperty(PropertyName = "Display a welcome message for new player")]
                public bool Welcome { get; set; }
                [JsonProperty(PropertyName = "Enable Chat Prefix")]
                public bool enablePrefix { get; set; }
                [JsonProperty(PropertyName = "Chat Prefix")]
                public string Prefix { get; set; }
                [JsonProperty(PropertyName = "Chat Icon (example 7656110000000000)")]
                public ulong ChatIcon { get; set; }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                General = new ConfigData.GeneralOptions
                {
                    Announce = true,
                    Welcome = true,
                    enablePrefix = true,
                    Prefix = "[Welcome Announcer]",
                    ChatIcon = 0
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new Core.VersionNumber(2, 0, 0))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
        #endregion

        #region Data Management
        private void SaveData() => Interface.Oxide.DataFileSystem.GetFile(this.Name).WriteObject(allplayers);

        private void LoadData()
        {
            try
            {
                allplayers = Interface.Oxide.DataFileSystem.GetFile(this.Name).ReadObject<List<ulong>>();
            }
            catch
            {
                allplayers = new List<ulong>();
            }
        }
        #endregion

        #region Localization
        private void SendMessage(BasePlayer player, string key, params object[] args)
        {
            string prefix;
            if (configData.General.enablePrefix) prefix = configData.General.Prefix;
            else prefix = null;

            Player.Message(player, (args != null ? string.Format(msg(key, player.UserIDString), args) : msg(key, player.UserIDString)), prefix, configData.General.ChatIcon);
        }
        private void SendChatMessage(string key, params object[] args)
        {
            string prefix;
            if (configData.General.enablePrefix) prefix = configData.General.Prefix;
            else prefix = null;

            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                BasePlayer player = BasePlayer.activePlayerList[i];
                Player.Message(player, (args != null ? string.Format(msg(key, player.UserIDString), args) : msg(key, player.UserIDString)), prefix, configData.General.ChatIcon);
            }
        }

        private static string msg(string key, string playerId = null) => ins.lang.GetMessage(key, ins, playerId);

        private Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["AnnounceAll"] = "<size=13><color=green>{0} is a new player, be helpful and try not to KOS!</color></size>",
            ["WelcomePlayer"] = "<color=green>Welcome to the server, {0}! Have a good time!</color>"
        };
        #endregion
    }
}

// --- End of file: NoobMessages.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-foundation-objects ---
// --- Original File Path: N/NoFoundationObjects/NoFoundationObjects.cs ---

using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("NoFoundationObjects", "mvrb", "1.0.0")]
	[Description("Blocks objects under foundations")]
    class NoFoundationObjects : RustPlugin
    {
        private Dictionary<string, string> deployables = new Dictionary<string, string>();

        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Error: CannotPlace"] = "You can't place {0} under foundations!"
            }, this);
        }

        private void OnServerInitialized()
        {
            LoadVariables();

            foreach (ItemDefinition itemDef in ItemManager.GetItemDefinitions())
            {
                if (itemDef.GetComponent<ItemModDeployable>() == null) continue;

                if (!deployables.ContainsKey(itemDef.GetComponent<ItemModDeployable>().entityPrefab.resourcePath))
                {
                    deployables.Add(itemDef.GetComponent<ItemModDeployable>().entityPrefab.resourcePath, itemDef.displayName.english);
                }
            }
        }

        private void OnEntityBuilt(Planner planner, GameObject obj)
        {
            if (planner == null || obj == null) return;

            if (configData.PreventBuildAboveStash && obj.GetComponent<StashContainer>() != null)
            {
                obj.layer = LayerMask.NameToLayer("Prevent Building");
                obj.transform.localScale = new Vector3(1f, 3f, 1f);
            }

            if (obj.GetComponent<BuildingBlock>() != null) return;

            BaseEntity deployable = obj.GetComponent<BaseEntity>();

            if (deployables.ContainsKey(deployable?.gameObject.name))
            {
                string name = deployables[deployable?.gameObject.name];

                if (configData.BlackList.Contains(name))
                {
                    List<BaseEntity> nearby = new List<BaseEntity>();
                    Vis.Entities(obj.transform.position, 2f, nearby, LayerMask.GetMask("Construction"), QueryTriggerInteraction.Ignore);

                    foreach (BaseEntity entity in nearby.Distinct().ToList().Where(x => x.ShortPrefabName == "foundation" && (int)(x as BuildingBlock)?.grade > 1))
                    {
                        float distFromCenter = Vector3.Distance(entity.CenterPoint(), obj.transform.position);

                        if (distFromCenter <= 1.75f && entity.transform.position.y > obj.transform.position.y)
                        {
                            BasePlayer player = planner.GetOwnerPlayer();
                            var ent = obj.GetComponent<BaseEntity>();

                            player.ChatMessage(Lang("Error: CannotPlace", player.UserIDString, name));

                            ent?.KillMessage();
                            break;
                        }
                    }
                }
            }
        }

        #region Config        
        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Prevent building above Small Stashes")]
            public bool PreventBuildAboveStash { get; set; }

            [JsonProperty(PropertyName = "List of blocked objects")]
            public List<string> BlackList { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                PreventBuildAboveStash = true,
                BlackList = new List<string>()
                {
                    "Sleeping Bag",
                    "Furnace",
                    "Repair Bench",
                    "Research Table",
                    "Barbeque",
                    "Lantern",
                    "Skull Fire Pit",
                    "Small Stash",
                    "Camp Fire",
                    "Wood Storage Box",
                    "Large Wood Box",
                    "Jack O lantern Angry",
                    "Jack O lantern Happy"
                }
            };

            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
    }
}

// --- End of file: NoFoundationObjects.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/never-teamless ---
// --- Original File Path: N/NeverTeamless/NeverTeamless.cs ---

﻿using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Never Teamless", "Dana", "1.0.0")]
    [Description("No one goes without a team, even if it's a team of one.")]

    public class NeverTeamless : RustPlugin
    {
        #region Fields

        private Coroutine _teamFormationCoroutine;
        private static Configuration _config;
        private Timer _scanTimer;

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Scan Interval Seconds")]
            public float ScanIntervalSeconds { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Detected changes in configuration! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Configuration update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                ScanIntervalSeconds = 300f
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            _scanTimer = timer.Every(_config.ScanIntervalSeconds, () =>
            {
                StartTeamFormationProcess();
            });
        }

        private void Unload()
        {
            _scanTimer?.Destroy();
            StopTeamFormationProcess();
            _config = null;
        }

        #endregion Oxide Hooks

        #region Functions

        private IEnumerator FormTeams()
        {
            WaitForSeconds waitDuration = ConVar.FPS.limit > 80 ? CoroutineEx.waitForSeconds(0.01f) : null;

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.Team != null)
                    continue;

                RelationshipManager.PlayerTeam newTeam = RelationshipManager.ServerInstance.CreateTeam();
                newTeam.AddPlayer(player);
                yield return waitDuration;
            }
        }

        private void StartTeamFormationProcess()
        {
            _teamFormationCoroutine = ServerMgr.Instance.StartCoroutine(FormTeams());
        }

        private void StopTeamFormationProcess()
        {
            if (!_teamFormationCoroutine.IsUnityNull())
            {
                ServerMgr.Instance.StopCoroutine(_teamFormationCoroutine);
                _teamFormationCoroutine = null;
            }
        }

        #endregion Functions
    }
}


// --- End of file: NeverTeamless.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-sash ---
// --- Original File Path: N/NoSash/NoSash.cs ---

﻿using System.Linq;

namespace Oxide.Plugins
{
    [Info("No Sash", "Wulf", "1.0.2")]
    [Description("Blocks sashes from showing on players")]
    public class NoSash : CovalencePlugin
    {
        private void OnServerInitialized()
        {
            foreach (BasePlayer player in BaseNetworkable.serverEntities.OfType<BasePlayer>())
            {
                OnPlayerSpawn(player);
            }
        }

        private void Unload()
        {
            foreach (BasePlayer player in BaseNetworkable.serverEntities.OfType<BasePlayer>())
            {
                if (player?.inventory != null)
                {
                    player.inventory.containerBelt.onItemAddedRemoved -= OnItemAddedRemoved;
                    player.inventory.containerMain.onItemAddedRemoved -= OnItemAddedRemoved;
                    player.inventory.containerWear.onItemAddedRemoved -= OnItemAddedRemoved;
                }
            }
        }

        private void OnPlayerSpawn(BasePlayer player)
        {
            NextFrame(() =>
            {
                if (player?.inventory != null)
                {
                    player.inventory.containerBelt.onItemAddedRemoved += OnItemAddedRemoved;
                    player.inventory.containerMain.onItemAddedRemoved += OnItemAddedRemoved;
                    player.inventory.containerWear.onItemAddedRemoved += OnItemAddedRemoved;
                }
            });
        }

        private void OnItemAddedRemoved(Item item, bool added)
        {
            BasePlayer player = item?.parent?.playerOwner;
            if (player != null)
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.DisplaySash, false);
            }
        }
    }
}


// --- End of file: NoSash.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rust-notice ---
// --- Original File Path: N/Notice/Notice.cs ---

﻿using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Notice", "LaserHydra", "1.0.1", ResourceId = 1193)]
    [Description("Notice players anonymously")]
    class Notice : RustPlugin
    {
        void Loaded()
        {
            LoadDefaultConfig();
            if (!permission.PermissionExists("canNotice")) permission.RegisterPermission("canNotice", this);
        }

        protected override void LoadDefaultConfig()
        {
			if(Config["Prefix"] == null) Config["Prefix"] = "<color=red>ADMIN</color>";
			if(Config["Prefix"].ToString() != "<color=red>ADMIN</color>") return;
            SaveConfig();
        }
		
        [ChatCommand("notice")]
        void cmdNotice(BasePlayer player, string cmd, string[] args)
        {
            string uid = player.userID.ToString();
            if (!permission.UserHasPermission(uid, "canNotice"))
            {
                SendChatMessage(player, "NOTICE", "You have no permission to use this command!");
                return;
            }

            if (args.Length < 2)
            {
                SendChatMessage(player, "NOTICE", "Syntax: /notice <player> <message>");
                return;
            }

            string msg = ArrayToString(args, 1);
            string prefix = Config["Prefix"].ToString();
            BasePlayer targetPlayer = GetPlayer(args[0], player, "NOTICE");
            if (targetPlayer != null)
            {
                SendChatMessage(targetPlayer, prefix, msg);
                SendChatMessage(player, "NOTICE", "Message sent!");
            }
        }

        #region UsefulMethods
        //--------------------------->   Player finding   <---------------------------//

        BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix)
        {
            BasePlayer targetPlayer = null;
            List<string> foundPlayers = new List<string>();
            string searchedLower = searchedPlayer.ToLower();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                string display = player.displayName;
                string displayLower = display.ToLower();

                if (!displayLower.Contains(searchedLower))
                {
                    continue;
                }
                if (displayLower.Contains(searchedLower))
                {
                    foundPlayers.Add(display);
                }
            }
            var matchingPlayers = foundPlayers.ToArray();

            if (matchingPlayers.Length == 0)
            {
                SendChatMessage(executer, prefix, "No matching players found!");
            }

            if (matchingPlayers.Length > 1)
            {
                SendChatMessage(executer, prefix, "Multiple players found:");
                string multipleUsers = "";
                foreach (string matchingplayer in matchingPlayers)
                {
                    if (multipleUsers == "")
                    {
                        multipleUsers = "<color=yellow>" + matchingplayer + "</color>";
                        continue;
                    }

                    if (multipleUsers != "")
                    {
                        multipleUsers = multipleUsers + ", " + "<color=yellow>" + matchingplayer + "</color>";
                    }

                }
                SendChatMessage(executer, prefix, multipleUsers);
            }

            if (matchingPlayers.Length == 1)
            {
                targetPlayer = BasePlayer.Find(matchingPlayers[0]);
            }
            return targetPlayer;
        }

        //---------------------------->   Converting   <----------------------------//

        string ArrayToString(string[] array, int first)
        {
            int count = 0;
            string output = array[first];
            foreach (string current in array)
            {
                if (count <= first)
                {
                    count++;
                    continue;
                }

                output = output + " " + current;
                count++;
            }
            return output;
        }

        //---------------------------->   Chat Sending   <----------------------------//

        void BroadcastChat(string prefix, string msg)
        {
            PrintToChat("<color=orange>" + prefix + "</color>: " + msg);
        }

        void SendChatMessage(BasePlayer player, string prefix, string msg)
        {
            SendReply(player, "<color=orange>" + prefix + "</color>: " + msg);
        }

        //---------------------------------------------------------------------------//
        #endregion
    }
}

// --- End of file: Notice.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/name-rewards ---
// --- Original File Path: N/NameRewards/NameRewards.cs ---

﻿using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("NameRewards", "Kappasaurus", "1.0.0", ResourceId = 0)]
    [Description("Adds players to a group based on phrases in their name")]

    class NameRewards : CovalencePlugin
    {
        ConfigData config;

        class ConfigData
        {
            public string Group { get; set; }
            public string[] Phrases { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new ConfigData
            {
                Group = "vip",
                Phrases = new[] { "Oxide", "Example" }
            }, true);
        }

        void Init()
        {
            config = Config.ReadObject<ConfigData>();
            if (!permission.GroupExists(config.Group))
                permission.CreateGroup(config.Group, config.Group, 0);
        }

        void OnUserConnected(IPlayer player)
        {
            foreach (var phrase in config.Phrases)
            {
                if (permission.UserHasGroup(player.Id, config.Group)) break;
                if (player.Name.ToLower().Contains(phrase.ToLower()))
                {
                    permission.AddUserGroup(player.Id, config.Group);
                    break;
                }
                permission.RemoveUserGroup(player.Id, config.Group);
            }
        }
    }
}

// --- End of file: NameRewards.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-mlrs-mount ---
// --- Original File Path: N/NoMLRSMount/NoMLRSMount.cs ---

using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;
using Rust;


namespace Oxide.Plugins
{
    [Info("No MLRS Mount", "Lincoln", "1.0.4")]
    [Description("Disallows people from using the MLRS.")]

    class NoMLRSMount : RustPlugin
    {
        private const string permBypass = "nomlrsmount.bypass";

        private void Init()
        {
            permission.RegisterPermission(permBypass, this);
            {
                    foreach (var mlrs in BaseMountable.serverEntities.OfType<MLRS>().ToArray())
                    {
                        if (mlrs == null) continue;

                        BasePlayer player = mlrs.GetMounted() ?? null;

                        if (player != null && !permission.UserHasPermission(player.UserIDString, permBypass))
                        {
                            Puts("Found player " + player.displayName + " mounted on MLRS, dismounting...");
                            mlrs.DismountAllPlayers();
                        }
                        return; 
                    }
            }
        }
        object CanMountEntity(BasePlayer player, MLRS entity)
        {
            if (!player.IsNpc && !permission.UserHasPermission(player.UserIDString, permBypass))
            {
                ChatMessage(player, "Disabled");
                return false;
            }
            return null;
        }
        #region Localization

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player.IPlayer, messageName), args));

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Disabled"] = "MLRS has been <color=red>disabled</color> on this server."

            }, this, "en");
        }
        #endregion
    }
}

// --- End of file: NoMLRSMount.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-heli-flyhack ---
// --- Original File Path: N/NoHeliFlyhack/NoHeliFlyhack.cs ---

namespace Oxide.Plugins
{
	[Info("No Heli Flyhack", "Dooby Skoo", "1.2.1")]
	[Description("Prevents players getting kicked for flyhacking after dismounting helicopters.")]

	public class NoHeliFlyhack : RustPlugin
	{
        private const string FHPerm = "noheliflyhack.use";
        private void Init()
        {
            permission.RegisterPermission(FHPerm, this);
        }

        private void OnEntityDismounted(BaseNetworkable entity, BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, FHPerm) && (entity.GetParentEntity() is PlayerHelicopter) || (entity.GetParentEntity() is CH47Helicopter))
            {
                player.PauseFlyHackDetection(5.0f);
            }
        }
    }
}

// --- End of file: NoHeliFlyhack.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/nudist-heli ---
// --- Original File Path: N/NudistHeli/NudistHeli.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Nudist Heli", "Panduck", "0.1.1")]
    [Description("Configurable helicopter engagement behaviour.")]
    public class NudistHeli : RustPlugin
    {

        #region Fields

        private NudistHeliSettings _settings;
        
        private Dictionary<BasePlayer, double> _hostilePlayers;
        private static double CurrentTime => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        #endregion

        #region Config
        
        private static NudistHeliSettings GetDefaultConfig()
        {
            return new NudistHeliSettings()
            {
                MaxClothingCount = 3,
                HostileTime = 6f,
                OnlyEngageOnWeaponHeld = false,
                RestrictedWeapons = new HashSet<string>()
                {
                    "rifle.ak",
                    "rifle.bolt",
                    "smg.2",
                    "shotgun.double",
                    "rifle.l96",
                    "rifle.lr300",
                    "lmg.m249",
                    "rifle.m39",
                    "pistol.m92",
                    "smg.mp5",
                    "shotgun.pump",
                    "pistol.python",
                    "pistol.revolver",
                    "rocket.launcher",
                    "pistol.semiauto",
                    "rifle.semiauto",
                    "shotgun.spas12",
                    "smg.thompson"
                }
            };
        }
        
        public class NudistHeliSettings
        {
            public int MaxClothingCount { get; set; }
            public float HostileTime { get; set; }
            public HashSet<string> RestrictedWeapons { get; set; }
            public bool OnlyEngageOnWeaponHeld { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            _settings = Config.ReadObject<NudistHeliSettings>();
            _hostilePlayers = new Dictionary<BasePlayer, double>();
        }
        
        private void OnEntityKill(BaseNetworkable entity)
        {
            if(entity is BaseHelicopter)
            {
                ClearHostiles();
            }
        }
        
        private bool CanHelicopterTarget(PatrolHelicopterAI heli, BasePlayer player)
        {
            return player.IsAlive() && !player.IsNpc && IsHostile(player);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            RemoveHostile(player);
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            player.cachedThreatLevel = 0f;
            RemoveHostile(player);
        }

        private object OnThreatLevelUpdate(BasePlayer player)
        {
            if (_settings.OnlyEngageOnWeaponHeld)
            {
                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    BaseEntity heldEntity = item.GetHeldEntity();
                    if (!_settings.RestrictedWeapons.Contains(item.info.shortname)) continue;
                    if (heldEntity == null || !(heldEntity is BaseProjectile) || heldEntity is BowWeapon) continue;
                    player.cachedThreatLevel += 2f;
                    SetHostile(player, _settings.HostileTime);
                    break;
                }
            }
            else
            {
                if (player.inventory.containerWear.itemList.Count >= _settings.MaxClothingCount)
                {
                    player.cachedThreatLevel += 2f;
                    SetHostile(player, _settings.HostileTime);
                }

                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    BaseEntity heldEntity = item.GetHeldEntity();
                    if (!_settings.RestrictedWeapons.Contains(item.info.shortname)) continue;
                    if (heldEntity == null || !(heldEntity is BaseProjectile) || heldEntity is BowWeapon) continue;
                    player.cachedThreatLevel += 2f;
                    SetHostile(player, _settings.HostileTime);
                    break;
                }
            }

            return true;
        }

        #endregion

        #region Helpers

        private bool IsHostile(BasePlayer player)
        {
            if (!_hostilePlayers.ContainsKey(player))
            {
                return false;
            }

            return _hostilePlayers[player] - CurrentTime > 0;
        }

        private void SetHostile(BasePlayer player, float duration)
        {
            if (!_hostilePlayers.ContainsKey(player))
            {
                _hostilePlayers.Add(player, 0);
            }

            _hostilePlayers[player] = CurrentTime + duration;
        }

        private void RemoveHostile(BasePlayer player)
        {
            if (_hostilePlayers.ContainsKey(player))
            {
                _hostilePlayers.Remove(player);
            }
        }
        
        private void ClearHostiles()
        {
            _hostilePlayers.Clear();
        }

        #endregion

    }
}

// --- End of file: NudistHeli.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-crawl ---
// --- Original File Path: N/NoCrawl/NoCrawl.cs ---

namespace Oxide.Plugins
{
    [Info("No Crawl", "Bushhy", "1.0.1")]
    [Description("A simple plugin to disable the crawling state.")]
    public class NoCrawl : RustPlugin
    {
        object OnPlayerWound(BasePlayer player, HitInfo hitInfo)
        {
        	NextFrame(() => {
            	if (player == null) return;
            	if (player.HasPlayerFlag(BasePlayer.PlayerFlags.Wounded))
            	{
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Incapacitated, b: true);
            	}
            });
            return null;            
        }
    }
}

// --- End of file: NoCrawl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-raid ---
// --- Original File Path: N/NoRaid/NoRaid.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("NoRaid", "Ryan", "1.3.22", ResourceId = 2530)]
    [Description("Prevents players destroying buildings of those they're not associated with")]

    class NoRaid : RustPlugin
    {
        #region Declaration

        // Helpers
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        // Config, instance, plugin references
        [PluginReference] private Plugin Friends, Clans;
        private static ConfigFile cFile;
        private static NoRaid _instance;

        // Variables
        private bool _canWipeRaid;
        private bool _canRaid;
        private float _startMinutes;

        // Timers
        private Timer _uiTimer;
        private Timer _startTimer;
        private Timer _wipeCheckTimer;
        private Timer _startUiTimer;

        // Cached dates
        private DateTime _cachedWipeTime;
        private DateTime _cachedRaidTime;

        // Active UI players, cached UI container, UI parent constants
        private HashSet<ulong> _uiPlayers = new HashSet<ulong>();
        private CuiElementContainer _cachedContainer;
        private const string _uiParent = "Timer_Body";
        private const string _timerParent = "Timer_Parent";

        // Permissions
        private const string _perm = "noraid.admin";

        #endregion

        #region Config

        private class ConfigFile
        {
            public FriendBypass FriendBypass;

            public bool StopAllRaiding;

            public WipeRaiding WipeRaiding;

            public NoRaidCommand NoRaidCommand;

            public UiSettings Ui;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    FriendBypass = new FriendBypass()
                    {
                        Enabled = true,
                        FriendsApi = new FriendsAPI()
                        {
                            Enabled = true
                        },
                        PlayerOwner = new PlayerOwner()
                        {
                            Enabled = true
                        },
                        RustIoClans = new RustIOClans()
                        {
                            Enabled = true
                        }
                    },
                    WipeRaiding = new WipeRaiding()
                    {
                        Enabled = false,
                        MinsFromWipe = 60f,
                        CheckInterval = 5f
                    },
                    NoRaidCommand = new NoRaidCommand()
                    {
                        Enabled = true,
                        DefaultMin = 30f,
                        CheckInterval = 2.5f
                    },
                    Ui = new UiSettings()
                    {
                        Enabled = false,
                        RefreshInterval = 1f,
                        PrimaryColor = new Rgba(196, 65, 50, 1),
                        DarkColor = new Rgba(119, 38, 0, 1),
                        TextColor = new Rgba(255, 255, 255, 1),
                        AnchorMin = new Anchor(0.75f, 0.92f),
                        AnchorMax = new Anchor(0.98f, 0.98f)
                    },
                    StopAllRaiding = true
                };
            }
        }

        private class FriendBypass
        {
            public bool Enabled { get; set; }
            public FriendsAPI FriendsApi { get; set; }
            public RustIOClans RustIoClans { get; set; }
            public PlayerOwner PlayerOwner { get; set; }
        }

        private class FriendsAPI
        {
            public bool Enabled { get; set; }
        }

        private class RustIOClans
        {
            public bool Enabled { get; set; }
        }

        private class PlayerOwner
        {
            public bool Enabled { get; set; }
        }

        private class WipeRaiding
        {
            public bool Enabled { get; set; }

            [JsonProperty("Amount of time from wipe people can raid (minutes)")]
            public float MinsFromWipe { get; set; }

            [JsonProperty("Amount of seconds to check if players can raid")]
            public float CheckInterval { get; set; }
        }

        private class NoRaidCommand
        {
            public bool Enabled { get; set; }
            public float DefaultMin { get; set; }
            public float CheckInterval { get; set; }
        }

        private class UiSettings
        {
            public bool Enabled { get; set; }
            public float RefreshInterval { get; set; }
            public Rgba PrimaryColor { get; set; }
            public Rgba DarkColor { get; set; }
            public Anchor AnchorMin { get; set; }
            public Anchor AnchorMax { get; set; }
            public Rgba TextColor { get; set; }
        }

        private class Rgba
        {
            public float R { get; set; }
            public float G { get; set; }
            public float B { get; set; }
            public float A { get; set; }

            public Rgba()
            {
            }

            public Rgba(float r, float g, float b, float a)
            {
                R = r;
                G = g;
                B = b;
                A = a;
            }

            public static string Format(Rgba rgba)
            {
                return $"{rgba.R / 255} {rgba.G / 255} {rgba.B / 255} {rgba.A}";
            }
        }

        private class Anchor
        {
            public float X { get; set; }
            public float Y { get; set; }

            public Anchor()
            {
            }

            public Anchor(float x, float y)
            {
                X = x;
                Y = y;
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating default configuration file...");
            cFile = ConfigFile.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            cFile = Config.ReadObject<ConfigFile>();
        }

        protected override void SaveConfig() => Config.WriteObject(cFile);

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CantDamage"] = "You cannot damage that entity because you are not associated with the building owner",
                ["CanRaid"] = "The raid cooldown has now been lifted, you're now able to raid!",

                ["Cmd_CanRaid"] = "The cooldown has been lifted, you're able to raid whoever you want!",
                ["Cmd_CantRaid"] = "You can't raid just yet, wait another <color=orange>{0}</color>",
                ["Cmd_Permission"] = "You don't have permission to use that command",
                ["Cmd_InvalidArgs"] = "Invalid arguments. Usage: </color=orange>/noraid</color> <color=silver><start/stop> OPTIONAL: <min></color>",
                ["Cmd_CantStart"] = "Cannot start a no raid period, there's already one running.",
                ["Cmd_NoRaid"] = "A no raid period has begun, you can raid in <color=orange>{0}</color>",

                ["Ui_Title"] = "RAID COOLDOWN",

                ["Msg_DayFormat"] = "{0}D {1}H",
                ["Msg_DaysFormat"] = "{0}D {1}H",
                ["Msg_HourFormat"] = "{0}H {1}M",
                ["Msg_HoursFormat"] = "{0}H {1}M",
                ["Msg_MinFormat"] = "{0}M {1}S",
                ["Msg_MinsFormat"] = "{0}M {1}S",
                ["Msg_SecsFormat"] = "{0}S",
            }, this);
        }

        #endregion

        #region Methods

        private string GetFormattedTime(double time)
        {
            TimeSpan timeSpan = TimeSpan.FromSeconds(time);
            if (timeSpan.TotalSeconds < 1) return null;

            if (Math.Floor(timeSpan.TotalDays) >= 1)
                return string.Format(timeSpan.Days > 1 ? Lang("Msg_DaysFormat", null, timeSpan.Days, timeSpan.Hours) : Lang("Msg_DayFormat", null, timeSpan.Days, timeSpan.Hours));
            if (Math.Floor(timeSpan.TotalMinutes) >= 60)
                return string.Format(timeSpan.Hours > 1 ? Lang("Msg_HoursFormat", null, timeSpan.Hours, timeSpan.Minutes) : Lang("Msg_HourFormat", null, timeSpan.Hours, timeSpan.Minutes));
            if (Math.Floor(timeSpan.TotalSeconds) >= 60)
                return string.Format(timeSpan.Minutes > 1 ? Lang("Msg_MinsFormat", null, timeSpan.Minutes, timeSpan.Seconds) : Lang("Msg_MinFormat", null, timeSpan.Minutes, timeSpan.Seconds));
            return Lang("Msg_SecsFormat", null, timeSpan.Seconds);
        }

        private void StartPeriod()
        {
            _cachedRaidTime = DateTime.UtcNow;
            _canRaid = false;
            foreach (var p in BasePlayer.activePlayerList)
            {
                PrintToChat(p, Lang("Cmd_NoRaid", p.UserIDString, GetFormattedTime((_cachedRaidTime.AddMinutes(_startMinutes)
                    - DateTime.UtcNow).TotalSeconds)));
            }
            _startTimer = timer.Every(cFile.NoRaidCommand.CheckInterval, () =>
            {
                if (UI.ShouldDestroy(_cachedRaidTime, _startMinutes))
                {
                    _canRaid = true;
                    PrintToChat(Lang("CanRaid"));
                    _startTimer?.Destroy();
                    _startUiTimer?.Destroy();
                    _startTimer = null;
                    _startUiTimer = null;
                    foreach (var p in BasePlayer.activePlayerList)
                    {
                        if (_uiPlayers.Contains(p.userID))
                            _uiPlayers.Remove(p.userID);
                        CuiHelper.DestroyUi(p, _uiParent);
                    }
                }

            });
            if (cFile.Ui.Enabled)
            {
                UI.ConstructCachedUi();
                _startUiTimer = timer.Every(cFile.Ui.RefreshInterval, () =>
                {
                    if (UI.ShouldDestroy(_cachedRaidTime, _startMinutes))
                        return;

                    var container = UI.ConstructTimer(_cachedRaidTime, _startMinutes);

                    foreach (var p in BasePlayer.activePlayerList)
                    {
                        if (!_uiPlayers.Contains(p.userID))
                        {
                            CuiHelper.AddUi(p, _cachedContainer);
                            _uiPlayers.Add(p.userID);
                        }
                        CuiHelper.DestroyUi(p, _timerParent);
                        CuiHelper.AddUi(p, container);
                    }
                });
            }
        }

        private void StopPeriod()
        {
            if (_startTimer != null)
            {
                _canRaid = true;
                PrintToChat(Lang("CanRaid"));
                _startTimer?.Destroy();
                _startUiTimer?.Destroy();
                _startTimer = null;
                _startUiTimer = null;
                foreach (var p in BasePlayer.activePlayerList)
                {
                    if (_uiPlayers.Contains(p.userID))
                        _uiPlayers.Remove(p.userID);
                    CuiHelper.DestroyUi(p, _uiParent);
                }
            }
        }

        #region UI

        private class UI
        {
            public static CuiElementContainer Container(string name, string bgColor, Anchor Min, Anchor Max,
                string parent = "Overlay", float fadeOut = 0f, float fadeIn = 0f)
            {
                var newElement = new CuiElementContainer()
                {
                    new CuiElement()
                    {
                        Name = name,
                        Parent = parent,
                        FadeOut = fadeOut,
                        Components =
                        {
                            new CuiImageComponent()
                            {
                                Color = bgColor,
                                FadeIn = fadeIn
                            },
                            new CuiRectTransformComponent()
                            {
                                AnchorMin = $"{Min.X} {Min.Y}",
                                AnchorMax = $"{Max.X} {Max.Y}"
                            }
                        }
                    },
                };
                return newElement;
            }

            public static void Text(string name, string parent, ref CuiElementContainer container, TextAnchor anchor,
                string color, int fontSize, string text,
                Anchor Min, Anchor Max, string font = "robotocondensed-regular.ttf", float fadeOut = 0f,
                float fadeIn = 0f)
            {
                container.Add(new CuiElement()
                {
                    Name = name,
                    Parent = parent,
                    FadeOut = fadeOut,
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = text,
                            Align = anchor,
                            FontSize = fontSize,
                            Font = font,
                            FadeIn = fadeIn,
                            Color = color
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = $"{Min.X} {Min.Y}",
                            AnchorMax = $"{Max.X} {Max.Y}"
                        }
                    }
                });
            }

            public static void Element(string name, string parent, ref CuiElementContainer container, Anchor Min, Anchor Max,
                string bgColor, float fadeOut = 0f, float fadeIn = 0f)
            {
                container.Add(new CuiElement()
                {
                    Name = name,
                    Parent = parent,
                    FadeOut = fadeOut,
                    Components =
                    {
                        new CuiImageComponent()
                        {
                            Color = bgColor,
                            Material = "",
                            FadeIn = fadeIn
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = $"{Min.X} {Min.Y}",
                            AnchorMax = $"{Max.X} {Max.Y}"
                        }
                    }
                });
            }

            public static void Image(string name, string parent, ref CuiElementContainer container, Anchor Min, Anchor Max, string img, string color)
            {
                container.Add(new CuiElement
                {
                    Name = name,
                    Parent = parent,
                    Components =
                    {
                        new CuiRawImageComponent()
                        {
                            Url = img,
                            Sprite = "assets/content/textures/generic/fulltransparent.tga",
                            Color = color,
                            Material = "Assets/Icons/IconMaterial.mat"
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = $"{Min.X} {Min.Y}",
                            AnchorMax = $"{Max.X} {Max.Y}"
                        }
                    }
                });
            }

            public static bool ShouldDestroy(DateTime time, float minutes)
            {
                if (time.AddMinutes(minutes) <= DateTime.UtcNow ||
                _instance.GetFormattedTime((time.AddMinutes(minutes) -
                DateTime.UtcNow).TotalSeconds) == null)
                {
                    return true;
                }
                return false;
            }

            public static void ConstructCachedUi()
            {
                _instance._cachedContainer = Container(_uiParent, "0 0 0 0.1", cFile.Ui.AnchorMin, cFile.Ui.AnchorMax);

                Element("Title_Element", _uiParent, ref _instance._cachedContainer, new Anchor(0.2f, 0f), new Anchor(0.75f, 1f), Rgba.Format(cFile.Ui.PrimaryColor));

                Element("Title_Padded", "Title_Element", ref _instance._cachedContainer, new Anchor(0.05f, 0.05f), new Anchor(0.95f, 0.95f), "0 0 0 0");

                Text("Title_Text", "Title_Padded", ref _instance._cachedContainer, TextAnchor.MiddleLeft, Rgba.Format(cFile.Ui.TextColor), 15, _instance.Lang("Ui_Title"), new Anchor(0f, 0f),
                    new Anchor(1f, 1f), "robotocondensed-bold.ttf");

                Element("Icon_Element", _uiParent, ref _instance._cachedContainer, new Anchor(0f, 0f), new Anchor(0.2f, 1f), Rgba.Format(cFile.Ui.PrimaryColor));

                Element("Icon_Padded", "Icon_Element", ref _instance._cachedContainer, new Anchor(0.2f, 0.15f), new Anchor(0.8f, 0.85f), "0 0 0 0");

                Image("Icon_Image", "Icon_Padded", ref _instance._cachedContainer, new Anchor(0f, 0f), new Anchor(1f, 1f), "http://i.imgur.com/jDo2bgn.png", Rgba.Format(cFile.Ui.DarkColor));
            }

            public static CuiElementContainer ConstructTimer(DateTime time, float minutes)
            {
                var container = Container(_timerParent, Rgba.Format(cFile.Ui.DarkColor), new Anchor(0.75f, 0f), new Anchor(1, 1f), _uiParent);

                Text("Timer_Time", _timerParent, ref container, TextAnchor.MiddleCenter, Rgba.Format(cFile.Ui.TextColor), 15,
                    _instance.GetFormattedTime((time.AddMinutes(minutes) - DateTime.UtcNow).TotalSeconds),
                    new Anchor(0.05f, 0.05f), new Anchor(0.95f, 0.95f));

                return container;
            }
        }

        #endregion

        #endregion

        #region Hooks

        private void Init()
        {
            _instance = this;
            permission.RegisterPermission(_perm, this);
            SaveConfig();
            if (cFile.NoRaidCommand.Enabled && cFile.WipeRaiding.Enabled)
            {
                PrintWarning("It is not recomended to have NoRaidCommand and WipeRaiding enabled at the same time. They could conflict!");
                cFile.NoRaidCommand.Enabled = false;
            }
        }

        private void OnServerInitialized()
        {
            if (!Clans && cFile.FriendBypass.RustIoClans.Enabled)
            {
                cFile.FriendBypass.RustIoClans.Enabled = false;
                PrintWarning("RustIO Clans not detected, disabling RustIO Clans integration");
            }
            if (!Friends && cFile.FriendBypass.FriendsApi.Enabled)
            {
                cFile.FriendBypass.FriendsApi.Enabled = false;
                PrintWarning("FriendsAPI not detected, disabling FriendsAPI integration");
            }

            _cachedWipeTime = SaveRestore.SaveCreatedTime;
            _canRaid = true;

            if (cFile.WipeRaiding.Enabled && _cachedWipeTime.AddMinutes(cFile.WipeRaiding.MinsFromWipe) > DateTime.UtcNow)
            {
                _wipeCheckTimer = timer.Every(cFile.WipeRaiding.CheckInterval, () =>
                {
                    if (UI.ShouldDestroy(_cachedWipeTime, cFile.WipeRaiding.MinsFromWipe))
                    {
                        _canWipeRaid = true;
                        PrintToChat(Lang("CanRaid"));
                        _wipeCheckTimer?.Destroy();
                        _uiTimer?.Destroy();
                        foreach (var player in BasePlayer.activePlayerList)
                            CuiHelper.DestroyUi(player, _uiParent);
                    }
                });
                if (cFile.Ui.Enabled)
                {
                    UI.ConstructCachedUi();

                    _uiTimer = timer.Every(cFile.Ui.RefreshInterval, () =>
                    {
                        if (UI.ShouldDestroy(_cachedWipeTime, cFile.WipeRaiding.MinsFromWipe))
                            return;

                        var container = UI.ConstructTimer(_cachedWipeTime, cFile.WipeRaiding.MinsFromWipe);

                        foreach (var player in BasePlayer.activePlayerList)
                        {
                            if (!_uiPlayers.Contains(player.userID))
                            {
                                CuiHelper.AddUi(player, _cachedContainer);
                                _uiPlayers.Add(player.userID);
                            }
                            CuiHelper.DestroyUi(player, _timerParent);
                            CuiHelper.AddUi(player, container);
                        }
                    });
                }
            }
            else
            {
                _canWipeRaid = true;
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, _uiParent);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (cFile.WipeRaiding.Enabled && _cachedWipeTime.AddMinutes(cFile.WipeRaiding.MinsFromWipe) > DateTime.UtcNow && cFile.Ui.Enabled)
            {
                timer.Once(3f, () =>
                {
                    if (!_uiPlayers.Contains(player.userID))
                    {
                        CuiHelper.AddUi(player, _cachedContainer);
                        _uiPlayers.Add(player.userID);
                    }
                });
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (_uiPlayers.Contains(player.userID))
                _uiPlayers.Remove(player.userID);
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BuildingBlock || entity.name.Contains("deploy") || entity.name.Contains("building"))
            {
                var player = info?.Initiator?.ToPlayer();

                if (!player || player.IsNpc || !entity.OwnerID.IsSteamId())
                {
                    return null;
                }

                if (cFile.FriendBypass.Enabled)
                {
                    // Owner checks
                    if (cFile.FriendBypass.PlayerOwner.Enabled && player.userID == entity.OwnerID)
                    {
                        return null;
                    }
                    // Friend checks

                    if (Friends)
                    {
                        var hasFriend = Friends?.Call("HasFriend", entity.OwnerID.ToString(), player.UserIDString) ?? false;
                        if (cFile.FriendBypass.FriendsApi.Enabled && (bool)hasFriend)
                        {
                            return null;
                        }
                    }

                    if (Clans)
                    {
                        // Clan checks
                        var targetClan = (string)Clans?.Call("GetClanOf", entity.OwnerID.ToString());
                        var playerClan = (string)Clans?.Call("GetClanOf", player.UserIDString);
                        if (cFile.FriendBypass.RustIoClans.Enabled && playerClan != null && targetClan != null && targetClan == playerClan)
                        {
                            return null;
                        }
                    }
                }

                // Prevents player from damaging after friendbypass checks
                if (cFile.StopAllRaiding)
                {
                    PrintToChat(player, Lang("CantDamage", player.UserIDString));
                    return true;
                }

                // No raid command checks
                if (!_canRaid)
                {
                    PrintToChat(player, Lang("Cmd_CantRaid", player.UserIDString, GetFormattedTime((_cachedRaidTime.AddMinutes(_startMinutes)
                        - DateTime.UtcNow).TotalSeconds)));
                    return true;
                }

                // Wipe raid checks
                if (cFile.WipeRaiding.Enabled && !_canWipeRaid)
                {
                    PrintToChat(player, Lang("Cmd_CantRaid", player.UserIDString, GetFormattedTime((_cachedWipeTime.AddMinutes(cFile.WipeRaiding.MinsFromWipe)
                        - DateTime.UtcNow).TotalSeconds)));
                    return true;
                }
                if (cFile.WipeRaiding.Enabled)
                {
                    return null;
                }
            }
            return null;
        }

        [ChatCommand("canraid")]
        private void RaidCmd(BasePlayer player, string command, string[] args)
        {
            if (cFile.WipeRaiding.Enabled && !_canWipeRaid)
            {
                PrintToChat(player, Lang("Cmd_CantRaid", player.UserIDString, GetFormattedTime((_cachedWipeTime.AddMinutes(cFile.WipeRaiding.MinsFromWipe)
                    - DateTime.UtcNow).TotalSeconds)));
                return;
            }
            PrintToChat(player, Lang("Cmd_CanRaid", player.UserIDString));
        }

        [ChatCommand("noraid")]
        private void NoRaidCmd(BasePlayer player, string command, string[] args)
        {
            if (!cFile.NoRaidCommand.Enabled)
                return;

            if (!permission.UserHasPermission(player.UserIDString, _perm))
            {
                PrintToChat(player, Lang("Cmd_Permission", player.UserIDString));
                return;
            }
            if (args.Length == 0)
            {
                PrintToChat(player, Lang("Cmd_InvalidArgs", player.UserIDString));
                return;
            }
            switch (args[0].ToLower())
            {
                case "start":
                    {
                        if (_startTimer != null)
                        {
                            PrintToChat(player, Lang("Cmd_CantStart", player.UserIDString));
                            return;
                        }
                        float outNum;
                        _startMinutes = args.Length == 2 && float.TryParse(args[1], out outNum) ? outNum : cFile.NoRaidCommand.DefaultMin;
                        StartPeriod();
                        return;
                    }
                case "stop":
                    {
                        StopPeriod();
                        return;
                    }
            }
        }

        [ConsoleCommand("noraid.start")]
        private void ConsoleStartCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && !permission.UserHasPermission(arg.Connection.userid.ToString(), _perm))
            {
                arg.ReplyWith(Lang("Cmd_Permission", arg.Connection.userid.ToString()));
                return;
            }
            if (_startTimer != null)
            {
                arg.ReplyWith(Lang("Cmd_CantStart"));
                return;
            }
            float outNum;
            _startMinutes = arg.Args.Length >= 1 && float.TryParse(arg.Args[0], out outNum) ? outNum : cFile.NoRaidCommand.DefaultMin;
            arg.ReplyWith($"Started NoRaid period that lasts for {_startMinutes} minutes");
            StartPeriod();
        }

        [ConsoleCommand("noraid.stop")]
        private void ConsoleStopCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && !permission.UserHasPermission(arg.Connection.userid.ToString(), _perm))
            {
                arg.ReplyWith(Lang("Cmd_Permission", arg.Connection.userid.ToString()));
                return;
            }
            StopPeriod();
            arg.ReplyWith("NoRaid period stopped");
        }

        #endregion
    }
}

// --- End of file: NoRaid.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-medical-healing ---
// --- Original File Path: N/NoMedicalHealing/NoMedicalHealing.cs ---

namespace Oxide.Plugins
{
    [Info("No Medical Healing", "BuzZ", "0.0.1")]
    [Description("Null medical healing")]

/*======================================================================================================================= 
*
*   
*   08th february 2019
*
*   0.0.1   20190129    creation

*
*	THANKS TO THE OXIDE/UMOD TEAM for coding quality, ideas, and time spent for the community
*
*=======================================================================================================================*/

    public class NoMedicalHealing : RustPlugin
    {

        bool debug = false;
        const string CanNotUseMedical = "nomedicalhealing.apply";

        void Init()
        {
            permission.RegisterPermission(CanNotUseMedical, this);
        }

//////////////////////////////////

        object OnHealingItemUse(MedicalTool tool, BasePlayer player)
        {
            bool noheal = permission.UserHasPermission(player.UserIDString, CanNotUseMedical);
            if (noheal)
            {
                if (debug) Puts($"OnHealingItemUse nulled for - {player.displayName}");
                return true;
            }
            else return null;
        }

    }
}

// --- End of file: NoMedicalHealing.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/noob-queue-bypass ---
// --- Original File Path: N/NoobQueueBypass/NoobQueueBypass.cs ---

﻿using System;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Noob Queue Bypass", "Ryan", "1.0.01")]
    [Description("Allows new players to skip the queue")]
    class NoobQueueBypass : RustPlugin
    {
        private string perm = "noobqueuebypass.redeemed";

        #region Hooks

        void Init() => permission.RegisterPermission(perm, this);

        object CanBypassQueue(Network.Connection connection)
        {
            var ID = connection.userid.ToString();
            if (connection.userid.IsSteamId() && !permission.UserHasPermission(ID, perm))
            {
                Puts($"{connection.username} ({connection.userid}) is skipping the queue because he/she is a new player");
                LogToFile("connects", $"[{DateTime.Now}] {connection.username} ({connection.userid}) is skipping the queue because he/she is a new player", this, false);
                return true;
            }
            return null;
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, perm))
                permission.GrantUserPermission(player.UserIDString, perm, this);
        }

        #endregion
    }
}


// --- End of file: NoobQueueBypass.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/name-manager ---
// --- Original File Path: N/NameManager/NameManager.cs ---

﻿using Oxide.Core;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("NameManager", "Ankawi", "1.0.1")]
    [Description("Manage names on your server")]
    class NameManager : CovalencePlugin
    {

        #region Config
        new void LoadConfig()
        {
            SetConfig("Characters Required", 2);
            SetConfig("Enable Restricted Characters", false);
            SetConfig("Enable Restricted Names", false);
            SetConfig("Enable Character Requirement", false);
            SetConfig("Restricted Characters", new List<object> { '$', '!', '+' });
            SetConfig("Restricted Names", new List<object> { "Oxide", "Admin", "Owner", "Moderator" });

            SaveConfig();
        }
        protected override void LoadDefaultConfig() => PrintWarning("Creating a new configuration file...");
        #endregion

        #region Hooks
        void Loaded()
        {
            permission.RegisterPermission("namemanager.admin", this);
            LoadDefaultMessages();
            LoadConfig();
        }

        object CanUserLogin(string name, string id, string ip)
        {
            //PrintWarning($"{name} ({id}) tries to connect from {ip} ({name.Length} of minimal {Config["Characters Required"]})");
            List<object> RestrictedNames = (List<object>)Config["Restricted Names"];
            List<object> RestrictedCharacters = (List<object>)Config["Restricted Characters"];

            if (permission.UserHasPermission(id, "namemanager.admin")) return null;

            if ((bool)Config["Enable Character Requirement"])
            {
                if (name.Length < (int)(Config["Characters Required"]))
                {
                    return (GetMsg("Not Enough Characters", id));
                }
            }
            if ((bool)Config["Enable Restricted Names"])
            {
                if (RestrictedNames.Contains(name))
                {
                    return (GetMsg("Restricted Name", id));
                }
            }
            if ((bool)Config["Enable Restricted Characters"])
            {
                foreach(var bannedChar in RestrictedCharacters)
                {
                    if (name.Contains(bannedChar.ToString()))
                    {
                        return (GetMsg("Restricted Character", id));
                    }
                }
            }
            return null;
        }
        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Restricted Name", "You were kicked for using a restricted name"},
                {"Restricted Character", "You were kicked for using a restricted character"},
                {"Not Enough Characters", "You were kicked because your name was not long enough"}

            }, this);
        }
        #endregion

        #region Helpers

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        string GetMsg(string key, object id = null) => lang.GetMessage(key, this, id == null ? null : id.ToString());
        #endregion
    }
}

// --- End of file: NameManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-recoil ---
// --- Original File Path: N/NoRecoil/NoRecoil.cs ---

﻿using System;
using System.Collections.Generic;
using ProtoBuf;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("NoRecoil", "Kappasaurus", "1.0.6")]
    class NoRecoil : RustPlugin
    {
        #region Variables

        private bool banEnabled;
        private bool kickEnabled = true;
        private float recoilTimer = 0.6f;


        private readonly Dictionary<ulong, NoRecoilData> data = new Dictionary<ulong, NoRecoilData>();
        private readonly Dictionary<ulong, Timer> detections = new Dictionary<ulong, Timer>();
        private readonly int detectionDiscardSeconds = 300;
        private readonly int violationProbability = 30;
        private readonly int maximumViolations = 30;
        private readonly Dictionary<string, int> probabilityModifiers = new Dictionary<string, int>() {
            {"weapon.mod.muzzleboost", -5},
            {"weapon.mod.silencer", 5},
            {"weapon.mod.holosight", 5},
            {"crouching", 8},
            {"aiming", 5}

        };

        private readonly List<string> blacklistedAttachments = new List<string>()
        {
            "weapon.mod.muzzlebreak",
            "weapon.mod.lasersight",
            "weapon.mod.small.scope"
        };

        #endregion

        #region NoRecoilData Class

        public class NoRecoilData
        {
            public int Ticks = 0;
            public int Count;
            public int Violations;
        }

        #endregion

        #region Init

        void Init() => LoadConfig();

        #endregion

        #region Hooks

        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProjectileShoot projectileShoot)
        {

            var item = player.GetActiveItem();
            if (!(item.info.shortname == "rifle.ak" || item.info.shortname == "lmg.m249"))
                return;

            if (item.contents.itemList.Any(x => blacklistedAttachments.Contains(x.info.shortname)))
                return;

            NoRecoilData info;
            if (!data.TryGetValue(player.userID, out info))
                data.Add(player.userID, info = new NoRecoilData());

            UnityEngine.Vector3 eyesDirection = player.eyes.HeadForward();

            if (eyesDirection.y < -0.80)
                return;

            info.Ticks++;

            int probModifier = 0;
            foreach (Item attachment in item.contents.itemList)
                if (probabilityModifiers.ContainsKey(attachment.info.shortname))
                    probModifier += probabilityModifiers[attachment.info.shortname];

            if (player.modelState.aiming && probabilityModifiers.ContainsKey("aiming"))
                probModifier += probabilityModifiers["aiming"];

            if (player.IsDucked() && probabilityModifiers.ContainsKey("crouching"))
                probModifier += probabilityModifiers["crouching"];

            Timer detectionTimer;
            if (detections.TryGetValue(player.userID, out detectionTimer))
                detectionTimer.Reset(detectionDiscardSeconds);
            else
                detections.Add(player.userID, timer.Once(detectionDiscardSeconds, delegate ()
                {
                    if (info.Violations > 0)
                        info.Violations--;
                }));

            timer.Once(recoilTimer, () =>
            {
                ProcessRecoil(projectile, player, mod, projectileShoot, info, probModifier, eyesDirection);
            });

        }

        #endregion

        #region Config

        private new void LoadConfig()
        {
            GetConfig(ref banEnabled, "Automatic banning enabled");
            GetConfig(ref kickEnabled, "Automatic kicking enabled");
            GetConfig(ref recoilTimer, "Developer option, use with care", "Recoil timer");

            SaveConfig();
        }

        #endregion

        #region Helpers

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file...");

        private void GetConfig<T>(ref T variable, params string[] path)
        {
            if (path.Length == 0)
                return;

            if (Config.Get(path) == null)
            {
                Config.Set(path.Concat(new object[] { variable }).ToArray());
                PrintWarning($"Added field to config: {string.Join("/", path)}");
            }

            variable = (T)Convert.ChangeType(Config.Get(path), typeof(T));
        }

        private void ProcessRecoil(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProjectileShoot projectileShoot, NoRecoilData info, int probModifier, UnityEngine.Vector3 eyesDirection)
        {
            var nextEyesDirection = player.eyes.HeadForward();
            if (Math.Abs(nextEyesDirection.y - eyesDirection.y) < .009 &&
                nextEyesDirection.y < .8) info.Count++;

            if (info.Ticks <= 10) return;

            var prob = 100 * info.Count / info.Ticks;

            if (prob > ((100 - violationProbability) + probModifier))
            {
                info.Violations++;
                PrintWarning($"{player.displayName} ({player.UserIDString}), {prob}% probability, {info.Violations.ToString()} violations.");
                LogToFile("violations", $"[{DateTime.Now.ToString()}] {player.displayName} ({player.UserIDString}), {prob}% probability, {info.Violations.ToString()} violations.", this, false);

                                 if (info.Violations > maximumViolations)
                                    if (banEnabled)
                                        Player.Ban(player, "Recoil Scripts");
                                    else if (kickEnabled)
                                        Player.Kick(player, "Recoil Scripts"); 
            }

            foreach (BasePlayer _player in BasePlayer.activePlayerList)
                if (_player.IsAdmin && prob > ((100 - violationProbability) + probModifier))
                    SendReply(_player, $"<size=12>NoRecoil: {player.displayName} ({player.UserIDString}), {prob}% probability, {info.Violations.ToString()} violations.</size>");

            info.Ticks = 0;
            info.Count = 0;
        }

        #endregion
    }
}

// --- End of file: NoRecoil.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-death-screen ---
// --- Original File Path: N/NoDeathScreen/NoDeathScreen.cs ---

/*
 ########### README ####################################################
                                                                             
  !!! DON'T EDIT THIS FILE !!!

    Discord: paulsimik#0506
                                                                     
 ########### CHANGES ###################################################

 1.0.2
    - Rewrited the plugin
    - Added configuration
    - Added option player has sleeping bag
    - Added option end sleeping after player respawned
    - Added command for toggle auto respawn
    - Added auto respawn after player connected

 #######################################################################
*/

using System.Collections.Generic;
using Oxide.Core;
using System.Linq;
using System;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("No Death Screen", "Paulsimik", "1.0.2")]
    [Description("Disables the death screen by automatically respawning players")]
    public class NoDeathScreen : RustPlugin
    {
        #region [Fields]

        private const string permUse = "nodeathscreen.use";
        private const string permToggle = "nodeathscreen.toggle";
        private const string fileName = "NoDeathScreen";

        private Configuration config;
        private List<string> playerData = new List<string>();

        #endregion

        #region [Oxide Hooks]

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permToggle, this);
            LoadData();

            foreach (var command in config.chatCommands)
            {
                cmd.AddChatCommand(command, this, nameof(chatCmdNoDeathScreen));
            }
        }

        private void Unload() => SaveData();

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }

            ProcessRespawn(player);
        }

        private void OnEntityDeath(BasePlayer player)
        {
            if (player.IsNpc)
                return;

            ProcessRespawn(player);
        }

        #endregion

        #region [Hooks]   

        private void ProcessRespawn(BasePlayer player)
        {
            if (!HasPermRespawn(player.UserIDString))
                return;

            if (playerData.Contains(player.UserIDString))
                return;

            if (config.sleepingBagBypass && HasSleepingBag(player.userID))
                return;

            NextTick(() =>
            {
                if (player == null || !player.IsConnected)
                    return;

                if (player.IsDead())
                    player.Respawn();

                if (config.endSleeping && player.IsSleeping())
                    player.EndSleeping();
            });
        }

        private bool HasSleepingBag(ulong playerID)
        {
            SleepingBag[] bag = SleepingBag.FindForPlayer(playerID, true);
            if (bag.Count() > 0)
                return true;

            return false;
        }

        private bool HasPermRespawn(string playerID)
        {
            return permission.UserHasPermission(playerID, permUse);
        }

        #endregion

        #region [Chat Commands]

        private void chatCmdNoDeathScreen(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permToggle))
            {
                SendReply(player, GetLang("noPerm", player.UserIDString));
                return;
            }

            if (playerData.Contains(player.UserIDString))
            {
                playerData.Remove(player.UserIDString);
                SendReply(player, GetLang("enabled", player.UserIDString));
            }
            else
            {
                playerData.Add(player.UserIDString);
                SendReply(player, GetLang("disabled", player.UserIDString));
            }
        }

        #endregion

        #region [Classes]

        private class Configuration
        {
            [JsonProperty(PropertyName = "No respawn if the player has a sleeping bag or bed")]
            public bool sleepingBagBypass;

            [JsonProperty(PropertyName = "End sleeping after respawned")]
            public bool endSleeping;

            [JsonProperty(PropertyName = "Custom chat commands")]
            public string[] chatCommands;

            public VersionNumber version;
        }

        #endregion

        #region [Data]

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(fileName, playerData);

        private void LoadData()
        {
            try
            {
                playerData = Interface.Oxide.DataFileSystem.ReadObject<List<string>>(fileName);
            }
            catch (Exception e)
            {
                PrintError($"Data was not loaded!");
                PrintError(e.Message);
            }

            SaveData();
        }

        #endregion

        #region [Config]

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                sleepingBagBypass = true,
                endSleeping = true,
                chatCommands = new string[]
                {
                    "nodeathscreen",
                    "nds",
                    "ns",
                    "autorespawn",
                    "atr",
                },
                version = Version
            };
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
            Puts("Generating new configuration file........");
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("######### Configuration file is not valid! #########");
                return;
            }

            SaveConfig();
        }

        #endregion

        #region [Localization]

        private string GetLang(string key, string playerID) => string.Format(lang.GetMessage(key, this, playerID));

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "noPerm", "You don't have permissions" },
                { "enabled", "No Death Screen has been enabled" },
                { "disabled", "No Death Screen has been disabled" }

            }, this);
        }

        #endregion
    }
}

// --- End of file: NoDeathScreen.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-backpacks ---
// --- Original File Path: N/NoBackpacks/NoBackpacks.cs ---

﻿using System;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("No Backpacks", "hoppel", "1.0.4")]
    [Description("Removes backpacks after the configured amount of time")]
    public class NoBackpacks : RustPlugin
    {
        #region Hooks
        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity != null && entity.name.Contains("item_drop_backpack"))
            {
                timer.Once(despawnTimer, () =>
                {
                    if(!entity.IsDestroyed)
                        entity?.Kill();
                });
            }
        }
        #endregion

        #region Config
        private int despawnTimer;

        private new void LoadConfig()
        {
            GetConfig(ref despawnTimer, "Settings", "Despawn timer (seconds)");
            SaveConfig();
        }

        private void Init() => LoadConfig();

        private void GetConfig<T>(ref T variable, params string[] path)
        {
            if (path.Length == 0)
                return;

            if (Config.Get(path) == null)
            {
                Config.Set(path.Concat(new object[] { variable }).ToArray());
            }

            variable = (T)Convert.ChangeType(Config.Get(path), typeof(T));
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file...");
        #endregion
    }
}


// --- End of file: NoBackpacks.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/youve-got-mail ---
// --- Original File Path: Y/YouveGotMail/YouveGotMail.cs ---

using System.Linq;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("You've Got Mail", "KajWithAJ", "1.0.2")]
    [Description("Notifies online players when they receive mail in their mailbox.")]
    class YouveGotMail : RustPlugin
    {
        private const string MailboxPermission = "youvegotmail.message";

        private void Init()
        {
            permission.RegisterPermission(MailboxPermission, this);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ReceivedMail"] = "<color=#FFFFFF>You've received mail from <color=#FFFF00>{0}</color> in your mailbox at <color=#FFFF00>{1}</color>.</color>"
            }, this);
        }

        void OnItemSubmit(Item item, Mailbox mailbox, BasePlayer player)
        {
            if (mailbox.ShortPrefabName == "mailbox.deployed") {
                string coordinates = MapHelper.PositionToString(mailbox.transform.position);
                ulong ownerID = mailbox.OwnerID;
                Puts($"{player.displayName} in mailbox of {ownerID} at {coordinates}");
                

                BasePlayer owner = BasePlayer.FindByID(ownerID);
                if (owner != null) {
                    if (permission.UserHasPermission(owner.UserIDString, MailboxPermission)) {
                        
                        string message = lang.GetMessage("ReceivedMail", this, owner.UserIDString);
                        Player.Message(owner, string.Format(message, player.displayName, coordinates));
                    }
                }
            }
        }
    }
}


// --- End of file: YouveGotMail.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/perma-death ---
// --- Original File Path: P/PermaDeath/PermaDeath.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Perma Death", "Kappasaurus", "1.0.1")]
    [Description("Deletes all of a player's entities after a set amount of deaths")]
    class PermaDeath : RustPlugin
    {
        private int maximumDeaths = 5;
        private bool includeSuicide = true;

        #region Data

        static PermaDeath Instance;

        class StoredData
        {
            public List<PlayerInfo> Players = new List<PlayerInfo>();

            public PlayerInfo GetInfo(BasePlayer player)
            {
                var playerInfo = Players.FirstOrDefault(x => x.SteamID == player.userID);
                if (playerInfo == null)
                {
                    playerInfo = new PlayerInfo(player);
                    Players.Add(playerInfo);
                    Instance.SaveData();
                }

                return playerInfo;
            }
        }

        StoredData storedData;

        class PlayerInfo
        {
            public ulong SteamID;
            public int Deaths;

            public PlayerInfo()
            {
            }

            public PlayerInfo(BasePlayer player)
            {
                SteamID = player.userID;
                Deaths = 0;
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject<StoredData>(this.Title, storedData);
        private void ReadData() => storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(this.Title);

        #endregion

        #region Hooks

        private void Init()
        {
            ReadData();
            Instance = this;

            LoadConfig();
            permission.RegisterPermission("permadeath.admin", this);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (storedData.Players.Any(x => x.SteamID == player.userID)) return;

            var info = new PlayerInfo(player);
            storedData.Players.Add(info);
            SaveData();
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            var playerInfo = storedData.GetInfo(player);

            playerInfo.Deaths++;
            SaveData();

            if (playerInfo.Deaths >= maximumDeaths)
            {
                ConVar.Entity.DeleteBy(player.userID);
                while (playerInfo.Deaths > 0)
                {
                    playerInfo.Deaths--;
                    SaveData();
                }
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            var playerInfo = storedData.GetInfo(player);
            if (playerInfo.Deaths > 0)
                PrintToChat(lang.GetMessage("Warning", this, player.UserIDString), maximumDeaths - playerInfo.Deaths);
        }

        private void OnNewSave() => storedData.Players.Clear();

        #endregion

        #region Command

        [ChatCommand("permadeath")]
        private void PermadeathCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "permadeath.admin"))
            {
                PrintToChat(player, lang.GetMessage("No Permission", this, player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                PrintToChat(player, lang.GetMessage("No Arguments", this, player.UserIDString));
                return;
            }

            switch (args[0].ToLower())
            {
                case "reset":
                    storedData.Players.Clear();
                    PrintToChat(player, lang.GetMessage("Reset Message", this, player.UserIDString));
                    break;
            }
        }

        #endregion

        #region Config

        private new void LoadConfig()
        {
            GetConfig(ref maximumDeaths, "Maximum deaths");
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file...");

        #endregion

        #region Helpers

        private void GetConfig<T>(ref T variable, params string[] path)
        {
            if (path.Length == 0)
                return;

            if (Config.Get(path) == null)
            {
                Config.Set(path.Concat(new object[] { variable }).ToArray());
                PrintWarning($"Added field to config: {string.Join("/", path)}");
            }

            variable = (T)Convert.ChangeType(Config.Get(path), typeof(T));
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "<size=12>Error, no permission.</size>",
                ["No Arguments"] = "<size=12>Error, no arguments.</size>",
                ["Reset Message"] = "<size=12>Reset all death data.</size>",
                ["Warning"] = "<size=12>Warning, you have <i>only</i> {0} lives left until all your entities reset!</size>",
            }, this);
        }

        #endregion
    }
}


// --- End of file: PermaDeath.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pills-here ---
// --- Original File Path: P/PillsHere/PillsHere.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Pills Here", "Wulf", "3.2.1")]
    [Description("Recovers health, hunger, and/or hydration by set amounts on item use")]
    class PillsHere : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Calories amount (0.0 - 500.0)")]
            public float CaloriesAmount = 50f;

            [JsonProperty("Health amount (0.0 - 100.0)")]
            public float HealthAmount = 10f;

            [JsonProperty("Hydration amount (0.0 - 250.0)")]
            public float HydrationAmount = 25f;

            [JsonProperty("Item ID or short name to use")]
            public string ItemIdOrShortName = "antiradpills";

            [JsonProperty("Use permission system")]
            public bool UsePermissions = true;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Initialization

        private const string permUse = "pillshere.use";

        private void Init()
        {
            permission.RegisterPermission(permUse, this);

            // Check if item name or ID used is old or not set
            if (string.IsNullOrEmpty(config.ItemIdOrShortName) || config.ItemIdOrShortName == "1685058759")
            {
                LogWarning("Old or no item configured, using default item: antiradpills");
                config.ItemIdOrShortName = "antiradpills";
                SaveConfig();
            }
        }

        #endregion Initialization

        #region Item Handling

        private void OnItemUse(Item item)
        {
            // Check if item name or ID used matches what is configured
            if (item.info.itemid.ToString() != config.ItemIdOrShortName && item.info.shortname != config.ItemIdOrShortName) // -1432674913 or antiradpills
            {
                return;
            }

            // Check of item was used by a real player
            BasePlayer player = item.GetOwnerPlayer();
            if (player == null)
            {
                return;
            }

            // Check if player has permission to use this
            if (config.UsePermissions && !permission.UserHasPermission(player.UserIDString, permUse))
            {
                return;
            }

            // Heal player and restore calories and hydration
            float targetHydration = player.metabolism.hydration.lastValue + config.HydrationAmount;
            player.metabolism.hydration.value = Mathf.Clamp(targetHydration, player.metabolism.hydration.min, player.metabolism.hydration.max); // Max: 250
            float targetCalories = player.metabolism.calories.lastValue + config.CaloriesAmount;
            player.metabolism.calories.value = Mathf.Clamp(targetCalories, player.metabolism.calories.min, player.metabolism.calories.max); // Max: 500
            player.Heal(config.HealthAmount);
        }

        #endregion Item Handling
    }
}


// --- End of file: PillsHere.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/personal-beacon ---
// --- Original File Path: P/PersonalBeacon/PersonalBeacon.cs ---

using System.Collections.Generic;
using System;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using System.Text;

//
// Credit to the original author, Mordenak / HighTower 2
//

namespace Oxide.Plugins
{
    [Info("PersonalBeacon", "redBDGR", "2.0.4")]
    [Description("Displays a beacon at a marked location for easier navigation")]

    class PersonalBeacon : RustPlugin
    {
        #region Data

        private DynamicConfigFile exampleData;
        WaypointDataStorage storedData;

        void SaveData()
        {
            storedData.playerWaypoints = playerWaypointsCache;
            storedData.globalWaypoints = globalWaypointCache;
            exampleData.WriteObject(storedData);
        }
        void LoadData()
        {
            try
            {
                storedData = exampleData.ReadObject<WaypointDataStorage>();
                LoadPlayerWaypoints();
                LoadGlobalWaypoints();
            }
            catch
            {
                Puts("Failed to load data, creating new file");
                storedData = new WaypointDataStorage();
            }
        }

        void LoadPlayerWaypoints()
        {
            foreach (var entry in storedData.playerWaypoints)
            {
                playerWaypointsCache.Add(entry.Key, new List<WaypointData>());
                foreach (var _entry in entry.Value)
                    playerWaypointsCache[entry.Key].Add(new WaypointData() { name = _entry.name, x = _entry.x, y = _entry.y, z = _entry.z });
            }
        }

        void LoadGlobalWaypoints()
        {
            foreach (var entry in storedData.globalWaypoints)
                globalWaypointCache.Add(new WaypointData() { name = entry.name, x = entry.x, y = entry.y, z = entry.z });
        }

        #endregion

        #region Config

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        void LoadVariables()
        {
            // Arrow settings
            arrowHeight = Convert.ToSingle(GetConfig("Arrow Settings", "Height", 100f));
            arrowLevitation = Convert.ToSingle(GetConfig("Arrow Settings", "Levitation from ground", 3f));
            arrowHeadSize = Convert.ToSingle(GetConfig("Arrow Settings", "Arrow Head Size", 3f));

            // General settings
            playerWaypointDisplaytime = Convert.ToSingle(GetConfig("Settings", "Player Display Time", 60f));
            globalRefreshTime = Convert.ToSingle(GetConfig("Settings", "Global Waypoint Refresh Time", 60f));
            maxWaypoints = Convert.ToInt32(GetConfig("Settings", "Max Waypoints", 5));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        #endregion

        bool Changed = false;
        private const string permissionName = "personalbeacon.use";
        private const string permissionNameADMIN = "personalbeacon.admin";
        Dictionary<string, List<WaypointData>> playerWaypointsCache = new Dictionary<string, List<WaypointData>>();
        List<WaypointData> globalWaypointCache = new List<WaypointData>();
        List<TimerData> timers = new List<TimerData>();
        public float arrowHeight = 50f;
        public float arrowLevitation = 3f;
        public float arrowHeadSize = 3;
        public float playerWaypointDisplaytime = 60;
        public float globalRefreshTime = 60f;
        public int maxWaypoints = 5;

        class WaypointDataStorage
        {
            public Dictionary<string, List<WaypointData>> playerWaypoints;
            public List<WaypointData> globalWaypoints;
        }

        class WaypointData
        {
            public string name;
            public float x;
            public float y;
            public float z;
        }

        class TimerData
        {
            public string name;
            public Timer timer;
            public WaypointData data;
        }

        void Loaded()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                //chat
                ["No Permission"] = "You cannot use this command!",
                ["/setwp Invalid Syntax"] = "Invalid syntax! /setwp <waypoint name>",
                ["/wp Invalid Syntax"] = "Invalid syntax! /wp <waypoint name>",
                ["/setglobalwp Invalid Syntax"] = "Invalid syntax! /setglobalwp <waypoint name>",
                ["/hideglobalwp Invalid Syntax"] = "Invalid syntax! /hideglobalwp <waypoint name>",
                ["/removewp Invalid Syntax"] = "Invalid syntax! /removewp <waypoint name>",
                ["Waypoint Removed"] = "This waypoint has been removed!",
                ["Waypoint Already Exists"] = "This waypoint name already exists!",
                ["Waypoint Added"] = "You successfully created a new waypoint!",
                ["Waypoint Not Found"] = "Waypoint was not found",
                ["Max Waypoints Allowed"] = "You already have the maxiumum amount of waypoints allowed!",
                ["Global Waypoint Hidden"] = "This waypoint will disapear on the next update cycle",
                ["Global Waypoint Already Showing"] = "This waypoint is already being broadcasted",
                ["No Waypoints"] = "You do not have any waypoints!",
                ["List 1st Line"] = "Your current waypoints are:",
                ["List Entry"] = "- {0}",

            }, this);

            exampleData = Interface.Oxide.DataFileSystem.GetFile("PersonalBeacon");

            NextTick(() =>
            {
                foreach (var entry in globalWaypointCache)
                    InitGlobalWaypoint(entry);
            });
        }

        void OnServerInitialized() => LoadData();
        void Unload() => SaveData();
        void OnServerSave() => SaveData();

        void Init()
        {
            permission.RegisterPermission("personalbeacon.use", this);
            permission.RegisterPermission("personalbeacon.admin", this);
            LoadVariables();
        }

        [ChatCommand("setwp")]
        void setwpCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
            {
                player.ChatMessage(msg("No Permission", player.UserIDString));
                return;
            }
            if (args.Length != 1)
            {
                player.ChatMessage(msg("/setwp Invalid Syntax", player.UserIDString));
                return;
            }
            if (!playerWaypointsCache.ContainsKey(player.UserIDString))
                playerWaypointsCache.Add(player.UserIDString, new List<WaypointData>());
            if (playerWaypointsCache[player.UserIDString].Count == maxWaypoints)
            {
                player.ChatMessage(msg("Max Waypoints Allowed", player.UserIDString));
                return;
            }
            foreach (var entry in playerWaypointsCache[player.UserIDString])
                if (args[0] == entry.name)
                {
                    player.ChatMessage(msg("Waypoint Already Exists", player.UserIDString));
                    return;
                }
            WaypointData data = new WaypointData() { name = args[0], x = player.transform.position.x, y = player.transform.position.y, z = player.transform.position.z };
            playerWaypointsCache[player.UserIDString].Add(data);
            DrawWaypoint(player, new Vector3(data.x, data.y, data.z), playerWaypointDisplaytime, false, data.name);
        }

        [ChatCommand("wp")]
        void wpCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
                if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
                {
                    player.ChatMessage(msg("No Permission", player.UserIDString));
                    return;
                }
            if (args.Length != 1)
            {
                player.ChatMessage(msg("/wp Invalid Syntax", player.UserIDString));
                return;
            }
            if (!playerWaypointsCache.ContainsKey(player.UserIDString))
                playerWaypointsCache.Add(player.UserIDString, new List<WaypointData>());
            WaypointData data = null;
            foreach (var entry in playerWaypointsCache[player.UserIDString])
                if (entry.name == args[0])
                    data = entry;
            if (data == null)
            {
                player.ChatMessage(msg("Waypoint Not Found", player.UserIDString));
                return;
            }
            DrawWaypoint(player, new Vector3(data.x, data.y, data.z), playerWaypointDisplaytime, false, data.name);
            player.ChatMessage(msg("Waypoint Added", player.UserIDString));
        }

        [ChatCommand("removewp")]
        void removewp(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
                if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
                {
                    player.ChatMessage(msg("No Permission", player.UserIDString));
                    return;
                }
            if (args.Length != 1)
            {
                player.ChatMessage(msg("/removewp Invalid Syntax", player.UserIDString));
                return;
            }
            if (!playerWaypointsCache.ContainsKey(player.UserIDString))
                playerWaypointsCache.Add(player.UserIDString, new List<WaypointData>());
            foreach (var entry in playerWaypointsCache[player.UserIDString])
                if (args[0] == entry.name)
                {
                    playerWaypointsCache[player.UserIDString].Remove(entry);
                    player.ChatMessage(msg("Waypoint Removed", player.UserIDString));
                    return;
                }
        }

        [ChatCommand("wplist")]
        void wplistCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
                if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
                {
                    player.ChatMessage(msg("No Permission", player.UserIDString));
                    return;
                }
            if (!playerWaypointsCache.ContainsKey(player.UserIDString))
            {
                player.ChatMessage(msg("No Waypoints", player.UserIDString));
                return;
            }
            else
            {
                StringBuilder x = new StringBuilder();
                x.AppendLine(msg("List 1st Line", player.UserIDString));
                foreach (var entry in playerWaypointsCache[player.UserIDString])
                    x.AppendLine(string.Format(msg("List Entry", player.UserIDString), entry.name.ToString()));
                player.ChatMessage(x.ToString().TrimEnd());
            }
        }

        // Admin commands:

        [ChatCommand("setglobalwp")]
        void globalwpCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
            {
                player.ChatMessage(msg("No Permissions", player.UserIDString));
                return;
            }
            if (args.Length != 1)
            {
                player.ChatMessage(msg("/setglobalwp Invalid Syntax", player.UserIDString));
                return;
            }
            foreach(var entry in globalWaypointCache)
                if (entry.name == args[0])
                {
                    player.ChatMessage(msg("Waypoint Already Exists", player.UserIDString));
                    return;
                }
            WaypointData data = new WaypointData() { name = args[0], x = player.transform.position.x, y = player.transform.position.y, z = player.transform.position.z };
            globalWaypointCache.Add(data);
            InitGlobalWaypoint(data);
        }

        [ChatCommand("removeglobalwp")]
        private void RemoveGlobalWPCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
            {
                player.ChatMessage(msg("No Permissions", player.UserIDString));
                return;
            }
            if (args.Length != 1)
            {
                player.ChatMessage(msg("/setglobalwp Invalid Syntax", player.UserIDString));
                return;
            }
            bool x = false;
            WaypointData data = null;
            foreach (var entry in globalWaypointCache)
                if (entry.name == args[0])
                {
                    x = true;
                    data = entry;
                    return;
                }
            if (x == true && data != null)
            {
                TimerData tData = null;
                foreach (var _entry in timers)
                    if (args[0] == _entry.name)
                        tData = _entry;
                if (tData != null)
                {
                    tData.timer.Destroy();
                    tData.timer = null;
                    timers.Remove(tData);
                }
                globalWaypointCache.Remove(data);
                player.ChatMessage("Waypoint was removed");
            }
            else
            {
                player.ChatMessage("That waypoint does not exist");
            }
        }

        [ChatCommand("hideglobalwp")]
        void hideglobalwpCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
            {
                player.ChatMessage(msg("No Permission", player.UserIDString));
                return;
            }
            if (args.Length != 1)
            {
                player.ChatMessage(msg("/hideglobalwp Invalid Syntax", player.UserIDString));
                return;
            }
            TimerData data = null;
            foreach (var entry in timers)
                if (args[0] == entry.name)
                    data = entry;
            if (data == null)
            {
                player.ChatMessage(msg("Waypoint Not Found", player.UserIDString));
                return;
            }
            data.timer.Destroy();
            data.timer = null;
            player.ChatMessage(msg("Global Waypoint Hidden", player.UserIDString));
        }

        [ChatCommand("showglobalwp")]
        void showglobalwpCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
            {
                player.ChatMessage(msg("No Permission", player.UserIDString));
                return;
            }
            if (args.Length != 1)
            {
                player.ChatMessage(msg("/hideglobalwp Invalid Syntax", player.UserIDString));
                return;
            }
            TimerData data = null;
            foreach (var entry in timers)
                if (entry.name == args[0])
                    data = entry;
            if (data == null)
            {
                player.ChatMessage(msg("Waypoint Not Found", player.UserIDString));
                return;
            }
            if (data.timer != null)
            {
                player.ChatMessage(msg("Global Waypoint Already Showing", player.UserIDString));
                return;
            }
            foreach (BasePlayer _player in BasePlayer.activePlayerList)
                DrawWaypoint(_player, new Vector3(data.data.x, data.data.y, data.data.z), globalRefreshTime, true, data.name);
            data.timer = timer.Repeat(globalRefreshTime, 0, () =>
            {
                foreach (BasePlayer _player in BasePlayer.activePlayerList)
                    DrawWaypoint(_player, new Vector3(data.data.x, data.data.y, data.data.z), globalRefreshTime, true, data.name);
            });
        }

        [ChatCommand("wpshowall")]
        void cmdShowAllBeacons(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
            {
                player.ChatMessage(msg("No Permission", player.UserIDString));
                return;
            }

            foreach (var entry in playerWaypointsCache)
                foreach (var _entry in playerWaypointsCache[entry.Key])
                    DrawWaypoint(player, new Vector3(_entry.x, _entry.y, _entry.z), playerWaypointDisplaytime, false, _entry.name);
        }

        void InitGlobalWaypoint(WaypointData data)
        {
            foreach (BasePlayer _player in BasePlayer.activePlayerList)
                DrawWaypoint(_player, new Vector3(data.x, data.y, data.z), globalRefreshTime, true, data.name);

            Timer repeat = timer.Repeat(globalRefreshTime, 0, () =>
            {
                foreach (BasePlayer _player in BasePlayer.activePlayerList)
                    DrawWaypoint(_player, new Vector3(data.x, data.y, data.z), globalRefreshTime, true, data.name);
            });
            timers.Add(new TimerData() { timer = repeat, name = data.name, data = data });
        }

        void DrawWaypoint(BasePlayer player, Vector3 pos, float time, bool isGlobal, string name)
        {
            var color = Color.blue;
            if (isGlobal)
                color = Color.red;

            if (!player.HasPlayerFlag(BasePlayer.PlayerFlags.IsAdmin))
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                player.SendNetworkUpdateImmediate();
                player.SendConsoleCommand("ddraw.arrow", time, color, new Vector3(pos.x, pos.y + arrowHeight + arrowLevitation, pos.z), new Vector3(pos.x, pos.y + arrowLevitation, pos.z), arrowHeadSize);
                player.SendConsoleCommand("ddraw.text", time, color, new Vector3(pos.x, pos.y + arrowHeight + arrowLevitation + 5f, pos.z), name);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                player.SendNetworkUpdate();
            }
            else
            {
                player.SendConsoleCommand("ddraw.arrow", time, color, new Vector3(pos.x, pos.y + arrowHeight + arrowLevitation, pos.z), new Vector3(pos.x, pos.y + arrowLevitation, pos.z), arrowHeadSize);
                player.SendConsoleCommand("ddraw.text", time, color, new Vector3(pos.x, pos.y + arrowHeight + arrowLevitation + 5f, pos.z), name);
            }
                    return;
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        string msg(string key, string id = null) => lang.GetMessage(key, this, id);
    }
}

// --- End of file: PersonalBeacon.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-blinder ---
// --- Original File Path: P/PlayerBlinder/PlayerBlinder.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.Globalization;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Player Blinder", "redBDGR", "1.0.5")]
    [Description("Gives an extra way of punishing players")]
    class PlayerBlinder : CovalencePlugin
    {
        public bool Changed = false;

        public const string permissionName = "playerblinder.admin";

        public bool useImage = false;
        public string ImageURL = "";
        public string ImageAMIN = "0 0";
        public string ImageAMAX = "1 1";

        public bool useText = true;
        public string TextTEXT = "You have been blinded by an admin!";
        public int TextSize = 20;

        public string BlindColour = "0 0 0 1";

        //public bool noTalk = true;

        Dictionary<string, bool> GUIinfo = new Dictionary<string, bool>();
        Dictionary<string, int> adminProtection = new Dictionary<string, int>();

        void Init()
        {
            permission.RegisterPermission(permissionName, this);
            LoadVariables();
        }

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["player already blinded"] = "This player is already blinded! use unblind <playername / id>",
                ["player blinded"] = "{0} was blinded!",
                ["player unblinded"] = "{0} was unblinded!",
                ["no permissions"] = "You are not allowed to use this command!",
                ["player not found"] = "The player was not found / is offline",
                ["unblind invalid syntax"] = "Invalid syntax! unblind <playername / id>",
                ["blind invalid syntax"] = "Invalid syntax! blind <playername / id> <length> <\"message\">",
                ["target offline"] = "The target you selected is currently offline!",
                ["More than one result"] = "There was more than one result! please give a clearer search term",
                ["Blindprotect Invalid Syntax"] = "Invalid syntax! /blindprotect <length of punishment>",
                ["protection disabled"] = "Your blind protection was disabled!",
                ["protection enabled"] = "Your blind protection was enabled!"
            }, this);
        }

        void LoadVariables()
        {
            ImageURL = Convert.ToString(GetConfig("Image UI", "URL", ""));
            useImage = Convert.ToBoolean(GetConfig("Settings", "ImageOverlay Enabled", false));
            useText = Convert.ToBoolean(GetConfig("Settings", "Use Text", true));
            TextTEXT = Convert.ToString(GetConfig("Text UI", "Default Text", "You have been blinded by an admin!"));
            BlindColour = Convert.ToString(GetConfig("Blind UI", "Colour", "0 0 0 1"));
            ImageAMIN = Convert.ToString(GetConfig("Image UI", "AnchorMIN", "0 0"));
            ImageAMAX = Convert.ToString(GetConfig("Image UI", "AnchorMAX", "1 1"));
            TextSize = Convert.ToInt32(GetConfig("Text UI", "Size", 20));
            //noTalk = Convert.ToBoolean(GetConfig("Settings", "No Talk While Blinded", true));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                if (GUIinfo.ContainsKey(player.UserIDString))
                    if (GUIinfo[player.UserIDString])
                        GUIDestroy(player);
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (!(entity is BasePlayer)) return;
            if (!adminProtection.ContainsKey(entity.ToPlayer().UserIDString)) return;
            if (!(info.Initiator is BasePlayer)) return;
            BasePlayer targetplayer = info.InitiatorPlayer;
            if (targetplayer.IsConnected)
            {
                if (GUIinfo.ContainsKey(targetplayer.UserIDString)) return;
                DoGUI(targetplayer, adminProtection[entity.ToPlayer().UserIDString], false, null);
            }
            return;
        }

        [Command("blind")]
        void BlindCMD(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permissionName))
            {
                player.Reply(msg("no permissions", player.Id));
                return;
            }

            if (args.Length == 1)
            {
                List<BasePlayer> PlayerList = FindPlayer(args[0]);
                if (PlayerList.Count > 1)
                {
                    player.Reply(msg("More than one result", player.Id));
                    return;
                }
                BasePlayer targetplayer = PlayerList[0];
                if (targetplayer == null)
                {
                    player.Reply(msg("player not found", player.Id));
                    return;
                }

                if (!targetplayer.IsConnected)
                {
                    player.Reply(msg("target offline", player.Id));
                    return;
                }

                if (GUIinfo.ContainsKey(targetplayer.UserIDString))
                {
                    if (GUIinfo[targetplayer.UserIDString])
                    {
                        player.Reply(msg("player already blinded", player.Id));
                        return;
                    }
                    DoGUI(targetplayer, 0.0f, true, null);
                    return;
                }
                else
                {
                    DoGUI(targetplayer, 0.0f, false, null);
                    player.Message(string.Format(msg("player blinded", player.Id), targetplayer.displayName));
                    return;
                }
            }
            else if (args.Length == 2)
            {
                List<BasePlayer> PlayerList = FindPlayer(args[0]);
                if (PlayerList.Count > 1)
                {
                    player.Reply(msg("More than one result", player.Id));
                    return;
                }
                BasePlayer targetplayer = PlayerList[0];
                if (targetplayer != null)
                {
                    player.Reply(msg("player not found", player.Id));
                    return;
                }

                if (!targetplayer.IsConnected)
                {
                    player.Reply(msg("target offline", player.Id));
                    return;
                }

                int lengthINT = Convert.ToInt32(args[1]);
                if (GUIinfo.ContainsKey(targetplayer.UserIDString))
                {
                    if (GUIinfo[targetplayer.UserIDString])
                    {
                        player.Reply(msg("player already blinded", player.Id));
                        return;
                    }
                    DoGUI(targetplayer, Convert.ToSingle(lengthINT), true, null);
                    return;
                }
                else
                {
                    DoGUI(targetplayer, Convert.ToSingle(lengthINT), false, null);
                    player.Reply(string.Format(msg("player blinded", player.Id), targetplayer.displayName));
                    return;
                }
            }
            else if (args.Length == 3)
            {
                List<BasePlayer> PlayerList = FindPlayer(args[0]);
                if (PlayerList.Count > 1)
                {
                    player.Reply(msg("More than one result", player.Id));
                    return;
                }
                BasePlayer targetplayer = PlayerList[0];
                if (targetplayer == null)
                {
                    player.Reply(msg("player not found", player.Id));
                    return;
                }

                if (!targetplayer.IsConnected)
                {
                    player.Reply(msg("target offline", player.Id));
                    return;
                }

                int lengthINT = Convert.ToInt32(args[1]);
                string message = Convert.ToString(args[2]);

                if (GUIinfo.ContainsKey(targetplayer.UserIDString))
                {
                    if (GUIinfo[targetplayer.UserIDString])
                    {
                        player.Reply(msg("player already blinded", player.Id));
                        return;
                    }
                    DoGUI(targetplayer, Convert.ToSingle(lengthINT), true, message);
                    return;
                }
                else
                {
                    DoGUI(targetplayer, Convert.ToSingle(lengthINT), false, message);
                    player.Reply(string.Format(msg("player blinded", player.Id), targetplayer.displayName));
                    return;
                }
            }
            else
                player.Reply(msg("blind invalid syntax", player.Id));
        }

        [Command("unblind")]
        void UnblindCMD(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permissionName))
            {
                player.Reply(msg("no permissions", player.Id));
                return;
            }

            if (args.Length == 1)
            {
                List<BasePlayer> PlayerList = FindPlayer(args[0]);
                if (PlayerList.Count > 1)
                {
                    player.Reply(msg("More than one result", player.Id));
                    return;
                }
                BasePlayer targetplayer = PlayerList[0];
                if (targetplayer == null)
                {
                    player.Reply(msg("player not found", player.Id));
                    return;
                }

                if (!targetplayer.IsConnected)
                {
                    player.Reply(msg("player not found", player.Id));
                    return;
                }

                if (GUIinfo.ContainsKey(targetplayer.UserIDString))
                {
                    if (!GUIinfo[targetplayer.UserIDString])
                    {
                        player.Reply(msg("player already blinded", player.Id));
                        return;
                    }
                    else
                    {
                        GUIDestroy(targetplayer);
                        player.Reply(string.Format(msg("player unblinded", player.Id), targetplayer.displayName));
                        return;
                    }
                }
                return;
            }
            else
                player.Reply(msg("unblind invalid syntax", player.Id));
        }

        [ChatCommand("blindprotect")]
        void BlindProtect(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
            {
                player.ChatMessage(msg("no permissions", player.UserIDString));
                return;
            }

            if (args.Length == 1)
            {
                if (adminProtection.ContainsKey(player.UserIDString))
                {
                    adminProtection.Remove(player.UserIDString);
                    player.ChatMessage(msg("protection disabled", player.UserIDString));
                    return;
                }
                else
                {
                    adminProtection.Add(player.UserIDString, Convert.ToInt32(args[0]));
                    player.ChatMessage(msg("protection enabled", player.UserIDString));
                    return;
                }
            }
            else
            {
                player.ChatMessage(msg("Blindprotect Invalid Syntax", player.UserIDString));
                return;
            }
        }

        void GUIDestroy(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Panel);
            GUIinfo[player.UserIDString] = false;
        }

        void DoGUI(BasePlayer targetplayer, float length, bool indic, string message)
        {
            if (indic == true)
            {
                var element = UI.CreateElementContainer(Panel, BlindColour, "0 0", "1 1", false);
                if (useImage)
                    UI.CreateImage(ref element, Panel, ImageURL, ImageAMIN, ImageAMAX);

                if (useText)
                {
                    if (message == null)
                        UI.CreateTextOutline(ref element, Panel, TextTEXT, "1 1 1 1", "0 0 0 0", "1", "1", TextSize, "0 0", "1 1", TextAnchor.MiddleCenter);
                    else
                        UI.CreateTextOutline(ref element, Panel, message, "1 1 1 1", "0 0 0 0", "1", "1", TextSize, "0 0", "1 1", TextAnchor.MiddleCenter);
                }

                CuiHelper.AddUi(targetplayer, element);
                GUIinfo[targetplayer.UserIDString] = true;

                if (length > 0.0f)
                    timer.Once(length, () => { GUIDestroy(targetplayer); });
            }
            else if (indic == false)
            {
                GUIinfo.Add(targetplayer.UserIDString, false);

                var element = UI.CreateElementContainer(Panel, BlindColour, "0 0", "1 1", false);
                if (useImage)
                    UI.CreateImage(ref element, Panel, ImageURL, ImageAMIN, ImageAMAX);

                if (useText)
                    UI.CreateTextOutline(ref element, Panel, TextTEXT, "1 1 1 1", "0 0 0 0", "1", "1", TextSize, "0 0", "1 1", TextAnchor.MiddleCenter);

                CuiHelper.AddUi(targetplayer, element);
                GUIinfo[targetplayer.UserIDString] = true;

                if (length > 0.0f)
                    timer.Once(length, () => { GUIDestroy(targetplayer); });
            }
        }

        private static List<BasePlayer> FindPlayer(string nameOrId)
        {
            List<BasePlayer> x = new List<BasePlayer>();

            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == nameOrId)
                    x.Add(activePlayer);
                if (activePlayer.displayName.Contains(nameOrId, CompareOptions.OrdinalIgnoreCase))
                    if (!x.Contains(activePlayer))
                        x.Add(activePlayer);
                if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress == nameOrId)
                    if (!x.Contains(activePlayer))
                        x.Add(activePlayer);
            }
            return x;
        }

        #region UI

        private string Panel = "BlindPanel";

        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor,
                    },
                    new CuiElement().Parent,
                    panel
                }
            };
                return NewElement;
            }

            static public void CreateTextOutline(ref CuiElementContainer element, string panel, string text, string colorText, string colorOutline, string DistanceA, string DistanceB, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiTextComponent{Color = colorText, FontSize = size, Align = align, Text = text },
                        new CuiOutlineComponent {Distance = DistanceA + " " + DistanceB, Color = colorOutline},
                        new CuiRectTransformComponent {AnchorMax = aMax, AnchorMin = aMin }
                    }
                });
            }

            static public void CreateImage(ref CuiElementContainer element, string panel, string imageURL, string aMin, string aMax)
            {
                element.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent { Url = imageURL, Color = "1 1 1 1" },
                        new CuiRectTransformComponent {AnchorMax = aMax, AnchorMin = aMin }
                    }
                });
            }
        }

        #endregion

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        string msg(string key, string id = null) => lang.GetMessage(key, this, id);
    }
}


// --- End of file: PlayerBlinder.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-hider ---
// --- Original File Path: P/PlayerHider/PlayerHider.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Network;
using Network.Visibility;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Player Hider", "birthdates", "1.3.0")]
    [Description("Don't network players that are out of view")]
    public class PlayerHider : RustPlugin
    {
        #region Behaviour

        /// <summary>
        ///     Behaviour that handles the viewing of players
        /// </summary>
        private class ViewBehaviour : FacepunchBehaviour
        {
            /// <summary>
            ///     A set of our hidden players
            /// </summary>
            private readonly HashSet<BasePlayer> _hiddenPlayers = new HashSet<BasePlayer>();

            private readonly List<Connection> _list = new List<Connection>();

            private bool _lastChangeable;
            private Vector3 _lastPos;

            /// <summary>
            ///     Our parent player
            /// </summary>
            private BasePlayer _player;

            public Group Group { get; set; }

            private void Awake()
            {
                _player = GetComponent<BasePlayer>();
                _list.Add(_player.Connection);
                Group = new Group(Net.sv.visibility, Net.sv.TakeUID());
                foreach (var networkable in BaseNetworkable.GlobalNetworkGroup.networkables)
                    Group.networkables.Add(networkable);
                _player.net.subscriber.UnsubscribeAll();
                _player.net.subscriber.Subscribe(Group);
                _player.net.SwitchGroup(Group);
                _player.SendNetworkGroupChange();
                _player.SendNetworkUpdateImmediate();
                Instance._idToBehaviour[_player.userID] = this;
            }

            public void OnDestroy()
            {
                foreach (var player in _hiddenPlayers) ShowPlayer(player);
                Instance._idToBehaviour.Remove(_player.userID);
                _player.UpdateNetworkGroup();
                Net.sv.ReturnUID(Group.ID);
            }

            /// <summary>
            ///     Called when our parent player ticks
            /// </summary>
            public void Tick()
            {
                foreach (var player in BasePlayer.sleepingPlayerList)
                {
                    // If this is us, continue
                    if (player.userID == _player.userID ||
                        _lastChangeable && _player.transform.position.Equals(_lastPos)) continue;
                    // Retrieve the distance between us and the target player
                    var distance = _player.Distance(player.transform.position);
                    // If the distance is out of the render distance (max distance) or is not above the minimum distance, continue
                    if (distance >= MaxDistance || distance <= Instance._config.MinimumDistance) continue;

                    // Calculate the direction and execute a raycast with an obstruction mask at the distance between the players to see if anything is blocking the view
                    var direction = (_player.transform.position - player.transform.position).normalized;
                    RaycastHit hit;
                    if (!Physics.Raycast(_player.eyes.position, direction, out hit, distance,
                        Instance.ObstructionMask,
                        QueryTriggerInteraction.Ignore) || IsFiring(player))
                    {
                        // If not obstructed, continue or show the player if hidden
                        if (!_hiddenPlayers.Remove(player)) continue;
                        ShowPlayer(player);
                        continue;
                    }

                    // Set if the object we hit can be modified
                    _lastChangeable = hit.transform.gameObject.IsOnLayer(Instance.ModifiableObstructionMask);
                    _lastPos = _player.transform.position;

                    // If obstructed and hidden, continue. Otherwise, hide the player.
                    if (!_hiddenPlayers.Add(player)) continue;
                    player.OnNetworkSubscribersLeave(_list);
                }
            }

            /// <summary>
            ///     Show this player
            /// </summary>
            /// <param name="player">Target player</param>
            public void ShowPlayer(BasePlayer player)
            {
                if (player.IsDestroyed || !player.IsConnected) return;
                Group.networkables.Add(player.net);
                player.SendAsSnapshot(_player.Connection);
                player.GetHeldEntity()?.SendAsSnapshot(_player.Connection);
                _player.SendNetworkGroupChange();
                _player.SendNetworkUpdateImmediate();
            }

            /// <summary>
            ///     Hide this player
            /// </summary>
            /// <param name="player">Target player</param>
            public void HidePlayer(BasePlayer player)
            {
                Group.Leave(player.net);
                player.OnNetworkSubscribersLeave(_list);
            }

            /// <summary>
            ///     Can our parent player see this player?
            /// </summary>
            /// <param name="player">Target player</param>
            /// <returns>True if our parent player can see this player. False, otherwise.</returns>
            public bool CanSee(BasePlayer player)
            {
                return !_hiddenPlayers.Contains(player);
            }

            /// <summary>
            ///     Kill this behaviour and show all players
            /// </summary>
            public void Kill()
            {
                DestroyImmediate(this);
            }
        }

        #endregion

        #region Variables

        /// <summary>
        ///     Max render distance
        /// </summary>
        private const float MaxDistance = 500.0f;

        /// <summary>
        ///     Layer mask that will obstruct a player
        /// </summary>
        private int ObstructionMask { get; } = LayerMask.GetMask("Construction", "World", "Terrain");

        /// <summary>
        ///     The layer mask from <see cref="ObstructionMask" /> that are modifiable
        /// </summary>
        private int ModifiableObstructionMask { get; } = LayerMask.GetMask("Construction");

        /// <summary>
        ///     Plugin instance
        /// </summary>
        private static PlayerHider Instance { get; set; }

        private readonly IDictionary<ulong, ViewBehaviour> _idToBehaviour = new Dictionary<ulong, ViewBehaviour>();

        #endregion

        #region Hooks

        [HookMethod("CanSee")]
        private bool CanSee(BasePlayer player, BasePlayer target)
        {
            if (_config.ShowOnFire && IsFiring(target)) return true;
            var component = target.GetComponent<ViewBehaviour>();
            return component == null || component.CanSee(player);
        }

        private void OnNetworkGroupLeft(BasePlayer player, Group group)
        {
            // If is not limit networking (limbo) group, return
            if (group.ID != 1U) return;
            ViewBehaviour viewBehaviour;
            if (!_idToBehaviour.TryGetValue(player.userID, out viewBehaviour)) return;
            player.net.SwitchGroup(viewBehaviour.Group);
        }

        private static bool IsFiring(BasePlayer player)
        {
            var projectile = player.GetHeldEntity() as BaseProjectile;
            return projectile != null && projectile.NextAttackTime - Time.time >= -1;
        }

        private void Init()
        {
            Instance = this;
            foreach (var player in BasePlayer.activePlayerList) OnPlayerRespawned(player);
        }

        private void OnServerInitialized()
        {
            timer.Every(_config.CheckInterval, CheckPlayers);

            // Map to new list
            MapGroupSubscribers(new UpdateListHashSet<Networkable>(OnNetworkableChanged));
        }

        private void OnNetworkableChanged(Networkable networkable, bool removed)
        {
            var foundPlayer =
                BasePlayer.activePlayerList.FirstOrDefault(basePlayer => basePlayer.net.ID == networkable.ID);
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                ViewBehaviour viewBehaviour;
                if (!_idToBehaviour.TryGetValue(basePlayer.userID, out viewBehaviour) ||
                    foundPlayer != null && !viewBehaviour.CanSee(foundPlayer)) continue;
                var group = viewBehaviour.Group;
                if (removed) group.networkables.Remove(networkable);
                else group.networkables.Add(networkable);
                basePlayer.SendNetworkUpdateImmediate();
            }
        }

        private static void CheckPlayers()
        {
            foreach (var player in BasePlayer.activePlayerList) player.GetComponent<ViewBehaviour>()?.Tick();
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList) player.GetComponent<ViewBehaviour>()?.Kill();
            Instance = null;
            MapGroupSubscribers(new ListHashSet<Networkable>());
        }

        private static void MapGroupSubscribers(ListHashSet<Networkable> newValue)
        {
            var old = BaseNetworkable.GlobalNetworkGroup.networkables;
            BaseNetworkable.GlobalNetworkGroup.networkables = newValue;
            foreach (var networkable in old) newValue.Add(networkable);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            player.gameObject.AddComponent<ViewBehaviour>();
        }

        private class UpdateListHashSet<T> : ListHashSet<T>
        {
            private readonly Action<T, bool> _callback;

            public UpdateListHashSet(Action<T, bool> callback)
            {
                _callback = callback;
            }

            public new void Add(T value)
            {
                base.Add(value);
                _callback.Invoke(value, false);
            }

            public new bool Remove(T value)
            {
                var ret = base.Remove(value);
                if (ret) _callback.Invoke(value, true);
                return ret;
            }
        }

        #endregion

        #region Configuration & Localization

        private ConfigFile _config;

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null) LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        private class ConfigFile
        {
            /// <summary>
            ///     The minimum distance a player needs to be before being hidden
            /// </summary>
            [JsonProperty("Minimum Distance")]
            public float MinimumDistance { get; set; }

            /// <summary>
            ///     Show a player if they're firing?
            /// </summary>
            [JsonProperty("Show a Player if Firing")]
            public bool ShowOnFire { get; set; }

            /// <summary>
            ///     Check interval for hiding & showing
            /// </summary>
            [JsonProperty("Check Interval (seconds)")]
            public float CheckInterval { get; set; }

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    MinimumDistance = 100f,
                    ShowOnFire = true,
                    CheckInterval = 0.5f
                };
            }
        }

        #endregion
    }
}

// --- End of file: PlayerHider.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/plagued-npcs ---
// --- Original File Path: P/PlaguedNPCs/PlaguedNPCs.cs ---

//#define DEBUG

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Plagued NPCs", "Wulf", "3.1.1")]
    [Description("Customize NPC player health, attire, skins and weapons")]
    public class PlaguedNPCs : CovalencePlugin
    {
        #region Configuration

        private Configuration _config;

        public class PlaguedNPC
        {
            [JsonProperty("Enable NPC")]
            public bool Enable = true;

            [JsonProperty("Health")]
            public int Health = 100;

            [JsonProperty("Max Health")]
            public int MaxHealth = 100;

            [JsonProperty("Speed")]
            public float Speed = 7f;

            [JsonProperty("No Loot")]
            public bool NoLoot = false;

            [JsonProperty("Glowing Eyes")]
            public bool GlowingEyes = true;

            [JsonProperty("Sound Effect")]
            public bool SoundEffect = true;

            [JsonProperty("Attire", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, List<string>> Attire = new Dictionary<string, List<string>>()
            {
                {
                    "Head", new List<string>()
                    {
                        "mask.balaclava", "burlap.headwrap", "none"
                    }
                },
                {
                    "Torso", new List<string>()
                    {
                        "burlap.shirt", "tshirt", "tshirt.long", "none"
                    }
                },
                {
                    "Hands", new List<string>()
                    {
                        "burlap.gloves", "none"
                    }
                },
                {
                    "Legs", new List<string>()
                    {
                        "burlap.trousers", "pants.shorts"
                    }
                },
                {
                    "Feet", new List<string>()
                    {
                        "shoes.boots", "none"
                    }
                }
            };

            [JsonProperty("Weapons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Weapons = new List<string>()
            {
                "hatchet", "knife.butcher", "knife.combat", "machete", "pistol.nailgun", "salvaged.cleaver"
            };

            [JsonProperty("Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, List<ulong>> Skins = new Dictionary<string, List<ulong>>()
            {
                ["mask.balaclava"] = new List<ulong>() { 1174080411, 811558576 },
                ["burlap.headwrap"] = new List<ulong>() { 1076584212, 811534810 },
                ["burlap.shirt"] = new List<ulong>() { 1177719024, 582568540 },
                ["tshirt"] = new List<ulong>() { 811616832, 960936268 },
                ["tshirt.long"] = new List<ulong>() { 1161735516, 810504871 },
                ["burlap.gloves"] = new List<ulong>() { 917605230, 1464134946 },
                ["burlap.trousers"] = new List<ulong>() { 1177788927, 823281717 },
                ["pants.shorts"] = new List<ulong>() { 885479497, 841150520 },
                ["shoes.boots"] = new List<ulong>() { 1428936568, 1291665415 }
            };

            [JsonProperty("Use Kits")]
            public bool UseKits = false;

            [JsonProperty("Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Kits = new List<string>()
            {
                "plagued-kit1", "plagued-kit2"
            };
        }

        private class Configuration
        {
            [JsonProperty("Scarecrows")]
            public PlaguedNPC Scarecrows = new PlaguedNPC();

            [JsonProperty("Scientists")]
            public PlaguedNPC Scientists = new PlaguedNPC();

            [JsonProperty("Tunnel Dwellers")]
            public PlaguedNPC TunnelDwellers = new PlaguedNPC();

            [JsonProperty("Underwater Dwellers")]
            public PlaguedNPC UnderwaterDwellers = new PlaguedNPC();

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #region Handling

        [PluginReference]
        private Plugin Kits;

        private const int plaguedFlag = 0x1000000;

        private PlaguedNPC GetPlaguedNpc(NPCPlayer npc)
        {
            PlaguedNPC plaguedNpc = null;

            switch (npc.GetType().Name)
            {
                case "ScarecrowNPC":
                    if (_config.Scarecrows.Enable)
                    {
                        plaguedNpc = _config.Scarecrows;
                    }
                    break;

                case "ScientistNPC":
                    if (_config.Scientists.Enable) // TODO: Expand options for subtypes
                    {
                        plaguedNpc = _config.Scientists;
                    }
                    break;

                case "TunnelDweller":
                    if (_config.TunnelDwellers.Enable)
                    {
                        plaguedNpc = _config.TunnelDwellers;
                    }
                    break;

                case "UnderwaterDweller":
                    if (_config.UnderwaterDwellers.Enable)
                    {
                        plaguedNpc = _config.UnderwaterDwellers;
                    }
                    break;
            }

            return plaguedNpc;
        }

        private void OnEntitySpawned(NPCPlayer npc)
        {
#if DEBUG
            LogWarning($"{npc.GetType().Name} spawned");
#endif
            PlaguedNPC plaguedNpc = GetPlaguedNpc(npc);
            if (plaguedNpc != null)
            {
                if (plaguedNpc.UseKits && Kits != null && Kits.IsLoaded && plaguedNpc.Kits.Count > 0)
                {
                    GiveKit(npc, plaguedNpc.Kits[Core.Random.Range(0, plaguedNpc.Kits.Count - 1)]);
                }
                else
                {
                    ClotheNpc(npc, plaguedNpc);
                }

#if DEBUG
                LogWarning($"Original NPC max health: {npc._maxHealth}, new NPC max health: {plaguedNpc.MaxHealth}");
                LogWarning($"Original NPC health: {npc.health}, new NPC health: {plaguedNpc.Health}");
#endif
                npc.InitializeHealth(plaguedNpc.Health, plaguedNpc.MaxHealth);

                NextTick(() =>
                {
                    NPCPlayer npcSpecific = npc;
                    if (npc is ScarecrowNPC)
                    {
                        ScarecrowNPC scarecrowNpc = npc as ScarecrowNPC;
                        if (scarecrowNpc?.Brain?.Navigator != null)
                        {
#if DEBUG
                            LogWarning($"Original NPC speed: {scarecrowNpc.Brain.Navigator.Speed}, new NPC speed: {plaguedNpc.Speed}");
#endif
                            scarecrowNpc.Brain.Navigator.Speed = plaguedNpc.Speed;
                        }
                    }
                    else
                    {
                        global::HumanNPC humanNpc = npc as global::HumanNPC;
                        if (humanNpc?.Brain?.Navigator != null)
                        {
#if DEBUG
                            LogWarning($"Original NPC speed: {humanNpc.Brain.Navigator.Speed}, new NPC speed: {plaguedNpc.Speed}");
#endif
                            humanNpc.Brain.Navigator.Speed = plaguedNpc.Speed;
                        }
                    }
                });

                npc.SetPlayerFlag((BasePlayer.PlayerFlags)plaguedFlag, true);
#if DEBUG
                LogWarning($"NPC has plagued flag? {IsPlagued(npc)}");
#endif
            }
        }

        private void OnNpcTarget(NPCPlayer npc)
        {
            if (!IsPlagued(npc))
            {
                return;
            }

            PlaguedNPC plaguedNpc = GetPlaguedNpc(npc);
            if (plaguedNpc != null && plaguedNpc.SoundEffect)
            {
                Effect.server.Run($"assets/bundled/prefabs/fx/player/beartrap_scream.prefab", npc, 0u, Vector3.zero, npc.eyes.transform.forward.normalized);
            }
        }

        private void OnCorpsePopulate(NPCPlayer npc, LootableCorpse corpse)
        {
            if (!IsPlagued(npc))
            {
                return;
            }

            PlaguedNPC plaguedNpc = GetPlaguedNpc(npc);
            if (plaguedNpc != null && plaguedNpc.NoLoot)
            {
                EmptyCorpse(npc, corpse);
            }
        }

        private void OnPlayerCorpseSpawned(NPCPlayer npc, LootableCorpse corpse)
        {
            if (!IsPlagued(npc))
            {
                return;
            }

            PlaguedNPC plaguedNpc = GetPlaguedNpc(npc);
            if (plaguedNpc != null && plaguedNpc.NoLoot)
            {
                EmptyCorpse(npc, corpse);
            }
        }

        #endregion Handling

        #region Helpers

        private void ClotheNpc(NPCPlayer npc, PlaguedNPC plaguedNpc)
        {
            ItemContainer containerWear = npc.inventory.containerWear;
            containerWear.Clear();

            if (plaguedNpc.GlowingEyes)
            {
                Item glowingEyes = ItemManager.CreateByName("gloweyes");
                if (glowingEyes != null)
                {
                    glowingEyes.MoveToContainer(containerWear);
                }
            }

            foreach (KeyValuePair<string, List<string>> clothing in plaguedNpc.Attire)
            {
                Item item = GetItem(clothing.Value, plaguedNpc);
                if (item != null)
                {
#if DEBUG
                    LogWarning($"Gave {npc.name} ({npc.net.ID}) {item.info.displayName.english}");
#endif
                    item.MoveToContainer(containerWear);
                }
            }

            Item weapon = GetItem(plaguedNpc.Weapons, plaguedNpc);
            if (weapon != null)
            {
#if DEBUG
                LogWarning($"Gave {npc.name} ({npc.net.ID}) {weapon.info.displayName.english}");
#endif
                BaseProjectile projectile = weapon.GetHeldEntity() as BaseProjectile;
                if (projectile != null)
                {
                    projectile.primaryMagazine.contents = projectile.primaryMagazine.capacity;
                }

                ItemContainer containerBelt = npc.inventory.containerBelt;
                containerBelt.Clear();

                weapon.MoveToContainer(containerBelt);
            }
        }

        private void EmptyCorpse(NPCPlayer npc, LootableCorpse corpse)
        {
            NextTick(() =>
            {
                for (int i = 0; i < corpse.containers.Length; i++)
                {
                    while (corpse.containers[i].itemList?.Count > 0)
                    {
                        Item item = corpse.containers[i].itemList[0];
                        item.RemoveFromContainer();
                        item.Remove(0f);
                    }
                }
            });
        }

        private Item GetItem(List<string> items, PlaguedNPC plaguedNpc)
        {
            if (items.Count < 1)
            {
                return null;
            }

            int itemIndex = Core.Random.Range(0, items.Count - 1);

            if (items[itemIndex] == "none")
            {
                return null;
            }

            List<ulong> skins;
            string chosenItem = items[itemIndex];
            bool skinsDefined = plaguedNpc.Skins.TryGetValue(chosenItem, out skins);

            Item selectedItem;
            if (skinsDefined && skins.Count > 0)
            {
                selectedItem = ItemManager.CreateByName(chosenItem, 1, skins[Core.Random.Range(0, skins.Count - 1)]);
            }
            else
            {
                selectedItem = ItemManager.CreateByName(chosenItem, 1);
            }
            return selectedItem;
        }

        private void GiveKit(NPCPlayer npc, string kitName)
        {
            npc.inventory.Strip();

            object kitResult = Kits.Call<object>("GiveKit", npc, kitName);
            if (kitResult == null || !(kitResult is bool))
            {
                LogError($"Failed to give kit {kitName} to {npc.name} ({npc.net.ID}): {kitResult}");
            }
        }

        private bool IsPlagued(NPCPlayer npc) => npc.HasPlayerFlag((BasePlayer.PlayerFlags)plaguedFlag);

        #endregion Helpers
    }
}


// --- End of file: PlaguedNPCs.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pound-bot-chat-relay ---
// --- Original File Path: P/PoundBotChatRelay/PoundBotChatRelay.cs ---

﻿// Requires: PoundBot

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

#if RUST
using ConVar;
#endif

namespace Oxide.Plugins
{
  [Info("Pound Bot Chat Relay", "MrPoundsign", "2.0.3")]
  [Description("Chat relay for use with PoundBot")]

  class PoundBotChatRelay : CovalencePlugin
  {
    [PluginReference]
    private Plugin PoundBot, Clans;

    protected int ApiChatRunnersCount;
    private bool RelayDiscordChat;
    private bool RelayGiveNotices;
    private bool RelayServerChat;
    private bool UseBetterChat;
    private string RelayChatChannel;
    private string RelayChatColor;
    private string RelayServerChatColor;
    private string RelayServerChannel;

    class ChatMessage
    {
      public string ClanTag { get; set; }
      public string DisplayName { get; set; }
      public string Message { get; set; }
    }

    class ChatRunner
    {
      public string ID { get; }
      public DateTime LastRun { get; set; }
      public bool Running { get; set; }
      public bool LastStartOK { get; set; }
      public Timer Timer { get; set; }

      public ChatRunner()
      {
        ID = Guid.NewGuid().ToString();
        LastRun = DateTime.UtcNow;
      }
    }

    private List<ChatRunner> ChatRunners = new List<ChatRunner>();

    #region Configuration
    protected override void LoadDefaultConfig()
    {
      LogWarning("Creating a new configuration file");
      Config["config.version"] = 3;
      Config["relay.chat"] = true;
      Config["relay.betterchat"] = false;
      Config["relay.serverchat"] = true;
      Config["relay.givenotices"] = true;
      Config["relay.discordchat"] = true;
      Config["chat.channel"] = "";
      Config["chat.server_channel"] = "";
      Config["chat.styled"] = true;
      Config["chat.styled_color"] = "darkorange";
      Config["chat.server_styled"] = true;
      Config["chat.server_styled_color"] = "darkred";
    }

    void UpgradeConfig()
    {
      string configVersion = "config.version";
      bool dirty = false;
      if (Config[configVersion] == null)
      {
        Config[configVersion] = 1;
      }
      else
      {
        try
        {
          var foo = (string)Config[configVersion];
          Config[configVersion] = 2;
        }
        catch (InvalidCastException) { } // testing if it can be converted to a string or not. No need to change it because it's not a string.
      }

      if ((int)Config[configVersion] < 2)
      {
        LogWarning(string.Format(lang.GetMessage("config.upgrading", this), 2));
        if ((bool)Config["relay.betterchat"])
        {
          Config["relay.chat"] = true;
        }
        Config["relay.givenotices"] = (bool)Config["relay.serverchat"];
        dirty = true;
      }

      if ((int)Config[configVersion] < 3)
      {
        LogWarning(string.Format(lang.GetMessage("config.upgrading", this), 3));
        Config[configVersion] = 3;
        Config["chat.channel"] = "";
        Config["chat.server_channel"] = "";
        Config["chat.styled"] = true;
        Config["chat.styled_color"] = "darkorange";
        Config["chat.server_styled"] = true;
        Config["chat.server_styled_color"] = "darkred";
        dirty = true;
      }
      if (dirty) SaveConfig();
    }
    #endregion

    #region Oxide Hooks
    protected override void LoadDefaultMessages()
    {
      lang.RegisterMessages(
        new Dictionary<string, string>
        {
          ["chat.ClanTag"] = "[{0}] ",
          ["chat.Msg"] = "{{DSCD}} {0}: {1}",
          ["chat.Prefix"] = ":radioactive:",
          ["chat.DateFormat"] = "[HH:mm]",
          ["console.ClanTag"] = "[{0}] ",
          ["console.Msg"] = "{{DSCD}} {0}: {1}",
          ["config.upgrading"] = "Upgrading config to v{0}",
          ["config.chat_config_updated"] = "Config updated. Check oxide/config/PoundBotChatRelay.json",
          ["usage.chat_config"] = @"Usage:
pb.chat_config <channel|server_channel|styled|styled_color|server_styled|server_styled_color> [value]

If value is not supplied, prints the current value.

The values 'styled' and 'server_styled' are booleans, and must be set to '0', '1', 'true', or 'false'.

It is recommended you use the channel IDs rather than channel names for 'channel' and 'server_channel'.

See 'pb.channels' for information about your channels.",
          ["setting.is"] = "Setting {0} is {1}",
        }, this);
    }

    void OnServerInitialized()
    {
      UpgradeConfig();
      ApplyConfig();
      StartChatRunners();
    }

    void ApplyConfig()
    {
      if (!(bool)Config["relay.chat"])
      {
        Unsubscribe("OnUserChat");
        Unsubscribe("OnBetterChat");
      }
      else
      {
        if ((bool)Config["relay.betterchat"])
        {
          Unsubscribe("OnUserChat");
          UseBetterChat = true;
        }
        else
        {
          Unsubscribe("OnBetterChat");
        }
      }

      RelayServerChat = (bool)Config["relay.serverchat"];
      RelayGiveNotices = (bool)Config["relay.givenotices"];

      if (!RelayServerChat && !RelayGiveNotices) Unsubscribe("OnServerMessage");

      RelayDiscordChat = (bool)Config["relay.discordchat"];

      RelayChatChannel = (string)Config["chat.channel"];
      RelayServerChannel = (string)Config["chat.server_channel"];

      if ((bool)Config["chat.styled"])
      {
        RelayChatColor = (string)Config["chat.styled_color"];
      }
      else
      {
        RelayChatColor = null;
      }

      if ((bool)Config["chat.server_styled"])
      {
        RelayServerChatColor = (string)Config["chat.server_styled_color"];
      }
      else
      {
        RelayServerChatColor = null;
      }
    }

    void Unload() => KillChatRunners();
    #endregion

    #region Chat Runners
    void KillChatRunners()
    {
      if (!RelayDiscordChat) return;
      Puts("Killing chat runners");
      foreach (var runner in ChatRunners)
      {
        runner.Timer.Destroy();
      }
      ChatRunners.Clear();
    }

    // Chat runners connect to PoundBot and wait for new chat messages
    // from Discord to send to global chat
    void StartChatRunners()
    {
      if (!RelayDiscordChat) return;

      Puts("Starting chat runners");
      var runners_to_start = Enumerable.Range(1, 2);
      foreach (int i in runners_to_start)
      {
        Puts($"Started chat runner {i}");
        ChatRunners.Add(StartChatRunner());
      }
    }

    void RestartChatRunner(string id)
    {
      int index = ChatRunners.FindIndex(x => x.ID == id);
      if (index < 0)
      {
        Puts($"Could not find ChatRunner with ID {id}");
        return;
      }
      ChatRunners[index].Timer.Destroy();
      ChatRunners.RemoveAt(index);
      ChatRunners.Add(StartChatRunner());
    }
    #endregion

    #region PoundBot Requests
    private ChatRunner StartChatRunner()
    {
      ChatRunner cr = new ChatRunner();
      Func<int, string, bool> callback = (int code, string response) =>
      {
        cr.Running = false;
        switch (code)
        {
          case 200:
            ChatMessage message;
            try
            {
              message = JsonConvert.DeserializeObject<ChatMessage>(response);
            }
            catch (JsonReaderException)
            {
              Puts($"Could not decode JSON message from body: {response}");
              return true;
            }
            if (message != null)
            {
              string chatName = message?.DisplayName;
              string consoleName = message?.DisplayName;

              if ((chatName != null) && (message.ClanTag != string.Empty))
              {
                chatName = $"{string.Format(lang.GetMessage("chat.ClanTag", this), message.ClanTag)}{chatName}";
                consoleName = $"{string.Format(lang.GetMessage("console.ClanTag", this), message.ClanTag)}{consoleName}";
              }

              Puts(string.Format(lang.GetMessage("console.Msg", this), consoleName, message?.Message));

              string chatMessage = string.Format(lang.GetMessage("chat.Msg", this), chatName, message?.Message);
              foreach (IPlayer p in players.Connected)
              {
                p.Message(chatMessage);
              }
            }
            return true;
          case 204: // Status No Content
            return true;
        }

        return false;
      };

      cr.Timer = timer.Every(1f, () =>
      {
        if (!cr.Running)
        {
          if ((bool)PoundBot.Call("API_GetChannelMessage", new object[] { this, "chat", callback }))
          {
            cr.LastRun = DateTime.UtcNow;
            cr.Running = true;
            cr.LastStartOK = true;
          }
          else
          {
            // The API is down or could not start
            cr.LastStartOK = false;
          }
        }
        else if (cr.LastStartOK && cr.LastRun.AddSeconds(60) < DateTime.UtcNow)
        {
          cr.Running = false;
          RestartChatRunner(cr.ID);
        }
      });

      return cr;
    }
    #endregion

    void OnServerMessage(string message, string name)
    {
      var isGaveMessage = (message.Contains("gave") && name == "SERVER");
      if (!RelayServerChat && !isGaveMessage) return;
      if (!RelayGiveNotices && isGaveMessage) return;

      if (message == "Wow, no one played so no one won.") return;

      SendToPoundBot(name, message, RelayServerChannel, RelayServerChatColor);
    }

#if RUST
    void OnPlayerChat(BasePlayer bplayer, string message, Chat.ChatChannel chatchannel)
    {
      if (chatchannel == Chat.ChatChannel.Team) return;
      IPlayer player = bplayer.IPlayer;
#else
    void OnUserChat(IPlayer player, string message)
    {
#endif
      if (UseBetterChat) return;
      SendToPoundBot(player, message, RelayChatChannel, RelayChatColor);
    }

    void OnBetterChat(Dictionary<string, object> data)
    {
      if (!UseBetterChat) return;

#if RUST
      if ((Chat.ChatChannel)data["ChatChannel"] == Chat.ChatChannel.Team) return;
#endif

      string color = RelayChatColor;

      if (RelayChatColor != null)
      {
        Dictionary<string, object> m = (Dictionary<string, object>)data["MessageSettings"];

        color = (string)m["Color"];
      }

      IPlayer player = (IPlayer)data["Player"];

      SendToPoundBot(player, (string)data["Message"], RelayChatChannel, color);
    }

    void SendToPoundBot(IPlayer player, string message, string channel, string embed_color = null)
    {
      string playerName = player.Name;
      var clanTag = (string)Clans?.Call("GetClanOf", player);
      if (!string.IsNullOrEmpty(clanTag))
      {
        playerName = $"[{clanTag}]{playerName}";
      }

      SendToPoundBot(playerName, message, channel, embed_color);
    }

    void SendToPoundBot(string player, string message, string channel, string embed_color = null)
    {
      if (channel.Length == 0)
      {
        Puts("Channel not defined. Please set your channel names in config/PoundBotChatRelay.json.");
        return;
      }

      KeyValuePair<string, bool>[] message_parts = new KeyValuePair<string, bool>[4];
      message_parts[0] = new KeyValuePair<string, bool>($"{lang.GetMessage("chat.Prefix", this)}{DateTime.Now.ToString(lang.GetMessage("chat.DateFormat", this))} **", false);
      message_parts[1] = new KeyValuePair<string, bool>(player, true);
      message_parts[2] = new KeyValuePair<string, bool>("**: ", false);
      message_parts[3] = new KeyValuePair<string, bool>(message, true);
      PoundBot.Call(
        "API_SendChannelMessage",
        new object[] { this, channel, message_parts, embed_color, null }
      );
    }

    #region Commands
    //channel|server_channel|styled|styled_color|server_styled|server_styled_color
    [Command("pb.chat_config")]
    private void ConsoleCommandSetChatConfig(IPlayer player, string command, string[] args)
    {
      if (args.Count() < 1 || args.Count() > 2)
      {
        Puts(lang.GetMessage("usage.chat_config", this));
        return;
      }

      var configName = $"chat.{args[0]}";

      if (args.Count() == 1)
      {
        Puts(string.Format(lang.GetMessage("setting.is", this), configName, Config[configName]));
        return;
      }

      object configValue;

      switch (args[0])
      {
        // All the string cases
        case "channel":
        case "server_channel":
        case "styled_color":
        case "server_styled_color":
          configValue = args[1];
          break;

        // All the boolean cases
        case "styled":
        case "server_styled":
          configValue = (args[1] == "1" || args[1].ToLower() == "true");
          break;
        default:
          Puts(lang.GetMessage("usage.chat_config", this));
          return;
      }

      Puts(lang.GetMessage("config.chat_config_updated", this));
      Config[configName] = configValue;
      SaveConfig();
      ApplyConfig();
    }
    #endregion
  }
}


// --- End of file: PoundBotChatRelay.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/portgun ---
// --- Original File Path: P/Portgun/Portgun.cs ---

#if REIGNOFKINGS
using CodeHatch;
using CodeHatch.Engine.Networking;
#endif
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
#if HURTWORLD || REIGNOFKINGS || RUST || THEFOREST
using UnityEngine;
#endif
#if HURTWORLD
using uLink;
#endif

// TODO: Protect players from damage (in all games) until second after teleporting

namespace Oxide.Plugins
{
    [Info("Portgun", "Wulf/lukespragg", "3.3.2")]
    [Description("Teleports players with permission to object or terrain they are looking at")]
    public class Portgun : CovalencePlugin
    {
        #region Localization

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandPort"] = "port",
                ["NoDestination"] = "Could not find a valid destination to port to",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["OutOfBounds"] = "The location you're aiming at is outside the map's boundaries",
                ["PlayersOnly"] = "Command '{0}' can only be used by a player"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private readonly HashSet<string> protection = new HashSet<string>();

        private const string permUse = "portgun.use";

        private float mapSize;
        private int layers;

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permUse, this);

            AddCovalenceCommand("portgun", "PortCommand");
            AddLocalizedCommand("CommandPort", "PortCommand");

#if HURTWORLD
            layers = LayerMaskManager.TerrainConstructionsMachines;
#elif REIGNOFKINGS
            layers = LayerMask.GetMask("Cubes", "Environment", "Terrain");
#elif RUST
            mapSize = TerrainMeta.Size.x / 2;
            layers = LayerMask.GetMask("Construction", "Default", "Deployed", "Resource", "Terrain", "Water", "World");
#elif THEFOREST
            layers = 67108864;
#endif
        }

        #endregion Initialization

        #region Port Command

        private void PortCommand(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
            {
                player.Reply(Lang("PlayersOnly", player.Id, command));
                return;
            }

            if (!player.HasPermission(permUse))
            {
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

#if HURTWORLD || REIGNOFKINGS || RUST || THEFOREST
            RaycastHit hit = new RaycastHit();
#endif
#if HURTWORLD
            EntityReferenceCache entity = (player.Object as PlayerSession).WorldPlayerEntity;
            CamData simData = entity.GetComponent<PlayerStatManager>().RefCache.PlayerCamera.SimData;
            CharacterController controller = entity.GetComponent<CharacterController>();
            Vector3 point1 = simData.FirePositionWorldSpace + controller.center + Vector3.up * -controller.height * 0.5f;
            Vector3 point2 = point1 + Vector3.up * controller.height;
            Vector3 direction = simData.FireRotationWorldSpace * Vector3.forward;
            if (!Physics.CapsuleCast(point1, point2, controller.radius, direction, out hit, float.MaxValue, layers))
#elif REIGNOFKINGS
            CodeHatch.Engine.Core.Cache.Entity entity = (player.Object as Player).Entity;
            if (!Physics.Raycast(entity.Position, entity.GetOrCreate<LookBridge>().Forward, out hit, float.MaxValue, layers))
#elif RUST
            BasePlayer basePlayer = player.Object as BasePlayer;
            if (basePlayer != null && !Physics.Raycast(basePlayer.eyes.HeadRay(), out hit, float.MaxValue, layers))
#elif THEFOREST
            BoltEntity entity = player.Object as BoltEntity;
            Physics.Raycast(entity.transform.position, entity.transform.rotation * Vector3.forward, out hit, float.MaxValue, layers);
            if (hit.collider != null && !hit.collider.CompareTag("TerrainMain") && !hit.collider.CompareTag("structure"))
#endif
            {
                player.Reply(Lang("NoDestination", player.Id));
                return;
            }

#if HURTWORLD
            Vector3 safePos = simData.FirePositionWorldSpace + direction * hit.distance;
            GenericPosition destination = new GenericPosition(safePos.x, safePos.y, safePos.z);
#elif REIGNOFKINGS || RUST || THEFOREST
            GenericPosition destination = new GenericPosition(hit.point.x, hit.point.y, hit.point.z);
#else
            GenericPosition destination = new GenericPosition();
#endif

            if (!IsValidMapCoordinates(destination.X, destination.Y, destination.Z))
            {
                player.Reply(Lang("OutOfBounds", player.Id));
                return;
            }

#if DEBUG
            player.Reply($"Current position: {player.Position()}");
            player.Reply($"Destination: {destination}");
#endif
            protection.Add(player.Id); // TODO: Remove to reset before adding if using timer?
            player.Teleport(destination.X, destination.Y, destination.Z);
        }

        #endregion Port Command

        #region Damage Protection

#if HURTWORLD
        private void OnPlayerTakeDamage(PlayerSession session, EntityEffectSourceData source)
        {
            string id = session.SteamId.ToString();
            if (protection.Contains(id))
            {
                source.Value = 0f;
                timer.Once(10f, () => protection.Remove(id)); // TODO: Detect ground instead of timer
            }
        }
#elif RUST
        private void OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            BasePlayer basePlayer = entity as BasePlayer;
            if (basePlayer != null && protection.Contains(basePlayer.UserIDString))
            {
                info.damageTypes = new Rust.DamageTypeList();
                info.HitMaterial = 0;
                info.PointStart = Vector3.zero;
                timer.Once(10f, () => protection.Remove(basePlayer.UserIDString)); // TODO: Detect ground instead of timer
            }
        }
#endif

        #endregion Damage Protection

        #region Helpers

        private bool IsValidMapCoordinates(float x, float y, float z)
        {
#if RUST
            return x <= mapSize && x >= -mapSize && y < 2000 && y >= -100 && z <= mapSize && z >= -mapSize;
#else
            return true; // Return true for unsupported games
#endif
        }

        private void AddLocalizedCommand(string key, string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages.Where(m => m.Key.Equals(key)))
                {
                    if (!string.IsNullOrEmpty(message.Value))
                    {
                        AddCovalenceCommand(message.Value, command);
                    }
                }
            }
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        #endregion Helpers
    }
}


// --- End of file: Portgun.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/permission-effects ---
// --- Original File Path: P/PermissionEffects/PermissionEffects.cs ---

﻿using System;
using System.Linq;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Permission Effects", "noname", "1.1.1")]
    [Description("Enhance the permission system by abstracting Oxide permission system")]
    class PermissionEffects : CovalencePlugin
    {
        [PluginReference]
        private Plugin PlaytimeTracker, UIScaleManager;

        public static PermissionEffects Plugin;
        public static string permissioneffects_admin_perm_admin_perm = "permissioneffects.admin";

        #region GUIField

        Dictionary<string, Timer> PlayersViewingUi = new Dictionary<string, Timer>();
        string CursorUIPanel = "CursorUIPanel";
        string UIBaseInvPanel = "UIBaseInvPanel";
        string UIBasePanel = "UIBasePanel";
        string BackGroundPanel = "BackGroundPanel";
        string UIBaseBtnPanel = "UIBaseBtnPanel";
        string UIPMBtn = "UIPMBtn";
        string ESBtn = "ESBtn";

        #endregion

        #region Hooks
        
        private new void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");

            Config.WriteObject(GetDefaultConfig(), true);
        }

        private void Init()
        {
            LoadConfig();
            LoadPlayersData();
            LoadGroupsData();
            LoadThreadsData();
            LoadPlayersGUIData();
        }

        void OnServerSave()
        {
            puts("Saving Permission Effects DataFile...");
            SavePlayersData();
            SaveGroupsData();
            SaveThreadsData();
            SavePlayersGUIData();
        }

        void Unload()
        {
            puts("Saving Permission Effects DataFile...");
            SavePlayersData();
            SaveGroupsData();
            SaveThreadsData();
            SavePlayersGUIData();

            PlayersRemoveBaseinvUI();

            Plugin = null;
        }

        private void OnServerInitialized()
        {
            Plugin = this;
            RegisterPermissions();
            RegisterCommands();
            StartTimer();
            playersUIData.ResetOnlinePlayersData();
            PlayersAddBaseinvUI();
            RegisterTestEffects();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsNpc) return;

            playersUIData.ResetPlayerData(player);
            timer.Once(5f, () =>
            {
                PlayerAddBaseinvUI(player);
                UpdatePlayerGUI(player);
            });
        }

        #endregion

        #region Classes

        #region BaseThread

        private enum PlayerThreadType
        {
            BasePlayerEffectThread,
            EffectThread,
            RealtimeEffectThread,
            PlaytimeEffectThread
        }

        private enum DataThreadType
        {
            BaseDataEffectThread,
            EffectThreadData,
            RealtimeEffectThreadData,
            PlaytimeEffectThreadData
        }

        private class BasePlayerEffectThread : IEquatable<BasePlayerEffectThread>
        {
            public PlayerThreadType PlayerThreadType { get; set; }
            public string ThreadName { get; set; }
            public string ThreadColor { get; set; }
            public List<string> Permissions { get; set; }

            public DateTime DisconnectAutoExpireDate { get; set; }
            public TimeSpan? DisconnectAutoExpireTime { get; set; }

            public DateTime ExpireDate { get; set; }
            public TimeSpan ExpireTime { get; set; }

            public BasePlayerEffectThread()
            {
                PlayerThreadType = PlayerThreadType.BasePlayerEffectThread;
            }

            public bool Equals(BasePlayerEffectThread other)
            {
                return other != null &&
                       ThreadName == other.ThreadName &&
                       ThreadColor == other.ThreadColor &&
                       PlayerThreadType == other.PlayerThreadType;
            }

            public override bool Equals(object obj)
            {
                var other = obj as BasePlayerEffectThread;
                return other != null &&
                       ThreadName == other.ThreadName &&
                       ThreadColor == other.ThreadColor &&
                       PlayerThreadType == other.PlayerThreadType;
            }

            public override int GetHashCode()
            {
                var hashCode = 909284198;
                hashCode = hashCode * -1521134295 + PlayerThreadType.GetHashCode();
                hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(ThreadName);
                hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(ThreadColor);
                return hashCode;
            }

            public void GrantUserPermissions(string id)
            {
                foreach (var item in Permissions)
                {
                    Plugin.permission.GrantUserPermission(id, item, null);
                }
            }

            public void GrantGroupPermissions(string groupName)
            {
                foreach (var item in Permissions)
                {
                    Plugin.permission.GrantGroupPermission(groupName, item, null);
                }
            }

            public void RevokeUserPermissions(string id, Dictionary<string, BasePlayerEffectThread> PlayerEffectThreads)
            {
                foreach (var item in Permissions)
                {
                    bool OthersContains = false;
                    foreach (var item2 in PlayerEffectThreads)
                    {
                        if (item2.Value.ThreadName != ThreadName && item2.Value.Permissions.Contains(item))
                        {
                            OthersContains = true;
                            break;
                        }
                    }
                    if (OthersContains == false)
                        Plugin.permission.RevokeUserPermission(id, item);
                }
            }

            public void RevokeUserPermissions(string id)
            {
                foreach (var item in Permissions)
                {
                    Plugin.permission.RevokeUserPermission(id, item);
                }
            }

            public void RevokeGroupPermissions(string groupName, Dictionary<string, BasePlayerEffectThread> PlayerEffectThreads)
            {
                foreach (var item in Permissions)
                {
                    bool OthersContains = false;
                    foreach (var item2 in PlayerEffectThreads)
                    {
                        if (item2.Value.ThreadName != ThreadName && item2.Value.Permissions.Contains(item))
                        {
                            OthersContains = true;
                            break;
                        }
                    }
                    if (OthersContains == false)
                        Plugin.permission.RevokeGroupPermission(groupName, item);
                }
            }

            public void RevokeGroupPermissions(string groupName)
            {
                foreach (var item in Permissions)
                {
                    Plugin.permission.RevokeGroupPermission(groupName, item);
                }
            }
        }

        private class BaseDataEffectThread
        {
            public DataThreadType DataThreadType { get; set; }
            public string ThreadName { get; set; }
            public string ThreadColor { get; set; }
            public List<string> Permissions { get; set; }

            public TimeSpan? DisconnectAutoExpireTime { get; set; }

            public TimeSpan ExpireTime { get; set; }

            public BaseDataEffectThread()
            {
                DataThreadType = DataThreadType.BaseDataEffectThread;
            }

            public BasePlayerEffectThread ToPlayerEffectThread(string PlayerID)
            {
                switch (DataThreadType)
                {
                    case DataThreadType.BaseDataEffectThread:
                        return new EffectThread(ThreadName, ThreadColor, Permissions, DisconnectAutoExpireTime);
                    case DataThreadType.EffectThreadData:
                        return new EffectThread(ThreadName, ThreadColor, Permissions, DisconnectAutoExpireTime);
                    case DataThreadType.RealtimeEffectThreadData:
                        return new RealtimeEffectThread(ThreadName, ThreadColor, Permissions, DisconnectAutoExpireTime, ExpireTime);
                    case DataThreadType.PlaytimeEffectThreadData:
                        return new PlaytimeEffectThread(ThreadName, ThreadColor, Permissions, DisconnectAutoExpireTime, ExpireTime, PlayerID);
                    default:
                        return null;
                }
            }
        }

        #endregion

        #region PlayerThread

        private class EffectThread : BasePlayerEffectThread
        {
            public EffectThread()
            {
                PlayerThreadType = PlayerThreadType.EffectThread;
            }

            public EffectThread(string threadName, string threadColor, List<string> permissions, TimeSpan? AutoExpireTIme) //default
            {
                PlayerThreadType = PlayerThreadType.EffectThread;

                ThreadName = threadName;
                ThreadColor = threadColor;
                Permissions = permissions;

                if (AutoExpireTIme != null)
                    DisconnectAutoExpireDate = DateTime.Now + (TimeSpan)AutoExpireTIme;

                DisconnectAutoExpireTime = AutoExpireTIme;
            }
        }

        private class RealtimeEffectThread : EffectThread
        {
            public RealtimeEffectThread()
            {
                PlayerThreadType = PlayerThreadType.RealtimeEffectThread;
            }

            public RealtimeEffectThread(string threadName, string threadColor, List<string> permissions, TimeSpan? AutoExpireTIme, TimeSpan expireTime)//realtime
                : base(threadName, threadColor, permissions, AutoExpireTIme)
            {
                PlayerThreadType = PlayerThreadType.RealtimeEffectThread;

                ExpireDate = DateTime.Now + expireTime;
            }
        }

        private class PlaytimeEffectThread : EffectThread
        {
            public PlaytimeEffectThread()
            {
                PlayerThreadType = PlayerThreadType.PlaytimeEffectThread;
            }

            public PlaytimeEffectThread(string threadName, string threadColor, List<string> permissions, TimeSpan? AutoExpireTIme, TimeSpan expireTime, string PlayerID)//playtime
                : base(threadName, threadColor, permissions, AutoExpireTIme)
            {
                PlayerThreadType = PlayerThreadType.PlaytimeEffectThread;

                TimeSpan? PlayerPlaytime = Plugin.GetPlayerPlaytime(PlayerID);
                if (PlayerPlaytime == null)
                {
                    ExpireTime = new TimeSpan();
                }
                else
                {
                    ExpireTime = (TimeSpan)PlayerPlaytime + expireTime;
                }
            }
        }

        #endregion

        #region DataThread

        private class EffectThreadData : BaseDataEffectThread
        {
            public EffectThreadData()
            {
                DataThreadType = DataThreadType.EffectThreadData;
            }

            public EffectThreadData(string threadName, string threadColor, List<string> permissions, TimeSpan? AutoExpireTIme)
            {
                DataThreadType = DataThreadType.EffectThreadData;

                ThreadName = threadName;
                ThreadColor = threadColor;
                Permissions = permissions;

                DisconnectAutoExpireTime = AutoExpireTIme;
            }
        }

        private class RealtimeEffectThreadData : EffectThreadData
        {
            public RealtimeEffectThreadData()
            {
                DataThreadType = DataThreadType.RealtimeEffectThreadData;
            }

            public RealtimeEffectThreadData(string threadName, string threadColor, List<string> permissions, TimeSpan? AutoExpireTIme, TimeSpan expireTime)
                : base(threadName, threadColor, permissions, AutoExpireTIme)
            {
                DataThreadType = DataThreadType.RealtimeEffectThreadData;

                ExpireTime = expireTime;
            }
        }

        private class PlaytimeEffectThreadData : EffectThreadData
        {
            public PlaytimeEffectThreadData()
            {
                DataThreadType = DataThreadType.PlaytimeEffectThreadData;
            }

            public PlaytimeEffectThreadData(string threadName, string threadColor, List<string> permissions, TimeSpan? AutoExpireTIme, TimeSpan expireTime)
                : base(threadName, threadColor, permissions, AutoExpireTIme)
            {
                DataThreadType = DataThreadType.PlaytimeEffectThreadData;

                ExpireTime = expireTime;
            }
        }

        #endregion

        #endregion

        #region PluginIO

        #region ConfigManage

        private PluginConfig config;

        private new void LoadConfig()
        {
            config = Config.ReadObject<PluginConfig>();

            if (config == null)
                config = GetDefaultConfig();

            VersionUpdate(config);
        }

        private void VersionUpdate(PluginConfig config)
        {
            if (config.ConfigVersion < new VersionNumber(1, 0, 5))
            {
                config.UIPosions = GetUIPosionConfig();
            }

            if (config.ConfigVersion < this.Version)
            {
                config.ConfigVersion = this.Version;
                Config.WriteObject(config, true);
                Puts("Config version has been updated");
            }
        }

        private class PluginConfig
        {
            public bool use_BroadCast;
            public bool use_Message;
            public bool use_ConsoleMessage;
            public int UIUpdateTimerInterval;
            public int TimeLimitTimerInterval;
            public int DisconnectDetectTimerInterval;
            public string EPSCommand;
            public string EffectCommand;
            public Dictionary<int, Posion> UIPosions;
            public class Posion
            {
                public float YAnchorMax;
                public float YAnchorMin;
                public float XAnchorMax;
                public float XAnchorMin;
            }
            public VersionNumber ConfigVersion;
        }

        private PluginConfig GetDefaultConfig()
        {
            PluginConfig pluginConfig = new PluginConfig
            {
                use_BroadCast = false,
                use_Message = true,
                use_ConsoleMessage = true,
                UIUpdateTimerInterval = 4,
                TimeLimitTimerInterval = 4,
                DisconnectDetectTimerInterval = 10,
                EPSCommand = "eps",
                EffectCommand = "effect",
                ConfigVersion = this.Version
            };
            pluginConfig.UIPosions = GetUIPosionConfig();
            return pluginConfig;
        }

        private Dictionary<int, PluginConfig.Posion> GetUIPosionConfig()
        {
            return new Dictionary<int, PluginConfig.Posion>
            {
                {
                    10,
                    new PluginConfig.Posion()
                    {
                        YAnchorMax = 0.11f,
                        YAnchorMin = 0.11f,
                        XAnchorMax = 0.6395f,
                        XAnchorMin = 0.3445f
                    }
                },
                {
                    8,
                    new PluginConfig.Posion()
                    {
                        YAnchorMax = 0.11f,
                        YAnchorMin = 0.11f,
                        XAnchorMax = 0.6105f,
                        XAnchorMin = 0.375f
                    }
                },
                {
                    6,
                    new PluginConfig.Posion()
                    {
                        YAnchorMax = 0.11f,
                        YAnchorMin = 0.11f,
                        XAnchorMax = 0.5825f,
                        XAnchorMin = 0.4056f
                    }
                }
            };
        }

        #endregion

        #region DataManage

        #region PlayersData

        DynamicConfigFile playersdataFile = Interface.Oxide.DataFileSystem.GetDatafile("PermissionEffects/PlayerData");
        PlayersData playersData;

        private void LoadPlayersData()
        {
            playersData = playersdataFile.ReadObject<PlayersData>();

            if (playersData == null)
                playersData = new PlayersData();
        }

        private void SavePlayersData()
        {
            playersdataFile.WriteObject(playersData);
        }

        private class PlayersData
        {
            public Dictionary<string, PlayerInfo> Players { get; set; }

            public PlayersData()
            {
                Players = new Dictionary<string, PlayerInfo>();
            }

            public void ResetData(IPlayer player)
            {
                foreach (var item in Players)
                {
                    foreach (var EffectThread in item.Value.PlayerEffectThreads)
                    {
                        EffectThread.Value.RevokeUserPermissions(item.Value.Id);
                    }
                }
                Players.Clear();
                Plugin.UpdatePlayersGUI();
                Plugin.SendReplyMessage(player, Plugin.Lang("Reseted PlayersData", player?.Id));
            }

            public void UpdatePlayers()
            {
                List<string> ClonedUsersKey = new List<string>();
                foreach (var item in Players)
                {
                    ClonedUsersKey.Add(item.Key);
                }

                foreach (var item in ClonedUsersKey)
                {
                    Players[item].UpdateEffects();
                }
            }

            public void AddEffectToPlayer(IPlayer target, IPlayer player, string EffectThreadName)
            {
                if (Players.ContainsKey(target.Id) == false)
                {
                    Players.Add(target.Id, new PlayerInfo(target));
                }

                Players[target.Id].AddEffect(EffectThreadName, player);
            }

            public void DeleteEffectFromPlayer(IPlayer target, IPlayer player, string EffectThreadName)
            {
                if (Players.ContainsKey(target.Id) == false)
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("Effect Is Not Exist On Player", player?.Id, EffectThreadName));

                    return;
                }

                Players[target.Id].DeleteEffect(EffectThreadName, player);
            }

            public void DeleteEffectFromPlayer(string target, IPlayer player, string EffectThreadName)
            {
                if (Players.ContainsKey(target) == false)
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("Effect Is Not Exist On Player", player?.Id, EffectThreadName));

                    return;
                }

                Players[target].DeleteEffect(EffectThreadName, player);
            }

            public void DeleteAllEffectFromPlayer(IPlayer target, IPlayer player)
            {
                if (Players.ContainsKey(target.Id) == false)
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("Effect Is Not Exist On Player", player?.Id, "All"));

                    return;
                }

                Players[target.Id].DeleteAllEffect(player);
            }

            public bool PlayerHasEffect(string playerId, string effectThreadName)
            {
                if (playerId.IsSteamId() == false)
                {
                    return false;
                }
                if (Players.ContainsKey(playerId) == false)
                {
                    return false;
                }

                PlayerInfo playerInfo = Players[playerId];

                if (playerInfo.PlayerEffectThreads.ContainsKey(effectThreadName))
                {
                    if (playerInfo.PlayerEffectThreads[effectThreadName].PlayerThreadType == PlayerThreadType.PlaytimeEffectThread && Plugin.PlaytimeTracker == null)
                    {
                        return false;
                    }
                    else
                    {
                        return true;
                    }
                }
                else
                {
                    foreach (string Groupname in Plugin.permission.GetUserGroups(playerId))
                    {
                        if (Plugin.groupsData.GroupHasEffect(Groupname, effectThreadName) == true)
                        {
                            return true;
                        }
                    }
                    return false;
                }
            }

            public TimeSpan? GetPlayerEffectLeftTime(string playerId, string effectThreadName)
            {
                if (Players.ContainsKey(playerId) == false)
                {
                    return null;
                }

                PlayerInfo playerInfo = Players[playerId];

                TimeSpan EffectLeftTime = new TimeSpan(0, 0, 0);

                if (playerInfo.PlayerEffectThreads.ContainsKey(effectThreadName))
                {
                    BasePlayerEffectThread baseEffectThread = playerInfo.PlayerEffectThreads[effectThreadName];

                    switch (baseEffectThread.PlayerThreadType)
                    {
                        case PlayerThreadType.EffectThread:
                            EffectLeftTime = TimeSpan.FromSeconds(-1);
                            break;

                        case PlayerThreadType.RealtimeEffectThread:
                            EffectLeftTime = baseEffectThread.ExpireDate.Subtract(DateTime.Now);
                            break;

                        case PlayerThreadType.PlaytimeEffectThread:
                            TimeSpan? PlayerPlaytime = Plugin.GetPlayerPlaytime(playerId);
                            if (PlayerPlaytime == null)
                            {
                                break;
                            }

                            EffectLeftTime = baseEffectThread.ExpireTime - (TimeSpan)PlayerPlaytime;
                            break;

                        default:
                            break;
                    }
                }

                string[] userGroups = Plugin.permission.GetUserGroups(playerId);

                if (userGroups.Length == 0)
                {
                    return EffectLeftTime;
                }

                foreach (string Groupname in userGroups)
                {
                    if (Plugin.groupsData.Groups.ContainsKey(Groupname) == false)
                        continue;

                    var Group = Plugin.groupsData.Groups[Groupname];

                    if (Group.PlayerEffectThreads.ContainsKey(effectThreadName))
                    {
                        BasePlayerEffectThread baseEffectThread = Group.PlayerEffectThreads[effectThreadName];

                        switch (baseEffectThread.PlayerThreadType)
                        {
                            case PlayerThreadType.EffectThread:
                                if (TimeSpan.FromSeconds(-1) > EffectLeftTime)
                                    EffectLeftTime = TimeSpan.FromSeconds(-1);
                                return EffectLeftTime;

                            case PlayerThreadType.RealtimeEffectThread:
                                TimeSpan LeftTime = baseEffectThread.ExpireDate.Subtract(DateTime.Now);
                                if (LeftTime > EffectLeftTime)
                                    EffectLeftTime = LeftTime;
                                return EffectLeftTime;

                            default:
                                break;
                        }
                    }
                }
                return null;
            }
        }

        private class PlayerInfo
        {
            public string Id { get; set; }
            public string Name { get; set; }
            public Dictionary<string, BasePlayerEffectThread> PlayerEffectThreads { get; set; }

            public PlayerInfo() { }

            public PlayerInfo(IPlayer player)
            {
                Id = player.Id;
                Name = player.Name;
                PlayerEffectThreads = new Dictionary<string, BasePlayerEffectThread>();
            }

            public void UpdateEffects()
            {
                List<BasePlayerEffectThread> DeleteThreads = new List<BasePlayerEffectThread>();
                var PlayerEffectThreadsList = PlayerEffectThreads.ToList();

                for (int j = 0; j < PlayerEffectThreadsList.Count; j++)
                {
                    BasePlayerEffectThread effectThread = PlayerEffectThreadsList[j].Value;

                    switch (effectThread.PlayerThreadType)
                    {
                        case PlayerThreadType.EffectThread:
                            break;

                        case PlayerThreadType.RealtimeEffectThread:
                            DateTime dt = effectThread.ExpireDate;
                            DateTime dtnow = DateTime.Now;

                            if (DateTime.Compare(dt, dtnow) <= 0)
                            {
                                DeleteThreads.Add(effectThread);
                            }
                            break;

                        case PlayerThreadType.PlaytimeEffectThread:
                            if (Plugin.PlaytimeTracker == null)
                            {
                                break;
                            }
                            TimeSpan? PlayerPlaytime = Plugin.GetPlayerPlaytime(Id);
                            if (PlayerPlaytime != null && PlayerPlaytime > effectThread.ExpireTime)
                            {
                                DeleteThreads.Add(effectThread);
                            }
                            break;

                        default:
                            break;
                    }
                }

                foreach (var item in DeleteThreads)
                {
                    DeleteEffect(item.ThreadName, null);
                }
            }

            public void UpdateEffect(string EffectName)
            {
                if (PlayerEffectThreads.ContainsKey(EffectName) == false)
                    return;

                BasePlayerEffectThread effectThread = PlayerEffectThreads[EffectName];

                switch (effectThread.PlayerThreadType)
                {
                    case PlayerThreadType.EffectThread:
                        break;

                    case PlayerThreadType.RealtimeEffectThread:
                        DateTime dt = effectThread.ExpireDate;
                        DateTime dtnow = DateTime.Now;

                        if (DateTime.Compare(dt, dtnow) <= 0)
                        {
                            DeleteEffect(EffectName, null);
                        }
                        break;

                    case PlayerThreadType.PlaytimeEffectThread:
                        if (Plugin.PlaytimeTracker == null)
                        {
                            break;
                        }
                        TimeSpan? PlayerPlaytime = Plugin.GetPlayerPlaytime(Id);
                        if (PlayerPlaytime != null && PlayerPlaytime > effectThread.ExpireTime)
                        {
                            DeleteEffect(EffectName, null);
                        }
                        break;

                    default:
                        break;
                }
            }

            public void AddEffect(string EffectThreadName, IPlayer player)
            {
                if (Plugin.registeredThreads.DataEffectThreads.ContainsKey(EffectThreadName))
                {
                    if (PlayerEffectThreads.ContainsKey(EffectThreadName))
                    {
                        BaseDataEffectThread regeffectThread = Plugin.registeredThreads.DataEffectThreads[EffectThreadName];
                        if (regeffectThread.DataThreadType == DataThreadType.PlaytimeEffectThreadData && Plugin.PlaytimeTracker == null)
                        {
                            Plugin.SendChatMessage(player, Plugin.Lang("PlaytimeTracker not Found", player?.Id));
                            return;
                        }
                        BasePlayerEffectThread effectThread = regeffectThread.ToPlayerEffectThread(Id);

                        PlayerEffectThreads[EffectThreadName] = effectThread;
                        effectThread.GrantUserPermissions(Id);

                        Plugin.SendReplyMessage(player, Plugin.Lang("EffectOverwrittedConsoleNotice", player?.Id, EffectThreadName, Name));
                        Plugin.SendChatMessage(Plugin.GetPlayer(Id), Plugin.Lang("EffectOverwrittedNotice", player?.Id, EffectThreadName));
                        Plugin.SendBroadcastMessage(Plugin.Lang("EffectOverwrittedConsoleNotice", player?.Id, EffectThreadName, Name));
                    }
                    else
                    {
                        BaseDataEffectThread regeffectThread = Plugin.registeredThreads.DataEffectThreads[EffectThreadName];
                        if (regeffectThread.DataThreadType == DataThreadType.PlaytimeEffectThreadData && Plugin.PlaytimeTracker == null)
                        {
                            Plugin.SendChatMessage(player, Plugin.Lang("PlaytimeTracker not Found", player?.Id));
                            return;
                        }
                        BasePlayerEffectThread effectThread = regeffectThread.ToPlayerEffectThread(Id);

                        PlayerEffectThreads.Add(EffectThreadName, effectThread);
                        effectThread.GrantUserPermissions(Id);

                        Plugin.SendReplyMessage(player, Plugin.Lang("EffectAddedConsoleNotice", player?.Id, EffectThreadName, Name));
                        Plugin.SendChatMessage(Plugin.GetPlayer(Id), Plugin.Lang("EffectAddedNotice", player?.Id, EffectThreadName));
                        Plugin.SendBroadcastMessage(Plugin.Lang("EffectAddedConsoleNotice", player?.Id, EffectThreadName, Name));
                    }

                    Plugin.UpdatePlayerGUI(Id);
                }
                else
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("Effect Is Not Exist", player?.Id, EffectThreadName));
                }
            }

            public void DeleteEffect(string EffectThreadName, IPlayer player)
            {
                if (PlayerEffectThreads.ContainsKey(EffectThreadName))
                {
                    PlayerEffectThreads[EffectThreadName].RevokeUserPermissions(Id, PlayerEffectThreads);
                    PlayerEffectThreads.Remove(EffectThreadName);

                    Plugin.SendReplyMessage(player, Plugin.Lang("EffectRemovedConsoleNotice", player?.Id, EffectThreadName, Name));
                    Plugin.SendChatMessage(Plugin.GetPlayer(Id), Plugin.Lang("EffectRemovedNotice", player?.Id, EffectThreadName));
                    Plugin.SendBroadcastMessage(Plugin.Lang("EffectRemovedConsoleNotice", player?.Id, EffectThreadName, Name));

                    Plugin.UpdatePlayersGUI();
                    if (PlayerEffectThreads.Count == 0)
                    {
                        Plugin.playersData.Players.Remove(Id);
                    }
                }
                else
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("Effect Is Not Exist On Player", player?.Id, EffectThreadName));
                }
            }

            public void DeleteAllEffect(IPlayer player)
            {
                if (PlayerEffectThreads.Count == 0)
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("Effect Is Not Exist On Player", player?.Id, "All"));
                    return;
                }
                else
                {
                    foreach (var item in PlayerEffectThreads)
                    {
                        item.Value.RevokeUserPermissions(Id);
                    }
                    Plugin.playersData.Players.Remove(Id);

                    Plugin.SendReplyMessage(player, Plugin.Lang("EffectRemovedConsoleNotice", player?.Id, "All", Name));
                    Plugin.SendChatMessage(Plugin.GetPlayer(Id), Plugin.Lang("EffectRemovedNotice", player?.Id, "All"));
                    Plugin.SendBroadcastMessage(Plugin.Lang("EffectRemovedConsoleNotice", player?.Id, "All", Name));

                    Plugin.UpdatePlayerGUI(Id);
                }
            }
        }

        #endregion

        #region GroupsData

        DynamicConfigFile groupsdataFile = Interface.Oxide.DataFileSystem.GetDatafile("PermissionEffects/GroupData");
        GroupsData groupsData;

        private void LoadGroupsData()
        {
            groupsData = groupsdataFile.ReadObject<GroupsData>();

            if (groupsData == null)
                groupsData = new GroupsData();
        }

        private void SaveGroupsData()
        {
            groupsdataFile.WriteObject(groupsData);
        }

        private class GroupsData
        {
            public Dictionary<string, GroupInfo> Groups { get; set; }

            public GroupsData()
            {
                Groups = new Dictionary<string, GroupInfo>();
            }

            public void ResetData(IPlayer player)
            {
                foreach (var item in Groups)
                {
                    foreach (var EffectThread in item.Value.PlayerEffectThreads)
                    {
                        EffectThread.Value.RevokeGroupPermissions(item.Value.GroupName);
                    }
                }
                Groups.Clear();
                Plugin.UpdatePlayersGUI();
                Plugin.SendReplyMessage(player, Plugin.Lang("Reseted GroupsData", player?.Id));
            }

            public void UpdateGroup()
            {
                List<string> ClonedGroupKey = new List<string>();
                foreach (var item in Groups)
                {
                    ClonedGroupKey.Add(item.Key);
                }

                var permissionGroups = Plugin.permission.GetGroups();

                foreach (var item in ClonedGroupKey)
                {
                    Groups[item].UpdateEffects();
                }

                foreach (var item in ClonedGroupKey)
                {
                    if (permissionGroups.Contains(item) == false)
                    {
                        if (Groups.ContainsKey(item))
                            Groups.Remove(item);
                    }
                }
            }

            public void AddEffectToGroup(string GroupName, IPlayer player, string EffectThreadName)
            {
                if (Plugin.permission.GroupExists(GroupName) == false)
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("GroupNotExist", player?.Id, GroupName));

                    return;
                }

                if (Groups.ContainsKey(GroupName) == false)
                {
                    Groups.Add(GroupName, new GroupInfo(GroupName));
                }

                Groups[GroupName].AddEffect(EffectThreadName, player);
            }

            public void DeleteEffectFromGroup(string GroupName, IPlayer player, string EffectThreadName)
            {
                if (Plugin.permission.GroupExists(GroupName) == false)
                {
                    Groups.Remove(GroupName);
                }

                if (Groups.ContainsKey(GroupName) == false)
                {
                    return;
                }

                Groups[GroupName].DeleteEffect(EffectThreadName, player);
            }

            public void DeleteAllEffectFromGroup(string GroupName, IPlayer player)
            {
                if (Groups.ContainsKey(GroupName) == false)
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("GroupNotExist", player?.Id, GroupName));

                    return;
                }

                Groups[GroupName].DeleteAllEffect(player);
            }

            public bool GroupHasEffect(string groupName, string effectThreadName)
            {
                if (Groups.ContainsKey(groupName) == false)
                {
                    return false;
                }

                GroupInfo groupInfo = Groups[groupName];

                if (groupInfo.PlayerEffectThreads.ContainsKey(effectThreadName))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }

            public TimeSpan? GetGroupEffectLeftTime(string groupName, string effectThreadName)
            {
                if (Plugin.groupsData.Groups.ContainsKey(groupName) == false)
                    return null;

                var Group = Plugin.groupsData.Groups[groupName];

                if (Group.PlayerEffectThreads.ContainsKey(effectThreadName))
                {
                    BasePlayerEffectThread baseEffectThread = Group.PlayerEffectThreads[effectThreadName];

                    switch (baseEffectThread.PlayerThreadType)
                    {
                        case PlayerThreadType.EffectThread:
                            return TimeSpan.FromSeconds(-1);

                        case PlayerThreadType.RealtimeEffectThread:
                            TimeSpan LeftTime = baseEffectThread.ExpireDate.Subtract(DateTime.Now);
                            return LeftTime;

                        default:
                            break;
                    }
                }

                return null;
            }
        }

        private class GroupInfo
        {
            public string GroupName { get; set; }
            public Dictionary<string, BasePlayerEffectThread> PlayerEffectThreads { get; set; }

            public GroupInfo() { }

            public GroupInfo(string groupName)
            {
                GroupName = groupName;
                PlayerEffectThreads = new Dictionary<string, BasePlayerEffectThread>();
            }

            public void UpdateEffects()
            {
                List<BasePlayerEffectThread> DeleteThreads = new List<BasePlayerEffectThread>();
                var PlayerEffectThreadsList = PlayerEffectThreads.ToList();

                for (int j = 0; j < PlayerEffectThreadsList.Count; j++)
                {
                    BasePlayerEffectThread effectThread = PlayerEffectThreadsList[j].Value;

                    switch (effectThread.PlayerThreadType)
                    {
                        case PlayerThreadType.EffectThread:
                            break;

                        case PlayerThreadType.RealtimeEffectThread:
                            DateTime dt = effectThread.ExpireDate;
                            DateTime dtnow = DateTime.Now;

                            if (DateTime.Compare(dt, dtnow) <= 0)
                            {
                                DeleteThreads.Add(effectThread);
                            }
                            break;

                        default:
                            break;
                    }
                }

                foreach (var item in DeleteThreads)
                {
                    DeleteEffect(item.ThreadName, null);
                }
            }

            public void UpdateEffect(string EffectName)
            {
                if (PlayerEffectThreads.ContainsKey(EffectName) == false)
                    return;

                BasePlayerEffectThread effectThread = PlayerEffectThreads[EffectName];

                switch (effectThread.PlayerThreadType)
                {
                    case PlayerThreadType.EffectThread:
                        break;

                    case PlayerThreadType.RealtimeEffectThread:
                        DateTime dt = effectThread.ExpireDate;
                        DateTime dtnow = DateTime.Now;

                        if (DateTime.Compare(dt, dtnow) <= 0)
                        {
                            DeleteEffect(EffectName, null);
                        }
                        break;

                    default:
                        break;
                }
            }

            public void AddEffect(string EffectThreadName, IPlayer player)
            {
                if (Plugin.registeredThreads.DataEffectThreads.ContainsKey(EffectThreadName))
                {
                    if (PlayerEffectThreads.ContainsKey(EffectThreadName))
                    {
                        BaseDataEffectThread regeffectThread = Plugin.registeredThreads.DataEffectThreads[EffectThreadName];
                        if (regeffectThread.DataThreadType == DataThreadType.PlaytimeEffectThreadData)
                        {
                            Plugin.SendReplyMessage(player, Plugin.Lang("CantAddPlaytimeEffectToGroup", player?.Id));
                            return;
                        }
                        BasePlayerEffectThread effectThread = regeffectThread.ToPlayerEffectThread(null);

                        PlayerEffectThreads[EffectThreadName] = effectThread;
                        effectThread.GrantGroupPermissions(GroupName);

                        Plugin.SendReplyMessage(player, Plugin.Lang("EffectOverwrittedConsoleNoticeGroup", player?.Id, EffectThreadName, GroupName));
                        Plugin.SendBroadcastMessage(Plugin.Lang("EffectOverwrittedConsoleNoticeGroup", player?.Id, EffectThreadName, GroupName));
                    }
                    else
                    {
                        BaseDataEffectThread regeffectThread = Plugin.registeredThreads.DataEffectThreads[EffectThreadName];
                        if (regeffectThread.DataThreadType == DataThreadType.PlaytimeEffectThreadData)
                        {
                            Plugin.SendReplyMessage(player, Plugin.Lang("CantAddPlaytimeEffectToGroup", player?.Id));
                            return;
                        }
                        BasePlayerEffectThread effectThread = regeffectThread.ToPlayerEffectThread(null);

                        PlayerEffectThreads.Add(EffectThreadName, effectThread);
                        effectThread.GrantGroupPermissions(GroupName);

                        Plugin.SendReplyMessage(player, Plugin.Lang("EffectAddedConsoleNoticeGroup", player?.Id, EffectThreadName, GroupName));
                        Plugin.SendBroadcastMessage(Plugin.Lang("EffectAddedConsoleNoticeGroup", player?.Id, EffectThreadName, GroupName));
                    }

                    Plugin.UpdatePlayersGUI();
                }
                else
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("Effect Is Not Exist", player?.Id, EffectThreadName));
                }
            }

            public void DeleteEffect(string EffectThreadName, IPlayer player)
            {
                if (PlayerEffectThreads.ContainsKey(EffectThreadName))
                {
                    PlayerEffectThreads[EffectThreadName].RevokeGroupPermissions(GroupName, PlayerEffectThreads);
                    PlayerEffectThreads.Remove(EffectThreadName);
                    if (PlayerEffectThreads.Count == 0)
                    {
                        Plugin.groupsData.Groups.Remove(GroupName);
                    }

                    Plugin.SendReplyMessage(player, Plugin.Lang("EffectRemovedConsoleNoticeGroup", player?.Id, EffectThreadName, GroupName));
                    Plugin.SendBroadcastMessage(Plugin.Lang("EffectRemovedConsoleNoticeGroup", player?.Id, EffectThreadName, GroupName));

                    Plugin.UpdatePlayersGUI();
                }
                else
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("Effect Is Not Exist On Group", player?.Id, EffectThreadName));
                }
            }

            public void DeleteAllEffect(IPlayer player)
            {
                if (PlayerEffectThreads.Count != 0)
                {
                    foreach (var item in PlayerEffectThreads)
                    {
                        item.Value.RevokeGroupPermissions(GroupName);
                    }
                    Plugin.groupsData.Groups.Remove(GroupName);

                    Plugin.SendReplyMessage(player, Plugin.Lang("EffectRemovedConsoleNoticeGroup", player?.Id, "All", GroupName));
                    Plugin.SendBroadcastMessage(Plugin.Lang("EffectRemovedConsoleNoticeGroup", player?.Id, "All", GroupName));

                    Plugin.UpdatePlayersGUI();
                }
                else
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("Effect Is Not Exist On Group", player?.Id, "All"));
                }
            }
        }

        #endregion

        #region ThreadsData

        DynamicConfigFile threadsdataFile = Interface.Oxide.DataFileSystem.GetDatafile("PermissionEffects/Threads");
        RegisteredThreads registeredThreads;

        private void LoadThreadsData()
        {
            registeredThreads = threadsdataFile.ReadObject<RegisteredThreads>();

            if (registeredThreads == null)
                registeredThreads = new RegisteredThreads();
        }

        private void SaveThreadsData()
        {
            threadsdataFile.WriteObject(registeredThreads);
        }

        private class RegisteredThreads
        {
            public Dictionary<string, BaseDataEffectThread> DataEffectThreads { get; set; }

            public RegisteredThreads()
            {
                DataEffectThreads = new Dictionary<string, BaseDataEffectThread>();
            }

            public void RegisterThread(BaseDataEffectThread dataEffectThread, IPlayer player)
            {
                dataEffectThread.Permissions = dataEffectThread.Permissions.Distinct().ToList();

                List<string> DeletePerms = new List<string>();

                foreach (var permission in dataEffectThread.Permissions)
                {
                    if (Plugin.permission.PermissionExists(permission) == false)
                        DeletePerms.Add(permission);
                }

                foreach (var DeletePerm in DeletePerms)
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("Permission Is Not Exist", player?.Id, DeletePerm));
                    dataEffectThread.Permissions.Remove(DeletePerm);
                }

                if (dataEffectThread.Permissions.Count == 0)
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("Permission Is Empty", player?.Id, dataEffectThread.ThreadName));
                }
                else if (DataEffectThreads.ContainsKey(dataEffectThread.ThreadName))
                {
                    DataEffectThreads[dataEffectThread.ThreadName] = dataEffectThread;
                    Plugin.SendReplyMessage(player, Plugin.Lang("OverwriteThread", player?.Id, dataEffectThread.ThreadName));
                }
                else
                {
                    DataEffectThreads.Add(dataEffectThread.ThreadName, dataEffectThread);
                    Plugin.SendReplyMessage(player, Plugin.Lang("RegisterThread", player?.Id, dataEffectThread.ThreadName));
                }
            }

            public void UnRegisterThread(string effectThreadName, IPlayer player)
            {
                if (DataEffectThreads.ContainsKey(effectThreadName))
                {
                    DataEffectThreads.Remove(effectThreadName);
                    Plugin.SendReplyMessage(player, Plugin.Lang("UnregisterThread", player?.Id, effectThreadName));
                }
                else
                {
                    Plugin.SendReplyMessage(player, Plugin.Lang("Effect Is Not Exist", player?.Id, effectThreadName));
                }
            }

            public bool ThreadIsExist(string ThreadName)
            {
                if (DataEffectThreads.ContainsKey(ThreadName))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }

        #endregion

        #region PlayersGUIData

        DynamicConfigFile playersuidataFile = Interface.Oxide.DataFileSystem.GetDatafile("PermissionEffects/PlayerGUIData");
        PlayersGUIData playersUIData;

        private void LoadPlayersGUIData()
        {
            playersUIData = playersuidataFile.ReadObject<PlayersGUIData>();

            if (playersUIData == null)
                playersUIData = new PlayersGUIData();
        }

        private void SavePlayersGUIData()
        {
            playersuidataFile.WriteObject<PlayersGUIData>(playersUIData);
        }

        private class PlayersGUIData
        {
            public Dictionary<string, PlayerGUIInfo> Players = new Dictionary<string, PlayerGUIInfo>();

            public PlayersGUIData()
            {

            }

            public void ResetPlayerData(BasePlayer player)
            {
                if (!Players.ContainsKey(player.UserIDString))
                {
                    Players.Add(player.UserIDString, new PlayerGUIInfo(player.IPlayer));
                }
            }

            public void ResetOnlinePlayersData()
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    ResetPlayerData(player);
                }
            }
        }

        private class PlayerGUIInfo
        {
            public string Id;
            public string Name;
            public bool useUI = true;
            public int EffectPage = 0;

            public PlayerGUIInfo()
            {

            }

            public PlayerGUIInfo(IPlayer player)
            {
                Id = player.Id;
                Name = player.Name;
            }
        }

        #endregion

        #endregion

        #region LangManage

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "You do not have permission to use the '{0}' command.",
                ["SteamID Not Found"] = "Could not find this SteamID: {0}.",
                ["Player Not Found"] = "Could not find this player: {0}.",
                ["Multiple Players Found"] = "Found multiple players!\n\n{0}",

                ["PlaytimeTracker not Found"] = "PlaytimeTracker is not Loaded",

                ["RegisterThread"] = "Thread '{0}' is Registered",
                ["OverwriteThread"] = "Thread '{0}' is Overwritted",
                ["UnregisterThread"] = "Thread '{0}' is UnRegistered",

                ["RegisterThreadPlaytime"] = "Thread '{0}' is Registered Time Based On Playtime",
                ["OverwriteThreadPlaytime"] = "Thread '{0}' is Overwritted Time Based On Playtime",

                ["EffectAddedConsoleNotice"] = "Effect '{0}' is Added to {1}",
                ["EffectOverwrittedConsoleNotice"] = "Effect '{0}' is Overwritted to {1}",
                ["EffectRemovedConsoleNotice"] = "Effect '{0}' is Removed from {1}",

                ["EffectAddedConsoleNoticeGroup"] = "Effect '{0}' is Added to {1} Group",
                ["EffectOverwrittedConsoleNoticeGroup"] = "Effect '{0}' is Overwritted to {1} Group",
                ["EffectRemovedConsoleNoticeGroup"] = "Effect '{0}' is Removed from {1} Group",

                ["CantAddPlaytimeEffectToGroup"] = "Playtime-based effects cannot be added to the group",

                ["Effect Is Not Exist On Player"] = "Effect '{0}' is not exist on player!",
                ["Effect Is Not Exist On Group"] = "Effect '{0}' is not exist on group!",

                ["Reseted PlayersData"] = "Players Data has been initialized",
                ["Reseted GroupsData"] = "Groups Data has been initialized",

                ["EffectAddedNotice"] = "Effect '{0}' is Added",
                ["EffectOverwrittedNotice"] = "Effect '{0}' is Overwritted",
                ["EffectRemovedNotice"] = "Effect '{0}' is Removed",

                ["NotEnoughArgument"] = "to run this command you need {0} arguments, do /eps for more information.",
                ["Invalid Parameter"] = "'{0}' is an invalid parameter, do /eps for more information.",
                ["Effect Is Not Exist"] = "'{0}' is not exist effect.",
                ["Permission Is Not Exist"] = "'{0}' is not exist permission.",
                ["Permission Is Empty"] = "'{0}' Effect permission is Empty\n" +
                                      "Fail to Add Effect!",

                ["GroupNotExist"] = "{0} is not Exist Group",

                ["RegisteredDataList"] = "EPS Registered Threads\n" +
                                  "\n" +
                                  "{0}\n",

                ["RegisteredPermList"] = "{0}",

                ["RegisteredThreadList"] = "======================EffectThread\n" +
                                           "ThreadName : {0}\n" +
                                           "HexThreadColor : {1}\n" +
                                           "DisconnectAutoExpireTime : {2}\n" +
                                           "-----------Permissions\n" +
                                           "{3}\n" +
                                           "\n",
                ["RegisteredRtThreadList"] = "======================RealTImeEffectThread\n" +
                                           "ThreadName : {0}\n" +
                                           "HexThreadColor : {1}\n" +
                                           "DisconnectAutoExpireTime : {2}s\n" +
                                           "EffectTime : {3}s\n" +
                                           "-----------Permissions\n" +
                                           "{4}\n" +
                                           "\n",
                ["RegisteredPtThreadList"] = "======================PlayTimeEffectThread\n" +
                                           "ThreadName : {0}\n" +
                                           "HexThreadColor : {1}\n" +
                                           "DisconnectAutoExpireTime : {2}s\n" +
                                           "EffectTime : {3}s\n" +
                                           "-----------Permissions\n" +
                                           "{4}\n" +
                                           "\n",

                ["SingleThread"] = "{0} - {1}",
                ["SinglePlaytimeThread"] = "{0} - {1} playtime",

                ["PlayerThreads"] = "====================={0}\n" +
                                    "{1}\n" +
                                    "=======Contained In Group\n" +
                                    "{2}\n",

                ["PlayersThreadsHead"] = "Players EffectThreads\n",

                ["PlayerThreadsHead"] = "{0}'s EffectThreads\n",

                ["GroupsThreadsHead"] = "Groups EffectThreads\n",

                ["GroupThreads"] = "====================={0}\n" +
                                   "{1}\n",

                ["Data Is Empty"] = "no data",

                ["CommandHelp"] = "Permission Effects Commands\n" +
                                  "\n" +
                                  "---add effect to player/group\n" +
                                  "/eps add <user/group> <playername/groupname> <effectthread>\n" +
                                  "---remove effect from player/group\n" +
                                  "/eps remove <user/group> <playername/groupname> <effectthread>\n" +
                                  "---remove all effect from player/group\n" +
                                  "/eps removeall <user/group> <playername/groupname>\n" +
                                  "\n" +
                                  "---reset players/groups thread data\n" +
                                  "/eps reset <user/group/all>\n" +
                                  "---register thread\n" +
                                  "/eps thread add <threadname> <threadcolor> <permission1,permission2,...> <sec> <rt/pt> <DisconnExpireSec>\n" +
                                  "---unregister thread\n" +
                                  "/eps thread remove <threadname>\n" +
                                  "\n" +
                                  "---Check Registered Thread\n" +
                                  "/eps rlist\n" +
                                  "---Check Players Thread\n" +
                                  "/eps plist\n" +
                                  "---Check Groups Thread\n" +
                                  "/eps glist\n" +
                                  "---Check Player Thread\n" +
                                  "/eps pt <player>\n" +
                                  "---Check My Thread\n" +
                                  "/effect"
            }, this);
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        #endregion

        #region PermissionManage

        private void RegisterPermissions()
        {
            permission.RegisterPermission(permissioneffects_admin_perm_admin_perm, this);
        }

        #endregion

        #endregion

        #region TestEffectThreads

        private void RegisterTestEffects()
        {
            permission.RegisterPermission("permissioneffects.test", this);

            registeredThreads.RegisterThread(GetTestEffectRegThread(), null);
            registeredThreads.RegisterThread(GetTestEffect2RegThread(), null);
            registeredThreads.RegisterThread(GetTestEffect3RegThread(), null);
        }

        private EffectThreadData GetTestEffectRegThread()
        {
            string ThreadName = "TestThread";

            List<string> effectPermissions = new List<string>();
            effectPermissions.Add("permissioneffects.test");

            return new EffectThreadData(ThreadName, GetHexColor(Color.red), effectPermissions, null);
        }

        private PlaytimeEffectThreadData GetTestEffect2RegThread()
        {
            string ThreadName = "TestThread2";

            List<string> effectPermissions = new List<string>();
            effectPermissions.Add("permissioneffects.test");

            return new PlaytimeEffectThreadData(ThreadName, GetHexColor(Color.gray), effectPermissions, new TimeSpan(0, 3, 0), new TimeSpan(0, 10, 0));
        }

        private RealtimeEffectThreadData GetTestEffect3RegThread()
        {
            string ThreadName = "TestThread3";

            List<string> effectPermissions = new List<string>();
            effectPermissions.Add("permissioneffects.test");

            return new RealtimeEffectThreadData(ThreadName, GetHexColor(Color.green), effectPermissions, new TimeSpan(1, 0, 0), new TimeSpan(1, 0, 0));
        }

        #endregion

        #region TimerManager

        private void StartTimer()
        {
            timer.Every(config.TimeLimitTimerInterval, TimeLimitTimer_Tick);
            timer.Every(config.UIUpdateTimerInterval, UIUpdateTimer_Tick);
            timer.Every(config.DisconnectDetectTimerInterval, DisconnectDetectTimer_Tick);
        }

        private void TimeLimitTimer_Tick()
        {
            playersData.UpdatePlayers();
            groupsData.UpdateGroup();
        }

        private void UIUpdateTimer_Tick()
        {
            UpdatePlayersGUI();
        }

        private void DisconnectDetectTimer_Tick()
        {
            List<BasePlayer> BasePlayerList = BasePlayer.activePlayerList.ToList();

            var Playerslist = playersData.Players.ToList();

            for (int i = 0; i < Playerslist.Count; i++)
            {
                PlayerInfo playerInfo = Playerslist[i].Value;

                List<BasePlayerEffectThread> DeleteThreads = new List<BasePlayerEffectThread>();
                var PlayerEffectThreadsList = playerInfo.PlayerEffectThreads.ToList();

                for (int j = 0; j < playerInfo.PlayerEffectThreads.Count; j++)
                {
                    BasePlayerEffectThread effectThread = PlayerEffectThreadsList[j].Value;

                    if (effectThread.DisconnectAutoExpireTime != null)
                    {
                        if (PlayerIsOnline(playerInfo.Id) == true)
                        {
                            DateTime EffectDisconnectExpireTime = DateTime.Now;
                            TimeSpan timeSpan = (TimeSpan)effectThread.DisconnectAutoExpireTime;
                            EffectDisconnectExpireTime = EffectDisconnectExpireTime + timeSpan;
                            effectThread.DisconnectAutoExpireDate = EffectDisconnectExpireTime;
                        }
                        else
                        {
                            DateTime dt = effectThread.DisconnectAutoExpireDate;
                            if (DateTime.Compare(dt, DateTime.Now) <= 0)
                            {
                                DeleteThreads.Add(effectThread);
                            }
                        }
                    }
                }

                foreach (var item in DeleteThreads)
                {
                    playerInfo.DeleteEffect(item.ThreadName, null);
                }
            }
        }

        #endregion

        #region InterCommand

        #region GUI

        private void UpdatePlayerGUI(string Id)
        {
            UpdatePagePlayerUIInfo(GetPlayerFromID(Id));
        }

        private void UpdatePlayerGUI(BasePlayer player)
        {
            UpdatePagePlayerUIInfo(player);
        }

        private void UpdatePlayersGUI()
        {
            UpdateUIInfo();
        }

        private void UpdateUIInfo()
        {
            List<BasePlayer> BasePlayerList = BasePlayer.activePlayerList.ToList();

            foreach (var BPlayeritem in BasePlayerList)
            {
                if (playersUIData.Players.ContainsKey(BPlayeritem.UserIDString) == false)
                    continue;
                PlayerGUIInfo playerGUIInfo = playersUIData.Players[BPlayeritem.UserIDString];

                List<BasePlayerEffectThread> basePlayerEffectThreads = GetPlayerGUIData(BPlayeritem.UserIDString);
                if (basePlayerEffectThreads.Count == 0)
                    continue;
                List<BasePlayerEffectThread> DisplayEffectthread = new List<BasePlayerEffectThread>();
                bool UseUpPM = false;
                bool UseDownPM = false;

                if (basePlayerEffectThreads.Count - 3 < playerGUIInfo.EffectPage)
                {
                    if (basePlayerEffectThreads.Count <= 3)
                        playerGUIInfo.EffectPage = 0;
                    else
                        playerGUIInfo.EffectPage = basePlayerEffectThreads.Count - 3;
                }

                if (3 < basePlayerEffectThreads.Count)
                {
                    if (playerGUIInfo.EffectPage != basePlayerEffectThreads.Count - 3)
                    {
                        UseUpPM = true;
                    }
                    if (playerGUIInfo.EffectPage > 0)
                    {
                        UseDownPM = true;
                    }
                }

                for (int i = 0; i < 3; i++)
                {
                    if (basePlayerEffectThreads.Count == playerGUIInfo.EffectPage + i)
                        break;

                    DisplayEffectthread.Add(basePlayerEffectThreads[playerGUIInfo.EffectPage + i]);
                }

                BasePlayer BPlayer = GetPlayerFromID(BPlayeritem.UserIDString);
                if (BPlayer != null)
                    UpdateBaseUI(BPlayer, DisplayEffectthread, UseUpPM, UseDownPM);
            }
        }

        private void UpdatePagePlayerUIInfo(BasePlayer player)
        {
            if (playersUIData.Players.ContainsKey(player.UserIDString) == false)
                return;

            PlayerGUIInfo playerGUIInfo = playersUIData.Players[player.UserIDString];

            List<BasePlayerEffectThread> basePlayerEffectThreads = GetPlayerGUIData(player.UserIDString);
            List<BasePlayerEffectThread> DisplayEffectthread = new List<BasePlayerEffectThread>();

            bool UseUpPM = false;
            bool UseDownPM = false;

            if (basePlayerEffectThreads.Count - 3 < playerGUIInfo.EffectPage)
            {
                if (basePlayerEffectThreads.Count <= 3)
                    playerGUIInfo.EffectPage = 0;
                else
                    playerGUIInfo.EffectPage = basePlayerEffectThreads.Count - 3;
            }

            if (3 < basePlayerEffectThreads.Count)
            {
                if (playerGUIInfo.EffectPage != basePlayerEffectThreads.Count - 3)
                {
                    UseUpPM = true;
                }
                if (playerGUIInfo.EffectPage > 0)
                {
                    UseDownPM = true;
                }
            }

            var PlayerEffectThreadsList = basePlayerEffectThreads.ToList();

            for (int i = 0; i < 3; i++)
            {
                if (basePlayerEffectThreads.Count == playerGUIInfo.EffectPage + i)
                    break;

                DisplayEffectthread.Add(PlayerEffectThreadsList[playerGUIInfo.EffectPage + i]);
            }

            UpdateBaseUI(player, DisplayEffectthread, UseUpPM, UseDownPM);
        }

        private List<BasePlayerEffectThread> GetPlayerGUIData(string Id)
        {
            List<BasePlayerEffectThread> effectthreadUIs = new List<BasePlayerEffectThread>();

            if (playersData.Players.ContainsKey(Id))
            {
                PlayerInfo playerinfo = playersData.Players[Id];

                foreach (var effectthread in playerinfo.PlayerEffectThreads)
                {
                    effectthreadUIs.Add(effectthread.Value);
                }
            }
            foreach (var groupname in permission.GetUserGroups(Id))
            {
                if (groupsData.Groups.ContainsKey(groupname) == false)
                    continue;

                foreach (var effectthread in groupsData.Groups[groupname].PlayerEffectThreads)
                {
                    effectthreadUIs.Add(effectthread.Value);
                }
            }

            return effectthreadUIs.Distinct().ToList();
        }

        #endregion

        #region GetListString

        private string GetRegisteredThread(IPlayer player)
        {
            string effectthreads = "";

            if (registeredThreads.DataEffectThreads.Count == 0)
                effectthreads += Lang("no data", player?.Id);

            foreach (var Thread in registeredThreads.DataEffectThreads)
            {
                string TeffectPermissions = "";

                foreach (var PermissioniT in Thread.Value.Permissions)
                {
                    TeffectPermissions += Lang("RegisteredPermList", player?.Id, PermissioniT);
                }

                switch (Thread.Value.DataThreadType)
                {
                    case DataThreadType.EffectThreadData:
                        effectthreads += Lang("RegisteredThreadList", player?.Id, Thread.Value.ThreadName, Thread.Value.ThreadColor, Thread.Value.DisconnectAutoExpireTime?.TotalSeconds, TeffectPermissions);
                        break;

                    case DataThreadType.RealtimeEffectThreadData:
                        effectthreads += Lang("RegisteredRtThreadList", player?.Id, Thread.Value.ThreadName, Thread.Value.ThreadColor, Thread.Value.DisconnectAutoExpireTime?.TotalSeconds, Thread.Value.ExpireTime.TotalSeconds, TeffectPermissions);
                        break;

                    case DataThreadType.PlaytimeEffectThreadData:
                        effectthreads += Lang("RegisteredPtThreadList", player?.Id, Thread.Value.ThreadName, Thread.Value.ThreadColor, Thread.Value.DisconnectAutoExpireTime?.TotalSeconds, Thread.Value.ExpireTime.TotalSeconds, TeffectPermissions);
                        break;

                    default:
                        break;
                }
            }

            effectthreads = effectthreads.Substring(0, effectthreads.Length - 2);

            return Lang("RegisteredDataList", player?.Id, effectthreads);
        }

        private string GetPlayersThread(IPlayer player)
        {
            string playersThread = Lang("PlayersThreadsHead", player?.Id);

            if (playersData.Players.Count == 0)
                playersThread += Lang("no data", player?.Id);

            foreach (var playerinfo in playersData.Players)
            {
                bool hasgroupeffect = false;
                int hidecount = 0;
                if (playerinfo.Value.PlayerEffectThreads.Count == 0)
                    hidecount += 1;
                if (Plugin.permission.UserHasAnyGroup(playerinfo.Value.Id) == false)
                    hidecount += 2;

                string playerThread = "";

                foreach (var effectthread in playerinfo.Value.PlayerEffectThreads)
                {
                    string Lefttime;
                    TimeSpan LeftTime;

                    switch (effectthread.Value.PlayerThreadType)
                    {
                        case PlayerThreadType.EffectThread:
                            Lefttime = "-1";

                            playerThread += Lang("SingleThread", player?.Id, effectthread.Value.ThreadName, Lefttime) + "\n";
                            break;

                        case PlayerThreadType.RealtimeEffectThread:
                            DateTime dt = (effectthread.Value as RealtimeEffectThread).ExpireDate;

                            LeftTime = dt.Subtract(DateTime.Now);
                            Lefttime = LeftTime.ToString();

                            playerThread += Lang("SingleThread", player?.Id, effectthread.Value.ThreadName, Lefttime) + "\n";
                            break;

                        case PlayerThreadType.PlaytimeEffectThread:
                            TimeSpan? PlayerPlaytime = Plugin.GetPlayerPlaytime(playerinfo.Value.Id);

                            if (PlayerPlaytime == null)
                                Lefttime = "Error";
                            else
                            {
                                LeftTime = effectthread.Value.ExpireTime - (TimeSpan)PlayerPlaytime;
                                Lefttime = LeftTime.ToString();
                            }


                            playerThread += Lang("SinglePlaytimeThread", player?.Id, effectthread.Value.ThreadName, Lefttime) + "\n";
                            break;

                        default:
                            Lefttime = "-1";

                            playerThread += Lang("SingleThread", player?.Id, effectthread.Value.ThreadName, Lefttime) + "\n";
                            break;
                    }
                }

                string playerGroupThread = "";
                if (Plugin.permission.UserHasAnyGroup(playerinfo.Value.Id) == false)
                    playerGroupThread += Lang("no data", player?.Id);

                foreach (var groupname in Plugin.permission.GetUserGroups(playerinfo.Value.Id))
                {
                    if (groupsData.Groups.ContainsKey(groupname) == false)
                        continue;

                    foreach (var effectthread in groupsData.Groups[groupname].PlayerEffectThreads)
                    {
                        hasgroupeffect = true;

                        string Lefttime;

                        switch (effectthread.Value.PlayerThreadType)
                        {
                            case PlayerThreadType.EffectThread:
                                Lefttime = "-1";
                                break;

                            case PlayerThreadType.RealtimeEffectThread:
                                DateTime dt = (effectthread.Value as RealtimeEffectThread).ExpireDate;

                                TimeSpan LeftTime = dt.Subtract(DateTime.Now);
                                Lefttime = LeftTime.ToString();
                                break;

                            default:
                                Lefttime = "-1";
                                break;
                        }

                        playerGroupThread += Lang("SingleThread", player?.Id, effectthread.Value.ThreadName, Lefttime) + "\n";
                    }
                }

                if (hidecount == 3)
                    continue;
                if (hidecount == 1 && hasgroupeffect == false)
                    continue;

                playersThread += Lang("PlayerThreads", player?.Id, playerinfo.Value.Name, playerThread, playerGroupThread);
            }

            return playersThread;
        }

        private string GetPlayerThread(IPlayer player, IPlayer target)
        {
            string playerRThread = Lang("PlayerThreadsHead", player?.Id, target.Name);

            if (playersData.Players.ContainsKey(target.Id) == false)
                playerRThread += Lang("no data", player?.Id);
            else
            {
                PlayerInfo playerinfo = playersData.Players[target.Id];

                bool hasgroupeffect = false;
                int hidecount = 0;
                if (playerinfo.PlayerEffectThreads.Count == 0)
                    hidecount += 1;
                if (Plugin.permission.UserHasAnyGroup(playerinfo.Id) == false)
                    hidecount += 2;

                string playerThread = "";

                foreach (var effectthread in playerinfo.PlayerEffectThreads)
                {
                    string Lefttime;
                    TimeSpan LeftTime;

                    switch (effectthread.Value.PlayerThreadType)
                    {
                        case PlayerThreadType.EffectThread:
                            Lefttime = "-1";

                            playerThread += Lang("SingleThread", player?.Id, effectthread.Value.ThreadName, Lefttime) + "\n";
                            break;

                        case PlayerThreadType.RealtimeEffectThread:
                            DateTime dt = (effectthread.Value as RealtimeEffectThread).ExpireDate;

                            LeftTime = dt.Subtract(DateTime.Now);
                            Lefttime = LeftTime.ToString();

                            playerThread += Lang("SingleThread", player?.Id, effectthread.Value.ThreadName, Lefttime) + "\n";
                            break;

                        case PlayerThreadType.PlaytimeEffectThread:
                            TimeSpan? PlayerPlaytime = Plugin.GetPlayerPlaytime(playerinfo.Id);

                            if (PlayerPlaytime == null)
                                Lefttime = "Error";
                            else
                            {
                                LeftTime = effectthread.Value.ExpireTime - (TimeSpan)PlayerPlaytime;
                                Lefttime = LeftTime.ToString();
                            }

                            playerThread += Lang("SinglePlaytimeThread", player?.Id, effectthread.Value.ThreadName, Lefttime) + "\n";
                            break;

                        default:
                            Lefttime = "-1";

                            playerThread += Lang("SingleThread", player?.Id, effectthread.Value.ThreadName, Lefttime) + "\n";
                            break;
                    }
                }

                string playerGroupThread = "";
                if (Plugin.permission.UserHasAnyGroup(playerinfo.Id) == false)
                    playerGroupThread += Lang("no data", player?.Id);

                foreach (var groupname in Plugin.permission.GetUserGroups(playerinfo.Id))
                {
                    if (groupsData.Groups.ContainsKey(groupname) == false)
                        continue;
                    foreach (var effectthread in groupsData.Groups[groupname].PlayerEffectThreads)
                    {
                        hasgroupeffect = true;

                        string Lefttime;

                        switch (effectthread.Value.PlayerThreadType)
                        {
                            case PlayerThreadType.EffectThread:
                                Lefttime = "-1";
                                break;

                            case PlayerThreadType.RealtimeEffectThread:
                                DateTime dt = effectthread.Value.ExpireDate;

                                TimeSpan LeftTime = dt.Subtract(DateTime.Now);
                                Lefttime = LeftTime.ToString();
                                break;

                            default:
                                Lefttime = "-1";
                                break;
                        }

                        playerGroupThread += Lang("SingleThread", player?.Id, effectthread.Value.ThreadName, Lefttime) + "\n";
                    }
                }

                if (hidecount == 3)
                {
                    playerRThread = Lang("no data", player?.Id);
                    return playerRThread;
                }
                if (hidecount == 1 && hasgroupeffect == false)
                {
                    playerRThread = Lang("no data", player?.Id);
                    return playerRThread;
                }

                playerRThread += Lang("PlayerThreads", player?.Id, playerinfo.Name, playerThread, playerGroupThread);
                return playerRThread;
            }

            return playerRThread;
        }

        private string GetGroupThread(IPlayer player)
        {
            string GroupsThread = Lang("GroupsThreadsHead", player?.Id);

            if (groupsData.Groups.Count == 0)
                return GroupsThread += Lang("no data", player?.Id);

            foreach (var groupinfo in groupsData.Groups)
            {
                string GroupThread = "";

                if (groupinfo.Value.PlayerEffectThreads.Count == 0)
                    GroupThread += Lang("no data", player?.Id);

                foreach (var effectthread in groupsData.Groups[groupinfo.Value.GroupName].PlayerEffectThreads)
                {
                    string Lefttime;

                    switch (effectthread.Value.PlayerThreadType)
                    {
                        case PlayerThreadType.EffectThread:
                            Lefttime = "-1";
                            break;

                        case PlayerThreadType.RealtimeEffectThread:
                            DateTime dt = (effectthread.Value as RealtimeEffectThread).ExpireDate;

                            TimeSpan LeftTime = dt.Subtract(DateTime.Now);
                            Lefttime = LeftTime.ToString();
                            break;

                        default:
                            Lefttime = "-1";
                            break;
                    }

                    GroupThread += Lang("SingleThread", player?.Id, effectthread.Value.ThreadName, Lefttime) + "\n";
                }

                GroupsThread += Lang("GroupThreads", player?.Id, groupinfo.Value.GroupName, GroupThread);
            }

            return GroupsThread;
        }

        #endregion

        #endregion

        #region Command

        void BasicCommand(IPlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                if (!player.HasPermission(permissioneffects_admin_perm_admin_perm) && !player.IsServer)
                {
                    SendReplyMessage(player, Lang("No Permission", player?.Id, command));
                    return;
                }
            }

            if (args.Length >= 1)
            {
                if (args[0].ToLower() == "add")
                {
                    if (args.Length >= 4)
                    {
                        if (args[1].ToLower() == "user")
                        {
                            IPlayer Tplayer = GetPlayer(args[2], player);

                            if (Tplayer == null)
                                return;

                            playersData.AddEffectToPlayer(Tplayer, player, args[3]);
                        }
                        if (args[1].ToLower() == "group")
                        {
                            groupsData.AddEffectToGroup(args[2], player, args[3]);
                        }
                    }
                    else
                    {
                        SendReplyMessage(player, Lang("NotEnoughArgument", player?.Id, 4.ToString()));
                    }
                }
                else if (args[0].ToLower() == "remove")
                {
                    if (args.Length >= 4)
                    {
                        if (args[1].ToLower() == "user")
                        {
                            IPlayer Tplayer = GetPlayer(args[2], player);

                            if (Tplayer == null)
                                return;

                            playersData.DeleteEffectFromPlayer(Tplayer.Id, player, args[3]);
                        }
                        if (args[1].ToLower() == "group")
                        {
                            groupsData.DeleteEffectFromGroup(args[2], player, args[3]);
                        }
                    }
                    else
                    {
                        SendReplyMessage(player, Lang("NotEnoughArgument", player?.Id, 4.ToString()));
                    }
                }
                else if (args[0].ToLower() == "removeall")
                {
                    if (args.Length >= 3)
                    {
                        if (args[1].ToLower() == "user")
                        {
                            IPlayer Tplayer = GetPlayer(args[2], player);

                            if (Tplayer == null)
                                return;

                            playersData.DeleteAllEffectFromPlayer(Tplayer, player);
                        }
                        else if (args[1].ToLower() == "group")
                        {
                            groupsData.DeleteAllEffectFromGroup(args[2], player);
                        }
                    }
                    else
                    {
                        SendReplyMessage(player, Lang("NotEnoughArgument", player?.Id, 3.ToString()));
                    }
                }
                else if (args[0].ToLower() == "reset")
                {
                    if (args.Length >= 2)
                    {
                        if (args[1].ToLower() == "user")
                        {
                            playersData.ResetData(player);
                        }
                        else if (args[1].ToLower() == "group")
                        {
                            groupsData.ResetData(player);
                        }
                        else if (args[1].ToLower() == "all")
                        {
                            playersData.ResetData(player);
                            groupsData.ResetData(player);
                        }
                    }
                    else
                    {
                        SendReplyMessage(player, Lang("NotEnoughArgument", player?.Id, 3.ToString()));
                    }
                }
                else if (args[0].ToLower() == "thread")
                {
                    if (args.Length >= 2)
                    {
                        if (args[1].ToLower() == "add")
                        {
                            if (args.Length >= 7)
                            {
                                if (args[6].ToLower() == "rt")
                                {
                                    int arg5i = 0;
                                    int arg7i = 0;
                                    if (int.TryParse(args[5], out arg5i) && int.TryParse(args[7], out arg7i))
                                    {
                                        string[] splitedperms = args[4].ToLower().Split(',');

                                        BaseDataEffectThread baseDataEffectThread;
                                        if (arg5i == 0)
                                            baseDataEffectThread = new EffectThreadData(args[2], GetHexColorFromFormat(args[3]), splitedperms.ToList(), (arg7i == 0) ? null : (TimeSpan?)TimeSpan.FromSeconds(arg7i));
                                        else
                                            baseDataEffectThread = new RealtimeEffectThreadData(args[2], GetHexColorFromFormat(args[3]), splitedperms.ToList(), (arg7i == 0) ? null : (TimeSpan?)TimeSpan.FromSeconds(arg7i), TimeSpan.FromSeconds(arg5i));

                                        registeredThreads.RegisterThread(baseDataEffectThread, player);
                                    }
                                    else
                                    {
                                        SendReplyMessage(player, Lang("Invalid Parameter", player?.Id, args[1]));
                                    }
                                }
                                else if (args[6].ToLower() == "pt")
                                {
                                    int arg5i = 0;
                                    int arg7i = 0;
                                    if (int.TryParse(args[5], out arg5i) && int.TryParse(args[7], out arg7i))
                                    {
                                        string[] splitedperms = args[4].ToLower().Split(',');

                                        BaseDataEffectThread baseDataEffectThread;
                                        if (arg5i == 0)
                                            baseDataEffectThread = new EffectThreadData(args[2], GetHexColorFromFormat(args[3]), splitedperms.ToList(), (arg7i == 0) ? null : (TimeSpan?)TimeSpan.FromSeconds(arg7i));
                                        else
                                            baseDataEffectThread = new PlaytimeEffectThreadData(args[2], GetHexColorFromFormat(args[3]), splitedperms.ToList(), (arg7i == 0) ? null : (TimeSpan?)TimeSpan.FromSeconds(arg7i), TimeSpan.FromSeconds(arg5i));

                                        registeredThreads.RegisterThread(baseDataEffectThread, player);
                                    }
                                    else
                                    {
                                        SendReplyMessage(player, Lang("Invalid Parameter", player?.Id, args[1]));
                                    }
                                }
                                else
                                {
                                    SendReplyMessage(player, Lang("Invalid Parameter", player?.Id, args[1]));
                                }
                            }
                            else
                            {
                                SendReplyMessage(player, Lang("NotEnoughArgument", player?.Id, 7.ToString()));
                            }
                        }
                        else if (args[1].ToLower() == "remove")
                        {
                            if (args.Length >= 3)
                            {
                                registeredThreads.UnRegisterThread(args[2], player);
                            }
                            else
                            {
                                SendReplyMessage(player, Lang("NotEnoughArgument", player?.Id, 3.ToString()));
                            }
                        }
                        else
                        {
                            SendReplyMessage(player, Lang("Invalid Parameter", player?.Id, args[1]));
                        }
                    }
                    else
                    {
                        SendReplyMessage(player, Lang("NotEnoughArgument", player?.Id, 2.ToString()));
                    }
                }
                else if (args[0] == "rlist")
                {
                    SendReplyMessage(player, GetRegisteredThread(player));
                }
                else if (args[0] == "plist")
                {
                    SendReplyMessage(player, GetPlayersThread(player));
                }
                else if (args[0] == "glist")
                {
                    SendReplyMessage(player, GetGroupThread(player));
                }
                else if (args[0] == "pt")
                {
                    if (args.Length >= 2)
                    {
                        IPlayer Tplayer = GetPlayer(args[1], player);

                        if (Tplayer == null)
                            return;

                        SendReplyMessage(player, GetPlayerThread(player, Tplayer));
                    }
                    else
                    {
                        SendReplyMessage(player, Lang("NotEnoughArgument", player?.Id, 2.ToString()));
                    }
                }
                else
                {
                    SendReplyMessage(player, Lang("Invalid Parameter", player?.Id, args[0]));
                }
            }
            else
            {
                SendReplyMessage(player, Lang("CommandHelp", player?.Id));
            }
        }

        void CheckEffectCommand(IPlayer player, string command, string[] args)
        {
            SendReplyMessage(player, GetPlayerThread(player, player));
        }

        void RegisterCommands()
        {
            AddCovalenceCommand(config.EffectCommand, nameof(CheckEffectCommand));
            AddCovalenceCommand(config.EPSCommand, nameof(BasicCommand));
        }

        #region GUI

        [Command("EffecterUI.set")]
        void SetEffectUIPage(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
            {
                return;
            }

            var BPlayer = player.Object as BasePlayer;

            if (args.Length >= 1)
            {
                switch (args[0])
                {
                    case "++":
                        PlayerAddCursor(BPlayer);
                        playersUIData.Players[player.Id].EffectPage++;
                        UpdatePagePlayerUIInfo(BPlayer);
                        break;
                    case "--":
                        PlayerAddCursor(BPlayer);
                        if (playersUIData.Players[player.Id].EffectPage > 0)
                        {
                            playersUIData.Players[player.Id].EffectPage--;
                            UpdatePagePlayerUIInfo(BPlayer);
                        }
                        break;
                    default:
                        break;
                }
            }
        }

        [Command("eui")]
        void SetUICommand(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
            {
                return;
            }

            var BPlayer = player.Object as BasePlayer;
            PlayerGUIInfo playerGUIInfo = playersUIData.Players[player.Id];

            if (playerGUIInfo.useUI == true)
            {
                PlayerAddCursor(BPlayer);
                playerGUIInfo.useUI = false;
                UpdatePagePlayerUIInfo(BPlayer);
                SendReplyMessage(player, "off");
            }
            else
            {
                PlayerAddCursor(BPlayer);
                playerGUIInfo.useUI = true;
                UpdatePagePlayerUIInfo(BPlayer);
                SendReplyMessage(player, "on");
            }
        }

        #endregion

        #endregion

        #region UI

        private void OnUIScaleChanged(IPlayer player)
        {
            PlayerAddBaseinvUI(player.Object as BasePlayer);
            UpdatePagePlayerUIInfo(player.Object as BasePlayer);
        }

        private void PlayerAddCursor(BasePlayer player)
        {
            CuiElementContainer CursorUI = new CuiElementContainer();

            CursorUI.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image =
                    {
                        Color = "0 0 0 0"
                    },

                RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0.00001 0.00001"
                    },
            }, "Hud", CursorUIPanel);

            CuiHelper.DestroyUi(player, CursorUIPanel);
            CuiHelper.AddUi(player, CursorUI);

            if (PlayersViewingUi.ContainsKey(player.UserIDString))
            {
                PlayersViewingUi[player.UserIDString].Reset();
            }
            else
            {
                PlayersViewingUi.Add(player.UserIDString, timer.Once(3f, () =>
                {
                    CuiHelper.DestroyUi(player, CursorUIPanel);
                    PlayersViewingUi.Remove(player.UserIDString);
                }));
            }
        }

        private void PlayerAddBaseinvUI(BasePlayer player)
        {
            CuiElementContainer EffectUI = new CuiElementContainer();

            string AnchorMin = GetAnchorMin(player, 0);
            string AnchorMax = GetAnchorMax(player, 3);

            EffectUI.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image =
                    {
                        Color = "0 0 0 0"
                    },

                RectTransform =
                    {
                        AnchorMin = AnchorMin,
                        AnchorMax = AnchorMax
                    },
            }, "Hud", UIBaseInvPanel);

            CuiHelper.DestroyUi(player, UIBaseInvPanel);
            CuiHelper.AddUi(player, EffectUI);
        }

        private void PlayersAddBaseinvUI()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiElementContainer EffectUI = new CuiElementContainer();

                string AnchorMin = GetAnchorMin(player, 0);
                string AnchorMax = GetAnchorMax(player, 3);

                EffectUI.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image =
                {
                    Color = "0 0 0 0"
                },

                    RectTransform =
                {
                    AnchorMin = AnchorMin,
                    AnchorMax = AnchorMax
                },
                }, "Hud", UIBaseInvPanel);

                CuiHelper.DestroyUi(player, UIBaseInvPanel);
                CuiHelper.AddUi(player, EffectUI);
            }
        }

        private void PlayersRemoveBaseinvUI()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, UIBaseInvPanel);
            }
        }

        private void UpdateBaseUI(BasePlayer player, List<BasePlayerEffectThread> effectthreadUIs, bool useUpPM, bool useDownPM)
        {
            CuiElementContainer EffectUI = new CuiElementContainer();

            EffectUI.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image =
                {
                    Color = "0 0 0 0"
                },

                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                },
            }, UIBaseInvPanel, UIBasePanel);

            if (playersUIData.Players[player.UserIDString].useUI)
            {
                for (int i = 0; i < effectthreadUIs.Count; i++)
                {
                    EffectUI.AddRange(SingleEffectUI(player, i, effectthreadUIs[i]));
                }
                if (effectthreadUIs.Count > 0)
                    EffectUI.AddRange(EndBarUI(effectthreadUIs.Count));

                EffectUI.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image =
                    {
                        Color = "0 0 0 0"
                    },

                    RectTransform =
                    {
                        AnchorMin = "0.92 0",
                        AnchorMax = "0.997 1"
                    },
                }, UIBasePanel, UIBaseBtnPanel);

                if (effectthreadUIs.Count > 0)
                {
                    if (useUpPM)
                    {
                        EffectUI.Add(new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin = GetSingleAnchorMin(2),
                                AnchorMax = GetBtnAnchorMax(2)
                            },
                            Button =
                            {
                                Color = "1 1 1 0.4",
                                Command = "EffecterUI.set ++"
                            },
                            Text =
                            {
                                Text = "△",
                                FontSize = 17,
                                Align = TextAnchor.MiddleCenter
                            }
                        }, UIBaseBtnPanel, UIPMBtn);
                    }
                    if (useDownPM)
                    {
                        EffectUI.Add(new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin = GetSingleAnchorMin(1),
                                AnchorMax = GetBtnAnchorMax(1)
                            },
                            Button =
                            {
                                Color = "1 1 1 0.4",
                                Command = "EffecterUI.set --"
                            },
                            Text =
                            {
                                Text = "▽",
                                FontSize = 17,
                                Align = TextAnchor.MiddleCenter
                            }
                        }, UIBaseBtnPanel, UIPMBtn);
                    }

                    EffectUI.Add(new CuiButton
                    {
                        RectTransform =
                        {
                            AnchorMin = GetSingleAnchorMin(0),
                            AnchorMax = GetBtnAnchorMax(0)
                        },
                        Button =
                        {
                            Color = "1 1 1 0.5",
                            Command = "eui"
                        },
                        Text =
                        {
                            Text = "▼",
                            FontSize = 13,
                            Align = TextAnchor.MiddleCenter
                        }
                    }, UIBaseBtnPanel, ESBtn);
                }
            }
            else
            {
                if (effectthreadUIs.Count > 0)
                {
                    EffectUI.Add(new CuiPanel
                    {
                        CursorEnabled = false,
                        Image =
                        {
                            Color = "0 0 0 0"
                        },

                        RectTransform =
                        {
                            AnchorMin = "0.92 0",
                            AnchorMax = "0.997 1"
                        },
                    }, UIBasePanel, UIBaseBtnPanel);

                    EffectUI.Add(new CuiButton
                    {
                        RectTransform =
                    {
                        AnchorMin = GetSingleAnchorMin(0),
                        AnchorMax = GetBtnAnchorMax(0)
                    },
                        Button =
                    {
                        Color = "1 1 1 0.3",
                        Command = "eui"
                    },
                        Text =
                    {
                        Text = "▲",
                        FontSize = 13,
                        Align = TextAnchor.MiddleCenter
                    }
                    }, UIBaseBtnPanel, ESBtn);
                }
            }

            CuiHelper.DestroyUi(player, UIBasePanel);
            CuiHelper.AddUi(player, EffectUI);
        }

        private CuiElementContainer SingleEffectUI(BasePlayer player, int index, BasePlayerEffectThread effectthreadUI)
        {
            CuiElementContainer EffectUI = new CuiElementContainer();

            string AnchorMin = GetSingleAnchorMin(index);
            string AnchorMax = GetSingleAnchorMax(index);
            string LeftTImeAnchorMax = GetLeftTImeAnchorMax(player, index);

            Color EffectColor;
            if (ColorUtility.TryParseHtmlString(effectthreadUI.ThreadColor, out EffectColor) == false)
                EffectColor = Color.cyan;
            string UIEffectColor = EffectColor.r.ToString() + ' ' + EffectColor.g.ToString() + ' ' + EffectColor.b.ToString();

            string TextColorThreadName;
            string TextColorLefttime;

            if (effectthreadUI.PlayerThreadType == PlayerThreadType.PlaytimeEffectThread)
            {
                TimeSpan? playtime = GetPlayerPlaytime(player.UserIDString);
                if (playtime == null)
                    TextColorLefttime = "<color=black>" + GetLeftTimeString(new TimeSpan()) + "</color>";
                else
                    TextColorLefttime = "<color=black>" + GetLeftTimeString(effectthreadUI.ExpireTime - (TimeSpan)playtime) + "</color>";
                TextColorThreadName = "<color=black>" + effectthreadUI.ThreadName + "</color>";
            }
            else
            {
                TextColorLefttime = "<color=white>" + GetLeftTimeString(effectthreadUI.ExpireDate - DateTime.Now) + "</color>";
                TextColorThreadName = "<color=white>" + effectthreadUI.ThreadName + "</color>";
            }

            EffectUI.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image =
                {
                    Color = UIEffectColor + " 0.6"
                },

                RectTransform =
                {
                    AnchorMin = AnchorMin,
                    AnchorMax = AnchorMax
                },
            }, UIBasePanel, BackGroundPanel);

            EffectUI.Add(new CuiLabel
            {
                Text =
                {
                    Text = TextColorThreadName,
                    FontSize = 13,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                }
            }, BackGroundPanel);

            if (effectthreadUI.PlayerThreadType != PlayerThreadType.EffectThread)
            {
                EffectUI.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image =
                    {
                        Color = UIEffectColor + " 0.7"
                    },

                    RectTransform =
                    {
                        AnchorMin = AnchorMin,
                        AnchorMax = LeftTImeAnchorMax
                    },
                }, UIBasePanel, BackGroundPanel);

                EffectUI.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = TextColorLefttime,
                        FontSize = 13,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }, BackGroundPanel);
            }

            return EffectUI;
        }

        private CuiElementContainer EndBarUI(int index)
        {
            CuiElementContainer EffectUI = new CuiElementContainer();

            string AnchorMin = GetSingleAnchorMin(index);
            string AnchorMax = GetEndAnchorMax(index);

            EffectUI.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image =
                {
                    Color = "1 1 1 0.3"
                },

                RectTransform =
                {
                    AnchorMin = AnchorMin,
                    AnchorMax = AnchorMax
                },
            }, UIBasePanel, BackGroundPanel);

            return EffectUI;
        }

        double IndexGap = 0.031;

        private string GetAnchorMin(BasePlayer player, int index)
        {
            float BeltSize = GetUISize(player.UserIDString);
            int CompareBeltSize = (int)(BeltSize * 10);

            string YMin;
            if (config.UIPosions.ContainsKey(CompareBeltSize))
                YMin = (config.UIPosions[CompareBeltSize].YAnchorMin + (IndexGap * index)).ToString();
            else
                YMin = (config.UIPosions.ElementAt(0).Value.YAnchorMin + (IndexGap * index)).ToString();

            if (config.UIPosions.ContainsKey(CompareBeltSize))
                return config.UIPosions[CompareBeltSize].XAnchorMin + " " + YMin;
            else
                return config.UIPosions.ElementAt(0).Value.XAnchorMin + " " + YMin;
        }

        private string GetAnchorMax(BasePlayer player, int index)
        {
            float BeltSize = GetUISize(player.UserIDString);
            int CompareBeltSize = (int)(BeltSize * 10);

            string YMax;
            if (config.UIPosions.ContainsKey(CompareBeltSize))
                YMax = (config.UIPosions[CompareBeltSize].YAnchorMax + 0.03 + (IndexGap * index)).ToString();
            else
                YMax = (config.UIPosions.ElementAt(0).Value.YAnchorMax + 0.03 + (IndexGap * index)).ToString();

            if (config.UIPosions.ContainsKey(CompareBeltSize))
                return config.UIPosions[CompareBeltSize].XAnchorMax + " " + YMax;
            else
                return config.UIPosions.ElementAt(0).Value.XAnchorMax + " " + YMax;
        }

        private string GetLeftTImeAnchorMax(BasePlayer player, int index)
        {
            return "0.22 " + (0.29 * (index + 1) + 0.015 * index).ToString();
        }

        private string GetEndAnchorMax(int index)
        {
            return "1 " + ((0.29 * (index) + 0.015 * index) + 0.07).ToString();
        }

        private string GetSingleAnchorMin(int index)
        {
            return "0 " + (0.29 * (index) + 0.015 * index).ToString();
        }

        private string GetSingleAnchorMax(int index)
        {
            return "1 " + (0.29 * (index + 1) + 0.015 * index).ToString();
        }

        private string GetBtnAnchorMax(int index)
        {
            return "1 " + (0.29 * (index + 1) + 0.015 * index - 0.01).ToString();
        }

        #endregion

        #region API

        private void API_AddEffectToPlayer(IPlayer player, string EffectThreadName)
        {
            playersData.AddEffectToPlayer(player, null, EffectThreadName);
        }

        private void API_DeleteEffectFromPlayer(IPlayer player, string EffectThreadName)
        {
            playersData.DeleteEffectFromPlayer(player.Id, null, EffectThreadName);
        }

        private void API_AddEffectToGroup(string GroupName, string EffectThreadName)
        {
            groupsData.AddEffectToGroup(GroupName, null, EffectThreadName);
        }

        private void API_DeleteEffectFromGroup(string GroupName, string EffectThreadName)
        {
            groupsData.DeleteEffectFromGroup(GroupName, null, EffectThreadName);
        }

        private void API_DeleteAllEffectFromGroup(string GroupName)
        {
            groupsData.DeleteAllEffectFromGroup(GroupName, null);
        }

        private void API_RegisterThread(int ThreadType, string ThreadName, string HexThreadColor, string[] Permissions, int AutoExpireTime, int EffectTime)
        {
            TimeSpan? autoExpireTime;

            if (AutoExpireTime == 0)
                autoExpireTime = null;
            else
                autoExpireTime = TimeSpan.FromSeconds(AutoExpireTime);

            BaseDataEffectThread effectThread = null;

            if (EffectTime == 0)
            {
                effectThread = new EffectThreadData(ThreadName, GetHexColorFromFormat(HexThreadColor), Permissions.ToList(), autoExpireTime);
            }

            switch (ThreadType)
            {
                case 0:
                    effectThread = new RealtimeEffectThreadData(ThreadName, GetHexColorFromFormat(HexThreadColor), Permissions.ToList(), autoExpireTime, TimeSpan.FromSeconds(EffectTime));
                    break;

                case 1:
                    effectThread = new PlaytimeEffectThreadData(ThreadName, GetHexColorFromFormat(HexThreadColor), Permissions.ToList(), autoExpireTime, TimeSpan.FromSeconds(EffectTime));
                    break;

                default:
                    break;
            }

            if (effectThread != null)
                registeredThreads.RegisterThread(effectThread, null);
        }

        private void API_UnRegisterThread(string ThreadName)
        {
            registeredThreads.UnRegisterThread(ThreadName, null);
        }

        private bool API_ThreadIsExist(string ThreadName)
        {
            return registeredThreads.ThreadIsExist(ThreadName);
        }

        private bool API_PlayerHasEffect(string playerId, string effectThreadName)
        {
            return playersData.PlayerHasEffect(playerId, effectThreadName);
        }

        private TimeSpan? API_GetPlayerEffectLeftTime(IPlayer player, string effectThreadName)
        {
            return playersData.GetPlayerEffectLeftTime(player.Id, effectThreadName);
        }

        #endregion

        #region Helper

        private float GetUISize(string playerID)
        {
            if (UIScaleManager != null)
                return (float)UIScaleManager.Call("API_CheckPlayerUISize", playerID);
            else
                return 0;
        }

        private string GetLeftTimeString(TimeSpan lefttime)
        {
            string lefttimestr;

            if (lefttime == new TimeSpan(0, 0, -1))
                lefttimestr = "-1";
            else if (0 < lefttime.Days)
                lefttimestr = lefttime.ToString(@"dd\.hh\:mm\:ss");
            else
                lefttimestr = lefttime.ToString(@"hh\:mm\:ss");

            return lefttimestr;
        }

        private TimeSpan? GetPlayerPlaytime(string playerID)
        {
            if (PlaytimeTracker != null)
            {
                object obj = PlaytimeTracker.Call("GetPlayTime", playerID);

                if (obj != null)
                {
                    return TimeSpan.FromSeconds((double)obj);
                }
            }
            return null;
        }

        private string GetHexColorFromFormat(string color)
        {
            return "#" + ColorUtility.ToHtmlStringRGB(GetColorFromString(color));
        }

        private string GetHexColor(Color color)
        {
            return "#" + ColorUtility.ToHtmlStringRGB(color);
        }

        private Color GetColorFromString(string str)
        {
            str = str.ToLower();

            Color color = new Color();

            switch (str)
            {
                case "black":
                    color = Color.black;
                    break;
                case "blue":
                    color = Color.blue;
                    break;
                case "clear":
                    color = Color.clear;
                    break;
                case "cyan":
                    color = Color.cyan;
                    break;
                case "gray":
                    color = Color.gray;
                    break;
                case "green":
                    color = Color.green;
                    break;
                case "magenta":
                    color = Color.magenta;
                    break;
                case "red":
                    color = Color.red;
                    break;
                case "white":
                    color = Color.white;
                    break;
                case "yellow":
                    color = Color.yellow;
                    break;
                default:
                    if (ColorUtility.TryParseHtmlString(str, out color) == false)
                        color = Color.cyan;
                    break;
            }

            return color;
        }

        private IPlayer GetPlayer(string nameOrID, IPlayer player)
        {
            List<BasePlayer> BasePlayerList = BasePlayer.activePlayerList.ToList();
            List<IPlayer> PlayersList = new List<IPlayer>();

            foreach (var item in BasePlayerList)
            {
                PlayersList.Add(item.IPlayer);
            }

            if (nameOrID.IsSteamId())
            {
                IPlayer result = PlayersList.Find((p) => p.Id == nameOrID);

                if (result == null)
                    SendReplyMessage(player, Lang("SteamID Not Found", player?.Id, nameOrID));

                return result;
            }

            List<IPlayer> foundPlayers = new List<IPlayer>();

            foreach (IPlayer current in PlayersList)
            {
                if (current.Name.ToLower() == nameOrID.ToLower())
                    return current;

                if (current.Name.ToLower().Contains(nameOrID.ToLower()))
                    foundPlayers.Add(current);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    SendReplyMessage(player, Lang("Player Not Found", player?.Id, nameOrID));
                    break;
                case 1:
                    return foundPlayers[0];
                default:
                    string[] names = (from current in foundPlayers select $"- {current.Name}").ToArray();
                    SendReplyMessage(player, Lang("Multiple Players Found", player?.Id, string.Join("\n", names)));
                    break;
            }
            return null;
        }

        private IPlayer GetPlayer(string nameOrID)
        {
            List<BasePlayer> BasePlayerList = BasePlayer.activePlayerList.ToList();
            List<IPlayer> PlayersList = new List<IPlayer>();

            foreach (var item in BasePlayerList)
            {
                PlayersList.Add(item.IPlayer);
            }

            if (nameOrID.IsSteamId())
            {
                IPlayer result = PlayersList.Find((p) => p.Id == nameOrID);

                return result;
            }

            List<IPlayer> foundPlayers = new List<IPlayer>();

            foreach (IPlayer current in PlayersList)
            {
                if (current.Name.ToLower() == nameOrID.ToLower())
                    return current;

                if (current.Name.ToLower().Contains(nameOrID.ToLower()))
                    foundPlayers.Add(current);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    break;
                case 1:
                    return foundPlayers[0];
                default:
                    string[] names = (from current in foundPlayers select $"- {current.Name}").ToArray();
                    break;
            }
            return null;
        }

        private BasePlayer GetPlayerFromID(string ID)
        {
            List<BasePlayer> BasePlayerList = BasePlayer.activePlayerList.ToList();

            BasePlayer result = BasePlayerList.Find((p) => p.UserIDString == ID);

            return result;
        }

        private bool PlayerIsOnline(string ID)
        {
            List<BasePlayer> BasePlayerList = BasePlayer.activePlayerList.ToList();

            BasePlayer result = BasePlayerList.Find((p) => p.UserIDString == ID);

            if (result == null)
                return false;
            else
                return true;
        }

        private void SendChatMessage(IPlayer player, string message)
        {
            if (message == null)
                return;
            if (player == null)
                Puts(message);
            else
                (player.Object as BasePlayer).ChatMessage(message);
        }

        private void SendReplyMessage(IPlayer player, string message)
        {
            if (player == null)
                Puts(message);
            else
                player.Reply(message);
        }

        private void SendBroadcastMessage(string message)
        {
            if (config.use_BroadCast)
            {
                foreach (IPlayer current in players.Connected)
                    SendChatMessage(current, message);
            }
        }

        private void puts(string msg)
        {
            if (config.use_ConsoleMessage == true)
                Puts(msg);
        }

        private void printWarning(string msg)
        {
            if (config.use_ConsoleMessage == true)
                PrintWarning(msg);
        }

        #endregion
    }
}

// --- End of file: PermissionEffects.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/powerless-electronics ---
// --- Original File Path: P/PowerlessElectronics/PowerlessElectronics.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Powerless Electronics", "WhiteThunder", "1.2.5")]
    [Description("Allows electrical entities to generate their own power when not plugged in.")]
    internal class PowerlessElectronics : CovalencePlugin
    {
        #region Fields

        private const string PermissionAll = "powerlesselectronics.all";
        private const string PermissionEntityFormat = "powerlesselectronics.{0}";

        private Configuration _config;

        #endregion

        #region Hooks

        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnServerInitialized()
        {
            // Don't overwrite the config if invalid since the user will lose their config!
            if (!_config.UsingDefaults)
            {
                var addedPrefabs = _config.AddMissingPrefabs();
                if (addedPrefabs != null)
                {
                    LogWarning($"Discovered and added {addedPrefabs.Count} electrical entity types to Configuration.\n - {string.Join("\n - ", addedPrefabs)}");
                    SaveConfig();
                }
            }

            _config.GeneratePermissionNames();

            // Register permissions only after discovering prefabs.
            permission.RegisterPermission(PermissionAll, this);
            foreach (var entry in _config.Entities)
            {
                permission.RegisterPermission(entry.Value.PermissionName, this);
            }

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var ioEntity = entity as IOEntity;
                if (ioEntity != null)
                {
                    ProcessIOEntity(ioEntity, delay: false);
                }
            }

            Subscribe(nameof(OnEntitySpawned));
        }

        private void OnEntitySpawned(IOEntity ioEntity)
        {
            ProcessIOEntity(ioEntity, delay: true);
        }

        private void OnIORefCleared(IOEntity.IORef ioRef, IOEntity ioEntity)
        {
            ProcessIOEntity(ioEntity, delay: true);
        }

        #endregion

        #region Helper Methods

        private static bool InputUpdateWasBlocked(IOEntity ioEntity, int inputSlot, int amount)
        {
            return Interface.CallHook("OnPowerlessInputUpdate", inputSlot, ioEntity, amount) is false;
        }

        private static bool IsHybridIOEntity(IOEntity ioEntity)
        {
            return ioEntity is ElectricFurnaceIO or ElevatorIOEntity or MicrophoneStandIOEntity
                   || (ioEntity is SimpleLight && ioEntity.GetParentEntity() is WeaponRack);
        }

        private static BaseEntity GetOwnerEntity(IOEntity ioEntity)
        {
            var parent = ioEntity.GetParentEntity();
            if ((object)parent == null)
                return ioEntity;

            return IsHybridIOEntity(ioEntity) ? parent : ioEntity;
        }

        private static bool ShouldIgnoreEntity(IOEntity ioEntity)
        {
            // Parented entities are assumed to be controlled by other plugins that can manage power themselves
            // Exception being entities that are parented in vanilla
            if (ioEntity.HasParent()
                && !IsHybridIOEntity(ioEntity)
                && !(ioEntity is IndustrialCrafter)
                && !(ioEntity is StorageMonitor)
                && !(ioEntity is DoorManipulator))
                return true;

            // Turrets and sam sites with switches on them are assumed to be controlled by other plugins
            if (ioEntity is AutoTurret or SamSite && GetChildEntity<ElectricSwitch>(ioEntity) != null)
                return true;

            return false;
        }

        private static void MaybeProvidePower(IOEntity ioEntity, EntityConfig entityConfig)
        {
            if (ShouldIgnoreEntity(ioEntity))
                return;

            foreach (var inputSlot in entityConfig.InputSlots)
            {
                var powerAmount = entityConfig.GetPowerForSlot(inputSlot);

                // Don't update power if speci