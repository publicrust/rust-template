] = "Player wasn't found",
                ["Multiple Players Found"] = "Multiple players found with that name ({players}), please try something more unique like a steamid",
                ["Ban Syntax"] = "[#ff0000]ban <playerNameOrID> \"the reason\" <length>[/#]\nexample: ban \"some user\" \"cheating\" 1y\n length examples: 1h for 1 hour, 1m for 1 month etc",
                ["UnBan Syntax"] = "sa.unban <playerNameOrID> <reason>",
                ["No Response From API"] = "Couldn't get an answer from ServerArmour.com! Error: {code} {response}",
                ["Player Not Banned"] = "Player not banned",
                ["Broadcast Player Banned"] = "{tag} {username} wasn't allowed to connect\nReason: {reason}",
                ["Reason: VAC Ban Too Fresh"] = "VAC ban received {daysago} days ago, wait another {daysto} days",
                ["Reason: VAC Ban Too Fresh - Lender"] = "VAC ban received {daysago} days ago on lender account, wait another {daysto} days",
                ["Lender Banned"] = "The lender account contained a ban",
                ["Keyword Kick"] = "Due to your past behaviour on other servers, you aren't allowed in.",
                ["Family Share Kick"] = "Family share accounts are not allowed on this server.",
                ["Too Many Previous Bans"] = "You have too many previous bans (other servers included). Appeal in discord",
                ["Too Many Previous Game Bans"] = "You have too many previous game bans. Appeal in discord",
                ["VAC Ceiling Kick"] = "You have too many VAC bans. Appeal in discord",
                ["Player Kicked"] = "[#ff0000]{player} Kicked[/#] - Reason\n{reason}",
                ["Profile Private"] = "Your Steam Profile is not allowed to be private on this server.",
                ["Profile Low Level"] = "You need a level {level} steam profile for this server.",
                ["Steam Level Hidden"] = "You are not allowed to hide your steam level on this server.",
                ["Strange Steam64ID"] = "Your steam id does not conform to steam standards.",
                ["Country Not Allowed"] = "Your country {country} is not allowed, only from {country2}",
                ["Permanent"] = "Permanent"
            }, this, "en");
        }

        #endregion

        #region Plugins methods
        string GetChatTag() => "[#008080ff][Server Armour]:[/#] ";
        void RegisterTag()
        {
            if (BetterChat != null && config.BetterChatDirtyPlayerTag != null && config.BetterChatDirtyPlayerTag.Length > 0)
                BetterChat?.Call("API_RegisterThirdPartyTitle", new object[] { this, new Func<IPlayer, string>(GetTag) });
        }

        string GetTag(IPlayer player)
        {
            if (BetterChat != null && IsPlayerDirty(player.Id) && config.BetterChatDirtyPlayerTag.Length > 0)
            {
                return $"[#FFA500][{config.BetterChatDirtyPlayerTag}][/#]";
            }
            else
            {
                return string.Empty;
            }
        }
        #endregion

        #region Log Helpers
        private void HandleLog(string message, string stackTrace, LogType type)
        {
            if (!type.Equals(LogType.Warning))
                return;

            var meshLog = logRegex.Match(message);
            if (!meshLog.Success || meshLog.Groups.Count < 3) return;

            var offendingPrefab = meshLog.Groups[1].ToString();
            var offendingPrefabPos = meshLog.Groups[2].ToString().ToVector3();

            var entities = new List<BaseEntity>();
            Vis.Entities(offendingPrefabPos, 5f, entities);

            if (entities.Count < 1) return;

            foreach (var entity in entities)
            {
                if (entity.PrefabName == offendingPrefab && !entity.IsDestroyed)
                {
                    entity.Kill();
                }
            }
        }
        #endregion

        #region Helpers 
        void SendReplyWithIcon(IPlayer player, string format, params object[] args)
        {
            int cnt = 0;
            string msg = GetMsg(format);
            foreach (var arg in args)
            {
                msg = msg.Replace("{" + cnt + "}", arg.ToString());
                cnt++;
            }

            if (!player.IsServer && player.IsConnected)
            {
                BasePlayer bPlayer = player.Object as BasePlayer;
                bPlayer?.SendConsoleCommand("chat.add", 2, config.IconSteamId, FixColors(msg));
            }
            else
            {
                player?.Reply(msg);
            }
        }
        void BroadcastWithIcon(string format, params object[] args)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                SendReplyWithIcon(player.IPlayer, format, args);
            }
        }

        string FixColors(string msg) => msg.Replace("[/#]", "</color>").Replace("[", "<color=").Replace("]", ">");

        void AssignGroup(string id, string group) => permission.AddUserGroup(id, group);
        bool HasGroup(string id, string group) => permission.UserHasGroup(id, group);
        void RegPerm(string perm)
        {
            if (!permission.PermissionExists(perm)) permission.RegisterPermission(perm, this);
        }

        bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);
        void GrantPerm(string id, string perm) => permission.GrantUserPermission(id, perm, this);

        private static readonly DateTime Epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
        private static uint ConvertToTimestamp(string value)
        {
            return ConvertToTimestamp(ConverToDateTime(value));
        }

        private static uint ConvertToTimestamp(DateTime value)
        {
            TimeSpan elapsedTime = value - Epoch;
            return (uint)elapsedTime.TotalSeconds;
        }

        private static DateTime ConverToDateTime(string stringDate)
        {
            DateTime time;
            if (!DateTime.TryParseExact(stringDate, DATE_FORMAT, CultureInfo.InvariantCulture, DateTimeStyles.None, out time))
            {
                if (!DateTime.TryParseExact(stringDate, DATE_FORMAT2, CultureInfo.InvariantCulture, DateTimeStyles.None, out time))
                {
                    if (!DateTime.TryParseExact(stringDate, DATE_FORMAT_BAN, CultureInfo.InvariantCulture, DateTimeStyles.None, out time))
                    {
                        return DateTime.MaxValue;
                    }
                }
            }
            return time;
        }

        private static DateTime ConvertUnixToDateTime(long unixTimeStamp)
        {
            // Unix timestamp is seconds past epoch
            DateTime dtDateTime = Epoch;
            dtDateTime = dtDateTime.AddSeconds(unixTimeStamp).ToLocalTime();
            return dtDateTime;
        }

        #endregion

        #region Classes 
        public class EmbedFieldList
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
        }

        public class ISAPlayer
        {
            public int id { get; set; }
            public string steamid { get; set; }
            public int? steamlevel { get; set; }

            public int steamCommunityBanned { get; set; }
            public int steamVACBanned { get; set; }
            public int steamNumberOfVACBans { get; set; }
            public int steamDaysSinceLastBan { get; set; }
            public int steamNumberOfGameBans { get; set; }
            public string steamEconomyBan { get; set; }
            public int communityvisibilitystate { get; set; }
            public string personaname { get; set; }
            //public long? twitterBanId { get; set; }
            public List<EacBan> eacBans { get; set; }

            public uint? cacheTimestamp { get; set; }

            public uint? lastConnected { get; set; }
            public List<ISABan> bans { get; set; }
            //public ISAPlayer lender { get; set; }

            public IPInfo ipInfo { get; set; }

            public ISAPlayer(ulong steamId)
            {
                steamid = steamId.ToString();
                personaname = "";
                this.bans = new List<ISABan>();
            }
        }

        public class IPInfo
        {
#pragma warning disable 0649
            public string ip;
            public string lastcheck;
            public long longIp;
            public string asn;
            public string provider;
            public string continent;
            public string country;
            public string isocode;
            public string region;
            public string regioncode;
            public string city;
            public string latitude;
            public string longitude;
            public string proxy;
            public string type;
            public float rating;
            public bool isCloudComputing;
#pragma warning restore 0649
        }

        public class EacBan
        {
#pragma warning disable 0649
            public string id;
            public string steamid;
            public string createdAt;
            public string lastChecked;
            public string text;
            public string steamProfile;
            public bool isCron;
            public bool isTemp;
#pragma warning restore 0649
        }

        public class ISABan
        {
#pragma warning disable 0649
            public int id;
            public string adminSteamId;
            public int serverId;
            public ulong steamid;
            public ulong bannedBy;
            public string reason;
            public string banLength;
            public string serverName;
            public string serverIp;
            public string dateTime;
            public string created;
            public int gameId;
            public string? banUntil;
#pragma warning restore 0649

            public uint GetUnixBanUntill()
            {
                return ConvertToTimestamp(banUntil);
            }

            /// <summary>This method throws an exception when the date cannot be parsed, parmanent bans do not have a banUntil date.</summary>
            /// <exception cref="FormatException">This exception is thrown if it's a pemanent ban</exception>
            public DateTime BanUntillDateTime()
            {
                return ConverToDateTime(banUntil);
            }

            public bool IsBanned()
            {
                return banUntil == null || !DateIsPast(BanUntillDateTime());
            }
        }

        #endregion

        #region ESP Detection
        private void API_EspDetected(string jString)
        {
            JObject aObject = JObject.Parse(jString);
            DoRequest($"player/{aObject.GetValue("steamId")}/addesp", $"radarUrl={aObject.GetValue("radarUrl")}&violations={aObject.GetValue("violations")}");
        }
        #endregion

        #region Stash Warning System
        private void API_StashFoundTrigger(string jString)
        {
            JObject aObject = JObject.Parse(jString);
            DoRequest($"player/{aObject.GetValue("steamId")}/addstashtrigger",
                $"isFalsePositive={aObject.GetValue("isFalsePositive")}&" +
                $"isClanMember={aObject.GetValue("isClanMember")}&" +
                $"location={aObject.GetValue("location")}&" +
                $"position={aObject.GetValue("position")}&" +
                $"stashOwnerSteamId={aObject.GetValue("stashOwnerSteamId")}");
        }
        #endregion

        #region Arkan

        private void API_ArkanOnNoRecoilViolation(BasePlayer player, int NRViolationsNum, string jString)
        {
            if (!serverStarted || !config.SubmitArkanData)
                return;

            if (jString != null)
            {
                JObject aObject = JObject.Parse(jString);

                string shotsCnt = aObject.GetValue("ShotsCnt").ToString();
                string violationProbability = aObject.GetValue("violationProbability").ToString();
                string ammoShortName = aObject.GetValue("ammoShortName").ToString();
                string weaponShortName = aObject.GetValue("weaponShortName").ToString();
                string attachments = String.Join(", ", aObject.GetValue("attachments").Select(jv => (string)jv).ToArray());
                string suspiciousNoRecoilShots = aObject.GetValue("suspiciousNoRecoilShots").ToString();

                DoRequest($"player/{player.UserIDString}/addarkan/nr",
                    $"vp={violationProbability}&sc={shotsCnt}&ammo={ammoShortName}&weapon={weaponShortName}&attach={attachments}&snrs={suspiciousNoRecoilShots}", (c, r) => { });
            }
        }

        private void API_ArkanOnAimbotViolation(BasePlayer player, int AIMViolationsNum, string jString)
        {
            if (!config.SubmitArkanData)
                return;

            if (jString != null)
            {
                JObject aObject = JObject.Parse(jString);
                string attachments = String.Join(", ", aObject.GetValue("attachments").Select(jv => (string)jv).ToArray());
                string ammoShortName = aObject.GetValue("ammoShortName").ToString();
                string weaponShortName = aObject.GetValue("weaponShortName").ToString();
                string damage = aObject.GetValue("damage").ToString();
                string bodypart = aObject.GetValue("bodyPart").ToString();
                string hitsData = aObject.GetValue("hitsData").ToString();
                string hitInfoProjectileDistance = aObject.GetValue("hitInfoProjectileDistance").ToString();

                DoRequest($"player/{player.UserIDString}/addarkan/aim",
                    $"attach={attachments}&ammo={ammoShortName}&weapon={weaponShortName}&dmg={damage}&bp={bodypart}&distance={hitInfoProjectileDistance}&hits={hitsData}", (c, r) => { });
            }
        }

        #endregion

        #region webrequest
        private void TranslateCode(int statusCode)
        {
            switch (statusCode)
            {
                case 429:
                    PrintWarning("Rate limited. Upgrade package on https://serverarmour.com");
                    break;
                case 502:
                    break;
                case 500:
                    break;
            }
        }

        private void GetJson(string url, Action<int, JObject> callback)
        {
            DoRequest(url, null, (c, s) =>
            {
                JObject json = new JObject();
                if (c < 300)
                {
                    json = JObject.Parse(s);
                }
                callback(c, json);
            }, RequestMethod.GET);
        }

        private void DoRequest(string url, string body = null, Action<int, string> callback = null, RequestMethod requestType = RequestMethod.POST, int retryInSeconds = 0, int retryCounter = 0)
        {
            try
            {
                webrequest.Enqueue($"{api_hostname}/api/v1/plugin/{url}", body, (code, response) =>
                {
                    var status = code < 299 ? "OK" : "NOK";
                    LogDebug($"API ({url}) Response = {code} {status}: \n{response}");
                    if (code < 299)
                    {
                        if (callback != null)
                            callback(code, response);
                        return;
                    }

                    TranslateCode(code);

                    if (retryInSeconds > 0 && retryCounter < 5)
                        timer.Once(retryInSeconds, () => DoRequest(url, body, callback, requestType, retryInSeconds, retryCounter++));

                }, this, requestType, headers);
            }
            catch (Exception e) { }
        }

        private void CalcElo(string steamIdKiller, string steamIdVictim, string killInfo, Action<int, string> callback = null, int retryInSeconds = 0)
        {
            webrequest.Enqueue($"{api_hostname}/api/v1/elo/{steamIdKiller}/{steamIdVictim}", killInfo, (code, response) =>
            {
                if (code < 400)
                {
                    Interface.CallHook("OnEloChange", JObject.Parse(response));
                    if (callback != null)
                        callback(code, response);
                    return;
                }

                TranslateCode(code);

                if (retryInSeconds > 0)
                    timer.Once(retryInSeconds, () => CalcElo(steamIdKiller, steamIdVictim, killInfo, callback));

            }, this, RequestMethod.POST, headers);
        }

        private void FetchElo(string steamId) => FetchEloUpdate(steamId, (c, r) => { });
        private void FetchEloUpdate(string steamId, Action<int, string> callback, int retryInSeconds = 0)
        {
            webrequest.Enqueue($"{api_hostname}/api/v1/elo/{steamId}", null, (code, response) =>
            {
                if (code < 299)
                {
                    Interface.CallHook("OnEloUpdate", JObject.Parse(response));
                    callback(code, response);
                    return;
                }

                TranslateCode(code);
                if (retryInSeconds > 0)
                    timer.Once(retryInSeconds, () => FetchEloUpdate(steamId, callback));

            }, this, RequestMethod.GET, headers);
        }
        #endregion

        #region Combat
        private void UploadCombatEntries(string logEntries)
        {
            // LogDebug("Combat Logs upload requested");
            DoRequest("combat_log", $"entries={logEntries}", (c, r) =>
            {
                Interface.CallHook("OnEntriesUploaded", c, r);
            });
        }
        #endregion

        #region Clan/Team Helpers
        List<ulong> GetTeamMembers(ulong userid) => RelationshipManager.ServerInstance.FindPlayersTeam(userid)?.members;
        string GetClanTag(string userid) => Clans?.Call<string>("GetClanOf", userid);
        List<ulong> GetClan(string userid) => Clans?.Call<JObject>("GetClan", GetClanTag(userid))?.GetValue("members").ToObject<List<ulong>>();
        #endregion

        #region Configuration
        private class SAConfig
        {
            // Config default vars
            public string ServerIp = "";
            public bool Debug = false;
            public bool ShowProtectedMsg = true;
            public bool AutoKickOn = true;
            public bool EnableTotalBanKick = false;

            public int AutoKickCeiling = 3;
            public int AutoVacBanCeiling = 1;
            public int AutoGameBanCeiling = 2;
            public int AutoTotalBanCeiling = 30;

            public int DissallowVacBanDays = 90;
            public int BroadcastPlayerBanReportVacDays = 120;

            public bool AutoKickFamilyShare = false;
            public bool AutoKickFamilyShareIfDirty = false;
            public string BetterChatDirtyPlayerTag = string.Empty;
            public bool BroadcastPlayerBanReport = true;
            public bool BroadcastNewBans = true;
            public bool BroadcastKicks = false;
            public bool ServerAdminShareDetails = true;
            public string ServerAdminName = string.Empty;
            public string ServerAdminEmail = string.Empty;
            public string ServerApiKey = string.Empty;
            public string SteamApiKey = string.Empty;

            public bool AutoKick_KickHiddenLevel = false;
            public int AutoKick_MinSteamProfileLevel = -1;
            public bool AutoKick_KickPrivateProfile = false;
            public bool AutoKick_KickWeirdSteam64 = true;

            public bool AutoKick_KickTwitterGameBanned = false;
            public bool AutoKick_BadIp = true;
            public bool AutoKick_BadIp_IgnoreComputing = true;

            public string DiscordWebhookURL = DISCORD_INTRO_URL;
            public string DiscordBanWebhookURL = DISCORD_INTRO_URL;
            public bool DiscordQuickConnect = true;
            public bool DiscordOnlySendDirtyReports = true;
            public bool DiscordJoinReports = true;
            public bool DiscordKickReport = true;
            public bool DiscordBanReport = true;
            public bool DiscordNotifyGameBan = true;
            public bool SubmitArkanData = true;
            public bool RconBroadcast = false;
            public bool AutoKick_IgnoreNvidia = true;
            public bool AutoKick_NetworkBan = true;
            public bool AutoKick_ActiveBans = false; 
            public bool AutoKick_SameServerIp = false;

            public string OwnerSteamId = "";
            public string ClanBanPrefix = "Assoc Ban -> {playerId}: {reason}";
            public bool ClanBanTeams = true;
            public bool IgnoreAdmins = true;
            public bool UseEloSystem = true;

            public int AutoKickMaxPing = 250;
            public string AutoKickLimitCountry = "";

            public string IconSteamId = "76561199044451528";
            public bool IgnoreCheatDetected = true;

            // Plugin reference
            private ServerArmour _plugin;
            public SAConfig(ServerArmour plugin)
            {
                this._plugin = plugin;
                /**
                 * Load all saved config values
                 * */
                GetConfig(ref ServerIp, "Server Info", "Your Server IP");

                GetConfig(ref IgnoreAdmins, "General", "Ignore Admins");
                GetConfig(ref Debug, "General", "Debug: Show additional debug console logs");
                GetConfig(ref IconSteamId, "General", "SteamID for message icon");


                GetConfig(ref ShowProtectedMsg, "Show Protected MSG");
                GetConfig(ref BetterChatDirtyPlayerTag, "Better Chat: Tag for dirty users");

                GetConfig(ref BroadcastPlayerBanReport, "Broadcast", "Player Reports");
                GetConfig(ref BroadcastPlayerBanReportVacDays, "Broadcast", "When VAC is younger than");
                GetConfig(ref BroadcastNewBans, "Broadcast", "New bans");
                GetConfig(ref BroadcastKicks, "Broadcast", "Kicks");
                GetConfig(ref RconBroadcast, "Broadcast", "RCON");

                GetConfig(ref ServerAdminShareDetails, "io.serverarmour.com", "Share details with other server owners");
                GetConfig(ref ServerApiKey, "io.serverarmour.com", "Server Key");
                GetConfig(ref SteamApiKey, "io.serverarmour.com", "Steam API Key");
                GetConfig(ref ServerAdminName, "io.serverarmour.com", "Owner Real Name");
                GetConfig(ref ServerAdminEmail, "io.serverarmour.com", "Owner Email");
                GetConfig(ref OwnerSteamId, "io.serverarmour.com", "Owner Steam64 ID");
                GetConfig(ref SubmitArkanData, "io.serverarmour.com", "Submit Arkan Data");

                GetConfig(ref AutoKickOn, "Auto Kick", "Enabled");

                GetConfig(ref AutoKick_NetworkBan, "Auto Kick", "Bans on your network");
                GetConfig(ref AutoKick_SameServerIp, "Auto Kick", "Bans from your server ip");
                GetConfig(ref AutoKick_ActiveBans, "Auto Kick", "Alts that have active bans on your servers");

                GetConfig(ref AutoKickCeiling, "Auto Kick", "Max allowed previous bans");
                GetConfig(ref AutoTotalBanCeiling, "Auto Kick", "Max allowed total bans (server + game + vac)");
                GetConfig(ref EnableTotalBanKick, "Auto Kick", "Enable Total bans (server + game + vac) kick");

                GetConfig(ref AutoKick_BadIp, "Auto Kick", "VPN", "Enabled");
                GetConfig(ref AutoKick_IgnoreNvidia, "Auto Kick", "VPN", "Ignore nVidia Cloud Gaming");

                GetConfig(ref AutoKick_KickTwitterGameBanned, "Auto Kick", "Users that have been banned on rusthackreport");

                GetConfig(ref AutoKick_KickPrivateProfile, "Auto Kick", "Steam", "Private Steam Profiles");
                GetConfig(ref AutoKick_KickHiddenLevel, "Auto Kick", "Steam", "When Steam Level Hidden");
                GetConfig(ref AutoKick_MinSteamProfileLevel, "Auto Kick", "Steam", "Min Allowed Steam Level (-1 disables)");
                GetConfig(ref AutoKick_KickWeirdSteam64, "Auto Kick", "Steam", "Profiles that do no conform to the Steam64 IDs (Highly recommended)");
                GetConfig(ref AutoVacBanCeiling, "Auto Kick", "Steam", "Max allowed VAC bans");
                GetConfig(ref AutoGameBanCeiling, "Auto Kick", "Steam", "Max allowed Game bans");
                GetConfig(ref DissallowVacBanDays, "Auto Kick", "Steam", "Min age of VAC ban allowed");
                GetConfig(ref AutoKickFamilyShare, "Auto Kick", "Steam", "Family share accounts");
                GetConfig(ref AutoKickFamilyShareIfDirty, "Auto Kick", "Steam", "Family share accounts that are dirty");

                GetConfig(ref AutoKickMaxPing, "Auto Kick", "Ping", "Max Ping Allowed");
                GetConfig(ref AutoKickLimitCountry, "Auto Kick", "Ping", "Limit players ONLY to this country ISO code, kick rest");

                GetConfig(ref DiscordWebhookURL, "Discord", "Webhook URL");
                GetConfig(ref DiscordBanWebhookURL, "Discord", "Bans Webhook URL");
                GetConfig(ref DiscordQuickConnect, "Discord", "Show Quick Connect On report");
                GetConfig(ref DiscordJoinReports, "Discord", "Send Join Player Reports");
                GetConfig(ref DiscordOnlySendDirtyReports, "Discord", "Send Only Dirty Player Reports");
                GetConfig(ref DiscordNotifyGameBan, "Discord", "Notify when a player has received a game ban");
                GetConfig(ref DiscordKickReport, "Discord", "Send Kick Report");
                GetConfig(ref DiscordBanReport, "Discord", "Send Ban Report");

                GetConfig(ref ClanBanPrefix, "Clan Ban", "Reason Prefix");
                GetConfig(ref ClanBanTeams, "Clan Ban", "Ban Native Team Members");

                GetConfig(ref IgnoreCheatDetected, "Anti Hack", "Ignore Cheat Detected");

                GetConfig(ref UseEloSystem, "Plugin", "Use ELO system?");

                plugin.SaveConfig();
            }

            private void GetConfig<T>(ref T variable, params string[] path)
            {
                if (path.Length == 0) return;

                if (_plugin.Config.Get(path) == null)
                {
                    SetConfig(ref variable, path);
                    _plugin.PrintWarning($"Added new field to config: {string.Join("/", path)}");
                }

                variable = (T)Convert.ChangeType(_plugin.Config.Get(path), typeof(T));
            }

            public void SetConfig<T>(ref T variable, params string[] path) => _plugin.Config.Set(path.Concat(new object[] { variable }).ToArray());
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file.");
        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = new SAConfig(this);
            }
            catch (InvalidCastException)
            {
                PrintError("Your config seems to be corrupted.");
                Interface.Oxide.UnloadPlugin(Name);
            }
        }
        #endregion
    }
}

// --- End of file: ServerArmour.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/scientist-names ---
// --- Original File Path: S/ScientistNames/ScientistNames.cs ---

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Scientist Names", "Ultra", "1.2.2")]
    [Description("Gives real names to scientists, bandits, murderers, tunnel dwellers and scarecrows (instead of numbers)")]

    class ScientistNames : RustPlugin
    {
        System.Random rnd;
        bool initialized = false;
        int renameCount = 0;
        List<string> surnameList = new List<string>();
        List<string> currentActiveNames = new List<string>();
        private string additionPermission = "scientistnames.addition";         

        #region Hooks

        void OnServerInitialized()
        {
            permission.RegisterPermission(additionPermission, this);
            
            LoadConfig();

            rnd = new System.Random();
            renameCount = 0;

            foreach (BaseNetworkable baseNetworkable in BaseNetworkable.serverEntities.Where(w => w is BasePlayer && (w is NPCPlayer)).Cast<BasePlayer>())
            {
                if (!baseNetworkable.ShortPrefabName.Contains("scientist") && !baseNetworkable.ShortPrefabName.Contains("tunneldweller") && !baseNetworkable.ShortPrefabName.Contains("bandit") && !baseNetworkable.ShortPrefabName.Contains("murderer") && !baseNetworkable.ShortPrefabName.Contains("scarecrow")) continue;

                BasePlayer basePlayer = (BasePlayer)baseNetworkable;
                string oldName = basePlayer.displayName;
                RenameBasePlayer(basePlayer, GetAbbrevation(basePlayer));
                if (oldName != basePlayer.displayName)
                {
                    Log($"{oldName} renamed to {basePlayer.displayName}", console: true);
                    renameCount++;
                }
            }

            Log($"{renameCount} scientists (bandits, murderers, scarecrows, tunnel dwellers) renamed", console: true);
            if (currentActiveNames.Count - renameCount > 0) Log($"{currentActiveNames.Count - renameCount} already named scientists (bandits, murderers, scarecrows, tunnel dwellers) found", console: true);

            initialized = true;
        }

        void OnEntitySpawned(BaseEntity entity)
        {
            if (initialized && entity is BasePlayer && entity is NPCPlayer)
            {
                BasePlayer basePlayer = (BasePlayer)entity;
                string oldName = basePlayer.displayName;
                RenameBasePlayer(basePlayer, GetAbbrevation(basePlayer));

                if (oldName != basePlayer.displayName)
                {
                    Log($"{oldName} renamed to {basePlayer.displayName}", console: true);
                }
            }
        }

        void OnDeathNotice(Dictionary<string, object> data, string message)
        {
            if (!initialized) return;
            object victim = data["VictimEntity"];
            if (victim == null) return;

            BasePlayer basePlayer = victim as BasePlayer;

            if (basePlayer != null && currentActiveNames.Contains(basePlayer.displayName))
            {
                currentActiveNames.Remove(basePlayer.displayName);
            }
        }

        #endregion

        #region Commands

        [ConsoleCommand("addname")]
        void AddNameConsoleCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (initialized && permission.UserHasPermission(player.UserIDString, additionPermission))
            {
                if (arg.Args.Length > 0)
                {
                    string nameString = string.Join(" ", arg.Args, 0, arg.Args.Length);
                    foreach (string name in nameString.Split(','))
                    {
                        AddName(name);
                    }
                    SaveConfig();
                }
            }
        }

        [ChatCommand("addname")]
        void AddNameChatCommand(BasePlayer player, string command, string[] args)
        {
            if (initialized && permission.UserHasPermission(player.UserIDString, additionPermission))
            {
                if (args.Length > 0)
                {
                    string nameString = string.Join(" ", args, 0, args.Length);
                    foreach (string name in nameString.Split(','))
                    {
                        AddName(name);
                    }
                    SaveConfig();
                }
            }
            else
            {
                SendReply(player, "You don't have the permissions to use this command");
            }
        }

        void AddName(string name)
        {
            if (name == null) return;
            if (!surnameList.Contains(name, StringComparer.OrdinalIgnoreCase))
            {
                surnameList.Add(name.Trim());   
            }

            configData.SurnameList = string.Join(",", surnameList.OrderBy(o => o).Where(w => w.Length > 0).Distinct().Select(s => s.Trim()));
        }

        #endregion

        #region Core

        void RenameBasePlayer(BasePlayer basePlayer, string abbrevation)
        {
            for (int attempt = 0; attempt < 5; attempt++)
            {
                string newName = RenameBasePlayer(abbrevation);
                if (!string.IsNullOrEmpty(newName))
                {
                    basePlayer.displayName = newName;
                    return;
                }
            }

            Log("Name generator failed: no unique name found", console: true, logType: LogType.ERROR);

            if (!string.IsNullOrEmpty(basePlayer.displayName)) currentActiveNames.Add(basePlayer.displayName);
        }

        string RenameBasePlayer(string abbrevation)
        {
            if (surnameList.Count > 0)
            {
                string newName = (string.Format("{0} {1} {2}", abbrevation, GetFirstnameFirstLetter().ToUpper(), surnameList[rnd.Next(0, surnameList.Count)].Trim())).Trim().Replace("  ", " ");
                if (!currentActiveNames.Contains(newName))
                {
                    return newName;
                }
            }

            return null;
        }

        string GetAbbrevation(BasePlayer basePlayer)
        {
            if (!configData.UseTitle) return string.Empty;
            else if (basePlayer.ShortPrefabName.Contains("bandit")) return configData.BanditTitle;
            else if (basePlayer.ShortPrefabName.Contains("scientist")) return configData.ScientistTitle;
            else if (basePlayer.ShortPrefabName.Contains("tunneldweller")) return configData.TunnelDwellerTitle;
            else if (basePlayer.ShortPrefabName.Contains("murderer")) return configData.MurdererTitle;
            else if (basePlayer.ShortPrefabName.Contains("scarecrow")) return configData.ScarecrowTitle;
            else
            {
                Log($"Unknown ShortPrefabName: {basePlayer.ShortPrefabName}", console: true, logType: LogType.WARNING);
                return string.Empty;
            }
        }

        string GetFirstnameFirstLetter()
        {
            if (!configData.UseFirstNameFirstLetter) return string.Empty;

            int num = rnd.Next(0, 26); // Zero to 25
            char letter = (char)('a' + num);
            return letter.ToString() + ".";
        }

        #endregion

        #region Config

        private ConfigData configData;

        private class ConfigData 
        {
            [JsonProperty(PropertyName = "UseTitle")]
            public bool UseTitle = true;

            [JsonProperty(PropertyName = "UseFirstNameFirstLetter")]
            public bool UseFirstNameFirstLetter = true;

            [JsonProperty(PropertyName = "ScientistTitle")]
            public string ScientistTitle = "Dr.";

            [JsonProperty(PropertyName = "TunnelDwellerTitle")]
            public string TunnelDwellerTitle = "guard";

            [JsonProperty(PropertyName = "BanditTitle")]
            public string BanditTitle = "bandit";

            [JsonProperty(PropertyName = "MurdererTitle")]
            public string MurdererTitle = "murderer";

            [JsonProperty(PropertyName = "ScarecrowTitle")]
            public string ScarecrowTitle = "scare";

            [JsonProperty(PropertyName = "SurnameList")]
            public string SurnameList = "Smith, Johnson, Williams, Jones, Brown, Davis, Miller, Wilson, Moore, Taylor, Anderson, Thomas, Jackson, White, Harris, Martin, Thompson, Garcia, Martinez, Robinson, Clark, Rodriguez, Lewis, Lee, Walker, Hall, Allen, Young, Hernandez, King, Wright, Lopez, Hill, Scott, Green, Adams, Baker, Gonzalez, Nelson, Carter, Mitchell, Perez, Roberts, Turner, Phillips, Campbell, Parker, Evans, Edwards, Collins, Stewart, Sanchez, Morris, Rogers, Reed, Cook, Morgan, Bell, Murphy, Bailey, Rivera, Cooper, Richardson, Cox, Howard, Ward, Torres, Peterson, Gray, Ramirez, James, Watson, Brooks, Kelly, Sanders, Price, Bennett, Wood, Barnes, Ross, Henderson, Coleman, Jenkins, Perry, Powell, Long, Patterson, Hughes, Flores, Washington, Butler, Simmons, Foster, Gonzales, Bryant, Alexander, Russell, Griffin, Diaz, Hayes, Myers, Ford, Hamilton, Graham, Sullivan, Wallace, Woods, Cole, West, Jordan, Owens, Reynolds, Fisher, Ellis, Harrison, Gibson, McDonald, Cruz, Marshall, Ortiz, Gomez, Murray, Freeman, Wells, Webb, Simpson, Stevens, Tucker, Porter, Hunter, Hicks, Crawford, Henry, Boyd, Mason, Morales, Kennedy, Warren, Dixon, Ramos, Reyes, Burns, Gordon, Shaw, Holmes, Rice, Robertson, Hunt, Black, Daniels, Palmer, Mills, Nichols, Grant, Knight, Ferguson, Rose, Stone, Hawkins, Dunn, Perkins, Hudson, Spencer, Gardner, Stephens, Payne, Pierce, Berry, Matthews, Arnold, Wagner, Willis, Ray, Watkins, Olson, Carroll, Duncan, Snyder, Hart, Cunningham, Bradley, Lane, Andrews, Ruiz, Harper, Fox, Riley, Armstrong, Carpenter, Weaver, Greene, Lawrence, Elliott, Chavez, Sims, Austin, Peters, Kelley, Franklin, Lawson, Fields, Gutierrez, Ryan, Schmidt, Carr, Vasquez, Castillo, Wheeler, Chapman, Oliver, Montgomery, Richards, Williamson, Johnston, Banks, Meyer, Bishop, McCoy, Howell, Alvarez, Morrison, Hansen, Fernandez, Garza, Harvey, Little, Burton, Stanley, Nguyen, George, Jacobs, Reid, Kim, Fuller, Lynch, Dean, Gilbert, Garrett, Romero, Welch, Larson, Frazier, Burke, Hanson, Day, Mendoza, Moreno, Bowman, Medina, Fowler, Brewer, Hoffman, Carlson, Silva, Pearson, Holland, Douglas, Fleming, Jensen, Vargas, Byrd, Davidson, Hopkins, May, Terry, Herrera, Wade, Soto, Walters, Curtis, Neal, Caldwell, Lowe, Jennings, Barnett, Graves, Jimenez, Horton, Shelton, Barrett, Obrien, Castro, Sutton, Gregory, Mckinney, Lucas, Miles, Craig, Rodriquez, Chambers, Holt, Lambert, Fletcher, Watts, Bates, Hale, Rhodes, Pena, Beck, Newman, Haynes, McDaniel, Mendez, Bush, Vaughn, Parks, Dawson, Santiago, Norris, Hardy, Love, Steele, Curry, Powers, Schultz, Barker, Guzman, Page, Munoz, Ball, Keller, Chandler, Weber, Leonard, Walsh, Lyons, Ramsey, Wolfe, Schneider, Mullins, Benson, Sharp, Bowen, Daniel, Barber, Cummings, Hines, Baldwin, Griffith, Valdez, Hubbard, Salazar, Reeves, Warner, Stevenson, Burgess, Santos, Tate, Cross, Garner, Mann, Mack, Moss, Thornton, Dennis, McGee, Farmer, Delgado, Aguilar, Vega, Glover, Manning, Cohen, Harmon, Rodgers, Robbins, Newton, Todd, Blair, Higgins, Ingram, Reese, Cannon, Strickland, Townsend, Potter, Goodwin, Walton, Rowe, Hampton, Ortega, Patton, Swanson, Joseph, Francis, Goodman, Maldonado, Yates, Becker, Erickson, Hodges, Rios, Conner, Adkins, Webster, Norman, Malone, Hammond, Flowers, Cobb, Moody, Quinn, Blake, Maxwell, Pope, Floyd, Osborne, Paul, McCarthy, Guerrero, Lindsey, Estrada, Sandoval, Gibbs, Tyler, Gross, Fitzgerald, Stokes, Doyle, Sherman, Saunders, Wise, Colon, Gill, Alvarado, Greer, Padilla, Simon, Waters, Nunez, Ballard, Schwartz, McBride, Houston, Christensen, Klein, Pratt, Briggs, Parsons, McLaughlin, Zimmerman, French, Buchanan, Moran, Copeland, Roy, Pittman, Brady, McCormick, Holloway, Brock, Poole, Frank, Logan, Owen, Bass, Marsh, Drake, Wong, Jefferson, Park, Morton, Abbott, Sparks, Patrick, Norton, Huff, Clayton, Massey, Lloyd, Figueroa, Carson, Bowers, Roberson, Barton, Tran, Lamb, Harrington, Casey, Boone, Cortez, Clarke, Mathis, Singleton, Wilkins, Cain, Bryan, Underwood, Hogan, Mckenzie, Collier, Luna, Phelps, McGuire, Allison, Bridges, Wilkerson, Nash, Summers, Atkins";

            [JsonProperty(PropertyName = "LogInFile")]
            public bool LogInFile = true;

            [JsonProperty(PropertyName = "LogInConsole")]
            public bool LogInConsole = true;
        }

        protected override void LoadConfig()
        {
            try
            {
                base.LoadConfig();
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                } 
            }
            catch
            {
                LoadDefaultConfig();
            }
          
            surnameList = configData.SurnameList.Split(',').Distinct().ToList();

            SaveConfig();
        }

        protected override void SaveConfig()
        {            
            Config.WriteObject(configData, true);            
            base.SaveConfig();
        }

        #endregion

        #region Log

        void Log(string message, bool console = false, LogType logType = LogType.INFO, string fileName = "")
        {
            if (string.IsNullOrEmpty(fileName)) fileName = this.Title;

            if (configData.LogInFile)
            {
                LogToFile(fileName, $"[{DateTime.Now.ToString("hh:mm:ss")}] {logType} > {message}", this);
            }

            if (configData.LogInConsole)
            {
                Puts($"{message.Replace("\n", " ")}");
            }
        }

        enum LogType
        {
            INFO = 0,
            WARNING = 1,
            ERROR = 2
        }

        #endregion
    }
}

// --- End of file: ScientistNames.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/solar-panel-tweaker ---
// --- Original File Path: S/SolarPanelTweaker/SolarPanelTweaker.cs ---

using System.Collections.Generic;   //list.config
using System;   //Convert

namespace Oxide.Plugins
{
    [Info("Solar Panel Tweaker", "BuzZ", "0.0.2")]
    [Description("Change Solar Panel Attributes")]

/*======================================================================================================================= 
*   
*   17th december 2018
*
*   0.0.1   20181217    creation
*   0.0.2   20181227    fix mistake in bool
*
*	THANKS TO THE OXIDE/UMOD TEAM for coding quality, ideas, and time spent for the community
*
*=======================================================================================================================*/

    public class SolarPanelTweaker : RustPlugin
    {
        bool debug = false;
        private bool ConfigChanged;
        const string Tweaker = "solarpaneltweaker.tweak"; 
        int MaxiPowa = 20;
        bool SolarWorld = false;

		void Init()
        {
            LoadVariables();
            permission.RegisterPermission(Tweaker, this);
        }

        private void OnServerInitialized()
        {
            if (SolarWorld) SetASolarWorld();
        }

        protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {
            MaxiPowa = Convert.ToInt32(GetConfig("Solar Panel Settings", "Maximum Power Output", "20"));    
            SolarWorld = Convert.ToBoolean(GetConfig("Solar Panel", "Setting for all World", "false"));    

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

/////// ON LOAD FIND
        void SetASolarWorld()
        {
            foreach (var solarpanel in UnityEngine.Object.FindObjectsOfType<SolarPanel>())
            {
                SolarPanelTweakerizer(solarpanel);
            }
        }

// FOR FUTURE USE
        /*List<SolarPanel> SolarPanelSpawned = new List<SolarPanel>();
        void OnServerInitialized()
        {
            timer.Every(10f, () =>
            {
                insidetimerstuff();
            });
        }*/

        void OnEntitySpawned(BaseNetworkable entity)
        {
    	    SolarPanel solarpanel = entity.GetComponent<SolarPanel>();
            if (solarpanel != null)
            {
                if (debug) Puts($"SOLAR PANEL SPAWN !");
                bool istweaker = permission.UserHasPermission(solarpanel.OwnerID.ToString(), Tweaker);
                if (SolarWorld || istweaker)
                {
                    SolarPanelTweakerizer(solarpanel);
                }
                //SolarPanelSpawned.Add(solarpanel);
            }
        }

        void SolarPanelTweakerizer(SolarPanel solarpanel)
        {
            solarpanel.maximalPowerOutput = MaxiPowa;
            if (debug) Puts($"ConsumptionAmount {solarpanel.ConsumptionAmount()}");   //0
            if (debug) Puts($"dot_maximum {solarpanel.dot_maximum}");   //0.7
            if (debug) Puts($"dot_minimum {solarpanel.dot_minimum}");   //0.3
            if (debug) Puts($"maximalPowerOutput {solarpanel.maximalPowerOutput}");    //20
        }

// FOR FUTURE USE
        /*void insidetimerstuff()
        {
            if (SolarPanelSpawned == null) return;
            foreach (var solarpanel in SolarPanelSpawned)
            {
                if (debug) Puts($"ConsumptionAmount {solarpanel.ConsumptionAmount()}");   //0
                if (debug) Puts($"dot_maximum {solarpanel.dot_maximum}");   //0.7
                if (debug) Puts($"dot_minimum {solarpanel.dot_minimum}");   //0.3
            }
        }*/
    }
}


// --- End of file: SolarPanelTweaker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/suicide-and-kill ---
// --- Original File Path: S/SuicideKill/SuicideKill.cs ---

ï»¿using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("SuicideKill", "Ankawi", "1.0.1")]
    [Description("Allows you to suicide, kill, or hurt players through chat and/or console commands")]
    class SuicideKill : CovalencePlugin
    {
        private const string killPerm = "suicidekill.kill";
        private const string hurtPerm = "suicidekill.hurt";
        private const string suicidePerm = "suicidekill.suicide";

        private void Init()
        {
            LoadDefaultMessages();
            permission.RegisterPermission(killPerm, this);
            permission.RegisterPermission(hurtPerm, this);
            permission.RegisterPermission(suicidePerm, this);
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["YouWereKilled"] = "You were killed by {0}",
                ["YouWereHurt"] = "You were damaged for {0} health by {1}",
                ["Suicide"] = "You killed yourself",
                ["PlayerNotFound"] = "{0} was not found",
                ["TargetSyntax"] = "{0} <target>",
                ["SuicideSyntax"] = "{0}",
                ["HurtSyntax"] = "{0} <target> <amount>",
                ["NoAccess"] = "You don't have access to this command"
            }, this, "en");
        }
        [Command("kill")]
        private void KillCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(killPerm))
            {
                player.Reply(GetMsg("NoAccess", player.Id));
                return;
            }
            if (args.Length == 0)
            {
                player.Reply(GetMsg("TargetSyntax", player.Id, command));
                return;
            }

            var target = players.FindPlayer(args[0]);

            if (target == null || !target.IsConnected)
            {
                player.Reply(GetMsg("PlayerNotFound", player.Id, args[0].Sanitize()));
                return;
            }
            target.Kill();
            target.Message(GetMsg("YouWereKilled", target.Id, player.Name.Sanitize()));
        }

        [Command("suicide")]
        private void SuicideCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(suicidePerm))
            {
                player.Reply(GetMsg("NoAccess", player.Id));
                return;
            }
            if (args.Length != 0)
            {
                player.Reply(GetMsg("SuicideSyntax", player.Id, command));
                return;
            }
            player.Hurt(1000);
            player.Reply(GetMsg("Suicide", player.Id));
        }

        [Command("hurt")]
        private void DamageCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(hurtPerm))
            {
                player.Reply(GetMsg("NoAccess", player.Id));
                return;
            }
            if (args.Length != 2)
            {
                player.Reply(GetMsg("HurtSyntax", player.Id, command));
                return;
            }
            var target = players.FindPlayer(args[0]);

            if (target == null || !target.IsConnected)
            {
                player.Reply(GetMsg("PlayerNotFound", player.Id, args[0].Sanitize()));
                return;
            }

            float amount = float.Parse(args[1]);
            target.Hurt(amount);
            target.Message(GetMsg("YouWereHurt", target.Id, amount, player.Name.Sanitize()));
        }

        #region Helpers

        private string GetMsg(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}

// --- End of file: SuicideKill.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/simple-loot ---
// --- Original File Path: S/SimpleLoot/SimpleLoot.cs ---

ï»¿using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Simple Loot", "MisterPixie", "1.0.91")]
    [Description("Sets multipliers for any item of your choosing")]
    public class SimpleLoot : RustPlugin
    {
        private static SimpleLoot _instance;

        private Configuration _configuration;

        private void Init()
        {
            Unsubscribe("OnLootSpawn");
            _instance = this;
        }

        private void OnServerInitialized()
        {
            _configuration = new Configuration();
            var containers = UnityEngine.Object.FindObjectsOfType<LootContainer>();
            for (var i = 0; i < containers.Length; i++)
            {
                OnLootSpawn(containers[i]);
                if (i == containers.Length - 1)
                    PrintWarning($"Repopulating {i} loot containers.");
            }

            Subscribe("OnLootSpawn");
        }

        private object OnLootSpawn(LootContainer lootContainer)
        {
            if (lootContainer?.inventory?.itemList == null)
                return null;

            foreach (var item in lootContainer.inventory.itemList.ToList())
            {
                item.RemoveFromWorld();
                item.RemoveFromContainer();
            }

            lootContainer.PopulateLoot();

            foreach (var item in lootContainer.inventory.itemList.ToList())
            {
                var itemBlueprint = ItemManager.FindItemDefinition(item.info.shortname).Blueprint;
                if (_configuration.ReplaceItems && itemBlueprint != null && itemBlueprint.isResearchable)
                {
                    var slot = item.position;
                    item.RemoveFromWorld();
                    item.RemoveFromContainer();
                    var blueprint = ItemManager.CreateByName("blueprintbase");
                    blueprint.blueprintTarget = item.info.itemid;
                    blueprint.MoveToContainer(lootContainer.inventory, slot);
                }
                else
                {
                    object multiplier;
                    if (_configuration.Multipliers.TryGetValue(item.info.shortname, out multiplier))
                        item.amount *= Convert.ToInt32(multiplier);
                }
            }

            if (lootContainer.shouldRefreshContents)
            {
                lootContainer.Invoke(new Action(lootContainer.SpawnLoot), UnityEngine.Random.Range(lootContainer.minSecondsBetweenRefresh, lootContainer.maxSecondsBetweenRefresh));
            }

            return true;

        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new config file...");

        private class Configuration
        {
            public readonly Dictionary<string, object> Multipliers = new Dictionary<string, object>
            {
                {"scrap", 1}
            };

            public readonly bool ReplaceItems;

            public Configuration()
            {
                GetConfig(ref Multipliers, "Settings", "Multipliers");

                GetConfig(ref ReplaceItems, "Settings", "Replace items with blueprints");

                foreach (var itemDefinition in ItemManager.itemList.Where(x => x?.category == ItemCategory.Component))
                {
                    if (itemDefinition.shortname == "bleach" || itemDefinition.shortname == "ducttape" ||
                        itemDefinition.shortname == "glue" || itemDefinition.shortname == "sticks")
                        continue;

                    if (Multipliers.ContainsKey(itemDefinition.shortname))
                        continue;

                    Multipliers.Add(itemDefinition.shortname, 1);
                }

                _instance.SaveConfig();
            }

            private void GetConfig<T>(ref T variable, params string[] path)
            {
                if (path.Length == 0) return;

                if (_instance.Config.Get(path) == null)
                {
                    SetConfig(ref variable, path);
                    _instance.PrintWarning($"Added field to config: {string.Join("/", path)}");
                }

                variable = (T)Convert.ChangeType(_instance.Config.Get(path), typeof(T));
            }

            private void SetConfig<T>(ref T variable, params string[] path) => _instance.Config.Set(path.Concat(new object[] { variable }).ToArray());
        }
    }
}

// --- End of file: SimpleLoot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/survey-blocker ---
// --- Original File Path: S/SurveyBlocker/SurveyBlocker.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SurveyBlocker", "miRror", "1.0.1")]
	
    class SurveyBlocker : RustPlugin
    {
		private float cooldownTime = 20;
		private uint surveyID = 2141863453;	
		
		private Dictionary<ulong, float> p = new Dictionary<ulong, float>();
		
		private void Init()
		{
			Dictionary<string, Dictionary<string, string>> compiledLangs = new Dictionary<string, Dictionary<string, string>>();
			
			foreach(var line in messages)
			{
				foreach(var translate in line.Value)
				{
					if(!compiledLangs.ContainsKey(translate.Key))
						compiledLangs[translate.Key] = new Dictionary<string, string>();
					
					compiledLangs[translate.Key][line.Key] = translate.Value;
				}				
			}
			
			foreach(var cLangs in compiledLangs)
			{
				lang.RegisterMessages(cLangs.Value, this, cLangs.Key);
			}
		}
		
		private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
		{
			if(info.WeaponPrefab == null || info.WeaponPrefab.prefabID != surveyID)
				return null;
			
			BasePlayer attacker = info.InitiatorPlayer;
			
			if(attacker != null)
			{
				if(!p.ContainsKey(attacker.userID) || p[attacker.userID] < Time.realtimeSinceStartup)
					SendReply(attacker, Lang("USE_SURVEY", attacker.UserIDString));
				
				p[attacker.userID] = Time.realtimeSinceStartup + cooldownTime;
			}
			
			return false;
		}

		private void OnPlayerDisconnected(BasePlayer player) => p.Remove(player.userID);
		
		private string Lang(string key, string userID = null, params object[] args) => string.Format(lang.GetMessage(key, this, userID), args);
		
  		private readonly Dictionary<string, Dictionary<string, string>> messages = new Dictionary<string, Dictionary<string, string>> 
		{
            {"USE_SURVEY", new Dictionary<string, string>() {
				{"ru", "Ð£ÑÐ¾Ð½ Ð¾Ñ Ð³ÐµÐ¾Ð»Ð¾Ð³Ð¸ÑÐµÑÐºÐ¸Ñ Ð·Ð°ÑÑÐ´Ð¾Ð² <color=orange>Ð¾ÑÐºÐ»ÑÑÐµÐ½</color>"},
				{"en", "Damage for survey charges <color=orange>disabled</color>"}
			}}
		};
	}
}

// --- End of file: SurveyBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/scheduled-spawns ---
// --- Original File Path: S/ScheduledSpawns/ScheduledSpawns.cs ---

ï»¿using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using System.Globalization;
using Newtonsoft.Json;
using WebSocketSharp;

namespace Oxide.Plugins
{
    [Info("Scheduled Spawns", "1AK1", "1.0.2")]
    [Description("Spawn any item or prefab on a schedule")]
    internal class ScheduledSpawns : CovalencePlugin
    {
        #region Vars

        private Dictionary<string, Timer> prefabTimers = new Dictionary<string, Timer>();
        private Dictionary<string, Timer> itemTimers = new Dictionary<string, Timer>();
        private const string permUse = "scheduledspawns.use";

        #endregion

        #region Config       

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Default timer (s)")]
            public float DefaultTimer { get; set; }

            [JsonProperty(PropertyName = "Check radius")]
            public float CheckRadius { get; set; }

        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                DefaultTimer = 300f,
                CheckRadius = 1f
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        #endregion Config

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["PlayersOnly"] = "Command '{0}' can only be used by players",
                ["UsageScheduledSpawns"] = "Usage {0} <item|prefab> <add|remove|list|start|stop>",
                ["UsageItemAddCommand"] = "Usage {0} item add <itemshortname> <timer> <name>",
                ["UsagePrefabAddCommand"] = "Usage {0} prefab add <prefabpath> <timer> <name>",
                ["UsageItemRemoveCommand"] = "Usage {0} item remove <name>",
                ["UsagePrefabRemoveCommand"] = "Usage {0} prefab remove <name>",
                ["AlreadyExist"] = "{0} already exist",
                ["NameDoesNotExist"] = "{0} does not exist",
                ["NameAdded"] = "{0} added successfully",
                ["NameRemoved"] = "{0} removed successfully",
                ["ItemSpawnStart"] = "Item spawn started",
                ["ItemSpawnStop"] = "Item spawn stopped",
                ["PrefabSpawnStart"] = "Prefab spawn started",
                ["PrefabSpawnStop"] = "Prefab spawn stopped",
                ["UnknownCommand"] = "Unknown command",
            }, this);
        }

        #endregion Localization

        #region Oxide Hooks

        private void Init()
        {
            AddCovalenceCommand("ss", "SpawnCommand");
            permission.RegisterPermission(permUse, this);
        }

        private void OnNewSave(string file)
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile(filename))
            {
                Interface.Oxide.DataFileSystem.GetFile(filename).Clear();
                Interface.Oxide.DataFileSystem.GetFile(filename).Save();
            }
        }

        private void OnServerInitialized(bool initial)
        {
            LoadData();
            SpawnPrefabsInData();
            SpawnItemsInData();
        }

        #endregion

        #region Core

        private void SpawnPrefabsInData()
        {
            foreach (var data in _data._prefabContainer)
            {
                Vector3 position = StringToVector3(data.Value["Location"]);

                float time = configData.DefaultTimer;

                try
                {
                    time = float.Parse(data.Value["Timer"], CultureInfo.InvariantCulture.NumberFormat);
                }
                catch (FormatException)
                {
                    Puts("'{0}' is invalid using {1}.", data.Value["Timer"], configData.DefaultTimer);
                }
            
                string name = data.Key;

                if (data.Value["Prefab"].IsNullOrEmpty())
                {
                    continue;
                }

                if (!prefabTimers.ContainsKey(name))
                {
                    prefabTimers[name] = timer.Every(time, () =>
                    {
                        var entities = FindEntities<BaseEntity>(position, configData.CheckRadius);

                        if (entities.Count == 0)
                        {
                            SpawnPrefab(data.Value["Prefab"], position);
                        }
                    });
                }
            }
        }

        private void SpawnItemsInData()
        {
            foreach (var data in _data._itemContainer)
            {
                Vector3 position = StringToVector3(data.Value["Location"]);
                position.y = position.y + 1;

                float time = configData.DefaultTimer;

                try
                {
                    time = float.Parse(data.Value["Timer"], CultureInfo.InvariantCulture.NumberFormat);
                }
                catch (FormatException)
                {
                    Puts("'{0}' is invalid using {1}.", data.Value["Timer"], configData.DefaultTimer);
                }

                string name = data.Key;

                if (data.Value["ItemShortName"].IsNullOrEmpty())
                {
                    continue;
                }

                if (!itemTimers.ContainsKey(name))
                {
                    itemTimers[name] = timer.Every(time, () =>
                    {
                        var entities = FindEntities<BaseEntity>(position, configData.CheckRadius);

                        if (entities.Count == 0)
                        {
                            SpawnItem(data.Value["ItemShortName"], position);
                        }                      
                    });
                }
            }
        }

        private void SpawnPrefab(string prefabname, Vector3 position)
        {
            var entity = GameManager.server.CreateEntity(prefabname, position) as BaseEntity;

            if (entity == null)
            {
                return;
            }
            else
            {
                entity.Spawn();
            }
        }

        private void SpawnItem(string itemname, Vector3 position)
        {
            Item item = ItemManager.CreateByName(itemname, 1);

            if (item == null)
            {
                return;
            }
            else
            {
                item.CreateWorldObject(position);
            }
        }

        #endregion

        #region Commands

        private void SpawnCommand(IPlayer player, string command, string[] args)
        {

            if (player.IsServer)
            {
                Message(player, "PlayersOnly", command);
                return;
            }

            if (!player.HasPermission(permUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args == null || args.Length <= 0)
            {
                Message(player, "UsageScheduledSpawns", command);
                return;
            }

            var bplayer = (BasePlayer)player.Object;
            var position = bplayer.transform.position;
            var newPos = GetGroundPosition(position);


            switch (args[0].ToLower())
            {
                case "item":
                    switch (args[1].ToLower())
                    {
                        case "add":
                            if (args.Length != 5)
                            {
                                Message(player, "UsageItemAddCommand", command);
                                
                            }
                            else
                            {
                                if (_data._itemContainer.ContainsKey(args[4]))
                                {
                                    Message(player, "AlreadyExist", args[4]);
                                }
                                else
                                {
                                    Dictionary<string, string> prefabsContainer2 = new Dictionary<string, string>();

                                    prefabsContainer2["ItemShortName"] = args[2];
                                    prefabsContainer2["Location"] = newPos.ToString();
                                    prefabsContainer2["Timer"] = args[3];

                                    _data._itemContainer.Add(args[4], prefabsContainer2);
                                    SaveData();
                                    Message(player, "NameAdded", args[4]);
                                }
                            }
                            break;
                        case "remove":
                            if (args.Length != 3)
                            {
                                Message(player, "UsageItemRemoveCommand", command);
                            }
                            else
                            {
                                if (!_data._itemContainer.ContainsKey(args[2]))
                                {
                                    Message(player, "NameDoesNotExist", args[2]);
                                }
                                else
                                {
                                    _data._itemContainer.Remove(args[2]);
                                    SaveData();
                                    if (itemTimers.ContainsKey(args[2]))
                                    {
                                        itemTimers[args[2]].Destroy();
                                    }
                                    Message(player, "NameRemoved", args[2]);
                                }
                            }
                            break;
                        case "list":
                            foreach (var entry in _data._itemContainer)
                            {
                                player.Message(entry.Key);
                            }
                            break;
                        case "start":
                            SpawnItemsInData();
                            Message(player, "ItemSpawnStart");
                            break;
                        case "stop":
                            foreach (var entry in itemTimers)
                            {
                                entry.Value.Destroy();
                            }
                            itemTimers.Clear();
                            Message(player, "ItemSpawnStop");
                            break;
                        default:
                            Message(player, "UnknownCommand");
                            break;
                    }
                    break;
                case "prefab":
                    switch (args[1].ToLower())
                    {
                        case "add":
                            if (args.Length != 5)
                            {
                                Message(player, "UsagePrefabAddCommand", command);
                            }
                            else
                            {
                                if (_data._prefabContainer.ContainsKey(args[4]))
                                {
                                    Message(player, "AlreadyExist", args[4]);
                                }
                                else
                                {
                                    Dictionary<string, string> prefabsContainer2 = new Dictionary<string, string>();

                                    prefabsContainer2["Prefab"] = args[2];
                                    prefabsContainer2["Location"] = newPos.ToString();
                                    prefabsContainer2["Timer"] = args[3];

                                    _data._prefabContainer.Add(args[4], prefabsContainer2);
                                    SaveData();
                                    Message(player, "NameAdded", args[4]);
                                }
                            }
                            break;
                        case "remove":
                            if (args.Length != 3)
                            {
                                Message(player, "UsagePrefabRemoveCommand", command);
                            }
                            else
                            {
                                if (!_data._prefabContainer.ContainsKey(args[2]))
                                {
                                    Message(player, "NameDoesNotExist", args[2]);
                                }
                                else
                                {
                                    _data._prefabContainer.Remove(args[2]);
                                    SaveData();
                                    if (prefabTimers.ContainsKey(args[2]))
                                    {
                                        prefabTimers[args[2]].Destroy();
                                    }

                                    Message(player, "NameRemoved", args[2]);
                                }
                            }
                            break;
                        case "list":
                            foreach (var entry in _data._prefabContainer)
                            {
                                player.Message(entry.Key);
                            }
                            break;
                        case "start":
                            SpawnPrefabsInData();
                            Message(player, "PrefabSpawnStart");
                            break;
                        case "stop":
                            foreach (var entry in prefabTimers)
                            {
                                entry.Value.Destroy();
                            }
                            prefabTimers.Clear();
                            Message(player, "PrefabSpawnStop");
                            break;
                        default:
                            Message(player, "UnknownCommand");
                            break;
                    }
                    break;
                default:
                    Message(player, "UnknownCommand");
                    break;
            }
        }

        #endregion

        #region Helpers

        List<T> FindEntities<T>(Vector3 position, float distance) where T : BaseEntity
        {
            LayerMask layers = LayerMask.GetMask("Deployed");
            var list = Facepunch.Pool.GetList<T>();
            Vis.Entities(position, distance, list);
            return list;
        }

        private static LayerMask GROUND_MASKS = LayerMask.GetMask("Terrain", "World", "Construction");
        //Credit: Wulf
        static Vector3 GetGroundPosition(Vector3 sourcePos)
        {
            RaycastHit hitInfo;

            if (UnityEngine.Physics.Raycast(sourcePos, Vector3.down, out hitInfo, GROUND_MASKS))
            {
                sourcePos.y = hitInfo.point.y;
            }
            sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));
            return sourcePos;
        }

        public static Vector3 StringToVector3(string sVector)
        {
            if (sVector.StartsWith("(") && sVector.EndsWith(")"))
            {
                sVector = sVector.Substring(1, sVector.Length - 2);
            }
            string[] sArray = sVector.Split(',');

            Vector3 result = new Vector3(
                float.Parse(sArray[0]),
                float.Parse(sArray[1]),
                float.Parse(sArray[2]));

            return result;
        }

        private void Message(IPlayer player, string key, params object[] args)
        {
            if (player.IsConnected)
            {
                player.Message(Lang(key, player.Id, args));
            }
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        #endregion

        #region Data

        private const string filename = "ScheduledSpawns/ScheduledSpawnsData";
        private PluginData _data;

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(filename, _data);
        }

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(filename);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null)
            {
                _data = new PluginData();
            }
        }

        private class PluginData
        {
            public Dictionary<string, Dictionary<string, string>> _prefabContainer = new Dictionary<string, Dictionary<string, string>>();
            public Dictionary<string, Dictionary<string, string>> _itemContainer = new Dictionary<string, Dictionary<string, string>>();
        }

        #endregion
    }

}

// --- End of file: ScheduledSpawns.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/skip-night-vote ---
// --- Original File Path: S/SkipNightVote/SkipNightVote.cs ---

ï»¿using System;
using System.Collections.Generic;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("SkipNightVote", "k1lly0u", "0.1.4", ResourceId = 2058)]
    class SkipNightVote : CovalencePlugin
    {
        #region Fields
        private List<string> ReceivedVotes;

        private bool VoteOpen;
        private bool DisplayCountEveryVote = false;
        private int TimeRemaining;
        private int RequiredVotes;
        private string TimeRemMSG;
        private Timer VotingTimer;
        private Timer TimeCheck;
        private Timer CountTimer;
        #endregion

        #region Oxide Hooks
        void Loaded() => lang.RegisterMessages(Messages, this);        
        void OnServerInitialized()
        {
            LoadVariables();
            ReceivedVotes = new List<string>();
            RequiredVotes = 0;
            VoteOpen = false;
            TimeRemaining = 0;
            TimeRemMSG = GetMSG("timeRem").Replace("{secCol}", configData.Messaging.MSGColor).Replace("{mainCol}", configData.Messaging.MainColor);
            if (configData.Messaging.DisplayCountEvery == -1)
                DisplayCountEveryVote = true;
            CheckTime();
        }
        void Unload()
        {
            if (VotingTimer != null)
                VotingTimer.Destroy();
            if (TimeCheck != null)
                TimeCheck.Destroy();
            if (CountTimer != null)
                CountTimer.Destroy();         
        }
        #endregion

        #region Functions
        private void OpenVote()
        {
            var rVotes = server.Players * configData.Options.RequiredVotePercentage;
            if (rVotes < 1) rVotes = 1;
            RequiredVotes = Convert.ToInt32(rVotes);
            VoteOpen = true;
            var msg = GetMSG("voteMSG").Replace("{secCol}", configData.Messaging.MSGColor).Replace("{mainCol}", configData.Messaging.MainColor).Replace("{reqVote}", (configData.Options.RequiredVotePercentage * 100).ToString());
            server.Broadcast(msg);
            VoteTimer();
            if (!DisplayCountEveryVote)
                CountTimer = timer.In(configData.Messaging.DisplayCountEvery, ShowCountTimer);
        }
        private void VoteTimer()
        {
            TimeRemaining = configData.VoteTimers.VoteOpenTimer * 60;
            VotingTimer = timer.Repeat(1, TimeRemaining, () =>
            {
                TimeRemaining--;
                switch (TimeRemaining)
                {
                    case 0:
                        TallyVotes();
                        return;
                    case 180:
                        server.Broadcast(TimeRemMSG.Replace("{time}", "3").Replace("{type}", GetMSG("Minutes")));
                        return;
                    case 120:
                        server.Broadcast(TimeRemMSG.Replace("{time}", "2").Replace("{type}", GetMSG("Minutes")));
                        return;
                    case 60:
                        server.Broadcast(TimeRemMSG.Replace("{time}", "1").Replace("{type}", GetMSG("Minute")));
                        return;
                    case 30:
                        server.Broadcast(TimeRemMSG.Replace("{time}", "30").Replace("{type}", GetMSG("Seconds")));
                        return;
                    case 10:
                        server.Broadcast(TimeRemMSG.Replace("{time}", "10").Replace("{type}", GetMSG("Seconds")));
                        return;
                    default:
                        return;
                }               
            });
        }        
        private void ShowCountTimer()
        {
            server.Broadcast($"{configData.Messaging.MainColor}{ReceivedVotes.Count} / {RequiredVotes}</color> {configData.Messaging.MSGColor}{GetMSG("have voted to skip night")}</color>");
            CountTimer = timer.In(configData.Messaging.DisplayCountEvery, ShowCountTimer);
        }       
        private void CheckTime()
        {
            if (!VoteOpen)
            {
                if ((server.Time.TimeOfDay >= TimeSpan.Parse(configData.Options.TimeToOpen) && server.Time.TimeOfDay < TimeSpan.Parse("23:59:59")) || (server.Time.TimeOfDay >= TimeSpan.Parse("00:00:00") && server.Time.TimeOfDay < TimeSpan.Parse(configData.Options.TimeToSet)))
                {
                    OpenVote();
                }
                else
                {
                    TimeCheck = timer.Once(20, () => CheckTime());
                }
            }
            else
            {
                if (server.Time.TimeOfDay >= TimeSpan.Parse(configData.Options.TimeToSet) && server.Time.TimeOfDay < TimeSpan.Parse(configData.Options.TimeToOpen))
                {
                    VoteEnd(false);
                }
            }
        }
        private void TallyVotes()
        {
            if (ReceivedVotes.Count >= RequiredVotes)
                VoteEnd(true);
            else VoteEnd(false);
        }
        private void VoteEnd(bool success)
        {            
            VoteOpen = false;
            RequiredVotes = 0;
            VotingTimer.Destroy();
            if (CountTimer != null)
                CountTimer.Destroy();        
            ReceivedVotes.Clear();
            TimeRemaining = 0;

            if (success)
            {
                server.Time = server.Time.Date + TimeSpan.Parse(configData.Options.TimeToSet);
                server.Time.Date.AddDays(1);
                server.Broadcast($"{configData.Messaging.MainColor}{GetMSG("Voting was successful, skipping night.")}</color>");                
            }
            else
            {
                server.Broadcast($"{configData.Messaging.MainColor}{GetMSG("Voting was unsuccessful.")}</color>");
            }
            TimeCheck = timer.Once(configData.VoteTimers.TimeBetweenVotes * 60, () => CheckTime());
        }
        #endregion

        #region Helpers
        private bool AlreadyVoted(string player) => ReceivedVotes.Contains(player);
        #endregion

        #region ChatCommands
        [Command("voteday")]
        private void cmdVoteDay(IPlayer player, string command, string[] args)
        {
            if (VoteOpen)
            {
                if (!AlreadyVoted(player.Id))
                {
                    ReceivedVotes.Add(player.Id);
                    player.Reply(GetMSG("You have voted to skip night", player.Id));
                    if (DisplayCountEveryVote)
                        server.Broadcast($"{configData.Messaging.MainColor}{ReceivedVotes.Count} / {RequiredVotes}</color> {configData.Messaging.MSGColor}{GetMSG("have voted to skip night", player.Id)}</color>");
                    if (ReceivedVotes.Count >= RequiredVotes)
                        VoteEnd(true);
                    return;
                }
            }
            else player.Reply($"{configData.Messaging.MainColor}{GetMSG("There is not a vote currently open", player.Id)}</color>");
        }
        [Command("nightvote"), Permission("skipnightvote.admin")]
        private void cmdAdminVote(IPlayer player, string command, string[] args)
        {
            if (args == null || args.Length == 0)
            {
                player.Reply($"{configData.Messaging.MainColor}/nightvote open</color> {configData.Messaging.MSGColor}- {GetMSG("Force open a new vote", player.Id)}</color>");
                player.Reply($"{configData.Messaging.MainColor}/nightvote close</color> {configData.Messaging.MSGColor}- {GetMSG("Cancel the current vote", player.Id)}</color>");
                return;
            }
            switch (args[0].ToLower())
            {
                case "open":
                    {
                        OpenVote();
                    }
                    return;
                case "close":
                    {
                        VoteEnd(false);
                    }
                    return;
                default:
                    break;
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class Messaging
        {
            public int DisplayCountEvery { get; set; }
            public string MainColor { get; set; }
            public string MSGColor { get; set; }
        }        
        class Timers
        {
            public int VoteOpenTimer { get; set; }
            public int TimeBetweenVotes { get; set; }
        }
        class Options
        {
            public float RequiredVotePercentage { get; set; }
            public string TimeToOpen { get; set; }
            public string TimeToSet { get; set; }
        }
        class ConfigData
        {

            public Messaging Messaging { get; set; }
            public Timers VoteTimers { get; set; }
            public Options Options { get; set; }

        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {                
                Messaging = new Messaging
                {
                    DisplayCountEvery = 30,
                    MainColor = "<color=orange>",
                    MSGColor = "<color=#939393>"
                },
                Options = new Options
                {
                    RequiredVotePercentage = 0.4f,
                    TimeToOpen = "18:00:00",
                    TimeToSet = "07:00:00"
                },
                VoteTimers = new Timers
                {
                    VoteOpenTimer = 4,
                    TimeBetweenVotes = 5
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Messaging
        private string GetMSG(string key, string userid = null) => lang.GetMessage(key, this, userid);
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"Force open a new vote", "Force open a new vote" },
            {"Cancel the current vote", "Cancel the current vote" },
            {"There is not a vote currently open", "There is not a vote currently open" },
            {"You have voted to skip night", "You have voted to skip night" },
            {"have voted to skip night", "players have voted to skip night" },
            {"Voting was successful, skipping night.", "Voting was successful, skipping night." },
            {"Voting was unsuccessful.", "Voting was unsuccessful." },
            {"Minutes", "Minutes" },
            {"Minute", "Minute" },
            {"Seconds", "Seconds" },
            {"voteMSG", "{secCol}Type</color> {mainCol}/voteday</color> {secCol}now if you want to skip night. If </color>{mainCol}{reqVote}%</color> {secCol}of players vote night will be skipped</color>" },
            {"timeRem", "{secCol}Voting ends in</color> {mainCol}{time} {type}</color>{secCol}, use </color>{mainCol}/voteday</color>{secCol} to cast your vote</color>" }
        };
        #endregion
    }
}

// --- End of file: SkipNightVote.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/server-chat ---
// --- Original File Path: S/ServerChat/ServerChat.cs ---

ï»¿using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Server Chat", "Enforcer", "2.0.2")]
    [Description("Replaces the default server chat icon and prefix")]
    public class ServerChat : RustPlugin
    {
        #region Config

        ConfigData config;

        public class ConfigData
        {
            [JsonProperty(PropertyName = "Chat icon (SteamID64)")]
            public ulong chatIcon { get; set; }

            [JsonProperty(PropertyName = "Messages to not modify", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> messagesToNotModify { get; set; }

            [JsonProperty(PropertyName = "Title Settings")]
            public ServerTitle serverTitleSettings { get; set; }

            [JsonProperty(PropertyName = "Message Settings")]
            public ServerMessage serverMessageSettings { get; set; }

            [JsonProperty(PropertyName = "Format")]
            public ServerFormat serverFormatSettings { get; set; }
        }

        public class ServerTitle
        {
            [JsonProperty(PropertyName = "Title")]
            public string titleName { get; set; }

            [JsonProperty(PropertyName = "Colour")]
            public string titleColour { get; set; }

            [JsonProperty(PropertyName = "Size")]
            public int titleSize { get; set; }
        }

        public class ServerMessage
        {
            [JsonProperty(PropertyName = "Colour")]
            public string messageColour { get; set; }

            [JsonProperty(PropertyName = "Size")]
            public int messageSize { get; set; }
        }

        public class ServerFormat
        {
            [JsonProperty(PropertyName = "Server chat format")]
            public string messageFormat { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError($"{Name}.json is corrupted! Recreating a new configuration");
                LoadDefaultConfig();
                return;
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData
            {
                chatIcon = 0,

                messagesToNotModify = new List<string>
                {
                    "gave",
                    "restarting"
                },

                serverTitleSettings = new ServerTitle
                {
                    titleName = "Server",
                    titleColour = "white",
                    titleSize = 15
                },

                serverMessageSettings = new ServerMessage
                {
                    messageColour = "white",
                    messageSize = 15
                },

                serverFormatSettings = new ServerFormat
                {
                    messageFormat = "{title} {message}"
                }
            };
        }

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Hooks

        private object OnServerMessage(string serverMessage)
        {
            foreach (var msg in config.messagesToNotModify)
            {
                if (serverMessage.Contains(msg))
                return null;
            }
            
            string title = $"<size={config.serverTitleSettings.titleSize}><color={config.serverTitleSettings.titleColour}>{config.serverTitleSettings.titleName}</color></size>";
            string message = $"<size={config.serverMessageSettings.messageSize}><color={config.serverMessageSettings.messageColour}>{serverMessage}</color></size>";

            string format = config.serverFormatSettings.messageFormat
                .Replace("{title}", title)
                .Replace("{message}", message);

            Server.Broadcast(format, config.chatIcon);
            return true;
        }



        #endregion
    }
}

// --- End of file: ServerChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/scheduled-messages ---
// --- Original File Path: S/ScheduledMessages/ScheduledMessages.cs ---

ï»¿//#define ScheduledMessages_DEBUG
// Uncomment above to enable debug statements. Will only be useful for developers or when debugging a problem.

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;

#if RUST
using Oxide.Core;
using Oxide.Game.Rust.Libraries;
#endif

namespace Oxide.Plugins
{
    [Info("Scheduled Messages", "gunman435", "1.2.0")]
    [Description("Allows the creation of custom messages to broadcast to players.")]
    class ScheduledMessages : CovalencePlugin
    {
        #region Fields
        // Timer for ticking scheduled messages.
        private Timer messageTimer;
        // Random number generator for getting next scheduled message.
        private System.Random rand;
        // Integer for tracking the next sequential message.
        private int nextMessage = 0;
#if RUST
        // Include server library for Rust so we can use AvatarIDs.
        protected Server Server = Interface.Oxide.GetLibrary<Server>();
#endif
        #endregion

        #region Config
        // Config variable.
        private Configuration config;

        // Class for holding config elements.
        class Configuration
        {
            // Holds the custom messages.
            [JsonProperty(PropertyName = "Scheduled Messages")]
            public List<string> scheduledMessages;

            // The time in seconds at which a message is broadcasted.
            [JsonProperty(PropertyName = "Scheduled Messages Interval")]
            public float scheduledMesssagesInterval;

            // The SteamID64 of the Avatar to use in broadcasted messages.
            [JsonProperty(PropertyName = "Scheduled Messages Avatar ID")]
            public ulong scheduledMessagesAvatarID;

            // Whether the next scheduled message should be decided randomly or sequentially.
            [JsonProperty(PropertyName = "Scheduled Messages Randomizer")]
            public bool scheduledMessagesRandom;
        }

        /// <summary>
        /// Loads the plugin configuration.
        /// </summary>
        protected override void LoadConfig()
        {
#if ScheduledMessages_DEBUG
            Puts("Started loading config...");
#endif
            base.LoadConfig();
            config = Config.ReadObject<Configuration>();

            // No existing config found, load default one and save it.
            if (config == null)
            {
#if ScheduledMessages_DEBUG
                Puts("Fresh install or missing config, creating default config and saving it...");
#endif
                LoadDefaultConfig();
                SaveConfig();
            }

#if ScheduledMessages_DEBUG
            Puts("Loaded config.");
#endif
        }

        /// <summary>
        /// Loads the default plugin configuration.
        /// </summary>
        protected override void LoadDefaultConfig() => config = new Configuration
        {
            scheduledMessages = new List<string>
            {
                "This is a scheduled message, this plugin was originally intended for a community I run. But I thought making it public would serve a better purpose. I hope you find the plugin useful!"
            },
            scheduledMesssagesInterval = 30f,
            scheduledMessagesAvatarID = 0,
            scheduledMessagesRandom = true
        };

        /// <summary>
        /// Saves the plugin configuration.
        /// </summary>
        protected override void SaveConfig() => Config.WriteObject(config, true);
        #endregion

        #region Language/Localization
        /// <summary>
        /// Loads the plugin localization messages.
        /// </summary>
        protected override void LoadDefaultMessages()
        {
#if ScheduledMessages_DEBUG
            Puts("Started registering languages...");
#endif

            // English translation.
            lang.RegisterMessages(new Dictionary<string, string>
            {
                // For when someone is missing permission to use a command.
                ["MissingPermission"] = "You do not have permission to use the '{0}' command!",

                // When a message gets added.
                ["ScheduledMessagesAdded"] = "The message '{0}' has been added!",
                // When a message gets removed.
                ["ScheduledMessagesRemoved"] = "The message at position {0} has been removed!",
                // When a message gets edited.
                ["ScheduledMessagesEdited"] = "The message at position {0} has been changed to '{1}'",
                // When all current messages are shown.
                ["ScheduledMessagesShow"] = "These are the current messages:\n{0}",
                // When the avatar is changed.
                ["ScheduledMessagesAvatarChanged"] = "Scheduled messages avatar has been changed to {0}!",
                // When the message interval is changed.
                ["ScheduledMessagesIntervalChanged"] = "Scheduled messages interval has been changed to {0} seconds!",
                // When scheduled messages are turned on.
                ["ScheduledMessagesOn"] = "Scheduled messages have been enabled!",
                // When scheduled messages are already turned on and someone is trying to turn them on.
                ["ScheduledMessagesAlreadyOn"] = "Scheduled messages are already enabled!",
                // When scheduled messages are turned off.
                ["ScheduledMessagesOff"] = "Scheduled messages have been disabled!",
                // When scheduled messages are already turned off and someone is trying to turn them off.
                ["ScheduledMessagesAlreadyOff"] = "Scheduled messages are already disabled!",
                // When scheduled messages are turned off due to no messages left to use.
                ["ScheduledMessagesOff2"] = "Scheduled messages have been disabled due to no messages being registered.",
                // When the scheduled messages randomizer is turned on.
                ["ScheduledMessagesRandomOn"] = "Scheduled messages will now be in a random order.",
                // When the scheduled messages randomizer is already on and someone is trying to turn it on.
                ["ScheduledMessagesRandomAlreadyOn"] = "Scheduled messages are already in random order!",
                // When the scheduled messages randomizer is turned off.
                ["ScheduledMessagesRandomOff"] = "Scheduled messages will now be shown in order.",
                // When the scheduled messages randomizer is already off and someone is trying to turn it off.
                ["ScheduledMessagesRandomAlreadyOff"] = "Scheduled messages are already in order!",

                // Generic help message for when no recognizable sub-command is used.
                ["ScheduledMessagesHelp"] = "Schedules messages are currently {0}. These are the commands available:\n{1}",
                // Usage text for add command.
                ["ScheduledMessagesAddUsage"] = "Usage: <scheduledmessages/smsg> <add/a> <message>",
                // Usage text for remove command.
                ["ScheduledMessagesRemoveUsage"] = "Usage: <scheduledmessages/smsg> <remove/r> <position>",
                // Usage text for edit command.
                ["ScheduledMessagesEditUsage"] = "Usage: <scheduledmessages/smsg> <edit/e> <position> <message>",
                // Usage text for show command.
                ["ScheduledMessagesShowUsage"] = "Usage: <scheduledmessages/smsg> <show/s>",
                // Usage text for set avatar command.
                ["ScheduledMessagesSetAvatarUsage"] = "Usage: <scheduledmessages/smsg> <setavatar/sa> <steamid64>",
                // Usage text for set interval command.
                ["ScheduledMessagesSetIntervalUsage"] = "Usage: <scheduledmessages/smsg> <setinterval/si> <seconds>",
                // Usage text for on command.
                ["ScheduledMessagesOnUsage"] = "Usage: <scheduledmessages/smsg> <on>",
                // Usage text for off command.
                ["ScheduledMessagesOffUsage"] = "Usage: <scheduledmessages/smsg> <off>",
                // Usage text for random command.
                ["ScheduledMessagesRandomUsage"] = "Usage: <scheduledmessages/smsg> <random> <on/off>",

                // Direct translation for "on", used in help message.
                ["on"] = "on",
                // Direct translation for "off", used in help message.
                ["off"] = "off"
            }, this);

            // Add other languages here.

#if ScheduledMessages_DEBUG
            Puts("Finished registering languages.");
#endif
        }
        #endregion

        #region Plugin Events
        /// <summary>
        /// Called when the server has finished startup or this plugin has been hotloaded.
        /// </summary>
        /// <param name="initial">Whether this is being called on server finishing startup or not.</param>
        void OnServerInitialized(bool initial)
        {
#if ScheduledMessages_DEBUG
            Puts("Loading plugin...");
#endif
            // Create random number generator.
            rand = new System.Random();

            // Start scheduled messages if we have any.
            if (config.scheduledMessages.Count != 0)
                StartScheduledMessages();

            // Register the permissions we need.
            permission.RegisterPermission("scheduledmessages.add", this);
            permission.RegisterPermission("scheduledmessages.remove", this);
            permission.RegisterPermission("scheduledmessages.edit", this);
            permission.RegisterPermission("scheduledmessages.show", this);
            permission.RegisterPermission("scheduledmessages.setavatar", this);
            permission.RegisterPermission("scheduledmessages.setinterval", this);
            permission.RegisterPermission("scheduledmessages.on", this);
            permission.RegisterPermission("scheduledmessages.off", this);
            permission.RegisterPermission("scheduledmessages.random", this);

#if ScheduledMessages_DEBUG
            Puts("Finished loading plugin.");
#endif
        }

        /// <summary>
        /// Called when the plugin is being unloaded.
        /// </summary>
        void Unload()
        {
#if ScheduledMessages_DEBUG
            Puts("Started unloading plugin...");
#endif
            // Cleanup after ourselves.
            StopScheduledMessages();

#if ScheduledMessages_DEBUG
            Puts("Finished unloading plugin.");
#endif
        }
        #endregion

        #region Scheduled Messages
        /// <summary>
        /// Starts the scheduled messages timer. If it has already started, destroy it and start again.
        /// </summary>
        private void StartScheduledMessages()
        {
#if ScheduledMessages_DEBUG
            Puts("Starting/Restarting messages timer...");
#endif

            // Create the message timer.
            if (messageTimer == null || messageTimer.Destroyed)
                messageTimer = timer.Every(config.scheduledMesssagesInterval, NextScheduledMessage);
            // Timer already exists, destroy it and recreate it next frame.
            else if (!messageTimer.Destroyed)
            {
                messageTimer.Destroy();
                NextFrame(() =>
                {
                    StartScheduledMessages();
                });
            }
        }

        /// <summary>
        /// Stops the scheduled message timer if it exists.
        /// </summary>
        private void StopScheduledMessages()
        {
#if ScheduledMessages_DEBUG
            Puts("Stopping messages timer...");
#endif

            // Only destroy the timer if it exists and is not destroyed already.
            if (messageTimer != null && !messageTimer.Destroyed)
                messageTimer.Destroy();
        }

        /// <summary>
        /// The callback to the timer, gets a message and broadcasts it.
        /// </summary>
        private void NextScheduledMessage()
        {
            // Bail if the timer is supposed to be destroyed.
            if (messageTimer.Destroyed)
                return;

            // Get message in the list.
            string message;
            // Get the next message randomly.
            if (config.scheduledMessagesRandom)
                message = config.scheduledMessages[rand.Next(0, config.scheduledMessages.Count)];
            // Get the next message sequentially.
            else
            {
                // Get next message index.
                nextMessage++;
                if (nextMessage >= config.scheduledMessages.Count)
                    nextMessage = 0;

                // Get next message.
                message = config.scheduledMessages[nextMessage];
            }

            // Broadcast the message.
            BroadcastMessage(message, config.scheduledMessagesAvatarID);
            // Call hook for when a scheduled message is broadcasted.
            plugins.CallHook("OnScheduledMessageBroadcasted", message, config.scheduledMessagesAvatarID);
        }

        #region Scheduled Messages Command
        /// <summary>
        /// Executes a players command for scheduled messages.
        /// </summary>
        /// <param name="ply">The player executing the command.</param>
        /// <param name="command">The command used.</param>
        /// <param name="args">The arguments passed in the message.</param>
        [Command("scheduledmessages", "smsg"), Permission("scheduledmessages.cmd")]
        private void ScheduledMessagesCommand(IPlayer ply, string command, string[] args)
        {
#if ScheduledMessages_DEBUG
            Puts($"{ply.Name} used command.");
#endif
            // Check if the player has the specific permission.
            if (!ply.HasPermission("scheduledmessages.cmd"))
            {
                PrintToChat(ply, Lang("MissingPermission", ply.Id, $"{command}"));
                return;
            }
            // If no arguments are passed then just display help section.
            else if (args.Length == 0)
            {
                HelpCommand(ply, command, args);
                return;
            }

#if ScheduledMessages_DEBUG
            Puts($"{ply.Name} passed initial checks.");
#endif

            // Boolean for whether the config has been edited during this function.
            bool configEdited;

            // Provide different functionality based on the first argument (sub-command)
            switch (args[0])
            {
                // Add command.
                case "add":
                case "a":
                    configEdited = AddCommand(ply, command, args);
                    break;
                // Remove command.
                case "remove":
                case "r":
                    configEdited = RemoveCommand(ply, command, args);
                    break;
                // Edit command.
                case "edit":
                case "e":
                    configEdited = EditCommand(ply, command, args);
                    break;
                // Show command.
                case "show":
                case "s":
                    configEdited = ShowCommand(ply, command, args);
                    break;
                // Set avatar command.
                case "setavatar":
                case "sa":
                    configEdited = SetAvatarCommand(ply, command, args);
                    break;
                // Set interval command.
                case "setinterval":
                case "si":
                    configEdited = SetIntervalCommand(ply, command, args);
                    break;
                // On command.
                case "on":
                    configEdited = OnCommand(ply, command, args);
                    break;
                // Off command.
                case "off":
                    configEdited = OffCommand(ply, command, args);
                    break;
                // Random command.
                case "random":
                    configEdited = RandomCommand(ply, command, args);
                    break;
                // Unknown/help command.
                default:
                    configEdited = HelpCommand(ply, command, args);
                    break;
            }

#if ScheduledMessages_DEBUG
            Puts($"{ply.Name} edited config: {configEdited.ToString()}");
#endif
            // If the config has been edited, save the changes.
            if (configEdited)
                SaveConfig();
        }

        /// <summary>
        /// Sub-command for adding a scheduled message.
        /// </summary>
        /// <param name="ply">The player executing the command.</param>
        /// <param name="command">The command used.</param>
        /// <param name="args">The arguments passed in the message.</param>
        private bool AddCommand(IPlayer ply, string command, string[] args)
        {
            // Check if the player has the specific permission.
            if (!ply.HasPermission("scheduledmessages.add"))
            {
                PrintToChat(ply, Lang("MissingPermission", ply.Id, $"{command} {args[0]}"));
                return false;
            }

            // Build the message the user tried to use.
            string newMessage = "";
            for (int i = 1; i < args.Length; i++)
                newMessage += $" {args[i]}";
            newMessage = newMessage.Trim();

            // Check to make sure it isn't still blank.
            if (newMessage == "")
            {
                PrintToChat(ply, Lang("ScheduledMessagesAddUsage", ply.Id));
                return false;
            }
            // Add the new message.
            else
            {
                config.scheduledMessages.Add(newMessage);
                PrintToChat(ply, Lang("ScheduledMessagesAdded", ply.Id, newMessage));
                return true;
            }
        }

        /// <summary>
        /// Sub-command for removing a scheduled message.
        /// </summary>
        /// <param name="ply">The player executing the command.</param>
        /// <param name="command">The command used.</param>
        /// <param name="args">The arguments passed in the message.</param>
        private bool RemoveCommand(IPlayer ply, string command, string[] args)
        {
            // Check if the player has the specific permission.
            if (!ply.HasPermission("scheduledmessages.remove"))
            {
                PrintToChat(ply, Lang("MissingPermission", ply.Id, $"{command} {args[0]}"));
                return false;
            }

            try
            {
                // Attempt to parse the index passed.
                int removeIndex = int.Parse(args[1]);
                // Attempt to remove the message at the parsed index.
                config.scheduledMessages.RemoveAt(removeIndex-1);
                // Let the player know the message at that index was removed.
                PrintToChat(ply, Lang("ScheduledMessagesRemoved", ply.Id, args[1]));

                // If no messages are left, turn off the scheduled messages and let the player know.
                if (config.scheduledMessages.Count == 0)
                {
                    StopScheduledMessages();
                    PrintToChat(ply, Lang("ScheduledMessagesOff2", ply.Id));
                }

                return true;
            }
            catch (Exception)
            {
                // Something went wrong, let the player know how to use the command.
                PrintToChat(ply, Lang("ScheduledMessagesRemoveUsage", ply.Id));
                return false;
            }
        }

        /// <summary>
        /// Sub-command for editing a scheduled message.
        /// </summary>
        /// <param name="ply">The player executing the command.</param>
        /// <param name="command">The command used.<param>
        /// <param name="args">The arguments passed in the message.</param>
        /// <returns></returns>
        private bool EditCommand(IPlayer ply, string command, string[] args)
        {
            // Check if the player has the specific permission.
            if (!ply.HasPermission("scheduledmessages.edit"))
            {
                PrintToChat(ply, Lang("MissingPermission", ply.Id, $"{command} {args[0]}"));
                return false;
            }

            try
            {
                // Attempt to parse the message number passed.
                int messageNumber = int.Parse(args[1]);
                // Create the new message.
                string newMessage = "";
                for (int i=2; i<args.Length; i++)
                    newMessage += $" {args[i]}";
                newMessage = newMessage.Trim();

                // Check that the new rule we got isn't empty.
                if (newMessage != "")
                {
                    // Edit the rule at the parsed index.
                    config.scheduledMessages[messageNumber - 1] = newMessage;
                    // Let the player know the message at that index+1 was edited.
                    PrintToChat(ply, Lang("ScheduledMessagesEdited", ply.Id, args[1], newMessage));

                    return true;
                }
                else
                    PrintToChat(ply, Lang("ScheduledMessagesEditUsage", ply.Id));
            }
            catch (Exception)
            {
                // Something went wrong, let the player know how to use the command.
                PrintToChat(ply, Lang("ScheduledMessagesEditUsage", ply.Id));
                return false;
            }

            return false;
        }

        /// <summary>
        /// Sub-command for showing scheduled messages.
        /// </summary>
        /// <param name="ply">The player executing the command.</param>
        /// <param name="command">The command used.</param>
        /// <param name="args">The arguments passed in the message.</param>
        private bool ShowCommand(IPlayer ply, string command, string[] args)
        {
            // Check if the player has the specific permission.
            if (!ply.HasPermission("scheduledmessages.show"))
            {
                PrintToChat(ply, Lang("MissingPermission", ply.Id, $"{command} {args[0]}"));
                return false;
            }

            string scheduledMessages = "";
            // No messages are registered.
            if (config.scheduledMessages.Count == 0)
                scheduledMessages = "There are no scheduled messages.";
            // There are messages registered.
            else
                for (int i = 0; i < config.scheduledMessages.Count; i++)
                    scheduledMessages += $"{i+1}: {config.scheduledMessages[i]}\n";

            // Show the player all the messages that are registered.
            PrintToChat(ply, Lang("ScheduledMessagesShow", ply.Id, scheduledMessages));
            return false;
        }

        /// <summary>
        /// Sub-command for changing the broadcast avatar of scheduled messages.
        /// </summary>
        /// <param name="ply">The player executing the command.</param>
        /// <param name="command">The command used.</param>
        /// <param name="args">The arguments passed in the message.</param>
        /// <returns></returns>
        private bool SetAvatarCommand(IPlayer ply, string command, string[] args)
        {
            // Check if the player has the specific permission.
            if (!ply.HasPermission("scheduledmessages.setavatar"))
            {
                PrintToChat(ply, Lang("MissingPermission", ply.Id, $"{command} {args[0]}"));
                return false;
            }
            // Check if the argument is exactly 17 characters long (the size of all SteamID64s) and make sure it isn't the default avatarID.
            else if (args[1].Length != 17 && args[1] != "0")
            {
                PrintToChat(ply, Lang("ScheduledMessagesSetAvatarUsage", ply.Id));
                return false;
            }

            try
            {
                // Attempt to parse the new avatar.
                config.scheduledMessagesAvatarID = ulong.Parse(args[1]);
                // Let the player know the avatar has been changed.
                PrintToChat(ply, Lang("ScheduledMessagesAvatarChanged", ply.Id, args[1]));
                return true;
            }
            catch (Exception)
            {
                // Something went wrong, let the player know how to use the command.
                PrintToChat(ply, Lang("ScheduledMessagesSetAvatarUsage", ply.Id));
                return false;
            }
        }

        /// <summary>
        /// Sub-command for changing the broadcast interval of scheduled messages.
        /// </summary>
        /// <param name="ply">The player executing the command.</param>
        /// <param name="command">The command used.</param>
        /// <param name="args">The arguments passed in the message.</param>
        private bool SetIntervalCommand(IPlayer ply, string command, string[] args)
        {
            // Check if the player has the specific permission.
            if (!ply.HasPermission("scheduledmessages.setinterval"))
            {
                PrintToChat(ply, Lang("MissingPermission", ply.Id, $"{command} {args[0]}"));
                return false;
            }

            try
            {
                // Attempt to parse the new interval.
                float newInterval = float.Parse(args[1]);
                // Check if we at least got a somewhat sensible number.
                if (newInterval > 0)
                {
                    config.scheduledMesssagesInterval = newInterval;
                    // Start the scheduled messages.
                    StartScheduledMessages();
                    // Let the player know the interval has been changed.
                    PrintToChat(ply, Lang("ScheduledMessagesIntervalChanged", ply.Id, args[1]));
                    return true;
                }
                // Didn't get a sensible number, just show help text.
                else
                {
                    PrintToChat(ply, Lang("ScheduledMessagesSetIntervalUsage", ply.Id));
                    return false;
                }
            }
            catch (Exception)
            {
                // Something went wrong, let the player know how to use the command.
                PrintToChat(ply, Lang("ScheduledMessagesSetIntervalUsage", ply.Id));
                return false;
            }
        }

        /// <summary>
        /// Sub-command for enabling scheduled messages.
        /// </summary>
        /// <param name="ply">The player executing the command.</param>
        /// <param name="command">The command used.</param>
        /// <param name="args">The arguments passed in the message.</param>
        private bool OnCommand(IPlayer ply, string command, string[] args)
        {
            // Check if the player has the specific permission.
            if (!ply.HasPermission("scheduledmessages.on"))
            {
                PrintToChat(ply, Lang("MissingPermission", ply.Id, $"{command} {args[0]}"));
                return false;
            }
            // Check if the scheduled messages timer is already running.
            else if (IsTimerRunning())
            {
                PrintToChat(ply, Lang("ScheduledMessagesAlreadyOn", ply.Id));
                return false;
            }

            // Start the scheduled messages.
            StartScheduledMessages();
            // Let the player know this happened.
            PrintToChat(ply, Lang("ScheduledMessagesOn"));
            return false;
        }

        /// <summary>
        /// Sub-command for disabling scheduled messages.
        /// </summary>
        /// <param name="ply">The player executing the command.</param>
        /// <param name="command">The command used.</param>
        /// <param name="args">The arguments passed in the message.</param>
        private bool OffCommand(IPlayer ply, string command, string[] args)
        {
            // Check if the player has the specific permission.
            if (!ply.HasPermission("scheduledmessages.off"))
            {
                PrintToChat(ply, Lang("MissingPermission", ply.Id, $"{command} {args[0]}"));
                return false;
            }
            // Check if the scheduled messages timer is already turned off.
            else if (!IsTimerRunning())
            {
                PrintToChat(ply, Lang("ScheduledMessagesAlreadyOff", ply.Id));
                return false;
            }

            // Stop the scheduled messages.
            StopScheduledMessages();
            // Let the player know this happened.
            PrintToChat(ply, Lang("ScheduledMessagesOff"));
            return false;
        }

        /// <summary>
        /// Sub-command for enabling/disabling randomized scheduled messages.
        /// </summary>
        /// <param name="ply">The player executing the command.</param>
        /// <param name="command">The command used.</param>
        /// <param name="args">The arguments passed in the message.</param>
        private bool RandomCommand(IPlayer ply, string command, string[] args)
        {
            // Check if the player has the specific permission.
            if (!ply.HasPermission("scheduledmessages.off"))
            {
                PrintToChat(ply, Lang("MissingPermission", ply.Id, $"{command} {args[0]}"));
                return false;
            }
            // Check if we got enough arguments.
            else if (args.Length < 2)
            {
                PrintToChat(ply, Lang("ScheduledMessagesRandomUsage", ply.Id));
                return false;
            }

            switch (args[1])
            {
                // Turn it on.
                case "on":
                case "true":
                    // Check if this setting is already turned on.
                    if (config.scheduledMessagesRandom)
                    {
                        PrintToChat(ply, Lang("ScheduledMessagesRandomAlreadyOn", ply.Id));
                        return false;
                    }

                    // Turn on the random message functionality.
                    config.scheduledMessagesRandom = true;
                    // Let the player know of the change.
                    PrintToChat(ply, Lang("ScheduledMessagesRandomOn", ply.Id));
                    return true;
                // Turn it off.
                case "off":
                case "false":
                    // Check if this setting is already turned off.
                    if (!config.scheduledMessagesRandom)
                    {
                        PrintToChat(ply, Lang("ScheduledMessagesRandomAlreadyOff", ply.Id));
                        return false;
                    }

                    // Turn off the random message functionality.
                    config.scheduledMessagesRandom = false;
                    // Let the player know of the change.
                    PrintToChat(ply, Lang("ScheduledMessagesRandomOff", ply.Id));
                    return true;
                // Unknown response.
                default:
                    // Received invalid input, let the player know how to use the command.
                    PrintToChat(ply, Lang("ScheduledMessagesRandomUsage", ply.Id));
                    return false;
            }
        }

        /// <summary>
        /// Sub-command for displaying command usage and helpful text.
        /// </summary>
        /// <param name="ply">The player executing the command.</param>
        /// <param name="command">The command used.</param>
        /// <param name="args">The arguments passed in the message.</param>
        private bool HelpCommand(IPlayer ply, string command, string[] args)
        {
            // Send the player the help text.
            PrintToChat(ply, Lang("ScheduledMessagesHelp", ply.Id,
                IsTimerRunning() ? Lang("on", ply.Id) : Lang("off", ply.Id),
                $"Add - {Lang("ScheduledMessagesAddUsage", ply.Id)}\n" +
                $"Remove - {Lang("ScheduledMessagesRemoveUsage", ply.Id)}\n" +
                $"Edit - {Lang("ScheduledMessagesEditUsage", ply.Id)}\n" +
                $"Show - {Lang("ScheduledMessagesShowUsage", ply.Id)}\n" +
                $"Set Avatar - {Lang("ScheduledMessagesSetAvatarUsage", ply.Id)}\n" +
                $"Set Interval - {Lang("ScheduledMessagesSetIntervalUsage", ply.Id)}\n" +
                $"On - {Lang("ScheduledMessagesOnUsage", ply.Id)}\n" +
                $"Off - {Lang("ScheduledMessagesOffUsage", ply.Id)}\n" +
                $"Random - {Lang("ScheduledMessagesRandomUsage", ply.Id)}"));

            return false;
        }
        #endregion
        #endregion

        #region API Functions
        /// <summary>
        /// Gets the scheduled messages currently registered within this system.
        /// </summary>
        /// <returns>A list of all the scheduled messages.</returns>
        public List<string> API_GetScheduledMessagesList() { return config.scheduledMessages; }
        /// <summary>
        /// Gets the scheduled messages currently registered within this system as an array.
        /// </summary>
        /// <returns>A list of all the scheduled messages as an array.</returns>
        public string[] API_GetScheduledMessages() { return config.scheduledMessages.ToArray(); }

        /// <summary>
        /// Broadcasts the next scheduled message. This functions exactly like the regular timer.
        /// This will call the OnScheduledMessageBroadcasted hook.
        /// </summary>
        public void API_BroadcastScheduledMessage()
        {
            NextScheduledMessage();
        }
        /// <summary>
        /// Broadcasts a scheduled message at the defined index.
        /// This will not call the OnScheduledMessageBroadcasted hook.
        /// </summary>
        /// <param name="index">The index of the message to send.</param>
        /// <returns>Whether broadcasting the message was successful or not.</returns>
        public bool API_BroadcastScheduledMessage(int index)
        {
            // Check if the index provided is valid.
            if (index < 0 || index >= config.scheduledMessages.Count)
                return false;

            // Get the desired message.
            string message = config.scheduledMessages[index];
            // Broadcast the message.
            BroadcastMessage(message, config.scheduledMessagesAvatarID);

            return true;
        }
        /// <summary>
        /// Broadcasts a scheduled message at the defined index with the defined avatar ID.
        /// This will not call the OnScheduledMessageBroadcasted hook.
        /// </summary>
        /// <param name="index">The index of the message to send.</param>
        /// <param name="avatarID">The SteamID64 of the profiles avatar to use.</param>
        /// <returns>Whether broadcasting the message was successful or not.</returns>
        public bool API_BroadcastScheduledMessage(int index, ulong avatarID=0)
        {
            // Check if the index provided is valid.
            if (index < 0 || index >= config.scheduledMessages.Count)
                return false;

            // Get the desired message.
            string message = config.scheduledMessages[index];
            // Broadcast the message.
            BroadcastMessage(message, avatarID);

            return true;
        }
        #endregion

        #region API Hooks
        /// <summary>
        /// Called when a scheduled message was broadcasted.
        /// </summary>
        /// <param name="message">The message that was broadcasted.</param>
        /// <param name="avatarID">The AvatarID that was used in the message.</param>
        private void OnScheduledMessageBroadcasted(string message, ulong avatarID) { }
        #endregion

        #region Helper Functions
        /// <summary>
        /// Helper function to get a localized string and place arguments within it.
        /// </summary>
        /// <param name="key">The localization key.</param>
        /// <param name="id">The UserID.</param>
        /// <param name="args">Any arguments to pass to the formatter.</param>
        /// <returns></returns>
        private string Lang(string key, string id = null, params object[] args)
        {
#if ScheduledMessages_DEBUG
            Puts($"Localizing '{key}'");
#endif
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        /// <summary>
        /// Prints a message to a players chat.
        /// </summary>
        /// <param name="ply">The player to send the message to.</param>
        /// <param name="message">The message to send, supports formatting.</param>
        /// <param name="args">The variables to pass to string.Format if message needs formatting.</param>
        private void PrintToChat(IPlayer ply, string message, params object[] args)
        {
#if ScheduledMessages_DEBUG
            Puts($"Sending '{message}' to {ply.Name}...");
#endif
#if RUST
            // Use console command so we can include a different avatarID.
            ply.Command("chat.add", 2, config.scheduledMessagesAvatarID, args.Length > 0 ? string.Format(message, args) : message);
#else
            // Just use default replying if we're not in Rust.
            ply.Reply(args.Length > 0 ? string.Format(message, args) : message);
#endif
        }

        /// <summary>
        /// Helper function to broadcast a message.
        /// </summary>
        /// <param name="message">The message to broadcast.</param>
        /// <param name="avatarID">(Rust only) the SteamID64 of the avatar to use in the messages.</param>
        private void BroadcastMessage(string message, ulong avatarID=0)
        {
#if ScheduledMessages_DEBUG
            Puts($"Broadcasting '{message}'...");
#endif
#if RUST
            // Broadcast the message to all players with the provided AvatarID.
            Server.Broadcast(message, null, avatarID);
#else
            // Broadcast the message to all players.
            server.Broadcast(message);
#endif
        }

        /// <summary>
        /// Helper function for checking if the scheduled messages timer is running or not.
        /// </summary>
        /// <returns>Whether the scheduled messages timer is running or not.</returns>
        private bool IsTimerRunning() { return messageTimer != null && !messageTimer.Destroyed; }
        #endregion
    }
}


// --- End of file: ScheduledMessages.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/scrap-helicopter-fix ---
// --- Original File Path: S/ScrapHelicopterFix/ScrapHelicopterFix.cs ---

namespace Oxide.Plugins
{
    [Info("Scrap Helicopter Fix", "Orange", "1.0.4")]
    [Description("Reduces lags of destroying scrap helicopter by removing effects of it")]
    public class ScrapHelicopterFix : RustPlugin
    {
        private void OnServerInitialized()
        {
            foreach (var entity in UnityEngine.Object.FindObjectsOfType<ScrapTransportHelicopter>())
            {
                if (entity == null) {continue;}
                OnEntitySpawned(entity);
            }
        }
        
        private void OnEntitySpawned(ScrapTransportHelicopter entity)
        {
            entity.explosionEffect.guid = null;
            entity.serverGibs.guid = null;
            entity.fireBall.guid = null;
        }
    }
}

// --- End of file: ScrapHelicopterFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sleeper-mark ---
// --- Original File Path: S/SleeperMark/SleeperMark.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Rust;
using System.Linq;
using System.Globalization;
using Facepunch;
using UnityEngine.SceneManagement;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Sleeper Mark", "Ts3Hosting", "1.0.29")]
    [Description("Create a event to mark sleepers to be killed by players")]
    public class SleeperMark : RustPlugin
    {
        [PluginReference]
        Plugin GUIAnnouncements, ServerRewards;
        Dictionary<ulong, HitInfo> LastWounded = new Dictionary<ulong, HitInfo>();

        static HashSet<PlayerData> LoadedPlayerData = new HashSet<PlayerData>();
        List<UIObject> UsedUI = new List<UIObject>();



        PlayerEntity pcdData;
        private DynamicConfigFile PCDDATA;
        private bool Changed;
        public bool debug = false;
        private int cooldownTime = 120;
        private bool useRewards = false;
        private bool useguiAnnounce = false;
        private bool useAirdrop = true;
        private bool useBloon = false;
        private int LastSeenSeconds = 259200;
        private int reward = 250;
        public bool EventStarted = false;
        public bool hitBalloon = false;
        public bool hitPlayer = false;
        public bool lockcrate = false;
        public bool usedirection = true;
        private int locktime = 120;
        private int CrateAmount;
        public uint BloonNetID;
        public BasePlayer eventplayer;
        public LockedByEntCrate locked;
        public bool Effects = true;
        float max = TerrainMeta.Size.x / 2;
        const string bloonprefab = "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab";
        const string c4Explosion = "assets/prefabs/npc/patrol helicopter/effects/rocket_explosion.prefab";
        const string boom = "assets/prefabs/npc/patrol helicopter/effects/heli_explosion.prefab";
        const string crates = "assets/prefabs/npc/patrol helicopter/heli_crate.prefab";
        const string supply = "assets/prefabs/misc/supply drop/supply_drop.prefab";
        const string fireball = "assets/bundled/prefabs/oilfireballsmall.prefab";
        private HashSet<LockedByEntCrate> lockedCrates = new HashSet<LockedByEntCrate>();
        public StorageContainer fuelTank;
        string colorTextMsg;
        string colorTextMsgB;



        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {

                ["Location"] = "Kill the sleeper <color=green>{0}</color> at Loc X= <color=red>{1}</color>, Z= <color=red>{2}</color> and get a reward!",
                ["noperm"] = "You do not have permissions to use this command!",
                ["found"] = "<color=green> {0}</color> has been found by <color=red>{1}</color>!",
                ["dead"] = "<color=green> {0}</color> has been killed by <color=red>{1}</color> and he received <color=orange>{2}</color> RP for his service!",
                ["msgNorth"] = "North",
                ["msgNorthEast"] = "NorthEast",
                ["msgEast"] = "East",
                ["msgSouthEast"] = "SouthEast",
                ["msgSouth"] = "South",
                ["msgSouthWest"] = "SouthWest",
                ["msgWest"] = "West",
                ["msgNorthWest"] = "NorthWest",
                ["NoRewards"] = "<color=green> {0}</color> has been killed by <color=red>{1}</color>",
                ["noSleepers"] = "No sleepers have been sleeping to long to start event!",
                ["eventstarted"] = "There is one event already started!",
                ["reset"] = "Sleep data reset events!",
                ["NoEvent"] = "There is no event running!",
                ["CoolDown"] = "You are on cooldown, Try again in {0} seconds!",
                ["LocationBloon"] = "Kill the sleeper <color=green>{0}</color> at Loc X= <color=red>{1}</color>, Z= <color=red>{2}</color> He is flying around in the bloon and get a reward!",
                ["LocationBloonDirection"] = "Kill the sleeper <color=green>{2}</color> He is flying around in the bloon at Loc X= <color=red>{3}</color>, Z= <color=red>{4}</color> and get a reward!\nThey are  <color=yellow>{0:F0}m</color> away from you at direction <color=yellow>{1}</color>",
                ["LocationDirection"] = "Kill the sleeper <color=green>{2}</color> at Loc X= <color=red>{3}</color>, Z= <color=red>{4}</color> and get a reward!\nThey are  <color=yellow>{0:F0}m</color> away from you at direction <color=yellow>{1}</color>",
                ["help"] = "/sleeper commands are - event - score - topscore -",
            }, this);
        }

        void Unload()
        {
            EventEnd();
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
            {
                foreach (var ui in UsedUI)
                    ui.Destroy(player);
            }


        }
        void Init()
        {
            PCDDATA = Interface.Oxide.DataFileSystem.GetFile("SleeperMark/SleeperMark_Player");
            LoadData();
            LoadVariables();
            RegisterPermissions();
            resetdataboot();
        }
        void OnServerInitialized()
        {
            CheckDependencies();
            lockedCrates = new HashSet<LockedByEntCrate>(GameObject.FindObjectsOfType<LockedByEntCrate>());
            foreach (var player in BasePlayer.activePlayerList.ToList())
            {
                PlayerData.TryLoad(player);
                LoadSleepers();
            }
        }
        private void RegisterPermissions()
        {
            permission.RegisterPermission("SleeperMark.admin", this);
            permission.RegisterPermission("SleeperMark.ignore", this);
            permission.RegisterPermission("SleeperMark.use", this);
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        void LoadVariables()
        {
            debug = Convert.ToBoolean(GetConfig("SETTINGS", "Debug", false));
            useRewards = Convert.ToBoolean(GetConfig("SETTINGS", "useRewards", false));
            LastSeenSeconds = Convert.ToInt32(GetConfig("SETTINGS", "LastSeenSeconds", 259200));
            reward = Convert.ToInt32(GetConfig("SETTINGS", "reward", 250));
            useguiAnnounce = Convert.ToBoolean(GetConfig("SETTINGS", "usegui", false));
            useBloon = Convert.ToBoolean(GetConfig("SETTINGS", "useBloon", false));
            usedirection = Convert.ToBoolean(GetConfig("Generic", "Broadcast direction in chat messages", true));
            useAirdrop = Convert.ToBoolean(GetConfig("LootDrops", "useLootCrates", true));
            lockcrate = Convert.ToBoolean(GetConfig("LootDrops", "LockLootCrates", true));
            locktime = Convert.ToInt32(GetConfig("LootDrops", "LockTimeCrate", 120));
            CrateAmount = Convert.ToInt32(GetConfig("LootDrops", "CrateAmount", 3));
            cooldownTime = Convert.ToInt32(GetConfig("SETTINGS", "cooldownTime", 120));
            colorTextMsg = Convert.ToString(GetConfig("Generic", "UI Broadcast messages color", "yellow"));
            colorTextMsgB = Convert.ToString(GetConfig("Generic", "UI Broadcast messages Background color", "purple"));
            Puts("Config Loaded");
            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new configuration file!");
            LoadVariables();
        }

        private void CheckDependencies()
        {
            if (ServerRewards == null)
            {
                PrintWarning($"ServerRewards could not be found! Disabling RP feature");
                useRewards = false;
            }
            if (ServerRewards && !useRewards)
            {
                Puts("ServerReward found but not enabled in config.");
            }
            if (GUIAnnouncements == null)
            {
                PrintWarning($"guiAnnounce could not be found! Disabling guiAnnounce feature");
                useguiAnnounce = false;
            }
            if (GUIAnnouncements && !useguiAnnounce)
            {
                Puts("GUIAnnouncements found but not enabled in config.");
            }
        }

        void LoadData()
        {
            try
            {
                pcdData = Interface.Oxide.DataFileSystem.ReadObject<PlayerEntity>("SleeperMark/SleeperMark_Player");
            }
            catch
            {
                Puts("Couldn't load Sleep data, creating new Playerfile");
                pcdData = new PlayerEntity();
            }
        }
        class PlayerEntity
        {
            public Dictionary<ulong, PCDInfo> pEntity = new Dictionary<ulong, PCDInfo>();


            public PlayerEntity() { }
        }
        class PCDInfo
        {
            public long LogOutDay;
            public float LocEntityX;
            public float LocEntityY;
            public float LocEntityZ;
            public uint BloonID;
            public long Cooldown;
            public PCDInfo() { }
            public PCDInfo(long cd)
            {
            }
        }
        void SaveData()
        {
            PCDDATA.WriteObject(pcdData);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            ulong playerId = player.userID;
            double timeStamp = GrabCurrentTime();
            if (!pcdData.pEntity.ContainsKey(playerId))
            {

                pcdData.pEntity.Add(playerId, new PCDInfo());
                pcdData.pEntity[playerId].LogOutDay = (long)timeStamp;
                pcdData.pEntity[playerId].LocEntityX = player.transform.position.x;
                pcdData.pEntity[playerId].LocEntityY = player.transform.position.y;
                pcdData.pEntity[playerId].LocEntityZ = player.transform.position.z;
                SaveData();
            }

            else
            {
                pcdData.pEntity[playerId].LogOutDay = (long)timeStamp;
                pcdData.pEntity[playerId].LocEntityX = player.transform.position.x;
                pcdData.pEntity[playerId].LocEntityY = player.transform.position.y;
                pcdData.pEntity[playerId].LocEntityZ = player.transform.position.z;
                SaveData();
            }
        }

        readonly Dictionary<ulong, Timer> timers = new Dictionary<ulong, Timer>();
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null) return;
            if (info.Initiator == null) return;
            if (entity == null) return;
            if (!EventStarted) return;


            if (!hitBalloon && entity is HotAirBalloon && EventStarted && entity.net.ID == BloonNetID && (info.Initiator is BasePlayer))       
            {
            if (debug) Puts("Debug running onentitytakedamage Bloon");

                var controller = entity.GetComponent<HotAirBalloon>();
                hitBalloon = true;

                controller.SetFlag(BaseEntity.Flags.On, false);
                controller.windForce = 1000f;

                if (Effects)
                {

                    Effect.server.Run(boom, entity.transform.position + Vector3.up * 6);
                    timer.Repeat(2, 10, () =>
                                   {
                                       if (entity != null && EventStarted) Effect.server.Run(c4Explosion, entity.transform.position + Vector3.up * 6);
                                   });

                }
                timer.Once(160, () =>
                {
                    hitBalloon = false;
                    controller.SetFlag(BaseEntity.Flags.On, true);
                    controller.windForce = 0f;
                });
            }

            if (!entity || !(entity is BasePlayer) || !(info.Initiator is BasePlayer) || info.Initiator is NPCMurderer || info.Initiator is BaseNpc || info.Initiator is NPCPlayerApex || entity is NPCMurderer || entity is BaseNpc || entity is NPCPlayerApex || entity is HTNPlayer || info.Initiator is HTNPlayer)
                return;
            BasePlayer player = entity as BasePlayer;
            var attacker = info.Initiator as BasePlayer;
            if (!player.userID.IsSteamId() || !attacker.userID.IsSteamId()) return;
            if (!player.IsSleeping())
                return;
            ulong playerId = player.userID;
            double timeStamp = GrabCurrentTime();
            var t = pcdData.pEntity[playerId].LogOutDay + LastSeenSeconds;
            if (player.IsSleeping() && (playerId == eventplayer.userID) && (timeStamp > t) && (!hitPlayer) && (EventStarted))
            {
                PrintToChat(string.Format(lang.GetMessage("found", this), player.displayName, attacker.displayName));
                hitPlayer = true;
                return;
            }

        }

       /* void OnPlayerInit(BasePlayer player)
        {
            PlayerData.TryLoad(player);
        }
*/



        void rewardplayer(BasePlayer player, BasePlayer attacker)
        {
                if (debug) Puts("Debug running rewards Start ...");
                PlayerData victimData = PlayerData.Find(player);
                PlayerData attackerData = PlayerData.Find(attacker);
                if (debug) Puts("Debug got player data");
                
                if (useAirdrop && attacker != null) 
                {
                    SpawnLoot(CrateAmount, attacker);
                }
                if (useRewards)
                {
                    if (debug) Puts("Running Use Rewards");
                    PrintToChat(string.Format(lang.GetMessage("dead", this), player.displayName, attacker.displayName, reward));
                    Effect.server.Run("assets/bundled/prefabs/fx/explosions/explosion_01.prefab", attacker.transform.position);
                    EventEnd();
                    ServerRewards?.Call("AddPoints", attacker.userID, (int)reward);

                }
                else
                {
                    if (debug) Puts("Running Not Use Rewards");
                    PrintToChat(string.Format(lang.GetMessage("NoRewards", this), player.displayName, attacker.displayName));
                    Effect.server.Run("assets/bundled/prefabs/fx/explosions/explosion_01.prefab", attacker.transform.position);
                    EventEnd();                  
                }
                if (attackerData != null)
                 {
                if (debug) Puts("Debug running Scoreboard under rewards attackerData save...");
                    attackerData.kills++;
                    attackerData.Save();
                }

                if (victimData != null)
                 {
                if (debug) Puts("Debug running Scoreboard under rewards victimData save...");
                    victimData.deaths++;
                    victimData.Save();
                }
            }






        void OnEntityDeath(BaseCombatEntity victimEntity, HitInfo info)
        {
            if (info == null) return;
            if (info.Initiator == null) return;
            if (victimEntity == null) return;
            if (!EventStarted) return;
            if (info.Initiator is NPCMurderer || info.Initiator is BaseNpc || info.Initiator is NPCPlayerApex || victimEntity is NPCMurderer || victimEntity is BaseNpc || victimEntity is NPCPlayerApex || victimEntity is HTNPlayer || info.Initiator is HTNPlayer) return;
            
            if ((victimEntity is BasePlayer) && !(info.Initiator is BasePlayer))
            {
                BasePlayer player4 = victimEntity as BasePlayer;
            if (player4.userID == eventplayer.userID) EventEnd();
            if (debug) Puts("Player killed By Unknown.");
            }


            if ((victimEntity is HotAirBalloon) && !(info.Initiator is BasePlayer) && victimEntity.net.ID == BloonNetID)
            {
                EventEnd();
            if (debug) Puts("Bloon Destroyed By Unknown");
            }

            if ((victimEntity is HotAirBalloon) && (info.Initiator is BasePlayer) && victimEntity.net.ID == BloonNetID)
            {
                if (eventplayer != null && eventplayer.IsSleeping())
                if (debug) Puts("Debug running onentitydeath bloon destroyed killing player");
                eventplayer.Hurt(1000);
                rewardplayer(eventplayer, (BasePlayer)info.Initiator);
                return;
            }
            if (!victimEntity || !(victimEntity is BasePlayer) || !(info.Initiator is BasePlayer) || info.Initiator is NPCMurderer || info.Initiator is BaseNpc || info.Initiator is NPCPlayerApex || victimEntity is NPCMurderer || victimEntity is BaseNpc || victimEntity is NPCPlayerApex || victimEntity is HTNPlayer || info.Initiator is HTNPlayer)
                return;
            BasePlayer player = victimEntity as BasePlayer;
            if (!player.IsSleeping())
                return;
            ulong playerId = player.userID;
            double timeStamp = GrabCurrentTime();
            var attacker = info.Initiator as BasePlayer;
            if (!player.userID.IsSteamId() || !attacker.userID.IsSteamId()) return;

            var t = pcdData.pEntity[playerId].LogOutDay + LastSeenSeconds;
            var bloonEntity = BaseNetworkable.serverEntities.Find(BloonNetID) as BaseEntity;
            if (eventplayer.userID != playerId) return;
            if (player.IsSleeping() && (pcdData.pEntity.ContainsKey(playerId)) && (timeStamp > t) && (EventStarted))
            {
            if (debug) Puts("Debug running onentitydeath reward player");
            rewardplayer(eventplayer, attacker);
            }
        }

        static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        [ConsoleCommand("sleepermark")]
        void cmdRun(ConsoleSystem.Arg arg)
        {
            FindPositionsleep(null);
        }

        [ChatCommand("sleepermark")]
        private void sleepermark(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, "SleeperMark.admin"))
            {
                SendReply(player, string.Format(lang.GetMessage("noperm", this, player.UserIDString)));
                return;
            }
            else
            {
                FindPositionsleep(player);
            }
        }

        [ChatCommand("sleeper")]
        private void sleeperevent(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "SleeperMark.use"))
            {
                SendReply(player, string.Format(lang.GetMessage("noperm", this, player.UserIDString)));
                return;
            }
            else if (args.Length == 0)
            { 
                    SendReply(player, string.Format(lang.GetMessage("help", this, player.UserIDString)));
                    return;
            }
            else if (args[0] == "topscore")
            { 
                    DrawKDRWindow(player);
                    return;
            }
            else if (args[0] == "score")
            { 
                    GetCurrentStats(player);
                    return;
            }
            else if (EventStarted && args[0] == "event")
            {                   
                    var loc = new Vector3(eventplayer.transform.position.x, 20, eventplayer.transform.position.z);
                    double timeStamp = GrabCurrentTime();
                    var cdTime = pcdData.pEntity[player.userID].Cooldown; // Get the cooldown time of the User
                    if (cdTime > timeStamp)
                    {
                        SendReply(player, string.Format(lang.GetMessage("CoolDown", this, player.UserIDString), (int)(cdTime - timeStamp)));
                        return;
                    }
                    if (!useBloon && !usedirection)
                    {
                    SendReply(player, string.Format(lang.GetMessage("Location", this, player.UserIDString), eventplayer.displayName, eventplayer.transform.position.x, eventplayer.transform.position.z));
                    }
                    else if (!useBloon && usedirection)
                    {
                    var msg1 = string.Format(lang.GetMessage("LocationDirection", this, player.UserIDString), Vector3.Distance(player.transform.position, loc), GetDirectionAngle(Quaternion.LookRotation((loc - player.eyes.position).normalized).eulerAngles.y, player.UserIDString), eventplayer.displayName, eventplayer.transform.position.x, eventplayer.transform.position.z);
                    MessageToPlayer(player, msg1);
                    }
                    else if (useBloon && !usedirection)
                    {    
                    SendReply(player, string.Format(lang.GetMessage("LocationBloon", this, player.UserIDString), eventplayer.displayName, eventplayer.transform.position.x, eventplayer.transform.position.z));
                    }
                    else
                    {
                    var msg = string.Format(lang.GetMessage("LocationBloonDirection", this, player.UserIDString), Vector3.Distance(player.transform.position, loc), GetDirectionAngle(Quaternion.LookRotation((loc - player.eyes.position).normalized).eulerAngles.y, player.UserIDString), eventplayer.displayName, eventplayer.transform.position.x, eventplayer.transform.position.z);
                    MessageToPlayer(player, msg); 
                    }
                    pcdData.pEntity[player.userID].Cooldown = (long)timeStamp + cooldownTime;
                    SaveData();
                }
                else if (!EventStarted && args[0] == "event")
                {
                    SendReply(player, string.Format(lang.GetMessage("NoEvent", this, player.UserIDString)));

                }
            }
        


        private void SpawnLoot(int amount, BaseEntity EntitySpawn)
        {
            if (amount == 0)
                return;

            for (int j = 0; j < amount; j++)
            {
                Vector3 randsphere = UnityEngine.Random.onUnitSphere;
                Vector3 entpos = (EntitySpawn.transform.position + new Vector3(0f, 1.5f, 0f)) + (randsphere * UnityEngine.Random.Range(-2f, 3f));

                var ent = crates;
                BaseEntity crate = GameManager.server.CreateEntity(ent, entpos, Quaternion.LookRotation(randsphere), true);
                if (crate == null) return;
                crate.Spawn();

                Rigidbody rigidbody;

                rigidbody = crate.gameObject.AddComponent<Rigidbody>();
                FireBall fireBall = GameManager.server.CreateEntity(fireball) as FireBall;
                if (fireBall == null) return;
                //SpawnFireball(crate);
                if (rigidbody != null)
                {
                    rigidbody.isKinematic = false;
                    rigidbody.useGravity = true;
                    rigidbody.mass = 0.55f;
                    rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
                    rigidbody.drag = 0.25f;
                    rigidbody.angularDrag = 0.1f;
                    rigidbody.AddForce((EntitySpawn.transform.forward + (EntitySpawn.transform.right * UnityEngine.Random.Range(-5f, 5f))) * 50);
                    Puts("Calling for fireballs.");
                    fireBall.Spawn();
                    fireBall.SetParent(crate);

                    fireBall.GetComponent<Rigidbody>().isKinematic = true;
                    fireBall.GetComponent<Collider>().enabled = false;

                    fireBall.Invoke(fireBall.Extinguish, locktime);

                    if (lockcrate)
                    {
                        var cratelock = (crate as LockedByEntCrate);
                        cratelock.SetLocked(true);
                        locked = cratelock;
                        timer.Once(locktime, () => { UnlockCrate(cratelock); locked = null;  });

                    }
                }

            }
        }

        private void UnlockCrate(LockedByEntCrate crate)
        {
            if (debug) Puts("Running UnlockCrate");
            if (crate == null || (crate?.IsDestroyed ?? true)) return;
            var lockingEnt = (crate?.lockingEnt != null) ? crate.lockingEnt.GetComponent<FireBall>() : null;
            if (lockingEnt != null && !lockingEnt.IsDestroyed)
            {
                lockingEnt.enableSaving = false; //again trying to fix issue with savelist
                lockingEnt.CancelInvoke(lockingEnt.Extinguish);
                lockingEnt.Invoke(lockingEnt.Extinguish, 30f);
            }
            crate.CancelInvoke(crate.Think);
            crate.SetLocked(false);
            crate.lockingEnt = null;
        }


        [ChatCommand("sleepermarkfind")]
        private void test(BasePlayer player)
        {
            if (debug) Puts("Running sleepermarkfind");
            if (!permission.UserHasPermission(player.UserIDString, "SleeperMark.admin"))
            {
                SendReply(player, string.Format(lang.GetMessage("noperm", this, player.UserIDString)));
                return;
            }
            if (permission.UserHasPermission(player.UserIDString, "SleeperMark.admin"))
            {
                FindPositionsleepsetup();
            }
        }
        private BaseEntity InstantiateEntity(string type, Vector3 position, Quaternion rotation)
        {
            var gameObject = Instantiate.GameObject(GameManager.server.FindPrefab(type), position, rotation);
            gameObject.name = type;

            SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);

            UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());

            if (!gameObject.activeSelf)
                gameObject.SetActive(true);

            BaseEntity component = gameObject.GetComponent<BaseEntity>();
            return component;
        }


        private void EventEnd()
        {
            if (useBloon && EventStarted)
            {
                var targetEntity = BaseNetworkable.serverEntities.Find(BloonNetID) as BaseEntity;                
                var player = BasePlayer.sleepingPlayerList.ToList().Find(o => o.userID == eventplayer.userID);

                if (targetEntity != null)
                {      
                    targetEntity.Kill();
                }


        if(player == null)
            {
                    player = BasePlayer.activePlayerList.ToList().Find(o => o.userID == eventplayer.userID);
            }
                if (player != null)
                {
                    player.Teleport(new Vector3(pcdData.pEntity[eventplayer.userID].LocEntityX, pcdData.pEntity[eventplayer.userID].LocEntityY, pcdData.pEntity[eventplayer.userID].LocEntityZ));  
                    
                }   
                    hitPlayer = false;
                    EventStarted = false;
                    hitBalloon = false;
                    eventplayer = null; 
                    BloonNetID = 0;        
            }
        }



        private void FindPositionsleep(BasePlayer player1)
        {
            var onetimer = timer.Repeat(2.5f, 1, () => { SendReply(player1, string.Format(lang.GetMessage("noSleepers", this))); ; });
            if (EventStarted)
            {
                SendReply(player1, string.Format(lang.GetMessage("eventstarted", this)));
                onetimer.Destroy();
                if (eventplayer == null) EventEnd();
                if (!useBloon && eventplayer != null) PrintToChat(string.Format(lang.GetMessage("Location", this), eventplayer.displayName, eventplayer.transform.position.x, eventplayer.transform.position.z));
                if (useBloon && eventplayer != null) PrintToChat(string.Format(lang.GetMessage("LocationBloon", this), eventplayer.displayName, eventplayer.transform.position.x, eventplayer.transform.position.z));
                return;
            }




            
            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
            {
                if (EventStarted && player.userID == eventplayer.userID) return;
                double timeStamp = GrabCurrentTime();
                ulong playerId = player.userID;
                FindPositionsleepsetup();

                if (!pcdData.pEntity.ContainsKey(playerId)) return;

                var t = pcdData.pEntity[playerId].LogOutDay + LastSeenSeconds;
                var a = pcdData.pEntity[playerId].LocEntityX;
                var b = pcdData.pEntity[playerId].LocEntityY;
                var c = pcdData.pEntity[playerId].LocEntityZ;

                if (pcdData.pEntity.ContainsKey(playerId) && (timeStamp > t) && !useBloon && !permission.UserHasPermission(player.UserIDString, "SleeperMark.ignore"))
                {
                    Effect.server.Run("assets/bundled/prefabs/fx/explosions/explosion_01.prefab", player.transform.position);
                    SaveData();
                    EventStarted = true;
                    eventplayer = player;
                    if (useguiAnnounce) MessageToAllGui(string.Format(lang.GetMessage("Location", this), player.displayName, a, c));
                    NotifyOnEvent(player);
                    onetimer.Destroy();
                    break;
                }
                if (pcdData.pEntity.ContainsKey(playerId) && (timeStamp > t) && useBloon && !permission.UserHasPermission(player.UserIDString, "SleeperMark.ignore"))
                {
                    var playerPos = player.transform.position + new Vector3(0, 250.1f, 0);
                    var playerRot = player.transform.rotation;   
                    BaseEntity entity = InstantiateEntity(bloonprefab, (Vector3)playerPos, playerRot);
                    entity.Spawn();
                    EventStarted = true;
                    var controller = entity.GetComponent<HotAirBalloon>();
                    fuelTank = controller.fuelSystem?.GetFuelContainer();
                    Item item = ItemManager.CreateByItemID(-946369541, 5);
                    item.MoveToContainer(fuelTank.inventory, -1, true);
                    controller.SetFlag(BaseEntity.Flags.Reserved6, true);
                    controller.SetFlag(BaseEntity.Flags.On, true);
                    controller.SetFlag(BaseEntity.Flags.Locked, true);
                    controller.windForce = 0f;
                    controller.inflationLevel = 1f;
                    controller.fuelPerSec = 0f;
                    var playermount = entity.transform.position + new Vector3(0, 0.4f, 0);
                    var x = entity.transform.position.x;
                    var z = entity.transform.position.z;
                    player.transform.position = playermount;
                    BloonNetID = entity.net.ID;
                    eventplayer = player;
                    SaveData();
                    NotifyOnEvent(player);
                    onetimer.Destroy();
                    if (useguiAnnounce) MessageToAllGui(string.Format(lang.GetMessage("LocationBloon", this), player.displayName, x, z));
                    break;
                }

            }

        }


        [ChatCommand("sleepermarkreset")]
        private void resetdata(BasePlayer reset1)
        {
            SendReply(reset1, string.Format(lang.GetMessage("reset", this, reset1.UserIDString)));
            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
            {

                ulong playerId = player.userID;
                FindPositionsleepsetup();
                SaveData();
                EventEnd();

            }
        }

        private void resetdataboot()
        {
            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
            {

                ulong playerId = player.userID;
                FindPositionsleepsetup();
                SaveData();
                EventStarted = false;
                hitPlayer = false;
                hitBalloon = false;
            }
        }

        private void FindPositionsleepsetup()
        {
            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
            {
                ulong playerId = player.userID;
                double timeStamp = GrabCurrentTime();
                if (!pcdData.pEntity.ContainsKey(playerId))
                {
                    pcdData.pEntity.Add(playerId, new PCDInfo());
                    pcdData.pEntity[playerId].LogOutDay = (long)timeStamp;
                    pcdData.pEntity[playerId].LocEntityX = player.transform.position.x;
                    pcdData.pEntity[playerId].LocEntityY = player.transform.position.y;
                    pcdData.pEntity[playerId].LocEntityZ = player.transform.position.z;
                    SaveData();
                    Puts(player.displayName);
                }
            }
        }
        void MessageToAllGui(string message)
        {
            foreach (var player in BasePlayer.activePlayerList.ToList())
            {
                GUIAnnouncements?.Call("CreateAnnouncement", message, colorTextMsgB, colorTextMsg, player);
            }
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            ulong playerId = player.userID;
            double timeStamp = GrabCurrentTime();
            if (!pcdData.pEntity.ContainsKey(playerId))
            {

                pcdData.pEntity.Add(playerId, new PCDInfo());
                SaveData();

            }
            {
                pcdData.pEntity[playerId].LogOutDay = (long)timeStamp;
                pcdData.pEntity[playerId].LocEntityX = player.transform.position.x;
                pcdData.pEntity[playerId].LocEntityY = player.transform.position.y;
                pcdData.pEntity[playerId].LocEntityZ = player.transform.position.z;
                SaveData();
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
			
			if (player == null) return;
			if (!player.userID.IsSteamId()) return;
				PlayerData.TryLoad(player);
            ulong playerId = player.userID;
            double timeStamp = GrabCurrentTime();
			
			
            if (!pcdData.pEntity.ContainsKey(playerId))
            {
                pcdData.pEntity.Add(playerId, new PCDInfo());
            }
           {

                pcdData.pEntity[playerId].LogOutDay = (long)timeStamp;
                pcdData.pEntity[playerId].LocEntityX = player.transform.position.x;
                pcdData.pEntity[playerId].LocEntityY = player.transform.position.y;
                pcdData.pEntity[playerId].LocEntityZ = player.transform.position.z;
                SaveData();
            }

			if (eventplayer == null) return;
            if (playerId == eventplayer.userID)
            {
                EventEnd();
                EventStarted = false;
                hitPlayer = false;
                hitBalloon = false;
            }
        }


        void MessageToPlayer(BasePlayer player, string message)
        {
            PrintToChat(player, string.Format(message));
        }
        string GetDirectionAngle(float angle, string UserIDString)
        {
            if (angle > 337.5 || angle < 22.5)
                return lang.GetMessage("msgNorth", this, UserIDString);
            else if (angle > 22.5 && angle < 67.5)
                return lang.GetMessage("msgNorthEast", this, UserIDString);
            else if (angle > 67.5 && angle < 112.5)
                return lang.GetMessage("msgEast", this, UserIDString);
            else if (angle > 112.5 && angle < 157.5)
                return lang.GetMessage("msgSouthEast", this, UserIDString);
            else if (angle > 157.5 && angle < 202.5)
                return lang.GetMessage("msgSouth", this, UserIDString);
            else if (angle > 202.5 && angle < 247.5)
                return lang.GetMessage("msgSouthWest", this, UserIDString);
            else if (angle > 247.5 && angle < 292.5)
                return lang.GetMessage("msgWest", this, UserIDString);
            else if (angle > 292.5 && angle < 337.5)
                return lang.GetMessage("msgNorthWest", this, UserIDString);
            return "";
        }
        void NotifyOnEvent(BasePlayer loc)
        {
            foreach (var player in BasePlayer.activePlayerList.ToList())
            {
            if (!useBloon && !usedirection)
            {
            SendReply(player, string.Format(lang.GetMessage("Location", this, player.UserIDString), eventplayer.displayName, eventplayer.transform.position.x, eventplayer.transform.position.z));
            }
            else if (!useBloon && usedirection)
            {
            var msg1 = string.Format(lang.GetMessage("LocationDirection", this, player.UserIDString), Vector3.Distance(player.transform.position, loc.transform.position), GetDirectionAngle(Quaternion.LookRotation((loc.transform.position - player.eyes.position).normalized).eulerAngles.y, player.UserIDString), eventplayer.displayName, eventplayer.transform.position.x, eventplayer.transform.position.z);
            MessageToPlayer(player, msg1); 
            }
                    else if (useBloon && !usedirection)
                    {    
                    SendReply(player, string.Format(lang.GetMessage("LocationBloon", this, player.UserIDString), eventplayer.displayName, eventplayer.transform.position.x, eventplayer.transform.position.z));                       
                    }
                    else if (useBloon && usedirection)
                    {
                    var msg = string.Format(lang.GetMessage("LocationBloonDirection", this, player.UserIDString), Vector3.Distance(player.transform.position, loc.transform.position), GetDirectionAngle(Quaternion.LookRotation((loc.transform.position - player.eyes.position).normalized).eulerAngles.y, player.UserIDString), eventplayer.displayName, eventplayer.transform.position.x, eventplayer.transform.position.z);
                    MessageToPlayer(player, msg); 
               }       
             }
           }

        class PlayerData
        {
            public ulong id;
            public string name;
            public int kills;
            public int deaths;
            internal float KDR => deaths == 0 ? kills : (float)Math.Round(((float)kills) / deaths, 1);

            internal static void TryLoad(BasePlayer player)
            {
				if (player == null) return;
                if (Find(player) != null)
                    return;

                PlayerData data = Interface.Oxide.DataFileSystem.ReadObject<PlayerData>($"SleeperMark/gui/{player.userID}");

                if (data == null || data.id == 0)
                {
                    data = new PlayerData
                    {
                        id = player.userID,
                        name = player.displayName
                    };
                }
                else
                    data.Update(player);

                data.Save();
                LoadedPlayerData.Add(data);
            }

            internal void Update(BasePlayer player)
            {
                name = player.displayName;
                Save();
            }

            internal void Save() => Interface.Oxide.DataFileSystem.WriteObject($"SleeperMark/gui/{id}", this, true);
            internal static PlayerData Find(BasePlayer player)
            {

                PlayerData data = LoadedPlayerData.ToList().Find((p) => p.id == player.userID);

                return data;
            }
        }

        // UI Classes - Created by LaserHydra
        class UIColor
        {
            double red;
            double green;
            double blue;
            double alpha;

            public UIColor(double red, double green, double blue, double alpha)
            {
                this.red = red;
                this.green = green;
                this.blue = blue;
                this.alpha = alpha;
            }

            public override string ToString()
            {
                return $"{red.ToString()} {green.ToString()} {blue.ToString()} {alpha.ToString()}";
            }
        }

        class UIObject
        {
            List<object> ui = new List<object>();
            List<string> objectList = new List<string>();

            public UIObject()
            {
            }

            public string RandomString()
            {
                string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
                List<char> charList = chars.ToList();

                string random = "";

                for (int i = 0; i <= UnityEngine.Random.Range(5, 10); i++)
                    random = random + charList[UnityEngine.Random.Range(0, charList.Count - 1)];

                return random;
            }

            public void Draw(BasePlayer player)
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", JsonConvert.SerializeObject(ui).Replace("{NEWLINE}", Environment.NewLine));
            }

            public void Destroy(BasePlayer player)
            {
                foreach (string uiName in objectList)
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", uiName);
            }

            public string AddPanel(string name, double left, double top, double width, double height, UIColor color, bool mouse = false, string parent = "Overlay")
            {
                name = name + RandomString();

                string type = "";
                if (mouse) type = "NeedsCursor";

                ui.Add(new Dictionary<string, object> {
                    {"name", name},
                    {"parent", parent},
                    {"components",
                        new List<object> {
                            new Dictionary<string, string> {
                                {"type", "UnityEngine.UI.Image"},
                                {"color", color.ToString()}
                            },

                            new Dictionary<string, string> {
                                {"type", "RectTransform"},
                                {"anchormin", $"{left.ToString()} {((1 - top) - height).ToString()}"},
                                {"anchormax", $"{(left + width).ToString()} {(1 - top).ToString()}"}
                            },
                            new Dictionary<string, string> {
                                {"type", type}
                            }
                        }
                    }
                });

                objectList.Add(name);
                return name;
            }

            public string AddText(string name, double left, double top, double width, double height, UIColor color, string text, int textsize = 15, string parent = "Overlay", int alignmode = 0)
            {
                name = name + RandomString(); text = text.Replace("\n", "{NEWLINE}"); string align = "";

                switch (alignmode)
                {
                    case 0: { align = "LowerCenter"; break; };
                    case 1: { align = "LowerLeft"; break; };
                    case 2: { align = "LowerRight"; break; };
                    case 3: { align = "MiddleCenter"; break; };
                    case 4: { align = "MiddleLeft"; break; };
                    case 5: { align = "MiddleRight"; break; };
                    case 6: { align = "UpperCenter"; break; };
                    case 7: { align = "UpperLeft"; break; };
                    case 8: { align = "UpperRight"; break; };
                }

                ui.Add(new Dictionary<string, object> {
                    {"name", name},
                    {"parent", parent},
                    {"components",
                        new List<object> {
                            new Dictionary<string, string> {
                                {"type", "UnityEngine.UI.Text"},
                                {"text", text},
                                {"fontSize", textsize.ToString()},
                                {"color", color.ToString()},
                                {"align", align}
                            },
                            new Dictionary<string, string> {
                                {"type", "RectTransform"},
                                {"anchormin", $"{left.ToString()} {((1 - top) - height).ToString()}"},
                                {"anchormax", $"{(left + width).ToString()} {(1 - top).ToString()}"}
                            }
                        }
                    }
                });

                objectList.Add(name);
                return name;
            }

            public string AddButton(string name, double left, double top, double width, double height, UIColor color, string command = "", string parent = "Overlay", string closeUi = "")
            {
                name = name + RandomString();

                ui.Add(new Dictionary<string, object> {
                    {"name", name},
                    {"parent", parent},
                    {"components",
                        new List<object> {
                            new Dictionary<string, string> {
                                {"type", "UnityEngine.UI.Button"},
                                {"close", closeUi},
                                {"command", command},
                                {"color", color.ToString()},
                                {"imagetype", "Tiled"}
                            },

                            new Dictionary<string, string> {
                                {"type", "RectTransform"},
                                {"anchormin", $"{left.ToString()} {((1 - top) - height).ToString()}"},
                                {"anchormax", $"{(left + width).ToString()} {(1 - top).ToString()}"}
                            }
                        }
                    }
                });

                objectList.Add(name);
                return name;
            }

            public string AddImage(string name, double left, double top, double width, double height, UIColor color, string url = "http://oxidemod.org/data/avatars/l/53/53411.jpg?1427487325", string parent = "Overlay")
            {
                ui.Add(new Dictionary<string, object> {
                    {"name", name},
                    {"parent", parent},
                    {"components",
                        new List<object> {
                            new Dictionary<string, string> {
                                {"type", "UnityEngine.UI.Button"},
                                {"sprite", "assets/content/textures/generic/fulltransparent.tga"},
                                {"url", url},
                                {"color", color.ToString()},
                                {"imagetype", "Tiled"}
                            },

                            new Dictionary<string, string> {
                                {"type", "RectTransform"},
                                {"anchormin", $"{left.ToString().Replace(",", ".")} {((1 - top) - height).ToString().Replace(",", ".")}"},
                                {"anchormax", $"{(left + width).ToString().Replace(",", ".")} {(1 - top).ToString().Replace(",", ".")}"}
                            }
                        }
                    }
                });

                objectList.Add(name);
                return name;
            }
        }

        void DrawKDRWindow(BasePlayer player)
        {
            UIObject ui = new UIObject();
            string panel = ui.AddPanel("panel1", 0.0132382892057026, 0.0285714285714286, 0.958248472505092, 0.874285714285714, new UIColor(0, 0, 0, 1), true, "Overlay");
            ui.AddText("label8", 0.675876726886291, 0.248366013071895, 0.272051009564293, 0.718954248366013, new UIColor(1, 1, 1, 1), GetNames(), 24, panel, 7);
            ui.AddText("label7", 0.483528161530287, 0.248366013071895, 0.0563230605738576, 0.718954248366013, new UIColor(1, 1, 1, 1), GetKDRs(), 24, panel, 6);
            ui.AddText("label6", 0.269925611052072, 0.248366013071895, 0.0456960680127524, 0.718954248366013, new UIColor(1, 1, 1, 1), GetDeaths(), 24, panel, 6);
            ui.AddText("label5", 0.0786397449521785, 0.248366013071895, 0.0456960680127524, 0.718954248366013, new UIColor(1, 1, 1, 1), GetTopKills(), 24, panel, 6);
            string close = ui.AddButton("button1", 0.849096705632306, 0.0326797385620915, 0.124335812964931, 0.0871459694989107, new UIColor(1, 0, 0, 1), "", panel, panel);
            ui.AddText("button1_Text", 0, 0, 1, 1, new UIColor(0, 0, 0, 1), "Close", 19, close, 3);
            ui.AddText("label4", 0.470775770456961, 0.163398692810458, 0.0935175345377258, 0.0610021786492375, new UIColor(1, 0, 0, 1), "K/D Ratio", 24, panel, 7);
            ui.AddText("label3", 0.260361317747078, 0.163398692810458, 0.0722635494155154, 0.0610021786492375, new UIColor(1, 0, 0, 1), "Deaths", 24, panel, 7);
            ui.AddText("label2", 0.0786397449521785, 0.163398692810458, 0.0467587672688629, 0.0610021786492375, new UIColor(1, 0, 0, 1), "Kills", 24, panel, 7);
            ui.AddText("label1", 0.675876726886291, 0.163398692810458, 0.125398512221041, 0.0610021786492375, new UIColor(1, 0, 0, 1), "Player Name", 24, panel, 7);

            ui.Draw(player);
            UsedUI.Add(ui);
        }
        private void LoadSleepers()
        {
            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
                PlayerData.TryLoad(player);
        }
        string GetTopKills()
        {
            LoadSleepers();
            return string.Join("\n", LoadedPlayerData.OrderByDescending((d) => d.kills).Select((d) => $"{d.kills}").Take(15).ToArray());
        }
        string GetDeaths()
        {
            return string.Join("\n", LoadedPlayerData.OrderByDescending((d) => d.kills).Select((d) => $"{d.deaths}").Take(15).ToArray());
        }
        string GetKDRs()
        {
            return string.Join("\n", LoadedPlayerData.OrderByDescending((d) => d.kills).Select((d) => $"{d.KDR}").Take(15).ToArray());
        }
        string GetNames()
        {
            return string.Join("\n", LoadedPlayerData.OrderByDescending((d) => d.kills).Select((d) => $"{d.name}").Take(15).ToArray());
        }

        void GetCurrentStats(BasePlayer player)
        {
            PlayerData data = Interface.Oxide.DataFileSystem.ReadObject<PlayerData>($"SleeperMark/gui/{player.userID}");
            int kills = data.kills;
            int deaths = data.deaths;
            string playerName = data.name;
            float kdr = data.KDR;

            PrintToChat(player, "<color=red> Player Name : </color>" + $"{playerName}"
                        + "\n" + "<color=lime> Event-Kills : </color>" + $"{kills}"
                        + "\n" + "<color=lime> Event-Deaths : </color>" + $"{deaths}");
        }
    }
}

// --- End of file: SleeperMark.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/server-announcer ---
// --- Original File Path: S/ServerAnnouncer/ServerAnnouncer.cs ---

using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Server Announcer", "austinv900", "1.0.7")]
    [Description("Allows you to send messages as the server with custom prefix")]
    internal class ServerAnnouncer : CovalencePlugin
    {
        #region  Initialization

        private const string Permission = "ServerAnnouncer.Allowed";

        private void OnServerInitialized()
        {
            permission.RegisterPermission(Permission, this);
        }

        #endregion

        #region Localizations

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["MessageFormat"] = "[ServerConsole]: {0}",
                ["NoAccess"] = "You are not allowed to use this command",
                ["NoMessage"] = "You did not specify a message"
            }, this);
        }

        #endregion

        #region Commands

        [Command("say", "server.say")]
        private void Say(IPlayer player, string command, string[] args)
        {
            if (!IsAdmin(player)) { player.Reply(Lang("NoAccess", player)); return; }

            if (args.Length == 0) { player.Reply(Lang("NoMessage", player)); return; }

            foreach (var user in players.Connected)
            {
                var msg = Lang("MessageFormat", user, string.Join(" ", args));
                user.Message(msg);
            }
        }

        #endregion

        #region Helpers

        private bool IsAdmin(IPlayer player) => permission.UserHasGroup(player.Id, "admin") || permission.UserHasPermission(player.Id, Permission) || player.IsAdmin;

        private string Lang(string key, IPlayer player, params object[] args) => string.Format(lang.GetMessage(key, this, player.Id), args);

        #endregion
    }
}


// --- End of file: ServerAnnouncer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/server-rewards-wipe ---
// --- Original File Path: S/ServerRewardsWipe/ServerRewardsWipe.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
	[Info("Server Rewards Wipe", "ZEODE", "1.1.3")]
	[Description("Reset Server Rewards player RP on wipe or command.")]
	public class ServerRewardsWipe : CovalencePlugin
	{
		[PluginReference]
		private Plugin ServerRewards;

		private const string permAdmin = "serverrewardswipe.admin";

		private _PlayerData _playerData;
		private DynamicConfigFile _playerdata, _playerdatabackup;

		private class _PlayerData
		{
			public Dictionary<ulong, int> playerRP = new Dictionary<ulong, int>();
		}
		
		#region Oxide Hooks

		private void Init()
		{
			permission.RegisterPermission(permAdmin, this);
		}

		private void OnServerInitialized(bool initial)
		{
			_playerdata = Interface.Oxide.DataFileSystem.GetFile("ServerRewards/player_data");
			_playerdatabackup = Interface.Oxide.DataFileSystem.GetFile("ServerRewards/player_data_backup");

			timer.Once(5f, ()=>
			{
				if (!ServerRewards)
				{
					Puts("WARNING: ServerRewards plugin not found, unloading.");
					Interface.Oxide.UnloadPlugin(Name);
					return;
				}
				LoadRPData();
			});
		}

		private void OnNewSave(string filename)
		{
			if (config.options.ResetRPOnWipe)
			{
				// Make sure server startup is finished
				timer.Once(config.options.WipeDelay, ()=>
				{
					Puts($"INFO: Wipe detected, ServerRewards player RP reset in {config.options.WipeDelay} seconds...");
					ClearRPData();
				});
			}
		}

		#endregion

		#region Main

		private void LoadRPData()
		{
			try
			{
				_playerData = _playerdata.ReadObject<_PlayerData>();
				if (_playerData == null)
				{
					Puts($"ERROR: ServerRewards received data was null, aborted.");
					return;
				}
			}
			catch (Exception ex)
			{
				if (ex is JsonSerializationException || ex is NullReferenceException || ex is JsonReaderException)
				{
					Puts($"Exception Type: {ex.GetType()}");
					Puts($"INFO: {ex}");
					return;
				}
			}
		}

		private void WipeAndSaveRP()
		{
			if (_playerData == null)
			{
				Puts("ERROR: ServerRewards RP data not wiped, RP data was null.");
				return;
			}

			if (config.options.BackupRP)
			{
				Puts("INFO: ServerRewards RP data backed up to oxide/data/ServerRewards/player_data_backup.json...");
				_playerdatabackup.WriteObject(_playerData);
			}
			_playerData.playerRP.Clear();
			_playerdata.WriteObject(_playerData);
			Puts("INFO: ServerRewards RP data wiped...");
		}

		private void ClearRPData()
		{
			if (ServerRewards)
			{
				Puts("INFO: Unloading ServerRewards plugin...");
				Interface.Oxide.UnloadPlugin("ServerRewards");
				timer.Once(2f,()=>
				{
					WipeAndSaveRP();
					Puts("INFO: Finished, reloading ServerRewards.");
					Interface.Oxide.LoadPlugin("ServerRewards");
				});
			}
			else
			{
				Puts("ERROR: ServerRewards is not loaded, aborting.");
			}
		}

		[Command("clearrpdata")]
		private void cmdClearRPData(IPlayer player, string command, string[] args)
		{
			if (!player.HasPermission(permAdmin))
			{
				player.Reply(lang.GetMessage("NoPermission", this, player.Id));
				return;
			}
			ClearRPData();
		}

		#endregion
		
		#region Config & Language

		private ConfigData config;
		private class ConfigData
		{
			[JsonProperty(PropertyName = "Options")]
			public Options options;

			public class Options
			{
				[JsonProperty(PropertyName = "Reset ServerRewards player RP on wipe")]
				public bool ResetRPOnWipe { get; set; }
				[JsonProperty(PropertyName = "Backup player RP before wiping")]
				public bool BackupRP { get; set; }
				[JsonProperty(PropertyName = "Wipe delay (seconds) after server startup. Try increasing if RP wipe fails on startup")]
				public float WipeDelay { get; set; }
			}
			public VersionNumber Version { get; set; }
		}

		private ConfigData GetDefaultConfig()
		{
			return new ConfigData
			{
				options = new ConfigData.Options
				{
					ResetRPOnWipe = true,
					BackupRP = true,
					WipeDelay = 30f
				},
				Version = Version
			};
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				config = Config.ReadObject<ConfigData>();
				if (config == null)
				{
					LoadDefaultConfig();
				}
				else
				{
					UpdateConfigValues();
				}
			}
			catch (Exception ex)
			{
				if (ex is JsonSerializationException || ex is NullReferenceException || ex is JsonReaderException)
				{
					LoadDefaultConfig();
					return;
				}
				throw;
			}
		}

		protected override void LoadDefaultConfig()
		{
			Puts("Configuration file missing or corrupt, creating default config file. Ignore if this is first load.");
			config = GetDefaultConfig();
			SaveConfig();
		}

		protected override void SaveConfig()
		{
			Config.WriteObject(config);
		}

		private void UpdateConfigValues()
		{
			if (config.Version < Version)
			{
				ConfigData defaultConfig = GetDefaultConfig();

				Puts("Config update detected! Updating config file...");
				if (config.Version < new VersionNumber(1, 1, 0))
				{
					config = defaultConfig;
				}
				if (config.Version < new VersionNumber(1, 1, 3))
				{
					config.options.WipeDelay = defaultConfig.options.WipeDelay;
				}
				Puts("Config update completed!");
			}
			config.Version = Version;
			SaveConfig();
		}

		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["NoPermission"] = "You do not have permission to use this command."
			}, this, "en");
		}

		#endregion
	}
}

// --- End of file: ServerRewardsWipe.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/slack ---
// --- Original File Path: S/Slack/Slack.cs ---

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Slack", "Wulf/lukespragg", "0.1.7", ResourceId = 1952)]
    [Description("Plugin API for sending messages and notifications to Slack")]

    class Slack : CovalencePlugin
    {
        #region Initialization

        static readonly DateTime Epoch = new DateTime(1970, 1, 1);
        static readonly Regex Regex = new Regex(@"<avatarIcon><!\[CDATA\[(.*)\]\]></avatarIcon>");

        bool linkNames;
        bool serverInfo;
        string botName;
        string hookUrl;
        string iconUrl;

        protected override void LoadDefaultConfig()
        {
            Config["BotName"] = botName = GetConfig("BotName", "Oxide");
            Config["HookUrl"] = hookUrl = GetConfig("HookUrl", "");
            Config["IconUrl"] = iconUrl = GetConfig("IconUrl", "");
            Config["LinkNames"] = linkNames = GetConfig("LinkNames", true);
            Config["ServerInfo"] = serverInfo = GetConfig("ServerInfo", true);

            SaveConfig();
        }

        void Init() => LoadDefaultConfig();

        #endregion

        #region Basic Message API

        /// <summary>
        /// Sends a basic message to Slack using configured settings
        /// </summary>
        /// <param name="message"></param>
        /// <param name="channel"></param>
        /// <param name="callback"></param>
        void Message(string message, string channel = null, Action<bool> callback = null)
        {
            if (!ErrorChecks(message, false)) return;

            var payload = new SlackMessage
            {
                channel = channel,
                icon_url = iconUrl,
                link_names = linkNames ? "1" : "0",
                mrkdwn = "true",
                username = botName,
                text = message
            };
            PostToSlack(payload, callback);
        }

        #endregion

        #region Player Message API

        /// <summary>
        /// Sends a fancy message to Slack with linked profile, in-game avatar, and server information
        /// </summary>
        /// <param name="message"></param>
        /// <param name="player"></param>
        /// <param name="channel"></param>
        /// <param name="callback"></param>
        void FancyMessage(string message, IPlayer player, string channel = null, Action<bool> callback = null)
        {
            if (!ErrorChecks(message, true, player)) return;

            webrequest.EnqueueGet($"http://steamcommunity.com/profiles/{player.Id}?xml=1", (code, response) =>
            {
                string avatar = null;
                if (response != null && code == 200) avatar = Regex.Match(response).Groups[1].ToString();

                var payload = new SlackMessage
                {
                    attachments = new List<SlackAttachment>
                    {
                        new SlackAttachment
                        {
                            color = "#E68C17", // TODO: Config option
                            author_icon = avatar,
                            author_name = $"{player.Name} ({player.Id})",
                            author_link = $"http://steamcommunity.com/profiles/{player.Id}",
                            fallback = $"{player.Name}: {message}",
                            footer = serverInfo ? $"{server.Name}" : null, // ({server.Address})
                            text = message
                        }
                    },
                    channel = channel,
                    icon_url = iconUrl,
                    username = botName
                };
                PostToSlack(payload, callback);
            }, this);
        }

        /// <summary>
        /// Sends a simple message to Slack as a fake user with in-game avatar
        /// </summary>
        /// <param name="message"></param>
        /// <param name="player"></param>
        /// <param name="channel"></param>
        /// <param name="callback"></param>
        void SimpleMessage(string message, IPlayer player, string channel = null, Action<bool> callback = null)
        {
            if (!ErrorChecks(message, true, player)) return;

            webrequest.EnqueueGet($"http://steamcommunity.com/profiles/{player.Id}?xml=1", (code, response) =>
            {
                string avatar = null;
                if (response != null && code == 200) avatar = Regex.Match(response).Groups[1].ToString();

                var payload = new SlackMessage
                {
                    channel = channel,
                    icon_url = avatar,
                    link_names = linkNames ? "1" : "0",
                    mrkdwn = "true",
                    username = serverInfo ? $"{player.Name} @ {(server.Name).Truncate(20)}" : player.Name,
                    text = message
                };
                PostToSlack(payload, callback);
            }, this);
        }

        #endregion

        #region Ticket Message API

        /// <summary>
        /// Sends a ticket-styled message to Slack with reporter information and position
        /// </summary>
        /// <param name="message"></param>
        /// <param name="player"></param>
        /// <param name="channel"></param>
        /// <param name="callback"></param>
        void TicketMessage(string message, IPlayer player, string channel = null, Action<bool> callback = null)
        {
            if (!ErrorChecks(message, true, player)) return;

            webrequest.EnqueueGet($"http://steamcommunity.com/profiles/{player.Id}?xml=1", (code, response) =>
            {
                string avatar = null;
                if (response != null && code == 200) avatar = Regex.Match(response).Groups[1].ToString();
                var position = player.Position();

                var payload = new SlackMessage
                {
                    attachments = new List<SlackAttachment>
                    {
                        new SlackAttachment
                        {
                            color = "#E68C17", // TODO: Config option
                            author_name = $"{player.Name} ({player.Id})",
                            author_link = $"http://steamcommunity.com/profiles/{player.Id}",
                            fallback = $"{player.Name}: {message}",
                            fields = new List<SlackAttachmentField>
                            {
                                new SlackAttachmentField
                                {
                                    value = $"X: {position.X}, Y: {position.Y}, Z: {position.Z}",
                                    @short = "true"
                                }
                            },
                            footer = serverInfo ? $"{server.Name}" : null, // ({server.Address})
                            footer_icon = "http://i.imgur.com/AIF29RT.png",
                            text = message,
                            thumb_url = avatar,
                            ts = DateTime.UtcNow.Subtract(Epoch).TotalSeconds.ToString()
                        }
                    },
                    channel = channel,
                    icon_url = iconUrl,
                    username = botName
                };
                PostToSlack(payload, callback);
            }, this);
        }

        #endregion

        #region Slack API

        /// <summary>
        /// Posts SlackMessage payload to configured webhook service URL
        /// </summary>
        /// <param name="payload"></param>
        /// <param name="callback"></param>
        void PostToSlack(SlackMessage payload, Action<bool> callback)
        {
            if (payload == null || string.IsNullOrEmpty(hookUrl)) return;
            webrequest.EnqueuePost(hookUrl, JsonConvert.SerializeObject(payload), (code, response) =>
            {
                if (code != 200 || response == null) PrintWarning($"Slack API responded with: {response} ({code})");
                callback?.Invoke(code == 200 || response != null);
            }, this);
        }

        /// <summary>
        /// Required message base class for sending messages to Slack
        /// Reference: https://api.slack.com/methods/chat.postMessage
        /// </summary>
        class SlackMessage
        {
            public string channel { get; set; } // Channel, private group, or IM channel to send the message to
            public string icon_url { get; set; } // URL to an image to use as the icon for the message
            public string link_names { get; set; } // Pass true to find and link channel names and usernames
            public string mrkdwn { get; set; } // Pass true to allow Markdown formatting in the message
            public string text { get; set; } // Optional text of the message to send
            public string username { get; set; } // Name of the bot sending the message
            public List<SlackAttachment> attachments; // Messages can have zero or more attachments
        }

        /// <summary>
        /// Optional attachment class for use with SlackMessage to send attachment messages
        /// Reference: https://api.slack.com/docs/attachments
        /// </summary>
        class SlackAttachment
        {
            public string author_icon { get; set; } // URL for a small 16px by 16px image beside the author_name text
            public string author_link { get; set; } // URL that will hyperlink the author_name text
            public string author_name { get; set; } // Small text used to display the author's name
            public string color { get; set; } // Optional good, warning, danger, or any hex color code (eg. #439FE0)
            public string fallback { get; set; } // A plain-text summary of the attachment
            public string footer { get; set; } // Brief text to help contextualize and identify an attachment
            public string footer_icon { get; set; } // URL for a small 16px by 16px image beside the footer text
            public string image_url { get; set; } // URL to an image to display inside a message attachment
            public string pretext { get; set; } // Optional text that appears above the attachment block
            public string text { get; set; } // Optional text that appears within the attachment
            public string thumb_url { get; set; } // Optional URL to an image to display as a thumbnail in a message attachment
            public string title { get; set; } // Optional, larger, bold text near the top of a message attachment
            public string title_link { get; set; } // Optional URL used to hyperlink the title text
            public string ts { get; set; } // Optional timestamp to be formatted and shown next to the footer text
            public List<SlackAttachmentField> fields; // A table inside the message attachment
        }

        /// <summary>
        /// Optional field class for use with SlackAttachment to send attachment fields
        /// </summary>
        class SlackAttachmentField
        {
            public string title { get; set; } // Shown as a bold heading above the value text
            public string value { get; set; } // Text value of the field (supports standard markup, can be multi-line)
            public string @short { get; set; } // Pass true to allow value to be side-by-side with another value
        }

        #endregion

        #region Error Checking

        bool ErrorChecks(string message, bool callback, IPlayer player = null)
        {
            if (string.IsNullOrEmpty(hookUrl))
            {
                PrintWarning("Invalid HookUrl, please check your config!");
                return false;
            }
            if (string.IsNullOrEmpty(message))
            {
                PrintWarning("No message was specified in API call!");
                return false;
            }
            if (callback && player == null)
            {
                PrintWarning("No valid player was specified in API call!");
                return false;
            }
            return true;
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        #endregion
    }
}

// --- End of file: Slack.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sign-checker ---
// --- Original File Path: S/SignChecker/SignChecker.cs ---

ï»¿using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Facepunch.Unity;
using Facepunch;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info( "Sign Checker", "Scarylaggy", "1.1.5" )]
    [Description( "Provides a way to check the last editor of signs" )]
    class SignChecker : RustPlugin
    {
        private static readonly string PERMISSION_USE = "signchecker.use";
        private static readonly string PERMISSION_CLEAN = "signchecker.clean";
        StoredData storedData;

        void Init()
        {
            registerPermissions();
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>( "SignChecker" );
        }

        /// <summary>
        /// Registers the Permissions on Plugin initilation
        /// </summary>
        private void registerPermissions()
        {
            permission.RegisterPermission( PERMISSION_USE, this );
            permission.RegisterPermission( PERMISSION_CLEAN, this );
        }

        /// <summary>
        /// Server hook wich gets called on every edit of an Signage
        /// </summary>
        /// <param name="sign"></param>
        /// <param name="player"></param>
        /// <param name="text"></param>
        void OnSignUpdated(Signage sign, BasePlayer player, string text)
        {   
            //Quick check if the Called sign is already in the Datafile
            if (!isAlreadyInStorageData( sign ))
            {
                //If not, it gets added
                storedData.signCheckerDatas.Add( new SignCheckerData( player, sign ) );
            }
            else
            {
                //If it is, we get it from the list, and Edit it to the new "Last editor"-Data
                foreach (SignCheckerData data in FindSignById( sign.ToString() ))
                {
                    data.userId = player.UserIDString;
                    data.name = player.UserIDString;
                }
            }
            Interface.Oxide.DataFileSystem.WriteObject( this.Name, storedData );
        }

        /// <summary>
        /// Gets an IEnumerable<SignCheckerData> wich will only contain the needed Part of our stored Data
        /// </summary>
        /// <param name="id"></param> The ID is specified by the Signage#ToString() Method
        /// <returns>IEnumerable<SignCheckerData></returns>
        private IEnumerable<SignCheckerData> FindSignById(string id)
        {
            return storedData.signCheckerDatas.Where( item => item.signId.Equals( id ) );
        }
        private bool hasPermissionUse(BasePlayer player, string perm)
        {
            return permission.UserHasPermission( player.UserIDString, perm );
        }

        /// <summary>
        /// Gets the Last editor for a given Signage
        /// </summary>
        /// <param name="sign"></param>
        /// <param name="caller"></param>
        /// <returns></returns>
        private string getPlayerDataForSign(Signage sign, string caller)
        {
            if (sign != null)
            {
                string playerData = "";
                foreach (SignCheckerData data in FindSignById( sign.ToString() ))
                {
                    playerData = data.ToString();
                }
                if (!string.IsNullOrEmpty(playerData))
                {
                    return playerData;
                }
            }
            return string.Format( GetLangValue( "NoOne", caller ) );
        }

        /// <summary>
        /// Chatcommand to clean the File, as it is apropriate to clean it after a Wipe
        /// </summary>
        /// <param name="player"></param>
        /// <param name="command"></param>
        /// <param name="args"></param>
        [ChatCommand( "signwipe" )]
        private void wipeDataChatCommand(BasePlayer player, string command, string[] args)
        {
            if (!hasPermissionUse(player, PERMISSION_CLEAN))
            {
                player.ChatMessage( string.Format( GetLangValue( "NoPermission", player.UserIDString ) ) );
                return;
            }
            storedData.signCheckerDatas.Clear();
            Interface.Oxide.DataFileSystem.WriteObject( this.Name, storedData );
            player.ChatMessage( string.Format( GetLangValue( "Wipe", player.UserIDString ) ) );
        }

        /// <summary>
        /// Chat Command for Players with the signchecker.use Permission
        /// Messages the user with an chatmessage about the last editor of an Signage
        /// => Checks if the player has the needed Permission
        /// => Checks if the player is looking at a Signage
        /// </summary>
        /// <param name="player"></param>
        /// <param name="command"></param>
        /// <param name="args"></param>
        [ChatCommand( "check" )]
        private void CheckChatCommand(BasePlayer player, string command, string[] args)
        {
            //Check for the Use Permission
            if (!hasPermissionUse( player, PERMISSION_USE ))
            {
                player.ChatMessage( string.Format( GetLangValue( "NoPermission", player.UserIDString ) ) );
                return;
            }
            Signage sign = null;
            RaycastHit hit;
            // Get the object that is in front of the player within the maximum distance set in the config.
            if (Physics.Raycast( player.eyes.HeadRay(), out hit, 3 ))
            {
                // Attempt to grab the Signage entity, if there is none this will set the sign to null, 
                // otherwise this will set it to the sign the player is looking at.
                sign = hit.GetEntity() as Signage;
            }
            else
            {
                player.ChatMessage( string.Format( GetLangValue( "NothingFound", player.UserIDString ) ) );
                return;
            }
            //If everything is ok, here we actually get the needed Values
            player.ChatMessage( string.Format( GetLangValue( "LastEdit", player.UserIDString ), getPlayerDataForSign( sign, player.UserIDString ) ) );
        }

        private string GetLangValue(string key, string userId) => lang.GetMessage( key, this, userId );

        bool isAlreadyInStorageData(Signage sign) => storedData.signCheckerDatas.Any( item => item.signId.Equals( sign.ToString() ) );

        protected override void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages( new Dictionary<string, string>
            {
                { "NoPermission", "You don't have the Permission to use this Command." },
                { "LastEdit", "Last editor was {0}" },
                { "NothingFound", "You are not looking at a Sign" },
                { "NoOne", "nobody" },
                { "Wipe", "Datafile has been wiped"}

            }, this );
        }

        class StoredData
        {
            public HashSet<SignCheckerData> signCheckerDatas = new HashSet<SignCheckerData>();

            public StoredData()
            {
            }
        }
        class SignCheckerData
        {
            public string userId;
            public string name;
            public string signId;

            public SignCheckerData()
            {

            }

            public SignCheckerData(BasePlayer player, Signage sign)
            {
                signId = sign.ToString();
                userId = player.UserIDString;
                name = player.displayName;
            }

            public override string ToString()
            {
                return name + " - " + userId;
            }
        }
    }
}


// --- End of file: SignChecker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sam-site-map ---
// --- Original File Path: S/SamSiteMap/SamSiteMap.cs ---

ï»¿using System.Collections.Generic;
using CompanionServer.Handlers;
using Network;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SAM Site Map", "Arainrr", "1.4.0")]
    [Description("Mark all SAM sites on the map")]
    internal class SamSiteMap : RustPlugin
    {
        #region Fields

        private const string PERMISSION_USE = "samsitemap.use";
        private const string PREFAB_MARKER = "assets/prefabs/tools/map/genericradiusmarker.prefab";
        private const string PREFAB_TEXT = "assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab";

        private static SamSiteMap _instance;

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            _instance = this;
            Unsubscribe(nameof(OnEntitySpawned));
            permission.RegisterPermission(PERMISSION_USE, this);
        }

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));
            foreach (var severEntity in BaseNetworkable.serverEntities)
            {
                var samSite = severEntity as SamSite;
                if (samSite != null)
                {
                    CreateMapMarker(samSite);
                }
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        private void Unload()
        {
            SamSiteMapMarker.DestroyAll();
            _instance = null;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.IsConnected) return;
            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }
            if (configData.usePermission)
            {
                SamSiteMapMarker.SendSnapshotToPlayer(player);
                return;
            }
            SamSiteMapMarker.SendUpdateToPlayers();
        }

        private void OnEntitySpawned(SamSite samSite)
        {
            CreateMapMarker(samSite);
        }

        #endregion Oxide Hooks

        #region Methods

        private void CreateMapMarker(SamSite samSite)
        {
            var settings = GetSamSiteSettings(samSite);
            if (!settings.enabled)
            {
                return;
            }
            if (samSite.GetComponent<SamSiteMapMarker>() != null)
            {
                return;
            }
            samSite.gameObject.AddComponent<SamSiteMapMarker>().Init(settings, configData.usePermission, configData.checkInterval);
        }

        private SamSiteSettings GetSamSiteSettings(SamSite samSite)
        {
            return samSite.OwnerID == 0 ? configData.staticSamS : configData.playerSamS;
        }

        #endregion Methods

        #region MapMarker

        private class SamSiteMapMarker : MonoBehaviour
        {
            #region Static

            private static List<SamSiteMapMarker> _mapMarkers;

            public static void DestroyAll()
            {
                if (_mapMarkers == null) return;
                foreach (var samMapMarker in _mapMarkers)
                {
                    Destroy(samMapMarker);
                }
                _mapMarkers.Clear();
                _mapMarkers = null;
            }

            public static void SendUpdateToPlayers()
            {
                if (_mapMarkers == null) return;
                foreach (var mapMarker in _mapMarkers)
                {
                    if (!mapMarker.CanSeeMapMarker()) continue;
                    mapMarker.EnableMarkers();
                }
            }

            private static void SendSnapshotToPlayers()
            {
                if (_mapMarkers == null) return;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    SendSnapshotToPlayer(player);
                }
            }

            public static void SendSnapshotToPlayer(BasePlayer player)
            {
                if (_mapMarkers == null) return;
                if (_instance.permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
                {
                    foreach (var mapMarker in _mapMarkers)
                    {
                        if (!mapMarker.CanSeeMapMarker()) continue;
                        mapMarker.UnlimitedMarkers(player.Connection);
                    }
                }
            }

            #endregion Static

            private SamSite _samSite;
            private MapMarkerGenericRadius _mapMarker;
            private MapMarkerGenericRadius _radiusMapMarker;
            private VendingMachineMapMarker _textMapMarker;
            private bool _usePermission;
            private SamSiteSettings _setting;
            private bool _tempCanShow;

            private void Awake()
            {
                if (_mapMarkers == null) _mapMarkers = new List<SamSiteMapMarker>();
                _mapMarkers.Add(this);
                _samSite = GetComponent<SamSite>();
            }

            public void Init(SamSiteSettings settings, bool usePermission, float checkInterval)
            {
                _setting = settings;
                _usePermission = usePermission;
                SpawnMapMarkers(settings.samSiteMarkerSetting, usePermission);
                _tempCanShow = CanSeeMapMarker();
                if (usePermission)
                {
                    if (_tempCanShow)
                    {
                        Show();
                    }
                }
                else
                {
                    if (!_tempCanShow)
                    {
                        Hide();
                    }
                }
                InvokeRepeating(nameof(TimedCheck), checkInterval, checkInterval);
            }

            private void SpawnMapMarkers(SamSiteMarkerSetting settings, bool usePermission)
            {
                //Text map marker
                if (!string.IsNullOrEmpty(settings.text))
                {
                    _textMapMarker = GameManager.server.CreateEntity(PREFAB_TEXT, _samSite.transform.position) as VendingMachineMapMarker;
                    if (_textMapMarker != null)
                    {
                        _textMapMarker.markerShopName = settings.text;
                        _textMapMarker.OwnerID = _samSite.OwnerID;
                        if (usePermission)
                        {
                            _textMapMarker.limitNetworking = true;
                        }
                        _textMapMarker.Spawn();
                        if (usePermission)
                        {
                            MapMarker.serverMapMarkers.Remove(_textMapMarker);
                        }
                    }
                }
                //Attack range map marker
                if (settings.samSiteRadiusMarker.enabled)
                {
                    _radiusMapMarker = GameManager.server.CreateEntity(PREFAB_MARKER, _samSite.transform.position) as MapMarkerGenericRadius;
                    if (_radiusMapMarker != null)
                    {
                        _radiusMapMarker.alpha = settings.samSiteRadiusMarker.alpha;
                        var color1 = settings.samSiteRadiusMarker.colorl;
                        if (!ColorUtility.TryParseHtmlString(color1, out _radiusMapMarker.color1))
                        {
                            _radiusMapMarker.color1 = Color.black;
                            _instance.PrintError($"Invalid range map marker color1: {color1}");
                        }
                        var color2 = settings.samSiteRadiusMarker.color2;
                        if (!ColorUtility.TryParseHtmlString(color2, out _radiusMapMarker.color2))
                        {
                            _radiusMapMarker.color2 = Color.white;
                            _instance.PrintError($"Invalid range map marker color2: {color2}");
                        }
                        _radiusMapMarker.radius = _samSite.vehicleScanRadius / 145f;
                        _radiusMapMarker.OwnerID = _samSite.OwnerID;
                        if (usePermission)
                        {
                            _radiusMapMarker.limitNetworking = true;
                        }
                        _radiusMapMarker.Spawn();
                        if (usePermission)
                        {
                            MapMarker.serverMapMarkers.Remove(_radiusMapMarker);
                        }
                        else
                        {
                            _radiusMapMarker.SendUpdate();
                        }
                    }
                }

                //Sam map marker
                _mapMarker = GameManager.server.CreateEntity(PREFAB_MARKER, _samSite.transform.position) as MapMarkerGenericRadius;
                if (_mapMarker != null)
                {
                    _mapMarker.alpha = settings.alpha;
                    var color1 = settings.colorl;
                    if (!ColorUtility.TryParseHtmlString(color1, out _mapMarker.color1))
                    {
                        _mapMarker.color1 = Color.black;
                        _instance.PrintError($"Invalid map marker color1: {color1}");
                    }
                    var color2 = settings.color2;
                    if (!ColorUtility.TryParseHtmlString(color2, out _mapMarker.color2))
                    {
                        _mapMarker.color2 = Color.white;
                        _instance.PrintError($"Invalid map marker color2: {color2}");
                    }
                    _mapMarker.radius = settings.radius;
                    _mapMarker.OwnerID = _samSite.OwnerID;
                    if (usePermission)
                    {
                        _mapMarker.limitNetworking = true;
                    }
                    _mapMarker.Spawn();
                    if (usePermission)
                    {
                        MapMarker.serverMapMarkers.Remove(_mapMarker);
                    }
                    else
                    {
                        _mapMarker.SendUpdate();
                    }
                }
            }

            private void TimedCheck()
            {
                var canShow = CanSeeMapMarker();
                if (canShow != _tempCanShow)
                {
                    if (canShow)
                    {
                        Show();
                    }
                    else
                    {
                        Hide();
                    }
                }
                _tempCanShow = canShow;
            }

            private bool CanSeeMapMarker()
            {
                if (_setting.hideWhenNoPower)
                {
                    return _samSite.IsPowered();
                }
                if (_setting.hideWhenNoAmmo)
                {
                    return _samSite.HasAmmo();
                }
                return true;
            }

            private void Show()
            {
                // _instance.PrintError($"Show : {_usePermission} | {_samSite.OwnerID}");
                if (_usePermission)
                {
                    SendSnapshotToPlayers();
                }
                else
                {
                    EnableMarkers();
                }
            }

            private void Hide()
            {
                // _instance.PrintError($"Hide : {_usePermission} | {_samSite.OwnerID}");
                if (_usePermission)
                {
                    LimitedMarkers();
                }
                else
                {
                    DisableMarkers();
                }
            }

            #region Methods

            private void EnableMarkers()
            {
                if (_mapMarker != null)
                {
                    if (_mapMarker.limitNetworking)
                    {
                        _mapMarker.limitNetworking = false;
                        _mapMarker.SendNetworkUpdateImmediate();
                    }
                    _mapMarker.SendUpdate();
                }
                if (_radiusMapMarker != null)
                {
                    if (_radiusMapMarker.limitNetworking)
                    {
                        _radiusMapMarker.limitNetworking = false;
                        _radiusMapMarker.SendNetworkUpdateImmediate();
                    }
                    _radiusMapMarker.SendUpdate();
                }
                if (_textMapMarker != null)
                {
                    if (_textMapMarker.limitNetworking)
                    {
                        _textMapMarker.limitNetworking = false;
                        _textMapMarker.SendNetworkUpdateImmediate();
                    }
                    _textMapMarker.SendNetworkUpdate();
                }
            }

            private void DisableMarkers()
            {
                if (_mapMarker != null)
                {
                    _mapMarker.limitNetworking = true;
                }
                if (_radiusMapMarker != null)
                {
                    _radiusMapMarker.limitNetworking = true;
                }
                if (_textMapMarker != null)
                {
                    _textMapMarker.limitNetworking = true;
                }
            }

            private void LimitedMarkers()
            {
                if (_mapMarker != null)
                {
                    _mapMarker.limitNetworking = false;
                    _mapMarker.limitNetworking = true;
                }
                if (_radiusMapMarker != null)
                {
                    _radiusMapMarker.limitNetworking = false;
                    _radiusMapMarker.limitNetworking = true;
                }
                if (_textMapMarker != null)
                {
                    _textMapMarker.limitNetworking = false;
                    _textMapMarker.limitNetworking = true;
                }
            }

            private void UnlimitedMarkers(Connection connection)
            {
                if (_mapMarker != null)
                {
                    _mapMarker.SendAsSnapshot(connection);
                    _mapMarker.SendUpdate();
                }
                if (_radiusMapMarker != null)
                {
                    _radiusMapMarker.SendAsSnapshot(connection);
                    _radiusMapMarker.SendUpdate();
                }
                if (_textMapMarker != null)
                {
                    _textMapMarker.SendAsSnapshot(connection);
                }
            }

            #endregion Methods

            private void OnDestroy()
            {
                if (_mapMarker != null && !_mapMarker.IsDestroyed)
                {
                    _mapMarker.Kill();
                }
                if (_radiusMapMarker != null && !_radiusMapMarker.IsDestroyed)
                {
                    _radiusMapMarker.Kill();
                }
                if (_textMapMarker != null && !_textMapMarker.IsDestroyed)
                {
                    _textMapMarker.Kill();
                }
                _mapMarkers?.Remove(this);
            }
        }

        #endregion MapMarker

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Use permission")]
            public bool usePermission = false;

            [JsonProperty(PropertyName = "Time interval to check the show of markers (seconds)")]
            public float checkInterval = 5f;

            [JsonProperty(PropertyName = "Static SAM settings")]
            public SamSiteSettings staticSamS = new SamSiteSettings
            {
                enabled = true,
                samSiteMarkerSetting = new SamSiteMarkerSetting
                {
                    radius = 0.15f,
                    colorl = "#FF4500",
                    color2 = "#0000FF",
                    alpha = 1f,
                    text = "static sam",
                    samSiteRadiusMarker = new SamSiteRadiusMarker
                    {
                        colorl = "#FFFF00",
                        color2 = "#FFFFF0",
                        alpha = 0.5f,
                    }
                },
            };

            [JsonProperty(PropertyName = "Player's SAM settings")]
            public SamSiteSettings playerSamS = new SamSiteSettings
            {
                enabled = true,
                samSiteMarkerSetting = new SamSiteMarkerSetting
                {
                    radius = 0.08f,
                    colorl = "#00FF00",
                    color2 = "#0000FF",
                    alpha = 1f,
                    text = "player's sam",
                    samSiteRadiusMarker = new SamSiteRadiusMarker
                    {
                        colorl = "#FFFF00",
                        color2 = "#FFFFF0",
                        alpha = 0.5f,
                    }
                },
            };
        }

        private class SamSiteSettings
        {
            [JsonProperty(PropertyName = "Enabled map marker")]
            public bool enabled = true;

            [JsonProperty(PropertyName = "Hide when no power")]
            public bool hideWhenNoPower = true;

            [JsonProperty(PropertyName = "Hide when no ammo")]
            public bool hideWhenNoAmmo = true;

            [JsonProperty(PropertyName = "SAM map marker")]
            public SamSiteMarkerSetting samSiteMarkerSetting = new SamSiteMarkerSetting();
        }

        private class SamSiteMarkerSetting
        {
            [JsonProperty(PropertyName = "Map marker radius")]
            public float radius = 0.08f;

            [JsonProperty(PropertyName = "Map marker color1")]
            public string colorl = "#00FF00";

            [JsonProperty(PropertyName = "Map marker color2")]
            public string color2 = "#0000FF";

            [JsonProperty(PropertyName = "Map marker alpha")]
            public float alpha = 1f;

            [JsonProperty(PropertyName = "Map marker text")]
            public string text = "sam";

            [JsonProperty(PropertyName = "SAM attack range map marker")]
            public SamSiteRadiusMarker samSiteRadiusMarker = new SamSiteRadiusMarker();
        }

        private class SamSiteRadiusMarker
        {
            [JsonProperty(PropertyName = "Enabled Sam attack range map marker")]
            public bool enabled = false;

            [JsonProperty(PropertyName = "Range map marker color1")]
            public string colorl = "#FFFF00";

            [JsonProperty(PropertyName = "Range map marker color2")]
            public string color2 = "#FFFFF0";

            [JsonProperty(PropertyName = "Range map marker alpha")]
            public float alpha = 0.5f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile
    }
}

// --- End of file: SamSiteMap.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/skull-crusher ---
// --- Original File Path: S/SkullCrusher/SkullCrusher.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Skull Crusher", "Krungh Crow", "1.1.1")]
    [Description("Adds some extra features to the crushing of human skulls")]

    /***********************************************************************************************************************
    *
    *    THANKS to redBDGR to creator of this plugin
    *    
    *    v1.1.1 :   Patched for Rust junes update
    *               Fixed scrap reward msg
    *    
    *
    ************************************************************************************************************************/
    class SkullCrusher : RustPlugin
    {
        [PluginReference]
        private Plugin Clans, Economics, Friends, ServerRewards;

        private Dictionary<string, int> cacheDic = new Dictionary<string, int>();
        private bool Changed;

        private bool giveItemsOnCrush = true;
        private double moneyPerSkullCrush = 20.0;
        private bool normalCrusherMessage = true;
        private bool nullCrusherMessage = true;
        private bool ownCrusherMessage = true;
        private int RPPerSkullCrush = 20;
        private bool sendNotificaitionMessage = true;
        private bool friendsSupport, clansSupport, teamsSupport;
        private bool useEconomy, useServerRewards;
        private bool useItem;
        private int ItemAmount = 20;
        private string Itemshortname = "scrap";
        private bool useRandomMessages;
        private List<object> randomMessages = null;

        #region Data

        private DynamicConfigFile SkullCrusherData;
        private StoredData storedData;

        private class StoredData
        {
            public Dictionary<string, int> PlayerInformation = new Dictionary<string, int>();
        }

        private void SaveData()
        {
            storedData.PlayerInformation = cacheDic;
            SkullCrusherData.WriteObject(storedData);
        }

        private void LoadData()
        {
            try
            {
                storedData = SkullCrusherData.ReadObject<StoredData>();
                cacheDic = storedData.PlayerInformation;
            }
            catch
            {
                Puts("Failed to load data, creating new file");
                storedData = new StoredData();
            }
        }

        #endregion

        #region Hooks

        private void Init()
        {
            LoadVariables();

            SkullCrusherData = Interface.Oxide.DataFileSystem.GetFile(Name);
            LoadData();
        }

        private void OnServerInitialized()
        {
            if (clansSupport)
                if (Clans == null)
                {
                    clansSupport = false;
                    PrintWarning("Clans.cs was not found... disabling features");
                }

            if (friendsSupport)
                if (Friends == null)
                {
                    friendsSupport = false;
                    PrintWarning("Friends.cs was not found... disabling features");
                }

            if (useEconomy)
                if (!Economics)
                {
                    PrintError("Economics.cs was not found, auto-disabling economic features");
                    useEconomy = false;
                }

            if (useServerRewards)
                if (!ServerRewards)
                {
                    PrintError("ServerRewards.cs was not found, auto-disabling serverrewards features");
                    useServerRewards = false;
                }
        }

        private void Unload()
        {
            SaveData();
        }

        private void OnServerSave()
        {
            SaveData();
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {
            giveItemsOnCrush = Convert.ToBoolean(GetConfig("Settings", "Give items on crush", true));

            useEconomy = Convert.ToBoolean(GetConfig("Economy", "Use Economy", false));
            useServerRewards = Convert.ToBoolean(GetConfig("Economy", "Use ServerRewards", false));
            useItem = Convert.ToBoolean(GetConfig("Economy", "Use Scrap as reward", false));

            RPPerSkullCrush = Convert.ToInt32(GetConfig("Economy", "RP Per Skull Crush", 20));
            moneyPerSkullCrush = Convert.ToDouble(GetConfig("Economy", "Money Per Skull Crush", 20.0));
            ItemAmount = Convert.ToInt32(GetConfig("Economy", "Scrap Per Skull Crush", 20.0));

            sendNotificaitionMessage = Convert.ToBoolean(GetConfig("Economy", "Send Notification Message", true));

            nullCrusherMessage = Convert.ToBoolean(GetConfig("Settings", "Null Owner Crush Message", true));
            ownCrusherMessage = Convert.ToBoolean(GetConfig("Settings", "Own Skull Crush Message", true));
            normalCrusherMessage = Convert.ToBoolean(GetConfig("Settings", "Normal Crush Message", true));

            friendsSupport = Convert.ToBoolean(GetConfig("Team Settings", "Use Friends", false));
            clansSupport = Convert.ToBoolean(GetConfig("Team Settings", "Use Clans", false));
            teamsSupport = Convert.ToBoolean(GetConfig("Team Settings", "Use Teams", false));

            useRandomMessages = Convert.ToBoolean(GetConfig("Settings", "Use Random Global Crush Messages", false));
            randomMessages = (List<object>)GetConfig("Settings", "Random Messages", new List<object>() { "{0}'s skull was crushed by {1}", "{1} crushed {0}'s skull" });

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Null Crusher"] = "{0}'s skull was crushed",
                ["Crushed own skull"] = "{0} crushed their own skull!",
                ["Default Crush Message"] = "{0}'s skull was crushed by {1}",
                ["Skulls chat command reply"] = "You have crushed a total of {0} skulls",
                ["Economy Notice"] = "You received ${0} for crushing an enemies skull!",
                ["ScrapRewards Notice"] = "You received {0} scrap for crushing an enemies skull!",
                ["ServerRewards Notice"] = "You received {0} RP for crushing an enemies skull!"
            }, this);
        }

        private object OnItemAction(Item item, string action)
        {
            if (action != "crush")
                return null;
            if (item.info.shortname != "skull.human")
                return null;
            string skullName = null;
            if (item.name != null)
                skullName = item.name.Substring(10, item.name.Length - 11);
            if (string.IsNullOrEmpty(skullName))
                return DecideReturn(item);

            BasePlayer ownerPlayer = item.GetOwnerPlayer();
            if (ownerPlayer == null)
            {
                if (nullCrusherMessage)
                    rust.BroadcastChat(null, string.Format(msg("Null Crusher"), skullName));
                return DecideReturn(item);
            }
            if (ownerPlayer.displayName == skullName)
            {
                if (ownCrusherMessage)
                    rust.BroadcastChat(null, string.Format(msg("Crushed own skull"), ownerPlayer.displayName));
                return DecideReturn(item);
            }

            BasePlayer skullOwner = BasePlayer.Find(skullName);
            if (skullOwner)
            {
                if (friendsSupport || clansSupport || teamsSupport)
                    if (IsTeamed(ownerPlayer, skullOwner))
                        return DecideReturn(item);
            }

            if (!cacheDic.ContainsKey(ownerPlayer.UserIDString))
                cacheDic.Add(ownerPlayer.UserIDString, 0);
            cacheDic[ownerPlayer.UserIDString]++;
            if (useEconomy)
                if (Economics)
                {
                    if (sendNotificaitionMessage)
                        ownerPlayer.ChatMessage(string.Format(msg("Economy Notice", ownerPlayer.UserIDString), moneyPerSkullCrush));
                    Economics.CallHook("Deposit", ownerPlayer.userID, moneyPerSkullCrush);
                }
            if (useServerRewards)
                if (ServerRewards)
                {
                    if (sendNotificaitionMessage)
                        ownerPlayer.ChatMessage(string.Format(msg("ServerRewards Notice", ownerPlayer.UserIDString), RPPerSkullCrush));
                    ServerRewards.Call("AddPoints", ownerPlayer.userID, RPPerSkullCrush);
                }
            if (useItem)
            {
                {
                    if (sendNotificaitionMessage)
                        ownerPlayer.ChatMessage(string.Format(msg("ScrapRewards Notice", ownerPlayer.UserIDString), ItemAmount));
                    Item currency = ItemManager.CreateByName(Itemshortname, ItemAmount);
                    currency.MoveToContainer(ownerPlayer.inventory.containerMain);
                }
            }
            if (normalCrusherMessage)
            {
                if (useRandomMessages)
                    rust.BroadcastChat(null, string.Format(randomMessages[UnityEngine.Random.Range(0, randomMessages.Count - 1)].ToString(), skullName, ownerPlayer.displayName));
                else
                    rust.BroadcastChat(null, string.Format(msg("Default Crush Message"), skullName, ownerPlayer.displayName));
            }
            return DecideReturn(item);
        }

        #endregion

        #region Commands

        [ChatCommand("skulls")]
        private void skullsCMD(BasePlayer player, string command, string[] args)
        {
            if (!cacheDic.ContainsKey(player.UserIDString))
                cacheDic.Add(player.UserIDString, 0);
            player.ChatMessage(string.Format(msg("Skulls chat command reply", player.UserIDString), cacheDic[player.UserIDString]));
        }

        #endregion

        #region Methods

        private bool IsTeamed(BasePlayer ownerPlayer, BasePlayer skullOwner)
        {
            if (ownerPlayer == null || skullOwner == null)
                return false;
            if (teamsSupport)
            {
                RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.FindTeam(ownerPlayer.currentTeam);
                if (team == null)
                    return false;
                foreach (ulong entry in team.members)
                {
                    if (entry == skullOwner.userID)
                        return true;
                }
            }

            if (friendsSupport)
                if ((bool)Friends?.Call("AreFriends", ownerPlayer.userID, skullOwner.userID) == true)
                    return true;

            if (clansSupport)
                if (Clans != null)
                    if ((bool)Clans?.Call("IsMemberOrAlly", ownerPlayer.userID, skullOwner.userID) == true)
                        return true;

            return false;
        }

        private object DecideReturn(Item item)
        {
            if (giveItemsOnCrush)
                return null;
            item.UseItem(); // Remove one of the item from the players inventory
            return true;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        private string msg(string key, string id = null)
        {
            return lang.GetMessage(key, this, id);
        }

        #endregion
    }
}


// --- End of file: SkullCrusher.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/safety-barrel ---
// --- Original File Path: S/SafetyBarrel/SafetyBarrel.cs ---

using Newtonsoft.Json;
using ProtoBuf;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Safety Barrel", "Dana", "1.0.0")]
    [Description("Be invincible like a superhero but with a barrel on your head.")]
    public class SafetyBarrel : RustPlugin
    {
        #region Fields

        private static SafetyBarrel _instance;
        private static Configuration _config;

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty(PropertyName = "Clothing")]
            public List<string> Clothing { get; set; }

            [JsonProperty(PropertyName = "Enable Damage Immunity")]
            public bool EnableDamageImmunity { get; set; }

            [JsonProperty(PropertyName = "Can Be Seen By NPC")]
            public bool CanBeSeenByNPC { get; set; }

            [JsonProperty(PropertyName = "Can Be Seen By Helicopter")]
            public bool CanBeSeenByHelicopter { get; set; }

            [JsonProperty(PropertyName = "Can Be Seen By Bradley")]
            public bool CanBeSeenByBradley { get; set; }

            [JsonProperty(PropertyName = "Can Be Seen By Trap")]
            public bool CanBeSeenByTrap { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Detected changes in configuration! Updating...");
            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Configuration update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                EnableDamageImmunity = true,
                CanBeSeenByNPC = false,
                CanBeSeenByHelicopter = false,
                CanBeSeenByBradley = false,
                CanBeSeenByTrap = false,
                Clothing = new List<string>()
                {
                    "barrelcostume",
                    "cratecostume",
                    "ghostsheet",
                    "scarecrow.suit"
                }
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void Init()
        {
            _instance = this;
            PermissionUtils.Register();
        }

        private void Unload()
        {
            _config = null;
            _instance = null;
        }

        private object OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (VerifyPlayerAttire(player) && _config.EnableDamageImmunity)
                return true;

            return null;
        }

        private object OnNpcPlayerTarget(ScientistNPC npc, BasePlayer targetPlayer)
        {
            if (VerifyPlayerAttire(targetPlayer) && !_config.CanBeSeenByNPC)
                return false;

            return null;
        }

        private object OnNpcTarget(ScientistNPC npc, BasePlayer targetPlayer)
        {
            if (VerifyPlayerAttire(targetPlayer) && !_config.CanBeSeenByNPC)
                return false;

            return null;
        }

        private object CanBeTargeted(BasePlayer player)
        {
            if (VerifyPlayerAttire(player) && !_config.CanBeSeenByTrap)
                return false;

            return null;
        }
        
        private object CanBradleyApcTarget(BasePlayer player)
        {
            if (VerifyPlayerAttire(player) && !_config.CanBeSeenByBradley)
                return false;

            return null;
        }

        private object CanHelicopterTarget(BasePlayer targetPlayer)
        {
            if (VerifyPlayerAttire(targetPlayer) && !_config.CanBeSeenByHelicopter)
                return false;

            return null;
        }

        #endregion Oxide Hooks

        #region Helper Functions

        private bool VerifyPlayerAttire(BasePlayer player)
        {
            if (!player.IsValid() || !player.userID.IsSteamId() || player.IsNpc)
                return false;

            if (!PermissionUtils.Verify(player))
                return false;

            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item == null)
                    continue;
                
                if (_config.Clothing.Contains(item.info.shortname))
                    return true;
            }

            return false;
        }

        #endregion Helper Functions

        #region Helper Classes

        private static class PermissionUtils
        {
            public const string USE = "safetybarrel.use";

            public static void Register()
            {
                _instance.permission.RegisterPermission(USE, _instance);
            }

            public static bool Verify(BasePlayer player, string permissionName = USE)
            {
                if (_instance.permission.UserHasPermission(player.UserIDString, permissionName))
                    return true;

                return false;
            }
        }

        #endregion Helper Classes
    }
}

// --- End of file: SafetyBarrel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/server-info ---
// --- Original File Path: S/ServerInfo/ServerInfo.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Server Info", "FastBurst", "0.5.9")]
    [Description("UI customizable server info with multiple tabs")]
    public sealed class ServerInfo : RustPlugin
    {
        private static Settings _settings;
        private static readonly Dictionary<ulong, PlayerInfoState> PlayerActiveTabs = new Dictionary<ulong, PlayerInfoState>();
        private static readonly Permission Permission = Interface.GetMod().GetLibrary<Permission>();

        protected override void LoadDefaultConfig()
        {
            Config.Set("settings", Settings.CreateDefault());
        }

        private void OnServerInitialized()
        {
            LoadConfig();
            var configFileName = Manager.ConfigPath + "/server_info_text.json";

            _settings = null;
            try
            {
                var settingsDict = Config.Get("settings") as Dictionary<string, object>;
                _settings = JsonConvert.DeserializeObject<Settings>(JsonConvert.SerializeObject(settingsDict));
            }
            catch (Exception)
            {
                Puts("ServerInfo: Failed to load config");
                return;
            }

            _settings = _settings ?? Settings.CreateDefault();

            if (!_settings.UpgradedConfig && Config.Exists(configFileName))
            {
                try
                {
                    Puts("ServerInfo: Upgrading settings from server_info_text.json");
                    _settings = Config.ReadObject<Settings>(configFileName);
                    _settings.UpgradedConfig = true;
                    Puts("ServerInfo: Successfully upgraded config");
                }
                catch (Exception)
                {
                    Puts("ServerInfo: Failed to upgrade config. Manual editing is required.");
                    Puts("ServerInfo: Copy your settings by parts to new config in ServerInfo.json");
                }
            }

            foreach (var player in BasePlayer.activePlayerList)
                AddHelpButton(player);

            Config.Set("settings", _settings);
            SaveConfig();
        }

        void Unload()
        {
            foreach (var playerActiveTab in PlayerActiveTabs)
            {
                var player = BasePlayer.activePlayerList.FirstOrDefault(f => f.userID == playerActiveTab.Key);
                if (player == null)
                    continue;

                CuiHelper.DestroyUi(player, playerActiveTab.Value.MainPanelName);
                CuiHelper.DestroyUi(player, playerActiveTab.Value.ChatHelpButtonName);
            }

            PlayerActiveTabs.Clear();
        }

        [ConsoleCommand("changetab")]
        private void ChangeTab(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.player == null || !arg.HasArgs(4) || _settings == null)
                return;

            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!PlayerActiveTabs.ContainsKey(player.userID.Get()))
                return;

            var previousTabIndex = PlayerActiveTabs[player.userID.Get()].ActiveTabIndex;
            var tabToChangeTo = arg.GetInt(0, 65535);

            if (previousTabIndex == tabToChangeTo)
                return;

            var tabToSelectIndex = arg.GetInt(0);
            var activeButtonName = arg.GetString(1);
            var tabToSelectButtonName = arg.GetString(2);
            var mainPanelName = arg.GetString(3);

            CuiHelper.DestroyUi(player, PlayerActiveTabs[player.userID.Get()].ActiveTabContentPanelName);
            CuiHelper.DestroyUi(player, activeButtonName);
            CuiHelper.DestroyUi(player, tabToSelectButtonName);

            var allowedTabs = _settings.Tabs
                .Where((tab, tabIndex) => string.IsNullOrEmpty(tab.OxideGroup) ||
                    tab.OxideGroup.Split(',')
                        .Any(group => Permission.UserHasGroup(player.userID.ToString(), group)))
                .ToList();
            var tabToSelect = allowedTabs[tabToSelectIndex];
            PlayerActiveTabs[player.userID.Get()].ActiveTabIndex = tabToSelectIndex;
            PlayerActiveTabs[player.userID.Get()].PageIndex = 0;

            var container = new CuiElementContainer();
            var tabContentPanelName = CreateTabContent(tabToSelect, container, mainPanelName);
            var newActiveButtonName = AddActiveButton(tabToSelectIndex, tabToSelect, container, mainPanelName);
            AddNonActiveButton(previousTabIndex, container, _settings.Tabs[previousTabIndex], mainPanelName, newActiveButtonName);

            PlayerActiveTabs[player.userID.Get()].ActiveTabContentPanelName = tabContentPanelName;

            SendUI(player, container);
        }

        [ConsoleCommand("changepage")]
        private void ChangePage(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.player == null || !arg.HasArgs(2) || _settings == null)
                return;

            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!PlayerActiveTabs.ContainsKey(player.userID.Get()))
                return;

            var playerInfoState = PlayerActiveTabs[player.userID.Get()];
            var currentTab = _settings.Tabs[playerInfoState.ActiveTabIndex];
            var currentPageIndex = playerInfoState.PageIndex;

            var pageToChangeTo = arg.GetInt(0, 65535);
            var currentTabContentPanelName = playerInfoState.ActiveTabContentPanelName;
            var mainPanelName = arg.GetString(1);

            if (pageToChangeTo == currentPageIndex)
                return;

            CuiHelper.DestroyUi(player, currentTabContentPanelName);

            playerInfoState.PageIndex = pageToChangeTo;

            var container = new CuiElementContainer();
            var tabContentPanelName = CreateTabContent(currentTab, container, mainPanelName, pageToChangeTo);
            PlayerActiveTabs[player.userID.Get()].ActiveTabContentPanelName = tabContentPanelName;

            SendUI(player, container);
        }

        [ConsoleCommand("infoclose")]
        private void CloseInfo(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.player == null || !arg.HasArgs() || _settings == null)
                return;

            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!PlayerActiveTabs.ContainsKey(player.userID.Get()))
                return;

            const string defaultName = "defaultString";
            var mainPanelName = arg.GetString(0, defaultName);

            if (mainPanelName.Equals(defaultName, StringComparison.OrdinalIgnoreCase))
                return;

            PlayerInfoState state;
            PlayerActiveTabs.TryGetValue(player.userID.Get(), out state);
            if (state == null)
                return;

            CuiHelper.DestroyUi(player, mainPanelName);

            state.ActiveTabIndex = _settings.TabToOpenByDefault;
            state.MainPanelName = string.Empty;
            state.PageIndex = 0;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || _settings == null)
                return;

            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2, () => OnPlayerConnected(player));
                return;
            }

            PlayerInfoState state;
            PlayerActiveTabs.TryGetValue(player.userID.Get(), out state);

            if (state == null)
            {
                state = new PlayerInfoState(_settings);
                PlayerActiveTabs.Add(player.userID.Get(), state);
            }

            AddHelpButton(player);

            if (!state.InfoShownOnLogin)
                return;
            if (state.InfoShownOnLoginOnce && checkedPlayers.Contains(player.userID.Get()))
                return;
            ShowInfo(player, string.Empty, new string[0]);
            if (state.InfoShownOnLoginOnce)
                checkedPlayers.Add(player.userID.Get());
        }

        List<ulong> checkedPlayers = new List<ulong>();

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (player == null || _settings == null)
                return;

            PlayerInfoState state;
            PlayerActiveTabs.TryGetValue(player.userID.Get(), out state);

            if (state == null)
                return;

            CuiHelper.DestroyUi(player, state.MainPanelName);

            state.ActiveTabIndex = _settings.TabToOpenByDefault;
            state.MainPanelName = string.Empty;
            state.PageIndex = 0;
        }

        private static void AddHelpButton(BasePlayer player)
        {
            if (!_settings.HelpButton.IsEnabled || _settings == null)
                return;

            var container = new CuiElementContainer();
            var helpChatButton = CreateHelpButton();
            var helpButtonName = container.Add(helpChatButton);
            if (!PlayerActiveTabs.ContainsKey(player.userID.Get()))
                PlayerActiveTabs[player.userID.Get()] = new PlayerInfoState(_settings);

            PlayerActiveTabs[player.userID.Get()].ChatHelpButtonName = helpButtonName;
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("info")]
        private void ShowConsoleInfo(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.Connection == null || arg.Connection.player == null || _settings == null)
                return;

            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (string.IsNullOrEmpty(PlayerActiveTabs[player.userID.Get()].MainPanelName))
                ShowInfo(player, string.Empty, null);
        }

        [ChatCommand("info")]
        private void ShowInfo(BasePlayer player, string command, string[] args)
        {
            if (player == null || _settings == null)
                return;

            if (!PlayerActiveTabs.ContainsKey(player.userID.Get()))
                PlayerActiveTabs.Add(player.userID.Get(), new PlayerInfoState(_settings));

            var container = new CuiElementContainer();
            var mainPanelName = AddMainPanel(container);
            PlayerActiveTabs[player.userID.Get()].MainPanelName = mainPanelName;

            var tabFirstIndex = _settings.TabToOpenByDefault;
            var tabToSelectIndex = tabFirstIndex;
            int tabtoSelectArgumentIndex = 0;
            if (args.Count() == 1)
            {
                if (int.TryParse(args[0], out tabtoSelectArgumentIndex))
                {
                    tabToSelectIndex = tabtoSelectArgumentIndex;
                    PlayerActiveTabs[player.userID.Get()].ActiveTabIndex = tabtoSelectArgumentIndex;
                }
            }

            var allowedTabs = _settings.Tabs
                .Where((tab, tabIndex) => string.IsNullOrEmpty(tab.OxideGroup) ||
                    tab.OxideGroup.Split(',')
                        .Any(group => Permission.UserHasGroup(player.userID.ToString(), group)))
                .ToList();
            if (allowedTabs.Count <= 0)
            {
                SendReply(player, "[GUI Help] You don't have permissions to see info.");
                return;
            }

            var activeAllowedTab = allowedTabs[tabToSelectIndex];
            var tabContentPanelName = CreateTabContent(activeAllowedTab, container, mainPanelName);
            var activeTabButtonName = AddActiveButton(tabToSelectIndex, activeAllowedTab, container, mainPanelName);


            for (int tabIndex = 0; tabIndex < allowedTabs.Count; tabIndex++)
            {
                if (tabIndex == tabToSelectIndex)
                    continue;

                AddNonActiveButton(tabIndex, container, allowedTabs[tabIndex], mainPanelName, activeTabButtonName);
            }
            PlayerActiveTabs[player.userID.Get()].ActiveTabContentPanelName = tabContentPanelName;
            SendUI(player, container);
        }

        private static void SendUI(BasePlayer player, CuiElementContainer container)
        {
            var json = JsonConvert.SerializeObject(container, Formatting.None, new JsonSerializerSettings
            {
                StringEscapeHandling = StringEscapeHandling.Default,
                DefaultValueHandling = DefaultValueHandling.Ignore,
                Formatting = Formatting.Indented
            });
            json = json.Replace(@"\t", "\t");
            json = json.Replace(@"\n", "\n");

            CuiHelper.AddUi(player, container);
        }

        private static string AddMainPanel(CuiElementContainer container)
        {
            Color backgroundColor;
            ColorExtensions.TryParseHexString(_settings.BackgroundColor, out backgroundColor);
            var mainPanel = new CuiPanel
            {
                Image =
                {
                    Color = ColorExtensions.ToRustFormatString(backgroundColor)
                },
                CursorEnabled = true,
                RectTransform =
                {
                    AnchorMin = _settings.Position.GetRectTransformAnchorMin(),
                    AnchorMax = _settings.Position.GetRectTransformAnchorMax()
                }
            };

            var tabContentPanelName = container.Add(mainPanel);
            if (!_settings.BackgroundImage.Enabled)
                return tabContentPanelName;

            var backgroundImage = CreateImage(tabContentPanelName, _settings.BackgroundImage);

            container.Add(backgroundImage);

            return tabContentPanelName;
        }

        private static CuiElement CreateImage(string panelName, ImageSettings settings)
        {
            var element = new CuiElement();
            var image = new CuiRawImageComponent
            {
                Url = settings.Url,
                Color = string.Format("1 1 1 {0:F1}", (settings.TransparencyInPercent / 100.0f))
            };

            var position = settings.Position;
            var rectTransform = new CuiRectTransformComponent
            {
                AnchorMin = position.GetRectTransformAnchorMin(),
                AnchorMax = position.GetRectTransformAnchorMax()
            };
            element.Components.Add(image);
            element.Components.Add(rectTransform);
            element.Name = CuiHelper.GetGuid();
            element.Parent = panelName;

            return element;
        }

        private string CreateTabContent(HelpTab helpTab, CuiElementContainer container, string mainPanelName, int pageIndex = 0)
        {
            var tabPanelName = CreateTab(helpTab, container, mainPanelName, pageIndex);
            var closeButton = CreateCloseButton(mainPanelName, _settings.CloseButtonColor);
            container.Add(closeButton, tabPanelName);
            return tabPanelName;
        }

        private static string CreateTab(HelpTab helpTab, CuiElementContainer container, string mainPanelName, int pageIndex)
        {
            var tabPanelName = CreateTabPanel(container, mainPanelName, "#00000000");

            var currentPage = helpTab.Pages.ElementAtOrDefault(pageIndex);
            if (currentPage == null)
                return tabPanelName;

            foreach (var imageSettings in currentPage.ImageSettings)
            {
                var imageObject = CreateImage(tabPanelName, imageSettings);
                container.Add(imageObject);
            }

            var cuiLabel = CreateHeaderLabel(helpTab);
            container.Add(cuiLabel, tabPanelName);

            const float firstLineMargin = 0.91f;
            const float textLineHeight = 0.04f;

            for (var textRow = 0; textRow < currentPage.TextLines.Count; textRow++)
            {
                var textLine = currentPage.TextLines[textRow];
                var textLineLabel = CreateTextLineLabel(helpTab, firstLineMargin, textLineHeight, textRow, textLine);
                container.Add(textLineLabel, tabPanelName);
            }

            if (pageIndex > 0)
            {
                var prevPageButton = CreatePrevPageButton(mainPanelName, pageIndex, _settings.PrevPageButtonColor);
                container.Add(prevPageButton, tabPanelName);
            }

            if (helpTab.Pages.Count - 1 == pageIndex)
                return tabPanelName;

            var nextPageButton = CreateNextPageButton(mainPanelName, pageIndex, _settings.NextPageButtonColor);
            container.Add(nextPageButton, tabPanelName);

            return tabPanelName;
        }

        private static string CreateTabPanel(CuiElementContainer container, string mainPanelName, string hexColor)
        {
            Color backgroundColor;
            ColorExtensions.TryParseHexString(hexColor, out backgroundColor);

            return container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image =
                {
                    Color = ColorExtensions.ToRustFormatString(backgroundColor),
                },
                RectTransform =
                {
                    AnchorMin = "0.22 0.01",
                    AnchorMax = "0.99 0.98"
                }
            }, mainPanelName);
        }

        private static string CreateTabContentPanel(CuiElementContainer container, string mainPanelName, string hexColor)
        {
            Color backgroundColor;
            ColorExtensions.TryParseHexString(hexColor, out backgroundColor);

            return container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image =
                {
                    Color = ColorExtensions.ToRustFormatString(backgroundColor),
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "0.86 1"
                }
            }, mainPanelName);
        }

        private static CuiLabel CreateHeaderLabel(HelpTab helpTab)
        {
            return new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0.01 0.85",
                    AnchorMax = "1.0 0.98"
                },
                Text =
                {
                    Align = helpTab.HeaderAnchor,
                    FontSize = helpTab.HeaderFontSize,
                    Text = helpTab.HeaderText
                }
            };
        }

        private static CuiButton CreateCloseButton(string mainPanelName, string hexColor)
        {
            Color color;
            ColorExtensions.TryParseHexString(hexColor, out color);
            return new CuiButton
            {
                Button =
                {
                    Command = string.Format("infoclose {0}", mainPanelName),
                    Close = mainPanelName,
                    Color = ColorExtensions.ToRustFormatString(color)
                },
                RectTransform =
                {
                    AnchorMin = "0.86 0.93",
                    AnchorMax = "0.97 0.99"
                },
                Text =
                {
                    Text = _settings.CloseButtonText,
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                }
            };
        }

        private static CuiButton CreateHelpButton()
        {
            Color color;
            ColorExtensions.TryParseHexString(_settings.HelpButton.Color, out color);
            return new CuiButton
            {
                Button =
                {
                    Command = "info",
                    Color = ColorExtensions.ToRustFormatString(color)
                },
                RectTransform =
                {
                    AnchorMin = _settings.HelpButton.Position.GetRectTransformAnchorMin(),
                    AnchorMax = _settings.HelpButton.Position.GetRectTransformAnchorMax()
                },
                Text =
                {
                    Text = _settings.HelpButton.Text,
                    FontSize = _settings.HelpButton.FontSize,
                    Align = TextAnchor.MiddleCenter
                }
            };
        }

        private static CuiLabel CreateTextLineLabel(HelpTab helpTab, float firstLineMargin, float textLineHeight, int textRow,
            string textLine)
        {
            var textLineLabel = new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0.01 " + (firstLineMargin - textLineHeight * (textRow + 1)),
                    AnchorMax = "0.85 " + (firstLineMargin - textLineHeight * textRow)
                },
                Text =
                {
                    Align = helpTab.TextAnchor,
                    FontSize = helpTab.TextFontSize,
                    Text = textLine
                }
            };
            return textLineLabel;
        }

        private static CuiButton CreatePrevPageButton(string mainPanelName, int pageIndex, string hexColor)
        {
            Color color;
            ColorExtensions.TryParseHexString(hexColor, out color);
            return new CuiButton
            {
                Button =
                {
                    Command = string.Format("changepage {0} {1}", pageIndex - 1, mainPanelName),
                    Color = ColorExtensions.ToRustFormatString(color)
                },
                RectTransform =
                {
                    AnchorMin = "0.86 0.01",
                    AnchorMax = "0.97 0.07"
                },
                Text =
                {
                    Text = _settings.PrevPageText,
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                }
            };
        }

        private static CuiButton CreateNextPageButton(string mainPanelName, int pageIndex, string hexColor)
        {
            Color color;
            ColorExtensions.TryParseHexString(hexColor, out color);
            return new CuiButton
            {
                Button =
                {
                    Command = string.Format("changepage {0} {1}", pageIndex + 1, mainPanelName),
                    Color = ColorExtensions.ToRustFormatString(color)
                },
                RectTransform =
                {
                    AnchorMin = "0.86 0.08",
                    AnchorMax = "0.97 0.15"
                },
                Text =
                {
                    Text = _settings.NextPageText,
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                }
            };
        }

        private static void AddNonActiveButton(
             int tabIndex,
             CuiElementContainer container,
             HelpTab helpTab,
             string mainPanelName,
             string activeTabButtonName)
        {
            Color nonActiveButtonColor;
            ColorExtensions.TryParseHexString(_settings.InactiveButtonColor, out nonActiveButtonColor);

            CuiButton helpTabButton = CreateTabButton(tabIndex, helpTab, nonActiveButtonColor);
            string helpTabButtonName = container.Add(helpTabButton, mainPanelName);
            string command = string.Format("changeTab {0} {1} {2} {3}", tabIndex, activeTabButtonName, helpTabButtonName, mainPanelName);
            helpTabButton.Button.Command = command;
        }

        private static string AddActiveButton(
            int activeTabIndex,
            HelpTab activeTab,
            CuiElementContainer container,
            string mainPanelName)
        {
            Color activeButtonColor;
            ColorExtensions.TryParseHexString(_settings.ActiveButtonColor, out activeButtonColor);

            var activeHelpTabButton = CreateTabButton(activeTabIndex, activeTab, activeButtonColor);
            var activeTabButtonName = container.Add(activeHelpTabButton, mainPanelName);
            var command = string.Format("changeTab {0}", activeTabIndex);

            activeHelpTabButton.Button.Command = command;
            return activeTabButtonName;
        }

        private static CuiButton CreateTabButton(int tabIndex, HelpTab helpTab, Color color)
        {
            const float verticalMargin = 0.03f;
            const float buttonHeight = 0.06f;

            return new CuiButton
            {
                Button =
                {
                    Color = ColorExtensions.ToRustFormatString(color)
                },
                RectTransform =
                {
                    AnchorMin = string.Format("0.01 {0}", 1 - ((verticalMargin + buttonHeight) * (tabIndex + 1))),
                    AnchorMax = string.Format("0.20 {0}", 1 - ((verticalMargin * (tabIndex + 1)) + (tabIndex * buttonHeight)))
                },
                Text =
                {
                    Text = helpTab.ButtonText,
                    FontSize = helpTab.TabButtonFontSize,
                    Align = helpTab.TabButtonAnchor
                }
            };
        }

        [JsonObject]
        public sealed class Settings
        {
            public Settings()
            {
                Tabs = new List<HelpTab>();
                ShowInfoOnPlayerInit = true;
                ShowInfoOnlyOncePerRuntime = true;
                TabToOpenByDefault = 0;
                Position = new Position();

                //ActiveButtonColor = "#" + Color.cyan.ToHexStringRGBA();
                //InactiveButtonColor = "#" + Color.gray.ToHexStringRGBA();
                //CloseButtonColor = "#" + Color.gray.ToHexStringRGBA();
                //PrevPageButtonColor = "#" + Color.gray.ToHexStringRGBA();
                //NextPageButtonColor = "#" + Color.gray.ToHexStringRGBA();
                //BackgroundColor = "#" + new Color(0f, 0f, 0f, 1.0f).ToHexStringRGBA();

                ActiveButtonColor = "#" + ColorExtensions.ToHexStringRGBA(Color.cyan);
                InactiveButtonColor = "#" + ColorExtensions.ToHexStringRGBA(Color.gray);
                CloseButtonColor = "#" + ColorExtensions.ToHexStringRGBA(Color.gray);
                PrevPageButtonColor = "#" + ColorExtensions.ToHexStringRGBA(Color.gray);
                NextPageButtonColor = "#" + ColorExtensions.ToHexStringRGBA(Color.gray);
                BackgroundColor = "#" + ColorExtensions.ToHexStringRGBA(new Color(0f, 0f, 0f, 1.0f));
                NextPageText = "Next Page";
                PrevPageText = "Prev Page";
                CloseButtonText = "Close";

                HelpButton = new HelpButtonSettings();

                BackgroundImage = new BackgroundImageSettings();
            }

            public List<HelpTab> Tabs { get; set; }
            public bool ShowInfoOnPlayerInit { get; set; }
            public bool ShowInfoOnlyOncePerRuntime { get; set; }

            public int TabToOpenByDefault { get; set; }

            public Position Position { get; set; }
            public BackgroundImageSettings BackgroundImage { get; set; }

            public string ActiveButtonColor { get; set; }
            public string InactiveButtonColor { get; set; }
            public string CloseButtonColor { get; set; }
            public string CloseButtonText { get; set; }
            public string NextPageButtonColor { get; set; }
            public string NextPageText { get; set; }
            public string PrevPageButtonColor { get; set; }
            public string PrevPageText { get; set; }
            public string BackgroundColor { get; set; }

            public HelpButtonSettings HelpButton { get; set; }

            public bool UpgradedConfig { get; set; }

            public static Settings CreateDefault()
            {
                var settings = new Settings();
                var firstTab = new HelpTab
                {
                    ButtonText = "First Tab",
                    HeaderText = "First Tab",
                    Pages =
                    {
                        new HelpTabPage
                        {
                            TextLines =
                            {
                                "This is first tab, first page.",
                                "Add some text here by adding more lines.",
                                "You should replace all default text lines with whatever you feel up to",
                                "type <color=red> /info </color> to open this window",
                                "Press next page to check second page.",
                                "You may add more pages in config file."
                            },
                            ImageSettings =
                            {
                                new ImageSettings
                                {
                                    Position = new Position
                                    {
                                        MinX = 0,
                                        MaxX = 0.5f,
                                        MinY = 0,
                                        MaxY = 0.5f
                                    },
                                    Url = "http://th04.deviantart.net/fs70/PRE/f/2012/223/4/4/rust_logo_by_furrypigdog-d5aqi3r.png"
                                },
                                new ImageSettings
                                {
                                    Position = new Position
                                    {
                                        MinX = 0.5f,
                                        MaxX = 1f,
                                        MinY = 0,
                                        MaxY = 0.5f
                                    },
                                    Url = "http://files.enjin.com/176331/IMGS/LOGO_RUST1.fw.png"
                                },
                                new ImageSettings
                                {
                                    Position = new Position
                                    {
                                        MinX = 0,
                                        MaxX = 0.5f,
                                        MinY = 0.5f,
                                        MaxY = 1f
                                    },
                                    Url = "http://files.enjin.com/176331/IMGS/LOGO_RUST1.fw.png"
                                },
                                new ImageSettings
                                {
                                    Position = new Position
                                    {
                                        MinX = 0.5f,
                                        MaxX = 1f,
                                        MinY = 0.5f,
                                        MaxY = 1f
                                    },
                                    Url = "http://th04.deviantart.net/fs70/PRE/f/2012/223/4/4/rust_logo_by_furrypigdog-d5aqi3r.png"
                                },
                            }
                        },
                        new HelpTabPage
                        {
                            TextLines =
                            {
                                "This is first tab, second page",
                                "Add some text here by adding more lines.",
                                "You should replace all default text lines with whatever you feel up to",
                                "type <color=red> /info </color> to open this window",
                                "Press next page to check third page.",
                                "Press prev page to go back to first page.",
                                "You may add more pages in config file."
                            }
                        }
                        ,
                        new HelpTabPage
                        {
                            TextLines =
                            {
                                "This is first tab, third page",
                                "Add some text here by adding more lines.",
                                "You should replace all default text lines with whatever you feel up to",
                                "type <color=red> /info </color> to open this window",
                                "Press prev page to go back to second page.",
                            }
                        }
                    }
                };
                var secondTab = new HelpTab
                {
                    ButtonText = "Second Tab",
                    HeaderText = "Second Tab",
                    Pages =
                    {
                        new HelpTabPage
                        {
                            TextLines =
                            {
                                "This is second tab, first page.",
                                "Add some text here by adding more lines.",
                                "You should replace all default text lines with whatever you feel up to",
                                "type <color=red> /info </color> to open this window",
                                "You may add more pages in config file."
                            }
                        }
                    }
                };
                var thirdTab = new HelpTab
                {
                    ButtonText = "Third Tab",
                    HeaderText = "Third Tab",
                    Pages =
                    {
                        new HelpTabPage
                        {
                            TextLines =
                            {
                                "This is third tab, first page.",
                                "Add some text here by adding more lines.",
                                "You should replace all default text lines with whatever you feel up to",
                                "type <color=red> /info </color> to open this window",
                                "You may add more pages in config file."
                            }
                        }
                    }
                };

                settings.Tabs.Add(firstTab);
                settings.Tabs.Add(secondTab);
                settings.Tabs.Add(thirdTab);

                return settings;
            }
        }

        public sealed class Position
        {
            public Position()
            {
                MinX = 0.15f;
                MaxX = 0.9f;
                MinY = 0.2f;
                MaxY = 0.9f;
            }

            public float MinX { get; set; }
            public float MaxX { get; set; }
            public float MinY { get; set; }
            public float MaxY { get; set; }

            public string GetRectTransformAnchorMin()
            {
                return string.Format("{0} {1}", MinX, MinY);
            }

            public string GetRectTransformAnchorMax()
            {
                return string.Format("{0} {1}", MaxX, MaxY);
            }
        }

        public sealed class HelpTab
        {
            private string _headerText;
            private string _buttonText;

            public HelpTab()
            {
                ButtonText = "Default ServerInfo Help Tab";
                HeaderText = "Default ServerInfo Help";
                Pages = new List<HelpTabPage>();
                TextFontSize = 16;
                HeaderFontSize = 32;
                TabButtonFontSize = 16;
                TextAnchor = TextAnchor.MiddleLeft;
                HeaderAnchor = TextAnchor.UpperLeft;
                TabButtonAnchor = TextAnchor.MiddleCenter;
                OxideGroup = string.Empty;
            }

            public string ButtonText
            {
                get { return string.IsNullOrEmpty(_buttonText) ? _headerText : _buttonText; }
                set { _buttonText = value; }
            }

            public string HeaderText
            {
                get
                {
                    return string.IsNullOrEmpty(_headerText) ? _buttonText : _headerText;
                }
                set { _headerText = value; }
            }

            public List<HelpTabPage> Pages { get; set; }

            public TextAnchor TabButtonAnchor { get; set; }
            public int TabButtonFontSize { get; set; }

            public TextAnchor HeaderAnchor { get; set; }
            public int HeaderFontSize { get; set; }

            public int TextFontSize { get; set; }
            public TextAnchor TextAnchor { get; set; }

            public string OxideGroup { get; set; }
        }

        public sealed class HelpTabPage
        {
            public List<string> TextLines { get; set; }
            public List<ImageSettings> ImageSettings { get; set; }

            public HelpTabPage()
            {
                TextLines = new List<string>();
                ImageSettings = new List<ImageSettings>();
            }
        }

        public class ImageSettings
        {
            public Position Position { get; set; }
            public string Url { get; set; }
            public int TransparencyInPercent { get; set; }

            public ImageSettings()
            {
                Position = new Position
                {
                    MaxX = 1.0f,
                    MaxY = 1.0f,
                    MinY = 0.0f,
                    MinX = 0.0f
                };
                Url = "http://7-themes.com/data_images/out/35/6889756-black-backgrounds.jpg";
                TransparencyInPercent = 100;
            }
        }

        public sealed class BackgroundImageSettings : ImageSettings
        {
            public bool Enabled { get; set; }

            public BackgroundImageSettings()
            {
                Enabled = false;
            }
        }

        public sealed class HelpButtonSettings
        {
            public bool IsEnabled { get; set; }
            public string Text { get; set; }
            public Position Position { get; set; }
            public string Color { get; set; }
            public int FontSize { get; set; }

            public HelpButtonSettings()
            {
                IsEnabled = false;
                Text = "Help";
                Color = "#" + ColorExtensions.ToHexStringRGBA(UnityEngine.Color.gray);

                FontSize = 18;

                Position = new Position { MinX = 0.00f, MaxX = 0.05f, MinY = 0.10f, MaxY = 0.14f };
            }
        }

        public sealed class PlayerInfoState
        {
            public PlayerInfoState(Settings settings)
            {
                if (settings == null) throw new ArgumentNullException("settings");

                ActiveTabIndex = settings.TabToOpenByDefault;
                PageIndex = 0;
                InfoShownOnLogin = settings.ShowInfoOnPlayerInit;
                InfoShownOnLoginOnce = settings.ShowInfoOnlyOncePerRuntime;
                ActiveTabContentPanelName = string.Empty;
                ChatHelpButtonName = string.Empty;
                MainPanelName = string.Empty;
            }

            public int ActiveTabIndex { get; set; }
            public int PageIndex { get; set; }
            public bool InfoShownOnLogin { get; set; }
            public bool InfoShownOnLoginOnce { get; set; }
            public string ActiveTabContentPanelName { get; set; }
            public string ChatHelpButtonName { get; set; }
            public string MainPanelName { get; set; }
        }

        public static class ColorExtensions
        {
            public static string ToRustFormatString(Color color)
            {
                return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
            }

            //
            // UnityEngine 5.1 Color extensions which were removed in 5.2
            //

            public static string ToHexStringRGB(Color col)
            {
                Color32 color = col;
                return string.Format("{0}{1}{2}", color.r, color.g, color.b);
            }

            public static string ToHexStringRGBA(Color col)
            {
                Color32 color = col;
                return string.Format("{0}{1}{2}{3}", color.r, color.g, color.b, color.a);
            }

            public static bool TryParseHexString(string hexString, out Color color)
            {
                try
                {
                    color = FromHexString(hexString);
                    return true;
                }
                catch
                {
                    color = Color.white;
                    return false;
                }
            }

            private static Color FromHexString(string hexString)
            {
                if (string.IsNullOrEmpty(hexString))
                {
                    throw new InvalidOperationException("Cannot convert an empty/null string.");
                }
                var trimChars = new[] { '#' };
                var str = hexString.Trim(trimChars);
                switch (str.Length)
                {
                    case 3:
                        {
                            var chArray2 = new[] { str[0], str[0], str[1], str[1], str[2], str[2], 'F', 'F' };
                            str = new string(chArray2);
                            break;
                        }
                    case 4:
                        {
                            var chArray3 = new[] { str[0], str[0], str[1], str[1], str[2], str[2], str[3], str[3] };
                            str = new string(chArray3);
                            break;
                        }
                    default:
                        if (str.Length < 6)
                        {
                            str = str.PadRight(6, '0');
                        }
                        if (str.Length < 8)
                        {
                            str = str.PadRight(8, 'F');
                        }
                        break;
                }
                var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
                var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
                var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
                var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

                return new Color32(r, g, b, a);
            }
        }
    }
}

// --- End of file: ServerInfo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sleeping-bag-tracker ---
// --- Original File Path: S/SleepingBagTracker/SleepingBagTracker.cs ---

ï»¿using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using UnityEngine.Networking;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Sleeping Bag Tracker", "Rogder Dodger", "1.0.3")]
    [Description("Tracks Sleeping bags assigned to other players (with team information)")]
    
    internal class SleepingBagTracker : CovalencePlugin
    {
        #region Configuration
        [PluginReference] private readonly Plugin Clans;
        private const string DefaultWebhookURL = "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
        private Configuration _config;
        private class Configuration
        {
            [JsonProperty(PropertyName = "Log To Console")]
            public bool LogToConsole;

            [JsonProperty(PropertyName = "Log To Discord")]
            public bool LogToDiscord;

            [JsonProperty(PropertyName = "Discord Webhook URL")]
            public string DiscordWebhookUrl = DefaultWebhookURL;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("A new configuration file is being generated.");
            _config = new Configuration
            {
                LogToConsole = true,
                LogToDiscord = true,
                DiscordWebhookUrl = DefaultWebhookURL,
            };
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["EmbedTitle"] = "Bag Assigned",
                ["EmbedBagDetailsWithBattlemetrics"] = "**Sleeping Bag** Owned by\n{ownerName}\n{ownerId}\n[Steam Profile](https://steamcommunity.com/profiles/{ownerId})\n [Battlemetrics](https://www.battlemetrics.com/rcon/players?filter%5Bsearch%5D={ownerId}&filter%5Bservers%5D=false&filter%5BplayerFlags%5D=&sort=score&showServers=true)\n\n **Assigned By**\n{assignerName}\n{assignerId}\nTeam: {assignerTeamId}\n[Steam Profile](https://steamcommunity.com/profiles/{assignerId})\n[Battlemetrics](https://www.battlemetrics.com/rcon/players?filter%5Bsearch%5D={assignerId}&filter%5Bservers%5D=false&filter%5BplayerFlags%5D=&sort=score&showServers=true)\n\n**Assigned To**\n{assigneeName}\n{assigneeId}\nTeam: {assigneeTeamId}\n[Steam Profile](https://steamcommunity.com/profiles/{assigneeId})\n[Battlemetrics](https://www.battlemetrics.com/rcon/players?filter%5Bsearch%5D={assigneeId}&filter%5Bservers%5D=false&filter%5BplayerFlags%5D=&sort=score&showServers=true)\n\n**Teleport**\n{teleportPos}\n\n**Server:\n**{serverName}",
                ["ConsoleMessage"] = "Sleeping Bag Assigned by {assignerName}/{assignerId} - Team {assignerTeamId} to {assigneeName}/{assigneeId} - Team {assigneeTeamId}"
            }, this);
        }

        private string FormatMessage(string key, BagInfo bagInfo)
        {
            return lang.GetMessage(key, this)
                .Replace("{ownerName}", bagInfo.BagDeployer?.displayName ?? "Unknown")
                .Replace("{ownerId}", bagInfo.BagDeployer?.UserIDString ?? "Unknown")
                .Replace("{assignerName}", bagInfo.BagAssigner?.displayName ?? "Unknown")
                .Replace("{assignerId}", bagInfo.BagAssigner?.UserIDString ?? "Unknown")
                .Replace("{assignerTeamId}", bagInfo.DeployerTeamId.ToString())
                .Replace("{assigneeName}", bagInfo.BagAssignee?.displayName ?? "Unknown")
                .Replace("{assigneeId}", bagInfo.AssigneeId.ToString())
                .Replace("{assigneeTeamId}", bagInfo.AssigneeTeamId.ToString())
                .Replace("{teleportPos}", bagInfo.TeleportPos)
                .Replace("{serverName}", covalence.Server.Name);
        }

        #endregion

        #region hooks

        object CanAssignBed(BasePlayer player, SleepingBag bag, ulong targetPlayerId)
        {
            var assignerTeamId = GetPlayerTeamId(player.userID);
            var assigneeTeamId = GetPlayerTeamId(targetPlayerId);
            var bagOwner = getPlayerById(bag.OwnerID);
            var assignee = getPlayerById(targetPlayerId);

            if (IsAssignedToNonTeamMember(assignerTeamId, assigneeTeamId) && !AreClanMembers(assignerTeamId, assigneeTeamId))
            {
                var bagInfo = new BagInfo(bagOwner, player, assignee, targetPlayerId, bag, assignerTeamId, assigneeTeamId);
                if (_config.LogToDiscord)
                {
                    SendDiscordEmbed(bagInfo);
                }
                if (_config.LogToConsole)
                {
                    Puts(FormatMessage("ConsoleMessage", bagInfo));
                }
            }


            return null;
        }

        #endregion

        #region Webhook
        private void SendDiscordEmbed(BagInfo bagInfo)
        {
            var title = FormatMessage("EmbedTitle", bagInfo);
            var description = FormatMessage("EmbedBagDetailsWithBattlemetrics", bagInfo);
            var payload = new
            {
                embeds = new[]
                {
                    new
                    {
                        title,
                        description,
                        color = 9109504,
                        timestamp = DateTime.Now,
                    }
                }
            };

            var form = new WWWForm();
            form.AddField("payload_json", JsonConvert.SerializeObject(payload));
            ServerMgr.Instance.StartCoroutine(PostToDiscord(_config.DiscordWebhookUrl, form));
        }

        private IEnumerator PostToDiscord(string url, WWWForm data)
        {
            var www = UnityWebRequest.Post(url, data);
            yield return www.SendWebRequest();

            if (www.isNetworkError || www.isHttpError)
            {
                Puts($"Failed to post to discord: {www.error}");
            }
            
        }

        #endregion

        #region models

        private class BagInfo
        {
            public BasePlayer BagDeployer { get; set; }
            public BasePlayer BagAssigner { get; set; }
            public ulong AssigneeId { get; set; }
            public BasePlayer BagAssignee { get; set; }
            public SleepingBag SleepingBag { get; set; }
            public ulong DeployerTeamId { get; set; }
            public ulong AssigneeTeamId { get; set; }
            public string TeleportPos { get; set; }
            public string BagName { get; set; }

            public BagInfo(BasePlayer bagDeployer, BasePlayer assigner, BasePlayer assignee, ulong assigneeId, SleepingBag bag, ulong deployerTeamId, ulong assigneeTeamId)
            {
                BagDeployer = bagDeployer;
                BagAssigner = assigner;
                BagAssignee = assignee;
                AssigneeId = assigneeId;
                AssigneeTeamId = assigneeTeamId;
                DeployerTeamId = deployerTeamId;
                TeleportPos = "teleportpos " + Math.Round(bag.transform.position.x, 2) + "," + Math.Round(bag.transform.position.y, 2) + "," + Math.Round(bag.transform.position.z, 2) + "";
                BagName = bag.name;
            }
        }

        #endregion

        #region helpers
        private ulong GetPlayerTeamId(ulong steamId)
        {
            var teamId = default(ulong);
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(steamId);

            if (playerTeam == null)
            {
                return teamId;
            }
            else
            {
                teamId = playerTeam.teamID;
            }

            return teamId;
        }

        private BasePlayer getPlayerById(ulong playerId)
        {
            var player = covalence.Players.FindPlayerById(playerId.ToString());
            if (player != null)
            {
                return (BasePlayer)(player).Object;
            }
            var sleeper = BasePlayer.FindSleeping(playerId);
            if (sleeper != null)
            {
                return sleeper;
            }
            return null;
        }

        private bool IsAssignedToNonTeamMember(ulong assigner, ulong assignee)
        {
            // both players are not in a team
            if (assigner == default(ulong) && assignee == default(ulong))
            {
                return true;
            }
            // both players are in a team return true if it's not the same team 
            if (assigner != default(ulong) && assignee != default(ulong))
            {
                return assigner != assignee;
            }
            // one player is in a team and the other is not
            return true;
        }
        
        private bool AreClanMembers(ulong playerID, ulong assignee)
        {
            if (Clans == null) 
                return false;

            string playerIdStr = playerID.ToString();
            string assigneeIdStr = assignee.ToString();

            var isSameClanMember = Clans.Call("IsClanMember", playerIdStr, assigneeIdStr);

            if (isSameClanMember != null)
                return (bool)isSameClanMember;

            var playerClan = Clans.Call("GetClanOf", playerIdStr);
            var assigneeClan = Clans.Call("GetClanOf", assigneeIdStr);

            if (playerClan == null || assigneeClan == null)
                return false;

            return (string)playerClan == (string)assigneeClan;
        }

        #endregion
    }
}


// --- End of file: SleepingBagTracker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/supply-alert ---
// --- Original File Path: S/SupplyAlert/SupplyAlert.cs ---

ï»¿using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Supply Alert", "Ultra", "1.1.2")]
    [Description("Sound and visual alert for dropped supply")]

    class SupplyAlert : RustPlugin
    {
        #region Fields

        Timer guiAlertTimer;
        CuiPanel alertPanel;
        string alertPanelName = "alertPanelName";

        #endregion

        #region Chat Commands

        [ChatCommand("satest")]
        void SupplyAlertTest(BasePlayer player)
        {
            RunSupplyAlert();
        }

        #endregion

        #region Oxide Hooks

        void OnServerInitialized()
        {
            InitCUI();
        }

        void OnEntitySpawned(BaseEntity baseEntity)
        {
            if (baseEntity != null && baseEntity is SupplyDrop)
            {
                RunSupplyAlert();
            }
        }

        void Unload()
        {
            DestroyGUIAlerts();

            guiAlertTimer?.DestroyToPool();
            guiAlertTimer = null;
        }

        #endregion

        #region Core

        void RunSupplyAlert()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (configData.ChatAlertEnabled) SendReply(player, $"<color=#ee2211>{configData.ChatAlertText}</color>");
                if (configData.SoundAlertEnabled) Effect.server.Run($"{configData.SoundAlertAsset}", player.transform.position);
                if (configData.GUIAlertEnabled) DisplayAlertGUI(player);
            }

            if (configData.GUIAlertEnabled) guiAlertTimer = timer.Once(configData.GUIAlertDuration, () => DestroyGUIAlerts());
        }

        #endregion

        #region Config

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Sound alert enabled")]
            public bool SoundAlertEnabled;

            [JsonProperty(PropertyName = "Sound alert asset")]
            public string SoundAlertAsset;

            [JsonProperty(PropertyName = "Chat alert enabled")]
            public bool ChatAlertEnabled;

            [JsonProperty(PropertyName = "Chat alert text")]
            public string ChatAlertText;

            [JsonProperty(PropertyName = "GUI alert enabled")]
            public bool GUIAlertEnabled;

            [JsonProperty(PropertyName = "GUI alert text")]
            public string GUIAlertText;

            [JsonProperty(PropertyName = "GUI alert duration (seconds)")]
            public float GUIAlertDuration;
        }

        protected override void LoadConfig()
        {
            try
            {
                base.LoadConfig();
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            configData = new ConfigData()
            {
                ChatAlertEnabled = true,
                ChatAlertText = "Supply in the air",
                GUIAlertEnabled = true,
                GUIAlertText = "SUPPLY IN THE AIR",
                GUIAlertDuration = 3,
                SoundAlertEnabled = true,
                SoundAlertAsset = "assets/bundled/prefabs/fx/invite_notice.prefab"
            };
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData, true);
            base.SaveConfig();
        }

        #endregion

        #region CUI

        void InitCUI()
        {
            alertPanel = new CuiPanel
            {
                CursorEnabled = false,
                RectTransform =
                    {
                        AnchorMin = $"0.4 0.77",
                        AnchorMax = $"0.6 0.81"
                    },
                Image =
                 { Color = "0 0 0 0.8" }
            };
        }

        void DisplayAlertGUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, alertPanelName);

            var container = new CuiElementContainer();
            container.Add(alertPanel, name: alertPanelName);
            container.Add(GetLabel($"{configData.GUIAlertText}", align: TextAnchor.MiddleCenter), alertPanelName);

            CuiHelper.AddUi(player, container);
        }

        void DestroyGUIAlerts()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, alertPanelName);
            }
        }

        CuiLabel GetLabel(string text, int size = 13, string anchorMin = "0.05 0.02", string anchorMax = "0.98 0.9", TextAnchor align = TextAnchor.MiddleCenter, string color = "1 1 1 1", string font = "robotocondensed-regular.ttf")
        {
            return new CuiLabel
            {
                Text =
                    {
                        Text = text,
                        FontSize = size,
                        Align = align,
                        Color = color,
                        Font = font
                    },
                RectTransform =
                    {
                        AnchorMin = anchorMin,
                        AnchorMax = anchorMax
                    },
            };
        }

        #endregion
    }
}


// --- End of file: SupplyAlert.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/server-status ---
// --- Original File Path: S/ServerStatus/ServerStatus.cs ---

ï»¿using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core;
using System;
using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries;
using System.Linq;
using ConVar;
using Oxide.Game.Rust.Libraries;

namespace Oxide.Plugins
{
    [Info("Server Status", "UNKN0WN", "1.3.0")]
    [Description("Server Status Check for discord Webhook")]
    class ServerStatus : RustPlugin
    {
        private Configuration _config;
        [PluginReference] Plugin SmoothRestart;
        private bool isQuit = false;
        private bool isSR = false;

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (null != arg)
            {
                string commandName = arg.cmd.Name;
                string[] args = arg.Args;

                if (null == commandName) return null;
                if(isSR == true)
                {
                    if("sr.restart".Equals(commandName))
                    {
                        string time = "300";
                        string reason = "Unknown";
                        if (null != args)
                        {
                            if("stop".Equals(args[0]))
                            {
                                SendMessage(Lang("Restart Cancel"), Lang("Restart Cancel Descriptions"));
                                Puts("Restart has been cancelled.");
                                return null;
                            }
                            else
                            {
                                if (2 <= args.Length)
                                {
                                    time = args[0];
                                    reason = "";
                                    for (int i = 1; i < args.Length; i++)
                                    {
                                        reason += args[i];
                                        if (i < args.Length - 1) reason += " ";
                                    }
                                }
                                else
                                {
                                    time = args[0];
                                }
                            }
                        }

                        var list = new Dictionary<string, string>
                        {
                            { "time", time },
                            { "reason", reason }
                        };
                        SendMessage(Lang("Restart"), Lang("Restart Descriptions", list));
                    }
                }
                if(isSR == false)
                {
                    if ("restart".Equals(commandName))
                    {
                        string time = "300";
                        string reason = "Unknown";
                        if (null != args)
                        {
                            if ("-1".Equals(args[0]))
                            {
                                SendMessage(Lang("Restart Cancel"), Lang("Restart Cancel Descriptions"));
                                Puts("Restart has been cancelled.");
                                return null;
                            }
                            else
                            {
                                if (2 <= args.Length)
                                {
                                    time = args[0];
                                    reason = "";
                                    for (int i = 1; i < args.Length; i++)
                                    {
                                        reason += args[i];
                                        if (i < args.Length - 1) reason += " ";
                                    }
                                }
                                else
                                {
                                    time = args[0];
                                }
                            }
                        }
                        var list = new Dictionary<string, string>
                        {
                            { "time", time },
                            { "reason", reason }
                        };
                        SendMessage(Lang("Restart"), Lang("Restart Descriptions", list));
                    }
                }
                
                if ("quit".Equals(commandName))
                {
                    timer.Once(3f, () =>
                    {
                        isQuit = true;
                        Server.Command("quit");
                    });

                    if (!isQuit)
                    {
                        SendMessage(Lang("Quit"), Lang("Quit Descriptions"));
                        return isQuit;
                    }
                }
            }

            return null;
        }

        private void OnServerInitialized()
        {
            if (_config.webhook == "webhookurl" || _config.webhook == null || _config.webhook == string.Empty)
            {
                PrintWarning("Change WebHook URL");
                return;
            }

            if(SmoothRestart != null)
            {
                isSR = true;
                PrintWarning("SmoothRestart Plugins Allowed");
            }

            SendMessage(Lang("Online"), Lang("Online Descriptions"));
        }

        #region Config
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class Configuration
        {
            [JsonProperty("Discord WebHook")]
            public string webhook { get; set; } = "webhookurl";

            [JsonProperty("Embed Fields Time Format")]
            public string TimeFormat { get; set; } = "MM/dd/yyyy HH:mm:ss";

            [JsonProperty("Selection Mention (0 - none | 1 - @here | 2 - @everyone | 3 - @something)")]
            public int SelectionMention { get; set; } = 0;

            [JsonProperty("Designated mention")]
            public string DesignatedMention = "@something";
        }
        #endregion
        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Title"] = "Server Status ð«",
                ["Online"] = "ð¡ Server is online | â",
                ["Quit"] = "ð¡ Server is offline | â",
                ["Restart"] = "ð¡ The server has started restarting | â³",
                ["Restart Cancel"] = "ð¡ The server has canceled the restart | â³",
                ["Time"] = "Time:",
                ["Descriptions"] = "Descriptions:",
                ["Online Descriptions"] = "ð Server is Online",
                ["Quit Descriptions"] = "ð Server is Offline",
                ["Restart Descriptions"] = "ð The server shuts down after {time} seconds.\n\nð Reason: {reason}",
                ["Restart Cancel Descriptions"] = "ð Server is Cancel Restart",
                ["Unknown"] = "Unknown"

            }, this, "en");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Title"] = "ìë² ìí ð«",
                ["Online"] = "ð¡ ìë² ìì | â",
                ["Quit"] = "ð¡ ìë² ì¤ì§. | â",
                ["Restart"] = "ð¡ ìë² ì¬ìì | â³",
                ["Restart Cancel"] = "ð¡ ì¬ìì ì·¨ì| â³",
                ["Time"] = "ìê°:",
                ["Descriptions"] = "ì¤ëª:",
                ["Online Descriptions"] = "ð ìë²ê° ììëììµëë¤.",
                ["Quit Descriptions"] = "ð ìë²ê° ì¤ì§ëììµëë¤.",
                ["Restart Descriptions"] = "ð ìë²ê°  {time} ì´ íì ì¬ìì ë©ëë¤.\n\nð ì´ì : {reason}",
                ["Restart Cancel Descriptions"] = "ð ìë² ì¬ììì´ ì·¨ìëììµëë¤.",
                ["Unknown"] = "ìììì"
            }, this, "kr");
        }

        private string Lang(string key, Dictionary<string, string> args = null)
        {
            if (string.IsNullOrEmpty(key))
                return string.Empty;

            key = lang.GetMessage(key, this);

            if (args != null)
            {
                foreach (var lekey in args)
                {
                    if (key.Contains("{" + lekey.Key + "}"))
                        key = key.Replace("{" + lekey.Key + "}", lekey.Value);
                }
            }

            return key;
        }
        #endregion
        #region Discord
        private void SendMessage(string status, string reason)
        {
            var list = new Dictionary<string, string>
            {
                { "hostname", ConVar.Server.hostname },
                { "ip", ConVar.Server.ip },
                { "port", ConVar.Server.port.ToString() },
                { "online", BasePlayer.activePlayerList.Count.ToString() },
                { "maxplayers", ConVar.Server.maxplayers.ToString() }
            };
            var embed = new Embed()
                .AddField(Lang("Title", list), status, true)
                .AddField(Lang("Time"), $"{DateTime.Now.ToString(_config.TimeFormat)}", false)
                .AddField(Lang("Descriptions", list), reason, false);

            if(_config.SelectionMention == 0)
            {
                webrequest.Enqueue(_config.webhook, new DiscordMessage("", embed).ToJson(), (code, response) => {
                }, this, RequestMethod.POST, new Dictionary<string, string>() {
                { "Content-Type", "application/json" }
                });
            }
            else if (_config.SelectionMention == 1)
            {
                webrequest.Enqueue(_config.webhook, new DiscordMessage("@here", embed).ToJson(), (code, response) => {
                }, this, RequestMethod.POST, new Dictionary<string, string>() {
                { "Content-Type", "application/json" }
                });
            }
            else if (_config.SelectionMention == 2)
            {
                webrequest.Enqueue(_config.webhook, new DiscordMessage("@everyone", embed).ToJson(), (code, response) => {
                }, this, RequestMethod.POST, new Dictionary<string, string>() {
                { "Content-Type", "application/json" }
                });
            }
            else if (_config.SelectionMention == 3)
            {
                webrequest.Enqueue(_config.webhook, new DiscordMessage($"{_config.DesignatedMention}", embed).ToJson(), (code, response) => {
                }, this, RequestMethod.POST, new Dictionary<string, string>() {
                { "Content-Type", "application/json" }
                });
            }
            
        }

        private class DiscordMessage
        {
            
            public DiscordMessage(string content, params Embed[] embeds)
            {
                Content = "" + content;
                Embeds = embeds.ToList();
            }

            [JsonProperty("content")] public string Content { get; set; }
            [JsonProperty("embeds")] public List<Embed> Embeds { get; set; }

            public string ToJson() => JsonConvert.SerializeObject(this);
        }

        private class Embed
        {
            [JsonProperty("fields")] public List<Field> Fields { get; set; } = new List<Field>();

            public Embed AddField(string name, string value, bool inline)
            {
                Fields.Add(new Field(name, Regex.Replace(value, "<.*?>", string.Empty), inline));

                return this;
            }
        }

        private class Field
        {
            public Field(string name, string value, bool inline)
            {
                Name = name;
                Value = value;
                Inline = inline;
            }

            [JsonProperty("name")] public string Name { get; set; }
            [JsonProperty("value")] public string Value { get; set; }
            [JsonProperty("inline")] public bool Inline { get; set; }
        }
        #endregion
    }
}


// --- End of file: ServerStatus.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/simple-kill-feed ---
// --- Original File Path: S/SimpleKillFeed/SimpleKillFeed.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using Facepunch;
using Facepunch.Math;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using ProtoBuf;

/**********************************************************************
*
*   2.4.0   -   Minor adjustments
*               Fixed most chatmessages in corrected language
*               Removed a hardcoded debug
*               Added Killfeed text allignment (left/right) to cfg and methods
*               Fix for dupe tags
*               Added support for wolf2 (make sure to add it to the cfg file manualy)
*               Added API : Interface.Call("OnKillFeedMessageReceived" , text);
*   2.4.1   -   Added permission simplekillfeed.exclude
*   2.4.2   -   Added more checks for The new animal AI
*           
***********************************************************************/
namespace Oxide.Plugins
{
    [Info("Simple Kill Feed", "Krungh Crow", "2.4.2")]
    [Description("A kill feed, that displays various kill events in the top right corner.")]
    public class SimpleKillFeed : RustPlugin
    {
        #region Fields

        [PluginReference] private Plugin BetterChat , Clans;
        private bool _isClansReborn;
        private bool _isClansIo;
        private bool _isClansMevent;
        private readonly Dictionary<uint, string> _itemNameMapping = new Dictionary<uint, string>();
        private GameObject _holder;
        private KillQueue _killQueue;
        private static SKFConfig configdata;
        private static SimpleKillFeedData _data;

        const string Exclude_Perm = "simplekillfeed.exclude";


        #endregion

        #region Config

        private class SKFConfig
        {
            [JsonProperty("Show Traps and Entitys in Kill Feed")]
            public bool EnableEntityFeed;
            [JsonProperty("Show Animals kills (default true)")]
            public bool EnableAnimalFeed;
            [JsonProperty("Show Npcs kills (Default true)")]
            public bool EnableNpcFeed;
            [JsonProperty("Show suicides (Default: true)")]
            public bool EnableSuicides;
            [JsonProperty("Show Deaths by Animals (Default: true)")]
            public bool EnableAnimal;
            [JsonProperty("Show Deaths by Cold (Default: true)")]
            public bool EnableCold;
            [JsonProperty("Show deaths by Drowning (Default: true)")]
            public bool EnableDrowning;
            [JsonProperty("Show Deaths by Fall (Default: true)")]
            public bool EnableFall;
            [JsonProperty("Show Deaths by Hunger (Default: true)")]
            public bool EnableHunger;
            [JsonProperty("Show Deaths by Electricution (Default: true)")]
            public bool EnableElectricution;
            [JsonProperty("Show Deaths by Radiation (Default: true)")]
            public bool EnableRadiationKills;
            [JsonProperty("Chat Icon Id (Steam profile ID)")]
            public ulong IconId;
            [JsonProperty("Max messages in feed (Default: 5)")]
            public int MaxFeedMessages;
            [JsonProperty("Max player name length in feed (Default: 18)")]
            public int MaxPlayerNameLength;
            [JsonProperty("Feed message TTL in seconds (Default: 7)")]
            public int FeedMessageTtlSec;
            [JsonProperty("Allow kill messages in chat along with kill feed")]
            public bool EnableChatFeed;
            [JsonProperty("Log PvP Kill events")]
            public bool EnableLogging;
            [JsonProperty("Height ident (space between messages). Default: 0.0185")]
            public float HeightIdent;
            [JsonProperty("Feed Position - Anchor Max. (Default: 0.995 0.986")]
            public string AnchorMax;
            [JsonProperty("Feed Position - Anchor Min. (Default: 0.723 0.964")]
            public string AnchorMin;
            [JsonProperty("Font size of kill feed (Default: 12)")]
            public int FontSize;
            [JsonProperty("Default textanchor (left or right)")]
            public string TextAnchor;
            [JsonProperty("Outline Text Size (Default: 0.5 0.5)")]
            public string OutlineSize;
            [JsonProperty("Default color for distance (if too far from any from the list). Default: #FF8000")]
            public string DefaultDistanceColor;
            [JsonProperty("Distance Colors List (Certain color will apply if distance is <= than specified)")]
            public DistanceColor[] DistanceColors;
            [JsonProperty("Custom Entity Names, you can remove or add more!")]
            public Dictionary<string, string> Ents = new Dictionary<string, string>();
            [JsonProperty("Custom Animal Names, you can remove or add more!")]
            public Dictionary<string, string> Animal = new Dictionary<string, string>();
            [JsonProperty("Custom Weapon Names, you can add more!")]
            public Dictionary<string, string> Weapons = new Dictionary<string, string>();
            [JsonProperty("Custom Npc Names, you can add more!")]
            public Dictionary<string, string> Npcs = new Dictionary<string, string>();

            [OnDeserialized]
            internal void OnDeserialized(StreamingContext ctx) => Array.Sort(DistanceColors, (o1, o2) => o1.DistanceThreshold.CompareTo(o2.DistanceThreshold));

            public class DistanceColor
            {
                public int DistanceThreshold;
                public string Color;
                public bool TestDistance(int distance) => distance <= DistanceThreshold;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configdata = Config.ReadObject<SKFConfig>();

            if (string.IsNullOrEmpty(configdata.TextAnchor))
            {
                configdata.TextAnchor = "right";
                SaveConfig();
                Puts("Adding TextAnchor to the cfg");
            }
        }

        protected override void LoadDefaultConfig()
        {
            configdata = new SKFConfig
            {
                EnableEntityFeed = true,
                EnableAnimalFeed = true,
                EnableNpcFeed = true,
                EnableFall = true ,
                EnableHunger = true ,
                EnableElectricution = true,
                EnableSuicides = true,
                EnableAnimal = true ,
                EnableCold = true ,
                EnableDrowning = true,
                EnableRadiationKills = true,
                IconId = 76561197960839785UL,
                MaxFeedMessages = 5,
                MaxPlayerNameLength = 18,
                FeedMessageTtlSec = 7,
                EnableChatFeed = true,
                EnableLogging = false,
                HeightIdent = 0.0185f,
                AnchorMax = "0.995 0.986",
                AnchorMin = "0.723 0.964",
                FontSize = 12,
                TextAnchor = "right" ,
                OutlineSize = "0.5 0.5",
                DefaultDistanceColor = "#FF8000",
                DistanceColors = new[]
                {
                    new SKFConfig.DistanceColor
                    {
                        Color = "#FFFFFF",
                        DistanceThreshold = 50
                    },
                    new SKFConfig.DistanceColor
                    {
                        Color = "#91D6FF",
                        DistanceThreshold = 100
                    },
                    new SKFConfig.DistanceColor
                    {
                        Color = "#FFFF00",
                        DistanceThreshold = 150
                    }
                },
                Ents = new Dictionary<string, string>()
                {
                    { "autoturret_deployed","Auto Turret" },
                    { "flameturret.deployed","Flame Turret"},
                    { "guntrap.deployed","Gun Trap"},
                    { "landmine","Landmine"},
                    { "beartrap","Bear Trap"},
                    { "sam_site_turret_deployed","Sam Site Turret"},
                    { "patrolhelicopter","Helicopter"},
                    { "bradleyapc","Bradley APC"}
                },
                Animal = new Dictionary<string, string>()
                {
                    { "bear","Bear" },
                    { "polarbear","PolarBear" },
                    { "wolf","Wolf" },
                    { "wolf2", "Wild wolf"},
                    { "stag","Stag"},
                    { "boar","Boar" },
                    { "chicken","Chicken" },
                    { "horse","Horse"},
                    { "simpleshark","Shark" }
                },
                Weapons = new Dictionary<string, string>()
                {
                    { "Assault Rifle","Ak-47" },
                    { "LR-300 Assault Rifle","LR-300" },
                    { "L96 Rifle","L96" },
                    { "Bolt Action Rifle","Bolt" },
                    { "Semi-Automatic Rifle","Semi-AR" },
                    { "Semi-Automatic Pistol","Semi-AP" },
                    { "Spas-12 Shotgun","Spas-12" },
                    { "M92 Pistol","M92" }
                },
                Npcs = new Dictionary<string, string>()
                {
                    { "scientist","Scientist Npc" }
                }
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configdata);

        #endregion

        #region Data (ProtoBuf)

        [ProtoContract(ImplicitFields = ImplicitFields.AllPublic)]
        private class SimpleKillFeedData
        {
            public HashSet<ulong> DisabledUsers = new HashSet<ulong>();
        }

        private void LoadData()
        {
            _data = ProtoStorage.Load<SimpleKillFeedData>(nameof(SimpleKillFeed)) ?? new SimpleKillFeedData();
        }

        private void SaveData()
        {
            if (_data == null) return;
            ProtoStorage.Save(_data, nameof(SimpleKillFeed));
        }

        #endregion

        #region ChatCommand

        [ChatCommand("feed")]
        private void ToggleFeed(BasePlayer player)
        {
            if (!_data.DisabledUsers.Contains(player.userID))
            {
                _data.DisabledUsers.Add(player.userID);
                Player.Message(player, _("Disabled", player), null, configdata.IconId);
            }
            else
            {
                _data.DisabledUsers.Remove(player.userID);
                Player.Message(player, _("Enabled", player), null, configdata.IconId);
            }
        }

        #endregion

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            _isClansReborn = Clans != null && Clans.Author.Contains("k1lly0u");
            _isClansIo = Clans != null && Clans.Author.Contains("playrust.io / dcode");
            _isClansMevent = Clans != null && Clans.Author.Contains("mevent");
            foreach (var blueprint in ItemManager.bpList.Where(bp => bp.targetItem.category == ItemCategory.Weapon || bp.targetItem.category == ItemCategory.Tool))
            {
                var md = blueprint.targetItem.GetComponent<ItemModEntity>();
                if (!md)
                    continue;
                if (!_itemNameMapping.ContainsKey(md.entityPrefab.resourceID))
                    _itemNameMapping.Add(md.entityPrefab.resourceID , blueprint.targetItem.displayName.english);
            }
            _holder = new GameObject("SKFHolder");
            UnityEngine.Object.DontDestroyOnLoad(_holder);
            _killQueue = _holder.AddComponent<KillQueue>();
            _killQueue.SetPlugin(this);//Add the plugin to the class
            Pool.ResizeBuffer<KillEvent>(configdata.MaxFeedMessages);
            permission.RegisterPermission(Exclude_Perm , this);
        }
        private void Init() => LoadData();

        private void Unload()
        {
            _killQueue = null;
            UnityEngine.Object.Destroy(_holder);
            _holder = null;
            for (var i = 0; i < configdata.MaxFeedMessages; i++)
                KillQueue.RemoveKillCui($"kf-{i}");
            configdata = null;
            Pool.IPoolCollection value;
            Pool.Directory.TryRemove(typeof(KillEvent), out value);
            SaveData();
            _data = null;
        }

        #endregion

        #region Oxide Hooks (Deaths)

        private void OnEntityDeath(BaseEntity victim , HitInfo hitInfo)
        {
            if (victim == null || victim is BasePlayer) return;

            // Check if victim is either an animal or a specific NPC type
            if (!(victim is BaseAnimalNPC || victim is BaseNPC2) || !IsAnimal(victim)) return;

            BasePlayer attacker = hitInfo.InitiatorPlayer;
            if (attacker == null || attacker.IsNpc || IsAnimal(attacker) || IsZombieHorde(attacker)) return;
            if (!attacker.userID.IsSteamId()) return;
            if (!configdata.EnableAnimalFeed) return;

            // Determine victim name based on its type
            string VictimName;
            if (victim is BaseAnimalNPC animalVictim)
            {
                VictimName = configdata.Animal[animalVictim.ShortPrefabName];
            }
            else if (victim is BaseNPC2 npcVictim)
            {
                VictimName = npcVictim.name.Contains("Wolf2") ? "Wolf2" : configdata.Animal[npcVictim.ShortPrefabName];
            }
            else
            {
                return; // Exit if victim is neither BaseAnimalNPC nor BaseNPC2
            }

            string AttackerName = SanitizeName(GetClan(attacker) + attacker.displayName);
            string WeaponName = GetCustomWeaponName(hitInfo);
            var distance = (int)Vector3.Distance(attacker.transform.position , victim.transform.position);
            _killQueue.OnDeath(attacker , null , string.Format(_("MsgFeedKillAnimalFromPlayer") , AttackerName , VictimName , WeaponName , GetDistanceColor(distance) , distance));
        }

        private void OnEntityDeath(SimpleShark victim, HitInfo hitInfo)
        {
            if (victim == null || victim is BasePlayer || !IsAnimal(victim)) return;
            BasePlayer attacker = hitInfo.InitiatorPlayer;

            if (attacker == null || attacker.IsNpc || IsAnimal(attacker) || IsZombieHorde(attacker)) return;
            if (!configdata.EnableAnimalFeed) return;

            string VictimName = configdata.Animal[victim.ShortPrefabName];
            string AttackerName = SanitizeName(GetClan(attacker) + attacker.displayName);
            string WeaponName = GetCustomWeaponName(hitInfo);
            var distance = (int)Vector3.Distance(attacker.transform.position, victim.transform.position);
            _killQueue.OnDeath(attacker, null, string.Format(_("MsgFeedKillAnimalFromPlayer"), AttackerName, VictimName, WeaponName, GetDistanceColor(distance), distance));

        }

        private void OnPlayerDeath(BasePlayer victim , HitInfo hitInfo)
        {
            try
            {
                if (victim == null) return;

                var wAttacker = victim.lastAttacker?.ToPlayer();
                if (!victim.userID.IsSteamId() && !configdata.EnableNpcFeed)
                {
                    return;
                }

                // Modified section to check for BaseNPC2 *before* checking IsWounded.
                if ((hitInfo.Initiator is BaseAnimalNPC || hitInfo.Initiator is BaseNPC2))
                {
                    if (!configdata.EnableAnimal) return; // Check EnableAnimal before processing
                    if (hitInfo.Initiator is BaseNPC2 && !configdata.EnableNpcFeed) return; // Check EnableNpcFeed when killed by BaseNPC2
                    OnKilledByAnimal(hitInfo.Initiator , victim);
                    return;
                }

                if (IsTrap(hitInfo.Initiator))
                {
                    if (!configdata.EnableEntityFeed) return;
                    OnKilledByEnt(hitInfo.Initiator , victim); return;
                }

                if (victim.lastAttacker is NPCAutoTurret)
                {
                    if (!configdata.EnableEntityFeed) return;
                    OnSentry(victim);
                    return;
                }

                if (victim.lastAttacker.ToString().Contains("cactus"))
                {
                    if (!victim.userID.IsSteamId() && !configdata.EnableNpcFeed) return;
                    OnCactus(victim); return;
                }

                if (!wAttacker.userID.IsSteamId() && !victim.userID.IsSteamId())
                {
                    //Puts($"Npc kill : {wAttacker} Killed {victim}");
                    return;
                }
                if ((wAttacker.userID.IsSteamId() && !victim.userID.IsSteamId()) && !configdata.EnableNpcFeed)
                {
                    return;
                }

                if (hitInfo == null && (wAttacker != null && victim.IsWounded()))
                {
                    OnDeathFromWounds(wAttacker , victim);
                    return;
                }

                if (victim.lastAttacker?.ToPlayer() == victim)
                {
                    if (!configdata.EnableSuicides) return;
                    OnSuicide(victim); return;
                    return;
                }

                if (!victim.userID.IsSteamId() && hitInfo.Initiator is HotAirBalloon) return;

                if (hitInfo.WeaponPrefab.prefabID == 3032863244)//Cannon Shell prefab id
                {
                    if (!configdata.EnableEntityFeed) return;
                    OnKilledByBradley(victim); return;
                }

                if (IsRadiation(hitInfo))
                {
                    if (!configdata.EnableRadiationKills) return;
                    OnKilledByRadiation(victim); return;
                }

                if (IsFall(hitInfo) && victim.IsWounded())
                {
                    if (!configdata.EnableFall) return;
                    DeathByFall(victim); return;
                }

                if (IsCold(hitInfo))
                {
                    if (!configdata.EnableCold) return;
                    OnFrozen(victim); return;
                }

                if (IsDrowning(hitInfo))
                {
                    if (!configdata.EnableDrowning) return;
                    OnDrowning(victim); return;
                }

                if (IsHunger(hitInfo) || IsThirst(hitInfo) || IsPoison(hitInfo))
                {
                    if (!configdata.EnableHunger) return;
                    OnHunger(victim); return;
                }

                if (IsShock(hitInfo))
                {
                    if (!configdata.EnableElectricution) return;
                    OnShock(victim); return;
                    return;
                }
                var distance = !hitInfo.IsProjectile() ? (int)Vector3.Distance(hitInfo.PointStart , hitInfo.HitPositionWorld) : (int)hitInfo.ProjectileDistance;
                if (IsCar(hitInfo)) distance = 0;
                var attacker = hitInfo.InitiatorPlayer;

                if (attacker == null) return;

                else if (IsFlame(hitInfo))
                {
                    OnBurned(attacker , victim);
                }
                //if (victim.IsNpc && IsExplosion(hitInfo)) return;//BotRespawn npc's can explode throwing errors
                else if (!IsDrowning(hitInfo))
                {
                    OnKilled(attacker , victim , hitInfo , distance);
                    return;
                }
                return;
            }
            catch
            {
                return;
            }
        }

        #endregion

        #region LanguageAPI

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string , string>
            {
            { "MsgAttacker", "You killed <color=#ff686b>{0}</color> from {1}m in <color=#ff686b>{2}</color>."},
            {"MsgVictim", "<color=#ff686b>{0}</color> killed you from {1}m with their {2} to <color=#ff686b>{3}</color>."},
            {"MsgFeedKill", "<color=#00ff00>{0}</color> killed <color=#ff686b>{1}</color>, <color=#ff686b>{2}</color>, <color=#ff686b>{3}</color><color={4}>({5}m)</color>"},
            {"MsgFeedKillNpc", "<color=#00ff00>{0}</color> killed <color=#ff686b>{1}</color>, <color={2}>({3}m)</color>"},
            {"MsgFeedKillAnimalFromPlayer", "<color=#00ff00>{0}</color> killed a <color=#ff686b>{1}</color>, <color=#ff686b>{2}</color>, <color={3}>({4}m)</color>"},

            {"MsgAtkWounded", "You wounded <color=#ff686b>{0}</color> till death."},
            {"MsgVictimWounded", "<color=#ff686b>{0}</color> has wounded you till death."},
            {"MsgFeedWounded", "<color=#00ff00>{0}</color> finished <color=#ff686b>{1}</color>"},

            {"MsgAtkBurned", "You burned <color=#ff686b>{0}</color> alive!"},
            {"MsgVictimBurned", "<color=#ff686b>{0}</color> has burned you alive!"},
            {"MsgFeedBurned", "<color=#00ff00>{0}</color> burned <color=#ff686b>{1}</color>!"},

            {"MsgFeedKillBrad", "<color=#ff686b>{0}</color> was killed by a <color=orange>Shell</color>"},
            {"MsgFeedKillEnt", "<color=#ff686b>{0}</color> was killed by <color=orange>{1}</color>"},
            {"MsgFeedKillAnimal", "<color=#ff686b>{0}</color> was killed by <color=orange>{1}</color>"},

            {"MsgFeedKillSuicide", "<color=#ff686b>{0}</color> committed <color=orange>Suicide</color>"},
            {"MsgFeedKillRadiation", "<color=#ff686b>{0}</color> died to <color=orange>Radiation</color>"},
            {"MsgFeedKillFall", "<color=#ff686b>{0}</color> died by <color=orange>Fall</color>"},
            {"MsgFeedKillCold", "<color=#ff686b>{0}</color> died by <color=orange>Cold</color>"},
            {"MsgFeedKillDrowned", "<color=#ff686b>{0}</color> <color=orange>Drowned</color>"},
            {"MsgFeedKillHunger", "<color=#ff686b>{0}</color> <color=orange>Starved</color>"},
            {"MsgFeedKillShock", "<color=#ff686b>{0}</color> got <color=orange>Electrocuted</color>"},
            {"MsgFeedKillSentry", "<color=#ff686b>{0}</color> got killed by <color=orange>Outpost</color>"},
            {"MsgFeedKillCactus", "<color=#ff686b>{0}</color> died to a <color=orange>Cactus</color>"},

            {"Enabled", "KillFeed Enabled"},
            {"Disabled", "KillFeed Disabled"}
            } , this);

            lang.RegisterMessages(new Dictionary<string , string>
            {
            {"MsgAttacker", "Du hast <color=#ff686b>{0}</color> aus {1}m in <color=#ff686b>{2}</color> getötet."},
            {"MsgVictim", "<color=#ff686b>{0}</color> hat dich aus {1}m mit ihrer {2} zu <color=#ff686b>{3}</color> getötet."},
            {"MsgFeedKill", "<color=#00ff00>{0}</color> hat <color=#ff686b>{1}</color> getötet, <color=#ff686b>{2}</color>, <color=#ff686b>{3}</color><color={4}>({5}m)</color>"},
            {"MsgFeedKillNpc", "<color=#00ff00>{0}</color> hat <color=#ff686b>{1}</color> getötet, <color={2}>({3}m)</color>"},
            {"MsgFeedKillAnimalFromPlayer", "<color=#00ff00>{0}</color> hat ein <color=#ff686b>{1}</color> getötet, <color=#ff686b>{2}</color>, <color={3}>({4}m)</color>"},

            {"MsgAtkWounded", "Du hast <color=#ff686b>{0}</color> bis zum Tod verwundet."},
            {"MsgVictimWounded", "<color=#ff686b>{0}</color> hat dich bis zum Tod verwundet."},
            {"MsgFeedWounded", "<color=#00ff00>{0}</color> hat <color=#ff686b>{1}</color> erledigt."},

            {"MsgAtkBurned", "Du hast <color=#ff686b>{0}</color> lebendig verbrannt!"},
            {"MsgVictimBurned", "<color=#ff686b>{0}</color> hat dich lebendig verbrannt!"},
            {"MsgFeedBurned", "<color=#00ff00>{0}</color> hat <color=#ff686b>{1}</color> verbrannt!"},

            {"MsgFeedKillBrad", "<color=#ff686b>{0}</color> wurde von einer <color=orange>Schale</color> getötet."},
            {"MsgFeedKillEnt", "<color=#ff686b>{0}</color> wurde von <color=orange>{1}</color> getötet."},
            {"MsgFeedKillAnimal", "<color=#ff686b>{0}</color> wurde von <color=orange>{1}</color> getötet."},

            {"MsgFeedKillSuicide", "<color=#ff686b>{0}</color> beging <color=orange>Suizid</color>."},
            {"MsgFeedKillRadiation", "<color=#ff686b>{0}</color> starb an <color=orange>Strahlung</color>."},
            {"MsgFeedKillFall", "<color=#ff686b>{0}</color> starb durch einen <color=orange>Fall</color>."},
            {"MsgFeedKillCold", "<color=#ff686b>{0}</color> starb an <color=orange>Kälte</color>."},
            {"MsgFeedKillDrowned", "<color=#ff686b>{0}</color> <color=orange>Ertrunken</color>."},
            {"MsgFeedKillHunger", "<color=#ff686b>{0}</color> <color=orange>Hungergestorben</color>."},
            {"MsgFeedKillShock", "<color=#ff686b>{0}</color> wurde <color=orange>elektrisiert</color>."},
            {"MsgFeedKillSentry", "<color=#ff686b>{0}</color> wurde von einem <color=orange>Außenposten</color> getötet."},
            {"MsgFeedKillCactus", "<color=#ff686b>{0}</color> starb an einem <color=orange>Kaktus</color>."},

            {"Enabled", "KillFeed Aktiviert"},
            {"Disabled", "KillFeed Deaktiviert"}
            } , this , "de");
        }

        #endregion

        #region API for other plugins to use the feed

        private void SendKillfeedmessage(string msg)
        {
            _killQueue.OnDeath(null , null , string.Format(_(msg)));
        }

        #endregion

        #region Kill Events

        private void OnKilled(BasePlayer attacker, BasePlayer victim, HitInfo hitInfo, int dist)
        {
            var HitBone = hitInfo.boneArea.ToString();
            if (HitBone == "-1") HitBone = "Body";
            if (IsCar(hitInfo)) dist = 0;

            if (configdata.EnableChatFeed == true)
            {
                if (!_data.DisabledUsers.Contains(attacker.userID))
                    Player.Message(attacker , _("MsgAttacker" , attacker) , null , configdata.IconId , GetClan(victim) + victim.displayName , dist , HitBone);
                if (!_data.DisabledUsers.Contains(victim.userID))
                    Player.Message(victim , _("MsgVictim" , victim) , null , configdata.IconId , GetClan(attacker) + attacker.displayName , dist , GetCustomWeaponName(hitInfo) , HitBone);
            }

            if ((IsZombieHorde(attacker) || attacker.IsNpc) && configdata.EnableNpcFeed)
            {
                var npc = attacker;
                _killQueue.OnDeath(victim, null, string.Format(_("MsgFeedKillNpc"), CustomNpcName(npc), SanitizeName(GetClan(victim) + victim.displayName), GetDistanceColor(dist), dist));
            }
            if ((victim.IsNpc || IsZombieHorde(victim)) && configdata.EnableNpcFeed)
            {
                var npc = victim;
                _killQueue.OnDeath(attacker, null, string.Format(_("MsgFeedKill"), SanitizeName(GetClan(attacker) + attacker.displayName), CustomNpcName(npc), GetCustomWeaponName(hitInfo), HitBone, GetDistanceColor(dist), dist));
            }
            else _killQueue.OnDeath(victim, attacker, string.Format(_("MsgFeedKill"), SanitizeName(GetClan(attacker) + attacker.displayName), SanitizeName(GetClan(victim) + victim.displayName), GetCustomWeaponName(hitInfo), HitBone, GetDistanceColor(dist), dist));

            if (!configdata.EnableLogging) return;
            var sfkLog = new StringBuilder($"{DateTime.Now}: ({attacker.UserIDString}){attacker.displayName} killed ({victim.UserIDString}){victim.displayName} from {dist}m in {HitBone}");
            LogToFile("SimpleKillFeed", sfkLog.ToString(), this);
        }

        private void OnSuicide(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillSuicide") , SanitizeName(GetClan(victim) + victim.displayName)));

        private void OnKilledByRadiation(BasePlayer victim) => _killQueue.OnDeath(victim, null, string.Format(_("MsgFeedKillRadiation"), SanitizeName(GetClan(victim) + victim.displayName)));

        private void OnKilledByEnt(BaseEntity attacker , BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillEnt") , SanitizeName(GetClan(victim) + victim.displayName) , CustomEntName(attacker)));

        private void OnKilledByBradley(BasePlayer victim) => _killQueue.OnDeath(victim, null, string.Format(_("MsgFeedKillBrad"), SanitizeName(GetClan(victim) + victim.displayName)));

        private void OnKilledByAnimal(BaseEntity attacker, BasePlayer victim) => _killQueue.OnDeath(victim, null, string.Format(_("MsgFeedKillAnimal"), SanitizeName(GetClan(victim) + victim.displayName), CustomAnimalName(attacker)));

        private void DeathByFall(BasePlayer victim) => _killQueue.OnDeath(victim, null, string.Format(_("MsgFeedKillFall"), SanitizeName(GetClan(victim) + victim.displayName)));

        private void OnDeathFromWounds(BasePlayer attacker, BasePlayer victim)
        {
            if (configdata.EnableChatFeed)
            {
                if (!_data.DisabledUsers.Contains(attacker.userID) && attacker.userID.IsSteamId())
                    Player.Message(attacker, _("MsgAtkWounded", attacker), null, configdata.IconId, GetClan(victim) + victim.displayName);
                if (!_data.DisabledUsers.Contains(victim.userID))
                    Player.Message(victim, _("MsgVictimWounded", victim), null, configdata.IconId, GetClan(attacker) + attacker.displayName);
            }
            _killQueue.OnDeath(victim, attacker, string.Format(_("MsgFeedWounded"), SanitizeName(GetClan(attacker) + attacker.displayName), SanitizeName(GetClan(victim) + victim.displayName)));

            if (!configdata.EnableLogging) return;
            var sfkLog = new StringBuilder($"{DateTime.Now}: ({attacker.UserIDString}){attacker.displayName} finished ({victim.UserIDString}){victim.displayName}");
            LogToFile("SimpleKillFeed", sfkLog.ToString(), this);
        }

        private void OnBurned(BasePlayer attacker, BasePlayer victim)
        {
            if (victim.IsNpc)
            {
                if (!configdata.EnableNpcFeed) return;
                var npc = victim;
                _killQueue.OnDeath(victim, attacker, string.Format(_("MsgFeedBurned"), SanitizeName(GetClan(attacker) + attacker.displayName), CustomNpcName(npc)));
            }

            if (attacker.IsNpc)
            {
                if (!configdata.EnableNpcFeed) return;
                var npc = attacker;
                _killQueue.OnDeath(victim, attacker, string.Format(_("MsgFeedBurned"), CustomNpcName(npc), SanitizeName(GetClan(victim) + victim.displayName)));
            }
            if (configdata.EnableChatFeed)
            {
                if (!_data.DisabledUsers.Contains(attacker.userID))
                    Player.Message(attacker, _("MsgAtkBurned", attacker), null, configdata.IconId, GetClan(victim) + victim.displayName);
                if (!_data.DisabledUsers.Contains(victim.userID))
                    Player.Message(victim, _("MsgVictimBurned", victim), null, configdata.IconId, GetClan(attacker) + attacker.displayName);
            }
            _killQueue.OnDeath(victim, attacker, string.Format(_("MsgFeedBurned"), SanitizeName(GetClan(attacker) + attacker.displayName), SanitizeName(GetClan(victim) + victim.displayName)));

            if (!configdata.EnableLogging) return;
            var sfkLog = new StringBuilder($"{DateTime.Now}: ({attacker.UserIDString}){attacker.displayName} burned ({victim.UserIDString}){victim.displayName}");
            LogToFile("SimpleKillFeed", sfkLog.ToString(), this);
        }

        private void OnDrowning(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillDrowned") , SanitizeName(GetClan(victim) + victim.displayName)));
        private void OnFrozen(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillCold") , SanitizeName(GetClan(victim) + victim.displayName)));
        private void OnHunger(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillHunger") , SanitizeName(GetClan(victim) + victim.displayName)));
        private void OnShock(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillShock") , SanitizeName(GetClan(victim) + victim.displayName)));
        private void OnSentry(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillSentry") , SanitizeName(GetClan(victim) + victim.displayName)));
        private void OnCactus(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillCactus") , SanitizeName(GetClan(victim) + victim.displayName)));

        #endregion

        #region UI

        private class KillEvent : Pool.IPooled
        {
            public int DisplayUntil;
            public string Text;

            public KillEvent Init(string text, int displayUntil)
            {
                Text = text;
                DisplayUntil = displayUntil;
                return this;
            }

            public void EnterPool()
            {
                Text = null;
                DisplayUntil = 0;
            }

            public void LeavePool() { }
        }

        private class KillQueue : MonoBehaviour
        {
            private readonly WaitForSeconds _secondDelay = new WaitForSeconds(1f);
            private readonly Queue<KillEvent> _queue = new Queue<KillEvent>(configdata.MaxFeedMessages);
            private readonly CuiOutlineComponent _outlineStatic = new CuiOutlineComponent { Distance = configdata.OutlineSize , Color = "0 0 0 1" };
            private readonly CuiRectTransformComponent[] _rectTransformStatic = new CuiRectTransformComponent[configdata.MaxFeedMessages];
            private readonly CuiTextComponent[] _textStatic = new CuiTextComponent[configdata.MaxFeedMessages];
            private readonly CuiElementContainer _cui = new CuiElementContainer();
            private bool _needsRedraw;
            private int _currentlyDrawn;
            private SimpleKillFeed _plugin;

            //add the plugin reference
            public void SetPlugin(SimpleKillFeed plugin)
            {
                _plugin = plugin;
            }


            public void OnDeath(BasePlayer victim , BasePlayer attacker , string text)
            {
                Interface.Call("OnKillFeedMessageReceived" , text);
                if (_queue.Count == configdata.MaxFeedMessages)
                    DequeueEvent(_queue.Dequeue());
                PushEvent(Pool.Get<KillEvent>().Init(text , Epoch.Current + configdata.FeedMessageTtlSec));
            }

            private void PushEvent(KillEvent evt)
            {
                _queue.Enqueue(evt);
                _needsRedraw = true;
                DoProccessQueue();
            }

            private void Start()
            {
                for (var i = 0; i < configdata.MaxFeedMessages; i++)
                {
                    _rectTransformStatic[i] = new CuiRectTransformComponent
                    {
                        AnchorMax =
                            $"{configdata.AnchorMax.Split(Convert.ToChar(' '))[0]} {float.Parse(configdata.AnchorMax.Split(Convert.ToChar(' '))[1]) - (configdata.HeightIdent * i)}" ,
                        AnchorMin =
                            $"{configdata.AnchorMin.Split(Convert.ToChar(' '))[0]} {float.Parse(configdata.AnchorMin.Split(Convert.ToChar(' '))[1]) - (configdata.HeightIdent * i)}"
                    };
                    if (configdata.TextAnchor == "right") _textStatic[i] = new CuiTextComponent { Align = TextAnchor.MiddleRight , FontSize = configdata.FontSize , Text = string.Empty };
                    else if (configdata.TextAnchor == "left") _textStatic[i] = new CuiTextComponent { Align = TextAnchor.MiddleLeft , FontSize = configdata.FontSize , Text = string.Empty };
                    else _textStatic[i] = new CuiTextComponent { Align = TextAnchor.MiddleRight , FontSize = configdata.FontSize , Text = string.Empty };
                }
                StartCoroutine(ProccessQueue());
            }

            private void DequeueEvent(KillEvent evt)
            {
                Pool.Free(ref evt);
                _needsRedraw = true;
            }

            private void DoProccessQueue()
            {
                while (_queue.Count > 0 && _queue.Peek().DisplayUntil < Epoch.Current)
                    DequeueEvent(_queue.Dequeue());

                if (!_needsRedraw)
                    return;
                var toBeRemoved = _currentlyDrawn;
                _currentlyDrawn = 0;
                foreach (var killEvent in _queue)
                {
                    var cuiText = _textStatic[_currentlyDrawn];
                    cuiText.Text = killEvent.Text;
                    _cui.Add(new CuiElement
                    {
                        Name = $"kf-{_currentlyDrawn}" ,
                        Parent = "Under" ,
                        Components =
                        {
                            cuiText,
                            _rectTransformStatic[_currentlyDrawn],
                            _outlineStatic
                        }
                    });
                    if (++_currentlyDrawn == configdata.MaxFeedMessages)
                        break;
                }
                _needsRedraw = false;
                SendKillCui(_cui , toBeRemoved);
                _cui.Clear();
            }

            private IEnumerator ProccessQueue()
            {
                while (!Interface.Oxide.IsShuttingDown)
                {
                    DoProccessQueue();
                    yield return _secondDelay;
                }
            }
            //Updated this method with plugin reference
            private void SendKillCui(CuiElementContainer cui , int toBeRemoved)
            {
                var json = cui.ToJson();
                foreach (var plr in BasePlayer.activePlayerList)
                {
                    // Check for Exclude Permission
                    if (_plugin.permission.UserHasPermission(plr.UserIDString , Exclude_Perm))
                    {
                        // User has the permission, remove existing UI, and skip adding new UI
                        for (var i = toBeRemoved; i > 0; i--)
                            CuiHelper.DestroyUi(plr , $"kf-{i - 1}");
                        continue; // Skip the rest of this loop and go to the next player
                    }

                    //If not excluded remove ui and add ui
                    for (var i = toBeRemoved; i > 0; i--)
                        CuiHelper.DestroyUi(plr , $"kf-{i - 1}");

                    if (!_data.DisabledUsers.Contains(plr.userID))
                        CuiHelper.AddUi(plr , json);

                }
            }

            public static void RemoveKillCui(string name)
            {
                foreach (var plr in BasePlayer.activePlayerList)
                    CuiHelper.DestroyUi(plr , name);
            }
        }
        #endregion

        #region Helpers

        private string _(string msg, BasePlayer player = null) => lang.GetMessage(msg, this, player?.UserIDString);

        private string GetCustomWeaponName(HitInfo hitInfo)
        {
            var name = GetWeaponName(hitInfo);
            if (string.IsNullOrEmpty(name))
                return null;

            string translatedName;
            if (configdata.Weapons.TryGetValue(name, out translatedName))
                return translatedName;

            configdata.Weapons.Add(name, name);
            Config.WriteObject(configdata);
            return name;
        }

        private string CustomNpcName(BasePlayer npc)
        {
            var name = npc.ShortPrefabName;
            if (string.IsNullOrEmpty(name))
                return null;
            if (npc.displayName != npc.userID.ToString())
                return npc.displayName;
            string translatedName;
            if (configdata.Npcs.TryGetValue(name, out translatedName))
                return translatedName;

            configdata.Npcs.Add(name, name);
            Config.WriteObject(configdata);
            return name;
        }

        private string CustomEntName(BaseEntity attacker)
        {
            var name = attacker.ShortPrefabName;
            if (string.IsNullOrEmpty(name))
                return null;
            string translatedName;
            if (configdata.Ents.TryGetValue(name, out translatedName))
                return translatedName;

            configdata.Npcs.Add(name, name);
            Config.WriteObject(configdata);
            return name;
        }

        private string CustomAnimalName(BaseEntity attacker)
        {
            var name = attacker.ShortPrefabName;
            if (string.IsNullOrEmpty(name))
                return null;
            string translatedName;
            if (configdata.Animal.TryGetValue(name, out translatedName))
                return translatedName;

            configdata.Npcs.Add(name, name);
            Config.WriteObject(configdata);
            return name;
        }

        private string GetWeaponName(HitInfo hitInfo)
        {
            var _WeaponName = "??Unknown??";
            if (hitInfo.Weapon == null)
            {
                if (hitInfo.WeaponPrefab.prefabID == 3898309212) _WeaponName = "C4";//3898309212
                if (hitInfo.WeaponPrefab.prefabID == 3046924118) _WeaponName = "Rocket";//3046924118
                if (hitInfo.WeaponPrefab.prefabID == 1217937936) _WeaponName = "HV Rocket";//1217937936
                if (hitInfo.WeaponPrefab.prefabID == 2742759844) _WeaponName = "Satchel";//1217937936
                if (hitInfo.WeaponPrefab.prefabID == 2144399804) _WeaponName = "Beancan";//2144399804
                if (hitInfo.WeaponPrefab.prefabID == 1859672190) _WeaponName = "Shell";//1217937936
                if (hitInfo.WeaponPrefab.prefabID == 1128089209) _WeaponName = "Grenade";//1128089209
                if (hitInfo.WeaponPrefab.prefabID == 3717106868) _WeaponName = "Flamethrower";//3717106868
                if (hitInfo.WeaponPrefab.prefabID == 3032863244) _WeaponName = "Cannon Shell";//3032863244

                if (hitInfo.Initiator is GunTrap) _WeaponName = "GunTrap";
                if (hitInfo.Initiator is FlameTurret) _WeaponName = "FlameTurret";
                if (hitInfo.Initiator is AutoTurret) _WeaponName = "AutoTurret";
                else if (hitInfo.damageTypes.GetMajorityDamageType() == DamageType.Heat) _WeaponName = "Fire";
                else if (hitInfo.damageTypes.GetMajorityDamageType() == DamageType.Fun_Water) _WeaponName = "WaterGun";
                if (hitInfo.WeaponPrefab.ToString().Contains("car_")) _WeaponName = "Car";
                //Puts(hitInfo.WeaponPrefab.prefabID.ToString());
                return _WeaponName;
            }

            if (hitInfo.Weapon != null)
            {
                var _Weapon = hitInfo.Weapon;
                var item = _Weapon.GetItem();
                if (item != null)
                    _WeaponName = item.info.displayName.english;
                if (hitInfo.WeaponPrefab.prefabID == 1233562048) _WeaponName = "Grenade Launcher";
            }
            if (hitInfo.Initiator is GunTrap) _WeaponName = "GunTrap";
            if (hitInfo.Initiator is FlameTurret) _WeaponName = "FlameTurret";
            if (hitInfo.Initiator is AutoTurret) _WeaponName = "AutoTurret";
            if (hitInfo.Initiator is HotAirBalloon) _WeaponName = "Hot Air Balloon";
            if (hitInfo.WeaponPrefab is MLRSRocket) _WeaponName = "MLRS";
            return _WeaponName;
        }

        private static bool IsExplosion(HitInfo hit) => (hit.WeaponPrefab != null && (hit.WeaponPrefab.ShortPrefabName.Contains("grenade") || hit.WeaponPrefab.ShortPrefabName.Contains("explosive")))
                                                        || hit.damageTypes.GetMajorityDamageType() == DamageType.Explosion || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Explosion));

        private static bool IsFlame(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Heat || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Heat));

        private static bool IsRadiation(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Radiation || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Radiation));

        private static bool IsCold(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Cold || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Cold));
        private static bool IsHunger(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Hunger || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Hunger));
        private static bool IsThirst(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Thirst || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Thirst));
        private static bool IsDrowning(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Drowned /* || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Drowned))*/;
        private static bool IsPoison(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Poison || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Poison));
        private static bool IsShock(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.ElectricShock || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.ElectricShock));
        private static bool IsFall(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Fall || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Fall));
        private static bool IsCar(HitInfo hit) => hit.WeaponPrefab.ToString().Contains("car_");

        private static bool IsTrap(BaseEntity ent) => ent != null && configdata.Ents.ContainsKey(ent.ShortPrefabName);

        private static bool IsAnimal(BaseEntity animal) => animal?.ShortPrefabName != null && configdata.Animal.ContainsKey(animal.ShortPrefabName);

        private static bool IsZombieHorde(BasePlayer player) => player.GetType().Name.Equals("ZombieNPC");

        private static string GetDistanceColor(int dist)
        {
            foreach (var distanceColor in configdata.DistanceColors)
            {
                if (distanceColor.TestDistance(dist))
                    return distanceColor.Color;
            }
            return configdata.DefaultDistanceColor ?? "white";
        }

        private string GetClan(BasePlayer player)
        {
            if (_isClansReborn || _isClansIo ||_isClansMevent || Clans == null || BetterChat) return null;
            var clan = (string)Clans.Call("GetClanOf", player.UserIDString);
            if (clan == null) return null;
            var format = string.Format("[" + clan + "] ");
            return format;
        }

        private static string SanitizeName(string name)
        {
            if (name.Length > configdata.MaxPlayerNameLength)
                name = name.Substring(0, configdata.MaxPlayerNameLength).Trim();
            return name.Replace("\"", "''");
        }
        #endregion
    }
}


// --- End of file: SimpleKillFeed.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/super-card ---
// --- Original File Path: S/SuperCard/SuperCard.cs ---

ï»¿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
	[Info("Super Card", "Mevent", "1.0.7")]
	[Description("Open all doors")]
	public class SuperCard : CovalencePlugin
	{
		#region Config

		private Configuration _config;

		private class Configuration
		{
			[JsonProperty(PropertyName = "Command")]
			public string Cmd = "supercard.give";

			[JsonProperty(PropertyName = "Item settings")]
			public ItemConfig Item = new ItemConfig
			{
				DisplayName = "Super Card",
				ShortName = "keycard_red",
				SkinID = 1988408422,
				EnableBreak = true,
				LoseCondition = 1f
			};

			[JsonProperty(PropertyName = "Enable spawn?")]
			public bool EnableSpawn = true;

			[JsonProperty(PropertyName = "Drop Settings", ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<DropInfo> Drop = new List<DropInfo>
			{
				new DropInfo
				{
					PrefabName = "assets/bundled/prefabs/radtown/crate_normal.prefab",
					MinAmount = 1,
					MaxAmount = 1,
					DropChance = 50
				},
				new DropInfo
				{
					PrefabName = "assets/bundled/prefabs/radtown/loot_barrel_2.prefab",
					MinAmount = 1,
					MaxAmount = 1,
					DropChance = 5
				},
				new DropInfo
				{
					PrefabName = "assets/bundled/prefabs/radtown/loot_barrel_1.prefab",
					MinAmount = 1,
					MaxAmount = 1,
					DropChance = 5
				}
			};
			
			[JsonProperty(PropertyName = "Use stacking hooks?")]
			public bool UseStackingHooks = true;
		}

		public class ItemConfig
		{
			[JsonProperty(PropertyName = "DisplayName")]
			public string DisplayName;

			[JsonProperty(PropertyName = "ShortName")]
			public string ShortName;

			[JsonProperty(PropertyName = "SkinID")]
			public ulong SkinID;

			[JsonProperty(PropertyName = "Enable breaking")]
			public bool EnableBreak;

			[JsonProperty(PropertyName = "Breaking the item (1 - standard)")]
			public float LoseCondition;

			public Item ToItem()
			{
				var newItem = ItemManager.CreateByName(ShortName, 1, SkinID);
				if (newItem == null)
				{
					Debug.LogError($"Error creating item with shortName '{ShortName}'!");
					return null;
				}

				if (!string.IsNullOrEmpty(DisplayName)) newItem.name = DisplayName;

				return newItem;
			}

			public bool IsSame(Item item)
			{
				return item != null && item.info.shortname == ShortName && item.skin == SkinID;
			}
		}

		public class DropInfo
		{
			[JsonProperty(PropertyName = "Object prefab name")]
			public string PrefabName;

			[JsonProperty(PropertyName = "Minimum item to drop")]
			public int MinAmount;

			[JsonProperty(PropertyName = "Maximum item to drop")]
			public int MaxAmount;

			[JsonProperty(PropertyName = "Item Drop Chance")]
			public float DropChance;
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				_config = Config.ReadObject<Configuration>();
				if (_config == null) throw new Exception();
				SaveConfig();
			}
			catch
			{
				PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
			}
		}

		protected override void SaveConfig()
		{
			Config.WriteObject(_config);
		}

		protected override void LoadDefaultConfig()
		{
			_config = new Configuration();
		}

		#endregion

		#region Hooks

		private void Init()
		{
			if (!_config.EnableSpawn) Unsubscribe(nameof(OnLootSpawn));

			if (!_config.UseStackingHooks)
			{
				Unsubscribe(nameof(CanCombineDroppedItem));
				Unsubscribe(nameof(CanStackItem));
			}

			AddCovalenceCommand(_config.Cmd, nameof(Cmd));
		}

		private object OnCardSwipe(CardReader cardReader, Keycard keyCard, BasePlayer player)
		{
			if (cardReader == null || keyCard == null || player == null) return null;

			var card = player.GetActiveItem();
			if (card == null || !_config.Item.IsSame(card) || card.conditionNormalized <= 0.0) return null;

			if (cardReader.IsOn()) return true;

			cardReader.Invoke(cardReader.GrantCard, 0.5f);

			if (_config.Item.EnableBreak)
			{
				var origCond = card.condition;

				card.condition -= _config.Item.LoseCondition;

				if (card.condition <= 0f && card.condition < origCond)
					card.OnBroken();
			}

			return true;
		}

		private void OnLootSpawn(LootContainer container)
		{
			if (container == null) return;

			var customItem = _config.Drop.Find(x => x.PrefabName.Contains(container.PrefabName));
			if (customItem == null || !(Random.Range(0f, 100f) <= customItem.DropChance)) return;

			timer.In(0.21f, () =>
			{
				if (container.inventory == null) return;

				var count = Random.Range(customItem.MinAmount, customItem.MaxAmount + 1);

				if (container.inventory.capacity <= container.inventory.itemList.Count)
					container.inventory.capacity = container.inventory.itemList.Count + count;

				for (var i = 0; i < count; i++)
				{
					var item = _config?.Item?.ToItem();
					if (item == null) break;

					item.MoveToContainer(container.inventory);
				}
			});
		}

		#region Split

		private object CanCombineDroppedItem(DroppedItem droppedItem, DroppedItem targetItem)
		{
			if (droppedItem == null || targetItem == null) return null;

			var item = droppedItem.GetItem();
			if (item == null) return null;

			var tItem = targetItem.GetItem();
			if (tItem == null || item.skin == tItem.skin) return null;

			return _config.Item.IsSame(item) || _config.Item.IsSame(tItem);
		}

		private object CanStackItem(Item item, Item targetItem)
		{
			if (item == null || targetItem == null || item.skin == targetItem.skin) return null;

			return item.info.shortname == targetItem.info.shortname &&
			       (item.skin == _config.Item.SkinID || targetItem.skin == _config.Item.SkinID) &&
			       item.skin == targetItem.skin
				? (object) (item.amount + targetItem.amount < item.info.stackable)
				: null;
		}

		#endregion

		#endregion

		#region Commands

		private void Cmd(IPlayer player, string command, string[] args)
		{
			if (!player.IsAdmin)
			{
				Reply(player, NoPermission);
				return;
			}

			if (args.Length == 0)
			{
				Reply(player, Syntax, _config.Cmd);
				return;
			}

			var target = players.FindPlayer(args[0])?.Object as BasePlayer;
			if (target == null)
			{
				Reply(player, NotFound, args[0]);
				return;
			}

			var item = _config?.Item?.ToItem();
			if (item == null) return;

			target.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
		}

		#endregion

		#region Lang

		private const string
			NotFound = "NotFound",
			Syntax = "Syntax",
			NoPermission = "NoPermission";


		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				[NotFound] = "We can't find player with that name/ID! {0}",
				[Syntax] = "Syntax: /{0} name/steamid",
				[NoPermission] = "You don't have permission to use this command!"
			}, this);
		}

		private void Reply(IPlayer player, string key, params object[] obj)
		{
			player.Reply(string.Format(lang.GetMessage(key, this, player.Id), obj));
		}

		#endregion
	}
}

// --- End of file: SuperCard.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/show-crosshair ---
// --- Original File Path: S/ShowCrosshair/ShowCrosshair.cs ---

// Requires: ImageLibrary

using System;
using System.Collections.Generic;
using System.Globalization;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Show Crosshair", "Marat", "1.0.79")]
    [Description("Shows a crosshair on the screen")]
    class ShowCrosshair : RustPlugin
    {
        private List<string> WeaponList = new List<string>();
        private Hash<ulong, Timer> popupMessages = new Hash<ulong, Timer>();
        static bool uiFadeIn;
        private bool isILReady;
        readonly Dictionary<string, string> lastCrosshair = new Dictionary<string, string>();
        readonly Dictionary<string, bool> enabled = new Dictionary<string, bool>();
        readonly Dictionary<string, bool> opened = new Dictionary<string, bool>();

        List<ulong> Cross = new List<ulong>();
        List<ulong> Menu = new List<ulong>();
        bool EnableCross(BasePlayer player) => Cross.Contains(player.userID);
        bool EnableMenu(BasePlayer player) => Menu.Contains(player.userID);

        #region Initialization

        private bool configChanged;
        private const string permShowCrosshair = "showcrosshair.allowed";

        private string GetImage(string name, ulong skin = 0)
        {
            string imageId = ImageLibrary.GetImage(name, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return string.Empty;
        }

        private void Init()
        {
            LoadConfiguration();
            permission.RegisterPermission(permShowCrosshair, this);
            cmd.AddChatCommand(commandmenu, this, "cmdChatShowMenu");
        }

        void OnServerInitialized()
        {
            ValidateImages();
        }

        void ValidateImages()
        {
            Puts("[Warning] Validating imagery");
            if (!ImageLibrary.HasImage("crosshair9", 0))
            {
                LoadImages();
            }
            Puts("[Warning] Images loading validate sucsessefull");
            isILReady = true;
        }

        private void LoadImages()
        {
            if (!ImageLibrary.IsReady())
            {
                timer.In(10, () => LoadImages());
                Puts("[Warning] Waiting for Image Library to finish processing images");
                return;
            }
            ImageLibrary.AddImage(image1, "crosshair1", 0);
            ImageLibrary.AddImage(image2, "crosshair2", 0);
            ImageLibrary.AddImage(image3, "crosshair3", 0);
            ImageLibrary.AddImage(image4, "crosshair4", 0);
            ImageLibrary.AddImage(image5, "crosshair5", 0);
            ImageLibrary.AddImage(image6, "crosshair6", 0);
            ImageLibrary.AddImage(image7, "crosshair7", 0);
            ImageLibrary.AddImage(image8, "crosshair8", 0);
            ImageLibrary.AddImage(background, "background", 0);
            ImageLibrary.AddImage(background2, "background2", 0);
            isILReady = true;
            Puts("Crosshair images loaded");
        }

        #endregion

        #region Configuration

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created.");
            Config.Clear();
        }

        [PluginReference]
        ImageLibrary ImageLibrary;

        private bool usePermissions = false;
        private bool ShowOnLogin = false;
        private bool HideWhenAiming = false;
        private bool EnableSound = true;
        private bool ShowMessage = true;
        private string SoundOpen = "assets/bundled/prefabs/fx/build/promote_metal.prefab";
        private string SoundDisable = "assets/prefabs/locks/keypad/effects/lock.code.lock.prefab";
        private string SoundSelect = "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab";
        private string SoundToggle = "assets/prefabs/misc/xmas/presents/effects/unwrap.prefab";
        private string commandmenu = "crosshair";
        private string colorClose = "0 0 0 0.7";
        private string colorBackground = "0 0 0 0.7";
        private string colorToggle = "0 0 0 0.7";
        private string colorDisable = "0 0 0 0.7";
        private string image1 = "https://image.ibb.co/jC4Fe7/image1.png";
        private string image2 = "https://image.ibb.co/k0zFe7/image2.png";
        private string image3 = "https://image.ibb.co/fjP3XS/image3.png";
        private string image4 = "https://image.ibb.co/erAcsS/image4.png";
        private string image5 = "https://image.ibb.co/fufcsS/image5.png";
        private string image6 = "https://image.ibb.co/cxymmn/image6.png";
        private string image7 = "https://image.ibb.co/j271K7/image7.png";
        private string image8 = "https://image.ibb.co/dko8z7/image8.png";
        private string background = "https://image.ibb.co/fNyDXS/background.png";
        private string background2 = "https://image.ibb.co/g8eRmn/background2.png";

        private void LoadConfiguration()
        {
            commandmenu = GetConfig("Options", "CommandMenu", commandmenu);
            ShowMessage = GetConfig("Options", "ShowMessage", ShowMessage);
            ShowOnLogin = GetConfig("Options", "ShowOnLogin", ShowOnLogin);
            HideWhenAiming = GetConfig("Options", "HideWhenAiming", HideWhenAiming);
            EnableSound = GetConfig("Options", "EnableSound", EnableSound);
            usePermissions = GetConfig("Options", "UsePermissions", usePermissions);

            SoundOpen = GetConfig("Sound", "SoundOpen", SoundOpen);
            SoundDisable = GetConfig("Sound", "SoundDisable", SoundDisable);
            SoundSelect = GetConfig("Sound", "SoundSelect", SoundSelect);
            SoundToggle = GetConfig("Sound", "SoundToggle", SoundToggle);

            colorClose = GetConfig("Color", "ColorButtonClose", colorClose);
            colorToggle = GetConfig("Color", "ColorButtonToggle", colorToggle);
            colorDisable = GetConfig("Color", "ColorButtonDisable", colorDisable);
            colorBackground = GetConfig("Color", "ColorBackground", colorBackground);

            image1 = GetConfig("Image", "crosshair1", image1);
            image2 = GetConfig("Image", "crosshair2", image2);
            image3 = GetConfig("Image", "crosshair3", image3);
            image4 = GetConfig("Image", "crosshair4", image4);
            image5 = GetConfig("Image", "crosshair5", image5);
            image6 = GetConfig("Image", "crosshair6", image6);
            image7 = GetConfig("Image", "crosshair7", image7);
            image8 = GetConfig("Image", "crosshair8", image8);

            background = GetConfig("Image", "background", background);
            background2 = GetConfig("Image", "background2", background2);

            List<object> weaponList = new List<object>()
            { 
                    "Eoka Pistol",
                    "Custom SMG",
                    "Assault Rifle",
                    "Bolt Action Rifle",
                    "Waterpipe Shotgun",
                    "Revolver",
                    "Thompson",
                    "Semi-Automatic Rifle",
                    "Semi-Automatic Pistol",
                    "Pump Shotgun",
                    "M249",
                    "Flame Thrower",
                    "Double Barrel Shotgun",
                    "MP5A4",
                    "LR-300 Assault Rifle",
                    "M92 Pistol",
                    "Python Revolver",
                    "Crossbow"
            };
            weaponList = GetConfig("Options", "List of weapons with disabled crosshair while aiming", weaponList);
            foreach (var item in weaponList)
            {
                WeaponList.Add(item.ToString());
            }

            if (!configChanged) return;
            PrintWarning("Configuration file updated.");
            SaveConfig();
        }
       
        private T GetConfig<T>(string category, string setting, T defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }
            if (data.TryGetValue(setting, out value)) return (T)Convert.ChangeType(value, typeof(T));
            value = defaultValue;
            data[setting] = value;
            configChanged = true;
            return (T)Convert.ChangeType(value, typeof(T));
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            //English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You don't have permission to use this command.",
                ["imWait"] = "You must wait until ImageLibrary has finished processing its images",
                ["Enabled"] = "You have enabled the crosshair.",
                ["Disabled"] = "You have disabled the crosshair.",
                ["crosshair1"] = "You set the crosshair â1.",
                ["crosshair2"] = "You set the crosshair â2.",
                ["crosshair3"] = "You set the crosshair â3.",
                ["crosshair4"] = "You set the crosshair â4.",
                ["crosshair5"] = "You set the crosshair â5.",
                ["crosshair6"] = "You set the crosshair â6.",
                ["crosshair7"] = "You set the crosshair â7.",
                ["crosshair8"] = "You set the crosshair â8.",
                ["close"] = "<color=#ff0000>C</color><color=#ff1a1a>l</color><color=#ff3333>o</color><color=#ff1a1a>s</color><color=#ff0000>e</color>",
                ["select"] = "<color=#46d100>S</color><color=#52f500>e</color><color=#66ff1a>l</color><color=#52f500>e</color><color=#46d100>c</color><color=#3aad00>t</color>",
                ["disable"] = "<color=#fbff00>D</color><color=#fbff1a>i</color><color=#fcff33>s</color><color=#fcff4d>a</color><color=#fcff33>b</color><color=#fbff1a>l</color><color=#fbff00>e</color>",
                ["next"] = "<color=#0055ff>N</color><color=#1a66ff>e</color><color=#1a66ff>x</color><color=#0055ff>t</color>",
                ["back"] = "<color=#0055ff>B</color><color=#1a66ff>a</color><color=#1a66ff>c</color><color=#0055ff>k</color>"
            }, this);
        }

        #endregion

        #region Commands

        ////ShowMenu////
        private void cmdChatShowMenu(BasePlayer player)
        {
            if (usePermissions && !IsAllowed(player.UserIDString, permShowCrosshair))
            {
                Reply(player, Lang("NoPermission", player.UserIDString));
                return;
            }
            if (!isILReady)
            {
                SendReply(player, "", Lang("imWait", player.UserIDString));
                return;
            }
            if (EnableMenu(player))
            {
                DisabledMenu(player);
            }
            else
            {
                EnabledMenu(player);
                if (EnableSound) Effect.server.Run(SoundOpen, player.transform.position, Vector3.zero, null, false);
            }
        }

        [ConsoleCommand("crosshair")]
        private void cmdConsoleShowMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!isILReady)
            {
                SendReply(player, "", Lang("imWait", player.UserIDString));
                return;
            }
            cmdChatShowMenu(player);
        }

        [ConsoleCommand("loadcrosshairimages")]
        private void cmdRefreshAllImages(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                PrintWarning("Reloading all images crosshair!");
                LoadImages();
            }
        }

        ////CloseMenu////
        [ConsoleCommand("CloseMenu")]
        void cmdConsoleCloseMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            DisabledMenu(player);
        }
        ////Commands////
        [ConsoleCommand("command1")]
        void cmdConsoleCommand1(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            DestroyCrosshair(player);
            Crosshair1(player);
            if (EnableSound) Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
            if (ShowMessage) OnScreen(player, Lang("crosshair1", player.UserIDString));//Reply(player, Lang("crosshair1", player.UserIDString));
        }
        [ConsoleCommand("command2")]
        void cmdConsoleCommand2(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            DestroyCrosshair(player);
            Crosshair2(player);
            if (EnableSound) Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
            if (ShowMessage) OnScreen(player, Lang("crosshair2", player.UserIDString));//Reply(player, Lang("crosshair2", player.UserIDString));
        }
        [ConsoleCommand("command3")]
        void cmdConsoleCommand3(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            DestroyCrosshair(player);
            Crosshair3(player);
            if (EnableSound) Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
            if (ShowMessage) OnScreen(player, Lang("crosshair3", player.UserIDString));//Reply(player, Lang("crosshair3", player.UserIDString));
        }
        [ConsoleCommand("command4")]
        void cmdConsoleCommand4(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            DestroyCrosshair(player);
            Crosshair4(player);
            if (EnableSound) Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
            if (ShowMessage) OnScreen(player, Lang("crosshair4", player.UserIDString));//Reply(player, Lang("crosshair4", player.UserIDString));
        }
        [ConsoleCommand("command5")]
        void cmdConsoleCommand5(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            DestroyCrosshair(player);
            Crosshair5(player);
            if (EnableSound) Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
            if (ShowMessage) OnScreen(player, Lang("crosshair5", player.UserIDString));//Reply(player, Lang("crosshair5", player.UserIDString));
        }
        [ConsoleCommand("command6")]
        void cmdConsoleCommand6(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            DestroyCrosshair(player);
            Crosshair6(player);
            if (EnableSound) Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
            if (ShowMessage) OnScreen(player, Lang("crosshair6", player.UserIDString));//Reply(player, Lang("crosshair6", player.UserIDString));
        }
        [ConsoleCommand("command7")]
        void cmdConsoleCommand7(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            DestroyCrosshair(player);
            Crosshair7(player);
            if (EnableSound) Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
            if (ShowMessage) OnScreen(player, Lang("crosshair7", player.UserIDString));//Reply(player, Lang("crosshair7", player.UserIDString));
        }
        [ConsoleCommand("command8")]
        void cmdConsoleCommand8(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            DestroyCrosshair(player);
            Crosshair8(player);
            if (EnableSound) Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
            if (ShowMessage) OnScreen(player, Lang("crosshair8", player.UserIDString));//Reply(player, Lang("crosshair8", player.UserIDString));
        }
        [ConsoleCommand("commandNext")]
        void cmdConsoleCommandNext(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            DestroyGUImenu(player);
            var panel = Convert.ToInt16(arg.Args[0]);
            if (panel == 1)
                ShowMenu(player, null);
            else 
                NextMenu2(player, null);
            //else if (panel == 3)
            //    NextMenu3(player, null);
            if (EnableSound) Effect.server.Run(SoundToggle, player.transform.position, Vector3.zero, null, false);
        }
        [ConsoleCommand("commandBack")]
        void cmdConsoleCommandBack(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            DestroyGUImenu(player);

            var panel = Convert.ToInt16(arg.Args[0]);
            if (panel == 1)
                ShowMenu(player, null);
            else 
                NextMenu2(player, null);
            //else if (panel == 3)
            //    NextMenu3(player, null);
            if (EnableSound) Effect.server.Run(SoundToggle, player.transform.position, Vector3.zero, null, false);
        }
        [ConsoleCommand("commandDisable")]
        void cmdConsoleCommandDisable(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            DestroyCrosshair(player);
            if (EnableSound) Effect.server.Run(SoundDisable, player.transform.position, Vector3.zero, null, false);
            enabled[player.UserIDString] = false;
            lastCrosshair.Remove(player.UserIDString);
            if (ShowMessage) OnScreen(player, Lang("Disabled", player.UserIDString));//Reply(player, Lang("Disabled", player.UserIDString));
        }

        #endregion

        #region Hooks

        private void OnPlayerInit(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2, () => OnPlayerInit(player));
                return;
            }
            if (usePermissions && !IsAllowed(player.UserIDString, permShowCrosshair))
            {
                return;
            }
            if (ShowOnLogin)
            {
                EnabledCrosshair(player);
            }
        }
        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (Menu.Contains(player.userID))
            {
                Menu.Remove(player.userID);
                DestroyAll(player);
                return;
            }
        }
        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                Menu.Remove(player.userID);
                DestroyAll(player);
                return;
            }
        }
        private void DestroyAll(BasePlayer player)
        {
            DestroyGUImenu(player);
            DestroyCrosshair(player);
        }
        private void DestroyCrosshair(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "image1");
            CuiHelper.DestroyUi(player, "image2");
            CuiHelper.DestroyUi(player, "image3");
            CuiHelper.DestroyUi(player, "image4");
            CuiHelper.DestroyUi(player, "image5");
            CuiHelper.DestroyUi(player, "image6");
            CuiHelper.DestroyUi(player, "image7");
            CuiHelper.DestroyUi(player, "image8");
        }
        private void DestroyGUImenu(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "GUImenu");
            CuiHelper.DestroyUi(player, "GUImenu2");
            CuiHelper.DestroyUi(player, "GUImenu3");
        }

        private void EnabledCrosshair(BasePlayer player)
        {
            if (!Cross.Contains(player.userID))
            {
                Cross.Add(player.userID);
                DestroyCrosshair(player);
                player.SendConsoleCommand("command1");
            }
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (player.GetActiveItem() != null)
                if (input.IsDown(BUTTON.FIRE_SECONDARY) && WeaponList.Contains(player.GetActiveItem().info.displayName.english) && HideWhenAiming)
                {
                    opened[player.UserIDString] = false;
                    DestroyCrosshair(player);
                }
                else
                {
                    if (enabled.ContainsKey(player.UserIDString) && enabled[player.UserIDString] == true)
                    {
                        if (opened.ContainsKey(player.UserIDString) && opened[player.UserIDString] == false)
                        {
                            opened[player.UserIDString] = true;
                            if (lastCrosshair[player.UserIDString] == "crosshair1") Crosshair1(player);
                            else if (lastCrosshair[player.UserIDString] == "crosshair2") Crosshair2(player);
                            else if (lastCrosshair[player.UserIDString] == "crosshair3") Crosshair3(player);
                            else if (lastCrosshair[player.UserIDString] == "crosshair4") Crosshair4(player);
                            else if (lastCrosshair[player.UserIDString] == "crosshair5") Crosshair5(player);
                            else if (lastCrosshair[player.UserIDString] == "crosshair6") Crosshair6(player);
                            else if (lastCrosshair[player.UserIDString] == "crosshair7") Crosshair7(player);
                            else if (lastCrosshair[player.UserIDString] == "crosshair8") Crosshair8(player);
                        }
                    }
                }
        }

        private void DisabledCrosshair(BasePlayer player)
        {
            if (Cross.Contains(player.userID))
            {
                Cross.Remove(player.userID);
                player.SendConsoleCommand("commandDisable");
            }
        }
        private void EnabledMenu(BasePlayer player)
        {
            if (!Menu.Contains(player.userID))
            {
                Menu.Add(player.userID);
                DestroyGUImenu(player);
                ShowMenu(player, null);
            }
        }
        private void DisabledMenu(BasePlayer player)
        {
            if (Menu.Contains(player.userID))
            {
                Menu.Remove(player.userID);
                DestroyGUImenu(player);
            }
        }

        #endregion

        #region Crosshair

        private void PopupMessage(BasePlayer player, string msg)
        {
            var element = UI.CreateElementContainer(UIPopup, UI.Color("#2a2a2a", 0.98f), "0.33 0.45", "0.67 0.6");
            UI.CreatePanel(ref element, UIPopup, UI.Color("#696969", 0.4f), "0.01 0.04", "0.99 0.96");
            UI.CreateLabel(ref element, UIPopup, $"{UI.Color("#2a2a2a", 0.9f)}{msg}</color>", 22, "0 0", "1 1");

            if (popupMessages.ContainsKey(player.userID))
            {
                CuiHelper.DestroyUi(player, UIPopup);
                popupMessages[player.userID].Destroy();
                popupMessages.Remove(player.userID);
            }
            CuiHelper.AddUi(player, element);
            popupMessages.Add(player.userID, timer.In(3.5f, () =>
            {
                CuiHelper.DestroyUi(player, UIPopup);
                popupMessages.Remove(player.userID);
            }));
        }

        private Dictionary<string, Timer> timers = new Dictionary<string, Timer>();
        void OnScreen(BasePlayer player, string msg)
        {
            if (timers.ContainsKey(player.userID.ToString()))
            {
                timers[player.userID.ToString()].Destroy();
                timers.Remove(player.userID.ToString());
            }
            CuiHelper.DestroyUi(player, PanelOnScreen);
            var element = UI.CreateElementContainer(PanelOnScreen, "0.0 0.0 0.0 0.0", "0.15 0.65", "0.85 .85", false);
            UI.CreateTextOutline(ref element, PanelOnScreen, UIColors["black"], UIColors["white"], msg, 24, "0.0 0.0", "1.0 1.0");
            CuiHelper.AddUi(player, element);
            timers.Add(player.userID.ToString(), timer.Once(3, () => CuiHelper.DestroyUi(player, PanelOnScreen)));
        }


        private void Crosshair1(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIHud1);
            var elements = UI.CreateElementContainer(UIHud1, "1 1 1 0.0", "0.490 0.4812", "0.509 0.517", false);
            var image = GetImage("crosshair1", 0);
            UI.LoadImage(ref elements, UIHud1, image, "0 0", "1 1");

            if (lastCrosshair.ContainsKey(player.UserIDString)) lastCrosshair.Remove(player.UserIDString);
            if (enabled.ContainsKey(player.UserIDString)) enabled.Remove(player.UserIDString);
            lastCrosshair.Add(player.UserIDString, "crosshair1");
            enabled.Add(player.UserIDString, true);
            CuiHelper.AddUi(player, elements);
        }

        private void Crosshair2(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "image2");
            var elements = UI.CreateElementContainer("image2", "1 1 1 0.0", "0.490 0.4812", "0.509 0.517", false);
            var image = GetImage("crosshair2", 0);
            UI.LoadImage(ref elements, "image2", image, "0 0", "1 1");

            if (lastCrosshair.ContainsKey(player.UserIDString)) lastCrosshair.Remove(player.UserIDString);
            if (enabled.ContainsKey(player.UserIDString)) enabled.Remove(player.UserIDString);
            lastCrosshair.Add(player.UserIDString, "crosshair2");
            enabled.Add(player.UserIDString, true);
            CuiHelper.AddUi(player, elements);
        }

        private void Crosshair3(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "image3");
            var elements = UI.CreateElementContainer("image3", "1 1 1 0.0", "0.490 0.4812", "0.509 0.517", false);
            var image = GetImage("crosshair3", 0);
            UI.LoadImage(ref elements, "image3", image, "0 0", "1 1");

            if (lastCrosshair.ContainsKey(player.UserIDString)) lastCrosshair.Remove(player.UserIDString);
            if (enabled.ContainsKey(player.UserIDString)) enabled.Remove(player.UserIDString);
            lastCrosshair.Add(player.UserIDString, "crosshair3");
            enabled.Add(player.UserIDString, true);
            CuiHelper.AddUi(player, elements);
        }

        private void Crosshair4(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "image4");
            var elements = UI.CreateElementContainer("image4", "1 1 1 0.0", "0.490 0.4812", "0.509 0.517", false);
            var image = GetImage("crosshair4", 0);
            UI.LoadImage(ref elements, "image4", image, "0 0", "1 1");

            if (lastCrosshair.ContainsKey(player.UserIDString)) lastCrosshair.Remove(player.UserIDString);
            if (enabled.ContainsKey(player.UserIDString)) enabled.Remove(player.UserIDString);
            lastCrosshair.Add(player.UserIDString, "crosshair4");
            enabled.Add(player.UserIDString, true);
            CuiHelper.AddUi(player, elements);
        }

        private void Crosshair5(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "image5");
            var elements = UI.CreateElementContainer("image5", "1 1 1 0.0", "0.490 0.4812", "0.509 0.517", false);
            var image = GetImage("crosshair5", 0);
            UI.LoadImage(ref elements, "image5", image, "0 0", "1 1");

            if (lastCrosshair.ContainsKey(player.UserIDString)) lastCrosshair.Remove(player.UserIDString);
            if (enabled.ContainsKey(player.UserIDString)) enabled.Remove(player.UserIDString);
            lastCrosshair.Add(player.UserIDString, "crosshair5");
            enabled.Add(player.UserIDString, true);
            CuiHelper.AddUi(player, elements);
        }

        private void Crosshair6(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "image6");
            var elements = UI.CreateElementContainer("image6", "1 1 1 0.0", "0.490 0.4812", "0.509 0.517", false);
            var image = GetImage("crosshair6", 0);
            UI.LoadImage(ref elements, "image6", image, "0 0", "1 1");

            if (lastCrosshair.ContainsKey(player.UserIDString)) lastCrosshair.Remove(player.UserIDString);
            if (enabled.ContainsKey(player.UserIDString)) enabled.Remove(player.UserIDString);
            lastCrosshair.Add(player.UserIDString, "crosshair6");
            enabled.Add(player.UserIDString, true);
            CuiHelper.AddUi(player, elements);
        }

        private void Crosshair7(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "image7");
            var elements = UI.CreateElementContainer("image7", "1 1 1 0.0", "0.490 0.4812", "0.509 0.517", false);
            var image = GetImage("crosshair7", 0);
            UI.LoadImage(ref elements, "image7", image, "0 0", "1 1");

            if (lastCrosshair.ContainsKey(player.UserIDString)) lastCrosshair.Remove(player.UserIDString);
            if (enabled.ContainsKey(player.UserIDString)) enabled.Remove(player.UserIDString);
            lastCrosshair.Add(player.UserIDString, "crosshair7");
            enabled.Add(player.UserIDString, true);
            CuiHelper.AddUi(player, elements);
        }

        private void Crosshair8(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "image8");
            var elements = UI.CreateElementContainer("image8", "1 1 1 0.0", "0.490 0.4812", "0.509 0.517", false);
            var image = GetImage("crosshair8", 0);
            UI.LoadImage(ref elements, "image8", image, "0 0", "1 1");

            if (lastCrosshair.ContainsKey(player.UserIDString)) lastCrosshair.Remove(player.UserIDString);
            if (enabled.ContainsKey(player.UserIDString)) enabled.Remove(player.UserIDString);
            lastCrosshair.Add(player.UserIDString, "crosshair8");
            enabled.Add(player.UserIDString, true);
            CuiHelper.AddUi(player, elements);
        }

        #endregion

        #region GuiMenu

        /////////////////Menu1/////////////////////

        private void ShowMenu(BasePlayer player, string text)
        {
            var elements = UI.CreateElementContainer("GUImenu", "0 0 0 0", "0.2395 0.18", "0.761 0.4525", true);
            UI.CreatePanel(ref elements, "GUImenu", colorBackground, "0 0.18", "1 1", 0.6f, true);

            ////////////MainBackground////////////////
            UI.LoadImage(ref elements, "GUImenu", GetImage("background2", 0), "0 0", "1 1");

            UI.CreateButton(ref elements, "GUImenu", colorClose, Lang("close", player.UserIDString), 18, "0.402 0", "0.596 0.18", $"CloseMenu", TextAnchor.MiddleCenter, 0.6f);

            ////////////////background///////////////
            //background1
            UI.LoadImage(ref elements, "GUImenu", GetImage("background", 0), $"0.030 0.28", $"0.240 0.9");
            //background2
            UI.LoadImage(ref elements, "GUImenu", GetImage("background", 0), $"0.262 0.28", $"0.486 0.9");
            //background3
            UI.LoadImage(ref elements, "GUImenu", GetImage("background", 0), $"0.505 0.28", $"0.730 0.9");
            //background4
            UI.LoadImage(ref elements, "GUImenu", GetImage("background", 0), $"0.750 0.28", $"0.97 0.9");

            ////////////////image////////////////
            //image1
            UI.LoadImage(ref elements, "GUImenu", GetImage("crosshair1", 0), $"0.100 0.530", $"0.150 0.680");
            //image2
            UI.LoadImage(ref elements, "GUImenu", GetImage("crosshair2", 0), $"0.352 0.530", $"0.396 0.680");
            //image3
            UI.LoadImage(ref elements, "GUImenu", GetImage("crosshair3", 0), $"0.585 0.530", $"0.655 0.680");
            //image4
            UI.LoadImage(ref elements, "GUImenu", GetImage("crosshair4", 0), $"0.815 0.530", $"0.895 0.680");

            /////////////button///////////////////
            //button1
            UI.CreateButton(ref elements, "GUImenu", "0 0 0 0", Lang("select", player.UserIDString), 20, $"0.0445 0.320", $"0.206 0.85", $"command1", TextAnchor.LowerCenter, 0.6f);
            //button2
            UI.CreateButton(ref elements, "GUImenu", "0 0 0 0", Lang("select", player.UserIDString), 20, $"0.282 0.320", $"0.476 0.85", $"command2", TextAnchor.LowerCenter, 0.6f);
            //button3
            UI.CreateButton(ref elements, "GUImenu", "0 0 0 0", Lang("select", player.UserIDString), 20, $"0.523 0.320", $"0.715 0.85", $"command3", TextAnchor.LowerCenter, 0.6f);
            //button4
            UI.CreateButton(ref elements, "GUImenu", "0 0 0 0", Lang("select", player.UserIDString), 20, $"0.762 0.320", $"0.954 0.85", $"command4", TextAnchor.LowerCenter, 0.6f);

            //buttonDisable
            UI.CreateButton(ref elements, "GUImenu", colorDisable, Lang("disable", player.UserIDString), 18, "0 0", "0.192 0.18", $"commandDisable", TextAnchor.MiddleCenter, 0.6f);
            //buttonNext
            UI.CreateButton(ref elements, "GUImenu", colorToggle, Lang("next", player.UserIDString), 18, "0.805 0", "1 0.18", $"commandNext 2", TextAnchor.MiddleCenter, 0.6f);

            CuiHelper.AddUi(player, elements);
        }

        /////////////////Menu2/////////////////////

        private void NextMenu2(BasePlayer player, string text)
        {
            var elements = UI.CreateElementContainer("GUImenu2", "0 0 0 0", "0.2395 0.18", "0.761 0.4525", true);
            UI.CreatePanel(ref elements, "GUImenu2", colorBackground, "0 0.18", "1 1", 0.6f, true);

            ////////////MainBackground////////////////
            UI.LoadImage(ref elements, "GUImenu2", GetImage("background2", 0), "0 0", "1 1");

            UI.CreateButton(ref elements, "GUImenu2", colorClose, Lang("close", player.UserIDString), 18, "0.402 0", "0.596 0.18", $"CloseMenu", TextAnchor.MiddleCenter, 0.6f);

            ////////////////background///////////////
            //background1
            UI.LoadImage(ref elements, "GUImenu2", GetImage("background", 0), $"0.030 0.28", $"0.240 0.9");
            //background2
            UI.LoadImage(ref elements, "GUImenu2", GetImage("background", 0), $"0.262 0.28", $"0.486 0.9");
            //background3
            UI.LoadImage(ref elements, "GUImenu2", GetImage("background", 0), $"0.505 0.28", $"0.730 0.9");
            //background4
            UI.LoadImage(ref elements, "GUImenu2", GetImage("background", 0), $"0.750 0.28", $"0.97 0.9");

            ////////////////image////////////////
            //image5
            UI.LoadImage(ref elements, "GUImenu2", GetImage("crosshair5", 0), $"0.100 0.530", $"0.150 0.680");
            //image6
            UI.LoadImage(ref elements, "GUImenu2", GetImage("crosshair6", 0), $"0.352 0.530", $"0.396 0.680");
            //image7
            UI.LoadImage(ref elements, "GUImenu2", GetImage("crosshair7", 0), $"0.585 0.530", $"0.655 0.680");
            //image8
            UI.LoadImage(ref elements, "GUImenu2", GetImage("crosshair8", 0), $"0.825 0.530", $"0.885 0.680");

            /////////////button///////////////////
            //button5
            UI.CreateButton(ref elements, "GUImenu2", "0 0 0 0", Lang("select", player.UserIDString), 20, $"0.0445 0.320", $"0.206 0.85", $"command5", TextAnchor.LowerCenter, 0.6f);
            //button6
            UI.CreateButton(ref elements, "GUImenu2", "0 0 0 0", Lang("select", player.UserIDString), 20, $"0.282 0.320", $"0.476 0.85", $"command6", TextAnchor.LowerCenter, 0.6f);
            //button7
            UI.CreateButton(ref elements, "GUImenu2", "0 0 0 0", Lang("select", player.UserIDString), 20, $"0.523 0.320", $"0.715 0.85", $"command7", TextAnchor.LowerCenter, 0.6f);
            //button8
            UI.CreateButton(ref elements, "GUImenu2", "0 0 0 0", Lang("select", player.UserIDString), 20, $"0.762 0.320", $"0.954 0.85", $"command8", TextAnchor.LowerCenter, 0.6f);

            //buttonDisable
            UI.CreateButton(ref elements, "GUImenu2", colorDisable, Lang("disable", player.UserIDString), 18, "0 0", "0.192 0.18", $"commandDisable", TextAnchor.MiddleCenter, 0.6f);
            //buttonBack
            UI.CreateButton(ref elements, "GUImenu2", colorToggle, Lang("back", player.UserIDString), 18, "0.805 0", "1 0.18", $"commandBack 1", TextAnchor.MiddleCenter, 0.6f);
            CuiHelper.AddUi(player, elements);
        }

        #endregion

        #region UI
        private string PanelOnScreen = "PanelOnScreen";
        string UIHud1 = "image1";
        const string UIPopup = "Popup";

        class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent = "Hud",
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, float fadein = 1.0f, bool cursor = false)
            {
                if (uiFadeIn)
                    fadein = 0;
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel, CuiHelper.GetGuid());
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, string color = null, float fadein = 1.0f)
            {
                if (uiFadeIn)
                    fadein = 0;
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel, CuiHelper.GetGuid());

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                if (uiFadeIn)
                    fadein = 0;
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = fadein },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel, CuiHelper.GetGuid());
            }
            static public void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }

            static public void CreateTextOutline(ref CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiTextComponent{Color = colorText, FontSize = size, Align = align, Text = text },
                        new CuiOutlineComponent {Distance = "1 1", Color = colorOutline},
                        new CuiRectTransformComponent {AnchorMax = aMax, AnchorMin = aMin }
                    }
                });
            }

            static public string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }

        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"black", "0 0 0 1.0" },
            {"dark", "0.1 0.1 0.1 0.98" },
            {"header", "1 1 1 0.3" },
            {"light", ".564 .564 .564 1.0" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"brown", "0.3 0.16 0.0 1.0" },
            {"yellow", "0.9 0.9 0.0 1.0" },
            {"orange", "1.0 0.65 0.0 1.0" },
            {"limegreen", "0.42 1.0 0 1.0" },
            {"blue", "0.2 0.6 1.0 1.0" },
            {"red", "1.0 0.1 0.1 1.0" },
            {"white", "1 1 1 1" },
            {"green", "0.28 0.82 0.28 1.0" },
            {"grey", "0.85 0.85 0.85 1.0" },
            {"lightblue", "0.6 0.86 1.0 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttongreen", "0.133 0.965 0.133 0.9" },
            {"buttonred", "0.964 0.133 0.133 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
        };
        #endregion

        #region Helpers

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        void Reply(BasePlayer player, string message, string args = null) => PrintToChat(player, $"{message}", args);
        bool IsAllowed(string id, string perm) => permission.UserHasPermission(id, perm);

        #endregion
    }
}

// --- End of file: ShowCrosshair.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/shared-doors ---
// --- Original File Path: S/SharedDoors/SharedDoors.cs ---

ï»¿using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SharedDoors", "dbteku", "2.0.1")]
    [Description("Making sharing doors easier.")]
    public class SharedDoors : RustPlugin
    {
        [PluginReference]
        private Plugin Clans;

        [PluginReference]
        private Plugin Friends;

        private static SharedDoors instance;
        private const string CLANS_NAME = "Clans";
        private const string CLANS_AUTHOR_NAME = "k1lly0u";
        private const string FRIENDS_NAME = "Friends";
        private const string FRIENDS_AUTHOR_NAME = "MrBlue";
        private const string FRIENDS_AUTHOR_NAME_ALTERNATE = "Wulf";
        private const string RUST_CLANS_HOOK = "SharedDoors now hooking to Clans by k1lly0u";
        private const string RUST_CLANS_UNHOOK = "SharedDoors now un-hooking from Clans";
        private const string RUST_FRIENDS_HOOK = "SharedDoors now hooking to Friends by MrBlue";
        private const string RUST_FRIENDS_UNHOOK = "SharedDoors now unhooking from Friends.";
        private const string RUST_CLANS_NOT_FOUND = "Rust Clans by k1lly0u has not been found.";
        private const string RUST_FRIENDS_NOT_FOUND = "Rust Friends by MrBlue has not been found.";
        private const string WRONG_CLANS_PLUGIN = "You are using the wrong Clans plugin. Please use the Clans by the author: k1lly0u.";
        private const string MASTER_PERM = "shareddoors.master";
        private MasterKeyHolders holders;

        private void OnServerInitialized()
        {
            instance = this;
            permission.RegisterPermission(MASTER_PERM, this);
            holders = new MasterKeyHolders();
            if (Clans == null)
            {
                Puts(RUST_CLANS_NOT_FOUND);
            }
            else
            {
                Puts(RUST_CLANS_HOOK);
            }
            if(Friends == null)
            {
                Puts(RUST_FRIENDS_NOT_FOUND);
            }
            else
            {
                Puts(RUST_FRIENDS_HOOK);
            }
        }

        private void Unload()
        {
            instance = null;
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Name == CLANS_NAME)
            {
                if(plugin.Author == CLANS_AUTHOR_NAME)
                {
                    Puts(RUST_CLANS_HOOK);
                    Clans = plugin;
                }
                else
                {
                    Puts(WRONG_CLANS_PLUGIN);
                }
            }
            if(plugin.Name == FRIENDS_NAME)
            {
                if (plugin.Author == FRIENDS_AUTHOR_NAME || plugin.Author == FRIENDS_AUTHOR_NAME_ALTERNATE)
                {
                    Puts(RUST_FRIENDS_HOOK);
                    Friends = plugin;
                }
            }
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin.Name == CLANS_NAME && plugin.Author == CLANS_AUTHOR_NAME)
            {
                Puts(RUST_CLANS_UNHOOK);
                Clans = null;
            }
            if(plugin.Name == FRIENDS_NAME && (plugin.Author == FRIENDS_AUTHOR_NAME || plugin.Author == FRIENDS_AUTHOR_NAME_ALTERNATE))
            {
                Puts(RUST_FRIENDS_UNHOOK);
                Friends = null;
            }
        }

        private void OnPlayerInit(BasePlayer player)
        {
            IPlayer iPlayer = covalence.Players.FindPlayerById(player.userID.ToString());
            if (player.IsAdmin || iPlayer.HasPermission(MASTER_PERM))
            {
                holders.AddMaster(player.userID.ToString());
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            IPlayer iPlayer = covalence.Players.FindPlayerById(player.userID.ToString());
            if (player.IsAdmin || iPlayer.HasPermission(MASTER_PERM))
            {
                holders.RemoveMaster(player.userID.ToString());
            }
        }

        private bool CanUseLockedEntity(BasePlayer player, BaseLock door)
        {
            IPlayer iPlayer = covalence.Players.FindPlayerById(player.userID.ToString());
            bool canUse = false;
            canUse = (player.IsAdmin && holders.IsAKeyMaster(player.userID.ToString()))
            || (iPlayer.HasPermission(MASTER_PERM) && holders.IsAKeyMaster(player.userID.ToString()))
            || new DoorAuthorizer(door, player).CanOpen();
            return canUse;
        }
        #region Commands
        [ChatCommand("sd")]
        private void SharedDoorsCommand(BasePlayer basePlayer, string command, string[] args)
        {
            IPlayer player = covalence.Players.FindPlayerById(basePlayer.userID.ToString());
            if (args.Length > 0)
            {
                if (args[0].ToLower() == "help")
                {
                    PlayerResponder.NotifyUser(player, "Master Mode Toggle: /sd masterMode");
                }
                else if (args[0].ToLower() == "mastermode" || args[0].ToLower() == "mm")
                {
                    if (player.IsAdmin || player.HasPermission(MASTER_PERM))
                    {
                        if (holders.HasMaster(player.Id))
                        {
                            holders.ToggleMasterMode(player.Id);
                            if (holders.IsAKeyMaster(player.Id))
                            {
                                PlayerResponder.NotifyUser(player, "Master Mode Enabled. You can now open all doors and chests.");
                            }
                            else
                            {
                                PlayerResponder.NotifyUser(player, "Master Mode Disabled. You can no longer open all doors and chests.");
                            }
                        }
                        else
                        {
                            holders.AddMaster(player.Id);
                            holders.GiveMasterKey(player.Id);
                            PlayerResponder.NotifyUser(player, "Master Mode Enabled. You can now open all doors and chests.");
                        }
                    }
                    else
                    {
                        PlayerResponder.NotifyUser(player, "Master Mode Not Available. You don't have permission to use this command.");
                    }
                }
            }
            else
            {
                PlayerResponder.NotifyUser(player, "Master Mode Toggle: /sd masterMode");
            }
        }
        #endregion

        public static SharedDoors getInstance()
        {
            return instance;
        }

        private class PlayerResponder
        {
            private const string PREFIX = "<color=#00ffffff>[</color><color=#ff0000ff>SharedDoors</color><color=#00ffffff>]</color>";

            public static void NotifyUser(IPlayer player, String message)
            {
                player.Message(message, PREFIX);
            }
        }

        /*
         *
         * Door Handler Class
         *
         * */

        private class DoorAuthorizer
        {
            public BaseLock BaseDoor { get; protected set; }
            public BasePlayer Player { get; protected set; }
            private ToolCupboardChecker checker;
            private FriendsClansHandler handler;

            public DoorAuthorizer(BaseLock door, BasePlayer player)
            {
                this.BaseDoor = door;
                this.Player = player;
                checker = new ToolCupboardChecker(Player);
                handler = new FriendsClansHandler(this);
            }

            public bool CanOpen()
            {
                bool canUse = false;
                if (BaseDoor.IsLocked())
                {
                    if (BaseDoor is CodeLock)
                    {
                        CodeLock codeLock = (CodeLock)BaseDoor;
                        canUse = CanOpenCodeLock(codeLock, Player);
                    }
                    else if (BaseDoor is KeyLock)
                    {
                        KeyLock keyLock = (KeyLock)BaseDoor;
                        canUse = CanOpenKeyLock(keyLock, Player);
                    }
                }
                else
                {
                    canUse = true;
                }
                return canUse;
            }

            private bool CanOpenCodeLock(CodeLock door, BasePlayer player)
            {
                bool canUse = false;
                var whitelist = door.whitelistPlayers;
                canUse = whitelist.Contains(player.userID);

                if (!canUse)
                {
                    bool isAuthorizedByTC = (player.CanBuild() && checker.IsPlayerAuthorized());
                    bool solution = canUse;
                    if (isAuthorizedByTC && !solution && handler.ClansAvailable())
                    {
                        canUse = handler.IsInClan(player.UserIDString, door.OwnerID.ToString());
                        solution = canUse;
                    }
                    if(isAuthorizedByTC && !solution && handler.FriendsAvailable())
                    {
                        canUse = handler.IsFriend(player.UserIDString, door.OwnerID.ToString());
                    }
                    if (!handler.FriendsAvailable() && !handler.ClansAvailable())
                    {
                        canUse = isAuthorizedByTC;
                    }
                }

                PlaySound(canUse, door, player);
                return canUse;
            }

            private bool CanOpenKeyLock(KeyLock door, BasePlayer player)
            {
                bool canUse = door.HasLockPermission(player);

                if (!canUse)
                {
                    bool isAuthorizedByTC = (player.CanBuild() && checker.IsPlayerAuthorized());
                    bool solution = canUse;
                    if (isAuthorizedByTC && !solution && handler.ClansAvailable())
                    {
                        canUse = handler.IsInClan(player.UserIDString, door.OwnerID.ToString());
                        solution = canUse;
                    }
                    if (isAuthorizedByTC && !solution && handler.FriendsAvailable())
                    {
                        canUse = handler.IsFriend(player.UserIDString, door.OwnerID.ToString());
                    }
                    if(!handler.FriendsAvailable() && !handler.ClansAvailable())
                    {
                        canUse = isAuthorizedByTC;
                    }
                }
                return canUse;
            }

            private void PlaySound(bool canUse, CodeLock door, BasePlayer player)
            {
                if (canUse)
                {
                    Effect.server.Run(door.effectUnlocked.resourcePath, player.transform.position, Vector3.zero, null, false);
                }
                else
                {
                    Effect.server.Run(door.effectDenied.resourcePath, player.transform.position, Vector3.zero, null, false);
                }
            }
        }

        /*
         *
         * Tool Cupboard Tool
         *
         * */

        private class ToolCupboardChecker
        {
            public BasePlayer Player { get; protected set; }

            public ToolCupboardChecker(BasePlayer player)
            {
                this.Player = player;
            }

            public bool IsPlayerAuthorized()
            {
                return Player.IsBuildingAuthed();
            }
        }

        /*
         *
         * RustIO Handler
         *
         * */

        private class FriendsClansHandler
        {
            private const string GET_CLAN_OF_PLAYER = "GetClanOf";
            private const string IS_CLAN_MEMBER = "IsClanMember";
            public Plugin Clans { get; protected set; }
            public Plugin Friends { get; protected set; }
            public ulong OriginalPlayerID { get; protected set; }
            public DoorAuthorizer Door { get; protected set; }

            public FriendsClansHandler(DoorAuthorizer door)
            {
                if (door.BaseDoor is CodeLock)
                {
                    CodeLock codeLock = door.BaseDoor as CodeLock;
                    List<ulong> whitelist = codeLock.whitelistPlayers;
                    if (whitelist.Count > 0)
                    {
                        this.OriginalPlayerID = whitelist[0];
                    }
                    else
                    {
                        this.OriginalPlayerID = 0;
                    }
                }
                this.Door = door;
                this.Clans = SharedDoors.getInstance().Clans;
                this.Friends = SharedDoors.getInstance().Friends;
            }

            public bool IsInClan(string playerId, string playerDoorOwner)
            {
                bool isInClan = false;
                if (ClansAvailable())
                {
                    string clanName = Clans.Call<string>(GET_CLAN_OF_PLAYER, playerId);
                    if (!string.IsNullOrWhiteSpace(clanName))
                    {
                        isInClan = Clans.Call<bool>(IS_CLAN_MEMBER, playerDoorOwner, playerId);
                    }
                }

                return isInClan;
            }

            public bool IsFriend(string playerId, string playerDoorOwner)
            {
                return Friends.IsLoaded && Friends.Call<bool>("IsFriend", playerId, playerDoorOwner);
            }

            public bool ClansAvailable()
            {
                return this.Clans != null && Clans.IsLoaded;
            }
            public bool FriendsAvailable()
            {
                return this.Friends != null && Friends.IsLoaded;
            }
        }

        /*
       *
       * Admin Mode Handler
       *
       * */

        private class MasterKeyHolders
        {
            private Dictionary<string, PlayerSettings> keyMasters;

            public MasterKeyHolders()
            {
                keyMasters = new Dictionary<string, PlayerSettings>();
            }

            public void AddMaster(String id)
            {
                this.keyMasters.Add(id, new PlayerSettings(false));
            }

            public void RemoveMaster(String id)
            {
                this.keyMasters.Remove(id);
            }

            public void GiveMasterKey(String id)
            {
                PlayerSettings settings = null;
                bool exists = keyMasters.TryGetValue(id, out settings);
                if (exists)
                {
                    settings.IsMasterKeyHolder = true;
                }
            }

            public void RemoveMasterKey(String id)
            {
                PlayerSettings settings = null;
                bool exists = keyMasters.TryGetValue(id, out settings);
                if (exists)
                {
                    settings.IsMasterKeyHolder = false;
                }
            }

            public bool IsAKeyMaster(String id)
            {
                bool isKeyMaster = false;
                PlayerSettings settings = null;
                bool exists = keyMasters.TryGetValue(id, out settings);
                if (exists)
                {
                    isKeyMaster = settings.IsMasterKeyHolder;
                }
                return isKeyMaster;
            }

            public void ToggleMasterMode(String id)
            {
                PlayerSettings settings = null;
                bool exists = keyMasters.TryGetValue(id, out settings);
                if (exists)
                {
                    settings.ToggleMasterMode();
                }
            }

            public bool HasMaster(string id)
            {
                return keyMasters.ContainsKey(id);
            }
        }

        /*
       *
       * Player Settings
       *
       * */

        private class PlayerSettings
        {
            public bool IsMasterKeyHolder { get; set; }

            public PlayerSettings(bool isMasterKeyHolder)
            {
                IsMasterKeyHolder = isMasterKeyHolder;
            }

            public void ToggleMasterMode()
            {
                IsMasterKeyHolder = !IsMasterKeyHolder;
            }
        }
    }
}

// --- End of file: SharedDoors.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/slasher ---
// --- Original File Path: S/Slasher/Slasher.cs ---

ï»¿// Requires: EventManager

using Facepunch;
using Network;
using Newtonsoft.Json;
using Oxide.Plugins.EventManagerEx;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Slasher", "k1lly0u", "0.3.2"), Description("Team Deathmatch event mode for EventManager")]
    class Slasher : RustPlugin, IEventPlugin
    {
        private string[] _torchItems = new string[] {"torch", "flashlight.held"};
        private string[] _validWeapons;

        private long _midnightTime;
        private long _middayTime;

        private const string WEAPON_FLASHLIGHT_ITEM = "weapon.mod.flashlight";

        private static EnvSync EnvSync;

        private static Slasher Instance;

        private static List<BasePlayer> EventPlayers;

        #region Oxide Hooks

        private void Loaded()
        {
            Instance = this;

            _middayTime = new DateTime().AddHours(12).ToBinary();
            _midnightTime = new DateTime().ToBinary();

            EventPlayers = Facepunch.Pool.Get<List<BasePlayer>>();

            Unsubscribe(nameof(CanNetworkTo));
        }

        private void OnServerInitialized()
        {
            EventManager.RegisterEvent(Title, this);

            GetMessage = Message;

            EnvSync = GameObject.FindObjectOfType<EnvSync>();

            FindValidWeapons();
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private object CanNetworkTo(EnvSync env, BasePlayer player)
        {
            if (env == null || player == null || !EventPlayers.Contains(player))
                return null;

            NetWrite netWrite = Net.sv.StartWrite();
            Connection connection = player.net.connection;
            connection.validate.entityUpdates = connection.validate.entityUpdates + 1;
            BaseNetworkable.SaveInfo saveInfo = new BaseNetworkable.SaveInfo
            {
                forConnection = player.net.connection,
                forDisk = false
            };

            netWrite.PacketID(Network.Message.Type.Entities);
            netWrite.UInt32(player.net.connection.validate.entityUpdates);

            using (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())
            {
                env.Save(saveInfo);

                saveInfo.msg.environment.dateTime = (EventManager.BaseManager as SlasherEvent).IsPlayingRound ? _midnightTime : _middayTime;

                saveInfo.msg.ToProto(netWrite);
                netWrite.Send(new SendInfo(player.net.connection));
            }

            return false;
        }

        private void Unload()
        {
            Facepunch.Pool.FreeUnmanaged(ref EventPlayers);

            if (!EventManager.IsUnloading)
                EventManager.UnregisterEvent(Title);

            Configuration = null;
            Instance = null;
        }
        #endregion

        #region Functions
        private void FindValidWeapons()
        {
            List<string> list = Facepunch.Pool.Get<List<string>>();

            foreach (ItemDefinition itemDefinition in ItemManager.itemList)
            {
                if (itemDefinition.category is ItemCategory.Weapon or ItemCategory.Tool)
                {
                    if (!itemDefinition.isHoldable)
                        continue;

                    AttackEntity attackEntity = itemDefinition.GetComponent<ItemModEntity>()?.entityPrefab?.Get()?.GetComponent<AttackEntity>();
                    if (attackEntity != null && attackEntity is BaseMelee or BaseProjectile)
                        list.Add(itemDefinition.shortname);
                }
            }

            list.Sort();

            _validWeapons = list.ToArray();

            Facepunch.Pool.FreeUnmanaged(ref list);
        }

        private string[] GetSlasherWeapons() => _validWeapons;

        private string[] GetSlasherTorches() => _torchItems;
        #endregion

        #region Event Checks
        public bool InitializeEvent(EventManager.EventConfig config) => EventManager.InitializeEvent<SlasherEvent>(this, config);

        public bool CanUseClassSelector => false;

        public bool RequireTimeLimit => false;

        public bool RequireScoreLimit => false;

        public bool UseScoreLimit => false;

        public bool UseTimeLimit => false;

        public bool IsTeamEvent => false;

        public void FormatScoreEntry(EventManager.ScoreEntry scoreEntry, ulong langUserId, out string score1, out string score2)
        {
            score1 = string.Format(Message("Score.Kills", langUserId), scoreEntry.value1);
            score2 = string.Format(Message("Score.Deaths", langUserId), scoreEntry.value2);
        }

        public List<EventManager.EventParameter> AdditionalParameters { get; } = new List<EventManager.EventParameter>
        {         
            new EventManager.EventParameter
            {
                DataType = "string",
                Field = "torchItem",
                Input = EventManager.EventParameter.InputType.Selector,
                SelectMultiple = false,
                SelectorHook = "GetSlasherTorches",
                IsRequired = true,
                DefaultValue = "flashlight.held",
                Name = "Torch Item"
            },
            new EventManager.EventParameter
            {
                DataType = "string",
                Field = "slasherWeapon",
                Input = EventManager.EventParameter.InputType.Selector,
                SelectMultiple = false,
                SelectorHook = "GetSlasherWeapons",
                IsRequired = false,
                Name = "Slasher Weapon",
                DefaultValue = "shotgun.pump"
            },
            new EventManager.EventParameter
            {
                DataType = "string",
                Field = "slasherClothing",
                Input = EventManager.EventParameter.InputType.Selector,
                SelectMultiple = false,
                SelectorHook = "GetAllKits",
                IsRequired = false,
                Name = "Slasher Clothing"
            },            
            new EventManager.EventParameter
            {
                DataType = "int",
                Field = "slasherTime",
                Input = EventManager.EventParameter.InputType.InputField,
                IsRequired = true,
                DefaultValue = 180,
                Name = "Slasher Timer (seconds)"
            },
            new EventManager.EventParameter
            {
                DataType = "int",
                Field = "playerTime",
                Input = EventManager.EventParameter.InputType.InputField,
                IsRequired = true,
                DefaultValue = 120,
                Name = "Player Timer (seconds)"
            },
        };

        public string ParameterIsValid(string fieldName, object value)
        {
            switch (fieldName)
            {
                case "slasherWeapon":
                    {
                        if (ItemManager.FindItemDefinition((string)value) == null)
                            return "Unable to find a weapon with the specified shortname";

                        return null;
                    }
                case "slasherClothing":
                    {
                        object success = EventManager.Instance.ValidateKit((string)value);
                        if (success != null)
                            return (string)success;

                        return null;
                    }
                default:
                    return null;
            }
        }
        #endregion

        #region Event Classes
        public class SlasherEvent : EventManager.BaseEventGame
        {
            private ItemDefinition torchItem;
            private ItemDefinition slasherWeapon;
            private string slasherKit;

            private int slasherTime;
            private int playerTime;

            private int rounds;
            private int currentRound;

            private EventManager.BaseEventPlayer slasherPlayer;

            private List<EventManager.BaseEventPlayer> remainingSlashers;

            internal bool IsPlayingRound { get; private set; }

            internal override void InitializeEvent(IEventPlugin plugin, EventManager.EventConfig config)
            {
                torchItem = ItemManager.FindItemDefinition(config.GetParameter<string>("torchItem"));
                slasherWeapon = ItemManager.FindItemDefinition(config.GetParameter<string>("slasherWeapon"));

                slasherKit = config.GetParameter<string>("slasherClothing");

                slasherTime = config.GetParameter<int>("slasherTime");
                playerTime = config.GetParameter<int>("playerTime");

                remainingSlashers = Facepunch.Pool.Get<List<EventManager.BaseEventPlayer>>();

                base.InitializeEvent(plugin, config);
            }

            protected override void OnDestroy()
            {
                Instance?.Unsubscribe(nameof(Instance.CanNetworkTo));

                Facepunch.Pool.FreeUnmanaged(ref remainingSlashers);

                EventPlayers.Clear();                

                base.OnDestroy();
            }

            internal override void PrestartEvent()
            {
                CloseEvent();
                base.PrestartEvent();
            }

            protected override void StartEvent()
            {                
                base.StartEvent();

                Instance.Subscribe(nameof(Instance.CanNetworkTo));

                rounds = eventPlayers.Count;

                remainingSlashers.AddRange(eventPlayers);

                EventPlayers.Clear();
                EventPlayers.AddRange(eventPlayers.Select((EventManager.BaseEventPlayer eventPlayer) => eventPlayer.Player));

                StartRound();
            }

            protected override EventManager.BaseEventPlayer AddPlayerComponent(BasePlayer player) => player.gameObject.AddComponent<SlasherPlayer>();

            internal override void LeaveEvent(BasePlayer player)
            {
                bool isSlasher = slasherPlayer != null && player.GetComponent<SlasherPlayer>() == slasherPlayer;

                EventPlayers.Remove(player);
                base.LeaveEvent(player);

                if (isSlasher && Status != EventManager.EventStatus.Finished)
                    EndRound();
            }

            #region Event Items
            protected override void OnKitGiven(EventManager.BaseEventPlayer eventPlayer)
            {
                List<Item> list = Facepunch.Pool.Get<List<Item>>();
                eventPlayer.Player.inventory.GetAllItems(list);

                bool isSlasher = eventPlayer == slasherPlayer;

                for (int i = 0; i < list.Count; i++)
                {
                    Item item = list[i];

                    if (!isSlasher && item.info.category == ItemCategory.Attire)
                        continue;

                    item.RemoveFromContainer();
                    item.Remove();
                }
                
                Pool.FreeUnmanaged(ref list);

                if (isSlasher)
                {
                    EventManager.GiveKit(eventPlayer.Player, slasherKit);
                    GiveSlasherWeapon(eventPlayer);
                }
                else GiveTorch(eventPlayer);

                eventPlayer.Player.inventory.SendUpdatedInventory(PlayerInventory.Type.Belt, eventPlayer.Player.inventory.containerBelt);
            }

            private void GiveSlasherWeapon(EventManager.BaseEventPlayer eventPlayer)
            {
                Item item = ItemManager.Create(slasherWeapon);

                if (item.contents != null && item.contents.availableSlots.Count > 0)
                {
                    Item attachment = ItemManager.CreateByName(WEAPON_FLASHLIGHT_ITEM);
                    if (!attachment.MoveToContainer(item.contents))                    
                        attachment.Remove();   
                    else item.GetHeldEntity()?.SendMessage("SetLightsOn", true, SendMessageOptions.DontRequireReceiver);
                }
                
                item.MoveToContainer(eventPlayer.Player.inventory.containerBelt);

                BaseProjectile baseProjectile = item.GetHeldEntity() as BaseProjectile;
                if (baseProjectile != null)
                {
                    Item ammo = ItemManager.Create(baseProjectile.primaryMagazine.ammoType, baseProjectile.primaryMagazine.capacity * 5);
                    ammo.MoveToContainer(eventPlayer.Player.inventory.containerMain);
                }
            }

            private void GiveTorch(EventManager.BaseEventPlayer eventPlayer)
            {
                Item item = ItemManager.Create(torchItem);
                item.MoveToContainer(eventPlayer.Player.inventory.containerBelt);
                item.GetHeldEntity()?.SendMessage("SetLightsOn", true, SendMessageOptions.DontRequireReceiver);
            }

            protected override bool CanDropBackpack() => false;
            #endregion

            internal override void OnEventPlayerDeath(EventManager.BaseEventPlayer victim, EventManager.BaseEventPlayer attacker = null, HitInfo info = null)
            {
                if (victim == null)
                    return;

                attacker?.OnKilledPlayer(info);

                if (victim == slasherPlayer || GetAlivePlayerCount() <= 1)
                {                   
                    victim.AddPlayerDeath();

                    if (victim == slasherPlayer)
                        BroadcastToPlayers(GetMessage, "Notification.HuntedWin");
                    else BroadcastToPlayers(GetMessage, "Notification.SlasherWin");

                    EndRound();
                    return;
                }

                victim.OnPlayerDeath(attacker, 0f);

                UpdateScoreboard();

                base.OnEventPlayerDeath(victim, attacker);
            }

            internal override void GetSpectateTargets(ref List<EventManager.BaseEventPlayer> list)
            {
                list.Clear();

                for (int i = 0; i < eventPlayers.Count; i++)
                {
                    EventManager.BaseEventPlayer eventPlayer = eventPlayers[i];
                    if (!eventPlayer.IsDead && eventPlayer != slasherPlayer)
                        list.Add(eventPlayer);
                }
            }

            #region Rounds
            private void StartRound()
            {
                GodmodeEnabled = false;

                IsPlayingRound = true;

                EnvSync.SendNetworkUpdateImmediate();

                currentRound += 1;

                slasherPlayer = GetRandomSlasher();

                StartCoroutine(ResetPlayers());

                Timer.StartTimer(slasherTime, GetMessage("Timer.Slasher", 0UL), OnSlasherTimerExpired);

                BroadcastToPlayers(GetMessage, "Notification.RoundStarted", slasherPlayer.Player.displayName);

                UpdateScoreboard();
            }
            
            private void EndRound()
            {
                slasherPlayer = null;

                Timer.StopTimer();

                IsPlayingRound = false;

                GodmodeEnabled = true;

                EnvSync.SendNetworkUpdateImmediate();

                if (currentRound >= rounds)
                {
                    Status = EventManager.EventStatus.Finished;

                    StartCoroutine(ResetPlayers());
                    InvokeHandler.Invoke(this, EndEvent, 5f);
                }
                else
                {
                    StartCoroutine(ResetPlayers());

                    InvokeHandler.Invoke(this, StartRound, Configuration.TimeBetweenRounds);
                    BroadcastToPlayers(GetMessage, "Notification.RoundStartsIn", Configuration.TimeBetweenRounds);
                }
            }

            private void OnSlasherTimerExpired()
            {
                Timer.StartTimer(playerTime, GetMessage("Timer.Hunted", 0UL), EndRound);

                StartCoroutine(GiveSlasherWeapons());

                BroadcastToPlayers(GetMessage, "Notification.HuntersTurn");
            }

            private EventManager.BaseEventPlayer GetRandomSlasher()
            {
                EventManager.BaseEventPlayer nextSlasher = remainingSlashers.GetRandom();

                remainingSlashers.Remove(nextSlasher);

                if (remainingSlashers.Count == 0)
                    remainingSlashers.AddRange(eventPlayers);

                if (nextSlasher == null)
                    return GetRandomSlasher();
                return nextSlasher;
            }

            private IEnumerator ResetPlayers()
            {
                List<EventManager.BaseEventPlayer> currentPlayers = Facepunch.Pool.Get<List<EventManager.BaseEventPlayer>>();
                currentPlayers.AddRange(eventPlayers);

                for (int i = 0; i < currentPlayers.Count; i++)
                {
                    EventManager.BaseEventPlayer eventPlayer = currentPlayers[i];
                    if (eventPlayer != null)
                    {
                        if (eventPlayer.IsDead)
                        {
                            EventManager.ResetPlayer(eventPlayer.Player);
                            OnPlayerRespawn(eventPlayer);
                        }
                        else
                        {
                            EventManager.StripInventory(eventPlayer.Player);
                            EventManager.ResetMetabolism(eventPlayer.Player);

                            yield return CoroutineEx.waitForEndOfFrame;
                            yield return CoroutineEx.waitForEndOfFrame;

                            EventManager.GiveKit(eventPlayer.Player, eventPlayer.Kit);

                            yield return CoroutineEx.waitForEndOfFrame;

                            OnKitGiven(eventPlayer);
                        }
                    }
                    
                    yield return CoroutineEx.waitForEndOfFrame;
                    yield return CoroutineEx.waitForEndOfFrame;
                }

                Facepunch.Pool.FreeUnmanaged(ref currentPlayers);
            }

            private IEnumerator GiveSlasherWeapons()
            {
                for (int i = eventPlayers.Count - 1; i >= 0; i--)
                {
                    EventManager.BaseEventPlayer eventPlayer = eventPlayers[i];

                    if (eventPlayer.IsDead || eventPlayer == slasherPlayer)
                        continue;

                    GiveSlasherWeapon(eventPlayer);

                    yield return CoroutineEx.waitForEndOfFrame;
                    yield return CoroutineEx.waitForEndOfFrame;
                }
            }
            #endregion

            protected override void GetWinningPlayers(ref List<EventManager.BaseEventPlayer> winners)
            {
                EventManager.BaseEventPlayer winner = null;

                if (eventPlayers.Count > 0)
                {
                    int kills = 0;
                    int deaths = 0;

                    for (int i = 0; i < eventPlayers.Count; i++)
                    {
                        EventManager.BaseEventPlayer eventPlayer = eventPlayers[i];
                        if (eventPlayer == null)
                            continue;

                        if (eventPlayer.Kills > kills)
                        {
                            winner = eventPlayer;
                            kills = eventPlayer.Kills;
                            deaths = eventPlayer.Deaths;
                        }
                        else if (eventPlayer.Kills == kills)
                        {
                            if (eventPlayer.Deaths < deaths)
                            {
                                winner = eventPlayer;
                                kills = eventPlayer.Kills;
                                deaths = eventPlayer.Deaths;
                            }
                        }
                    }
                }

                if (winner != null)
                    winners.Add(winner);
            }

            #region Scoreboards
            protected override void BuildScoreboard()
            {
                scoreContainer = EMInterface.CreateScoreboardBase(this);

                int index = -1;
                EMInterface.CreatePanelEntry(scoreContainer, string.Format(GetMessage("Score.RoundNumber", 0UL), currentRound, rounds), index += 1);

                EMInterface.CreateScoreEntry(scoreContainer, string.Empty, "K", "D", index += 1);

                for (int i = 0; i < Mathf.Min(scoreData.Count, 15); i++)
                {
                    EventManager.ScoreEntry score = scoreData[i];
                    EMInterface.CreateScoreEntry(scoreContainer, score.displayName, ((int)score.value1).ToString(), ((int)score.value2).ToString(), i + index + 1);
                }
            }

            protected override float GetFirstScoreValue(EventManager.BaseEventPlayer eventPlayer) => eventPlayer.Kills;

            protected override float GetSecondScoreValue(EventManager.BaseEventPlayer eventPlayer) => eventPlayer.Deaths;

            protected override void SortScores(ref List<EventManager.ScoreEntry> list)
            {
                list.Sort(delegate (EventManager.ScoreEntry a, EventManager.ScoreEntry b)
                {
                    int primaryScore = a.value1.CompareTo(b.value1);

                    if (primaryScore == 0)
                        return a.value2.CompareTo(b.value2) * -1;

                    return primaryScore;
                });
            }
            #endregion
        }

        private class SlasherPlayer : EventManager.BaseEventPlayer
        {
            internal override void OnPlayerDeath(EventManager.BaseEventPlayer attacker = null, float respawnTime = 5)
            {
                AddPlayerDeath(attacker);

                DestroyUI();

                BeginSpectating();
            }
        }
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {            
            [JsonProperty(PropertyName = "Amount of time between rounds (seconds)")]
            public int TimeBetweenRounds { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                TimeBetweenRounds = 10,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Localization
        public string Message(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId != 0U ? playerId.ToString() : null);

        private static Func<string, ulong, string> GetMessage;

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Score.Kills"] = "Kills: {0}",
            ["Score.Deaths"] = "Deaths: {0}",
            ["Score.Name"] = "Kills",
            ["Score.Limit"] = "Score Limit : {0}",
            ["Score.RoundNumber"] = "Round {0} / {1}",
            ["Timer.Slasher"] = "Slasher Time",
            ["Timer.Hunted"] = "Hunted Time",
            ["Notification.RoundStartsIn"] = "The next round starts in <color=#007acc>{0}</color> seconds",
            ["Notification.RoundStarted"] = "<color=#007acc>{0}</color> is the slasher. Hide from them!",
            ["Notification.HuntersTurn"] = "The hunted have become the hunters!",
            ["Notification.HuntedWin"] = "The hunted have won this round!",
            ["Notification.SlasherWin"] = "The slasher has won this round!"
        };
        #endregion
    }
}


// --- End of file: Slasher.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/signs-monitor ---
// --- Original File Path: S/SignsMonitor/SignsMonitor.cs ---

// ReSharper disable CheckNamespace

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Networking;

namespace Oxide.Plugins
{
    [Info( "Signs Monitor", "Mr. Blue", "1.0.1" )]
    [Description( "Send a message to discord with an image of the signage content set by the user" )]
    public class SignsMonitor : RustPlugin
    {
        #region Configuration

        private const string WEBHOOK_INTRO =
            "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

        private static int? _embedColor;

        private class PluginConfiguration
        {
            [JsonProperty( "Discord Webhook" )] public string DiscordWebhook;
            [JsonProperty( "Embed Color" )] public string EmbedColor;
        }

        private PluginConfiguration _config;

        private void Init()
        {
            _config = Config.ReadObject<PluginConfiguration>();
            _embedColor = FromHex( _config.EmbedColor );

            if( _config.DiscordWebhook == WEBHOOK_INTRO )
            {
                PrintWarning( $"Please set the discord webhook in the configuration file! ({WEBHOOK_INTRO})" );
                Unsubscribe( nameof( OnSignUpdated ) );
                Unsubscribe( nameof( OnItemPainted ) );
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject( GetDefaultConfig(), true );
        }

        private PluginConfiguration GetDefaultConfig()
        {
            return new PluginConfiguration
            {
                DiscordWebhook = WEBHOOK_INTRO,
                EmbedColor = "#54a8fc"
            };
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages( new Dictionary<string, string>
            {
                ["EmbedTitle"] = "Signage changed!",
                ["EmbedBody"] =
                    "**Player:**\n{playerName}\n{playerId}\n[Steam Profile](https://steamcommunity.com/profiles/{playerId})\n\n" +
                    "**Signage owner:**\n{ownerName}\n{ownerId}\n[Steam Profile](https://steamcommunity.com/profiles/{ownerId})\n\n" +
                    "**Signage info:**\nPosition: {signagePosition}\nType: {signageType}\n\n" +
                    "**Server:\n**{serverName}"
            }, this );
        }

        private string FormatMessage( string key, BasePlayer player, string displayName, string steamId, BaseEntity entity )
        {
            return lang.GetMessage( key, this )
                .Replace( "{playerName}", player.displayName )
                .Replace( "{playerId}", player.UserIDString )
                .Replace( "{ownerName}", displayName )
                .Replace( "{ownerId}", steamId )
                .Replace( "{signagePosition}", entity.transform.position.ToString().Replace( " ", string.Empty ) )
                .Replace( "{signageType}", entity.ShortPrefabName )
                .Replace( "{serverName}", covalence.Server.Name );
        }

        #endregion

        #region Signage Logic

        private void OnSignUpdated( ISignage signage, BasePlayer player, int textureIndex = 0 )
        {
            uint crc = signage.GetTextureCRCs()[textureIndex];
            var encodedPng = FileStorage.server.Get( crc, FileStorage.Type.png, signage.NetworkID, (uint) textureIndex );
            if( encodedPng == null ) return;

            var entity = signage as BaseEntity;
            SendDiscordEmbed( encodedPng, player, entity.OwnerID, entity );
        }

        private void OnItemPainted( PaintedItemStorageEntity entity, Item item, BasePlayer player, byte[] encodedPng )
        {
            if( entity._currentImageCrc == 0 )
            {
                return;
            }

            SendDiscordEmbed( encodedPng, player, entity.OwnerID, entity );
        }

        private void SendDiscordEmbed( byte[] image, BasePlayer player, ulong signageOwnerId, BaseEntity entity )
        {
            var signageOwnerName = ConVar.Admin.GetPlayerName( signageOwnerId );
            var signageSteamId = signageOwnerId.ToString();
            var title = FormatMessage( "EmbedTitle", player, signageOwnerName, signageSteamId, entity );
            var description = FormatMessage( "EmbedBody", player, signageOwnerName, signageSteamId, entity );

            var payload = new
            {
                embeds = new[]
                {
                    new
                    {
                        title,
                        description,
                        color = _embedColor,
                        image = new
                        {
                            url = "attachment://image.png"
                        },
                        timestamp = DateTime.Now
                    }
                }
            };

            var form = new WWWForm();
            form.AddBinaryData( "file", image, "image.png" );
            form.AddField( "payload_json", JsonConvert.SerializeObject( payload ) );

            ServerMgr.Instance.StartCoroutine( HandleUpload( _config.DiscordWebhook, form ) );
        }

        private IEnumerator HandleUpload( string url, WWWForm data )
        {
            var www = UnityWebRequest.Post( url, data );
            yield return www.SendWebRequest();

            if( www.isNetworkError || www.isHttpError )
            {
                Puts( $"Failed to post sign image to discord: {www.error}" );
            }
        }

        #endregion

        #region Helpers

        private static int? FromHex( string value )
        {
            var match = Regex.Match( value, "#?([0-9a-f]{6})" );
            if( !match.Success )
            {
                return null;
            }

            return int.Parse( match.Groups[1].Value, System.Globalization.NumberStyles.HexNumber );
        }

        #endregion
    }
}

// --- End of file: SignsMonitor.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/stash-marker ---
// --- Original File Path: S/StashMarker/StashMarker.cs ---

ï»¿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Stash Marker", "supreme", "1.1.0")]
    [Description("Marks the hidden stashes on the ingame map")]
    public class StashMarker : RustPlugin
    {
        //credits to nivex for improvements
        const string permUse = "stashmarker.use";
        const string permAdmin = "stashmarker.admin";

        #region Class Variables
        private readonly Hash<ulong, List<MapMarkerGenericRadius>> _mapMarker = new Hash<ulong, List<MapMarkerGenericRadius>>();
        private WaitForEndOfFrame _cachedWaitForEndOfFrame = new WaitForEndOfFrame();
        private HashSet<StashContainer> _stashes = new HashSet<StashContainer>();
        private Coroutine _stashRoutine;
        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Marker Radius")]
            public float markerRadius = 0.1f;

            [JsonProperty(PropertyName = "Marker Alpha")]
            public float markerAlpha = 0.8f;

            [JsonProperty(PropertyName = "Marker Color")]
            public string markerColor = "ACFA58";

            [JsonProperty(PropertyName = "Marker Color Outline")]
            public string markerColorOutline = "000000";

        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #region Setup & Loading

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));
            Subscribe(nameof(OnEntityKill));
            Subscribe(nameof(OnPlayerSleepEnded));
            Subscribe(nameof(CanNetworkTo));
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                OnPlayerSleepEnded(player);
            }
            _stashRoutine = ServerMgr.Instance.StartCoroutine(StashRoutine());
        }

        IEnumerator StashRoutine()
        {
            int total = 0;

            foreach (var e in BaseNetworkable.serverEntities)
            {
                if (e is StashContainer)
                {
                    _stashes.Add(e as StashContainer);
                }

                if (++total % 50 == 0)
                {
                    yield return _cachedWaitForEndOfFrame;
                }
            }

            _stashRoutine = null;
        }

        void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(CanNetworkTo));
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permAdmin, this);
        }

        private void Unload()
        {
            if (_stashRoutine != null)
            {
                ServerMgr.Instance.StopCoroutine(_stashRoutine);
            }
            foreach (MapMarkerGenericRadius marker in _mapMarker.SelectMany(mm => mm.Value))
            {
                marker.Kill();
            }
        }

        #endregion

        #region uMod Hooks

        private void OnEntitySpawned(StashContainer stash)
        {
            if (stash != null)
            {
                _stashes.Add(stash);
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permUse)) return;
            List<MapMarkerGenericRadius> playerMarkers;
            if (!_mapMarker.TryGetValue(player.userID, out playerMarkers))
                _mapMarker.Add(player.userID, playerMarkers = new List<MapMarkerGenericRadius>());

            foreach (StashContainer stash in _stashes.Where(s => s.OwnerID == player.userID))
                if (stash.IsHidden())
                {
                    MapMarkerGenericRadius marker = GetOrAddMarker(player, stash.transform.position);
                    marker.SendUpdate();
                }
        }

        private void OnEntityKill(StashContainer stash)
        {
            _stashes.Remove(stash);
            List<MapMarkerGenericRadius> playerMarkers = _mapMarker[stash.OwnerID];
            MapMarkerGenericRadius marker = playerMarkers?.FirstOrDefault(m => m.transform.position == stash.transform.position);

            if (marker == null || marker.IsDestroyed) return;
            marker.Kill();
            playerMarkers.Remove(marker);
        }

        void CanSeeStash(BasePlayer player, StashContainer stash)
        {
            List<MapMarkerGenericRadius> playerMarkers;
            if (!_mapMarker.TryGetValue(player.userID, out playerMarkers))
                _mapMarker.Add(player.userID, playerMarkers = new List<MapMarkerGenericRadius>());

            MapMarkerGenericRadius marker = playerMarkers?.FirstOrDefault(m => m.transform.position == stash.transform.position);

            if (marker == null || marker.IsDestroyed) return;
            marker.Kill();
            playerMarkers.Remove(marker);
        }

        void CanHideStash(BasePlayer player, StashContainer stash)
        {
            if (!permission.UserHasPermission(player.UserIDString, permUse)) return;
            MapMarkerGenericRadius marker = GetOrAddMarker(player, stash.transform.position);
            marker.SendUpdate();
        }

        private object CanNetworkTo(MapMarkerGenericRadius marker, BasePlayer target)
        {
            if (marker == null) return null;

            List<MapMarkerGenericRadius> playerMarkers;
            if (!_mapMarker.TryGetValue(marker.OwnerID, out playerMarkers) || !playerMarkers.Contains(marker)) return null;

            return marker.OwnerID == target.userID || permission.UserHasPermission(target.UserIDString, permAdmin) ? (object)true : false;
        }

        #endregion

        #region Marker Methods

        private MapMarkerGenericRadius GetOrAddMarker(BasePlayer player, Vector3 pos)
        {
            if (!permission.UserHasPermission(player.UserIDString, permUse)) return null;
            List<MapMarkerGenericRadius> playerMarkers;
            if (!_mapMarker.TryGetValue(player.userID, out playerMarkers))
                _mapMarker.Add(player.userID, playerMarkers = new List<MapMarkerGenericRadius>());
            MapMarkerGenericRadius marker = playerMarkers.FirstOrDefault(m => m.transform.position == pos);
            marker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", pos) as MapMarkerGenericRadius;
            if (marker == null) return null;
            marker.alpha = _config.markerAlpha;
            string colorMarker = _config.markerColor;
            string colorOutline = _config.markerColorOutline;
            ColorUtility.TryParseHtmlString($"#{colorMarker}", out marker.color1);
            ColorUtility.TryParseHtmlString($"#{colorOutline}", out marker.color2);
            marker.radius = _config.markerRadius;
            marker.OwnerID = player.userID;
            playerMarkers.Add(marker);
            marker.Spawn();
            return marker;
        }

        #endregion
    }
}

// --- End of file: StashMarker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/spawn-logger ---
// --- Original File Path: S/SpawnLogger/SpawnLogger.cs ---

ï»¿using System.Linq;
using System;
using UnityEngine;
using Newtonsoft.Json;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using UnityEngine.Assertions.Must;

namespace Oxide.Plugins
{
    [Info("Spawn Logger", "un-boxing-man & Lincoln", "1.0.8")]
    [Description("Logs all player spawned items to a file.")]
    public class SpawnLogger : RustPlugin
    {
        #region config
        //Creating a config file
        private static PluginConfig config;
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Excluded Logging  ")] public List<string> LoggingExcludeList { get; set; }


            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                LoggingExcludeList = new List<string>()
                    {
                        ""
                    }
            };

        }   
        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created!!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        #endregion

        #region loging
        private void OnEntitySpawned(BaseEntity entity)
        {
            if (entity == null) return;
            var player = covalence.Players.FindPlayerById(entity.OwnerID.ToString());
            if (player == null ) return;
            var pos = $"({entity.transform.position.x} {entity.transform.position.y} {entity.transform.position.z})";
            if (config.LoggingExcludeList.Contains(entity.ShortPrefabName)) return;
            Log("Entity_Spawned", player.Name, player.Id, entity.ShortPrefabName, pos);
        }
        private void Log(string filename, string player, string id, string entity, string pos)
        {
            LogToFile(filename, $"[{DateTime.Now}] {player}[{id}]: {entity} {pos}", this);
        }
        #endregion

        // Credits Lincoln, For the config and more.
    }
}


// --- End of file: SpawnLogger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sleeper-group ---
// --- Original File Path: S/SleeperGroup/SleeperGroup.cs ---

ï»¿using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Sleeper Group", "Wulf", "1.0.0")]
    [Description("Puts players in a permissions group on disconnect if sleeping")]
    class SleeperGroup : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Sleeper group name")]
            public string SleeperGroup = "sleeper";

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        private void Init()
        {
            if (!permission.GroupExists(config.SleeperGroup))
            {
                permission.CreateGroup(config.SleeperGroup, config.SleeperGroup, 0);
            }
        }

        private void OnUserConnected(IPlayer player)
        {
            if (player.BelongsToGroup(config.SleeperGroup))
            {
                player.RemoveFromGroup(config.SleeperGroup);
            }
        }

        private void OnUserDisconnected(IPlayer player)
        {
            if (player.IsSleeping && !player.BelongsToGroup(config.SleeperGroup))
            {
                player.AddToGroup(config.SleeperGroup);
            }
        }
    }
}


// --- End of file: SleeperGroup.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/staff-roster ---
// --- Original File Path: S/StaffRoster/StaffRoster.cs ---

ï»¿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Staff Roster", "Mr. Blue", "2.0.1")]
    [Description("Shows staff roster and availability")]

    class StaffRoster : CovalencePlugin
    {
        #region Variables
        private Dictionary<IPlayer, StaffMember> staffMembers = new Dictionary<IPlayer, StaffMember>();
        private PluginConfig config = null;
        #endregion

        #region Config
        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig()
            {
                staffStatuses = new List<StaffStatus>()
                {
                    new StaffStatus("Available", "available", "green"),
                    new StaffStatus("Off-Duty", "od", "#FF0000"),
                    new StaffStatus("Busy", "busy", "yellow"),
                    new StaffStatus("Afk", "afk", "orange")
                },
                staffGroups = new List<StaffGroup>()
                {
                    new StaffGroup("admin", 1, "<color=red>Admin</color>"),
                    new StaffGroup("mod", 2, "<color=orange>Mod</color>"),
                    new StaffGroup("helper", 3, "<color=yellow>Helper</color>")
                }
            };
            Config.WriteObject(config, true);
        }
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                {"StaffList","<color=orange>StaffRoster</color>: Current Staff online are:"},
                {"StaffEntry","{Title} <color=orange>{Player}</color> Status: {Status}"},
                {"NoStaff","<color=orange>StaffRoster</color>: Current there is no staff online."},
                {"NoPermission","<color=orange>StaffRoster</color>: Only staff members are able to use this command."},
                {"StatusChanged","<color=orange>StaffRoster</color>: {Title} {Player} has changed their status to: {Status}"},
                {"SameStatus","<color=orange>StaffRoster</color>: You already have that status."},
                {"StatusInvalid","<color=orange>StaffRoster</color>: Invalid status, available statuses:\n{Statuses}"}
            };
            lang.RegisterMessages(messages, this);
        }

        string Msg(string msg, string SteamId = null) => lang.GetMessage(msg, this, SteamId);
        #endregion

        #region Classes
        class PluginConfig
        {
            [JsonProperty("Statuses")]
            public List<StaffStatus> staffStatuses = new List<StaffStatus>();
            [JsonProperty("Groups")]
            public List<StaffGroup> staffGroups = new List<StaffGroup>();
        }

        class StaffMember
        {
            public StaffGroup Group;
            public StaffStatus Status;

            public StaffMember(StaffGroup group, StaffStatus status)
            {
                Group = group;
                Status = status;
            }
        }

        class StaffGroup
        {
            [JsonProperty("Group (Oxide group name)")]
            public string GroupName;
            public int Priority;
            public string Title;
            
            public StaffGroup(string groupName, int priority, string title)
            {
                GroupName = groupName;
                Priority = priority;
                Title = title;
            }
        }

        class StaffStatus
        {
            public string Title;
            public string Command;
            public string Color;

            public StaffStatus(string title, string command, string color)
            {
                Title = title;
                Command = command;
                Color = color;
            }
        }
        #endregion

        #region Helpers
        private StaffGroup GetStaffGroup(IPlayer player)
        {
            StaffGroup selectedStaffGroup = null;
            foreach (StaffGroup staffGroup in config.staffGroups)
                if (permission.UserHasGroup(player.Id, staffGroup.GroupName) && (selectedStaffGroup == null || selectedStaffGroup.Priority > staffGroup.Priority))
                    selectedStaffGroup = staffGroup;
            
            return selectedStaffGroup;
        }
        #endregion

        #region Hooks
        void OnServerInitialized()
        {
            foreach (IPlayer p in players.Connected)
            {
                StaffGroup staffGroup = GetStaffGroup(p);
                if (staffGroup != null)
                    staffMembers.Add(p, new StaffMember(staffGroup, config.staffStatuses.First()));
            }
        }

        void OnUserConnected(IPlayer player)
        {
            StaffGroup staffGroup = GetStaffGroup(player);
            if (staffGroup != null)
                staffMembers.Add(player, new StaffMember(staffGroup, config.staffStatuses.First()));
        }

        void OnUserDisconnected(IPlayer player)
        {
            if (staffMembers.ContainsKey(player))
                staffMembers.Remove(player);
        }
        #endregion

        #region Commands
        [Command("staff")]
        private void StaffCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                if (staffMembers.Count == 0)
                {
                    player.Reply(Msg("NoStaff", player.Id));
                    return;
                }

                player.Reply(Msg("StaffList", player.Id));

                IOrderedEnumerable<KeyValuePair<IPlayer, StaffMember>> sortedStaff = staffMembers.OrderBy(o => o.Value.Group.Priority);

                foreach (KeyValuePair<IPlayer, StaffMember> staffMember in sortedStaff)
                {
                    player.Reply(Msg("StaffEntry", player.Id)
                        .Replace("{Title}", staffMember.Value.Group.Title)
                        .Replace("{Player}", staffMember.Key.Name)
                        .Replace("{Status}", $"<color={staffMember.Value.Status.Color}>{staffMember.Value.Status.Title}</color>"));    
                }
            }
            if (args.Length == 1)
            {
                IEnumerable<StaffStatus> newStatuses = config.staffStatuses.Where(s => s.Command.ToLower() == args[0].ToLower());
                if (newStatuses == null || newStatuses.Count() < 1)
                {
                    List<string> Statuses = new List<string>();

                    foreach (StaffStatus staffStatus in config.staffStatuses)
                        Statuses.Add($"<color={staffStatus.Color}>{staffStatus.Title}</color> ({staffStatus.Command})");

                    string statuses = string.Join(", ", Statuses.ToArray());

                    player.Reply(Msg("StatusInvalid", player.Id)
                        .Replace("{Statuses}", statuses));
                    return;
                }

                StaffStatus newStatus = newStatuses.First();
                StaffMember staffMember = staffMembers[player];
                if (newStatus == staffMember.Status)
                {
                    player.Reply(Msg("SameStatus", player.Id));
                    return;
                }

                staffMember.Status = newStatus;

                string statusString = $"<color={newStatus.Color}>{newStatus.Title}</color>";
                foreach (IPlayer p in players.Connected)
                {
                    p.Message(Msg("StatusChanged", p.Id)
                        .Replace("{Title}", staffMember.Group.Title)
                        .Replace("{Player}", player.Name)
                        .Replace("{Status}", statusString));
                }
                return;
            }
        }
        #endregion
    }
}

// --- End of file: StaffRoster.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/simple-sort ---
// --- Original File Path: S/SimpleSort/SimpleSort.cs ---

ï»¿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Simple Sort", "birthdates", "1.0.7")]
    [Description("A UI supported sorting system for storage, based for performance and simplicity")]
    public class SimpleSort : RustPlugin
    {
        #region Variables

        private const string permission_use = "simplesort.use";
        private CuiElementContainer cuiElements;

        #endregion

        #region Core

        private void Init()
        {
            LoadConfig();
            permission.RegisterPermission(permission_use, this);
            cuiElements = new CuiElementContainer
            {
                {
                    new CuiButton
                    {
                        Text =
                        {
                            Text = _config.Ui.Text,
                            Color = ToUnityColor(_config.Ui.TextColor),
                            FontSize = _config.Ui.FontSize,
                            Align = TextAnchor.MiddleCenter,
                            FadeIn = 0.15f
                        },
                        Button =
                        {
                            Color = ToUnityColor(_config.Ui.Color),
                            FadeIn = 0.15f,
                            Command = "SimpleSort:Sort"
                        },
                        RectTransform =
                        {
                            AnchorMin = _config.Ui.AnchorMin,
                            AnchorMax = _config.Ui.AnchorMax
                        }
                    },
                    "Overlay",
                    "SimpleSortUI"
                }
            };
        }

        private void OnLootEntity(BasePlayer player, StorageContainer entity)
        {
            if (!(entity is BoxStorage) || _config.Blocked.Contains(entity.ShortPrefabName) || _config.Blocked.Contains(entity.PrefabName)) return;
            OpenUI(player);
        }

        private void OnLootEntityEnd(BasePlayer player)
        {
            CloseUI(player);
        }

        private static void CloseUI(BasePlayer Player)
        {
            CuiHelper.DestroyUi(Player, "SimpleSortUI");
        }

        private void OpenUI(BasePlayer Player)
        {
            if (!Player.IPlayer.HasPermission(permission_use)) return;
            CuiHelper.AddUi(Player, cuiElements);
        }

        [ConsoleCommand("SimpleSort:Sort")]
        private void ConsoleCommand(ConsoleSystem.Arg Arg)
        {
            var Player = Arg.Player();
            if (!Player || !Player.IPlayer.HasPermission(permission_use) ||
                Player.inventory.loot.containers.Count < 1) return;
            var Container = Player.inventory.loot.containers[0];
            if (Container == null || Container.itemList.Count < 1) return;
            var a = Container.itemList;
            a.Sort((x, y) => x.info.itemid.CompareTo(y.info.itemid) + x.skin.CompareTo(y.skin));
            a = a.OrderBy(b => b.info.category).ToList();
            while (Container.itemList.Count > 0) Container.itemList[0].RemoveFromContainer();

            foreach (var c in a) c.MoveToContainer(Container);
        }

        private ConfigFile _config;

        public class UI
        {
            [JsonProperty("Anchor Max")] public string AnchorMax;

            [JsonProperty("Anchor Min")] public string AnchorMin;

            [JsonProperty("Hex Color")] public string Color;

            [JsonProperty("Font Size")] public int FontSize;

            [JsonProperty("Text")] public string Text;

            [JsonProperty("Text Color")] public string TextColor;
        }

        public class ConfigFile
        {
            [JsonProperty("UI Settings")] public UI Ui;

            [JsonProperty("Blocked Items (short or long prefabs accepted)")] public List<string> Blocked;
            public static ConfigFile Default()
            {
                return new ConfigFile
                {
                    Ui = new UI
                    {
                        AnchorMin = "0.6564 0.1",
                        AnchorMax = "0.7 0.15",
                        Color = "#6f8344",
                        FontSize = 13,
                        Text = "Sort",
                        TextColor = "#A5BA7A"
                    },
                    Blocked = new List<string>()
                    {
                        "locker.deployed"
                    }
                };
            }
        }

        private static string ToUnityColor(string hexColor)
        {
            var BaseColor = new Color();
            return !ColorUtility.TryParseHtmlString(hexColor, out BaseColor)
                ? "1 1 1 1"
                : $"{BaseColor.r} {BaseColor.g} {BaseColor.b} {BaseColor.a}";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null) LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.Default();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
    }
}
//Generated with birthdates' Plugin Maker

// --- End of file: SimpleSort.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/spawn-entity-group ---
// --- Original File Path: S/SpawnEntityGroup/SpawnEntityGroup.cs ---

using System;
using System.Linq;
using System.Collections.Generic;
using Oxide.Core;
using Newtonsoft.Json;
using UnityEngine;
using Rust;

namespace Oxide.Plugins
{
    [Info("Spawn Entity Group", "Obito", "1.0.3")]
    [Description("Random spawn a custom entity group in a random map location")]

    class SpawnEntityGroup : RustPlugin
    {
        #region Defaults

        private float terrainSize = TerrainMeta.Size.x;

        #endregion

        #region Oxide Hooks

        void OnServerInitialized()
        {
            timer.Every(config.spawnTime, () => {
                Vector3 pos = GetGroundPosition((Vector3)GetSpawnPos());
                SpawnLooter(pos);
                if (config.consoleLog)
                {
                    Puts(string.Format(config.logMsg, pos));
                }
            });
        }

        #endregion

        #region Helpers

        public void SpawnLooter(Vector3 pos)
        {
            if(pos != null)
            {
                foreach(var value in config.entities)
                {
                    var prefab = value.prefab;
                    var position = pos + GetVector(value);
                    var entity = GameManager.server.CreateEntity(prefab, position);
                    if (entity == null) continue;
                    entity?.Spawn();
                    AddRigidbody(entity);
                }
            }
        }

        private void AddRigidbody(BaseEntity entity)
        {
            Rigidbody rigidbody = entity.gameObject.GetComponent<Rigidbody>();
            if (rigidbody == null) rigidbody = entity.gameObject.AddComponent<Rigidbody>();
            rigidbody.useGravity = false;
            rigidbody.drag = 0.3f;
            rigidbody.isKinematic = true;
            var mesh = (MeshCollider)entity.gameObject.GetComponent<MeshCollider>();
            if (mesh == null) mesh = entity.gameObject.AddComponent<MeshCollider>();
            mesh.convex = false;
        }

        private Vector3 GetVector(EntityData ent)
        {
            return new Vector3(ent.x, ent.y, ent.z);
        }

        #region Method by 'Egor Blagov' from plugin Random Respawner

        private Vector3? GetSpawnPos() 
        {
            for (int i = 0; i < 150; i++) 
            {
                Vector3 randomPos = new Vector3(
                    UnityEngine.Random.Range(-TerrainMeta.Size.x / 4, TerrainMeta.Size.x / 4),
                    10f,
                    UnityEngine.Random.Range(-TerrainMeta.Size.z / 4, TerrainMeta.Size.z / 4)
                );

                if (this.TestPosIsValid(ref randomPos)) 
                {
                    return randomPos;
                }
            }

            return null;
        }

        private bool TestPosIsValid(ref Vector3 randomPos) {
            RaycastHit hitInfo;


            if (WaterLevel.Test(randomPos + new Vector3(0, 1.3f, 0))) 
            {
                return false;
            }

            var colliders = new List<Collider>();
            Vis.Colliders(randomPos, 3f, colliders);

            if (colliders.Where(col => col.name.ToLower().Contains("prevent") && col.name.ToLower().Contains("building")).Count() > 0) 
            {
                return false;
            }

            var entities = new List<BaseEntity>();
            Vis.Entities(randomPos, 3f, entities);
            if (entities.Where(ent => ent is BaseHelicopter).Count() > 0) 
            {
                return false;
            }

            if (10f > 0) 
            {
                var players = new List<BasePlayer>();
                Vis.Entities(randomPos, 10f, players);
                if (players.Count > 0) {
                    return false;
                }
            }

            var cupboards = new List<BuildingPrivlidge>();
            Vis.Entities(randomPos, 20f + 10f, cupboards);
            if (cupboards.Count > 0) 
            {
                return false;
            }

            return true;
        }

        #endregion

        //Credits: Wulf
        private static LayerMask GROUND_MASKS = LayerMask.GetMask("Terrain", "World", "Construction");
        static Vector3 GetGroundPosition(Vector3 sourcePos)
        {
            RaycastHit hitInfo;            
            if (Physics.Raycast(sourcePos, Vector3.down, out hitInfo, GROUND_MASKS)){
                sourcePos.y = hitInfo.point.y;
            }
            sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));
            return sourcePos;
        }

        #endregion

        #region Config

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Spawn time")]
            public float spawnTime { get; set; }

            [JsonProperty(PropertyName = "Show console log")]
            public bool consoleLog { get; set; }

            [JsonProperty(PropertyName = "Log message")]
            public string logMsg { get; set; }

            [JsonProperty(PropertyName = "Entities")]
            public List<EntityData> entities;
        }

        private class EntityData
        {
            public string prefab;
            public float x;
            public float y;
            public float z;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                spawnTime = 300f,
                consoleLog = true,
                logMsg = "A entity group spawned at: {0}",

                entities = new List<EntityData>()
                {
                    new EntityData()
                    {
                        prefab = "assets/bundled/prefabs/radtown/loot_barrel_1.prefab",
                        x = 1f,
                        y = 0f,
                        z = 0f
                    },
                    new EntityData()
                    {
                        prefab = "assets/bundled/prefabs/radtown/loot_barrel_2.prefab",
                        x = -1f,
                        y = 0f,
                        z = 0f
                    },
                    new EntityData()
                    {
                        prefab = "assets/bundled/prefabs/radtown/crate_normal_2.prefab",
                        x = 0f,
                        y = 0f,
                        z = 0f
                    },
                    new EntityData()
                    {
                        prefab = "assets/prefabs/npc/patrol helicopter/heli_crate.prefab",
                        x = 0f,
                        y = 1.5f,
                        z = 0f
                    }
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("The default configuration file has been created!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: SpawnEntityGroup.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/security-lights ---
// --- Original File Path: S/SecurityLights/SecurityLights.cs ---

ï»¿/// <summary>
/// Author: S0N_0F_BISCUIT
/// Permissions:
///		securitylights.use - Allows players to use commands
///	Chat Commands:
///		/sl - Help information
///		/sl add - Converts the search light you are looking at to a security light
///		/sl remove - Converts the security light you are looking at to back to a search light
///		/sl mode <mode> - Sets the mode of the security light you are looking at
///		/sl globalmode <mode> - Sets the mode of all security lights you own
///		/sl info - Gives the owner the ability to check the status of a search light
///		/sl reloadconfig - Reloads the config file
///		<mode>
///			all - Targets players and helicopter
///			players - Targets players only
///			heli - Targets heli only
///		</mode>
/// </summary>
using System;
using System.Collections.Generic;

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Rust;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Security Lights", "S0N_0F_BISCUIT", "1.1.11")]
    [Description("Search light targeting system")]
    class SecurityLights : RustPlugin
    {
        #region Variables
        /// <summary>
        /// References to other plugins
        /// </summary>
        [PluginReference]
        Plugin Clans, Friends, Vanish;
        /// <summary>
        /// Targeting mode for security lights
        /// </summary>
        public enum TargetMode { all, players, heli, lightshow };
        /// <summary>
        /// Configuration options
        /// </summary>
        class ConfigData
        {
            [JsonProperty("Detection Radius - All")]
            public int allDetectionRadius = 30;

            [JsonProperty("Tracking Radius - All")]
            public int allTrackingRadius = 30;

            [JsonProperty("Detection Radius - Player")]
            public int playerDetectionRadius = 30;

            [JsonProperty("Tracking Radius - Player")]
            public int playerTrackingRadius = 30;

            [JsonProperty("Detection Radius - Helicopter")]
            public int heliDetectionRadius = 100;

            [JsonProperty("Tracking Radius - Helicopter")]
            public int heliTrackingRadius = 100;

            [JsonProperty("Heli Mode - Target Minicopter and Scrap Heli")]
            public bool heliTargetVehicles = false;

            [JsonProperty("Auto Convert Lights When Placed")]
            public bool autoConvert = false;

            [JsonProperty("Require Power")]
            public bool requirePower = true;

            [JsonProperty("Night Only Operation")]
            public bool nightOnly = false;

            [JsonProperty("Target Acquired Sound")]
            public bool acquisitionSound = true;

            [JsonProperty("Target Friends")]
            public bool targetFriends = true;

            [JsonProperty("Target Team Members")]
            public bool targetTeamMembers = true;
        }
        /// <summary>
        /// Data saved by the plugin
        /// </summary>
        class StoredData
        {
            public Dictionary<ulong, TargetMode> Security_Lights { get; set; } = new Dictionary<ulong, TargetMode>();
        }
        /// <summary>
        /// Permissions used by the plugin
        /// </summary>
        static class Permissions
        {
            static readonly public string use = "securitylights.use";
        }
        /// <summary>
        /// Main behaviour of security lights
        /// </summary>
        class SecurityLight : MonoBehaviour
        {
            #region Variables
            private ulong id;
            private SearchLight light { get; set; } = null;
            private TargetMode mode { get; set; } = TargetMode.all;
            private bool powered = false;
            public BaseCombatEntity target = null;
            #endregion

            #region Initialization
            /// <summary>
            /// Initialize security light
            /// </summary>
            private void Awake()
            {
                light = GetComponent<SearchLight>();
                id = light.net.ID.Value;
                if (!instance.data.Security_Lights.ContainsKey(id))
                    instance.data.Security_Lights.Add(id, mode);
                mode = instance.data.Security_Lights[id];
                instance.securityLights.Add(this);
                instance.SaveData();

                gameObject.layer = (int)Layer.Reserved1;
                var collider = gameObject.GetComponent<SphereCollider>();
                if (collider != null)
                    Destroy(collider);
                collider = gameObject.AddComponent<SphereCollider>();
                collider.center = Vector3.zero;
                collider.radius = instance.config.allDetectionRadius;
                collider.isTrigger = true;
                collider.enabled = true;

                ResetTarget();
            }
            #endregion

            #region Functionality
            /// <summary>
            /// New entity in range
            /// </summary>
            /// <param name="range"></param>
            private void OnTriggerEnter(Collider range)
            {
                BaseCombatEntity entity = range.GetComponentInParent<BaseCombatEntity>();

                // Check if entity is valid
                if (!IsValid(entity))
                    return;
                // Check for current target
                if (target != null)
                    return;
                // Acquire new target
                if (ShouldTarget(entity))
                    SetTarget(entity);
            }
            /// <summary>
            /// Update entities within range
            /// </summary>
            /// <param name="range"></param>
            private void OnTriggerStay(Collider range)
            {
                BaseCombatEntity entity = range.GetComponentInParent<BaseCombatEntity>();

                // Check if entity is valid
                if (!IsValid(entity))
                    return;
                // Check for current target
                if (target != null)
                    return;
                // Acquire new target
                if (ShouldTarget(entity))
                    SetTarget(entity);
            }
            /// <summary>
            /// Entity leaving range
            /// </summary>
            /// <param name="range"></param>
            private void OnTriggerExit(Collider range)
            {
                BaseCombatEntity entity = range.GetComponentInParent<BaseCombatEntity>();

                // Check if entity is valid
                if (!IsValid(entity))
                    return;
                // Reset the target if target leaves range
                if (IsTargeting(entity))
                    ResetTarget();
            }
            /// <summary>
            /// Update the target if in lightshow mode also make sure current target is valid
            /// </summary>
            private void Update()
            {
                if (mode == TargetMode.lightshow)
                {
                    BaseCombatEntity owner = instance.GetPlayer(OwnerID()) as BaseCombatEntity;
                    if (!ShouldTarget(owner))
                        return;
                    if (!IsTargeting(owner))
                        SetTarget(owner);
                    else
                        UpdateTarget();
                }
                else if (target != null)
                {
                    if (ShouldTarget(target))
                        UpdateTarget();
                    else
                        ResetTarget();
                }

                if (light.currentEnergy >= light.DesiredPower())
                    powered = true;
                else
                    powered = false;
            }
            /// <summary>
            /// Destroy the the security light
            /// </summary>
            public void OnDestroy()
            {
                if (!instance.unloading)
                {
                    if (instance.data.Security_Lights.ContainsKey(id))
                        instance.data.Security_Lights.Remove(id);
                    if (instance.securityLights.Contains(this))
                        instance.securityLights.Remove(this);
                }

                instance.SaveData();

                Destroy(this);
            }
            #endregion

            #region Targeting
            /// <summary>
            /// Check if entity should be targeted
            /// </summary>
            /// <param name="entity"></param>
            /// <returns></returns>
            private bool ShouldTarget(BaseCombatEntity entity)
            {
                try
                {
                    // Check if light is mounted
                    if (light.IsMounted())
                        return false;
                    // If power is required, check if light is powered
                    if (instance.config.requirePower && !powered)
                        return false;
                    // Check if target is valid
                    if (!IsValid(entity))
                        return false;
                    // Check if in lightshow mode
                    if (mode == TargetMode.lightshow)
                        return true;
                    // Check if auto-lights are enabled
                    if (!instance.lightsEnabled)
                        return false;
                    if (mode != TargetMode.heli)
                    {
                        // Check if light has line of sight
                        if (!HasLoS(entity))
                            return false;
                        // Check if owner already targeting entity
                        if (!IsTargeting(entity))
                        {
                            if (instance.IsOwnerTargeting(OwnerID(), entity))
                                return false;
                            // Check if light is the closest valid light
                            else if (!instance.IsClosest(entity, id))
                                return false;
                        }
                        // Check if entity is a BasePlayer and not an NPCPlayer
                        if (entity.GetType() == typeof(BasePlayer) && !(entity is NPCPlayer))
                            return ShouldTargetPlayer(entity as BasePlayer);
                        // Check driver of vehicle
                        if (entity is BaseVehicle)
                            return ShouldTargetPlayer((entity as BaseVehicle).GetDriver());
                    }
                    else if (entity is BaseHelicopter)
                    {
                        if (instance.config.heliTargetVehicles)
                            return ShouldTargetPlayer((entity as BaseHelicopter).GetDriver());

                        return false;
                    }
                    return true;
                }
                catch
                {
                    return false;
                }
            }
            /// <summary>
            /// Check if player should be targeted
            /// </summary>
            /// <param name="player"></param>
            /// <returns></returns>
            private bool ShouldTargetPlayer(BasePlayer player)
            {
                if (player == null)
                    return false;
                try
                {
                    // Check if player is authorized on the light
                    if (instance.IsAuthorized(player, light))
                        return false;
                    // Make sure player is not NPC
                    if (instance.GetPlayer(player.userID) == null)
                        return false;
                    // Check if player has building privlege
                    if (HasBuildingPrivilege(player))
                        return false;
                    // Check if player is crouched
                    if (player.IsDucked() && player != light.lastAttacker)
                        return false;
                    // Check if player is invisible
                    if (instance.IsInvisible(player))
                        return false;
                    // Check if player is a friend
                    if (!instance.config.targetFriends)
                        if (instance.IsFriend(OwnerID(), player.userID))
                            return false;
                    // Check if player is a team member
                    if (!instance.config.targetTeamMembers)
                        if (instance.GetPlayer(OwnerID()).currentTeam == player.currentTeam && player.currentTeam != 0)
                            return false;

                    return true;
                }
                catch { return false; }
            }
            /// <summary>
            /// Set the lights target
            /// </summary>
            /// <param name="entity"></param>
            private void SetTarget(BaseCombatEntity entity)
            {
                if (entity == null)
                    return;
                target = entity;

                if (entity is BasePlayer)
                    light.SetTargetAimpoint(entity.transform.position + Vector3.up);
                else
                    light.SetTargetAimpoint(entity.transform.position);

                if (instance.config.acquisitionSound)
                    Effect.server.Run("assets/prefabs/npc/autoturret/effects/targetacquired.prefab", light.eyePoint.transform.position);

                if (!instance.config.requirePower)
                {
                    light.UpdateHasPower(light.DesiredPower(), 0);
                    light.SetFlag(BaseEntity.Flags.Reserved8, true);
                }
                else if (powered)
                {
                    light.SetFlag(BaseEntity.Flags.Reserved8, true);
                }

                light.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                SphereCollider collider = gameObject.GetComponent<SphereCollider>();
                collider.radius = GetTrackingRadius();
            }
            /// <summary>
            /// Update the lights target
            /// </summary>
            private void UpdateTarget()
            {
                if (target is BasePlayer || target is NPCPlayer)
                    light.SetTargetAimpoint(target.transform.position + Vector3.up);
                else
                    light.SetTargetAimpoint(target.transform.position);

                if (instance.config.requirePower && !powered)
                    ResetTarget();

                light.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }
            /// <summary>
            /// Reset the lights target
            /// </summary>
            public void ResetTarget()
            {
                target = null;
                light.SetTargetAimpoint(light.eyePoint.transform.position + Vector3.down * 3);
                light.SetFlag(BaseEntity.Flags.Reserved8, false);
                light.SetFlag(BaseEntity.Flags.On, false);
                light.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                SphereCollider collider = gameObject.GetComponent<SphereCollider>();
                collider.radius = GetDetectionRadius();
            }
            #endregion

            #region Helpers
            /// <summary>
            /// Check if the light is targeting an entity
            /// </summary>
            /// <param name="entity"></param>
            /// <returns></returns>
            public bool IsTargeting(BaseCombatEntity entity = null)
            {
                if (entity != null && target != null)
                    if (target == entity)
                        return true;
                if (target != null && entity == null)
                    return true;
                return false;
            }
            /// <summary>
            /// Check if entity is a valid target
            /// </summary>
            /// <param name="entity"></param>
            /// <returns></returns>
            private bool IsValid(BaseCombatEntity entity)
            {
                if (!entity)
                    return false;

                switch (mode)
                {
                    case TargetMode.all:
                        return entity is BasePlayer ||
                               entity is PatrolHelicopter ||
                               entity is NPCPlayer ||
                               entity is BaseVehicle;
                    case TargetMode.players:
                        return (entity is BasePlayer && !(entity is NPCPlayer)) ||
                               entity is BaseVehicle;
                    case TargetMode.heli:
                        return entity is PatrolHelicopter  ||
                               entity is CH47Helicopter ||
                               entity is BaseHelicopter;
                    case TargetMode.lightshow:
                        return entity == instance.GetPlayer(OwnerID());
                    default:
                        return false;
                }
            }
            /// <summary>
            /// Find first object in line of sight
            /// </summary>
            /// <typeparam name="T"></typeparam>
            /// <param name="ray"></param>
            /// <param name="distance"></param>
            /// <returns></returns>
            private object RaycastAll<T>(Ray ray, float distance)
            {
                var hits = Physics.RaycastAll(ray, distance, Layers.Solid, QueryTriggerInteraction.Ignore);
                GamePhysics.Sort(hits);
                object target = false;
                foreach (var hit in hits)
                {
                    var ent = hit.GetEntity();
                    if (ent is T)
                    {
                        target = ent;
                        break;
                    }
                }
                return target;
            }
            /// <summary>
            /// Check if light has line of sight to entity
            /// </summary>
            /// <param name="entity"></param>
            /// <returns></returns>
            public bool HasLoS(BaseCombatEntity entity)
            {
                if (!IsValid(entity))
                    return false;
                if (entity is PatrolHelicopter)
                    return true;

                Ray ray = new Ray(light.eyePoint.transform.position, entity.transform.position - light.transform.position);
                ray.origin += ray.direction / 2;
                float distance = gameObject.GetComponent<SphereCollider>().radius;

                var foundEntity = RaycastAll<BaseNetworkable>(ray, distance);

                if (foundEntity is BaseCombatEntity)
                {
                    if (entity == foundEntity as BaseCombatEntity)
                        return true;
                }
                return false;
            }
            /// <summary>
            /// Destroy collider
            /// </summary>
            public void DestroyLight()
            {
                ResetTarget();
                Destroy(this);
            }
            /// <summary>
            /// Get the detection radius for the current mode
            /// </summary>
            /// <returns></returns>
            private float GetDetectionRadius()
            {
                if (mode == TargetMode.all)
                    return instance.config.allDetectionRadius;
                if (mode == TargetMode.players)
                    return instance.config.playerDetectionRadius;
                if (mode == TargetMode.heli)
                    return instance.config.heliDetectionRadius;
                return 0;
            }
            /// <summary>
            /// Get the tracking radius for the current mode
            /// </summary>
            /// <returns></returns>
            private float GetTrackingRadius()
            {
                if (mode == TargetMode.all)
                    return instance.config.allTrackingRadius;
                if (mode == TargetMode.players)
                    return instance.config.playerTrackingRadius;
                if (mode == TargetMode.heli)
                    return instance.config.heliTrackingRadius;
                return 0;
            }
            /// <summary>
            /// Return the light's owner ID
            /// </summary>
            /// <returns></returns>
            public ulong OwnerID()
            {
                return light.OwnerID;
            }
            /// <summary>
            /// Return the light's ID
            /// </summary>
            /// <returns></returns>
            public ulong ID()
            {
                return id;
            }
            /// <summary>
            /// Return the position of the light
            /// </summary>
            /// <returns></returns>
            public Vector3 Position()
            {
                return light.eyePoint.transform.position;
            }
            /// <summary>
            /// Change the operation mode
            /// </summary>
            /// <param name="newMode"></param>
            public void ChangeMode(TargetMode newMode)
            {
                if ((mode == TargetMode.lightshow && newMode != TargetMode.lightshow) || newMode == TargetMode.heli || newMode == TargetMode.lightshow)
                    ResetTarget();
                mode = newMode;
                instance.data.Security_Lights[id] = mode;
                instance.SaveData();

                UpdateRadius();
            }
            /// <summary>
            /// Return the operation mode
            /// </summary>
            /// <returns></returns>
            public TargetMode Mode()
            {
                return mode;
            }
            /// <summary>
            /// Update the detection/targeting radii
            /// </summary>
            public void UpdateRadius()
            {
                SphereCollider collider = gameObject.GetComponent<SphereCollider>();
                if (IsTargeting())
                    collider.radius = GetTrackingRadius();
                else
                    collider.radius = GetDetectionRadius();
            }
            /// <summary>
            /// Check if the player has building privledge
            /// </summary>
            /// <param name="player"></param>
            /// <returns></returns>
            private bool HasBuildingPrivilege(BasePlayer player)
            {
                BuildingPrivlidge buildingPrivlidge = player.GetBuildingPrivilege(player.WorldSpaceBounds());
                if (buildingPrivlidge)
                    if (buildingPrivlidge.IsAuthed(player))
                        return true;
                return false;
            }
            #endregion
        }

        static SecurityLights instance;
        private ConfigData config = new ConfigData();
        private StoredData data;
        private List<SecurityLight> securityLights = new List<SecurityLight>();
        private bool lightsEnabled = true;
        private bool unloading = false;
        #endregion

        #region Localization
        /// <summary>
        /// Load messages relayed to player
        /// </summary>
        private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["InvalidTarget"] = "Invalid Target!",
                ["NoPermission"] = "You do not have permission to use this {0} light!",
                ["Convert"] = "Converted to a security light.",
                ["AlreadySL"] = "This is already a security light.",
                ["Revert"] = "Converted to search light.",
                ["NotSL"] = "This is not a security light.",
                ["AllMode"] = "Targeting players and helicopters.",
                ["PlayersMode"] = "Targeting only players.",
                ["HeliMode"] = "Targeting only helicopters.",
                ["LightshowMode"] = "Targeting owner for a lightshow!",
                ["ModeUsage"] = "Usage: /sl mode <all|players|heli|lightshow>",
                ["GlobalModeUsage"] = "Usage: /sl globalmode <all|players|heli|lightshow>",
                ["GlobalChange"] = "Changed {0} light(s) to {1} mode.",
                ["Unknown"] = "Unknown",
                ["SecurityLight"] = "Security Light",
                ["SearchLight"] = "Search Light",
                ["NoCommandPermission"] = "You do not have permission to use this command!",
                ["False"] = "False",
                ["True"] = "True",
                ["SecurityInfo"] = "Owner: {0}\nState: {1}\nMode: {2}\nTargeting: {3}",
                ["SearchInfo"] = "Owner: {0}\nState: {1}",
                ["DataReload"] = "Reloaded plugin data.",
                ["ConfigReload"] = "Reloaded plugin config.",
                ["ConfigInfo"] = "Configuration Info: \nRadius: (Detection,Tracking)\nRadius - All: ({0},{1})\nRadius - Players: ({2},{3})\nRadius - Helicopters: ({4},{5})\nAuto-Convert: {6}\nRequire Power: {7}\nNight Only Operation: {8}\nTarget Acquired Sound: {9}",
                ["AdminUsage"] = "Usage: /sl <add|remove|mode|globalmode|info|reloaddata|reloadconfig>",
                ["Usage"] = "Usage: /sl <add|remove|mode|globalmode|info>",
                ["Search"] = "search",
                ["Security"] = "security"
            }, this);
            // German
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["InvalidTarget"] = "Ungueltiges VerfolgungsZiel ...",
                ["NoPermission"] = "Du hast keine Erlaubnis zum benutzen dieses {0} Scheinwerfers ...",
                ["Convert"] = "... geaendert zu SicherheitsScheinwerfer",
                ["AlreadySL"] = "Dies ist schon ein SicherheitsScheinwerfer ...",
                ["Revert"] = "... geaendert zu normalen SuchScheinwerfer",
                ["NotSL"] = "Dies ist kein SicherheitsScheinwerfer ...",
                ["AllMode"] = "Ziele sind jetzt alle normalen Spieler & Helikopter ...",
                ["PlayersMode"] = "Ziel sind jetzt nur normale Spieler ...",
                ["HeliMode"] = "Ziel sind jetzt nur Helikopter ...",
                ["LightshowMode"] = "Ziel ist jetzt nur der ServerOwner ...",
                ["ModeUsage"] = "benutze: /sl mode <all | players | heli | lightshow>",
                ["GlobalModeUsage"] = "benutze: /sl globalmode <all | players | heli | lightshow>",
                ["GlobalChange"] = "Geaendert {0} Scheinwerfer in {1}Modus ...",
                ["Unknown"] = "Unbekannt !",
                ["SecurityLight"] = "SicherheitsScheinwerfer",
                ["SearchLight"] = "SuchScheinwerfer",
                ["NoCommandPermission"] = "Du hast keine Erlaubnis zum benutzen des Befehls ...",
                ["False"] = "False",
                ["True"] = "True",
                ["SecurityInfo"] = "Owner: {0}\nState: {1}\nMode: {2}\nTargeting: {3}",
                ["SearchInfo"] = "Owner: {0}\nState: {1}",
                ["DataReload"] = "... neuladen der DATA-Datei",
                ["ConfigReload"] = "... neuladen der CONFIG-Datei",
                ["ConfigInfo"] = "Configuration Info: \nRadius: (Detection,Tracking)\nRadius - All: ({0},{1})\nRadius - Players: ({2},{3})\nRadius - Helicopters: ({4},{5})\nAuto-Convert: {6}\nRequire Power: {7}\nNight Only Operation: {8}\nTarget Acquired Sound: {9}",
                ["AdminUsage"] = "benutze: /sl <add | remove | mode | globalmode | info | reloaddata | reloadconfig>",
                ["Usage"] = "benutze: /sl <add | remove | mode | globalmode | info>",
                ["Search"] = "search",
                ["Security"] = "security"
            }, this, "de");
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Plugin initialization
        /// </summary>
        private void Init()
        {
            // Permissions
            permission.RegisterPermission(Permissions.use, this);
            // Data
            LoadData();
        }
        /// <summary>
        /// Restore plugin data when server finishes startup
        /// </summary>
        void OnServerInitialized()
        {
            // Set instance
            instance = this;
            // Restore data
            FindSecurityLights();
            // Get time of day
            if (config.nightOnly && TOD_Sky.Instance.IsDay)
                lightsEnabled = false;
        }
        /// <summary>
        /// Unloading Plugin
        /// </summary>
        void Unload()
        {
            unloading = true;
            foreach (SecurityLight light in securityLights)
                light.DestroyLight();
            SaveData();
        }
        #endregion

        #region Config Handling
        /// <summary>
        /// Load default config file
        /// </summary>
        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }
        /// <summary>
        /// Load the config values to the config class
        /// </summary>
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Your configuration file is invalid");
                LoadDefaultConfig();
                return;
            }
            SaveConfig();
        }
        /// <summary>
        /// Save the config file
        /// </summary>
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        #endregion

        #region Data Handling
        /// <summary>
        /// Load plugin data
        /// </summary>
        private void LoadData()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("SecurityLights");
            }
            catch
            {
                data = new StoredData();
                SaveData();
            }
        }
        /// <summary>
        /// Save PlayerData
        /// </summary>
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("SecurityLights", data);
        }
        /// <summary>
        /// Find all security lights
        /// </summary>
        private void FindSecurityLights()
        {
            List<ulong> delete = new List<ulong>();
            foreach (ulong id in data.Security_Lights.Keys)
            {
                BaseNetworkable networkable = BaseNetworkable.serverEntities.Find(new NetworkableId(id));

                if (networkable is SearchLight)
                {
                    SecurityLight sl = networkable.gameObject.AddComponent<SecurityLight>();
                }
                else
                    delete.Add(id);
            }
            Puts($"Implemented {securityLights.Count} saved security lights.");
            foreach (ulong id in delete)
            {
                data.Security_Lights.Remove(id);
            }
        }
        /// <summary>
        /// Clear PlayerData
        /// </summary>
        private void ClearData()
        {
            data = new StoredData();
            SaveData();
        }
        #endregion

        #region Chat Commands
        /// <summary>
        /// Handle commands for plugin
        /// </summary>
        /// <param name="player"></param>
        /// <param name="command"></param>
        /// <param name="args"></param>
        [ChatCommand("sl")]
        void ManageSecurityLight(BasePlayer player, string command, string[] args)
        {
            // Check if player has permission to use security lights
            if (!permission.UserHasPermission(player.UserIDString, Permissions.use) && !IsDeveloper(player))
            {
                PrintToChat(player, Lang("NoCommandPermission", player.UserIDString));
                return;
            }
            // Get entity player is looking at
            var target = RaycastAll<BaseEntity>(player.eyes.HeadRay());
            SearchLight light = null;
            if (target is SearchLight)
                light = target as SearchLight;

            if (args.Length == 0)
                args = new string[] { String.Empty };
            switch (args[0].ToLower())
            {
                case "add":
                    if (!(target is SearchLight))
                    {
                        PrintToChat(player, Lang("InvalidTarget", player.UserIDString));
                        return;
                    }
                    if (light.gameObject.GetComponent<SecurityLight>() == null)
                    {
                        if (!IsAuthorized(player, light) && !IsDeveloper(player))
                        {
                            PrintToChat(player, Lang("NoPermission", player.UserIDString, Lang("Search", player.UserIDString)));
                            return;
                        }
                        light.gameObject.AddComponent<SecurityLight>();
                        PrintToChat(player, Lang("Convert", player.UserIDString));
                    }
                    else
                        PrintToChat(player, Lang("AlreadySL", player.UserIDString));
                    return;
                case "remove":
                    if (!(target is SearchLight))
                    {
                        PrintToChat(player, Lang("InvalidTarget", player.UserIDString));
                        return;
                    }
                    SecurityLight removeLight;
                    if ((removeLight = light.gameObject.GetComponent<SecurityLight>()) != null)
                    {
                        if (!IsAuthorized(player, light) && !IsDeveloper(player))
                        {
                            PrintToChat(player, Lang("NoPermission", player.UserIDString, Lang("Security", player.UserIDString)));
                            return;
                        }
                        removeLight.OnDestroy();
                        PrintToChat(player, Lang("Revert", player.UserIDString));
                    }
                    else
                        PrintToChat(player, Lang("NotSL", player.UserIDString));
                    return;
                case "mode":
                    if (!(target is SearchLight))
                    {
                        PrintToChat(player, Lang("InvalidTarget", player.UserIDString));
                        return;
                    }
                    SecurityLight modeLight;
                    if ((modeLight = light.gameObject.GetComponent<SecurityLight>()) != null)
                    {
                        if (!IsAuthorized(player, light) && !IsDeveloper(player))
                        {
                            PrintToChat(player, Lang("NoPermission", player.UserIDString, Lang("Security", player.UserIDString)));
                            return;
                        }
                        string option = String.Empty;
                        if (args.Length == 2)
                            option = args[1].ToLower();
                        switch (option)
                        {
                            case "all":
                                modeLight.ChangeMode(TargetMode.all);
                                PrintToChat(player, Lang("AllMode", player.UserIDString));
                                break;
                            case "players":
                                modeLight.ChangeMode(TargetMode.players);
                                PrintToChat(player, Lang("PlayersMode", player.UserIDString));
                                break;
                            case "heli":
                                modeLight.ChangeMode(TargetMode.heli);
                                PrintToChat(player, Lang("HeliMode", player.UserIDString));
                                break;
                            case "lightshow":
                                modeLight.ChangeMode(TargetMode.lightshow);
                                PrintToChat(player, Lang("LightshowMode", player.UserIDString));
                                break;
                            default:
                                PrintToChat(player, Lang("ModeUsage", player.UserIDString));
                                return;
                        }
                    }
                    else
                        PrintToChat(player, Lang("NotSL", player.UserIDString));
                    return;
                case "globalmode":
                    TargetMode globalmode;
                    int lightsChanged = 0;
                    string option2 = String.Empty;
                    if (args.Length == 2)
                        option2 = args[1].ToLower();
                    switch (option2)
                    {
                        case "all":
                            globalmode = TargetMode.all;
                            break;
                        case "players":
                            globalmode = TargetMode.players;
                            break;
                        case "heli":
                            globalmode = TargetMode.heli;
                            break;
                        case "lightshow":
                            globalmode = TargetMode.lightshow;
                            break;
                        default:
                            PrintToChat(player, Lang("GlobalModeUsage", player.UserIDString));
                            return;
                    }
                    foreach (SecurityLight currentLight in securityLights)
                    {
                        if (currentLight.OwnerID() == player.userID)
                        {
                            currentLight.ChangeMode(globalmode);
                            lightsChanged++;
                        }
                    }
                    PrintToChat(player, Lang("GlobalChange", player.UserIDString, lightsChanged, globalmode));
                    return;
                case "info":
                    if (!(target is SearchLight))
                    {
                        PrintToChat(player, Lang("InvalidTarget", player.UserIDString));
                        return;
                    }
                    if (!IsAuthorized(player, light) && !player.IsAdmin && !IsDeveloper(player))
                    {
                        PrintToChat(player, Lang("NoCommandPermission", player.UserIDString));
                        return;
                    }
                    string ownerString = Lang("Unknown");
                    if (GetPlayer(light.OwnerID) != null)
                        ownerString = GetPlayer(light.OwnerID).displayName;
                    SecurityLight infoLight;
                    if ((infoLight = light.gameObject.GetComponent<SecurityLight>()) != null)
                    {
                        string targeting = infoLight.IsTargeting() ? Lang("True", player.UserIDString) : Lang("False", player.UserIDString);
                        PrintToChat(player, Lang("SecurityInfo", player.UserIDString, ownerString, Lang("SecurityLight", player.UserIDString), infoLight.Mode().ToString(), targeting));
                    }
                    else
                        PrintToChat(player, Lang("SearchInfo", player.UserIDString, ownerString, Lang("SearchLight", player.UserIDString)));
                    if (IsDeveloper(player))
                        PrintToChat(player, $"Total Input Power: {light.currentEnergy}");
                    return;
                case "reloadconfig":
                    if (!player.IsAdmin)
                    {
                        PrintToChat(player, Lang("NoCommandPermission", player.UserIDString));
                        return;
                    }
                    LoadConfig();
                    PrintToChat(player, Lang("ConfigReload", player.UserIDString));
                    PrintToChat(player, Lang("ConfigInfo", player.UserIDString,
                        config.allDetectionRadius, config.allTrackingRadius,
                        config.playerDetectionRadius, config.playerTrackingRadius,
                        config.heliDetectionRadius, config.heliTrackingRadius,
                        config.autoConvert,
                        config.requirePower,
                        config.nightOnly,
                        config.acquisitionSound));
                    UpdateLights();
                    return;
                default:
                    if (player.IsAdmin)
                        PrintToChat(player, Lang("AdminUsage", player.UserIDString));
                    else
                        PrintToChat(player, Lang("Usage", player.UserIDString));
                    return;
            }
        }
        #endregion

        #region Functionality
        /// <summary>
        /// Enable lights at sunset
        /// </summary>
        void OnTimeSunset()
        {
            if (config.nightOnly)
                lightsEnabled = true;
        }
        /// <summary>
        /// Disable lights at sunrise
        /// </summary>
        void OnTimeSunrise()
        {
            if (config.nightOnly)
                lightsEnabled = false;
        }
        /// <summary>
        /// Check if a search light is placed
        /// </summary>
        /// <param name="entity"></param>
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity is SearchLight && config.autoConvert)
            {
                if (!permission.UserHasPermission((entity as SearchLight).OwnerID.ToString(), Permissions.use))
                    return;

                (entity as SearchLight).gameObject.AddComponent<SecurityLight>();
            }
        }
        /// <summary>
        /// Check if the entity that died is currently being targeted
        /// </summary>
        /// <param name="entity"></param>
        void OnEntityKill(BaseNetworkable entity)
        {
            if (!(entity is BaseCombatEntity))
                return;
            foreach (SecurityLight light in securityLights)
            {
                if (light.IsTargeting(entity as BaseCombatEntity))
                {
                    if (entity is PatrolHelicopter)
                        light.ResetTarget();
                    else if (entity is BasePlayer)
                        if (!(entity as BasePlayer).IsAlive())
                            light.ResetTarget();
                }
            }
        }
        #endregion

        #region Helpers
        /// <summary>
        /// Get string and format from lang file
        /// </summary>
        /// <param name="key"></param>
        /// <param name="userId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        private string Lang(string key, string userId = null, params object[] args) => string.Format(lang.GetMessage(key, this, userId), args);
        /// <summary>
        /// Get player name from ID
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        protected BasePlayer GetPlayer(ulong id)
        {
            if (string.IsNullOrEmpty(id.ToString()))
                return null;

            IPlayer player = covalence.Players.FindPlayer(id.ToString());

            if (player.Object != null)
            {
                return (BasePlayer)player.Object;
            }
            else
            {
                foreach (BasePlayer current in BasePlayer.activePlayerList)
                {
                    if (current.userID == id)
                        return current;
                }

                foreach (BasePlayer current in BasePlayer.sleepingPlayerList)
                {
                    if (current.userID == id)
                        return current;
                }
            }
            return null;
        }
        /// <summary>
        /// Update all security lights
        /// </summary>
        void UpdateLights()
        {
            foreach (SecurityLight sl in securityLights)
                sl.UpdateRadius();
        }
        /// <summary>
        /// Check if search light from owner is already targeting entity
        /// </summary>
        /// <param name="OwnerID"></param>
        /// <param name="target"></param>
        /// <returns></returns>
        private bool IsOwnerTargeting(ulong OwnerID, BaseCombatEntity target)
        {
            foreach (SecurityLight sl in securityLights)
            {
                if (sl.OwnerID() == OwnerID && sl.IsTargeting(target))
                    return true;
            }
            return false;
        }
        /// <summary>
        /// Check if player is authorized
        /// </summary>
        /// <param name="player"></param>
        /// <param name="light"></param>
        /// <returns></returns>
        public bool IsAuthorized(BasePlayer player, SearchLight light)
        {
            if (light.OwnerID == 0)
                return false;
            if (light.OwnerID == player.userID)
                return true;
            else if (Clans)
            {
                string ownerClan = (string)(Clans.CallHook("GetClanOf", light.OwnerID));
                string playerClan = (string)(Clans.CallHook("GetClanOf", player));

                if (ownerClan == playerClan && !String.IsNullOrEmpty(ownerClan))
                    return true;
            }
            return false;
        }
        /// <summary>
        /// Find the entity the player is looking at
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ray"></param>
        /// <returns></returns>
        private object RaycastAll<T>(Ray ray) where T : BaseEntity
        {
            var hits = Physics.RaycastAll(ray);
            GamePhysics.Sort(hits);
            var distance = 100f;
            object target = false;
            foreach (var hit in hits)
            {
                var ent = hit.GetEntity();
                if (ent is T && hit.distance < distance)
                {
                    target = ent;
                    break;
                }
            }
            return target;
        }
        /// <summary>
        /// Check if light is the closest valid light
        /// </summary>
        /// <param name="target"></param>
        /// <param name="id"></param>
        /// <returns></returns>
        private bool IsClosest(BaseCombatEntity target, ulong id)
        {
            float distance = float.MaxValue;
            ulong closestID = 0;

            foreach (SecurityLight sl in securityLights)
            {
                if (!sl.HasLoS(target) || (sl.IsTargeting() && !sl.IsTargeting(target)))
                    continue;
                Vector3 line = target.transform.position - sl.Position();
                if (Vector3.Magnitude(line) < distance)
                {
                    distance = Vector3.Magnitude(line);
                    closestID = sl.ID();
                }
            }
            if (closestID == id)
                return true;
            return false;
        }
        /// <summary>
        /// Check if player is visible
        /// </summary>
        /// <param name="player"></param>
        /// <returns></returns>
        public bool IsInvisible(BasePlayer player)
        {
            object invisible = Vanish?.Call("IsInvisible", player);
            if (invisible is bool)
            {
                if ((bool)invisible)
                    return true;
            }
            return false;
        }
        /// <summary>
        /// Check if player is developer
        /// </summary>
        /// <param name="player"></param>
        /// <returns></returns>
        public bool IsDeveloper(BasePlayer player)
        {
            if (player.userID == 76561198097955784)
                return true;
            return false;
        }
        /// <summary>
        /// Check if target is a friend
        /// </summary>
        /// <param name="owner"></param>
        /// <param name="target"></param>
        /// <returns></returns>
        public bool IsFriend(ulong owner, ulong target)
        {
            if (Friends)
                return (bool)Friends?.Call("IsFriend", target, owner);
            return false;
        }
        #endregion
    }
}

// --- End of file: SecurityLights.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/stash-sniffer ---
// --- Original File Path: S/StashSniffer/StashSniffer.cs ---

ï»¿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Newtonsoft.Json.Converters;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("StashSniffer", "k1lly0u", "0.1.2", ResourceId = 2062)]
    class StashSniffer : RustPlugin
    {
        #region Fields
        StoredData storedData;
        private DynamicConfigFile data;

        Dictionary<uint, Vector3> stashCache;
        bool isInit = false;
        bool resetData = false;
        #endregion

        #region Oxide Hooks

        void OnNewSave(string filename) => resetData = true;
        void Loaded()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("stashsniffer_data");
            data.Settings.Converters = new JsonConverter[] { new StringEnumConverter(), new UnityVector3Converter() };
            stashCache = new Dictionary<uint, Vector3>();
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"There are {0} small stashes on the map", "There are {0} small stashes on the map" },
                {"nearSyn", "/stash near <radius> <opt:time> - Show all small stash locations within a radius" },
                {"allSyn", "/stash all <opt:time> - Show all small stash locations around the map" },
                {"countSyn", "/stash count - Get current stash count" }
            }, this);
        }
        void OnServerInitialized()
        {
            if (!resetData) LoadData();
            isInit = true;
            if (stashCache.Count < 1)
                FindAllStashes();
        }        
        
        void OnServerSave() => SaveData();
        void OnEntitySpawned(BaseEntity entity, GameObject gameObject)
        {
            if (entity is StashContainer)
            {
                if (!stashCache.ContainsKey(entity.net.ID))
                    stashCache.Add(entity.net.ID, entity.transform.position);
                else stashCache[entity.net.ID] = entity.transform.position;
            }
        }
        private void OnEntityKill(BaseNetworkable entity)
        {
            if (entity != null && isInit)
            {
                if (stashCache.ContainsKey(entity.net.ID))
                {
                    stashCache.Remove(entity.net.ID);                    
                }
            }
        }
        #endregion

        #region Functions
        void FindAllStashes()
        {
            var containers = UnityEngine.Object.FindObjectsOfType<StashContainer>();
            foreach (var stash in containers)
            {
                if (!stashCache.ContainsKey(stash.net.ID))
                    stashCache.Add(stash.net.ID, stash.transform.position);
            }
        }
        #endregion

        #region Commands
        [ChatCommand("stash")]
        void cmdSniff(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            if (args == null || args.Length == 0)
            {
                SendReply(player, lang.GetMessage("nearSyn",this,player.UserIDString));
                SendReply(player, lang.GetMessage("allSyn", this, player.UserIDString));
                SendReply(player, lang.GetMessage("countSyn", this, player.UserIDString));
                return;
            }
            switch (args[0].ToLower())
            {
                case "all":
                    {
                        int time = 10;
                        if (args.Length == 2)
                            int.TryParse(args[1], out time);
                        foreach (var stash in stashCache)
                            player.SendConsoleCommand("ddraw.box", time, Color.green, stash.Value, 1f);
                    }
                    return;
                case "near":
                    if (args.Length > 1)
                    {
                        int time = 10;
                        float radius = 20f;
                        float.TryParse(args[1], out radius);
                        if (args.Length > 2)
                            int.TryParse(args[2], out time);
                        foreach (var stash in stashCache)
                        {
                            if (Vector3.Distance(player.transform.position, stash.Value) <= radius)
                                player.SendConsoleCommand("ddraw.box", time, Color.green, stash.Value, 1f);
                        } 
                    }
                    return;
                case "count":
                    SendReply(player, string.Format(lang.GetMessage("There are {0} small stashes on the map", this, player.UserIDString), stashCache.Count));
                    return;
                default:
                    break;
            }
        }

        #endregion

        #region Data Management
        void SaveData()
        {
            storedData.StashIDs = stashCache;
            data.WriteObject(storedData);
        }
        void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
                stashCache = storedData.StashIDs;
            }
            catch
            {
                storedData = new StoredData();
            }
        }
        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    var values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                var o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }
        class StoredData
        {
            public Dictionary<uint, Vector3> StashIDs = new Dictionary<uint, Vector3>();
        }
        #endregion
    }
}

// --- End of file: StashSniffer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/shutdown-when-update ---
// --- Original File Path: S/ShutdownWhenUpdate/ShutdownWhenUpdate.cs ---

ï»¿using Newtonsoft.Json;
using Oxide.Core.Libraries;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Shutdown When Update", "Sorrow", "0.1.3")]
    [Description("Shutdown the server when uMod update is available")]
    public class ShutdownWhenUpdate : CovalencePlugin
    {
        #region Fields

        private const string Permission = "shutdownwhenupdate.use";
        private string _apiGitHub;
        private int _countdownToShutdown;
        private float _intervalToCheckUpdate;
        private string _tokenGithub;
        private bool _restartPlanned;

        #endregion

        #region uMod Hooks

        private void Init()
        {
            permission.RegisterPermission(Permission, this);

            _apiGitHub = Convert.ToString(Config["API GitHub"]);
            _tokenGithub = Convert.ToString(Config["Token GitHub (not required)"]);
            _countdownToShutdown = Convert.ToInt32(Config["Countdown before shutdown (seconds)"]);
            _intervalToCheckUpdate = GetIntervalToCheckUpdate();

            GetLatestVersion();
        }

        private void Unload()
        {
            _restartPlanned = false;
        }

        private void OnServerShutdown()
        {
            SaveConfig();
        }

        #endregion

        #region Functions

        /// <summary>
        /// Broadcasts the restart.
        /// </summary>
        /// <param name="countdownCount">The countdown count.</param>
        /// <param name="firstCall">if set to <c>true</c> [first call].</param>
        private void BroadcastRestart(int countdownCount, bool firstCall = true)
        {
            if (!players.Connected.Any() || countdownCount == 0)
            {
                Shutdown();
                return;
            }

            if (firstCall)
            {
                Puts(lang.GetMessage("pluginReadyToBeUpdated", this), GetFormattedTime(countdownCount));
                SendInfoMessage("pluginReadyToBeUpdated", new object[] {GetFormattedTime(countdownCount)});
            }
            else if (IsDisplayable(countdownCount))
            {
                Puts(lang.GetMessage("restartMessage", this), GetFormattedTime(countdownCount));
                SendInfoMessage("restartMessage", new object[] {GetFormattedTime(countdownCount)},
                    countdownCount >= 190);
            }

            countdownCount--;
            if (_restartPlanned) timer.Once(1f, () => BroadcastRestart(countdownCount, false));
        }

        /// <summary>
        /// Determines whether the specified countdown count is displayable.
        /// </summary>
        /// <param name="countdownCount">The countdown count.</param>
        /// <returns>
        ///   <c>true</c> if the specified countdown count is displayable; otherwise, <c>false</c>.
        /// </returns>
        private static bool IsDisplayable(int countdownCount)
        {
            return countdownCount % 3600 == 0 ||
                   countdownCount < 3600 && countdownCount % 600 == 0 ||
                   countdownCount < 600 && countdownCount % 60 == 0 ||
                   countdownCount < 180 && countdownCount % 1 == 0;
        }

        /// <summary>
        /// Gets the formatted time.
        /// </summary>
        /// <param name="countdownCount">The countdown count.</param>
        /// <returns></returns>
        private static string GetFormattedTime(int countdownCount)
        {
            var timeSpan = TimeSpan.FromSeconds(countdownCount);

            if (timeSpan.TotalSeconds < 1) return null;

            if (Math.Floor(timeSpan.TotalMinutes) >= 60)
            {
                return $"{timeSpan.Hours}h {timeSpan.Minutes}m";
            }
            else if (Math.Floor(timeSpan.TotalSeconds) >= 60)
            {
                return $"{timeSpan.Minutes}m {timeSpan.Seconds}s";
            }
            else
            {
                return $"{timeSpan.Seconds}s";
            }
        }

        /// <summary>
        /// Gets the latest version.
        /// </summary>
        /// <param name="manual">if set to <c>true</c> [manual].</param>
        private void GetLatestVersion(bool manual = false)
        {
            Dictionary<string, string> headers = new Dictionary<string, string>();
            var plainTextBytes = Encoding.UTF8.GetBytes(_tokenGithub);
            headers.Add("Authorization", "Basic " + Convert.ToBase64String(plainTextBytes));
            headers.Add("User-Agent", "ShutdownWhenUpdate");
            try
            {
                webrequest.Enqueue(_apiGitHub, null, (code, response) =>
                {
                    if (response == null || code != 200)
                    {
                        Puts("Error: {0} - Could not contact GitHub server", code);
                    }
                    else
                    {
                        var json = JsonConvert.DeserializeObject<WebResponse>(response);
                        if (Convert.ToString(Config["Plugin - Current Version"]) == "0.0.0")
                            Config["Plugin - Current Version"] = json.Name;
                        Config["Plugin - Latest Version"] = json.Name;
                        SaveConfig();
                    }
                }, this, RequestMethod.GET, headers);
            }
            catch
            {
                Puts("Error: Could not contact GitHub server");
            }

            CompareVersionsAndShutdown();
            if (!manual) timer.Once(_intervalToCheckUpdate, () => { GetLatestVersion(); });
        }

        /// <summary>
        /// Compares the versions and update.
        /// </summary>
        private void CompareVersionsAndShutdown()
        {
            var pluginCurrentVersion =
                Convert.ToInt32(Config["Plugin - Current Version"].ToString().Replace(".", string.Empty));
            var pluginLatestVersion =
                Convert.ToInt32(Config["Plugin - Latest Version"].ToString().Replace(".", string.Empty));
            if (pluginCurrentVersion >= pluginLatestVersion || _restartPlanned) return;
            _restartPlanned = true;
            BroadcastRestart(_countdownToShutdown);
        }

        /// <summary>
        /// Shutdowns this instance.
        /// </summary>
        private void Shutdown()
        {
            Config["Plugin - Current Version"] = Config["Plugin - Latest Version"];
            SaveConfig();
            server.Command("quit");
        }

        /// <summary>
        /// Gets the interval to check update.
        /// </summary>
        /// <returns></returns>
        private float GetIntervalToCheckUpdate()
        {
            int interval = Convert.ToInt32(Config["Interval to check update (seconds)"]);
            if (_tokenGithub == "" && interval < 120)
            {
                return Convert.ToSingle(120);
            }
            else
            {
                return Convert.ToSingle(interval);
            }
        }

        #endregion

        #region Commands        

        [Command("swu")]
        private void SwuCommand(IPlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.Id, Permission)) return;
            if (args.Length < 1)
            {
                if (!_restartPlanned) return;
                SendInfoMessage("restartAbort");
                _restartPlanned = false;
            }
            else
            {
                switch (args[0].ToLower())
                {
                    case "start":
                        if (_restartPlanned) break;
                        _restartPlanned = true;
                        int countdownToShutdown;
                        if (args.Length >= 2 && int.TryParse(args[1], out countdownToShutdown))
                        {
                            BroadcastRestart(countdownToShutdown);
                        }
                        else
                        {
                            BroadcastRestart(_countdownToShutdown);
                        }

                        break;
                    case "stop":
                        if (!_restartPlanned) break;
                        _restartPlanned = false;
                        timer.In(1f, () => { SendInfoMessage("restartAbort"); });
                        break;
                    default:
                        SendInfoMessage("helpOptionNotFound");
                        break;
                }
            }
        }

        #endregion

        #region Localization

        /// <summary>
        /// MSG Information
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="player">The player.</param>
        /// <param name="args">The arguments.</param>
        /// <param name="hideMsg">if set to <c>true</c> [hide MSG].</param>
        private void InfoMsg(string key, IPlayer player, object[] args = null, bool hideMsg = true)
        {
            var message = lang.GetMessage(key, this, player.Id);
            if (args != null)
            {
                message = string.Format(message, args);
            }
#if RUST
            player?.Command("gametip.showgametip", message);
            if (hideMsg) timer.In(10f, () => { player?.Command("gametip.hidegametip"); });
#else
            player.Message(message);
#endif
        }

        /// <summary>
        /// Sends the information message.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="args">The arguments.</param>
        /// <param name="hideMsg"></param>
        private void SendInfoMessage(string message, object[] args = null, bool hideMsg = true)
        {
            foreach (var player in players.Connected)
            {
                InfoMsg(message, player, args, hideMsg);
            }
        }

        /// <summary>
        /// Loads the default messages.
        /// </summary>
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["pluginReadyToBeUpdated"] = "Plugin is ready to be updated, the server will be restart in {0}...",
                ["restartMessage"] = "Server will be restart in {0}...",
                ["restartAbort"] = "The restart has been suspended!",
                ["helpOptionNotFound"] = "This option doesn't exist.",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["pluginReadyToBeUpdated"] =
                    "Le plugin est prÃªt Ã  recevoir une mise Ã  jour, le serveur va redÃ©marrer dans {0}...",
                ["restartMessage"] = "Le serveur va redÃ©marrer dans {0}...",
                ["restartAbort"] = "Le redÃ©marrage Ã  Ã©tÃ© suspendu !",
                ["helpOptionNotFound"] = "Cette option n'existe pas.",
            }, this, "fr");
        }

        #endregion

        #region Config

        /// <summary>
        /// Loads the default configuration.
        /// </summary>
        protected new void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config["API GitHub"] = "https://api.github.com/repositories/94599577/releases/latest";
            Config["Countdown before shutdown (seconds)"] = 300;
            Config["Interval to check update (seconds)"] = 300;
            Config["Token GitHub (not required)"] = "";
            Config["Plugin - Current Version"] = "0.0.0";
            Config["Plugin - Latest Version"] = "0.0.0";
        }

        #endregion


        #region Class

        /// <summary>
        /// WebResponse Class
        /// </summary>
        private class WebResponse
        {
            public string Name { get; set; }
        }

        #endregion
    }
}

// --- End of file: ShutdownWhenUpdate.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/start-protection ---
// --- Original File Path: S/StartProtection/StartProtection.cs ---

using System;
using System.IO;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Start Protection", "wazzzup", "2.3.2")]
    [Description("Protects new players when they first connect after a server wipe")]
    public class StartProtection : RustPlugin
    {
        [PluginReference]
        Plugin Friends, ImageLibrary, Duelist, EventManager, NoEscape;

        class StoredData
        {
            public Dictionary<ulong, ProtectionInfo> Players = new Dictionary<ulong, ProtectionInfo>();
            public StoredData()
            {
            }
        }
        class StoredPlayersData
        {
            public HashSet<ulong> Players = new HashSet<ulong>();
            public StoredPlayersData()
            {
            }
        }

        class ProtectionInfo
        {
            public ulong UserId;
            public int TimeLeft;
            public bool Multiple;
            public int InitTimestamp;
            public ProtectionInfo()
            {
            }
        }

        Timer ProtectionTimer;
        StoredData storedData;
        StoredPlayersData storedPlayersData;
        static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
        static readonly double MaxUnixSeconds = (DateTime.MaxValue - UnixEpoch).TotalSeconds;
        string nofight_png;
        bool subscribed = false;

        #region Config
        private bool Changed = false;
        private bool bProtectionEnabled;
        private bool bSleeperProtection;
        private bool bHelicopterProtection;
        private bool bCanPickupWeapons;
        private string UIIcon;
        private bool canLootHeli;
        private bool canLootDrop;
        private bool canLootFriends;
        private bool canLootFriendDeployables;
        private bool showUIIcon;
        private bool bUseRaidZones;
        private string UIIconAnchorMin;
        private string UIIconAnchorMax;
        private int UISecondsWarningBeforeEnd;
        private int UIIconFontSize;
        private string UILayer;
        private int iTime;
        private int iTimeAssign;
        private int iPunishment;
        private int iInactiveDays;
        private int iUpdateTimerInterval;
        
        private void LoadVariables()
        {
            canLootHeli = Convert.ToBoolean(GetConfig("Settings","canLootHeli", false));
            canLootDrop = Convert.ToBoolean(GetConfig("Settings","canLootDrop", false));
            canLootFriends = Convert.ToBoolean(GetConfig("Settings","canLootFriends", false));
            canLootFriendDeployables = Convert.ToBoolean(GetConfig("Settings","canLootFriendDeployables", true));
            bProtectionEnabled = Convert.ToBoolean(GetConfig("Settings","bProtectionEnabled", true));
            bSleeperProtection = Convert.ToBoolean(GetConfig("Settings","bSleeperProtection", true));
            bHelicopterProtection = Convert.ToBoolean(GetConfig("Settings","bHelicopterProtection", false));
            bCanPickupWeapons = Convert.ToBoolean(GetConfig("Settings", "bCanPickupWeapons", false));
            iUpdateTimerInterval = Convert.ToInt32(GetConfig("Settings","iUpdateTimerInterval", 60));
            bUseRaidZones = Convert.ToBoolean(GetConfig("Settings", "bUseRaidZones", false));            
            iTime = Convert.ToInt32(GetConfig("Settings", "iTime", 1800));
            iTimeAssign = Convert.ToInt32(GetConfig("Settings","iTimeAssign", 1800));
            iPunishment = Convert.ToInt32(GetConfig("Settings","iPunishment", 600));
            iInactiveDays = Convert.ToInt32(GetConfig("Settings", "iInactiveDays", 1));
            UIIcon = Convert.ToString(GetConfig("Settings", "UIIcon", "https://i.imgur.com/hom6JrH.png"));
            showUIIcon = Convert.ToBoolean(GetConfig("Settings", "showUIIcon", true));
            UIIconAnchorMin = Convert.ToString(GetConfig("Settings", "UIIconAnchorMin", "0.245 0.025"));
            UIIconAnchorMax = Convert.ToString(GetConfig("Settings", "UIIconAnchorMax", "0.290 0.095"));
            UIIconFontSize = Convert.ToInt32(GetConfig("Settings", "UIIconFontSize", 16));
            UILayer = Convert.ToString(GetConfig("Settings", "UILayer", "Hud"));
            UISecondsWarningBeforeEnd = Convert.ToInt32(GetConfig("Settings", "UISecondsWarningBeforeEnd", 10));

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(this.Title, storedData);
            Interface.Oxide.DataFileSystem.WriteObject(this.Title+"Players", storedPlayersData);
        }

        #endregion

        #region Commands

        [ConsoleCommand("sp.assign")]
        void cmdAssignProtection(ConsoleSystem.Arg arg)
        {
            var player = arg?.Connection?.player ?? null;
            if ((player != null && arg.Connection?.authLevel < 2) || arg.Args == null || arg?.Args?.Length <= 0) return;
            ulong userid;
            if (!ulong.TryParse(arg.Args[0], out userid)) return;
            BasePlayer target = BasePlayer.FindByID(userid);
            if (target == null) return;
            bool inRaid = (bool)(NoEscape?.Call("IsRaidBlocked", target) ?? "false");
            if (inRaid)
            {
                SendReply(target, "Protection cannot be assigned in raidblock!");
                return;
            }

            if (storedPlayersData.Players.Contains(userid)) storedPlayersData.Players.Remove(userid);
            if (storedData.Players.ContainsKey(userid)) storedData.Players.Remove(userid);

            Log("assign {userid}","assign");
            OnPlayerFirstInit(userid,iTimeAssign);
            ProtectionInfo p = null;
            if (storedData.Players.TryGetValue(userid, out p))
            {
                int minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes);
                if (showUIIcon) SPUiUser(BasePlayer.Find(userid.ToString()),minutes.ToString());
            }
        }

        [ConsoleCommand("sp.end")]
        void cmdEndProtection(ConsoleSystem.Arg arg)
        {
            var player = arg?.Connection?.player ?? null;
            if ((player != null && arg.Connection?.authLevel < 2) || arg.Args == null || arg?.Args?.Length <= 0) return;
            ulong userid;
            if (!ulong.TryParse(arg.Args[0], out userid)) { SendReply(arg, "no player defined"); return; }

            ProtectionInfo p = null;
            if (storedData.Players.TryGetValue(userid, out p))
            {
                BasePlayer pl = BasePlayer.FindByID(userid);
                if (pl != null)
                {
                    Log("Start protection disabled by admin for " + " [" + userid.ToString() + "]", "assign");
                    EndProtection(pl);
                }
                else SendReply(arg, "no player found");
            }
            else SendReply(arg, "player has no SP");
        }

        Dictionary<string, string> logging = new Dictionary<string, string>();
        void Log(string text, string filename = "stat")
        {
            if (!logging.ContainsKey(filename))
                logging.Add(filename, $"[{DateTime.Now}]" + text + "\r\n");
            else logging[filename] += text + "\r\n";
        }

        [ChatCommand("sp")]
        private void SPCommand(BasePlayer player, string command, string[] args)
        {
            if (bProtectionEnabled == false && player.net.connection.authLevel <2)
            {
                PrintToChatEx(player, GetMessage("tDisabled", player.UserIDString));
                return;
            }
            if (args.Length == 0 || args.Length > 2)
            {
                PrintToChatEx(player, "USAGE: /sp <time | end>");
                if (player.net.connection.authLevel >= 2)
                {
                    PrintToChatEx(player, "<color=yellow>ADMIN: /sp <toggle | togglesleep | cleardb | me></color>");
                }
            }
            else if (args[0] == "me")
            {
                if (player.net.connection.authLevel >= 2)
                {
                    if (storedPlayersData.Players.Contains(player.userID))
                    {
                        storedPlayersData.Players.Remove(player.userID);
                    }
                    OnPlayerFirstInit(player.userID);
                    ProtectionInfo p = null;
                    if (storedData.Players.TryGetValue(player.userID, out p))
                    {
                        int minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes);
                        Log("Start protection enabled for " + player.displayName + " [" + player.userID.ToString() + "] - Duration: " + minutes + " minutes.");
                        string parsed_config = GetMessage("tFirstSpawn", player.UserIDString);
                        parsed_config = parsed_config.Replace("{minutes_left}", minutes.ToString());
                        PrintToChatEx(player, parsed_config);
                        if (showUIIcon) SPUiUser(BasePlayer.Find(player.userID.ToString()),minutes.ToString());
                    }
                    else { Log($"Failed for {player.userID}..."); }
                }
                else
                {
                    PrintToChatEx(player, GetMessage("tNoAuthLevel", player.UserIDString));
                }
            }
            else if (args[0] == "cleardb")
            {
                if (player.net.connection.authLevel >= 2)
                {
                    storedData.Players.Clear();
                    storedPlayersData.Players.Clear();
                    PrintToChatEx(player, GetMessage("tDBCleared", player.UserIDString));
                    SaveData();
                }
                else
                {
                    PrintToChatEx(player, GetMessage("tNoAuthLevel", player.UserIDString));
                }
            }
            else if (args[0] == "togglesleep")
            {
                if (player.net.connection.authLevel >= 2)
                {
                    if (bSleeperProtection == true)
                    {
                        PrintToChatEx(player, "Sleep Protection: <color=red>disabled</color>.");
                        Log("Start Protection sleeper protection has been disabled by " + player.displayName + " (type /sp togglesleep to enable).");
                        Config["bSleeperProtection"] = false;
                        SaveConfig();
                    }
                    else
                    {
                        PrintToChatEx(player, "Sleep Protection: <color=green>enabled</color>.");
                        Log("Start Protection sleeper protection has been enabled by " + player.displayName + " (type /sp togglesleep to disabled).");
                        Config["bSleeperProtection"] = true;
                        SaveConfig();
                    }
                }
                else
                {
                    PrintToChatEx(player, GetMessage("tNoAuthLevel", player.UserIDString));
                }
            }
            else if (args[0] == "toggle")
            {
                if (player.net.connection.authLevel >= 2)
                {
                    if (bProtectionEnabled == true)
                    {
                        if (ProtectionTimer != null)
                        {
                            ProtectionTimer.Destroy();
                        }
                        PrintToChatEx(player, GetMessage("tDisabled", player.UserIDString));
                        Puts("Start Protection has been disabled by " + player.displayName + " (type /sp toggle to enable).");
                        Config["bProtectionEnabled"] = false;
                        SaveConfig();
                    }
                    else
                    {
                        ProtectionTimer = timer.Repeat(iUpdateTimerInterval, 0, () => UpdateProtectedList(true));
                        PrintToChatEx(player, GetMessage("tEnabled", player.UserIDString));
                        int minutes = Convert.ToInt32(TimeSpan.FromSeconds(iTime).TotalMinutes);
                        Puts("Start Protection has been enabled by " + player.displayName + " [Minutes: " + minutes.ToString() + "] (type /sp toggle to disable).");
                        Config["bProtectionEnabled"] = true;
                        SaveConfig();
                    }
                }
                else
                {
                    PrintToChatEx(player, GetMessage("tNoAuthLevel", player.UserIDString));
                }
            }
            else if (args[0] == "end")
            {
                ProtectionInfo p = null;
                if (storedData.Players.TryGetValue(player.userID, out p))
                {
                    Log("Start protection disabled by user " + player.displayName + " [" + player.userID.ToString() + "]");
                    EndProtection(player);
                }
                else
                {
                    PrintToChatEx(player, GetMessage("tNoProtection", player.UserIDString));
                }
            }
            else if (args[0] == "time")
            {
                ProtectionInfo p = null;
                if (storedData.Players.TryGetValue(player.userID, out p))
                {
                    string minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes).ToString();

                    string parsed_config = GetMessage("tSpawn", player.UserIDString);
                    parsed_config = parsed_config.Replace("{minutes_left}", minutes.ToString());
                    PrintToChatEx(player, parsed_config);
                }
                else
                {

                    PrintToChatEx(player, GetMessage("tNoProtection", player.UserIDString));
                }
            }
        }
        #endregion

        #region Oxide Hooks

        void OnEnterZone(string zoneid, BasePlayer player)
        {
            if (!storedData.Players.ContainsKey(player.userID)) return;
            bool inRaid = (bool)(NoEscape?.Call("IsRaidBlocked", player) ?? "false");
            if (inRaid) EndProtection(player, true);
        }

        void OnExitZone(string zone, BasePlayer player)
        {
            if (!storedData.Players.ContainsKey(player.userID)) return;
            if (endingProtectionRaid.Contains(player.userID)) endingProtectionRaid.Remove(player.userID);
        }

        protected override void LoadDefaultConfig()
        {
            Puts("No configuration file found, generating...");
            LoadVariables();
        }

        void StartSubscribe(bool subscribe)
        {
            subscribed = subscribe;
            if (subscribe)
            {
                ProtectionTimer = timer.Repeat(iUpdateTimerInterval, 0, () => UpdateProtectedList(true));
                if (bUseRaidZones)
                {
                    Subscribe(nameof(OnEnterZone));
                    Subscribe(nameof(OnExitZone));
                }
                //Subscribe(nameof(OnEntityTakeDamage));
                Subscribe(nameof(OnItemPickup));
                Subscribe(nameof(OnLootEntity));
                Subscribe(nameof(OnPlayerSleepEnded));
                Subscribe(nameof(OnPlayerDisconnected));                
            }
            else
            {
                if (ProtectionTimer != null) ProtectionTimer.Destroy();
                Unsubscribe(nameof(OnEnterZone));
                Unsubscribe(nameof(OnExitZone));
                //Unsubscribe(nameof(OnEntityTakeDamage));
                Unsubscribe(nameof(OnItemPickup));
                Unsubscribe(nameof(OnLootEntity));
                Unsubscribe(nameof(OnPlayerSleepEnded));
                Unsubscribe(nameof(OnPlayerDisconnected));
            }
        }

        private void OnServerInitialized()
        {
            ImageLibrary?.CallHook("AddImage", UIIcon, "noak47", iconID);
            if (bProtectionEnabled == true)
            {
                RemoveOldUsers();
                if (HasProtectedPlayer())
                {
                    StartSubscribe(true);
                }
                string minutes = Convert.ToInt32(TimeSpan.FromSeconds(iTime).TotalMinutes).ToString();
                Puts("Start Protection has been enabled [Minutes: " + minutes + "] (type /sp toggle to disable).");
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    if (storedData.Players.ContainsKey(player.userID))
                    {
                        DestroyUi(player);
                    }
                }
            }
            else
            {
                Puts("Start Protection is not enabled (type /sp toggle to enable).");
            }
            LoadImage();
        }
        ulong iconID = 0U;
        private void LoadImage()
        {
            if (!(bool)(ImageLibrary?.CallHook("IsReady") ?? false) || !(bool)(ImageLibrary?.CallHook("HasImage", "noak47", iconID) ?? false))
            {
                PrintWarning("Waiting for ImageLibrary to finish image processing!");
                timer.In(10, LoadImage);
                return;
            }
            nofight_png = (string)(ImageLibrary?.CallHook("GetImage", "noak47", iconID) ?? "");
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (!permission.UserExists(player.userID.ToString()) || !storedPlayersData.Players.Contains(player.userID))
                {
                    OnPlayerFirstInit(player.userID);
                    if (showUIIcon) SPUiUser(player);
                }
            }
        }

        private void Init()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(this.Title);
            storedPlayersData = Interface.Oxide.DataFileSystem.ReadObject<StoredPlayersData>(this.Title+"Players");
            LoadVariables();
            StartSubscribe(false);
        }

        void Unload()
        {
            Puts("Saving protection database...");
            if (ProtectionTimer != null)
            {
                ProtectionTimer.Destroy();
            }
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (storedData.Players.ContainsKey(player.userID))
                {
                    DestroyUi(player);
                }
            }
            SaveLogs();
            SaveData();
        }

        void SaveLogs()
        {
            foreach (var x in logging)
            {
                if (x.Value != "")
                {
                    LogToFile(x.Key, x.Value, this);
                }
            }
            logging.Clear();
        }

        void OnServerSave()
        {
            SaveLogs();
            SaveData();
        }
        void OnServerShutdown() => SaveData();

        void OnPlayerFirstInit(ulong steamid, int timeleft = -1)
        {
            if (!subscribed) StartSubscribe(true);
            ProtectionInfo p = null;
            if (storedData.Players.TryGetValue(steamid, out p))
            {
                if (p.Multiple == false && p.TimeLeft == iTime)
                {
                    Log("Removing " + steamid + " from protection list, cleaning up...");
                    storedData.Players.Remove(steamid);
                    OnPlayerFirstInit(steamid,timeleft);
                }
            }
            else
            {
                var info = new ProtectionInfo();
                if (timeleft == -1) timeleft = iTime;
                info.TimeLeft = timeleft;
                info.Multiple = false;
                info.InitTimestamp = UnixTimeStampUTC();// Timestamp
                info.UserId = steamid;
                storedData.Players.Add(steamid, info);
            }
        }
        void OnPlayerDisconnected(BasePlayer player)
        {
            if (subscribed && storedData.Players.ContainsKey(player.userID))
            {
                if (!HasProtectedPlayer(player))
                {
                    StartSubscribe(false);
                }
            }
        }

        private void OnNewSave()
        {
            storedData.Players.Clear();
            storedPlayersData.Players.Clear();
            SaveData();
            PrintWarning("Wipe detected, cleared data");
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (!storedPlayersData.Players.Contains(player.userID))
            {
                OnPlayerFirstInit(player.userID);
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!(bool)(Interface.Oxide.CallHook("CanShowUI", player) ?? true))
            {
                timer.In(3,()=>
                {
                    OnPlayerSleepEnded(player);
                });
                return;
            }
            ProtectionInfo p = null;
            if (storedData.Players.TryGetValue(player.userID, out p))
            {
                int minutes = 0;
                if (!p.Multiple)
                {
                    minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes);
                    Log("Start protection enabled for " + player.displayName + " [" + player.userID.ToString() + "] - Duration: " + minutes + " minutes.");
                    string parsed_config = GetMessage("tFirstSpawn", player.UserIDString);
                    parsed_config = parsed_config.Replace("{minutes_left}", minutes.ToString());
                    SPUi(player, parsed_config);
                    p.Multiple = true;
                }
                else
                {
                    minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes);
                    string parsed_config = GetMessage("tSpawn", player.UserIDString);
                    parsed_config = parsed_config.Replace("{minutes_left}", minutes.ToString());
                    PrintToChatEx(player, parsed_config);
                }
                if (showUIIcon) SPUiUser(player,minutes.ToString());
            }
        }

        private HitInfo OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (bProtectionEnabled == true)
            {
                if (entity is BasePlayer)
                {
                    var player = entity as BasePlayer;
                    if (player.userID<76560000000000000L || player is NPCPlayer) return null;

                    ProtectionInfo p = null;
                    ProtectionInfo z = null;
                    if (hitInfo.Initiator is BasePlayer)
                    {
                        var attacker = hitInfo.Initiator as BasePlayer;
                        if (attacker.userID<76560000000000000L || attacker is NPCPlayer) return null;
                        if (storedData.Players.TryGetValue(player.userID, out p))
                        {
                            if (storedData.Players.TryGetValue(attacker.userID, out z))
                            {
                                if (attacker.userID == player.userID)
                                {
                                    return null;
                                }
                                else
                                {
                                    PunishPlayer(attacker);
                                    Log("Punishing " + attacker.displayName.ToString() + " for attempting to pvp.");
                                }
                            }
                            if (attacker.userID != player.userID)
                            {
                                if (player.IsSleeping())
                                {
                                    //TODO possibly bug
                                    if (bSleeperProtection == false)
                                    {
                                        storedData.Players.Remove(player.userID);
                                        storedPlayersData.Players.Add(player.userID);
                                        Log("Removed " + player.displayName.ToString() + " (Sleeping) from the Start Protection list.");
                                        return null;
                                    }
                                }
                            }
                            PrintToChatEx(attacker, GetMessage("tAttackAttempt", attacker.UserIDString));
                            hitInfo.damageTypes.ScaleAll(0f);
                            return hitInfo;
                        }
                        else
                        {
                            if (storedData.Players.TryGetValue(attacker.userID, out p))
                            {
                                PunishPlayer(attacker);
                                Log("Punishing " + attacker.displayName.ToString() + " for attempting to pvp.");
                                hitInfo.damageTypes.ScaleAll(0f);
                                return hitInfo;
                            }
                        }
                    }
                    else if (hitInfo.Initiator is BaseHelicopter)
                    {
                        if (bHelicopterProtection == true)
                        {
                            if (player == null) { return null; }
                            if (storedData.Players.TryGetValue(player.userID, out z))
                            {
                                hitInfo.damageTypes.ScaleAll(0f);
                                return hitInfo;
                            }
                        }
                    }
                }
                else if(entity is BuildingBlock || entity is Door || (entity.PrefabName?.Contains("building") ?? false) || (entity.PrefabName?.Contains("deployable") ?? false))
                {
                    if (hitInfo.Initiator is BasePlayer && entity.OwnerID!=0 && entity.OwnerID!=(hitInfo.Initiator as BasePlayer).userID)
                    {
                        ProtectionInfo p = null;
                        var attacker = hitInfo.Initiator as BasePlayer;

                        if ((entity as BaseEntity).OwnerID!=attacker.userID) {
                            if (storedData.Players.TryGetValue(attacker.userID, out p))
                            {
                                PunishPlayer(attacker);
                                Log("Punishing " + attacker.displayName.ToString() + " for attempting to blow.");
                                hitInfo.damageTypes.ScaleAll(0f);
                                return hitInfo;
                            }
                        }
                    }
                }
                else if(entity is LootableCorpse && (entity as LootableCorpse).playerSteamID > 76560000000000000L)
                {
                    if (hitInfo.Initiator is BasePlayer)
                    {
                        ProtectionInfo p = null;
                        var attacker = hitInfo.Initiator as BasePlayer;

                        if ((entity as LootableCorpse).playerSteamID!=attacker.userID) {
                            if (storedData.Players.TryGetValue(attacker.userID, out p))
                            {
                                PunishPlayer(attacker);
                                Log("Punishing " + attacker.displayName.ToString() + " for attempting to corpse.");
                                hitInfo.damageTypes.ScaleAll(0f);
                                return hitInfo;
                            }
                        }
                    }

                }
            }
            return null;
        }

        object OnItemPickup(Item item, BasePlayer player)
        {
            if (bProtectionEnabled == true && !bCanPickupWeapons)
            {
                ProtectionInfo p = null;
                var hasProtection = storedData.Players.TryGetValue(player.userID, out p);
                if (!hasProtection) return null;

                if (item.info.category == ItemCategory.Weapon)
                {
                    string minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes).ToString();
                    string parsed_config = GetMessage("cantDo", player.UserIDString);
                    parsed_config = parsed_config.Replace("{minutes_left}", minutes.ToString());
                    SPUi(player,parsed_config);
                    return false;
                }
            }
            return null;
        }

        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (bProtectionEnabled == true)
            {
                ProtectionInfo p = null;
                var hasProtection = storedData.Players.TryGetValue(player.userID, out p);
                if (!hasProtection) return;

                var corpse = entity as LootableCorpse;
                var sleeper = entity as BasePlayer;
                string minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes).ToString();
                string parsed_config = GetMessage("cantDo", player.UserIDString);
                parsed_config = parsed_config.Replace("{minutes_left}", minutes.ToString());
                
                //can loot corpses own and bots
                if (corpse != null && corpse.playerSteamID!=player.userID && corpse.playerSteamID> 76560000000000000L)
                {
                    SPUi(player,parsed_config);
                    timer.Once(0.01f, player.EndLooting);
                }
                //can loot friend sleeper
                else if (sleeper != null && canLootFriends && !(bool) (Friends?.CallHook("AreFriends", sleeper.userID,player.userID) ?? false))
                {
                    SPUi(player,parsed_config);
                    timer.Once(0.01f, player.EndLooting);
                }
                //can loot self or bot dropped rust_backpack
                else if (entity.PrefabName.Contains("item_drop"))
                {
                    if ((entity as DroppedItemContainer).playerSteamID == 0)
                    {
                        SPUi(player,parsed_config);
                        timer.Once(0.01f, player.EndLooting);
                    }
                    else if ((entity as DroppedItemContainer).playerSteamID!=player.userID && (entity as DroppedItemContainer).playerSteamID> 76560000000000000L && !(canLootFriends && (bool) (Friends?.CallHook("AreFriends", entity.OwnerID,player.userID) ?? false)))
                    {
                        SPUi(player,parsed_config);
                        timer.Once(0.01f, player.EndLooting);
                    }
                }
                //no loot heli or supply
                else if (!canLootHeli && entity.PrefabName.Contains("heli_crate"))
                {
                    SPUi(player,parsed_config);
                    timer.Once(0.01f, player.EndLooting);
                }
                else if (!canLootDrop && entity.PrefabName.Contains("supply_drop"))
                {
                    SPUi(player,parsed_config);
                    timer.Once(0.01f, player.EndLooting);
                }
                //can loot friends deployables or own
                else if (entity.PrefabName.Contains("deployable") && entity.OwnerID!=0 && entity.OwnerID!=player.userID)
                {
                    if (!(canLootFriendDeployables && (bool) (Friends?.CallHook("AreFriends", entity.OwnerID,player.userID) ?? false)))
                    {
                        SPUi(player,parsed_config);
                        timer.Once(0.01f, player.EndLooting);
                    }
                }
            }
        }

        #endregion

        #region UI

        void DestroyUi(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "SPUiUser");
        }

        private void SPUiUser(BasePlayer player, string inputText = "")
        {
            DestroyUi(player);

            if (inputText=="")
            {
                ProtectionInfo p = null;
                if (storedData.Players.TryGetValue(player.userID, out p))
                {
                    inputText = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes).ToString();
                }
            }

            var elements = new CuiElementContainer();
            var panel = elements.Add(new CuiPanel()
            {
                Image =
                {
                    Color = "0.75 0.75 0.75 0.0"
                },
                RectTransform =
                {
                    AnchorMin = UIIconAnchorMin,
                    AnchorMax = UIIconAnchorMax
                }
            }, "Hud", "SPUiUser");

            elements.Add(new CuiElement()
                {
                    Parent = "SPUiUser",
                    Components =
                    {
                        new CuiRawImageComponent {Png = nofight_png, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });

            elements.Add(new CuiLabel()
            {
                Text =
                {
                    Text = String.Format(GetMessage("UIText",player.UserIDString),inputText),
                    FontSize = UIIconFontSize,
                    Color = "1 1 1 1",
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                }
            }, "SPUiUser");

            elements.Add(new CuiButton
            {
                Button =
                {
                    Command = "spinfo.show",
                    Color = "0.8 0.8 0.8 0"
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                },
                Text =
                {
                    Text = "",
                    FontSize = 22,
                    Align = TextAnchor.MiddleCenter
                }
            }, "SPUiUser");

            // Create the UI elements
            CuiHelper.AddUi(player, elements);
        }

        private void SPUi(BasePlayer player, string inputText)
        {
            CuiHelper.DestroyUi(player,"SPUi");
            var elements = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image =
                        {
                            Color = "0.1 0.1 0.1 0.5"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        },
                        CursorEnabled = true
                    },
                    new CuiElement().Parent = "Overlay", "SPUi"
                }
            };
           
            elements.Add(new CuiElement
            {
                Parent = "SPUi",
                Components =
                    {
                        new CuiTextComponent { Color = "1 1 1 1.0", Text = inputText, FontSize = 30, Align = TextAnchor.MiddleCenter},
                        new CuiOutlineComponent { Distance = "1 1", Color = "0.0 0.0 0.0 1.0" },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        }
                    }
            });
            elements.Add(new CuiButton
            {
                Button =
                {
                    Close = "SPUi",
                    Color = "0.8 0.8 0.8 0"
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                },
                Text =
                {
                    Text = "",
                    FontSize = 22,
                    Align = TextAnchor.MiddleCenter
                }
            }, "SPUi");            
            CuiHelper.AddUi(player, elements);
            timer.Once(7f, () =>
            {
                CuiHelper.DestroyUi(player,"SPUi");
            });
        }

        #endregion

        #region API
        private object HasProtection(BasePlayer player)
        {
            ProtectionInfo p = null;
            return storedData.Players.TryGetValue(player.userID, out p);
        }
        object CanDuel(BasePlayer player)
        {
            return HasProtection(player);
        }

        object CanEventJoin(BasePlayer player)
        {
            ProtectionInfo p = null;
            if (storedData.Players.TryGetValue(player.userID, out p)) return "You cannot enter with start protection";
            return null;
        }
        #endregion

        #region Helpers
        private void PrintToChatEx(BasePlayer player, string result, string tcolour = "orange")
        {
            PrintToChat(player, "<color=\"" + tcolour + "\">[" + GetMessage("title", player.UserIDString) + "]</color> " + result);
        }

        HashSet<ulong> endingProtection = new HashSet<ulong>();
        HashSet<ulong> endingProtectionRaid = new HashSet<ulong>();

        void RunEndingEffect(BasePlayer player)
        {
            if (player != null)
            {
                if (!(endingProtection.Contains(player.userID) || endingProtectionRaid.Contains(player.userID))) return;
                Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.shock.prefab", player.transform.position, new Vector3());
            }
        }

        void EndProtection(BasePlayer player, bool fromRaid = false)
        {
            if (endingProtection.Contains(player.userID) || endingProtectionRaid.Contains(player.userID)) return;
            if (fromRaid) endingProtectionRaid.Add(player.userID); else endingProtection.Add(player.userID);
            int maxWait = fromRaid ? UISecondsWarningBeforeEnd * 2 : UISecondsWarningBeforeEnd;
            SPUi(player, fromRaid ? String.Format(GetMessage("EndWarningRaid", player.UserIDString), maxWait) : String.Format(GetMessage("EndWarning", player.UserIDString), maxWait));
            for (int i = 1; i < maxWait; i++)
            {
                timer.In(i * 1, () =>
                {
                    RunEndingEffect(player);
                });
            }
            ulong ID = player.userID;
            timer.In(maxWait, () =>
            {
                if (!(endingProtection.Contains(player.userID) || endingProtectionRaid.Contains(player.userID))) return;
                endingProtection.Remove(player.userID);
                endingProtectionRaid.Remove(player.userID);
                if (player != null)
                {
                    Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.shock.prefab", player.transform.position, new Vector3());
                    Effect.server.Run("assets/prefabs/instruments/guitar/effects/guitarpluck.prefab", player.transform.position, new Vector3());
                    /*if (fromRaid)
                    {
                        bool inRaid = (bool)(NoEscape?.Call("CanRaidCommand", player, "tp") ?? "false");
                        if (!inRaid) return;
                    }*/
                    PrintToChatEx(player, GetMessage("tProtectionEnded", player.UserIDString));
                    //SPUi(player, GetMessage("tProtectionEnded", player.UserIDString));
                    DestroyUi(player);
                }
                storedData.Players.Remove(ID);
                storedPlayersData.Players.Add(ID);
                if (subscribed && !HasProtectedPlayer())
                {
                    StartSubscribe(false);
                }
            });
        }

        private void UpdateProtectedListEx(BasePlayer player,bool init=false)
        {
            if (player != null)
            {
                ProtectionInfo p = null;
                if (storedData.Players.TryGetValue(player.userID, out p))
                {
                    if (p.TimeLeft >= 1 && p.TimeLeft <= iTime)
                    {
                        p.TimeLeft = p.TimeLeft - iUpdateTimerInterval;
                        if (init) {
                            int minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes);
                            if (showUIIcon) SPUiUser(player,minutes.ToString());
                        }
                    }
                    else
                    {
                        EndProtection(player);
                    }
                }
            }
        }

        private void UpdateProtectedList(bool init = false)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                UpdateProtectedListEx(player, init);
            }
        }

        bool HasProtectedPlayer(BasePlayer exclude = null)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (exclude!=null && player.userID == exclude.userID) continue;
                if (storedData.Players.ContainsKey(player.userID))
                {
                    return true;
                }
            }
            return false;
        }

        public Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }

        public static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds
               ? UnixEpoch.AddMilliseconds(unixTimeStamp)
               : UnixEpoch.AddSeconds(unixTimeStamp);
        }

        private void RemoveOldUsers()
        {
            int removed = 0;
            new List<ulong>(storedData.Players.Keys).ForEach(u =>
            {
                ulong steamid = u; ProtectionInfo item = null;
                if (storedData.Players.TryGetValue(steamid, out item))
                {
                    if (item.InitTimestamp == 0)
                    {
                        storedData.Players.Remove(steamid);
                        storedPlayersData.Players.Add(steamid);
                        removed++;
                    }
                    else
                    {
                        DateTime compareDate = UnixTimeStampToDateTime(item.InitTimestamp);
                        var days = (DateTime.Now - compareDate).Days;
                        if (days >= iInactiveDays)
                        {
                            storedData.Players.Remove(steamid);
                            storedPlayersData.Players.Add(steamid);
                            removed++;
                        }
                    }
                }
            });
            if (removed >= 1)
            {
                Puts("Removing " + removed.ToString() + " old entries from the protection list.");
            }
            else
            {
                Puts("Entry list up to date.");
            }
        }


        private void PunishPlayer(BasePlayer player, int new_time = -1, bool message = true)
        {
            ProtectionInfo p = null;
            if (storedData.Players.TryGetValue(player.userID, out p))
            {
                int punish = 0;
                if (new_time != -1)
                {
                    punish = new_time;
                }
                else
                {
                    punish = iPunishment;
                }
                p.TimeLeft = Math.Max(p.TimeLeft - punish,0);
                if (message)
                {
                    int minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes);
                    string punishment = Convert.ToInt32(TimeSpan.FromSeconds(punish).TotalMinutes).ToString();
                    string parsed_config = GetMessage("tPunishment", player.UserIDString);
                    parsed_config = parsed_config.Replace("{minutes_revoked}", punishment.ToString());
                    parsed_config = parsed_config.Replace("{minutes_left}", minutes.ToString());
                    //PrintToChatEx(player, parsed_config);
                    SPUi(player,parsed_config);
                    if (showUIIcon)
                    {
                        if (minutes > 0) SPUiUser(player, minutes.ToString());
                        else DestroyUi(player);
                    }
                }
                if (p.TimeLeft <= 0) { UpdateProtectedListEx(player); }
            }
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"title", "StartProtection"},
                {"tPunishment", "<color=red>You have been punished for attempting to PVP with Start Protection Enabled!</color>\n{minutes_revoked} minutes revoked.\nYou now have <color=#FF3300>{minutes_left}</color> minutes left before your Start Protection is disabled."},
                {"tFirstSpawn", "Start protection enabled for {minutes_left} minutes, during this time you will not be able to pvp on any level.\nYou can check how much time you have left - /sp time\nTo turn protection off - /sp end" },
                {"tSpawn", "You have {minutes_left} minutes left before your Start Protection is disabled."},
                {"cantDo", "You have PVP Protection and can't loot/pickup that.\n{minutes_left} minutes left before your Start Protection is disabled.\nTo turn protection off - /sp end"},
                {"tProtectionEnded", "Start protection <color=#FF3300>disabled</color>, you are now on your own."},
                {"tNoProtection", "Start protection status is currently <color=#FF3300>disabled</color>."},
                {"tAttackAttempt","The player you are trying to attack has Start Protection enabled and <color=#FF3300>cannot</color> be damaged."},
                {"tDisabled", "Start Protection is currently <color=#FF3300>disabled</color> server-wide."},
                {"tEnabled", "Start Protection has been <color=#66FF66>enabled</color>, new players will now be protected upon spawning."},
                {"tNoAuthLevel", "You <color=#FF3300>do not</color> have access to this command."},
                {"tDBCleared", "You have <color=#FF3300>cleared</color> the Start Protection database."},
                {"UIText", "NO PVP\n{0} min."},
                {"EndWarning", "<color=red>Warning!</color> Your protection will end in {0} seconds."},
                {"EndWarningRaid", "<color=red>Warning!</color> Leave RaidBlock or your protection will end in {0} seconds."},
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"title", "ÐÐ°ÑÐ¸ÑÐ°"},
                {"tPunishment", "<color=red>ÐÑ Ð½Ð°ÐºÐ°Ð·Ð°Ð½Ñ Ð·Ð° Ð¿Ð²Ð¿ Ñ Ð²ÐºÐ»ÑÑÐµÐ½Ð½Ð¾Ð¹ Ð·Ð°ÑÐ¸ÑÐ¾Ð¹!</color>\n{minutes_revoked} Ð¼Ð¸Ð½ÑÑ Ð¾ÑÐ½ÑÑÐ¾ Ð¾Ñ Ð·Ð°ÑÐ¸ÑÑ.\nÐÑÑÐ°Ð»Ð¾ÑÑ {minutes_left} Ð¼Ð¸Ð½ÑÑ Ð´Ð¾ ÐºÐ¾Ð½ÑÐ° Ð·Ð°ÑÐ¸ÑÑ.\nÐÑÐºÐ»ÑÑÐ¸ÑÑ ÑÐ²Ð¾Ñ Ð·Ð°ÑÐ¸ÑÑ - /sp end"},
                {"tFirstSpawn", "ÐÐ°ÑÐ¸ÑÐ° Ð¾Ñ Ð¿Ð²Ð¿ Ð²ÐºÐ»ÑÑÐµÐ½Ð° Ð½Ð° {minutes_left} Ð¼Ð¸Ð½ÑÑ, Ð² ÑÑÐ¾ Ð²ÑÐµÐ¼Ñ Ð½ÐµÐ»ÑÐ·Ñ Ð¿Ð²Ð¿.\n\nÐ¡ÐºÐ¾Ð»ÑÐºÐ¾ Ð²ÑÐµÐ¼ÐµÐ½Ð¸ Ð¾ÑÑÐ°Ð»Ð¾ÑÑ, Ð½Ð°Ð±ÐµÑÐ¸ÑÐµ - /sp time\n\nÐÑÐºÐ»ÑÑÐ¸ÑÑ ÑÐ²Ð¾Ñ Ð·Ð°ÑÐ¸ÑÑ - /sp end" },
                {"tSpawn", "ÐÑÑÐ°Ð»Ð¾ÑÑ {minutes_left} Ð¼Ð¸Ð½ÑÑ Ð´Ð¾ ÐºÐ¾Ð½ÑÐ° Ð·Ð°ÑÐ¸ÑÑ."},
                {"cantDo", "Ð¢Ñ Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑÑ Ð¿Ð¾Ð´ Ð·Ð°ÑÐ¸ÑÐ¾Ð¹ Ð¾Ñ Ð¿Ð²Ð¿ Ð¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÑ Ð¾ÑÐºÑÑÑÑ/Ð²Ð·ÑÑÑ ÑÑÐ¾.\nÐÑÑÐ°Ð»Ð¾ÑÑ {minutes_left} Ð¼Ð¸Ð½ÑÑ Ð´Ð¾ ÐºÐ¾Ð½ÑÐ° Ð·Ð°ÑÐ¸ÑÑ.\nÐÑÐºÐ»ÑÑÐ¸ÑÑ ÑÐ²Ð¾Ñ Ð·Ð°ÑÐ¸ÑÑ - /sp end "},
                {"tProtectionEnded", "ÐÐ°ÑÐ¸ÑÐ° Ð²ÑÐºÐ»ÑÑÐµÐ½Ð°."},
                {"tNoProtection", "ÐÐ°ÑÐ¸ÑÐ° Ð½Ð° Ð´Ð°Ð½Ð½ÑÐ¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ <color=#FF3300>Ð²ÑÐºÐ»ÑÑÐµÐ½Ð°</color>"},
                {"tAttackAttempt","ÐÐ³ÑÐ¾Ðº Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð¿Ð¾Ð´ Ð·Ð°ÑÐ¸ÑÐ¾Ð¹, ÐµÐ³Ð¾ <color=#FF3300>Ð½ÐµÐ»ÑÐ·Ñ</color> ÑÐ±Ð¸ÑÑ"},
                {"tDisabled", "ÐÐ°ÑÐ¸ÑÐ° <color=#FF3300>Ð²ÑÐºÐ»ÑÑÐµÐ½Ð°</color> Ð´Ð»Ñ ÑÐµÑÐ²ÐµÑÐ°."},
                {"tEnabled", "ÐÐ°ÑÐ¸ÑÐ° <color=#66FF66>Ð²ÐºÐ»ÑÑÐµÐ½Ð°</color>, Ð½Ð¾Ð²ÑÐµ Ð¸Ð³ÑÐ¾ÐºÐ¸ Ð±ÑÐ´ÑÑ Ð·Ð°ÑÐ¸ÑÐµÐ½Ñ."},
                {"tNoAuthLevel", "ÐÐµÑ Ð´Ð¾ÑÑÑÐ¿Ð° Ðº ÑÑÐ¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ðµ"},
                {"tDBCleared", "ÐÐ°Ð·Ð° Ð·Ð°ÑÐ¸ÑÑ Ð¾ÑÐ¸ÑÐµÐ½Ð°"},
                {"UIText", "NO PVP\n{0} Ð¼Ð¸Ð½."},
                {"EndWarning", "<color=red>ÐÐ½Ð¸Ð¼Ð°Ð½Ð¸Ðµ!</color> Ð¢Ð²Ð¾Ñ Ð·Ð°ÑÐ¸ÑÐ° Ð·Ð°ÐºÐ¾Ð½ÑÐ¸ÑÑÑ ÑÐµÑÐµÐ· {0} ÑÐµÐºÑÐ½Ð´."},
                {"EndWarningRaid", "<color=red>ÐÐ½Ð¸Ð¼Ð°Ð½Ð¸Ðµ!</color> ÐÐ¾ÐºÐ¸Ð½Ñ Ð·Ð¾Ð½Ñ ÑÐµÐ¹Ð´Ð° Ð¸Ð»Ð¸ ÑÐ²Ð¾Ñ Ð·Ð°ÑÐ¸ÑÐ° Ð·Ð°ÐºÐ¾Ð½ÑÐ¸ÑÑÑ ÑÐµÑÐµÐ· {0} ÑÐµÐºÑÐ½Ð´."},
            }, this,"ru");
        }
        string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);

        #endregion
    }
}

// --- End of file: StartProtection.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/scraponomics-lite ---
// --- Original File Path: S/ScraponomicsLite/ScraponomicsLite.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("Scraponomics Lite", "haggbart", "1.0.0")]
    [Description("Adds ATM UI with simple, intuitive functionality to vending machines and bandit vendors")]
    internal class ScraponomicsLite : RustPlugin
    {
        #region localization
        
        private const string LOC_PAID_BROKERAGE = "PaidBrokerage";
        private const string LOC_DEPOSIT = "Deposit";
        private const string LOC_WITHDRAW = "Withdraw";
        private const string LOC_AMOUNT = "Amount";
        private const string LOC_BALANCE = "Balance";
        private const string LOC_ATM = "ATM";
        private const string LOC_REWARD_INTEREST = "RewardInterst";

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LOC_PAID_BROKERAGE] = "Paid the brokerage fee of {0} scrap.",
                [LOC_DEPOSIT] = "Deposit",
                [LOC_WITHDRAW] = "Withdraw",
                [LOC_BALANCE] = "Balance: {0} scrap",
                [LOC_AMOUNT] = "amount",
                [LOC_ATM] = "ATM",
                [LOC_REWARD_INTEREST] = "You've earned {0} scrap in interest."
            }, this);
        }

        #endregion localization
        

        #region data
        private void SaveData() =>
            Interface.Oxide.DataFileSystem.WriteObject(Name, playerData);

        private void ReadData() =>
            playerData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerData>>(Name);

        private static Dictionary<ulong, PlayerData> playerData;
        private static readonly Dictionary<ulong, PlayerPreference> playerPrefs = new Dictionary<ulong, PlayerPreference>();

        private class PlayerData
        {
            public int scrap { get; set; }
            public DateTime lastInterest = DateTime.UtcNow;
        }
        
        private class PlayerPreference
        { 
            public int amount { get; set; }
        }
        
        #endregion data

        #region config
        
        private PluginConfig config;

        private class PluginConfig
        {
            public float feesFraction;
            public int startingBalance;
            public bool allowPlayerVendingMachines;
            public bool resetOnMapWipe;
            public float interestRate;
        }
        
        protected override void LoadDefaultConfig() => Config.WriteObject(GetDefaultConfig(), true);
        private new void SaveConfig() => Config.WriteObject(config, true);
        
        private static PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                feesFraction = 0.05f,
                startingBalance = 50,
                allowPlayerVendingMachines = false,
                resetOnMapWipe = true,
                interestRate = 0.10f
            };
        }
        
        
        #endregion config
        
        #region init

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();

            if (!config.resetOnMapWipe)
            {
                Unsubscribe(nameof(OnNewSave));
            }

            SaveConfig();
            ReadData();
        }

        private void InitPlayerData(BasePlayer player)
        {
            var playerbalances = new PlayerData
            {
                scrap = config.startingBalance
            };
            playerData.Add(player.userID, playerbalances);
        }
        
        private static void InitPlayerPerference(BasePlayer player)
        {
            var playerPreference = new PlayerPreference
            {
                amount = 100
            };
            playerPrefs.Add(player.userID, playerPreference);
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                DestroyGuiAll(player);
            }
            
            SaveData();
        }
        
        #endregion init
        
        
        #region methods
        
        private void DoInterest(BasePlayer player)
        {
            PlayerData data = playerData[player.userID];

            if (data.scrap < 1) return;
            
            TimeSpan timeSinceLastInterest = DateTime.UtcNow - data.lastInterest;
            if (timeSinceLastInterest.Days == 0)
            {
                return;
            }
            
            int interest = (int) (data.scrap * Math.Pow(config.interestRate + 1.0f, 
                timeSinceLastInterest.TotalSeconds / 86400.0)) - data.scrap;
            
            if (interest < 1) return;
            data.scrap += interest;
            data.lastInterest = DateTime.UtcNow;

            SendReply(player, lang.GetMessage(LOC_REWARD_INTEREST, this, player.UserIDString), interest);
        }
        
        #endregion methods

        #region hooks
        
        private void OnServerSave()
        {
            SaveData();
        }

        private void OnNewSave(string filename)
        {
            playerData = new Dictionary<ulong, PlayerData>();
            SaveData();
        }

        private void OnVendingShopOpened(VendingMachine machine, BasePlayer player)
        {
            if (!(machine is NPCVendingMachine) && !config.allowPlayerVendingMachines) return;
            
            if (!playerData.ContainsKey(player.userID))
            {
                InitPlayerData(player);
            }
            
            DoInterest(player);

            NextTick(() => CreateUi(player)); 
        }
        
        private void OnLootEntityEnd(BasePlayer player, VendingMachine machine)
        {
            DestroyGuiAll(player);
        }

        private static void DestroyGuiAll(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, CUI_BANK_NAME);
        }
        
        #endregion hooks

        #region bank CUI
        
        private const int CUI_MAIN_FONTSIZE = 10;
        private const string CUI_MAIN_FONT_COLOR = "0.7 0.7 0.7 1.0";
        private const string CUI_GREEN_BUTTON_COLOR = "0.415 0.5 0.258 0.4";
        private const string CUI_GREEN_BUTTON_FONT_COLOR = "0.607 0.705 0.431";
        private const string CUI_GRAY_BUTTON_COLOR = "0.75 0.75 0.75 0.3";
        private const string CUI_BUTTON_FONT_COLOR = "0.77 0.68 0.68 1";
        private const string CUI_BANK_NAME = "BankUI";
        private const string CUI_BANK_HEADER_NAME = "header";
        private const string CUI_BANK_CONTENT_NAME = "content";
        
        private const string ANCHOR_MIN = "0.5 0.0";
        private const string ANCHOR_MAX = "0.67 0.0";
        private const string OFFSET_MIN = "193 16";
        private const string OFFSET_MAX = "200 97";

        private void CreateUi(BasePlayer player) 
        {
            if (!player.inventory.loot.IsLooting()) return;
            
            
            if (!playerPrefs.ContainsKey(player.userID))
            {
                InitPlayerPerference(player);
            }

            int amount = playerPrefs[player.userID].amount;
            

            double nextDecrement = amount / 1.5;
            double nextIncrement = amount * 1.5;
            
            CuiHelper.DestroyUi(player, CUI_BANK_NAME);
            
            var bankCui = new CuiElementContainer
            {
                {
                    new CuiPanel // main panel
                    {
                        Image = new CuiImageComponent {Color = "0 0 0 0"},
                        RectTransform =
                        {
                            AnchorMin = ANCHOR_MIN, AnchorMax = ANCHOR_MAX,
                            OffsetMin = OFFSET_MIN, OffsetMax = OFFSET_MAX
                        }
                    },
                    "Hud.Menu", CUI_BANK_NAME
                },
                {
                    new CuiPanel // header
                    {
                        Image = new CuiImageComponent {Color = "0.75 0.75 0.75 0.35"},
                        RectTransform = {AnchorMin = "0 0.775", AnchorMax = "1 1"}
                    },
                    CUI_BANK_NAME, CUI_BANK_HEADER_NAME
                },
                {
                    new CuiLabel // header label
                    {
                        RectTransform = {AnchorMin = "0.051 0", AnchorMax = "1 0.95"},
                        Text = {Text = lang.GetMessage(
                            LOC_ATM, this, player.UserIDString), 
                            Align = TextAnchor.MiddleLeft, Color = "0.77 0.7 0.7 1", FontSize = 13}
                    },
                    CUI_BANK_HEADER_NAME
                },
                {
                    new CuiPanel // content panel
                    {
                        Image = new CuiImageComponent {Color = "0.65 0.65 0.65 0.25"},
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 0.74"}
                    },
                    CUI_BANK_NAME, CUI_BANK_CONTENT_NAME
                },
                {
                    new CuiLabel // balance label
                    {
                        RectTransform = {AnchorMin = "0.02 0.7", AnchorMax = "0.98 1"},
                        Text =
                        {
                            Text = string.Format(lang.GetMessage(LOC_BALANCE, this, 
                                player.UserIDString), playerData[player.userID].scrap),
                            Align = TextAnchor.MiddleLeft,
                            Color = CUI_MAIN_FONT_COLOR,
                            FontSize = CUI_MAIN_FONTSIZE
                        }
                    },
                    CUI_BANK_CONTENT_NAME
                },
                {
                    new CuiButton // deposit button
                    {
                        RectTransform = {AnchorMin = "0.02 0.4", AnchorMax = "0.25 0.7"},
                        Button = {Command = "sc.deposit " + amount, Color = CUI_GREEN_BUTTON_COLOR},
                        Text =
                        {
                            Align = TextAnchor.MiddleCenter,
                            Text = lang.GetMessage(LOC_DEPOSIT, this, player.UserIDString),
                            Color = CUI_GREEN_BUTTON_FONT_COLOR,
                            FontSize = 11
                        }
                    },
                    CUI_BANK_CONTENT_NAME
                },
                {
                    new CuiButton // withdraw button
                    {
                        RectTransform = {AnchorMin = "0.27 0.4", AnchorMax = "0.52 0.7"},
                        Button = {Command = "sc.withdraw " + amount, Color = CUI_GRAY_BUTTON_COLOR},
                        Text = {Align = TextAnchor.MiddleCenter, Text = lang.GetMessage(
                            LOC_WITHDRAW, this, player.UserIDString), Color = CUI_MAIN_FONT_COLOR, FontSize = 11}
                    },
                    CUI_BANK_CONTENT_NAME
                },
                {
                    new CuiButton // decrement button
                    {
                        RectTransform = {AnchorMin = "0.02 0.05", AnchorMax = "0.07 0.35"},
                        Button = {Command = "sc.setamount " + nextDecrement, Color = CUI_GRAY_BUTTON_COLOR},
                        Text =
                        {
                            Align = TextAnchor.MiddleCenter,
                            Text = "<",
                            Color = CUI_BUTTON_FONT_COLOR,
                            FontSize = CUI_MAIN_FONTSIZE
                        }
                    },
                    CUI_BANK_CONTENT_NAME
                },
                {
                    new CuiLabel // amount label
                    {
                        RectTransform = {AnchorMin = "0.08 0.05", AnchorMax = "0.19 0.35"},
                        Text =
                        {
                            Align = TextAnchor.MiddleCenter,
                            Text = amount.ToString(),
                            Color = CUI_MAIN_FONT_COLOR,
                            FontSize = CUI_MAIN_FONTSIZE
                        }
                    },
                    CUI_BANK_CONTENT_NAME
                },
                {
                    new CuiButton // increment button
                    {
                        RectTransform = {AnchorMin = "0.19 0.05", AnchorMax = "0.25 0.35"},
                        Button = {Command = "sc.setamount " + nextIncrement, Color = CUI_GRAY_BUTTON_COLOR},
                        Text =
                        {
                            Align = TextAnchor.MiddleCenter,
                            Text = ">",
                            Color = CUI_BUTTON_FONT_COLOR,
                            FontSize = CUI_MAIN_FONTSIZE
                        }
                    },
                    CUI_BANK_CONTENT_NAME
                },
                {
                    new CuiLabel // amount text label
                    {
                        RectTransform = {AnchorMin = "0.27 0.05", AnchorMax = "1 0.35"},
                        Text =
                        {
                            Align = TextAnchor.MiddleLeft,
                            Text = lang.GetMessage(LOC_AMOUNT, this, player.UserIDString),
                            Color = CUI_MAIN_FONT_COLOR,
                            FontSize = CUI_MAIN_FONTSIZE
                        }
                    },
                    CUI_BANK_CONTENT_NAME
                }
            };

            CuiHelper.AddUi(player, bankCui);
        }

        [ConsoleCommand("sc.setamount")]
        private void CmdSetAmount(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null || arg.Args.Length != 1 || 
                !(player.inventory.loot.entitySource is VendingMachine)) return;
            
            double amount;
            if (!double.TryParse(arg.Args[0], out amount)) return;
            
            amount = Math.Round(amount / 10) * 10;
            
            if (amount < 10) amount = 10;
            else if (amount > 1000) amount = 1000;

            if (arg.Args.Length != 1) return;
            
            if (!playerPrefs.ContainsKey(player.userID))
            {
                InitPlayerPerference(player);
            }
            playerPrefs[player.userID].amount = (short) amount;
            CreateUi(player);
        }

        [ConsoleCommand("sc.deposit")]
        private void CmdDeposit(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null || arg.Args.Length != 1 || 
                !(player.inventory.loot.entitySource is VendingMachine)) return;
            
            int amount;
            if (!int.TryParse(arg.Args[0], out amount)) return;
            
            if (player.inventory.GetAmount(-932201673) < amount)
            {
                amount = player.inventory.GetAmount(-932201673);
            }
            if (amount == 0) return;
            
            if (!playerData.ContainsKey(player.userID))
            {
                InitPlayerData(player);
            }
            playerData[player.userID].scrap += amount;
            player.inventory.Take(null, -932201673, amount);
            CreateUi(player);
        }

        [ConsoleCommand("sc.withdraw")]
        private void CmdWithdraw(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null || arg.Args.Length != 1 || 
                !(player.inventory.loot.entitySource is VendingMachine)) return;

            int amount;
            if (!int.TryParse(arg.Args[0], out amount)) return;

            if (!playerData.ContainsKey(player.userID))
            {
                InitPlayerData(player);
            }
            int balance = playerData[player.userID].scrap;
            if (balance < amount) amount = balance;
            var tax = (int)Math.Round(amount * config.feesFraction);

            if (tax < 1) tax = 1;
            if (amount < 1) return;
            
            playerData[player.userID].scrap -= amount + tax;
            CreateUi(player);
            Item item = ItemManager.CreateByItemID(-932201673, amount);
            if (item == null) return;
            player.inventory.GiveItem(item);
            SendReply(player, string.Format(
                lang.GetMessage(LOC_PAID_BROKERAGE, this, player.UserIDString), tax));
        }
        
        #endregion bank CUI

        #region API

        private object SetBalance(ulong userId, int balance)
        {
            if (!playerData.ContainsKey(userId) && !TryInitPlayer(userId)) return null;

            playerData[userId].scrap = balance;
            return true;
        }

        private object GetBalance(ulong userId)
        {
            if (!playerData.ContainsKey(userId) && !TryInitPlayer(userId)) return null;
            return playerData[userId].scrap;
        }

        private bool TryInitPlayer(ulong userId)
        {
            BasePlayer player = BasePlayer.FindByID(userId);
            if (player == null) return false;
            InitPlayerData(player);
            return true;
        }
        
        #endregion API
    }
}


// --- End of file: ScraponomicsLite.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/slack-notices ---
// --- Original File Path: S/SlackNotices/SlackNotices.cs ---

// Requires: Slack

/*
TODO:
- Add option to send all server info every X seconds
*/

using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("SlackNotices", "Wulf/lukespragg", "0.1.2", ResourceId = 1957)]
    [Description("Sends connection and disconnection notices to Slack channel")]

    class SlackNotices : CovalencePlugin
    {
        // Do NOT edit this file, instead edit SlackNotices.en.json in oxide/lang,
        // or create a language file for another language using the 'en' file as a default.

        [PluginReference] Plugin Slack;

        void Init()
        {
            LoadDefaultConfig();
            LoadDefaultMessages();

            if (!connections) Unsubscribe("OnUserConnected");
            if (!disconnections) Unsubscribe("OnUserDisconnected");
        }

        #region Configuration

        string channel;
        bool connections;
        bool disconnections;

        protected override void LoadDefaultConfig()
        {
            Config["Channel"] = channel = GetConfig("Channel", "");
            Config["Connections"] = connections = GetConfig("Connections", true);
            Config["Disconnections"] = disconnections = GetConfig("Disconnections", true);
            SaveConfig();
        }

        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Connected"] = "*{0}* _({1})_ connected",
                ["Disconnected"] = "*{0}* _({1})_ disconnected, reason: {2}",
                ["Unknown"] = "Unknown"
            }, this);
        }

        #endregion

        #region Hooks

        void OnUserConnected(IPlayer player) => Slack.Call("Message", Lang("Connected", null, player.Name, player.Id), channel);

        void OnUserDisconnected(IPlayer player, string reason)
        {
            reason = reason.Equals("Disconnected") ? Lang("Unknown") : reason;
            Slack.Call("Message", Lang("Disconnected", null, player.Name, player.Id, reason), channel);
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}

// --- End of file: SlackNotices.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/scoreboards ---
// --- Original File Path: S/Scoreboards/Scoreboards.cs ---

ï»¿using System.Collections.Generic;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("Scoreboards", "LaserHydra", "1.0.2")]
    [Description("Provides a simple scoreboard API system")]
    class Scoreboards : RustPlugin
    {
        static Scoreboards Instance;
        static ScoreboardData Data;

        #region Config Variables

        static string AnchorMin;
        static string AnchorMax;

        static string BackgroundColor;

        static string HeaderColor;
        static string TitleColor;
        static string ContentColor;

        #endregion

        #region Classes

        public class ScoreboardData
        {
            public string ActiveScoreboard = string.Empty;
            public List<Scoreboard> All = new List<Scoreboard>();
        }

        public class Scoreboard
        {
            public static Scoreboard Find(string Title) => Data.All.Find((s) => s.Title == Title);

            public string Title;
            public string Description;
            internal bool Active => Data.ActiveScoreboard == Title;

            internal KeyValuePair<string, string>[] Entries = new KeyValuePair<string, string>[0];

            public override int GetHashCode() => Title.GetHashCode();

            public void Remove() => Data.All.Remove(this);

            public void SetActive() => SetActiveScoreboard(this);

            public void SetEntries(KeyValuePair<string, string>[] Entries)
            {
                this.Entries = Entries;
                Instance.ScoreboardUpdated(this);
            }

            public static void SetActiveScoreboard(Scoreboard scoreboard)
            {
                Data.ActiveScoreboard = scoreboard.Title;
                Instance.ActiveScoreboardChanged(scoreboard);
            }

            public static Scoreboard GetActiveScoreboard() => Data.All.Find((s) => s.Active);

            public static void AddScoreboard(Scoreboard scoreboard)
            {
                if (!Data.All.Contains(scoreboard))
                {
                    Data.All.Add(scoreboard);
                    Instance.WriteData(Data);
                }
            }
        }

        #endregion

        #region API

        void UpdateScoreboard(string ScoreboardTitle, KeyValuePair<string, string>[] Entries)
        {
            var scoreboard = Scoreboard.Find(ScoreboardTitle);

            if (scoreboard == null)
                return;

            scoreboard.SetEntries(Entries);
        }

        void CreateScoreboard(string ScoreboardTitle, string ScoreboardDescription, KeyValuePair<string, string>[] Entries)
        {
            if (Scoreboard.Find(ScoreboardTitle) != null)
                return;

            Scoreboard.AddScoreboard(new Scoreboard { Title = ScoreboardTitle, Description = ScoreboardDescription, Entries = Entries.Take(10).ToArray() });
        }

        void RemoveScoreboard(string ScoreboardTitle)
        {
            var scoreboard = Scoreboard.Find(ScoreboardTitle);

            if (scoreboard == null)
                return;

            scoreboard.Remove();
        }

        #endregion

        #region Scoreboards

        void ScoreboardUpdated(Scoreboard scoreboard)
        {
            WriteData(Data);

            if (scoreboard.Active)
                UpdateScoreboardUI();
        }

        void ActiveScoreboardChanged(Scoreboard scoreboard)
        {
            UpdateScoreboardUI();
            WriteData(Data);
        }

        void UpdateScoreboardUI()
        {
            foreach (var player in BasePlayer.activePlayerList)
                DrawScoreboardUI(player);
        }

        void DrawScoreboardUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "Scoreboard");

            var cui = GetCUI();
            
            if (cui != null)
                CuiHelper.AddUi(player, cui);
        }

        static CuiElementContainer GetCUI()
        {
            var activeScoreboard = Scoreboard.GetActiveScoreboard();

            if (activeScoreboard == null)
                return null;

            CuiElementContainer elements = new CuiElementContainer();

            elements.Add(new CuiPanel
            {
                Image =
                {
                    Color = BackgroundColor
                },
                RectTransform =
                {
                    AnchorMin = AnchorMin,
                    AnchorMax = AnchorMax
                }
            }, "Under", "Scoreboard");

            elements.Add(new CuiElement
            {
                Name = "Header",
                Parent = "Scoreboard",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = "Scoreboard",
                        Align = TextAnchor.LowerCenter,
                        FontSize = 28,
                        Color = HeaderColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.06372549 0.8822171",
                        AnchorMax = "0.9411765 0.9676675"
                    }
                }
            });

            elements.Add(new CuiElement
            {
                Name = "Title",
                Parent = "Scoreboard",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = activeScoreboard.Title,
                        Align = TextAnchor.UpperCenter,
                        FontSize = 18,
                        Color = TitleColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.06372549 0.8337182",
                        AnchorMax = "0.9411765 0.8960739"
                    }
                }
            });

            elements.Add(new CuiElement
            {
                Name = "Contents",
                Parent = "Scoreboard",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = string.Join("\n", activeScoreboard.Entries.Select((kvp) => $"{kvp.Key}: {kvp.Value}").ToArray()),
                        Align = TextAnchor.UpperCenter,
                        FontSize = 18,
                        Color = ContentColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.06372549 0.0277136",
                        AnchorMax = "0.9411765 0.8337182"
                    }
                }
            });

            return elements;
        }

        #endregion

        #region Commands

        [ChatCommand("scoreboard")]
        void cmdScoreboard(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "scoreboards.admin"))
            {
                SendReply(player, LangMsg("No Permission", player.userID));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, "/scoreboard <select|disable|list>");
                return;
            }

            switch (args[0].ToLower())
            {
                case "select":
                    if (args.Length != 2)
                    {
                        SendReply(player, "Syntax: /scoreboard select <scoreboard>");
                        return;
                    }

                    var scoreboard = Scoreboard.Find(args[1]);

                    if (scoreboard == null)
                    {
                        SendReply(player, LangMsg("Scoreboard Does Not Exist", player.userID, args[1]));
                        return;
                    }

                    scoreboard.SetActive();
                    SendReply(player, LangMsg("Scoreboard Selected", player.userID, scoreboard.Title));

                    break;

                case "disable":

                    Scoreboard.SetActiveScoreboard(new Scoreboard { Title = string.Empty });
                    SendReply(player, LangMsg("Scoreboard Disabled", player.userID));

                    break;

                case "list":

                    SendReply(player, $"Scoreboards:{Environment.NewLine}{string.Join(Environment.NewLine, Data.All.Select((s) => $"{s.Title} - {s.Description}").ToArray())}");

                    break;

                default:
                    SendReply(player, "/scoreboard <select|disable|list>");
                    break;
            }
        }

        #endregion

        #region Hooks

        void Init()
        {
            Instance = this;

            permission.RegisterPermission("scoreboards.admin", this);
            ReadData(out Data);
            LoadConfig();
        }

        void OnServerInitialized()
        {
            CreateScoreboard("Bullets Fired", "Shows the amount of fired bullets", new KeyValuePair<string, string>[0]);

            UpdateScoreboardUI();
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, "Scoreboard");
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            DrawScoreboardUI(player);
        }

        #endregion
        
        #region Loading

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "No Permission", "You do not have permission to do that." }
            }, this);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            AnchorMin = UpdateConfig<string>("Anchor Min", "0.83 0.21");
            AnchorMax = UpdateConfig<string>("Anchor Max", "0.98 0.91");

            BackgroundColor = UpdateConfig<string>("Background Color", "0.3 0.3 0.3 0.7");

            HeaderColor = UpdateConfig<string>("Header Color", "0.66 1 0 1");
            TitleColor = UpdateConfig<string>("Title Color", "0 0 0 1");
            ContentColor = UpdateConfig<string>("Content Color", "0 0 0 1");

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file...");

        #endregion

        #region Helpers

        string LangMsg(string key, object id = null, params string[] replacements) => string.Format(lang.GetMessage(key, this, id == null ? null : id.ToString()), replacements);

        DataValue ReadData<DataValue>(out DataValue data, string filename = null) => data = Core.Interface.Oxide.DataFileSystem.ReadObject<DataValue>(filename == null ? GetType().Name : $"{GetType().Name}/{filename}");
        void WriteData<DataValue>(DataValue data, string filename = null) => Core.Interface.Oxide.DataFileSystem.WriteObject(filename == null ? GetType().Name : $"{GetType().Name}/{filename}", data);

        ConfigValue UpdateConfig<ConfigValue>(params object[] fullPath)
        {
            List<string> pathL = fullPath.Select((v) => (string)v).ToList();
            pathL.RemoveAt(pathL.Count - 1);
            string[] path = pathL.ToArray();

            if (Config.Get(path) == null)
            {
                PrintWarning("Generating config value: {0}", string.Join("/", path));
                Config.Set(fullPath);
            }

            return (ConfigValue)Convert.ChangeType(Config.Get(path), typeof(ConfigValue));
        }

        #endregion
    }
}

// --- End of file: Scoreboards.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/scrap-heli-storage ---
// --- Original File Path: S/ScrapHeliStorage/ScrapHeliStorage.cs ---

using UnityEngine;
using Oxide.Core.Configuration;
using System.Linq;
using System;

namespace Oxide.Plugins {

	[Info("Scrap Heli Storage", "yetzt", "0.0.5")]
	[Description("Adds Storage Boxes to Scrap Transport Helicopters")]

	public class ScrapHeliStorage : RustPlugin {

		private string prefab = "assets/content/vehicles/boats/rhib/subents/rhib_storage.prefab";

		#region Config
		private PluginConfig config;
		private int num;
		private bool retrofit;
		
		protected override void LoadDefaultConfig() {
			Config.WriteObject(GetDefaultConfig(), true);
		}

		private PluginConfig GetDefaultConfig() {
			return new PluginConfig
			{
				Enabled = true,
				NumBoxes = 2,
				Retrofit = false
			};
		}

		private class PluginConfig {
			public bool Enabled;
			public int NumBoxes;
			public bool Retrofit;
		}
		#endregion

		#region Oxide
		private void Init() {
			config = Config.ReadObject<PluginConfig>();
			
			try {
				num = Convert.ToInt32(config.NumBoxes);
			} catch {
				num = 2;
			}

			if (num < 1) num = 1;
			if (num > 2) num = 2;
			
			try {
				retrofit = Convert.ToBoolean(config.Retrofit);
			} catch {
				retrofit = false;
			}
			
		}
		
		// add boxes to already existing copters without boxes when plugin is loaded
		void OnServerInitialized(){
			if (retrofit) RetrofitBoxes();
		}

		void RetrofitBoxes(){
			// find existing copters and add bxes
			var copters = GameObject.FindObjectsOfType<ScrapTransportHelicopter>();
			for (int i = 0; i < copters.Length; i++) {
				AddBoxes(copters[i]);
			}
		}

		private void OnEntitySpawned(ScrapTransportHelicopter entity) {
			if (entity == null || !config.Enabled) return;

			// defer checking to ensure storage box is loaded (loads after parent, race condition there)
			timer.Once(0.1f, () => {
				AddBoxes(entity);
			});

		}
		
		private void AddBoxes(ScrapTransportHelicopter entity) {
			if (entity == null || !config.Enabled || num == 0) return;

			// check if there is already a box
			foreach (var child in entity.GetComponentsInChildren<StorageContainer>(true)) {
				if (child.name == prefab) return;
			}
					
			// Putting the Transport in Transport Helicopter
			if (num == 1) {

				var box = GameManager.server?.CreateEntity(prefab, entity.transform.position) as StorageContainer;
				if (box == null) return;
				box.Spawn();
				box.SetParent(entity);
				box.transform.localPosition = new Vector3(0f, 0.85f, 1.75f);
				box.transform.Rotate(new Vector3(0.0f, 0.0f, 0.0f));
				box.SendNetworkUpdateImmediate(true);
				
			} else if (num == 2) {

				var box = GameManager.server?.CreateEntity(prefab, entity.transform.position) as StorageContainer;
				if (box == null) return;
				box.Spawn();
				box.SetParent(entity);
				box.transform.localPosition = new Vector3(-0.5f, 0.85f, 1.75f);
				box.transform.Rotate(new Vector3(0.0f, 0.0f, 0.0f));
				box.SendNetworkUpdateImmediate(true);

				var box2 = GameManager.server?.CreateEntity(prefab, entity.transform.position) as StorageContainer;
				if (box2 == null) return;
				box2.Spawn();
				box2.SetParent(entity);
				box2.transform.localPosition = new Vector3(0.5f, 0.85f, 1.75f);
				box2.transform.Rotate(new Vector3(0.0f, 0.0f, 0.0f));
				box2.SendNetworkUpdateImmediate(true);
				
			}

		}

		// drop items when entity is killed (don't want salty tears)
		private void OnEntityKill(ScrapTransportHelicopter entity) {
			if (entity == null) return;
			foreach (var child in entity.GetComponentsInChildren<StorageContainer>(true)) {
				if (child.name == prefab) {
					child.DropItems();
				}
			}
		}
		
		#endregion
	}
}



// --- End of file: ScrapHeliStorage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/suicide-bomber ---
// --- Original File Path: S/SuicideBomber/SuicideBomber.cs ---

ï»¿using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info ("SuicideBomber", "Calytic", "0.0.31")]
    class SuicideBomber : RustPlugin
    {
        float damage;
        float radius;
        int explosives;
        int c4;
        bool flare;
        bool scream;

        Dictionary<string, string> messages = new Dictionary<string, string> ();

        List<string> texts = new List<string> () {
            "You lack the required {0} timed explosives",
            "You lack the required {0} explosives",
            "You lack the required flare",
            "You will explode shortly..",
        };

        void OnServerInitialized ()
        {
            damage = GetConfig ("damage", 1200f);
            radius = GetConfig ("radius", 12f);
            c4 = GetConfig ("c4", 1);
            explosives = GetConfig ("explosives", 10);
            scream = GetConfig ("scream", true);
            flare = GetConfig ("flare", true);

            Dictionary<string, object> customMessages = GetConfig<Dictionary<string, object>> ("messages", null);
            if (customMessages != null) {
                foreach (KeyValuePair<string, object> kvp in customMessages) {
                    messages [kvp.Key] = kvp.Value.ToString ();
                }
            }

            LoadData ();
        }

        void LoadData ()
        {
            if (Config ["VERSION"] == null) {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig ();
            } else if (GetConfig ("VERSION", Version.ToString ()) != Version.ToString ()) {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig ();
            }
        }

        protected void ReloadConfig ()
        {
            Dictionary<string, object> messages = new Dictionary<string, object> ();

            foreach (string text in texts) {
                if (!messages.ContainsKey (text)) {
                    messages.Add (text, text);
                }
            }

            Config ["messages"] = messages;
            Config ["VERSION"] = Version.ToString ();

            // NEW CONFIGURATION OPTIONS HERE
            // END NEW CONFIGURATION OPTIONS

            PrintWarning ("Upgrading Configuration File");
            this.SaveConfig ();
        }

        protected override void LoadDefaultConfig ()
        {
            PrintWarning ("Creating new configuration");
            Config.Clear ();

            Dictionary<string, object> messages = new Dictionary<string, object> ();

            foreach (string text in texts) {
                if (messages.ContainsKey (text)) {
                    PrintWarning ("Duplicate translation string: " + text);
                } else {
                    messages.Add (text, text);
                }
            }

            Config ["messages"] = messages;
            Config ["damage"] = 1200f;
            Config ["radius"] = 12f;
            Config ["explosives"] = 10;
            Config ["c4"] = 1;
            Config ["scream"] = true;
            Config ["flare"] = true;
            Config ["VERSION"] = Version.ToString ();
        }

        private T GetConfig<T> (string name, T defaultValue)
        {
            if (Config [name] == null) {
                return defaultValue;
            }

            return (T)Convert.ChangeType (Config [name], typeof (T));
        }

        void OnPlayerInput (BasePlayer player, InputState input)
        {
            Item activeItem = player.GetActiveItem ();

            if (activeItem != null && activeItem.info.shortname == "targeting.computer" && input.WasJustPressed (BUTTON.USE)) {
                bool fail = false;
                if (c4 > 0) {
                    int c4_amount = player.inventory.GetAmount (1248356124);
                    if (c4_amount < c4) {
                        Effect.server.Run ("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                        SendReply (player, messages ["You lack the required {0} timed explosives"], c4);
                        fail = true;
                    }
                }

                if (explosives > 0) {
                    int explosives_amount = player.inventory.GetAmount (-592016202);
                    if (explosives_amount < explosives) {
                        Effect.server.Run ("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                        SendReply (player, messages ["You lack the required {0} explosives"], explosives);
                        fail = true;
                    }
                }

                if (flare) {
                    int flare_amount = player.inventory.GetAmount (304481038);
                    if (flare_amount < 1) {
                        Effect.server.Run ("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                        SendReply (player, messages ["You lack the required flare"]);
                        fail = true;
                    }
                }

                if (fail) {
                    return;
                } else {
                    player.inventory.Take (null, 1248356124, c4);
                    player.inventory.Take (null, -592016202, explosives);
                    player.inventory.Take (null, 304481038, 1);
                }

                SendReply (player, messages ["You will explode shortly.."]);

                activeItem.Remove (0f);
                activeItem.RemoveFromContainer ();

                Effect.server.Run ("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", player.transform.position);

                timer.Once (2f, delegate () {
                    Effect.server.Run ("assets/prefabs/locks/keypad/effects/lock.code.lock.prefab", player.transform.position);
                });

                if (scream) {
                    timer.Once (3f, delegate () {
                        Effect.server.Run ("assets/bundled/prefabs/fx/player/beartrap_scream.prefab", player.transform.position);
                    });
                }

                timer.Once (4f, delegate () {
                    Effect.server.Run ("assets/prefabs/locks/keypad/effects/lock.code.lock.prefab", player.transform.position);
                });

                timer.Once (6f, delegate () {
                    Effect.server.Run ("assets/bundled/prefabs/fx/firebomb.prefab", player.transform.position);
                    Effect.server.Run ("assets/bundled/prefabs/fx/gas_explosion_small.prefab", player.transform.position);

                    Effect.server.Run ("assets/prefabs/npc/patrol helicopter/effects/rocket_explosion.prefab", player.transform.position);
                    Effect.server.Run ("assets/prefabs/npc/patrol helicopter/effects/rocket_explosion.prefab", player.transform.position);
                    Effect.server.Run ("assets/prefabs/npc/patrol helicopter/effects/rocket_explosion.prefab", player.transform.position);
                });

                timer.Once (6.2f, delegate () {
                    Effect.server.Run ("assets/prefabs/tools/c4/effects/c4_explosion.prefab", player.transform.position);

                    List<BaseCombatEntity> entities = new List<BaseCombatEntity> ();
                    Vis.Entities (player.transform.position, radius / 3, entities);

                    foreach (BaseCombatEntity e in entities) {
                        e.Hurt (damage, Rust.DamageType.Explosion, player, true);
                    }

                    List<BaseCombatEntity> entities2 = new List<BaseCombatEntity> ();
                    Vis.Entities (player.transform.position, radius / 2, entities2);

                    foreach (BaseCombatEntity e in entities2) {
                        if (entities.Contains (e)) {
                            continue;
                        }
                        e.Hurt (damage / 2, Rust.DamageType.Explosion, player, true);
                    }

                    List<BaseCombatEntity> entities3 = new List<BaseCombatEntity> ();
                    Vis.Entities (player.transform.position, radius, entities3);

                    foreach (BaseCombatEntity e in entities3) {
                        if (entities.Contains (e) || entities2.Contains (e)) {
                            continue;
                        }

                        e.Hurt (damage / 4, global::Rust.DamageType.Explosion, player, true);
                    }

                    if (player.net.connection.authLevel == 0) {
                        player.Die ();
                    }
                });

                timer.Once (6.4f, delegate () {
                    Effect.server.Run ("assets/prefabs/tools/c4/effects/c4_explosion.prefab", player.transform.position);
                });
            }
        }
    }
}

// --- End of file: SuicideBomber.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/save-announcer ---
// --- Original File Path: S/SaveAnnouncer/SaveAnnouncer.cs ---

ï»¿using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Save Announcer", "Ryan", "1.0.4")]
    [Description("Announces to all players when the server saves")]
    public class SaveAnnouncer : RustPlugin
    {
        [PluginReference]
        private Plugin GUIAnnouncements;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file.");
            Config["Settings", "Enable Console Notice"] = false;
            Config["Entity Settings", "Enable Entity Message"] = true;
            Config["Entity Settings", "Amount To Trigger Entity Message"] = 150000;
            Config["GUIAnnouncements Settings", "Enable GUI Announcements"] = false;
            Config["GUIAnnouncements Settings", "Banner Color"] = "Grey";
            Config["GUIAnnouncements Settings", "Text Color"] = "White";
        }

        // Settings
        private bool consoleAnnoucement() => Convert.ToBoolean(Config["Settings", "Enable Console Notice"]);

        // Entity Settings
        private bool entAnnoucement() => Convert.ToBoolean(Config["Entity Settings", "Enable Entity Message"]);
        private int entAmount() => int.Parse(Config["Entity Settings", "Amount To Trigger Entity Message"].ToString());

        // GUIAnnouncements Settings
        private bool guiAnnoucements() => Convert.ToBoolean(Config["GUIAnnouncements Settings", "Enable GUI Announcements"]);
        private string guiColor() => Config["GUIAnnouncements Settings", "Banner Color"].ToString();
        private string guiTextColor() => Config["GUIAnnouncements Settings", "Text Color"].ToString();

        private string constructMsg()
        {
            int entCount = ConVar.Admin.ServerInfo().EntityCount;
            if (entAnnoucement())
            {
                if (entCount >= entAmount())
                {
                    return Lang("EntityMsg", null, entCount);
                }
                return Lang("AnnouncementMsg");
            }
            return Lang("AnnouncementMsg");
        }

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AnnouncementMsg"] = "Server saving, expect some lag...",
                ["EntityMsg"] = "Server is saving {0:n0} entities, expect some lag.",
                ["ConsoleMsg"] = "Server is saving {0:n0} entities."
            }, this);
        }

        private void OnServerSave()
        {
            if (consoleAnnoucement()) Puts(Lang("ConsoleMsg", null, ConVar.Admin.ServerInfo().EntityCount));
            if (guiAnnoucements())
            {
                GUIAnnouncements?.Call("CreateAnnouncement", constructMsg(), guiColor(), guiTextColor());
                return;
            }
            PrintToChat(constructMsg());
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
    }
}


// --- End of file: SaveAnnouncer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/slowmode-chat ---
// --- Original File Path: S/SlowmodeChat/SlowmodeChat.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Slowmode Chat", "Death", "1.0.8")]
    [Description("Restrict players messages per second on a configurable interval")]

    class SlowmodeChat : RustPlugin
    {
        #region Declarations
        List<string> CD = new List<string>();
        const string perm = "slowmodechat.exclude";
        #endregion

        #region Hooks
        object OnUserChat(IPlayer player)
        {
            if (player == null)
            {
                return null;
            }

            if (CD.Contains(player.Id))
            {
                if (configData.Options.Enabled && !permission.UserHasPermission(player.Id, perm))
                {
                    player.Message(lang.GetMessage("errmsg", this, player.Id).Replace("{i}", configData.Settings.Interval.ToString()));
                    return true;
                }
            }
            else
            {
                CD.Add(player.Id);
                timer.Once(configData.Settings.Interval, () => CD.Remove(player.Id));
            }

            return null;
        }

        void Init()
        {
            LoadConfigVariables();

            if (configData.Options.Permission_Enabled)
            {
                permission.RegisterPermission(perm, this);
            }

            if (!configData.Options.Enabled)
            {
                Unsubscribe("OnUserChat");
            }
        }
        #endregion

        #region Functions
        [ConsoleCommand("slowmode")]
        void ChangeSettings(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;

            if (arg.Args == null || arg.Args.Length <= 0)
            {
                arg.ReplyWith(lang.GetMessage("info1msg", this, player?.UserIDString));
                return;
            }

            if (configData.Options.Rcon_Only)
            {
                if (player != null)
                {
                    return;
                }
            }

            var cmd = arg.Args[0].ToLower();

            if (string.IsNullOrEmpty(cmd))
            {
                return;
            }

            switch (cmd)
            {
                case "enable":
                    arg.ReplyWith(lang.GetMessage("enmsg", this, player?.UserIDString));
                    configData.Options.Enabled = true;
                    break;

                case "disable":
                    arg.ReplyWith(lang.GetMessage("dimsg", this, player?.UserIDString));
                    configData.Options.Enabled = false;
                    break;

                case "interval":
                    if (arg.Args.Length < 2)
                    {
                        arg.ReplyWith(lang.GetMessage("info4msg", this, player?.UserIDString));
                        return;
                    }

                    var inti = arg.Args[1];

                    if (inti == null)
                    {
                        return;
                    }

                    arg.ReplyWith(lang.GetMessage("info3msg", this, player?.UserIDString).Replace("{0}", inti));
                    configData.Settings.Interval = Convert.ToInt16(inti);
                    break;

                case "reload":
                    arg.ReplyWith(lang.GetMessage("info2msg", this, player?.UserIDString));
                    LoadConfigVariables();
                    break;
            }

            SaveConfig(configData);
        }
        #endregion

        #region Config
        private ConfigData configData;

        class ConfigData
        {
            public Options Options = new Options();
            public Settings Settings = new Settings();
        }

        class Options
        {
            public bool Enabled = false;
            public bool Rcon_Only = false;
            public bool Permission_Enabled = true;
        }

        class Settings
        {
            public int Interval = 5;
        }

        private void LoadConfigVariables()
        {
            configData = Config.ReadObject<ConfigData>();
            SaveConfig(configData);
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData();

            SaveConfig(config);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"errmsg", "Slowmode is currently active. You may only send one message every {i} seconds!" },
                {"enmsg", "Slowmode has been enabled!" },
                {"dimsg", "Slowmode has been disabled!" },
                {"info1msg", "\nCommands:\nenable - Enables slowmode\ndisable - Disables slowmode\ninterval - Adjust the interval between messages\nreload - Load new config values without reloading the entire plugin\n\nPermissions:\nslowmode.exclude - Excluded granted users/groups from slowmode" },
                {"info2msg", "Loaded new config values!" },
                {"info3msg", "Interval has been adjusted to {0} seconds! Pre-existing timers will not be affected!" },
                {"info4msg", "You must specify an interval (in seconds.)" }
            }, this, "en");
        }

        private string msg(string key, string id = null)
        {
            return lang.GetMessage(key, this, id);
        }
        #endregion
    }
}

// --- End of file: SlowmodeChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/spin-drop ---
// --- Original File Path: S/SpinDrop/SpinDrop.cs ---

ï»¿using System;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Spin Drop", "misticos", "1.0.7")]
    [Description("Spin around dropped items")]
    class SpinDrop : RustPlugin
    {
        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Speed Modifier")]
            public float SpeedModifier = 125f;

            [JsonProperty(PropertyName = "Move Item UP On N")]
            public float HeightOnDrop = 0.4f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities.OfType<WorldItem>())
            {
                // Destroy the old spin drop controller since it will spam NREs.
                foreach (var component in entity.GetComponents<MonoBehaviour>())
                {
                    if (component.GetType().Name == "SpinDropControl")
                    {
                        UnityEngine.Object.Destroy(component);
                        break;
                    }
                }
            }
        }

        private void OnItemDropped(Item item, BaseEntity entity)
        {
            var worldEntity = item?.GetWorldEntity();
            if (worldEntity == null)
                return;

            if (Interface.CallHook("CanSpinDrop", item, entity) != null)
                return;

            SpinDropController.AddToEntity(entity, _config);
        }

        #endregion

        #region Controller

        private class SpinDropController : MonoBehaviour
        {
            public static void AddToEntity(BaseEntity entity, Configuration config)
            {
                var component = entity.gameObject.AddComponent<SpinDropController>();
                
                component.Config = config;
            }

            public Configuration Config;
            private bool _triggered = false;

            private void OnCollisionEnter(Collision collision)
            {
                if (_triggered || collision.gameObject.ToBaseEntity()?.GetItem() != null)
                    return;

                var rigidbody = gameObject.GetComponent<Rigidbody>();
                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;

                var transform = this.transform;
                var position = transform.position;

                transform.rotation = Quaternion.identity;
                transform.position = new Vector3(position.x, position.y + Config.HeightOnDrop, position.z);

                _triggered = true;
            }

            private void FixedUpdate()
            {
                if (!_triggered)
                   return;

                gameObject.transform.Rotate(Time.deltaTime * Config.SpeedModifier * Vector3.down);
            }
        }

        #endregion
    }
}

// --- End of file: SpinDrop.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/safe-zone-harvest-block ---
// --- Original File Path: S/SafeZoneHarvestBlock/SafeZoneHarvestBlock.cs ---

namespace Oxide.Plugins
{
  [Info("Safe Zone Harvest Block", "gnif", "1.0.2")]
  [Description("Prevents harvesting in the Safe Zones")]
  internal class SafeZoneHarvestBlock : CovalencePlugin
  {
    private const string BypassPerm = "safezoneharvestblock.bypass";

    private void Init()
    {
      permission.RegisterPermission(BypassPerm, this);
      timer.Every(1, () => { OnTick(); });
    }

    private void OnTick()
    {
      foreach (var player in BasePlayer.activePlayerList)
      {
        if (player == null || player.IsNpc)
          continue;

        if (permission.UserHasPermission(player.UserIDString, BypassPerm))
          continue;

        if (!player.InSafeZone())
        {
          if (player.inventory.containerBelt.capacity == 0)
          {
            player.inventory.containerBelt.capacity = 6;
            player.SendNetworkUpdateImmediate();
          }
          continue;
        }

        bool update = false;
        if (player.inventory.containerBelt.capacity > 0)
        {
          player.inventory.containerBelt.capacity = 0;
          update = true;
        }


        Item activeItem = player.GetActiveItem();
        if (activeItem != null)
        {
          HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
          if (heldEntity)
          {
            heldEntity.SetHeld(false);
            update = true;
          }
        }

        if (update)
          player.SendNetworkUpdateImmediate();
      }
    }
  }
}


// --- End of file: SafeZoneHarvestBlock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/suicide-modifier ---
// --- Original File Path: S/SuicideModifier/SuicideModifier.cs ---

ï»¿using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Suicide Modifier", "Ryan", "1.0.3")]
    [Description("Adds the ability to change the suicide cooldown or remove it completely.")]
    class SuicideModifier : RustPlugin
    {
        string permissionName = "suicidemodifier.use";
        int defaultCooldown = 60;

        void Init()
        {
            permission.RegisterPermission(permissionName, this);
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file.");
            Config.Clear();
            Config["Settings", "Cooldown of default kill command (seconds)"] = defaultCooldown;
            SaveConfig();
        }

        private int getCooldown()
        {
            int output;
            if (int.TryParse(Config["Settings", "Cooldown of default kill command (seconds)"].ToString(), out output))
                return output;

            PrintWarning("Configuration file invalid, using default value.");
            return defaultCooldown;
        }

        void OnPlayerRespawn(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, permissionName))
                player.nextSuicideTime = Time.realtimeSinceStartup + getCooldown();

            return;
        }
    }
}


// --- End of file: SuicideModifier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sticky-nades ---
// --- Original File Path: S/StickyNades/StickyNades.cs ---

using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using Newtonsoft.Json;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Sticky Nades", "Bazz3l", "1.0.7")]
    [Description("Stick grenades to players, and watch them go boom.")]
    public class StickyNades : RustPlugin
    {
        #region Fields

        private const string PERM_USE = "stickynades.use";

        private PluginConfig _config;

        #endregion

        #region Config

        protected override void LoadDefaultConfig() => _config = PluginConfig.DefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    throw new JsonException();
                }

                if (_config.ToDictionary().Keys
                    .SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys)) return;

                PrintWarning("Loaded updated config.");

                SaveConfig();
            }
            catch
            {
                PrintWarning("Default config loaded.");

                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        private class PluginConfig
        {
            public List<string> AllowedItems;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    AllowedItems = new List<string>
                    {
                        "grenade.beancan.deployed",
                        "grenade.f1.deployed",
                    }
                };
            }
        }

        #endregion

        #region Oxide

        private void OnServerInitialized()
        {
            permission.RegisterPermission(PERM_USE, this);
        }

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity, ThrownWeapon item)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERM_USE)) return;

            if (!_config.AllowedItems.Contains(entity.ShortPrefabName)) return;

            entity.gameObject.AddComponent<StickyExplosiveComponent>().player = player;
        }

        private object OnExplosiveDud(DudTimedExplosive explosive)
        {
            if (explosive == null || !explosive.IsStuck()) return null;

            explosive.GetComponent<StickyExplosiveComponent>()
                ?.UnStickExplosive();

            return null;
        }

        #endregion

        #region Components

        private class StickyExplosiveComponent : MonoBehaviour
        {
            public BaseEntity player;
            private SphereCollider _collider;
            private TimedExplosive _explosive;

            private void Awake()
            {
                gameObject.layer = (int) Layer.Reserved1;

                _explosive = GetComponent<TimedExplosive>();

                _collider = gameObject.AddComponent<SphereCollider>();
                _collider.isTrigger = true;
                _collider.radius = 0.01f;
            }

            private void OnCollisionEnter(Collision collision)
            {
                BasePlayer target = collision.gameObject.ToBaseEntity() as BasePlayer;

                if (target == null || target == player) return;

                StickExplosive(target, collision.GetContact(0));
            }

            public void StickExplosive(BaseEntity entity, ContactPoint contact)
            {
                if (_explosive == null) return;

                _explosive.DoStick(contact.point, contact.normal, entity, contact.otherCollider);

                Destroy(_collider);
            }

            public void UnStickExplosive()
            {
                if (_explosive == null || !_explosive.GetParentEntity()) return;

                _explosive.SetParent(null, true, true);
                _explosive.SetMotionEnabled(true);
                _explosive.SetCollisionEnabled(true);
                _explosive.gameObject.transform.GetOrAddComponent<EntityCollisionMessage>();

                Destroy(this);
            }
        }

        #endregion
    }
}

// --- End of file: StickyNades.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/stack-fuel-generator ---
// --- Original File Path: S/StackFuelGenerator/StackFuelGenerator.cs ---

using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Stack Fuel Generator", "ninco90", "1.0.1")]
    [Description("Change the maximum fuel capacity.")]
    class StackFuelGenerator : RustPlugin
    {
        private ConfigData config;

        private class ConfigData
        {
            public int StackMax { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData
            {
                StackMax = 1000
            };
            Config.WriteObject(config, true);
        }

        private void Init()
        {
            config = Config.ReadObject<ConfigData>();
        }

        void OnServerInitialized(){
            foreach(var generator in GameObject.FindObjectsOfType<FuelGenerator>()){
               generator.inventory.maxStackSize = config.StackMax;
            }
        }

        private void OnEntitySpawned(FuelGenerator entity){
             entity.inventory.maxStackSize = config.StackMax;
        }
    }
}

// --- End of file: StackFuelGenerator.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/stack-modifier ---
// --- Original File Path: S/StackModifier/StackModifier.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using UnityEngine;
using System.Collections;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("Stack Modifier", "Mabel", "2.0.7")]
    [Description("Modify item stack sizes")]
    public class StackModifier : RustPlugin
    {
        #region Fields
        static Dictionary<string, int> _defaults = null;
        static Dictionary<string, int> _FB = new Dictionary<string, int>();

        readonly List<string> _exclude = new List<string>
        {
            "water",
            "water.radioactive",
            "water.salt",
            "ammo.snowballgun",
            "motorbike",
            "motorbike_sidecar",
            "bicycle",
            "trike",
            "rowboat",
            "rhib",
            "parachute.deployed",
            "minigunammopack",
            "minihelicopter.repair",
            "scraptransportheli.repair",
            "habrepair",
            "submarinesolo",
            "submarineduo",
            "workcart",
            "mlrs",
            "snowmobile",
            "snowmobiletomaha",
            "wagon",
            "locomotive",
            "attackhelicopter",
            "tugboat",
            "vehicle.chassis.2mod",
            "vehicle.chassis.3mod",
            "vehicle.chassis.4mod",
            "vehicle.chassis",
            "vehicle.module",
            "weaponrack.light",
            "weaponrack.doublelight",
            "batteringram",
            "batteringram.head.repair",
            "ballista.static",
            "ballista.mounted",
            "catapult",
            "siegetower"
        };

        readonly Dictionary<string, string> _corrections = new Dictionary<string, string>
        {
            {"sunglasses02black", "Sunglasses Style 2"},
            {"sunglasses02camo", "Sunglasses Camo"},
            {"sunglasses02red", "Sunglasses Red"},
            {"sunglasses03black", "Sunglasses Style 3"},
            {"sunglasses03chrome", "Sunglasses Chrome"},
            {"sunglasses03gold", "Sunglasses Gold"},
            {"twitchsunglasses", "Sunglasses Purple"},
            {"hazmatsuit_scientist_peacekeeper", "Peacekeeper Scientist Suit"},
            {"skullspikes.candles", "Skull Spikes Candles"},
            {"skullspikes.pumpkin", "Skull Spikes Pumpkin"},
            {"skull.trophy.jar", "Skull Trophy Jar"},
            {"skull.trophy.jar2", "Skull Trophy Jar 2"},
            {"skull.trophy.table", "Skull Trophy Table"},
            {"innertube.horse", "Inner Tube Horse"},
            {"innertube.unicorn", "Inner Tube Unicorn"},
            {"sled.xmas", "Xmas Sled"},
            {"discofloor.largetiles", "Disco Floor Large"},
        };
        #endregion

        #region Config
        private PluginConfig _config;
        readonly Dictionary<string, string> _itemMap = new Dictionary<string, string>();

        IEnumerator CheckConfig()
        {
            Puts("Checking Configuration Settings");
            yield return CoroutineEx.waitForSeconds(0.30f);

            foreach (ItemDefinition item in ItemManager.itemList)
            {
                string categoryName = item.category.ToString();
                Dictionary<string, _Items> stackCategory;

                if (_exclude.Contains(item.shortname))
                {
                    if (_config.StackCategories[categoryName].ContainsKey(item.shortname))
                        _config.StackCategories[categoryName].Remove(item.shortname);

                    continue;
                }

                if (!_config.StackCategoryMultipliers.ContainsKey(categoryName))
                    _config.StackCategoryMultipliers[categoryName] = 0;

                if (!_config.StackCategories.TryGetValue(categoryName, out stackCategory))
                    _config.StackCategories[categoryName] = stackCategory = new Dictionary<string, _Items>();

                if (stackCategory.ContainsKey(item.shortname))
                    stackCategory[item.shortname].ItemId = item.itemid;

                if (!stackCategory.ContainsKey(item.shortname))
                {
                    stackCategory.Add(item.shortname, new _Items
                    {
                        ShortName = item.shortname,
                        ItemId = item.itemid,
                        DisplayName = item.displayName.english,
                        Modified = item.stackable,
                    });
                }

                if (_corrections.ContainsKey(item.shortname))
                    _config.StackCategories[categoryName][item.shortname].DisplayName = _corrections[item.shortname];

                if (stackCategory.ContainsKey(item.shortname))
                    _config.StackCategories[categoryName][item.shortname].ShortName = item.shortname;

                if (_config.StackCategories[categoryName][item.shortname].Disable)
                    item.stackable = 1;
                else if (_config.StackCategoryMultipliers[categoryName] > 0 && _config.StackCategories[categoryName][item.shortname].Modified == _defaults[item.shortname])
                    item.stackable *= _config.StackCategoryMultipliers[categoryName];
                else if (_config.StackCategories[categoryName][item.shortname].Modified > 0 && _config.StackCategories[categoryName][item.shortname].Modified != _defaults[item.shortname])
                    item.stackable = _config.StackCategories[categoryName][item.shortname].Modified;

                if (item.stackable == 0)
                {
                    if (_config.StackCategories[categoryName][item.shortname].Modified <= 0)
                        _config.StackCategories[categoryName][item.shortname].Modified = _defaults[item.shortname];

                    item.stackable = _defaults[item.shortname];
                    PrintError($"Error {item.shortname} server > {item.stackable} config > {_config.StackCategories[categoryName][item.shortname].Modified} \nStack size is set to ZERO this will break the item! Resetting to default!");
                }
            }
            SaveConfig();

            Puts("Successfully updated all server stack sizes.");

            Updating = null;
            yield return null;
        }

        internal class PluginConfig : SerializableConfiguration
        {
            [JsonProperty("Disable Ammo/Fuel duplication fix (Recommended false)")]
            public bool DisableFix;

            [JsonProperty("Enable VendingMachine Ammo Fix (Recommended)")]
            public bool VendingMachineAmmoFix = true;

            [JsonProperty("Category Stack Multipliers", Order = 4)]
            public Dictionary<string, int> StackCategoryMultipliers = new Dictionary<string, int>();

            [JsonProperty("Stack Categories", Order = 5)]
            public Dictionary<string, Dictionary<string, _Items>> StackCategories = new Dictionary<string, Dictionary<string, _Items>>();

            public void ResetCategory(string cat)
            {
                if (cat == "All")
                {
                    foreach (var cats in StackCategories.Values)
                    {
                        foreach (var i in cats)
                            i.Value.Modified = _defaults[i.Value.ShortName];
                    }

                    foreach (var value in StackCategories.Keys)
                        StackCategoryMultipliers[value] = 0;
                }
                else
                {
                    if (!StackCategoryMultipliers.ContainsKey(cat)) return;
                    StackCategoryMultipliers[cat] = 0;

                    foreach (var item in StackCategories[cat].Values)
                        item.Modified = _defaults[item.ShortName];
                }
            }

            public void SetCategory(string cat, int digit)
            {
                if (cat == "All")
                {
                    foreach (var value in StackCategories.Keys)
                        StackCategoryMultipliers[value] = digit;
                }
                else
                {
                    if (!StackCategoryMultipliers.ContainsKey(cat)) return;
                    StackCategoryMultipliers[cat] = digit;
                }
            }

            public void SetItems(string cat, int digit)
            {
                if (digit == 0)
                    digit = 1;

                if (cat == "All")
                {
                    foreach (var cats in StackCategories.Values)
                    {
                        foreach (var i in cats)
                            i.Value.Modified = digit;
                    }
                }
                else
                {
                    if (!StackCategoryMultipliers.ContainsKey(cat)) return;
                    foreach (var item in StackCategories[cat].Values)
                        item.Modified = digit;
                }
            }

            public void ToggleCats(string cat, bool toggle)
            {
                if (cat == "All")
                {
                    foreach (var cats in StackCategories.Values)
                    {
                        foreach (var i in cats)
                            i.Value.Disable = toggle;
                    }
                }
                else
                {
                    if (!StackCategoryMultipliers.ContainsKey(cat)) return;
                    foreach (var item in StackCategories[cat].Values)
                        item.Disable = toggle;
                }
            }
        }

        public class _Items
        {
            public string ShortName;
            public int ItemId;
            public string DisplayName;
            public int Modified;
            public bool Disable;
        }
        #region Updater

        internal class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                            .ToDictionary(prop => prop.Name, prop => ToObject(prop.Value));
                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }
        #endregion
        #endregion

        #region Oxide
        protected override void LoadDefaultConfig() => _config = new PluginConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    PrintWarning($"No configuration file found or configuration is empty for {Name}. Generating default configuration.");
                    LoadDefaultConfig();
                    SaveConfig();
                }
                else
                {
                    if (MaybeUpdateConfig(_config))
                    {
                        PrintWarning("Configuration appears to be outdated; updating and saving.");
                        SaveConfig();
                    }
                }
            }
            catch (Exception ex)
            {
                PrintWarning($"Failed to load config file (is the config file corrupt?): {ex.Message}. Loading default configurations.");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        Coroutine Updating = null;

        void Unload()
        {
            if (Updating != null)
            {
                ServerMgr.Instance.StopCoroutine(Updating);
            }

            RestoreVanillaStackSizes();
            _defaults = null;
        }

        void OnServerShutdown()
        {
            SaveConfig();

            _defaults = null;
        }

        void Init()
        {
            Unsubscribe(nameof(OnItemAddedToContainer));
        }

        void InitializeFB()
        {
            _FB.Clear();

            foreach (ItemDefinition itemDefinition in ItemManager.GetItemDefinitions())
            {
                _FB[itemDefinition.shortname] = itemDefinition.stackable;
            }
        }

        void OnServerInitialized()
        {
            LoadDefaultStackSizes();
            InitializeFB();
            PrintWarning($"Defaults initialized with {_defaults.Count} items.");

            bool updated = false;
            foreach (ItemDefinition item in ItemManager.itemList)
            {
                string categoryName = item.category.ToString();
                if (!_config.StackCategoryMultipliers.ContainsKey(categoryName) || _config.StackCategoryMultipliers[categoryName] < 1)
                {
                    _config.StackCategoryMultipliers[categoryName] = 1;
                    updated = true;
                }
            }

            if (updated)
            {
                PrintWarning("One or more Category Multipliers were below minimum of 1 and have been updated.");
                SaveConfig();
            }

            int count = 0;
            foreach (var cat in _config.StackCategories)
            {
                foreach (var item in cat.Value.ToArray())
                {
                    if (!_defaults.ContainsKey(item.Key))
                    {
                        count++;
                        cat.Value.Remove(item.Key);
                    }
                }
            }

            if (count > 0)
            {
                Puts($"Updated {count} outdated configuration options continuing to phase 2");
                SaveConfig();
            }

            Updating = ServerMgr.Instance.StartCoroutine(CheckConfig());
            Subscribe(nameof(OnItemAddedToContainer));

            SaveDefaultStackSizes();
        }

        void SaveDefaultStackSizes()
        {
            if (_FB == null)
            {
                _FB = new Dictionary<string, int>();
            }

            foreach (ItemDefinition itemDefinition in ItemManager.GetItemDefinitions())
            {
                if (_FB.ContainsKey(itemDefinition.shortname)) continue;

                _FB[itemDefinition.shortname] = itemDefinition.stackable;
            }

            Interface.Oxide.DataFileSystem.WriteObject("Stackmodifier_Defaults", _FB);
            Puts("Default stack sizes saved.");
        }

        void LoadDefaultStackSizes()
        {
            _FB = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, int>>("Stackmodifier_Defaults");
            if (_FB == null)
            {
                _FB = new Dictionary<string, int>();
                Puts("No default stack sizes found. Creating a new dictionary.");
            }
            else
            {
                Puts("Default stack sizes loaded.");
            }
            _defaults = _FB;
        }

        void RestoreVanillaStackSizes()
        {
            if (_defaults == null || !_defaults.Any())
            {
                PrintWarning("No default stack sizes to restore.");
                return;
            }

            foreach (ItemDefinition itemDefinition in ItemManager.GetItemDefinitions())
            {
                if (!_defaults.ContainsKey(itemDefinition.shortname)) continue;
                itemDefinition.stackable = _defaults[itemDefinition.shortname];
            }
            Puts("Vanilla stack sizes restored.");
        }

        object CanStackItem(Item item, Item targetItem)
        {
            if (item == null || targetItem == null) return null;

            if (item.name != targetItem.name || item.info.shortname != targetItem.info.shortname) return false;

            var itemOwner = item.GetOwnerPlayer();
            var targetItemOwner = targetItem.GetOwnerPlayer();
            if (itemOwner == null || targetItemOwner == null) return null;

            if (item.info.itemid == targetItem.info.itemid && !CanWaterItemsStack(item, targetItem)) return false;

            if (item.contents?.capacity != targetItem.contents?.capacity || item.contents?.itemList.Count != targetItem.contents?.itemList.Count) return false;

            if (!(targetItem != item &&
                  item.info.stackable > 1 &&
                  targetItem.info.stackable > 1 &&
                  targetItem.info.itemid == item.info.itemid &&
                  (!item.hasCondition || (double)item.condition == targetItem.info.condition.max) &&
                  (!targetItem.hasCondition || (double)targetItem.condition == targetItem.info.condition.max) &&
                  item.IsValid() &&
                  (!item.IsBlueprint() || item.blueprintTarget == targetItem.blueprintTarget) &&
                  targetItem.skin == item.skin &&
                  targetItem.name == item.name &&
                  targetItem.info.shortname == item.info.shortname &&
                  targetItem.streamerName == item.streamerName &&
                  (targetItem.info.amountType != ItemDefinition.AmountType.Genetics && item.info.amountType != ItemDefinition.AmountType.Genetics || (targetItem.instanceData != null ? targetItem.instanceData.dataInt : -1) == (item.instanceData != null ? item.instanceData.dataInt : -1)) &&
                  (item.instanceData == null || item.instanceData.subEntity == null || !(bool)item.info.GetComponent<ItemModSign>()) &&
                  (targetItem.instanceData == null || targetItem.instanceData.subEntity == null || !(bool)targetItem.info.GetComponent<ItemModSign>())))
                return false;

            if ((item.contents?.capacity ?? 0) != (targetItem.contents?.capacity ?? 0)) return false;

            if (targetItem.contents?.itemList.Count > 0)
            {
                if (!HasVanillaContainer(targetItem.info)) return false;

                for (var i = targetItem.contents.itemList.Count - 1; i >= 0; i--)
                {
                    var childItem = targetItem.contents.itemList[i];
                    item.parent.playerOwner.GiveItem(childItem);
                }
            }

            BaseProjectile.Magazine itemMag = targetItem.GetHeldEntity()?.GetComponent<BaseProjectile>()?.primaryMagazine;
            if (itemMag != null)
            {
                if (itemMag.contents > 0)
                {
                    item.GetOwnerPlayer().GiveItem(ItemManager.CreateByItemID(itemMag.ammoType.itemid, itemMag.contents));
                    itemMag.contents = 0;
                }
            }

            if (targetItem.GetHeldEntity() is FlameThrower)
            {
                FlameThrower flameThrower = targetItem.GetHeldEntity().GetComponent<FlameThrower>();

                if (flameThrower.ammo > 0)
                {
                    item.GetOwnerPlayer().GiveItem(ItemManager.CreateByItemID(flameThrower.fuelType.itemid, flameThrower.ammo));
                    flameThrower.ammo = 0;
                }
            }

            if (targetItem.GetHeldEntity() is Chainsaw)
            {
                Chainsaw chainsaw = targetItem.GetHeldEntity().GetComponent<Chainsaw>();

                if (chainsaw.ammo > 0)
                {
                    item.GetOwnerPlayer().GiveItem(ItemManager.CreateByItemID(chainsaw.fuelType.itemid, chainsaw.ammo));
                    chainsaw.ammo = 0;
                }
            }
            return true;
        }

        bool HasVanillaContainer(ItemDefinition itemDefinition)
        {
            foreach (var itemMod in itemDefinition.itemMods)
            {
                if (itemMod is ItemModContainer)
                    return true;
            }
            return false;
        }

        object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (item.item.info.itemid != targetItem.item.info.itemid ||
                item.skinID != targetItem.skinID ||
                item.item.name != targetItem.item.name)
                return true;

            if (item.item.contents?.itemList.Count > 0 || targetItem.item.contents?.itemList.Count > 0)
                return true;

            if (item.item.contents?.capacity != targetItem.item.contents?.capacity)
                return true;

            return null;
        }

        Item OnItemSplit(Item item, int amount)
        {
            if (amount <= 0) return null;

            if (item.amount < amount) return null;

            if (item.skin == 2591851360 || item.skin == 2817854052 || item.skin == 2892143123 || item.skin == 2892142979 ||
                item.skin == 2892142846 || item.skin == 2817854377 || item.skin == 2817854677 || item.skin == 2888602635 ||
                item.skin == 2888602942 || item.skin == 2888603247 || item.skin == 2445048695 || item.skin == 2445033042)
            {
                return null;
            }

            var armorSlotComponent = item.info.GetComponent<ItemModContainerArmorSlot>();
            if (armorSlotComponent != null)
            {
                Item newArmorItem = ItemManager.CreateByItemID(item.info.itemid);
                if (newArmorItem == null) return null;

                int capacity = item.contents?.capacity ?? 0;
                armorSlotComponent.CreateAtCapacity(capacity, newArmorItem);

                if (item.contents != null && newArmorItem.contents != null)
                {
                    foreach (var nItem in item.contents.itemList)
                    {
                        Item cArmor = ItemManager.CreateByItemID(nItem.info.itemid, nItem.amount);
                        if (cArmor != null)
                        {
                            newArmorItem.contents.AddItem(cArmor.info, cArmor.amount);
                            cArmor.MarkDirty();
                        }
                    }
                }

                item.amount -= amount;
                newArmorItem.name = item.name;
                newArmorItem.skin = item.skin;
                newArmorItem.amount = amount;
                newArmorItem.MarkDirty();
                item.MarkDirty();

                return newArmorItem;
            }

            if (item.GetHeldEntity()?.GetComponentInChildren<BaseLiquidVessel>() != null)
            {
                Item liquidContainer = ItemManager.CreateByName(item.info.shortname);
                if (liquidContainer == null)
                {
                    return null;
                }

                liquidContainer.amount = amount;
                item.amount -= amount;
                item.MarkDirty();

                Item water = item.contents.FindItemByItemID(-1779180711);
                if (water != null)
                {
                    liquidContainer.contents.AddItem(ItemManager.FindItemDefinition(-1779180711), water.amount);
                }

                return liquidContainer;
            }

            if (item.skin != 0 && item.info.amountType != ItemDefinition.AmountType.Genetics)
            {
                Item x = ItemManager.CreateByItemID(item.info.itemid);
                if (x == null)
                {
                    return null;
                }

                BaseProjectile.Magazine itemMag = x.GetHeldEntity()?.GetComponent<BaseProjectile>()?.primaryMagazine;
                if (itemMag != null && itemMag.contents > 0)
                {
                    itemMag.contents = 0;
                }

                if (item.contents != null)
                {
                    if (x.contents == null)
                    {
                        x.contents = new ItemContainer();
                        x.contents.ServerInitialize(x, item.contents.capacity);
                        x.contents.GiveUID();
                    }
                    else
                    {
                        x.contents.capacity = item.contents.capacity;
                    }
                }

                item.amount -= amount;
                x.name = item.name;
                x.skin = item.skin;
                x.amount = amount;
                x.MarkDirty();
                var heldEntity = x.GetHeldEntity();
                if (heldEntity != null)
                {
                    heldEntity.skinID = item.skin;
                }

                item.MarkDirty();

                return x;
            }

            Item newItem = ItemManager.CreateByItemID(item.info.itemid);
            if (newItem == null)
            {
                return null;
            }

            BaseProjectile.Magazine newItemMag = newItem.GetHeldEntity()?.GetComponent<BaseProjectile>()?.primaryMagazine;
            if (newItem.contents?.itemList.Count == 0 && (_config.DisableFix || newItemMag?.contents == 0))
            {
                newItem.Remove();
                return null;
            }

            item.amount -= amount;
            newItem.name = item.name;
            newItem.amount = amount;
            if (item.skin != 0)
            {
                newItem.skin = item.skin;
            }
            item.MarkDirty();

            if (item.IsBlueprint())
            {
                newItem.blueprintTarget = item.blueprintTarget;
            }


            if (item.info.amountType == ItemDefinition.AmountType.Genetics && item.instanceData != null && item.instanceData.dataInt != 0)
            {
                newItem.instanceData = new ProtoBuf.Item.InstanceData()
                {
                    dataInt = item.instanceData.dataInt,
                    ShouldPool = false
                };
            }

            if (newItem.contents?.itemList.Count > 0)
            {
                item.contents.Clear();
            }


            newItem.MarkDirty();

            if (_config.VendingMachineAmmoFix && item.GetRootContainer()?.entityOwner is VendingMachine)
            {
                return newItem;
            }

            if (_config.DisableFix)
            {
                return newItem;
            }

            if (newItem.GetHeldEntity() is FlameThrower)
            {
                newItem.GetHeldEntity().GetComponent<FlameThrower>().ammo = 0;
            }

            if (newItem.GetHeldEntity() is Chainsaw)
            {
                newItem.GetHeldEntity().GetComponent<Chainsaw>().ammo = 0;
            }

            BaseProjectile.Magazine itemMagDefault = newItem.GetHeldEntity()?.GetComponent<BaseProjectile>()?.primaryMagazine;
            if (itemMagDefault != null && itemMagDefault.contents > 0)
            {
                itemMagDefault.contents = 0;
            }

            return newItem;
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            BasePlayer player = container.GetOwnerPlayer();
            if (player == null || !player.userID.IsSteamId()) return;
            if (Interface.CallHook("OnIgnoreStackSize", player, item) != null) return;
            if (player.inventory.containerWear.uid != container.uid) return;
            if (item.amount > 1)
            {
                int amount2 = item.amount -= 1;
                player.inventory.containerWear.Take(null, item.info.itemid, amount2 - 1);
                Interface.Oxide.NextTick(() =>
                {
                    Item x = ItemManager.CreateByItemID(item.info.itemid, item.amount, item.skin);
                    x.name = item.name;
                    x.skin = item.skin;
                    x.amount = amount2;
                    x._condition = item._condition;
                    x._maxCondition = item._maxCondition;
                    x.MarkDirty();
                    if (!x.MoveToContainer(player.inventory.containerMain))
                        x.DropAndTossUpwards(player.transform.position);
                });
            }
        }

        object OnCardSwipe(CardReader cardReader, Keycard card, BasePlayer player)
        {
            var item = card.GetItem();
            if (item == null || item.isBroken || item.amount <= 1) return null;

            int division = item.amount / 1;

            for (int i = 0; i < division; i++)
            {
                Item x = item.SplitItem(1);
                if (x != null && !x.MoveToContainer(player.inventory.containerMain, -1, false) && (item.parent == null || !x.MoveToContainer(item.parent)))
                    x.Drop(player.inventory.containerMain.dropPosition, player.inventory.containerMain.dropVelocity);
            }
            return null;
        }
        #endregion

        #region Helpers
        bool CanWaterItemsStack(Item item, Item targetItem)
        {
            var itemVessel = item.GetHeldEntity()?.GetComponentInChildren<BaseLiquidVessel>();
            var targetItemVessel = targetItem.GetHeldEntity()?.GetComponentInChildren<BaseLiquidVessel>();

            if (itemVessel == null && targetItemVessel == null) return true;

            if (itemVessel == null || targetItemVessel == null) return false;

            var itemMaxCapacity = item.info.stackable;
            var targetItemMaxCapacity = targetItem.info.stackable;

            if (itemMaxCapacity != targetItemMaxCapacity) return false;

            if (targetItem.contents.IsEmpty() && item.contents.IsEmpty()) return true;

            if (!targetItem.contents.IsEmpty() && !item.contents.IsEmpty())
            {
                var first = item.contents.itemList.First();
                var second = targetItem.contents.itemList.First();

                if (first.info.itemid == second.info.itemid)
                {
                    int combinedAmount = first.amount + second.amount;
                    return combinedAmount <= itemMaxCapacity;
                }
            }
            return false;
        }
        #endregion
    }
}

// --- End of file: StackModifier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sign-map ---
// --- Original File Path: S/SignMap/SignMap.cs ---

ï»¿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;
using Color = System.Drawing.Color;
using Component = UnityEngine.Component;
using Graphics = System.Drawing.Graphics;

namespace Oxide.Plugins
{
    [Info("Sign Map", "MJSU", "1.0.4")]
    [Description("Allows placing the rust map on a signs")]
    internal class SignMap : RustPlugin
    {
        #region Class Fields
        [PluginReference] private Plugin RustMapApi;

        private PluginConfig _pluginConfig; //Plugin Config
        
        private const string UsePermission = "signmap.use";
        private const string NoResourcesPermission = "signmap.noresources";
        private const string NoCooldownPermission = "signmap.nocooldown";
        private const string AccentColor = "#de8732";
        
        private readonly Hash<string, ItemDefinition> _prefabNameToItem = new Hash<string, ItemDefinition>();
        private readonly Hash<ulong, Coroutine> _activeRoutines = new Hash<ulong, Coroutine>();
        private readonly Hash<ulong, DateTime> _cooldowns = new Hash<ulong, DateTime>();
        private readonly Hash<ulong, List<Signage>> _undoSigns = new Hash<ulong, List<Signage>>();
        
        private const string DefaultMapName = "Default";

        private GameObject _go;
        private SignBehavior _behavior;
        
        private readonly StringBuilder _sb = new StringBuilder();
        #endregion

        #region Setup & Loading
        private void Init()
        {
            permission.RegisterPermission(UsePermission, this);
            permission.RegisterPermission(NoResourcesPermission, this);
            permission.RegisterPermission(NoCooldownPermission, this);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Chat] = $"<color=#bebebe>[<color={AccentColor}>{Title}</color>] {{0}}</color>",
                [LangKeys.NoPermission] = "You do not have permission to use this command",
                [LangKeys.NoSign] = "You're not looking at a sign",
                [LangKeys.CanNotUpdate] = "You're not allowed to update this sign",
                [LangKeys.InvalidRow] = "You have entered an invalid number for row: {0}",
                [LangKeys.InvalidCol] = "You have entered an invalid number for column: {0}",
                [LangKeys.SignNotSupported] = "This sign is not supported by sign map. Please contact plugin author with the following information. {0}",
                [LangKeys.ImageNotValid] = "This map image is not valid. Please contact plugin author.",
                [LangKeys.ActiveGeneration] = "You already have an active sign map generation in progress. You cannot use this command until it is finished.",
                [LangKeys.NoAvailableUndos] = "You do not have any signs that can be undone.",
                [LangKeys.UndoSuccessful] = "All signs have been undone.",
                [LangKeys.UnderCooldown] = "You still have {0:0} seconds remaining before you can use this command again.",
                [LangKeys.InvalidGenSyntax] = $"Invalid Syntax. <color={AccentColor}>/{{0}} gen 2 3</color> - to create a sign map that is 2 rows and 3 columns.",
                [LangKeys.MaxSize] = "The maximum number of signs generated cannot be more than {0}",
                [LangKeys.NotEnoughItems] = "You do not have enough {0}. You have {1} and you need {2}",
                [LangKeys.NeedsWall] = "Can only create maps greater than 1 row and 1 column with signs that are placed on walls",
                [LangKeys.SignBroke] = "This sign broke or was destroyed",
                [LangKeys.FinishedGenerating] = "We have finished generating your sign map using the {0} map that is {1} row(s) and {2} column(s)",
                [LangKeys.Refunded] = "We have refunded {0} {1}(s) to you",
                [LangKeys.MapHeader] = "The list of available maps are:",
                [LangKeys.MissingRustMapApi] = "Plugin Dependency RustMapApi is missing. Please install the plugin and try again. https://umod.org/plugins/rust-map-api",
                [LangKeys.MapName] = $"<color={AccentColor}>{{0}}</color>",
                [LangKeys.HelpText] = "Allows add map image to signs or creating a map sign grid\n" +
                                      $"<color={AccentColor}>/{{0}} gen 1 1</color> - will add the full map to the sign you're looking at'\n" +
                                      $"<color={AccentColor}>/{{0}} gen 4 5</color> - will create a 4 row x 5 column map using the sign you're looking at as the bottom left corner\n" +
                                      $"<color={AccentColor}>/{{0}} gen 4 5 nr|norotation</color> - will create a 4 x 5 map and not correct the rotation of the sign\n" +
                                      $"<color={AccentColor}>/{{0}} gen 4 5 Icon</color> - will create a 4 x 5 map using the Icons render\n" +
                                      $"<color={AccentColor}>/{{0}} undo</color> - will undo the most recently generated sign map and refund the cost\n" +
                                      $"<color={AccentColor}>/{{0}} maps</color> - to see the list of available maps to use'\n" +
                                      $"<color={AccentColor}>/{{0}}</color> - to display this help text again."
            }, this);
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            return config;
        }

        private void OnServerInitialized()
        {
            _go = new GameObject();
            _behavior = _go.AddComponent<SignBehavior>();
            
            foreach (ItemDefinition item in ItemManager.GetItemDefinitions())
            {
                ItemModDeployable itemDeployable = item?.GetComponent<ItemModDeployable>();
                if (itemDeployable == null)
                {
                    continue;
                }

                string path = itemDeployable.entityPrefab.resourcePath;
                if (!SignImageSizes.Keys.Any(s => path.Contains(s)))
                {
                    continue;
                }
                
                if (!_prefabNameToItem.ContainsKey(path))
                {
                    _prefabNameToItem[path] = item;
                }
            }
            
            if (!IsRustMapApiLoaded())
            {
                PrintError("Missing plugin dependency RustMapApi: https://umod.org/plugins/rust-map-api");
                return;
            }
        }
        
        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            Coroutine routine = _activeRoutines[player.userID];
            if (routine != null)
            {
                _behavior.StopCoroutine(routine);
            }
        }

        private void Unload()
        {
            if (_go != null)
            {
                _behavior.StopAllCoroutines();
                GameObject.Destroy(_go);
            }
        }
        #endregion

        #region Chat Command
        [ChatCommand("sm")]
        private void SignMapChatCommand(BasePlayer player, string cmd, string[] args)
        {
            if (!HasPermission(player, UsePermission) && !player.IsAdmin)
            {
                Chat(player, LangKeys.NoPermission);
                return;
            }
            
            if (args.Length == 0)
            {
                Chat(player, LangKeys.HelpText, _pluginConfig.ChatCommand);
                return;
            }
            
            if (_activeRoutines[player.userID] != null)
            {
                Chat(player, LangKeys.ActiveGeneration);
                return;
            }
            
            switch (args[0].ToLower())
            {
                case "undo":
                    HandleUndo(player);
                    break;
                
                case "maps":
                    HandleMaps(player);
                    break;
                
                case "gen":
                    HandleGen(player, args);
                    break;
                
                default:
                    Chat(player, LangKeys.HelpText, _pluginConfig.ChatCommand);
                    break;
            }
        }

        private void HandleUndo(BasePlayer player)
        {
            List<Signage> signs = _undoSigns[player.userID];
            if (signs == null)
            {
                Chat(player, LangKeys.NoAvailableUndos);
                return;
            }

            _activeRoutines[player.userID] = _behavior.StartCoroutine(UndoRoutine(player, signs));
        }

        private IEnumerator UndoRoutine(BasePlayer player, List<Signage> signs)
        {
            ItemDefinition def = null;
            int refund = 0;
            foreach (Signage sign in signs)
            {
                if (sign == null || sign.IsDestroyed)
                {
                    continue;
                }

                if (def == null)
                {
                    def = _prefabNameToItem[sign.PrefabName];
                }
                
                sign.Die();
                refund++;
                yield return null;
            }

            if (!HasPermission(player, NoResourcesPermission))
            {
                yield return HandleRefund(player, def, refund);
            }

            Chat(player, LangKeys.UndoSuccessful);
            _activeRoutines.Remove(player.userID);
        }

        private void HandleMaps(BasePlayer player)
        {
            List<string> maps = GetMaps();
            if (maps == null)
            {
                Chat(player, LangKeys.MissingRustMapApi);
                return;
            }

            _sb.Clear();
            _sb.AppendLine(Lang(LangKeys.MapHeader, player));
            foreach (string map in maps)
            {
                _sb.AppendLine(Lang(LangKeys.MapName, player, map));
            }
            
            Chat(player, _sb.ToString());
        }

        private void HandleGen(BasePlayer player, string[] args)
        {
            if (!HasPermission(player, NoCooldownPermission) && _cooldowns.ContainsKey(player.userID) && _cooldowns[player.userID] > DateTime.Now)
            {
                TimeSpan remaining = _cooldowns[player.userID] - DateTime.Now;
                Chat(player, LangKeys.UnderCooldown, remaining.TotalSeconds);
                return;
            }
            
            if (args.Length < 3)
            {
                Chat(player, LangKeys.InvalidGenSyntax, _pluginConfig.ChatCommand);
                return;
            }
            
            string numRowsArg = args[1];
            string numColsArg = args[2];

            int numRows;
            if (!int.TryParse(numRowsArg, out numRows) || numRows <= 0)
            {
                Chat(player, LangKeys.InvalidRow, numRowsArg);
                return;
            }
            
            int numCols;
            if (!int.TryParse(numColsArg, out numCols) || numCols <= 0)
            {
                Chat(player, LangKeys.InvalidCol, numColsArg);
                return;
            }
            
            if (numRows * numCols > _pluginConfig.MaxSigns)
            {
                Chat(player, LangKeys.MaxSize, _pluginConfig.MaxSigns);
                return;
            }
            
            Signage sign = RaycastAll<Signage>(player.eyes.HeadRay(), 5f);
            if (sign == null)
            {
                Chat(player, LangKeys.NoSign);
                return;
            }
            
            if (!sign.CanUpdateSign(player))
            {
                Chat(player, LangKeys.CanNotUpdate);
                return;
            }
            
            ItemDefinition def = _prefabNameToItem[sign.PrefabName];
            if (!HasPermission(player, NoResourcesPermission))
            {
                int amount = player.inventory.GetAmount(def.itemid);
                int need = numRows * numCols - 1;
                if (amount < need)
                {
                    Chat(player, LangKeys.NotEnoughItems, def.displayName.translated, amount, need);
                    return;
                }

                List<Item> items = Pool.GetList<Item>();
                player.inventory.Take(items, def.itemid, need);
                foreach (Item item in items)
                {
                    item.Remove();
                }

                Pool.FreeList(ref items);
            }
            
            bool correctRotation = !args.Any(a => a.Equals("nr", StringComparison.InvariantCultureIgnoreCase) || a.Equals("norotation", StringComparison.InvariantCultureIgnoreCase ));
            
            List<string> maps = GetMaps();
            if (maps == null)
            {
                Chat(player, LangKeys.MissingRustMapApi);
                return;
            }
            
            string map = maps.FirstOrDefault(a => args.Any(m => m.Equals(a, StringComparison.InvariantCultureIgnoreCase)));
            if (string.IsNullOrEmpty(map))
            {
                map = maps.FirstOrDefault(m => m.Equals(_pluginConfig.DefaultMap, StringComparison.InvariantCultureIgnoreCase));
                if (string.IsNullOrEmpty(map))
                {
                    map = DefaultMapName;
                }
            }
            
            _behavior.StartCoroutine(CreateSignGrid(player, sign, numRows, numCols, def, map, correctRotation));
        }

        private IEnumerator CreateSignGrid(BasePlayer player, Signage sign, int numRows, int numCols, ItemDefinition def, string mapName, bool correctRotation)
        {
            try
            {
                List<Signage> signs = new List<Signage>();
                _undoSigns[player.userID] = signs;
                
                 if (numCols > 1 || numRows > 1)
                 {
                     BuildingBlock block = GetNearbyBuildingBlock(sign);
                     if (block == null || !block.ShortPrefabName.Contains("wall"))
                     {
                         Chat(player, LangKeys.NeedsWall);
                         yield break;
                     }
                     
                     if (correctRotation)
                     {
                         Vector3 relativePoint = block.transform.InverseTransformPoint(sign.transform.position);
                         if (relativePoint.x < 0.0)
                         {
                             sign.transform.rotation = block.transform.rotation * Quaternion.Euler(0, 270, 0);
                         }
                         else if (relativePoint.x > 0.0)
                         {
                             sign.transform.rotation = block.transform.rotation * Quaternion.Euler(0, 90, 0);
                         }
                     }
                     
                    sign.transform.position += sign.transform.forward * 0.001f;
                    sign.SendNetworkUpdateImmediate();
                 }
                
                 yield return null;
                 
                 if (sign == null || sign.IsDestroyed)
                 {
                     Chat(player, LangKeys.SignBroke);
                     yield break;
                 }
                 
                float width = sign.bounds.size.x;
                float height = sign.bounds.size.y;
                Vector3 signPos = sign.transform.position;
                Vector3 signRight = sign.transform.right;
                Vector3 signUp = sign.transform.up;
                Quaternion signRot = sign.transform.rotation;
                string signPrefab = sign.PrefabName;

                int refund = 0;
                for (int row = 0; row < numRows; row++)
                {
                    for (int col = 0; col < numCols; col++)
                    {
                        Signage newSign;
                        if (row == 0 && col == 0)
                        {
                            newSign = sign;
                        }
                        else
                        {
                            Vector3 pos = signPos + -signRight * (width * col) + signUp * (height * row);
                            newSign = GameManager.server.CreateEntity(signPrefab, pos, signRot) as Signage;
                            newSign.OwnerID = player.userID;
                            newSign.Spawn();
                        }

                        yield return null;

                        Hash<string, object> mapSection = GetSection(mapName, numRows, numCols, row, col);
                         if (mapSection == null)
                         {
                             Chat(player, LangKeys.MissingRustMapApi);
                             yield break;
                         }
                         
                         byte[] map = mapSection["image"] as byte[];
                         if (map == null)
                         {
                             refund++;
                             continue;
                         }
                         
                         yield return null;
                         
                         if (newSign == null || newSign.IsDestroyed)
                         {
                             refund++;
                             continue;
                         }
                         
                         newSign.BroadcastMessage("OnPhysicsNeighbourChanged", SendMessageOptions.DontRequireReceiver);
                         if (newSign == null || newSign.IsDestroyed)
                         {
                             refund++;
                             continue;
                         }
                         
                        signs.Add(newSign);

                        yield return AddImageToSign(player, newSign, map);
                        
                        yield return new WaitForSeconds(_pluginConfig.GenerationDelay);
                    }
                }
                
                if (refund > 0 && !HasPermission(player, NoResourcesPermission))
                {
                    yield return HandleRefund(player, def, refund);
                }
            }
            finally
            {
                _cooldowns[player.userID] = DateTime.Now + TimeSpan.FromSeconds(_pluginConfig.Cooldown);
                _activeRoutines.Remove(player.userID);
                Chat(player, LangKeys.FinishedGenerating, mapName, numRows, numCols);
            }
        }

        private BuildingBlock GetNearbyBuildingBlock(BaseEntity entity)
        {
            float minDistance = float.MaxValue;
            BuildingBlock buildingBlock = null;
            Vector3 point = entity.PivotPoint();
            List<BuildingBlock> list = Pool.GetList<BuildingBlock>();
            Vis.Entities(point, 1.5f, list, Rust.Layers.Construction);
            for (int i = 0; i < list.Count; i++)
            {
                BuildingBlock item = list[i];
                float distance = item.SqrDistance(point);
                if (distance < minDistance)
                {
                    minDistance = distance;
                    buildingBlock = item;
                }
            }

            Pool.FreeList(ref list);
            return buildingBlock;
        }

        private IEnumerator HandleRefund(BasePlayer player, ItemDefinition def, int amount)
        {
            Item item = ItemManager.CreateByItemID(def.itemid, amount);
            int max = Math.Max(1, item.MaxStackable());
            while (item.amount > max)
            {
                player.GiveItem(item.SplitItem(max));
                yield return null;
            }
                
            player.GiveItem(item);
            Chat(player, LangKeys.Refunded, amount, def.displayName.translated);
            yield return null;
        }
        #endregion

        #region Map Handler
        private IEnumerator AddImageToSign(BasePlayer player, Signage sign, byte[] data)
        {
            yield return null;

            ImageSize size = SignImageSizes[sign.ShortPrefabName];
            if (size == null)
            {
                Chat(player, LangKeys.SignNotSupported, sign.PrefabName);
                yield break;
            }
            
            byte[] resized = ResizeImage(data, size.ImageWidth, size.ImageHeight);
            if(!ImageProcessing.IsValidPNG(resized, 1024, 1024))
            {
                Chat(player, LangKeys.ImageNotValid);
                yield break;
            }
            
            yield return null;
            
            if (sign.textureIDs[0] != 0)
            {
                FileStorage.server.Remove(sign.textureIDs[0], FileStorage.Type.png, sign.net.ID);
                yield return null;
            }
            
            sign.textureIDs[0] = FileStorage.server.Store(resized, FileStorage.Type.png, sign.net.ID);
            sign.SendNetworkUpdate();
        }
        
        private byte[] ResizeImage(byte[] bytes, int targetWidth, int targetHeight)
        {
            using (MemoryStream original = new MemoryStream(), resizedBytesStream = new MemoryStream())
            {
                original.Write(bytes, 0, bytes.Length);
                using (Bitmap img = new Bitmap(Image.FromStream(original)))
                {
                    using (Bitmap resize = ResizeImage(img, targetWidth, targetHeight))
                    {
                        //Rust images are crc and if we have the same image it is deleted from the file storage
                        //Here we changed the last few pixels of the image with colors based off the current milliseconds since wipe
                        //This will generate a unique image every time and allow us to use the same image multiple times
                        byte[] milli = BitConverter.GetBytes((DateTime.Now - SaveRestore.SaveCreatedTime).TotalMilliseconds);
                        for (int i = 0; i < milli.Length / 4; i++)
                        {
                            int red = GetValueAtIndex(milli, i * 4);
                            int green = GetValueAtIndex(milli, i * 4 + 1);
                            int blue = GetValueAtIndex(milli, i * 4 + 2);
                            int alpha = GetValueAtIndex(milli, i * 4 + 3);
                            
                            Color pixel = Color.FromArgb(red, green, blue, alpha);
                            resize.SetPixel(targetWidth - 1 - i, targetHeight - 1, pixel);
                        }
                        
                        resize.Save(resizedBytesStream, ImageFormat.Png);
                        return resizedBytesStream.ToArray();
                    }
                }
            }
        }
        
        /// <summary>
        /// Resize the image to the specified width and height.
        /// </summary>
        /// <param name="image">The image to resize.</param>
        /// <param name="width">The width to resize to.</param>
        /// <param name="height">The height to resize to.</param>
        /// <returns>The resized image.</returns>
        private static Bitmap ResizeImage(Image image, int width, int height)
        {
            Rectangle destRect = new Rectangle(0, 0, width, height);
            Bitmap destImage = new Bitmap(width, height);

            //destImage.SetResolution(image.HorizontalResolution, image.VerticalResolution);

            using (Graphics graphics = Graphics.FromImage(destImage))
            {
                graphics.CompositingMode = CompositingMode.SourceCopy;
                graphics.CompositingQuality = CompositingQuality.HighQuality;
                graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
                graphics.SmoothingMode = SmoothingMode.HighQuality;
                graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

                using (ImageAttributes wrapMode = new ImageAttributes())
                {
                    wrapMode.SetWrapMode(System.Drawing.Drawing2D.WrapMode.TileFlipXY);
                    graphics.DrawImage(image, destRect, 0, 0, image.Width,image.Height, GraphicsUnit.Pixel, wrapMode);
                }
            }

            return destImage;
        }

        private int GetValueAtIndex(byte[] bytes, int index)
        {
            if (index >= bytes.Length)
            {
                return 0;
            }

            return Convert.ToInt32(bytes[index]);
        }

        #endregion

        #region Helper Methods
        private bool IsRustMapApiLoaded()
        {
            return RustMapApi != null && RustMapApi.IsLoaded;
        }

        public Hash<string, object> GetSection(string mapName, int numRows, int numCols, int row, int col)
        {
            if (!IsRustMapApiLoaded())
            {
                return null;
            }
            
            return RustMapApi.Call<Hash<string, object>>("GetSection", mapName, numRows, numCols, row, col);
        }
        
        private List<string> GetMaps()
        {
            if (!IsRustMapApiLoaded())
            {
                return null;
            }
            
            return RustMapApi.Call<List<string>>("GetRenderNames");
        }
        
        private T RaycastAll<T>(Ray ray, float distance) where T : BaseEntity
        {
            RaycastHit[] hits = Physics.RaycastAll(ray, distance, Rust.Layers.Server.Deployed, QueryTriggerInteraction.Ignore);
            GamePhysics.Sort(hits);
            for (int index = 0; index < hits.Length; index++)
            {
                RaycastHit hit = hits[index];
                BaseEntity entity = hit.GetEntity();
                if (entity is T)
                {
                    return entity as T;
                }
            }
            
            return null;
        }

        private void Chat(BasePlayer player, string key, params object[] args) => PrintToChat(player, Lang(LangKeys.Chat, player, Lang(key, player, args)));

        private string Lang(string key, BasePlayer player = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, player?.UserIDString), args);
            }
            catch(Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception\n:{ex.Message}");
                throw;
            }
        }

        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
        #endregion

        #region Behavior
        private class SignBehavior : FacepunchBehaviour
        {
            
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue("sm")]
            [JsonProperty(PropertyName = "Chat Command")]
            public string ChatCommand { get; set; }
            
            [DefaultValue(0.1f)]
            [JsonProperty(PropertyName = "Delay between sign generation (Seconds)")]
            public float GenerationDelay { get; set; }
            
            [DefaultValue(120f)]
            [JsonProperty(PropertyName = "Command cooldown (Seconds)")]
            public float Cooldown { get; set; }
            
            [DefaultValue(16)]
            [JsonProperty(PropertyName = "Max number of signs in generated grid")]
            public int MaxSigns { get; set; }
            
            [DefaultValue("Icons")]
            [JsonProperty(PropertyName = "Default map to use when non specified")]
            public string DefaultMap { get; set; }
        }
        private class LangKeys
        {
            public const string Chat = "Chat";
            public const string NoPermission = "NoPermission";
            public const string NoSign = "NoSign";
            public const string CanNotUpdate = "CanNotUpdate";
            public const string InvalidRow = "InvalidRow";
            public const string InvalidCol = "InvalidCol";
            public const string HelpText = "HelpText";
            public const string SignNotSupported = "SignNotSupported";
            public const string ImageNotValid = "ImageNotValid";
            public const string ActiveGeneration = "ActiveGeneration";
            public const string NoAvailableUndos = "NoAvailableUndos";
            public const string UnderCooldown = "UnderCooldown";
            public const string UndoSuccessful = "UndoSuccessful";
            public const string InvalidGenSyntax = "InvalidGenSyntax";
            public const string MaxSize = "MaxSize";
            public const string NotEnoughItems = "NotEnoughItems";
            public const string NeedsWall = "NeedsWall";
            public const string SignBroke = "SignBroke";
            public const string FinishedGenerating = "FinishedGenerating";
            public const string Refunded = "Refunded";
            public const string MapHeader = "MapHeader";
            public const string MapName = "MapName";
            public const string MissingRustMapApi = "MissingRustMapApi";
        }
        #endregion

        #region Sign Artist Code
        private Dictionary<string, ImageSize> SignImageSizes { get; } = new Dictionary<string, ImageSize>
        {
            // Picture Frames
            ["sign.pictureframe.landscape"] = new ImageSize(256, 128), // Landscape Picture Frame
            ["sign.pictureframe.portrait"] = new ImageSize(128, 256), // Portrait Picture Frame
            ["sign.pictureframe.tall"] = new ImageSize(128, 512), // Tall Picture Frame
            ["sign.pictureframe.xl"] = new ImageSize(512, 512), // XL Picture Frame
            ["sign.pictureframe.xxl"] = new ImageSize(1024, 512), // XXL Picture Frame

            // Wooden Signs
            ["sign.small.wood"] = new ImageSize(128, 64), // Small Wooden Sign
            ["sign.medium.wood"] = new ImageSize(256, 128), // Wooden Sign
            ["sign.large.wood"] = new ImageSize(256, 128), // Large Wooden Sign
            ["sign.huge.wood"] = new ImageSize(512, 128), // Huge Wooden Sign

            // Banners
            ["sign.hanging.banner.large"] = new ImageSize(64, 256), // Large Banner Hanging
            ["sign.pole.banner.large"] = new ImageSize(64, 256), // Large Banner on Pole

            // Hanging Signs
            ["sign.hanging"] = new ImageSize(128, 256), // Two Sided Hanging Sign
            ["sign.hanging.ornate"] = new ImageSize(256, 128), // Two Sided Ornate Hanging Sign

            // Town Signs
            ["sign.post.single"] = new ImageSize(128, 64), // Single Sign Post
            ["sign.post.double"] = new ImageSize(256, 256), // Double Sign Post
            ["sign.post.town"] = new ImageSize(256, 128), // One Sided Town Sign Post
            ["sign.post.town.roof"] = new ImageSize(256, 128), // Two Sided Town Sign Post

            // Other paintable assets
            ["spinner.wheel.deployed"] = new ImageSize(512, 512, 285, 285), // Spinning Wheel
        };

        private class ImageSize
        {
            public int Width { get; }
            public int Height { get; }
            public int ImageWidth { get; }
            public int ImageHeight { get; }
            
            public ImageSize(int width, int height) : this(width, height, width, height)
            {
            }
            
            public ImageSize(int width, int height, int imageWidth, int imageHeight)
            {
                Width = width;
                Height = height;
                ImageWidth = imageWidth;
                ImageHeight = imageHeight;
            }
        }
        #endregion
    }
}


// --- End of file: SignMap.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/speed-type ---
// --- Original File Path: S/SpeedType/SpeedType.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnityEngine;
using Oxide.Core.Configuration;
using Oxide.Core;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
	[Info("Speed Type", "TMafono", "1.1.5")]
    [Description("Quickly type randomly generated words to win a prize")]
    class SpeedType : RustPlugin
    {
		#region Variables
		private const string SpeedTypeAdmin = "speedtype.admin";
		
		private bool EventActive = false;
		private string RandomWord = String.Empty;
		
		private bool StartTier2Event = false;
		private bool StartTier3Event = false;
		
		Timer EndEventTimer;
        Timer EventAutoTimer;
		
		private List<string> EventWords = new List<string> {"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","0","1","2","3","4","5","6","7","8","9"};
		
		private readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("SpeedType");

        private Dictionary<string, int> TierStates = new Dictionary<string, int>();
		#endregion Variables
		
		#region Configuration
		private static Configuration config;

		private class Configuration
        {
			[JsonProperty(PropertyName = "Enable Automatic Events")]
            public bool AutoEventEnabled = true;
			
			[JsonProperty(PropertyName = "Event Frequency (Run Event Every X Seconds)")]
            public float EventFrequency = 300f;
			
			[JsonProperty(PropertyName = "Event Length (Ends After X Seconds)")]
            public float EventLength = 60f;
			
			[JsonProperty(PropertyName = "Minimum number of players to start a event")]
			public int StartEventMinPlayers = 10;
			
			[JsonProperty(PropertyName = "Chat Icon (SteamID64)")]
            public ulong ChatIcon = 0;
			
			[JsonProperty(PropertyName = "Tier 1 Letters/Numbers count")]
            public int Tier1LetterCount = 6;
			
			[JsonProperty(PropertyName = "Enable Tier 2 Events")]
            public bool Tier2EventStatus = false;
			
			[JsonProperty(PropertyName = "Tier 2 Event Frequency (Every X events it will be a tier 2 event)")]
            public int Tier2Frequency = 10;
			
			[JsonProperty(PropertyName = "Tier 2 Letters/Numbers count")]
            public int Tier2LetterCount = 10;
			
			[JsonProperty(PropertyName = "Enable Tier 3 Events")]
            public bool Tier3EventStatus = false;
			
			[JsonProperty(PropertyName = "Tier 3 Event Frequency (Every X events it will be a tier 3 event)")]
            public int Tier3Frequency = 100;
			
			[JsonProperty(PropertyName = "Tier 3 Letters/Numbers count")]
            public int Tier3LetterCount = 14;
			
			[JsonProperty(PropertyName = "Tier 1 Loot (Item Shortname | Item Ammount)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Dictionary<string, int>> EventT1LootTable = new List<Dictionary<string, int>>
            {
				new Dictionary<string, int>
				{
					{"stones", 100},
					{"wood", 100}
				},
				new Dictionary<string, int>
				{
					{"bandage", 100}
				}
            };
			
			[JsonProperty(PropertyName = "Tier 2 Loot (Item Shortname | Item Ammount)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<Dictionary<string, int>> EventT2LootTable = new List<Dictionary<string, int>>
            {
				new Dictionary<string, int>
				{
					{"metal.fragments", 50},
					{"metal.refined", 20}
				},
				new Dictionary<string, int>
				{
					{"leather", 60},
					{"cloth", 40}
				}
            };

			[JsonProperty(PropertyName = "Tier 3 Loot (Item Shortname | Item Ammount)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<Dictionary<string, int>> EventT3LootTable = new List<Dictionary<string, int>>
            {
				new Dictionary<string, int>
				{
					{"explosive.timed", 1}
				},
				new Dictionary<string, int>
				{
					{"rifle.ak", 1},
					{"ammo.rifle", 50}
				}
            };
			
			[JsonProperty(PropertyName = "Log Events to console")]
            public bool LogEvents = false;
        }
		
		protected override void LoadConfig()
        {
            base.LoadConfig();
            try {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            } catch {
                PrintError("Could not load a valid configuration file. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);
		#endregion Configuration
		
		#region Localization
        protected override void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["EventStart"] = "<size=20><color=#1e90ff>Speed Type</color></size>\n<size=16><color=#{0}>Tier {1} Event</color></size>\n\nThe first person to type:\n<color=#33ccff>/guess {2}</color>\nWill win a prize!",
				["EventEnd"] = "<size=20><color=#1e90ff>Speed Type</color></size>\n<size=16><color=#ffa500>Event Over!</color></size>\n\nNo Winners",
				["EventEndWinner"] = "<size=20><color=#1e90ff>Speed Type</color></size>\n<size=16><color=#ffa500>Event Over!</color></size>\n\nThe Winner is:\n<color=#1e90ff>{0}</color>\nReward:{1}",
				["EventNotStarted"] = "<size=20><color=#1e90ff>Speed Type</color></size>\n\n<size=16><color=#ffa500>No Active Events!</color></size>",
				["EventStarted"] = "<size=20><color=#1e90ff>Speed Type</color></size>\n\n<size=16><color=#ffa500>Event already started</color></size>",
				["LogEventStart"] = "Speed Type Tier {0} Event Started",
				["LogEventEnd"] = "Speed Type Event Ended",
				["LogEventEndWinner"] = "Speed Type Event Winner: {0} | User Won: {1} x{2}",
				["WrongCode"] = "<size=20><color=#1e90ff>Speed Type</color></size>\n\n<size=16><color=#ffa500>Wrong Code!</color></size>",
				["WrongSyntax"] = "<size=20><color=#1e90ff>Speed Type</color></size>\n\n<size=16><color=#ffa500>Wrong Command Syntax</color></size>",
				["WrongPerm"] = "<size=20><color=#1e90ff>Speed Type</color></size>\n\n<size=16><color=#ffa500>No Permission!</color></size>",
				["RewardFormat"] = "\n<color=#FFD700>{0}</color> x{1}",
            }, this);
        }
        #endregion Localization
		
		#region Initialization
		private void Init()
        {
            permission.RegisterPermission(SpeedTypeAdmin, this);
			
			if(config.Tier2EventStatus || config.Tier3EventStatus) {
				TierStates = dataFile.ReadObject<Dictionary<string, int>>();
			
				if(TierStates.Count == 0) {
					TierStates = new Dictionary<string, int>
					{
						{"t2efrequency", config.Tier2Frequency},
						{"t3efrequency", config.Tier3Frequency}
					};
					dataFile.WriteObject(TierStates);
				}
			}
		}
		#endregion Initialization
		
		#region Hooks
		private void OnServerInitialized()
        {
			if (config.AutoEventEnabled) {
				EventAutoTimer = timer.Repeat(config.EventFrequency, 0, () =>
                {
                    StartSpeedTypeEvent();
                });
			}
		}
		#endregion Hooks
		
		void StartSpeedTypeEvent(bool consolecmd = false)
        {
            if (EventActive)
				return;
			
			if(BasePlayer.activePlayerList.Count <= config.StartEventMinPlayers && !consolecmd)
				return;
			
			if(!consolecmd)
				CheckTierStatus();
			
			EventActive = true;
			
			if(StartTier3Event) {
				RandomWord = SpeedEventWordGenerator(config.Tier3LetterCount);
				Broadcast(Lang("EventStart",null,"ff4500","3",RandomWord));
				if(config.LogEvents)
					Puts(Lang("LogEventStart",null,"3"));
			} else if (StartTier2Event) {
				RandomWord = SpeedEventWordGenerator(config.Tier2LetterCount);
				Broadcast(Lang("EventStart",null,"ffa500","2",RandomWord));
				if(config.LogEvents)
					Puts(Lang("LogEventStart",null,"2"));
			} else {
				RandomWord = SpeedEventWordGenerator(config.Tier1LetterCount);
				Broadcast(Lang("EventStart",null,"ffff00","1",RandomWord));
				if(config.LogEvents)
					Puts(Lang("LogEventStart",null,"1"));
			}
            
            EndEventTimer = timer.Once(config.EventLength, () =>
            {
				EndSpeedTypeEvent();
            });
        }
		
		private void EndSpeedTypeEvent(BasePlayer winner = null)
        {	
			EventActive = false;
			EndEventTimer.Destroy();
			
			if(winner != null){
				if(StartTier3Event) {
					var RandomList = RandomGen(config.EventT3LootTable.Count);
					GiveItem(winner,config.EventT3LootTable[RandomList]);
				} else if (StartTier2Event) {
					var RandomList = RandomGen(config.EventT2LootTable.Count);
					GiveItem(winner,config.EventT2LootTable[RandomList]);
				} else {
					var RandomList = RandomGen(config.EventT1LootTable.Count);
					GiveItem(winner,config.EventT1LootTable[RandomList]);
				}
				if(config.LogEvents)
					Puts(Lang("LogEventEnd"));
			} else {
				Broadcast(Lang("EventEnd"));
				if(config.LogEvents)
					Puts(Lang("LogEventEnd"));
			}
			
			StartTier2Event = false;
			StartTier3Event = false;
        }
		
		[ChatCommand("guess")]
        private void SpeedTypeCommand(BasePlayer player, string cmd, string[] args)
        {
			if (args.Length == 1) {
				if(args[0].ToUpper() == "END") {
					if(HasPermission(player)) {
						if (EventActive){
							EndSpeedTypeEvent();
						}
					}
				} else {
					if (!EventActive) {
						Message(player,Lang("EventNotStarted"));
						return;
					}
					
					if(args[0].ToUpper() == RandomWord) {
						EndSpeedTypeEvent(player);
					} else {
						Message(player,Lang("WrongCode"));
					}
				}
			} else if (args.Length == 2) {
				if(args[0].ToUpper() == "START") {
					if(HasPermission(player)) {
						if(args[1].ToUpper() == "T1") {
							if (EventActive){
								Message(player,Lang("EventStarted"));
								return;
							}
							
							StartSpeedTypeEvent(true);
						} else if(args[1].ToUpper() == "T2") {
							if (EventActive){
								Message(player,Lang("EventStarted"));
								return;
							}
							
							StartTier2Event = true;
							StartSpeedTypeEvent(true);
						} else if(args[1].ToUpper() == "T3") {
							if (EventActive){
								Message(player,Lang("EventStarted"));
								return;
							}
							
							StartTier3Event = true;
							StartSpeedTypeEvent(true);
						} else {
							Message(player,Lang("WrongSyntax"));
						}
					} else {
						Message(player,Lang("WrongPerm"));
					}
				}
			} else {
				Message(player,Lang("WrongSyntax"));
			}
		}
		
		#region Helpers
		private int RandomGen(int tableSize)
        {
            return Convert.ToInt32(Math.Round(Convert.ToDouble(Random.Range(Convert.ToSingle(0), Convert.ToSingle(tableSize-1)))));
        }
		
		
		private void GiveItem(BasePlayer player, Dictionary<string, int> selectedList)
        {
			string ItemReward = String.Empty;
			
			foreach(var items in selectedList)
			{
				Item item = ItemManager.Create(FindItem(items.Key));
				if (item == null) {
					return;
				}

				item.amount = items.Value;

				ItemContainer itemContainer = player.inventory.containerMain;

				if (!player.inventory.GiveItem(item, itemContainer)) {
					item.Remove();
					return;
				}

				var itemName = item.info.displayName.english;
				player.Command("note.inv", item.info.itemid, items.Value);
				ItemReward += Lang("RewardFormat",null,itemName,items.Value);
				
				if(config.LogEvents)
					Puts(Lang("LogEventEndWinner",null,player.displayName,itemName,items.Value));
			}
			
			Broadcast(Lang("EventEndWinner",null,player.displayName,ItemReward));
		}
		
		private void CheckTierStatus()
        {
			if(TierStates.Count != 0) {
				if(config.Tier2EventStatus) {
					if(TierStates["t2efrequency"] == 0){
						StartTier2Event = true;
						TierStates["t2efrequency"] = config.Tier2Frequency;
					} else {
						TierStates["t2efrequency"]--;
					}
				}
				
				if(config.Tier3EventStatus) {
					if(TierStates["t3efrequency"] == 0){
						StartTier2Event = false;
						StartTier3Event = true;
						TierStates["t3efrequency"] = config.Tier3Frequency;
					} else {
						TierStates["t3efrequency"]--;
					}
				}
				
				if(config.Tier2EventStatus || config.Tier3EventStatus) {
					dataFile.WriteObject(TierStates);
				}
			}
		}
		
		private ItemDefinition FindItem(string itemName)
        {
            ItemDefinition itemDef = ItemManager.FindItemDefinition(itemName.ToLower());
            return itemDef;
        }
		
		private string SpeedEventWordGenerator(int wordcount)
		{
			var RandomGeneratedWord = String.Empty;
			
			for (var i = 0; i < wordcount; i++) {
				var randomletter = Convert.ToInt32(Math.Round(Convert.ToDouble(Random.Range(Convert.ToSingle(0), Convert.ToSingle(EventWords.Count-1)))));
				RandomGeneratedWord = RandomGeneratedWord + EventWords[randomletter];
            }
			
			return RandomGeneratedWord;
			
		}
        private void Broadcast(string message)
        {
            Server.Broadcast(message, config.ChatIcon);
        }

        private void Message(BasePlayer player, string message)
        {
            Player.Message(player, message, config.ChatIcon);
        }

        private bool HasPermission(BasePlayer player)
        {
            return permission.UserHasPermission(player.UserIDString, SpeedTypeAdmin);
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }
		#endregion Helpers
	}
}

// --- End of file: SpeedType.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/spawn-modular-car ---
// --- Original File Path: S/SpawnModularCar/SpawnModularCar.cs ---

ï»¿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using Rust.Modular;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.Text;

namespace Oxide.Plugins
{
    [Info("Spawn Modular Car", "WhiteThunder", "5.3.0")]
    [Description("Allows players to spawn modular cars.")]
    internal class SpawnModularCar : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin MonumentFinder, VehicleDeployedLocks;

        private static SpawnModularCar _pluginInstance;
        private static Configuration _pluginConfig;

        private PluginData _pluginData;
        private CommonPresets _commonPresets;

        private const string DefaultPresetName = "default";
        private const int PresetMaxLength = 30;

        private const string PermissionSpawnSockets2 = "spawnmodularcar.spawn.2";
        private const string PermissionSpawnSockets3 = "spawnmodularcar.spawn.3";
        private const string PermissionSpawnSockets4 = "spawnmodularcar.spawn.4";

        private const string PermissionEnginePartsTier1 = "spawnmodularcar.engineparts.tier1";
        private const string PermissionEnginePartsTier2 = "spawnmodularcar.engineparts.tier2";
        private const string PermissionEnginePartsTier3 = "spawnmodularcar.engineparts.tier3";

        private const string PermissionFix = "spawnmodularcar.fix";
        private const string PermissionFetch = "spawnmodularcar.fetch";
        private const string PermissionDespawn = "spawnmodularcar.despawn";
        private const string PermissionAutoFuel = "spawnmodularcar.autofuel";
        private const string PermissionAutoCodeLock = "spawnmodularcar.autocodelock";
        private const string PermissionAutoKeyLock = "spawnmodularcar.autokeylock";
        private const string PermissionAutoStartEngine = "spawnmodularcar.autostartengine";
        private const string PermissionAutoFillTankers = "spawnmodularcar.autofilltankers";
        private const string PermissionGiveCar = "spawnmodularcar.givecar";

        private const string PermissionPresets = "spawnmodularcar.presets";
        private const string PermissionPresetLoad = "spawnmodularcar.presets.load";
        private const string PermissionCommonPresets = "spawnmodularcar.presets.common";
        private const string PermissionManageCommonPresets = "spawnmodularcar.presets.common.manage";

        private const string PrefabSockets2 = "assets/content/vehicles/modularcar/2module_car_spawned.entity.prefab";
        private const string PrefabSockets3 = "assets/content/vehicles/modularcar/3module_car_spawned.entity.prefab";
        private const string PrefabSockets4 = "assets/content/vehicles/modularcar/4module_car_spawned.entity.prefab";

        private const string ItemDropPrefab = "assets/prefabs/misc/item drop/item_drop.prefab";

        private const string RepairEffectPrefab = "assets/bundled/prefabs/fx/build/promote_toptier.prefab";
        private const string TankerFilledEffectPrefab = "assets/prefabs/food/water jug/effects/water-jug-fill-container.prefab";

        // These layers are used to preventing spawning inside walls or players.
        private const int BoxcastLayers = Layers.Mask.Default
            + Layers.Mask.Deployed
            + Layers.Mask.Player_Server
            + Layers.Mask.AI
            + Layers.Mask.Vehicle_Detailed
            + Layers.Mask.Vehicle_World
            + Layers.Mask.World
            + Layers.Mask.Construction
            + Layers.Mask.Tree;

        // These layers are used to find a surface to spawn on.
        private const int RaycastLayers = Layers.Mask.Default
            + Layers.Mask.Terrain
            + Layers.World
            + Layers.Mask.Construction;

        private static readonly Vector3 ShortCarExtents = new(1, 1.1f, 1.5f);
        private static readonly Vector3 MediumCarExtents = new(1, 1.1f, 2.3f);
        private static readonly Vector3 LongCarExtents = new(1, 1.1f, 3);

        private static readonly Vector3 ShortCarFrontLeft = new(ShortCarExtents.x, 0, ShortCarExtents.z);
        private static readonly Vector3 ShortCarFrontRight = new(-ShortCarExtents.x, 0, ShortCarExtents.z);
        private static readonly Vector3 ShortCarBackLeft = new(ShortCarExtents.x, 0, -ShortCarExtents.z);
        private static readonly Vector3 ShortCarBackRight = new(-ShortCarExtents.x, 0, -ShortCarExtents.z);

        private static readonly Vector3 MediumCarFrontLeft = new(MediumCarExtents.x, 0, MediumCarExtents.z);
        private static readonly Vector3 MediumCarFrontRight = new(-MediumCarExtents.x, 0, MediumCarExtents.z);
        private static readonly Vector3 MediumCarBackLeft = new(MediumCarExtents.x, 0, -MediumCarExtents.z);
        private static readonly Vector3 MediumCarBackRight = new(-MediumCarExtents.x, 0, -MediumCarExtents.z);

        private static readonly Vector3 LongCarFrontLeft = new(LongCarExtents.x, 0, LongCarExtents.z);
        private static readonly Vector3 LongCarFrontRight = new(-LongCarExtents.x, 0, LongCarExtents.z);
        private static readonly Vector3 LongCarBackLeft = new(LongCarExtents.x, 0, -LongCarExtents.z);
        private static readonly Vector3 LongCarBackRight = new(-LongCarExtents.x, 0, -LongCarExtents.z);

        private static readonly float ForwardRaycastDistance = 1.5f + ShortCarExtents.x;
        private const float DownwardRaycastDistance = 4;

        private readonly RaycastHit[] _raycastBuffer = new RaycastHit[1];

        private readonly Dictionary<string, PlayerConfig> _playerConfigsMap = new();

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginInstance = this;

            _pluginData = PluginData.LoadData();
            _commonPresets = CommonPresets.LoadData(_pluginData);

            MigrateConfig();

            permission.RegisterPermission(PermissionSpawnSockets2, this);
            permission.RegisterPermission(PermissionSpawnSockets3, this);
            permission.RegisterPermission(PermissionSpawnSockets4, this);

            permission.RegisterPermission(PermissionEnginePartsTier1, this);
            permission.RegisterPermission(PermissionEnginePartsTier2, this);
            permission.RegisterPermission(PermissionEnginePartsTier3, this);

            permission.RegisterPermission(PermissionFix, this);
            permission.RegisterPermission(PermissionFetch, this);
            permission.RegisterPermission(PermissionDespawn, this);
            permission.RegisterPermission(PermissionAutoFuel, this);
            permission.RegisterPermission(PermissionAutoCodeLock, this);
            permission.RegisterPermission(PermissionAutoKeyLock, this);
            permission.RegisterPermission(PermissionAutoStartEngine, this);
            permission.RegisterPermission(PermissionAutoFillTankers, this);
            permission.RegisterPermission(PermissionGiveCar, this);

            permission.RegisterPermission(PermissionPresets, this);
            permission.RegisterPermission(PermissionPresetLoad, this);
            permission.RegisterPermission(PermissionCommonPresets, this);
            permission.RegisterPermission(PermissionManageCommonPresets, this);
        }

        private void OnServerInitialized()
        {
            if (_pluginConfig.HasMonumentRestriction && MonumentFinder == null)
            {
                LogWarning("The Monument Finder plugin is not loaded, so monument restrictions will not work. If you don't want monument restrictions, set \"DisallowedMonuments\": [] in the config to stop seeing this warning.");
            }
        }

        private void Unload()
        {
            _pluginInstance = null;
            _pluginConfig = null;
        }

        private void OnNewSave(string filename)
        {
            _pluginData.PlayerCars.Clear();
            _pluginData.Cooldowns.ClearAll();
            _pluginData.SaveData();
        }

        private void OnEntityKill(ModularCar car)
        {
            if (!IsPlayerCar(car))
                return;

            var userId = _pluginData.PlayerCars.FirstOrDefault(x => x.Value == car.net.ID.Value).Key;
            var player = BasePlayer.Find(userId);

            if (player != null)
                ChatMessage(player, "Generic.Info.CarDestroyed");

            _pluginData.UnregisterCar(userId);
        }

        private void OnEngineStarted(ModularCar car, BasePlayer player)
        {
            if (car == null
                || car.OwnerID == 0
                || !_pluginData.PlayerCars.ContainsValue(car.net.ID.Value)
                || !permission.UserHasPermission(car.OwnerID.ToString(), PermissionAutoStartEngine))
                return;

            if (car.engineController.IsStarting)
            {
                car.CancelInvoke(car.engineController.FinishStartingEngine);
                car.engineController.FinishStartingEngine();
            }
        }

        #endregion

        #region API

        private static class ApiParser
        {
            public static string CodeLockField = "CodeLock";
            public static string KeyLockField = "KeyLock";
            public static string EnginePartsTierField = "EnginePartsTier";
            public static string FreshWaterAmountField = "FreshWaterAmount";
            public static string FuelAmountField = "FuelAmount";
            public static string ModulesField = "Modules";

            public static bool TryParseOptions(Dictionary<string, object> options, out PresetCarOptions presetOptions)
            {
                var codeLock = BoolOption(options, CodeLockField);
                var keyLock = BoolOption(options, KeyLockField);
                var enginePartsTier = IntOption(options, EnginePartsTierField);
                var freshWaterAmount = IntOption(options, FreshWaterAmountField);
                var fuelAmount = IntOption(options, FuelAmountField);
                var moduleIDs = ParseModulesOption(options);

                presetOptions = null;

                if (moduleIDs == null)
                {
                    _pluginInstance.LogError($"[API] '{ApiParser.ModulesField}' field is missing or unrecognizable.");
                    return false;
                }

                if (moduleIDs.Length is < 2 or > 4)
                {
                    _pluginInstance.LogError($"[API] Requested a car with {moduleIDs.Length} sockets, but only 2-4 sockets is supported.");
                    return false;
                }

                presetOptions = new PresetCarOptions
                {
                    CodeLock = codeLock,
                    KeyLock = keyLock,
                    EnginePartsTier = enginePartsTier,
                    FreshWaterAmount = freshWaterAmount,
                    FuelAmount = fuelAmount,
                    NormalizedModuleIDs = moduleIDs
                };
                return true;
            }

            private static bool BoolOption(Dictionary<string, object> options, string name)
            {
                return options.TryGetValue(name, out var value) && value is true;
            }

            private static int IntOption(Dictionary<string, object> options, string name)
            {
                return options.TryGetValue(name, out var value) && value is int i
                    ? i
                    : 0;
            }

            public static int[] ParseModulesOption(Dictionary<string, object> options)
            {
                if (!options.ContainsKey(ModulesField))
                    return null;

                if (options[ModulesField] is not object[] moduleArray)
                    return null;

                return _pluginInstance.ValidateModules(moduleArray);
            }
        }

        private ModularCar API_SpawnPreset(Dictionary<string, object> options, BasePlayer player, Vector3 position, Quaternion rotation)
        {
            if (!ApiParser.TryParseOptions(options, out var presetOptions))
                return null;

            if (SpawnWasBlocked(player))
                return null;

            if (position == Vector3.zero && player != null)
                DetermineCarPositionAndRotation(player, presetOptions.Length, out position, out rotation);

            return SpawnCar(presetOptions, position, rotation, player, shouldTrackCar: false);
        }

        private ModularCar API_SpawnNamedPreset(string presetName, BasePlayer player, Vector3 position, Quaternion rotation)
        {
            var presetOptions = _pluginConfig.FindPreset(presetName)?.Options;
            if (presetOptions == null)
            {
                LogError($"[API] Server preset '{presetName}' not found.");
                return null;
            }

            if (presetOptions.Length is < 2 or > 4)
            {
                LogError($"[API] Requested a car with {presetOptions.Length} sockets, but only 2-4 sockets is supported.");
                return null;
            }

            if (SpawnWasBlocked(player))
                return null;

            if (position == Vector3.zero && player != null)
                DetermineCarPositionAndRotation(player, presetOptions.Length, out position, out rotation);

            return SpawnCar(presetOptions, position, rotation, player, shouldTrackCar: false);
        }

        private ModularCar API_SpawnPresetCar(BasePlayer player, Dictionary<string, object> options, Action<ModularCar> onReady = null)
        {
            if (!ApiParser.TryParseOptions(options, out var presetOptions))
                return null;

            if (SpawnWasBlocked(player))
                return null;

            if (!TryGetIdealCarPositionAndRotation(player, presetOptions.Length, out var spawnPosition, out var rotation))
            {
                spawnPosition = GetFixedCarPosition(player);
                rotation = GetRelativeCarRotation(player);
            }

            var car = SpawnCar(presetOptions, spawnPosition, rotation, player, shouldTrackCar: false);
            if (car != null)
            {
                // Note: Consumers no longer need to use this callback since this plugin now forces synchronous module registration.
                onReady?.Invoke(car);
            }

            return car;
        }

        #endregion

        #region Commands

        [Command("givecar")]
        private void SpawnCarServerCommand(IPlayer player, string cmd, string[] args)
        {
            if (!player.IsServer && !VerifyPermissionAny(player, PermissionGiveCar))
                return;

            if (args.Length < 2)
            {
                ReplyToPlayer(player, "Command.Give.Error.Syntax");
                return;
            }

            var playerNameOrIdArg = args[0];
            var presetNameArg = args[1];

            var targetPlayer = BasePlayer.Find(playerNameOrIdArg);
            if (targetPlayer == null)
            {
                ReplyToPlayer(player, "Command.Give.Error.PlayerNotFound", playerNameOrIdArg);
                return;
            }

            var preset = _pluginConfig.FindPreset(presetNameArg);
            if (preset == null)
            {
                ReplyToPlayer(player, "Generic.Error.PresetNotFound", presetNameArg);
                return;
            }

            var carOptions = preset.Options;
            if (carOptions.Length < 2)
            {
                ReplyToPlayer(player, "Command.Give.Error.PresetTooFewModules", preset.Name, carOptions.Length);
                return;
            }
            if (carOptions.Length > 4)
            {
                ReplyToPlayer(player, "Command.Give.Error.PresetTooManyModules", preset.Name, carOptions.Length);
                return;
            }

            if (!TryGetIdealCarPositionAndRotation(targetPlayer, preset.Options.Length, out var spawnPosition, out var rotation))
            {
                spawnPosition = GetFixedCarPosition(targetPlayer);
                rotation = GetRelativeCarRotation(targetPlayer);
            }

            var car = SpawnCar(carOptions, spawnPosition, rotation, targetPlayer, shouldTrackCar: false);
            if (car != null)
            {
                ReplyToPlayer(player, "Command.Give.Success", targetPlayer.displayName, preset.Name);
            }
        }

        [Command("mycar")]
        private void MyCarCommand(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer)
                return;

            var basePlayer = player.Object as BasePlayer;
            if (!basePlayer.CanInteract())
                return;

            if (args.Length == 0)
            {
                SubCommand_SpawnCar(player, args);
                return;
            }

            switch (args[0].ToLower())
            {
                case "help":
                    SubCommand_Help(player, args.Skip(1).ToArray());
                    return;

                case "list":
                    SubCommand_ListPresets(player, args.Skip(1).ToArray());
                    return;

                case "save":
                    SubCommand_SavePreset(player, args.Skip(1).ToArray());
                    return;

                case "update":
                    SubCommand_UpdatePreset(player, args.Skip(1).ToArray());
                    return;

                case "load":
                    SubCommand_LoadPreset(player, args.Skip(1).ToArray());
                    return;

                case "rename":
                    SubCommand_RenamePreset(player, args.Skip(1).ToArray());
                    return;

                case "delete":
                    SubCommand_DeletePreset(player, args.Skip(1).ToArray());
                    return;

                case "fix":
                    SubCommand_FixCar(player, args.Skip(1).ToArray());
                    return;

                case "fetch":
                    SubCommand_FetchCar(player, args.Skip(1).ToArray());
                    return;

                case "destroy":
                    SubCommand_DestroyCar(player, args.Skip(1).ToArray());
                    return;

                case "autocodelock":
                    SubCommand_ToggleAutoCodeLock(player, args.Skip(1).ToArray());
                    return;

                case "autokeylock":
                    SubCommand_ToggleAutoKeyLock(player, args.Skip(1).ToArray());
                    return;

                case "autofilltankers":
                    SubCommand_ToggleAutoFillTankers(player, args.Skip(1).ToArray());
                    return;

                case "common":
                    SubCommand_CommonPreset(player, args.Skip(1).ToArray());
                    return;

                default:
                    SubCommand_SpawnCar(player, args);
                    return;
            }
        }

        private void SubCommand_CommonPreset(IPlayer player, string[] args)
        {
            if (args.Length == 0)
            {
                ReplyToPlayer(player, "Command.Common.Error.Syntax");
                return;
            }

            switch (args[0].ToLower())
            {
                case "list":
                    SubCommand_Common_ListPresets(player, args.Skip(1).ToArray());
                    return;

                case "load":
                    SubCommand_Common_LoadPreset(player, args.Skip(1).ToArray());
                    return;

                case "save":
                    SubCommand_Common_SavePreset(player, args.Skip(1).ToArray());
                    return;

                case "update":
                    SubCommand_Common_UpdatePreset(player, args.Skip(1).ToArray());
                    return;

                case "rename":
                    SubCommand_Common_RenamePreset(player, args.Skip(1).ToArray());
                    return;

                case "delete":
                    SubCommand_Common_DeletePreset(player, args.Skip(1).ToArray());
                    return;

                default:
                    SubCommand_Common_SpawnCar(player, args);
                    return;
            }
        }

        private void SubCommand_Help(IPlayer player, string[] args)
        {
            var maxAllowedSockets = GetPlayerMaxAllowedCarSockets(player.Id);
            if (maxAllowedSockets == 0)
            {
                ReplyToPlayer(player, "Generic.Error.NoPermission");
                return;
            }

            var canUsePresets = permission.UserHasPermission(player.Id, PermissionPresets);
            var canLoadPresets = permission.UserHasPermission(player.Id, PermissionPresetLoad);

            var sb = new StringBuilder();
            sb.AppendLine(GetMessage(player, "Command.Help"));

            if (canUsePresets)
            {
                sb.AppendLine(GetMessage(player, "Command.Help.Spawn.Basic.PresetsAllowed"));
            }
            else
            {
                sb.AppendLine(GetMessage(player, "Command.Help.Spawn.Basic"));
            }

            sb.AppendLine(GetMessage(player, "Command.Help.Spawn.Sockets"));

            if (permission.UserHasPermission(player.Id, PermissionFix))
            {
                sb.AppendLine(GetMessage(player, "Command.Help.Fix"));
            }

            if (permission.UserHasPermission(player.Id, PermissionFetch))
            {
                sb.AppendLine(GetMessage(player, "Command.Help.Fetch"));
            }

            if (permission.UserHasPermission(player.Id, PermissionDespawn))
            {
                sb.AppendLine(GetMessage(player, "Command.Help.Destroy"));
            }

            if (canUsePresets)
            {
                sb.AppendLine(GetMessage(player, "Command.Help.Section.PersonalPresets"));
                sb.AppendLine(GetMessage(player, "Command.Help.ListPresets"));
                sb.AppendLine(GetMessage(player, "Command.Help.Spawn.Preset"));

                if (canLoadPresets)
                {
                    sb.AppendLine(GetMessage(player, "Command.Help.LoadPreset"));
                }

                sb.AppendLine(GetMessage(player, "Command.Help.SavePreset"));
                sb.AppendLine(GetMessage(player, "Command.Help.UpdatePreset"));
                sb.AppendLine(GetMessage(player, "Command.Help.RenamePreset"));
                sb.AppendLine(GetMessage(player, "Command.Help.DeletePreset"));
            }

            if (permission.UserHasPermission(player.Id, PermissionCommonPresets))
            {
                sb.AppendLine(GetMessage(player, "Command.Help.Section.CommonPresets"));
                sb.AppendLine(GetMessage(player, "Command.Help.Common.ListPresets"));
                sb.AppendLine(GetMessage(player, "Command.Help.Common.Spawn"));

                if (canLoadPresets)
                {
                    sb.AppendLine(GetMessage(player, "Command.Help.Common.LoadPreset"));
                }

                if (permission.UserHasPermission(player.Id, PermissionManageCommonPresets))
                {
                    sb.AppendLine(GetMessage(player, "Command.Help.Common.SavePreset"));
                    sb.AppendLine(GetMessage(player, "Command.Help.Common.UpdatePreset"));
                    sb.AppendLine(GetMessage(player, "Command.Help.Common.RenamePreset"));
                    sb.AppendLine(GetMessage(player, "Command.Help.Common.DeletePreset"));
                }
            }

            var canCodeLock = VehicleDeployedLocks != null && permission.UserHasPermission(player.Id, PermissionAutoCodeLock);
            var canKeyLock = permission.UserHasPermission(player.Id, PermissionAutoKeyLock);
            var canFillTankers = permission.UserHasPermission(player.Id, PermissionAutoFillTankers);

            if (canCodeLock || canKeyLock || canFillTankers)
            {
                sb.AppendLine(GetMessage(player, "Command.Help.Section.PersonalSettings"));
            }

            if (canCodeLock)
            {
                sb.AppendLine(GetMessage(player, "Command.Help.ToggleAutoCodeLock",
                    BooleanToLocalizedString(player, GetPlayerConfig(player).Settings.AutoCodeLock)));
            }

            if (canKeyLock)
            {
                sb.AppendLine(GetMessage(player, "Command.Help.ToggleAutoKeyLock",
                    BooleanToLocalizedString(player, GetPlayerConfig(player).Settings.AutoKeyLock)));
            }

            if (canFillTankers)
            {
                sb.AppendLine(GetMessage(player, "Command.Help.ToggleAutoFillTankers",
                    BooleanToLocalizedString(player, GetPlayerConfig(player).Settings.AutoFillTankers)));
            }

            if (permission.UserHasPermission(player.Id, PermissionGiveCar))
            {
                sb.AppendLine("Command.Help.Section.OtherCommands");
                sb.AppendLine(GetMessage(player, "Command.Help.Give"));
            }

            player.Reply(sb.ToString());
        }

        private void SubCommand_SpawnCar(IPlayer player, string[] args)
        {
            var maxAllowedSockets = GetPlayerMaxAllowedCarSockets(player.Id);
            if (maxAllowedSockets == 0)
            {
                ReplyToPlayer(player, "Generic.Error.NoPermission");
                return;
            }

            if (!VerifyHasNoCar(player)
                || !VerifyOffCooldown(player, CooldownType.Spawn)
                || !VerifyLocationNotRestricted(player)
                || !_pluginConfig.CanSpawnBuildingBlocked && !VerifyNotBuildingBlocked(player))
                return;

            // Key binds automatically pass the "True" argument.
            var wasPassedArgument = args.Length > 0 && args[0] != "True";

            if (wasPassedArgument)
            {
                if (int.TryParse(args[0], out var desiredSockets))
                {
                    if (desiredSockets is < 2 or > 4)
                    {
                        ReplyToPlayer(player, "Command.Spawn.Error.SocketSyntax");
                        return;
                    }

                    if (desiredSockets > maxAllowedSockets)
                    {
                        ReplyToPlayer(player, "Generic.Error.NoPermission");
                        return;
                    }

                    SpawnRandomCarForPlayer(player, desiredSockets);
                    return;
                }

                if (!VerifyPermissionAny(player, PermissionPresets))
                    return;

                var presetNameArg = args[0];

                if (!VerifyOnlyOneMatchingPreset(player, GetPlayerConfig(player), presetNameArg, out var preset))
                    return;

                SpawnPresetCarForPlayer(player, preset);
            }
            else
            {
                if (permission.UserHasPermission(player.Id, PermissionPresets))
                {
                    var preset = GetPlayerConfig(player).FindPreset(DefaultPresetName);
                    if (preset != null)
                    {
                        SpawnPresetCarForPlayer(player, preset);
                        return;
                    }
                }

                SpawnRandomCarForPlayer(player, maxAllowedSockets);
            }
        }

        private void SubCommand_Common_SpawnCar(IPlayer player, string[] args)
        {
            var maxAllowedSockets = GetPlayerMaxAllowedCarSockets(player.Id);
            if (maxAllowedSockets == 0)
            {
                ReplyToPlayer(player, "Generic.Error.NoPermission");
                return;
            }

            if (!VerifyPermissionAny(player, PermissionCommonPresets)
                || !VerifyHasNoCar(player)
                || !VerifyOffCooldown(player, CooldownType.Spawn)
                || !VerifyLocationNotRestricted(player)
                || !_pluginConfig.CanSpawnBuildingBlocked && !VerifyNotBuildingBlocked(player))
                return;

            var presetNameArg = args[0];

            if (!VerifyOnlyOneMatchingPreset(player, _commonPresets, presetNameArg, out var preset))
                return;

            SpawnPresetCarForPlayer(player, preset);
        }

        private void SubCommand_FixCar(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionFix))
                return;

            if (!VerifyHasCar(player, out var car)
                || !VerifyOffCooldown(player, CooldownType.Fix)
                || FixMyCarWasBlocked(player.Object as BasePlayer, car))
                return;

            if (car.IsDead())
                ReviveCar(car);

            FixCar(car, GetPlayerAllowedFuel(player.Id), GetPlayerEnginePartsTier(player.Id));
            MaybeFillTankerModules(car, GetPlayerAllowedFreshWater(player.Id));
            _pluginData.StartCooldown(player.Id, CooldownType.Fix);

            MaybePlayCarRepairEffects(car);
            ReplyToPlayer(player, "Command.Fix.Success");
        }

        private void SubCommand_FetchCar(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionFetch))
                return;

            var basePlayer = player.Object as BasePlayer;

            if (!VerifyHasCar(player, out var car)
                || !_pluginConfig.CanFetchOccupied && !VerifyCarNotOccupied(player, car)
                || !VerifyOffCooldown(player, CooldownType.Fetch)
                || !VerifyLocationNotRestricted(player)
                || !_pluginConfig.CanFetchBuildingBlocked && !VerifyNotBuildingBlocked(player)
                || !VerifySufficientSpace(player, car.TotalSockets, out var fetchPosition, out var fetchRotation)
                || FetchMyCarWasBlocked(basePlayer, car))
                return;

            // This is a hacky way to determine that the car is on a lift.
            if (car.rigidBody.isKinematic && !TryReleaseCarFromLift(car))
            {
                var messages = new List<string> { GetMessage(player, "Command.Fetch.Error.StuckOnLift") };
                if (permission.UserHasPermission(player.Id, PermissionDespawn))
                    messages.Add(GetMessage(player, "Command.Fetch.Error.StuckOnLift.Help"));

                player.Reply(string.Join(" ", messages));
                return;
            }

            if (_pluginConfig.DismountPlayersOnFetch)
            {
                DismountAllPlayersFromCar(car);
            }

            // Temporarily clear max angular velocity to prevent the car from unexpectedly spinning when teleporting really far.
            var maxAngularVelocity = car.rigidBody.maxAngularVelocity;
            car.rigidBody.maxAngularVelocity = 0;

            car.transform.SetPositionAndRotation(fetchPosition, fetchRotation);
            car.SetVelocity(Vector3.zero);
            car.SetAngularVelocity(Vector3.zero);
            car.UpdateNetworkGroup();
            car.SendNetworkUpdateImmediate();
            timer.Once(1f, () =>
            {
                if (car != null)
                {
                    car.rigidBody.maxAngularVelocity = maxAngularVelocity;
                }
            });

            _pluginData.StartCooldown(player.Id, CooldownType.Fetch);
            ReplyToPlayer(player, "Command.Fetch.Success");
        }

        private void SubCommand_DestroyCar(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionDespawn))
                return;

            var basePlayer = player.Object as BasePlayer;

            if (!VerifyHasCar(player, out var car)
                || !_pluginConfig.CanDespawnOccupied && !VerifyCarNotOccupied(player, car)
                || DestroyMyCarWasBlocked(basePlayer, car))
                return;

            var extractedEngineParts = ExtractEnginePartsAboveTierAndDeleteRest(car, GetPlayerEnginePartsTier(player.Id));

            car.Kill();

            if (extractedEngineParts.Count > 0)
            {
                GiveItemsToPlayerOrDrop(basePlayer, extractedEngineParts);
                ReplyToPlayer(player, "Generic.Info.PartsRecovered");
            }
        }

        private void SubCommand_ListPresets(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresets))
                return;

            var config = GetPlayerConfig(player);
            if (config.Presets.Count == 0)
            {
                ReplyToPlayer(player, "Generic.Error.NoPresets");
                return;
            }

            var presetList = config.Presets.Select(p => p).ToList();
            presetList.Sort(SortPresetNames);

            var sb = new StringBuilder();
            sb.AppendLine(GetMessage(player, "Command.List"));

            foreach (var preset in presetList)
            {
                sb.AppendLine(GetMessage(player, "Command.List.Item", preset.Name, preset.NumSockets));
            }

            player.Reply(sb.ToString());
        }

        private void SubCommand_Common_ListPresets(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionCommonPresets))
                return;

            if (_commonPresets.Presets.Count == 0)
            {
                ReplyToPlayer(player, "Generic.Error.NoCommonPresets");
                return;
            }

            var maxAllowedSockets = GetPlayerMaxAllowedCarSockets(player.Id);

            var presetList = _commonPresets.Presets.Where(p => p.NumSockets <= maxAllowedSockets).ToList();
            presetList.Sort(SortPresetNames);

            var sb = new StringBuilder();
            sb.AppendLine(GetMessage(player, "Command.Common.List"));

            foreach (var preset in presetList)
            {
                sb.AppendLine(GetMessage(player, "Command.List.Item", preset.Name, preset.NumSockets));
            }

            player.Reply(sb.ToString());
        }

        private void SubCommand_SavePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresets))
                return;

            if (!VerifyHasCar(player, out var car))
                return;

            var presetNameArg = args.Length == 0 ? DefaultPresetName : args[0];

            var presetManager = GetPlayerConfig(player);
            if (!VerifyNoMatchingPreset(player, presetManager, presetNameArg))
                return;

            if (presetManager.Presets.Count >= _pluginConfig.MaxPresetsPerPlayer)
            {
                ReplyToPlayer(player, "Command.SavePreset.Error.TooManyPresets", _pluginConfig.MaxPresetsPerPlayer);
                return;
            }

            SavePreset(player, presetManager, presetNameArg, car);
        }

        private void SubCommand_Common_SavePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionManageCommonPresets))
                return;

            if (args.Length == 0)
            {
                ReplyToPlayer(player, "Command.Common.SavePreset.Error.Syntax");
                return;
            }

            var presetNameArg = args[0];

            if (!VerifyHasCar(player, out var car)
                || !VerifyNoMatchingPreset(player, _commonPresets, presetNameArg))
                return;

            SavePreset(player, _commonPresets, presetNameArg, car);
        }

        private void SavePreset(IPlayer player, SimplePresetManager presetManager, string presetNameArg, ModularCar car)
        {
            if (presetNameArg.Length > PresetMaxLength)
            {
                ReplyToPlayer(player, "Generic.Error.PresetNameLength", PresetMaxLength);
                return;
            }

            presetManager.SavePreset(SimplePreset.FromCar(car, presetNameArg));
            ReplyToPlayer(player, "Command.SavePreset.Success", presetNameArg);
        }

        private void SubCommand_UpdatePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresets))
                return;

            var presetNameArg = args.Length == 0 ? DefaultPresetName : args[0];
            UpdatePreset(player, GetPlayerConfig(player), presetNameArg);
        }

        private void SubCommand_Common_UpdatePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionManageCommonPresets))
                return;

            if (args.Length == 0)
            {
                ReplyToPlayer(player, "Command.Common.UpdatePreset.Error.Syntax");
                return;
            }

            UpdatePreset(player, _commonPresets, args[0]);
        }

        private void UpdatePreset(IPlayer player, SimplePresetManager presetManager, string presetNameArg)
        {
            if (!VerifyHasCar(player, out var car))
                return;

            if (!VerifyHasPreset(player, presetManager, presetNameArg, out var preset))
                return;

            presetManager.UpdatePreset(SimplePreset.FromCar(car, preset.Name));
            ReplyToPlayer(player, "Command.UpdatePreset.Success", preset.Name);
        }

        private void SubCommand_LoadPreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresetLoad))
                return;

            var presetNameArg = args.Length == 0 ? DefaultPresetName : args[0];
            LoadPreset(player, GetPlayerConfig(player.Id), presetNameArg);
        }

        private void SubCommand_Common_LoadPreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresetLoad)
                || !VerifyPermissionAny(player, PermissionCommonPresets))
                return;

            if (args.Length == 0)
            {
                ReplyToPlayer(player, "Command.Common.LoadPreset.Error.Syntax");
                return;
            }

            var presetNameArg = args[0];
            LoadPreset(player, _commonPresets, presetNameArg);
        }

        private void LoadPreset(IPlayer player, SimplePresetManager presetManager, string presetNameArg)
        {
            var basePlayer = player.Object as BasePlayer;

            if (!VerifyHasCar(player, out var car)
                || !VerifyCarNotOccupied(player, car)
                || !VerifyOffCooldown(player, CooldownType.Load)
                || LoadMyCarPresetWasBlocked(basePlayer, car))
                return;

            if (!VerifyOnlyOneMatchingPreset(player, presetManager, presetNameArg, out var preset))
                return;

            var presetNumSockets = preset.NumSockets;
            if (presetNumSockets > GetPlayerMaxAllowedCarSockets(player.Id))
            {
                ReplyToPlayer(player, "Generic.Error.NoPermissionToPresetSocketCount", preset.Name, preset.NumSockets);
                return;
            }

            if (presetNumSockets != car.TotalSockets)
            {
                ReplyToPlayer(player, "Command.LoadPreset.Error.SocketCount", preset.Name, presetNumSockets, car.TotalSockets);
                return;
            }

            if (car.IsDead())
            {
                ReviveCar(car);
            }

            var wasEngineOn = car.IsOn();
            var enginePartsTier = GetPlayerEnginePartsTier(player.Id);
            var extractedEngineParts = ExtractEnginePartsAboveTierAndDeleteRest(car, enginePartsTier);
            UpdateCarModules(car, preset.ModuleIDs);
            _pluginData.StartCooldown(player.Id, CooldownType.Load);

            NextTick(() =>
            {
                var wereExtraParts = false;

                if (extractedEngineParts.Count > 0)
                {
                    var remainingEngineParts = AddEngineItemsAndReturnRemaining(car, extractedEngineParts);
                    if (remainingEngineParts.Count > 0)
                    {
                        wereExtraParts = true;
                        GiveItemsToPlayerOrDrop(basePlayer, remainingEngineParts);
                    }
                }

                FixCar(car, GetPlayerAllowedFuel(player.Id), enginePartsTier);

                // Restart the engine if it turned off during the brief moment it had no engine or no parts.
                if (wasEngineOn && !car.IsOn() && car.engineController.CanRunEngine())
                    car.engineController.FinishStartingEngine();

                MaybeFillTankerModules(car, GetPlayerAllowedFreshWater(player.Id));

                if (car.CarLock.HasALock && !car.CarLock.CanHaveALock())
                {
                    car.RemoveLock();
                }

                MaybePlayCarRepairEffects(car);

                var chatMessages = new List<string>() { GetMessage(player, "Command.LoadPreset.Success", preset.Name) };
                if (wereExtraParts)
                    chatMessages.Add(GetMessage(player, "Generic.Info.PartsRecovered"));

                player.Reply(string.Join(" ", chatMessages));
            });
        }

        private void SubCommand_RenamePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresets))
                return;

            if (args.Length < 2)
            {
                ReplyToPlayer(player, "Command.RenamePreset.Error.Syntax");
                return;
            }

            RenamePreset(player, GetPlayerConfig(player), args[0], args[1]);
        }

        private void SubCommand_Common_RenamePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionManageCommonPresets))
                return;

            if (args.Length < 2)
            {
                ReplyToPlayer(player, "Command.Common.RenamePreset.Error.Syntax");
                return;
            }

            RenamePreset(player, _commonPresets, args[0], args[1]);
        }

        private void RenamePreset(IPlayer player, SimplePresetManager presetManager, string oldName, string newName)
        {
            if (!VerifyHasPreset(player, presetManager, oldName, out var preset))
                return;

            // Cache actual old preset name since matching is case-insensitive.
            var actualOldPresetName = preset.Name;

            var existingPresetWithNewName = presetManager.FindPreset(newName);

            if (newName.Length > PresetMaxLength)
            {
                ReplyToPlayer(player, "Generic.Error.PresetNameLength", PresetMaxLength);
                return;
            }

            // Allow renaming if just changing case.
            if (existingPresetWithNewName != null && preset != existingPresetWithNewName)
            {
                ReplyToPlayer(player, "Generic.Error.PresetAlreadyTaken", existingPresetWithNewName.Name);
                return;
            }

            presetManager.RenamePreset(preset, newName);
            ReplyToPlayer(player, "Command.RenamePreset.Success", actualOldPresetName, newName);
        }

        private void SubCommand_DeletePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionPresets))
                return;

            var presetNameArg = args.Length == 0 ? DefaultPresetName : args[0];
            DeletePreset(player, GetPlayerConfig(player), presetNameArg);
        }

        private void SubCommand_Common_DeletePreset(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionManageCommonPresets))
                return;

            if (args.Length == 0)
            {
                ReplyToPlayer(player, "Command.Common.DeletePreset.Error.Syntax");
                return;
            }

            DeletePreset(player, _commonPresets, args[0]);
        }

        private void DeletePreset(IPlayer player, SimplePresetManager presetManager, string presetNameArg)
        {
            if (!VerifyHasPreset(player, presetManager, presetNameArg, out var preset))
                return;

            presetManager.DeletePreset(preset);
            ReplyToPlayer(player, "Command.DeletePreset.Success", preset.Name);
        }

        private void SubCommand_ToggleAutoCodeLock(IPlayer player, string[] args)
        {
            if (VehicleDeployedLocks == null
                || !VerifyPermissionAny(player, PermissionAutoCodeLock))
                return;

            var config = GetPlayerConfig(player);
            config.Settings.AutoCodeLock = !config.Settings.AutoCodeLock;
            config.SaveData();
            ReplyToPlayer(player, "Command.ToggleAutoCodeLock.Success", BooleanToLocalizedString(player, config.Settings.AutoCodeLock));
        }

        private void SubCommand_ToggleAutoKeyLock(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionAutoKeyLock))
                return;

            var config = GetPlayerConfig(player);
            config.Settings.AutoKeyLock = !config.Settings.AutoKeyLock;
            config.SaveData();
            ReplyToPlayer(player, "Command.ToggleAutoKeyLock.Success", BooleanToLocalizedString(player, config.Settings.AutoKeyLock));
        }

        private void SubCommand_ToggleAutoFillTankers(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, PermissionAutoFillTankers))
                return;

            var config = GetPlayerConfig(player);
            config.Settings.AutoFillTankers = !config.Settings.AutoFillTankers;
            config.SaveData();
            ReplyToPlayer(player, "Command.ToggleAutoFillTankers.Success", BooleanToLocalizedString(player, config.Settings.AutoFillTankers));
        }

        #endregion

        #region Dependencies

        private class MonumentAdapter
        {
            public string ShortName => (string)_monumentInfo["ShortName"];

            private Dictionary<string, object> _monumentInfo;

            public MonumentAdapter(Dictionary<string, object> monumentInfo)
            {
                _monumentInfo = monumentInfo;
            }

            public bool IsInBounds(Vector3 position) =>
                ((Func<Vector3, bool>)_monumentInfo["IsInBounds"]).Invoke(position);
        }

        private MonumentAdapter GetClosestMonument(Vector3 position)
        {
            return MonumentFinder?.Call("API_GetClosest", position) is Dictionary<string, object> dictResult
                ? new MonumentAdapter(dictResult)
                : null;
        }

        #endregion

        #region Helper Methods - Command Checks

        private static bool SpawnWasBlocked(BasePlayer player)
        {
            var hookResult = Interface.CallHook("CanSpawnModularCar", player);
            return hookResult is false;
        }

        private static bool SpawnMyCarWasBlocked(BasePlayer player)
        {
            if (SpawnWasBlocked(player))
                return true;

            var hookResult = Interface.CallHook("CanSpawnMyCar", player);
            return hookResult is false;
        }

        private static bool FetchMyCarWasBlocked(BasePlayer player, ModularCar car)
        {
            return Interface.CallHook("CanFetchMyCar", player, car) is false;
        }

        private static bool FixMyCarWasBlocked(BasePlayer player, ModularCar car)
        {
            return Interface.CallHook("CanFixMyCar", player, car) is false;
        }

        private static bool LoadMyCarPresetWasBlocked(BasePlayer player, ModularCar car)
        {
            return Interface.CallHook("CanLoadMyCarPreset", player, car) is false;
        }

        private static bool DestroyMyCarWasBlocked(BasePlayer player, ModularCar car)
        {
            return Interface.CallHook("CanDestroyMyCar", player, car) is false;
        }

        private static bool HasParent<T>(BasePlayer player) where T : BaseEntity
        {
            var parent = player.GetParentEntity();
            while (parent != null)
            {
                if (parent is T)
                    return true;

                parent = parent.GetParentEntity();
            }

            return false;
        }

        private bool IsMonumentAllowed(BasePlayer basePlayer)
        {
            if (!_pluginConfig.HasMonumentRestriction || MonumentFinder == null)
                return true;

            var position = basePlayer.transform.position;
            return GetClosestMonument(position) is not {} monument
                || !monument.IsInBounds(position)
                || _pluginConfig.IsMonumentAllowed(monument.ShortName);
        }

        private bool IsOnCargoShip(BasePlayer basePlayer)
        {
            return HasParent<CargoShip>(basePlayer);
        }

        private bool VerifyPermissionAny(IPlayer player, params string[] permissionNames)
        {
            foreach (var perm in permissionNames)
            {
                if (!permission.UserHasPermission(player.Id, perm))
                {
                    ReplyToPlayer(player, "Generic.Error.NoPermission");
                    return false;
                }
            }
            return true;
        }

        private bool VerifyLocationNotRestricted(IPlayer player)
        {
            var basePlayer = player.Object as BasePlayer;
            if (IsOnCargoShip(basePlayer) || !IsMonumentAllowed(basePlayer))
            {
                ReplyToPlayer(player, "Generic.Error.LocationRestricted");
                return false;
            }

            return true;
        }

        private bool VerifyNotBuildingBlocked(IPlayer player)
        {
            if ((player.Object as BasePlayer).IsBuildingBlocked())
            {
                ReplyToPlayer(player, "Generic.Error.BuildingBlocked");
                return false;
            }

            return true;
        }

        private bool VerifySufficientSpace(IPlayer player, int numSockets, out Vector3 determinedPosition, out Quaternion determinedRotation)
        {
            var basePlayer = player.Object as BasePlayer;

            if (!TryGetIdealCarPositionAndRotation(basePlayer, numSockets, out determinedPosition, out determinedRotation)
                || !HasSufficientSpace(basePlayer, numSockets, determinedPosition, determinedRotation))
            {
                ReplyToPlayer(player, "Generic.Error.InsufficientSpace");
                return false;
            }

            return true;
        }

        private bool VerifyHasPreset(IPlayer player, SimplePresetManager presetManager, string presetName, out SimplePreset preset)
        {
            preset = presetManager.FindPreset(presetName);
            if (preset == null)
            {
                ReplyToPlayer(player, "Generic.Error.PresetNotFound", presetName);
                return false;
            }

            return true;
        }

        private bool VerifyNoMatchingPreset(IPlayer player, SimplePresetManager presetManager, string presetName)
        {
            var existingPreset = presetManager.FindPreset(presetName);
            if (existingPreset != null)
            {
                ReplyToPlayer(player, "Command.SavePreset.Error.PresetAlreadyExists", existingPreset.Name);
                return false;
            }

            return true;
        }

        private bool VerifyHasCar(IPlayer player, out ModularCar car)
        {
            car = FindPlayerCar(player);
            if (car == null)
            {
                ReplyToPlayer(player, "Generic.Error.CarNotFound");
                return false;
            }

            return true;
        }

        private bool VerifyHasNoCar(IPlayer player)
        {
            if (FindPlayerCar(player) == null)
                return true;

            var messages = new List<string> { GetMessage(player, "Command.Spawn.Error.CarAlreadyExists") };
            if (permission.UserHasPermission(player.Id, PermissionFetch))
                messages.Add(GetMessage(player, "Command.Spawn.Error.CarAlreadyExists.Help"));

            player.Reply(string.Join(" ", messages));
            return false;
        }

        private bool VerifyCarNotOccupied(IPlayer player, ModularCar car)
        {
            // Players can either be mounted in seats, or standing on flatbed modules.
            if (car.AnyMounted()
                || car.AttachedModuleEntities.Any(module => module.children.Any(child => child is BasePlayer)))
            {
                ReplyToPlayer(player, "Generic.Error.CarOccupied");
                return false;
            }

            return true;
        }

        private bool VerifyOffCooldown(IPlayer player, CooldownType cooldownType)
        {
            var secondsRemaining = _pluginData.GetRemainingCooldownSeconds(player.Id, cooldownType);
            if (secondsRemaining > 0)
            {
                ReplyToPlayer(player, "Generic.Error.Cooldown", secondsRemaining);
                return false;
            }

            return true;
        }

        private bool VerifyOnlyOneMatchingPreset(IPlayer player, SimplePresetManager presetManager, string presetName, out SimplePreset preset)
        {
            preset = presetManager.FindPreset(presetName);
            if (preset != null)
                return true;

            var matchingPresets = presetManager.FindMatchingPresets(presetName);
            var matchCount = matchingPresets.Count;

            if (matchCount == 0)
            {
                ReplyToPlayer(player, "Generic.Error.PresetNotFound", presetName);
                return false;
            }

            if (matchCount > 1)
            {
                ReplyToPlayer(player, "Generic.Error.PresetMultipleMatches", presetName);
                return false;
            }

            preset = matchingPresets.First();
            return true;
        }

        #endregion

        #region Helper Methods - Cars

        private static int SortPresetNames(SimplePreset a, SimplePreset b) =>
            a.Name.ToLower() == DefaultPresetName ? -1 :
            b.Name.ToLower() == DefaultPresetName ? 1 :
            a.Name.CompareTo(b.Name);

        private static Vector3 GetCarExtents(int numSockets)
        {
            switch (numSockets)
            {
                case 2:
                    return ShortCarExtents;
                case 3:
                    return MediumCarExtents;
                default:
                    return LongCarExtents;
            }
        }

        private static void GetCarFrontBack(int numSockets, out Vector3 frontLeft, out Vector3 frontRight, out Vector3 backLeft, out Vector3 backRight)
        {
            switch (numSockets)
            {
                case 2:
                    frontLeft = ShortCarFrontLeft;
                    frontRight = ShortCarFrontRight;
                    backLeft = ShortCarBackLeft;
                    backRight = ShortCarBackRight;
                    return;
                case 3:
                    frontLeft = MediumCarFrontLeft;
                    frontRight = MediumCarFrontRight;
                    backLeft = MediumCarBackLeft;
                    backRight = MediumCarBackRight;
                    return;
                default:
                    frontLeft = LongCarFrontLeft;
                    frontRight = LongCarFrontRight;
                    backLeft = LongCarBackLeft;
                    backRight = LongCarBackRight;
                    return;
            }
        }

        private static int[] GetCarModuleIDs(ModularCar car)
        {
            var moduleIDs = new List<int>();

            for (var socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                if (car.TryGetModuleAt(socketIndex, out var module) && module.FirstSocketIndex == socketIndex)
                    moduleIDs.Add(module.AssociatedItemDef.itemid);
                else
                    // Use 0 to represent an empty socket.
                    moduleIDs.Add(0);
            }

            return moduleIDs.ToArray();
        }

        private static Vector3 GetPlayerForwardPosition(BasePlayer player)
        {
            var forward = player.GetNetworkRotation() * Vector3.forward;
            forward.y = 0;
            return forward.normalized;
        }

        // Directly in front of the player.
        private static Vector3 GetFixedCarPosition(BasePlayer player)
        {
            var forward = GetPlayerForwardPosition(player);
            var position = player.transform.position + forward * 3f;
            position.y = player.transform.position.y + 1f;
            return position;
        }

        // On surface in front of player.
        private static bool TryGetIdealCarPositionAndRotation(BasePlayer player, int numSockets, out Vector3 position, out Quaternion rotation)
        {
            var carMiddle = player.eyes.position + GetPlayerForwardPosition(player) * ForwardRaycastDistance;

            GetCarFrontBack(numSockets, out var carFrontLeft, out var carFrontRight, out var carBackLeft, out var carBackRight);

            var initialRotation = GetRelativeCarRotation(player);

            if (!Physics.Raycast(carMiddle + initialRotation * carFrontLeft, Vector3.down, out var frontLeftHit, DownwardRaycastDistance, RaycastLayers, QueryTriggerInteraction.Ignore)
                || !Physics.Raycast(carMiddle + initialRotation * carFrontRight, Vector3.down, out var frontRightHit, DownwardRaycastDistance, RaycastLayers, QueryTriggerInteraction.Ignore)
                || !Physics.Raycast(carMiddle + initialRotation * carBackLeft, Vector3.down, out var backLeftHit, DownwardRaycastDistance, RaycastLayers, QueryTriggerInteraction.Ignore)
                || !Physics.Raycast(carMiddle + initialRotation * carBackRight, Vector3.down, out var backRightHit, DownwardRaycastDistance, RaycastLayers, QueryTriggerInteraction.Ignore))
            {
                position = Vector3.zero;
                rotation = Quaternion.identity;
                return false;
            }

            // Rotate the car relative to the hit positions.
            rotation = Quaternion.LookRotation((frontLeftHit.point - backLeftHit.point), Vector3.up)
                * Quaternion.Euler(0, 0, (frontLeftHit.point - frontRightHit.point).y * 30);

            // Spawn in the midpoint between the front and back hits.
            position = Vector3.Lerp(frontLeftHit.point, backRightHit.point, 0.5f);

            return true;
        }

        private static void DetermineCarPositionAndRotation(BasePlayer player, int numSockets, out Vector3 position, out Quaternion rotation)
        {
            if (!TryGetIdealCarPositionAndRotation(player, numSockets, out position, out rotation))
            {
                position = GetFixedCarPosition(player);
                rotation = GetRelativeCarRotation(player);
            }
        }

        private static Quaternion GetRelativeCarRotation(BasePlayer player)
        {
            return Quaternion.Euler(0, player.GetNetworkRotation().eulerAngles.y - 90, 0);
        }

        private static void AddInitialModules(ModularCar car, int[] ModuleIDs)
        {
            for (var socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                var desiredItemID = ModuleIDs[socketIndex];

                // We are using 0 to represent an empty socket which we skip.
                if (desiredItemID != 0)
                {
                    var moduleItem = ItemManager.CreateByItemID(desiredItemID);
                    if (moduleItem != null)
                    {
                        car.TryAddModule(moduleItem, socketIndex);
                    }
                }
            }
        }

        private static void UpdateCarModules(ModularCar car, int[] moduleIDs)
        {
            // Phase 1: Remove all modules that don't match the desired preset.
            // This is done first since some modules take up two sockets.
            for (var socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                var desiredItemID = moduleIDs[socketIndex];
                var existingItem = car.Inventory.ModuleContainer.GetSlot(socketIndex);

                if (existingItem != null && existingItem.info.itemid != desiredItemID)
                {
                    existingItem.RemoveFromContainer();
                    existingItem.Remove();
                }
            }

            // Phase 2: Add the modules that are missing.
            for (var socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                var desiredItemID = moduleIDs[socketIndex];
                var existingItem = car.Inventory.ModuleContainer.GetSlot(socketIndex);

                // We are using 0 to represent an empty socket which we skip.
                if (existingItem == null && desiredItemID != 0)
                {
                    var moduleItem = ItemManager.CreateByItemID(desiredItemID);
                    if (moduleItem != null)
                    {
                        car.TryAddModule(moduleItem, socketIndex);
                    }
                }
            }
        }

        private static List<Item> AddEngineItemsAndReturnRemaining(ModularCar car, List<Item> engineItems)
        {
            var itemsByType = engineItems
                .GroupBy(item => item.info.GetComponent<ItemModEngineItem>().engineItemType)
                .ToDictionary(
                    grouping => grouping.Key,
                    grouping => grouping.OrderByDescending(item => item.info.GetComponent<ItemModEngineItem>().tier).ToList()
                );

            foreach (var module in car.AttachedModuleEntities)
            {
                var engineStorage = (module as VehicleModuleEngine)?.GetContainer() as EngineStorage;
                if (engineStorage == null)
                    continue;

                for (var slotIndex = 0; slotIndex < engineStorage.inventory.capacity; slotIndex++)
                {
                    var engineItemType = engineStorage.slotTypes[slotIndex];
                    if (!itemsByType.ContainsKey(engineItemType))
                        continue;

                    var itemsOfType = itemsByType[engineItemType];
                    var existingItem = engineStorage.inventory.GetSlot(slotIndex);
                    if (existingItem != null || itemsOfType.Count == 0)
                        continue;

                    itemsOfType[0].MoveToContainer(engineStorage.inventory, slotIndex, allowStack: false);
                    itemsOfType.RemoveAt(0);
                }
            }

            return itemsByType.Values.SelectMany(x => x).ToList();
        }

        private static void AddUpgradeOrRepairEngineParts(EngineStorage engineStorage, int desiredTier)
        {
            var inventory = engineStorage.inventory;
            if (inventory == null)
                return;

            // Ignore if the engine storage is locked, since it must be controlled by another plugin.
            if (inventory.IsLocked())
                return;

            for (var i = 0; i < inventory.capacity; i++)
            {
                var item = inventory.GetSlot(i);
                if (item != null)
                {
                    var component = item.info.GetComponent<ItemModEngineItem>();
                    if (component != null && component.tier < desiredTier)
                    {
                        item.RemoveFromContainer();
                        item.Remove();
                        TryAddEngineItem(engineStorage, i, desiredTier);
                    }
                    else
                    {
                        item.condition = item.maxCondition;
                    }
                }
                else if (desiredTier > 0)
                {
                    TryAddEngineItem(engineStorage, i, desiredTier);
                }
            }
        }

        private static bool TryAddEngineItem(EngineStorage engineStorage, int slot, int tier)
        {
            if (!engineStorage.allEngineItems.TryGetItem(tier, engineStorage.slotTypes[slot], out var output))
                return false;

            var component = output.GetComponent<ItemDefinition>();
            var item = ItemManager.Create(component);
            if (item == null)
                return false;

            item.condition = component.condition.max;
            item.MoveToContainer(engineStorage.inventory, slot, allowStack: false);

            return true;
        }

        private static List<Item> ExtractEnginePartsAboveTierAndDeleteRest(ModularCar car, int tier)
        {
            var extractedEngineParts = new List<Item>();

            foreach (var module in car.AttachedModuleEntities)
            {
                var engineStorage = (module as VehicleModuleEngine)?.GetContainer() as EngineStorage;
                if (engineStorage == null)
                    continue;

                var inventory = engineStorage.inventory;

                // Ignore if the engine storage is locked, since it must be controlled by another plugin.
                if (inventory.IsLocked())
                    continue;

                for (var i = 0; i < inventory.capacity; i++)
                {
                    var item = inventory.GetSlot(i);
                    if (item == null)
                        continue;

                    var component = item.info.GetComponent<ItemModEngineItem>();
                    if (component == null)
                        continue;

                    item.RemoveFromContainer();

                    if (component.tier > tier)
                        extractedEngineParts.Add(item);
                    else
                        item.Remove();
                }
            }

            return extractedEngineParts;
        }

        private static void GiveItemsToPlayerOrDrop(BasePlayer player, List<Item> itemList)
        {
            var itemsToDrop = new List<Item>();

            foreach (var item in itemList)
            {
                if (!player.inventory.GiveItem(item))
                {
                    itemsToDrop.Add(item);
                }
            }

            if (itemsToDrop.Count > 0)
            {
                DropEngineParts(player, itemsToDrop);
            }
        }

        private static void DropEngineParts(BasePlayer player, List<Item> itemList)
        {
            if (itemList.Count == 0)
                return;

            var position = player.GetDropPosition();
            if (itemList.Count == 1)
            {
                itemList[0].Drop(position, player.GetDropVelocity());
                return;
            }

            var container = GameManager.server.CreateEntity(ItemDropPrefab, position, player.GetNetworkRotation()) as DroppedItemContainer;
            if (container == null)
                return;

            container.playerName = $"{player.displayName}'s Engine Parts";

            // 4 large engines * 8 parts (each damaged) = 32 max engine parts.
            // This fits within the standard max size of 36.
            var capacity = Math.Min(itemList.Count, container.maxItemCount);

            container.inventory = new ItemContainer();
            container.inventory.ServerInitialize(null, capacity);
            container.inventory.GiveUID();
            container.inventory.entityOwner = container;
            container.inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);

            foreach (var item in itemList)
            {
                if (!item.MoveToContainer(container.inventory))
                {
                    item.DropAndTossUpwards(position);
                }
            }

            container.ResetRemovalTime();
            container.SetVelocity(player.GetDropVelocity());
            container.Spawn();
        }

        private static void FixCar(ModularCar car, int fuelAmount, int enginePartsTier)
        {
            car.SetHealth(car.MaxHealth());
            car.SendNetworkUpdate();
            AddOrRestoreFuel(car, fuelAmount);

            foreach (var module in car.AttachedModuleEntities)
            {
                module.SetHealth(module.MaxHealth());
                module.SendNetworkUpdate();

                var engineModule = module as VehicleModuleEngine;
                if (engineModule != null)
                {
                    var engineStorage = engineModule.GetContainer() as EngineStorage;
                    AddUpgradeOrRepairEngineParts(engineStorage, enginePartsTier);
                    engineModule.RefreshPerformanceStats(engineStorage);
                }
            }
        }

        private static void ReviveCar(ModularCar car)
        {
            car.lifestate = BaseCombatEntity.LifeState.Alive;
            car.repair.enabled = true;

            foreach (var module in car.AttachedModuleEntities)
            {
                module.repair.enabled = true;
            }
        }

        private static void AddOrRestoreFuel(ModularCar car, int specifiedFuelAmount)
        {
            if (car.GetFuelSystem() is not EntityFuelSystem fuelSystem)
                return;

            var fuelContainer = fuelSystem.GetFuelContainer();
            var targetFuelAmount = specifiedFuelAmount == -1 ? fuelContainer.allowedItem.stackable : specifiedFuelAmount;
            if (targetFuelAmount == 0)
                return;

            var fuelItem = fuelContainer.inventory.FindItemByItemID(fuelContainer.allowedItem.itemid);
            if (fuelItem == null)
            {
                fuelContainer.inventory.AddItem(fuelContainer.allowedItem, targetFuelAmount);
            }
            else if (fuelItem.amount < targetFuelAmount)
            {
                fuelItem.amount = targetFuelAmount;
                fuelItem.MarkDirty();
            }
        }

        private bool TryReleaseCarFromLift(ModularCar car)
        {
            if (!TryFindCarLift(car, out var lift))
                return false;

            // Disable the lift for a bit, to prevent it from grabbing the car back.
            lift.enabled = false;
            lift.ReleaseOccupant();
            lift.Invoke(() => lift.enabled = true, 0.5f);

            return true;
        }

        private bool TryFindCarLift(ModularCar car, out ModularCarGarage lift)
        {
            if (Physics.RaycastNonAlloc(car.transform.position, car.transform.right, _raycastBuffer, 2, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore) > 0)
            {
                lift = _raycastBuffer[0].GetEntity() as ModularCarGarage;
                if (lift != null && lift.carOccupant == car)
                    return true;
            }

            if (Physics.RaycastNonAlloc(car.transform.position, car.transform.right * -1, _raycastBuffer, 2, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore) > 0)
            {
                lift = _raycastBuffer[0].GetEntity() as ModularCarGarage;
                if (lift != null && lift.carOccupant == car)
                    return true;
            }

            lift = null;
            return false;
        }

        private static void DismountAllPlayersFromCar(ModularCar car)
        {
            // Dismount seated players.
            if (car.AnyMounted())
                car.DismountAllPlayers();

            // Dismount players standing on flatbed modules.
            foreach (var module in car.AttachedModuleEntities)
            {
                foreach (var child in module.children.ToList())
                {
                    if (child is BasePlayer player)
                    {
                        player.SetParent(null, worldPositionStays: true);
                    }
                }
            }
        }

        private static void MaybeFillTankerModules(ModularCar car, int specifiedLiquidAmount)
        {
            if (specifiedLiquidAmount == 0)
                return;

            foreach (var module in car.AttachedModuleEntities)
            {
                var liquidContainer = (module as VehicleModuleStorage)?.GetContainer() as LiquidContainer;
                if (liquidContainer == null)
                    continue;

                if (FillLiquidContainer(liquidContainer, specifiedLiquidAmount) && _pluginConfig.EnableEffects)
                {
                    Effect.server.Run(TankerFilledEffectPrefab, module.transform.position);
                }
            }
        }

        private static bool FillLiquidContainer(LiquidContainer liquidContainer, int specifiedAmount)
        {
            var targetAmount = specifiedAmount == -1 ? liquidContainer.maxStackSize : specifiedAmount;
            var defaultItem = liquidContainer.defaultLiquid;
            var existingItem = liquidContainer.GetLiquidItem();

            if (existingItem == null)
            {
                liquidContainer.inventory.AddItem(defaultItem, targetAmount);
                return true;
            }

            if (existingItem.info.itemid != defaultItem.itemid)
            {
                // Remove other liquid such as salt water.
                existingItem.RemoveFromContainer();
                existingItem.Remove();
                liquidContainer.inventory.AddItem(defaultItem, targetAmount);
                return true;
            }

            if (existingItem.amount >= targetAmount)
                // Nothing added in this case.
                return false;

            existingItem.amount = targetAmount;
            existingItem.MarkDirty();
            return true;
        }

        private static void MaybePlayCarRepairEffects(ModularCar car)
        {
            if (!_pluginConfig.EnableEffects)
                return;

            if (car.AttachedModuleEntities.Count > 0)
            {
                foreach (var module in car.AttachedModuleEntities)
                {
                    Effect.server.Run(RepairEffectPrefab, module.transform.position);
                }
            }
            else
            {
                Effect.server.Run(RepairEffectPrefab, car.transform.position);
            }
        }

        private static int Clamp(int x, int min, int max)
        {
            return Math.Min(max, Math.Max(min, x));
        }

        private bool IsPlayerCar(ModularCar car)
        {
            return _pluginData.PlayerCars.ContainsValue(car.net.ID.Value);
        }

        private ModularCar FindPlayerCar(IPlayer player)
        {
            if (!_pluginData.PlayerCars.ContainsKey(player.Id))
                return null;

            var car = BaseNetworkable.serverEntities.Find(new NetworkableId(_pluginData.PlayerCars[player.Id])) as ModularCar;

            // Just in case the car was removed and that somehow wasn't detected sooner.
            // This could happen if the data file somehow got out of sync for instance.
            if (car == null)
            {
                _pluginData.UnregisterCar(player.Id);
            }

            return car;
        }

        private bool HasSufficientSpace(BasePlayer player, int numSockets, Vector3 desiredPosition, Quaternion rotation)
        {
            var carExtents = GetCarExtents(numSockets);
            var carCenterPoint = desiredPosition + rotation * new Vector3(0, carExtents.y);

            // Need some extra height for the boxcast to allow spawning on a lift since lifts are construction.
            // Cars can't be spawned on sleepers.
            // Cars can still be spawned below ceiling lights.
            carCenterPoint.y += 0.3f;

            return Physics.BoxCastNonAlloc(carCenterPoint, carExtents, rotation * Vector3.forward, _raycastBuffer, rotation, 0.1f, BoxcastLayers, QueryTriggerInteraction.Ignore) == 0;
        }

        private int GetPlayerAllowedFreshWater(string userId)
        {
            return permission.UserHasPermission(userId, PermissionAutoFillTankers)
                   && GetPlayerConfig(userId).Settings.AutoFillTankers
                ? _pluginConfig.FreshWaterAmount
                : 0;
        }

        private int GetPlayerAllowedFuel(string userId)
        {
            return permission.UserHasPermission(userId, PermissionAutoFuel) ? _pluginConfig.FuelAmount : 0;
        }

        private int GetPlayerEnginePartsTier(string userId)
        {
            if (permission.UserHasPermission(userId, PermissionEnginePartsTier3))
                return 3;
            if (permission.UserHasPermission(userId, PermissionEnginePartsTier2))
                return 2;
            if (permission.UserHasPermission(userId, PermissionEnginePartsTier1))
                return 1;

            return 0;
        }

        private ushort GetPlayerMaxAllowedCarSockets(string userId)
        {
            if (permission.UserHasPermission(userId, PermissionSpawnSockets4))
                return 4;
            if (permission.UserHasPermission(userId, PermissionSpawnSockets3))
                return 3;
            if (permission.UserHasPermission(userId, PermissionSpawnSockets2))
                return 2;

            return 0;
        }

        private void SpawnRandomCarForPlayer(IPlayer player, int desiredSockets)
        {
            var basePlayer = player.Object as BasePlayer;
            if (!VerifySufficientSpace(player, desiredSockets, out var spawnPosition, out var rotation)
                || SpawnMyCarWasBlocked(basePlayer))
                return;

            var carOptions = new RandomCarOptions(player.Id, desiredSockets);
            var car = SpawnCar(carOptions, spawnPosition, rotation, basePlayer, shouldTrackCar: true);
            if (car == null)
                return;

            ReplyToPlayer(player, "Command.Spawn.Success");
        }

        private void SpawnPresetCarForPlayer(IPlayer player, SimplePreset preset)
        {
            if (preset.NumSockets > GetPlayerMaxAllowedCarSockets(player.Id))
            {
                ReplyToPlayer(player, "Generic.Error.NoPermissionToPresetSocketCount", preset.Name, preset.NumSockets);
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            if (!VerifySufficientSpace(player, preset.NumSockets, out var spawnPosition, out var rotation)
                || SpawnMyCarWasBlocked(basePlayer))
                return;

            var carOptions = new PresetCarOptions(player.Id, preset.ModuleIDs);
            var car = SpawnCar(carOptions, spawnPosition, rotation, basePlayer, shouldTrackCar: true);
            if (car == null)
                return;

            ReplyToPlayer(player, "Command.Spawn.Success.Preset", preset.Name);

            if (preset != null)
            {
                MaybePlayCarRepairEffects(car);
            }
        }

        private ModularCar SpawnCar(BaseCarOptions options, Vector3 position, Quaternion rotation, BasePlayer player = null, bool shouldTrackCar = false)
        {
            var numSockets = options.Length;

            string prefabName;
            if (numSockets == 4)
            {
                prefabName = PrefabSockets4;
            }
            else if (numSockets == 3)
            {
                prefabName = PrefabSockets3;
            }
            else if (numSockets == 2)
            {
                prefabName = PrefabSockets2;
            }
            else
            {
                return null;
            }

            var car = GameManager.server.CreateEntity(prefabName, position, rotation) as ModularCar;
            if (car == null)
                return null;

            var presetOptions = options as PresetCarOptions;
            if (presetOptions != null)
            {
                car.spawnSettings.useSpawnSettings = false;
            }

            if (player != null)
            {
                car.OwnerID = player.userID;
            }

            car.Spawn();

            if (presetOptions != null)
            {
                AddInitialModules(car, presetOptions.NormalizedModuleIDs);
            }

            if (shouldTrackCar && player != null)
            {
                _pluginData.StartCooldown(player.UserIDString, CooldownType.Spawn, save: false);
                _pluginData.RegisterCar(player.UserIDString, car);
            }

            // Force all modules to be processed and registered in AttachedModuleEntities.
            // This allows plugins to easily interact with the module entities such as to add engine parts.
            foreach (var entry in car.moduleAddActions.ToList())
            {
                entry.Key.CancelInvoke(entry.Value);
                entry.Value.Invoke();
            }

            FixCar(car, options.FuelAmount, options.EnginePartsTier);
            MaybeFillTankerModules(car, options.FreshWaterAmount);

            if (options.CodeLock && VehicleDeployedLocks != null)
            {
                VehicleDeployedLocks.Call("API_DeployCodeLock", car, player);
            }

            if (!options.CodeLock && options.KeyLock && VehicleDeployedLocks != null)
            {
                VehicleDeployedLocks.Call("API_DeployKeyLock", car, player);
            }

            return car;
        }

        private bool ShouldTryAddCodeLockForPlayer(string userId)
        {
            return permission.UserHasPermission(userId, PermissionAutoCodeLock)
                   && GetPlayerConfig(userId).Settings.AutoCodeLock;
        }

        private bool ShouldTryAddKeyLockForPlayer(string userId)
        {
            return permission.UserHasPermission(userId, PermissionAutoKeyLock)
                   && GetPlayerConfig(userId).Settings.AutoKeyLock;
        }

        private int[] ValidateModules(object[] moduleArray)
        {
            ItemManager.Initialize();

            var moduleIDList = new List<int>();

            foreach (var module in moduleArray)
            {
                ItemDefinition itemDef;

                if (module is int or long)
                {
                    var moduleInt = module is long l ? Convert.ToInt32(l) : (int)module;
                    if (moduleInt == 0)
                    {
                        moduleIDList.Add(0);
                        continue;
                    }
                    itemDef = ItemManager.FindItemDefinition(moduleInt);
                }
                else if (module is string s)
                {
                    if (int.TryParse(s, out var parsedItemId))
                    {
                        if (parsedItemId == 0)
                        {
                            moduleIDList.Add(0);
                            continue;
                        }
                        itemDef = ItemManager.FindItemDefinition(parsedItemId);
                    }
                    else
                        itemDef = ItemManager.FindItemDefinition(s);
                }
                else
                {
                    LogWarning("Unable to parse module id or name: '{0}'", module);
                    continue;
                }

                if (itemDef == null)
                {
                    LogWarning("No item definition found for: '{0}'", module);
                    continue;
                }

                var vehicleModule = itemDef.GetComponent<ItemModVehicleModule>();
                if (vehicleModule == null)
                {
                    LogWarning("No vehicle module found for item: '{0}'", module);
                    continue;
                }

                moduleIDList.Add(itemDef.itemid);

                // Normalize module IDs by adding 0s after the module if it takes multiple sockets.
                for (var i = 0; i < vehicleModule.SocketsTaken - 1; i++)
                {
                    moduleIDList.Add(0);
                }
            }

            return moduleIDList.ToArray();
        }

        #endregion

        #region Data Management

        private class PluginData : SimplePresetManager
        {
            [JsonProperty("playerCars")]
            public Dictionary<string, ulong> PlayerCars = new();

            [JsonProperty("Cooldowns")]
            public CooldownManager Cooldowns = new();

            public override List<SimplePreset> Presets { get; set; }
            public bool ShouldSerializePresets() => false;

            public static PluginData LoadData()
            {
                return Interface.Oxide.DataFileSystem.ReadObject<PluginData>(_pluginInstance.Name);
            }

            public override void SaveData()
            {
                Interface.Oxide.DataFileSystem.WriteObject(_pluginInstance.Name, this);
            }

            public void RegisterCar(string userId, ModularCar car)
            {
                PlayerCars.Add(userId, car.net.ID.Value);
                SaveData();
            }

            public void UnregisterCar(string userId)
            {
                PlayerCars.Remove(userId);
                SaveData();
            }

            public long GetRemainingCooldownSeconds(string userId, CooldownType cooldownType)
            {
                if (!Cooldowns.GetCooldownMap(cooldownType).TryGetValue(userId, out var cooldownStart))
                    return 0;

                var cooldownSeconds = _pluginConfig.Cooldowns.GetSeconds(cooldownType);
                return cooldownStart + cooldownSeconds - DateTimeOffset.UtcNow.ToUnixTimeSeconds();
            }

            public void StartCooldown(string userId, CooldownType cooldownType, bool save = true)
            {
                if (_pluginConfig.Cooldowns.GetSeconds(cooldownType) <= 0)
                    return;

                Cooldowns.GetCooldownMap(cooldownType)[userId] = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

                if (save)
                {
                    SaveData();
                }
            }
        }

        private class CommonPresets : SimplePresetManager
        {
            private static string Filename => $"{_pluginInstance.Name}_CommonPresets";

            public static CommonPresets LoadData(PluginData pluginData)
            {
                var data = Interface.Oxide.DataFileSystem.ReadObject<CommonPresets>(Filename);

                if (pluginData.Presets != null)
                {
                    if (data.Presets == null || data.Presets.Count == 0)
                    {
                        _pluginInstance.LogWarning($"Migrating common presets to separate data file: {Filename}.json.");
                        data.Presets = pluginData.Presets.ToList();
                        data.SaveData();
                    }
                    else
                    {
                        _pluginInstance.LogWarning($"Deleting common presets from main data file since they appear to have already been migrated to a separate data file: {Filename}.json.");
                    }
                    pluginData.Presets.Clear();
                    pluginData.SaveData();
                }

                return data;
            }

            public override void SaveData()
            {
                Interface.Oxide.DataFileSystem.WriteObject(Filename, this);
            }
        }

        private PlayerConfig GetPlayerConfig(IPlayer player)
        {
            return GetPlayerConfig(player.Id);
        }

        private PlayerConfig GetPlayerConfig(string userId)
        {
            if (_playerConfigsMap.ContainsKey(userId))
                return _playerConfigsMap[userId];

            var config = PlayerConfig.Get(Name, userId);
            _playerConfigsMap.Add(userId, config);
            return config;
        }

        private enum CooldownType { Spawn, Fetch, Load, Fix }

        private class CooldownManager
        {
            [JsonProperty("Spawn")]
            private Dictionary<string, long> Spawn = new();

            [JsonProperty("Fetch")]
            private Dictionary<string, long> Fetch = new();

            [JsonProperty("LoadPreset")]
            private Dictionary<string, long> LoadPreset = new();

            [JsonProperty("Fix")]
            private Dictionary<string, long> Fix = new();

            public Dictionary<string, long> GetCooldownMap(CooldownType cooldownType)
            {
                switch (cooldownType)
                {
                    case CooldownType.Spawn:
                        return Spawn;
                    case CooldownType.Fetch:
                        return Fetch;
                    case CooldownType.Load:
                        return LoadPreset;
                    case CooldownType.Fix:
                        return Fix;
                    default:
                        _pluginInstance.LogWarning($"Cooldown not implemented for {cooldownType}");
                        return null;
                }
            }

            public void ClearAll()
            {
                Spawn.Clear();
                Fetch.Clear();
                LoadPreset.Clear();
                Fix.Clear();
            }
        }

        private abstract class SimplePresetManager
        {
            public static Func<SimplePreset, bool> MatchPresetName(string presetName) =>
                preset => preset.Name.Equals(presetName, StringComparison.CurrentCultureIgnoreCase);

            [JsonProperty("Presets")]
            public virtual List<SimplePreset> Presets { get; set; } = new();

            public SimplePreset FindPreset(string presetName)
            {
                return Presets.FirstOrDefault(MatchPresetName(presetName));
            }

            public List<SimplePreset> FindMatchingPresets(string presetName)
            {
                return Presets.Where(preset =>
                    preset.Name.IndexOf(presetName, StringComparison.CurrentCultureIgnoreCase) >= 0).ToList();
            }

            public void SavePreset(SimplePreset newPreset)
            {
                Presets.Add(newPreset);
                SaveData();
            }

            public void UpdatePreset(SimplePreset newPreset)
            {
                var presetIndex = Presets.FindIndex(new Predicate<SimplePreset>(MatchPresetName(newPreset.Name)));
                if (presetIndex == -1)
                    return;

                Presets[presetIndex] = newPreset;
                SaveData();
            }

            public void RenamePreset(SimplePreset preset, string newName)
            {
                preset.Name = newName;
                SaveData();
            }

            public void DeletePreset(SimplePreset preset)
            {
                Presets.Remove(preset);
                SaveData();
            }

            public abstract void SaveData();
        }

        private class PlayerConfig : SimplePresetManager
        {
            public static PlayerConfig Get(string dirPath, string ownerID)
            {
                var filepath = $"{dirPath}/{ownerID}";

                var config = Interface.Oxide.DataFileSystem.ExistsDatafile(filepath) ?
                    Interface.Oxide.DataFileSystem.ReadObject<PlayerConfig>(filepath) :
                    new PlayerConfig(ownerID);

                config.Filepath = filepath;
                return config;
            }

            [JsonIgnore]
            private string Filepath;

            [JsonProperty("OwnerID")]
            public string OwnerID { get; }

            [JsonProperty("Settings")]
            public PlayerSettings Settings = new();

            public PlayerConfig(string ownerID)
            {
                OwnerID = ownerID;
            }

            public override void SaveData()
            {
                Interface.Oxide.DataFileSystem.WriteObject(Filepath, this);
            }
        }

        private class SimplePreset
        {
            public static SimplePreset FromCar(ModularCar car, string presetName)
            {
                return new SimplePreset
                {
                    Name = presetName,
                    ModuleIDs = GetCarModuleIDs(car)
                };
            }

            [JsonProperty("Name")]
            public string Name;

            [JsonProperty("ModuleIDs")]
            public int[] ModuleIDs;

            [JsonIgnore]
            public int NumSockets => ModuleIDs.Length;
        }

        private class PlayerSettings
        {
            [JsonProperty("AutoCodeLock")]
            public bool AutoCodeLock;

            [JsonProperty("AutoKeyLock")]
            public bool AutoKeyLock;

            [JsonProperty("AutoFillTankers")]
            public bool AutoFillTankers;
        }

        #endregion

        #region Configuration

        private void MigrateConfig()
        {
            if (_pluginConfig.ValidateServerPresets())
            {
                LogWarning("Performing automatic config migration.");
                SaveConfig();
            }
        }

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("CanSpawnWhileBuildingBlocked")]
            public bool CanSpawnBuildingBlocked = false;

            [JsonProperty("CanFetchWhileBuildingBlocked")]
            public bool CanFetchBuildingBlocked = false;

            [JsonProperty("CanFetchWhileOccupied")]
            public bool CanFetchOccupied = false;

            [JsonProperty("CanDespawnWhileOccupied")]
            public bool CanDespawnOccupied = false;

            [JsonProperty("DismountPlayersOnFetch")]
            public bool DismountPlayersOnFetch = true;

            [JsonProperty("FuelAmount")]
            public int FuelAmount = 500;

            [JsonProperty("FreshWaterAmount")]
            public int FreshWaterAmount = -1;

            [JsonProperty("MaxPresetsPerPlayer")]
            public int MaxPresetsPerPlayer = 10;

            [JsonProperty("EnableEffects")]
            public bool EnableEffects = true;

            [JsonProperty("DisallowedMonuments")]
            private string[] DisallowedMonuments = Array.Empty<string>();

            [JsonProperty("Cooldowns")]
            public CooldownConfig Cooldowns = new();

            [JsonProperty("Presets")]
            public ServerPreset[] Presets = Array.Empty<ServerPreset>();

            [JsonIgnore]
            public bool HasMonumentRestriction => DisallowedMonuments?.Length > 0;

            public ServerPreset FindPreset(string name)
            {
                var nameLower = name.ToLower();

                foreach (var preset in Presets)
                {
                    if (preset.Name.ToLower() == nameLower)
                    {
                        return preset;
                    }
                }

                return null;
            }

            public bool ValidateServerPresets()
            {
                var changed = false;

                foreach (var preset in Presets)
                {
                    if (preset.Options.ValidateModules())
                        changed = true;
                }

                return changed;
            }

            public bool IsMonumentAllowed(string monumentName)
            {
                if (DisallowedMonuments.Length == 0)
                    return true;

                foreach (var disallowedMonumentName in DisallowedMonuments)
                {
                    if (monumentName.IndexOf(disallowedMonumentName, StringComparison.OrdinalIgnoreCase) >= 0)
                        return false;
                }

                return true;
            }
        }

        private class ServerPreset
        {
            [JsonProperty("Name")]
            public string Name;

            [JsonProperty("Options")]
            public ServerPresetOptions Options;
        }

        private abstract class BaseCarOptions
        {
            private int _enginePartsTier;

            [JsonProperty("CodeLock", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool CodeLock;

            [JsonProperty("EnginePartsTier", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int EnginePartsTier
            {
                get => _enginePartsTier;
                set => _enginePartsTier = Clamp(value, 0, 3);
            }

            [JsonProperty("FreshWaterAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int FreshWaterAmount;

            [JsonProperty("FuelAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int FuelAmount;

            [JsonProperty("KeyLock", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool KeyLock;

            [JsonIgnore]
            public abstract int Length { get; }

            public BaseCarOptions() { }

            public BaseCarOptions(string userId)
            {
                CodeLock = _pluginInstance.ShouldTryAddCodeLockForPlayer(userId);
                KeyLock = _pluginInstance.ShouldTryAddKeyLockForPlayer(userId);
                EnginePartsTier = _pluginInstance.GetPlayerEnginePartsTier(userId);
                FuelAmount = _pluginInstance.GetPlayerAllowedFuel(userId);
                FreshWaterAmount = _pluginInstance.GetPlayerAllowedFreshWater(userId);
            }
        }

        private class PresetCarOptions : BaseCarOptions
        {
            [JsonProperty("ModuleIDs")]
            public virtual int[] NormalizedModuleIDs { get; set; } = Array.Empty<int>();

            [JsonIgnore]
            public override int Length => NormalizedModuleIDs?.Length ?? 0;

            // Empty constructor needed for deserialization.
            public PresetCarOptions() { }

            public PresetCarOptions(string userId, int[] moduleIDs) : base(userId)
            {
                NormalizedModuleIDs = moduleIDs;
            }
        }

        private class RandomCarOptions : BaseCarOptions
        {
            public int NumSockets;

            public override int Length => NumSockets;

            public RandomCarOptions(string userId, int numSockets) : base(userId)
            {
                NumSockets = numSockets;
            }
        }

        private class ServerPresetOptions : PresetCarOptions
        {
            // Override so we can avoid serializing it.
            public override int[] NormalizedModuleIDs { get; set; }

            // Hidden from config.
            public bool ShouldSerializeNormalizedModuleIDs() => false;

            [JsonProperty("Modules")]
            public object[] Modules;

            // Return value indicates whether the config was changed.
            public bool ValidateModules()
            {
                // Give precedence to "Modules".
                if (Modules != null)
                {
                    NormalizedModuleIDs = _pluginInstance.ValidateModules(Modules);
                }
                else if (NormalizedModuleIDs != null)
                {
                    // Resave the config with the field renamed to Modules.
                    // Must do this before normalizing so that no extra 0's are added.
                    Modules = NormalizedModuleIDs.Cast<object>().ToArray();
                    NormalizedModuleIDs = NormalizeModuleIDs(NormalizedModuleIDs);
                    return true;
                }

                return false;
            }

            private int[] NormalizeModuleIDs(int[] moduleIDs)
            {
                ItemManager.Initialize();

                var moduleIDList = moduleIDs.ToList();

                for (var i = 0; i < moduleIDList.Count; i++)
                {
                    if (moduleIDList[i] != 0)
                    {
                        // Add a 0 after each module that takes 2 sockets.
                        // This is more user-friendly than requiring people to add the 0s themselves.
                        var itemDefinition = ItemManager.FindItemDefinition(moduleIDList[i]);
                        var socketsTaken = itemDefinition.GetComponent<ItemModVehicleModule>()?.SocketsTaken ?? 1;
                        if (socketsTaken == 2)
                            moduleIDList.Insert(i + 1, 0);
                    }
                }

                return moduleIDList.ToArray();
            }
        }

        private class CooldownConfig
        {
            [JsonProperty("SpawnCarSeconds")]
            public long SpawnSeconds = 3600;

            [JsonProperty("FetchCarSeconds")]
            public long FetchSeconds = 600;

            [JsonProperty("LoadPresetSeconds")]
            public long LoadPresetSeconds = 3600;

            [JsonProperty("FixCarSeconds")]
            public long FixSeconds = 3600;

            public long GetSeconds(CooldownType cooldownType)
            {
                switch (cooldownType)
                {
                    case CooldownType.Spawn:
                        return SpawnSeconds;
                    case CooldownType.Fetch:
                        return FetchSeconds;
                    case CooldownType.Load:
                        return LoadPresetSeconds;
                    case CooldownType.Fix:
                        return FixSeconds;
                    default:
                        _pluginInstance.LogWarning($"Cooldown not implemented for {cooldownType}");
                        return 0;
                }
            }
        }

        private Configuration GetDefaultConfig() => new();

        #endregion

        #region Configuration Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion

        #region Localization

        private string BooleanToLocalizedString(IPlayer player, bool value)
        {
            return value ? GetMessage(player, "Generic.Setting.On") : GetMessage(player, "Generic.Setting.Off");
        }

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args)
        {
            player.Reply(string.Format(GetMessage(player, messageName), args));
        }

        private void ChatMessage(BasePlayer player, string messageName, params object[] args)
        {
            player.ChatMessage(string.Format(GetMessage(player.IPlayer, messageName), args));
        }

        private string GetMessage(IPlayer player, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, player.Id);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Generic.Setting.On"] = "<color=yellow>ON</color>",
                ["Generic.Setting.Off"] = "<color=#bbb>OFF</color>",

                ["Generic.Error.NoPermission"] = "You don't have permission to use this command.",
                ["Generic.Error.LocationRestricted"] = "Error: Cannot do that here.",
                ["Generic.Error.BuildingBlocked"] = "Error: Cannot do that while building blocked.",
                ["Generic.Error.NoPresets"] = "You don't have any saved presets.",
                ["Generic.Error.NoCommonPresets"] = "There are no common presets.",
                ["Generic.Error.CarNotFound"] = "Error: You need a car to do that.",
                ["Generic.Error.CarOccupied"] = "Error: Cannot do that while your car is occupied.",
                ["Generic.Error.Cooldown"] = "Please wait <color=yellow>{0}s</color> and try again.",
                ["Generic.Error.NoPermissionToPresetSocketCount"] = "Error: You don't have permission to use preset <color=yellow>{0}</color> because it requires <color=yellow>{1}</color> sockets.",
                ["Generic.Error.PresetNotFound"] = "Error: Preset <color=yellow>{0}</color> not found.",
                ["Generic.Error.PresetMultipleMatches"] = "Error: Multiple presets found matching <color=yellow>{0}</color>. Use <color=yellow>mycar list</color> to view your presets.",
                ["Generic.Error.PresetAlreadyTaken"] = "Error: Preset <color=yellow>{0}</color> is already taken.",
                ["Generic.Error.PresetNameLength"] = "Error: Preset name may not be longer than {0} characters.",
                ["Generic.Error.InsufficientSpace"] = "Error: Not enough space.",

                ["Generic.Info.CarDestroyed"] = "Your modular car was destroyed.",
                ["Generic.Info.PartsRecovered"] = "Recovered engine components were added to your inventory or dropped in front of you.",

                ["Command.Spawn.Error.SocketSyntax"] = "Syntax: <color=yellow>mycar <2|3|4></color>",
                ["Command.Spawn.Error.CarAlreadyExists"] = "Error: You already have a car.",
                ["Command.Spawn.Error.CarAlreadyExists.Help"] = "Try <color=yellow>mycar fetch</color> or <color=yellow>mycar help</color>.",
                ["Command.Spawn.Success"] = "Here is your modular car.",
                ["Command.Spawn.Success.Preset"] = "Here is your modular car from preset <color=yellow>{0}</color>.",

                ["Command.Fix.Success"] = "Your car was fixed.",
                ["Command.Fetch.Error.StuckOnLift"] = "Error: Unable to fetch your car from its lift.",
                ["Command.Fetch.Error.StuckOnLift.Help"] = "You can use <color=yellow>mycar destroy</color> to destroy it.",
                ["Command.Fetch.Success"] = "Here is your modular car.",

                ["Command.SavePreset.Error.TooManyPresets"] = "Error: You may not have more than <color=yellow>{0}</color> presets. You may delete another preset and try again. See <color=yellow>mycar help</color>.",
                ["Command.SavePreset.Error.PresetAlreadyExists"] = "Error: Preset <color=yellow>{0}</color> already exists. Use <color=yellow>mycar update {0}</color> to update it.",
                ["Command.SavePreset.Success"] = "Saved car as <color=yellow>{0}</color> preset.",
                ["Command.UpdatePreset.Success"] = "Updated <color=yellow>{0}</color> preset with current module configuration.",
                ["Command.LoadPreset.Error.SocketCount"] = "Error: Unable to load <color=yellow>{0}</color> preset (<color=yellow>{1}</color> sockets) because your car has <color=yellow>{2}</color> sockets.",
                ["Command.LoadPreset.Success"] = "Loaded <color=yellow>{0}</color> preset onto your car.",
                ["Command.DeletePreset.Success"] = "Deleted <color=yellow>{0}</color> preset.",
                ["Command.RenamePreset.Error.Syntax"] = "Syntax: <color=yellow>mycar rename <name> <new_name></color>",
                ["Command.RenamePreset.Success"] = "Renamed <color=yellow>{0}</color> preset to <color=yellow>{1}</color>",
                ["Command.List"] = "Your saved modular car presets:",
                ["Command.List.Item"] = "<color=yellow>{0}</color> ({1} sockets)",

                ["Command.Common.List"] = "Common modular car presets:",
                ["Command.Common.Error.Syntax"] = "Try <color=yellow>mycar help</color>",
                ["Command.Common.LoadPreset.Error.Syntax"] = "Syntax: <color=yellow>mycar common load <name></color>",
                ["Command.Common.SavePreset.Error.Syntax"] = "Syntax: <color=yellow>mycar common save <name></color>",
                ["Command.Common.SavePreset.Error.PresetAlreadyExists"] = "Error: Common preset <color=yellow>{0}</color> already exists. Use <color=yellow>mycar common update {0}</color> to update it.",
                ["Command.Common.UpdatePreset.Error.Syntax"] = "Syntax: <color=yellow>mycar common update <name></color>",
                ["Command.Common.RenamePreset.Error.Syntax"] = "Syntax: <color=yellow>mycar common rename <name> <new_name></color>",
                ["Command.Common.DeletePreset.Error.Syntax"] = "Syntax: <color=yellow>mycar common delete <name></color>",

                ["Command.ToggleAutoCodeLock.Success"] = "<color=yellow>AutoCodeLock</color> set to {0}",
                ["Command.ToggleAutoKeyLock.Success"] = "<color=yellow>AutoKeyLock</color> set to {0}",
                ["Command.ToggleAutoFillTankers.Success"] = "<color=yellow>AutoFillTankers</color> set to {0}",

                ["Command.Give.Error.Syntax"] = "Syntax: <color=yellow>givecar <player> <preset></color>",
                ["Command.Give.Error.PlayerNotFound"] = "Error: Player <color=yellow>{0}</color> not found.",
                ["Command.Give.Error.PresetTooFewModules"] = "Error: Preset <color=yellow>{0}</color> has too few modules ({1}).",
                ["Command.Give.Error.PresetTooManyModules"] = "Error: Preset <color=yellow>{0}</color> has too many modules ({1}).",
                ["Command.Give.Success"] = "Modular car given to <color=yellow>{0}</color> from preset <color=yellow>{1}</color>.",

                ["Command.Help"] = "<color=orange>SpawnModularCar Command Usages</color>",
                ["Command.Help.Spawn.Basic"] = "<color=yellow>mycar</color> - Spawn a random car with max allowed sockets",
                ["Command.Help.Spawn.Basic.PresetsAllowed"] = "<color=yellow>mycar</color> - Spawn a car using your <color=yellow>default</color> preset if saved, else spawn a random car with max allowed sockets",
                ["Command.Help.Spawn.Sockets"] = "<color=yellow>mycar <2|3|4></color> - Spawn a random car of desired length",
                ["Command.Help.Fetch"] = "<color=yellow>mycar fetch</color> - Fetch your car",
                ["Command.Help.Fix"] = "<color=yellow>mycar fix</color> - Fix your car",
                ["Command.Help.Destroy"] = "<color=yellow>mycar destroy</color> - Destroy your car",

                ["Command.Help.Section.PersonalPresets"] = "<color=orange>--- Personal presets ---</color>",
                ["Command.Help.ListPresets"] = "<color=yellow>mycar list</color> - List your saved presets",
                ["Command.Help.Spawn.Preset"] = "<color=yellow>mycar <name></color> - Spawn a car from a saved preset",
                ["Command.Help.LoadPreset"] = "<color=yellow>mycar load <name></color> - Load a preset onto your car",
                ["Command.Help.SavePreset"] = "<color=yellow>mycar save <name></color> - Save your car as a preset",
                ["Command.Help.UpdatePreset"] = "<color=yellow>mycar update <name></color> - Overwrite a preset",
                ["Command.Help.RenamePreset"] = "<color=yellow>mycar rename <name> <new_name></color> - Rename a preset",
                ["Command.Help.DeletePreset"] = "<color=yellow>mycar delete <name></color> - Delete a preset",

                ["Command.Help.Section.CommonPresets"] = "<color=orange>--- Common presets ---</color>",
                ["Command.Help.Common.ListPresets"] = "<color=yellow>mycar common list</color> - List common presets",
                ["Command.Help.Common.Spawn"] = "<color=yellow>mycar common <name></color> - Spawn a car from a common preset",
                ["Command.Help.Common.LoadPreset"] = "<color=yellow>mycar common load <name></color> - Load a common preset onto your car",
                ["Command.Help.Common.SavePreset"] = "<color=yellow>mycar common save <name></color> - Save your car as a common preset",
                ["Command.Help.Common.UpdatePreset"] = "<color=yellow>mycar common update <name></color> - Overwrite a common preset",
                ["Command.Help.Common.RenamePreset"] = "<color=yellow>mycar common rename <name> <new_name></color> - Rename a common preset",
                ["Command.Help.Common.DeletePreset"] = "<color=yellow>mycar common delete <name></color> - Delete a common preset",

                ["Command.Help.Section.PersonalSettings"] = "<color=orange>--- Personal settings ---</color>",
                ["Command.Help.ToggleAutoCodeLock"] = "<color=yellow>mycar autocodelock</color> - Toggle AutoCodeLock: {0}",
                ["Command.Help.ToggleAutoKeyLock"] = "<color=yellow>mycar autokeylock</color> - Toggle AutoKeyLock: {0}",
                ["Command.Help.ToggleAutoFillTankers"] = "<color=yellow>mycar autofilltankers</color> - Toggle automatic filling of tankers with fresh water: {0}",

                ["Command.Help.Section.OtherCommands"] = "<color=orange>--- Other commands ---</color>",
                ["Command.Help.Give"] = "<color=yellow>givecar <player> <preset></color> - Spawn a car for the target player from the specified server preset",
            }, this);
        }

        #endregion
    }
}


// --- End of file: SpawnModularCar.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/smart-chat-bot ---
// --- Original File Path: S/SmartChatBot/SmartChatBot.cs ---

using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;
using Random = System.Random;
using Time = Oxide.Core.Libraries.Time;

namespace Oxide.Plugins
{
    [Info("Smart Chat Bot", "Iv Misticos", "2.0.13")]
    [Description("I send chat messages based on some triggers or time.")]
    class SmartChatBot : RustPlugin
    {
        #region Variables

        [PluginReference]
        // ReSharper disable once InconsistentNaming
        private Plugin PlaceholderAPI = null;

        private static readonly Random Random = new Random();
        private readonly Dictionary<BasePlayer, uint> _lastSent = new Dictionary<BasePlayer, uint>();
        private uint _lastSentGlobal;

        private static readonly Time Time = GetLibrary<Time>();

        private const string CountryRequest = "http://ip-api.com/json/{ip}?fields=country,countryCode,status";
        
        #endregion
        
        #region Configuration

        private Configuration _config = new Configuration();

        private class Configuration
        {
            [JsonProperty(PropertyName = "Chat Prefix")]
            public string Prefix = "<color=#787FFF>Bot </color>";

            [JsonProperty(PropertyName = "Show Chat Prefix")]
            public bool ShowPrefix = true;

            [JsonProperty(PropertyName = "Bot Icon (SteamID)")]
            public ulong ChatSteamId = 0;

            [JsonProperty(PropertyName = "Cooldown Between Auto Responses For User")]
            public string Cooldown = "10s";

            [JsonProperty(PropertyName = "Global Cooldown Between Auto Responses")]
            public string CooldownGlobal = "2s";

            [JsonProperty(PropertyName = "Use Default Chat (0), Chat Plus (1), Better Chat (2)")]
            public ushort ChatSystem = 0;

            [JsonIgnore] public uint ParsedCooldown;
            [JsonIgnore] public uint ParsedCooldownGlobal;

            [JsonProperty(PropertyName = "Debug")]
            public bool Debug = false;

            [JsonProperty(PropertyName = "Allow Multiple Auto Responses")]
            public bool MultipleAutoResponses = false;

            [JsonProperty(PropertyName = "Minimal Time Between Message And Answer")]
            public float MinTime = 1.0f;

            [JsonProperty(PropertyName = "Maximal Time Between Message And Answer")]
            public float MaxTime = 3.0f;

            [JsonProperty(PropertyName = "Welcome Message", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> WelcomeMessage = new List<string> { "Welcome, {name}!", "Hello, dear {name}!", "Hello, {name}! Your IP: { ip }" };

            [JsonProperty(PropertyName = "Welcome Message Enabled")]
            public bool WelcomeMessageEnabled = false;

            [JsonProperty(PropertyName = "Joining Message", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> JoiningMessage = new List<string> { "Welcome, {name} ({id}, { ip })!", "Hello, dear {name} ({id}, { ip })!", "{name} came from {country} ({countrycode})" };

            [JsonProperty(PropertyName = "Leaving Message", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> LeavingMessage = new List<string> { "Bye, {name} ({id}, { ip })!\nReason: {reason}", "{name} ({id}, { ip }) left the game. Reason: {reason}", "{name} from {country} ({countrycode}) just left the game!" };

            [JsonProperty(PropertyName = "Joining Message Enabled")]
            public bool JoiningMessageEnabled = false;

            [JsonProperty(PropertyName = "Leaving Message Enabled")]
            public bool LeavingMessageEnabled = false;

            [JsonProperty(PropertyName = "Show Joining Message To Player That Joined")]
            public bool JoiningMessageSelfEnabled = false;

            [JsonProperty(PropertyName = "Show Leaving Message To Player That Left")]
            public bool LeavingMessageSelfEnabled = false;
            
            [JsonProperty(PropertyName = "Auto Messages", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<AutoMessageGroup> AutoMessages = new List<AutoMessageGroup> { new AutoMessageGroup() };
            
            [JsonProperty(PropertyName = "Auto Responses", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<AutoResponseGroup> AutoResponses = new List<AutoResponseGroup> { new AutoResponseGroup() };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class AutoMessageGroup
        {
            [JsonProperty(PropertyName = "Permission")]
            public string Permission = "smartchatbot.messages";
            
            [JsonProperty(PropertyName = "Message Frequency")]
            public string Frequency = "5m";

            [JsonIgnore] public uint ParsedFrequency;
            [JsonIgnore] public short ActiveMessage;

            [JsonProperty(PropertyName = "Auto Messages", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<AutoMessage> AutoMessages = new List<AutoMessage> { new AutoMessage() };
        }

        private class AutoMessage
        {
            [JsonProperty(PropertyName = "Is Enabled")]
            public bool Enabled = true;

            [JsonProperty(PropertyName = "Message")]
            public string Message = "Do not mind, I am just a stupid bot.";
        }

        private class AutoResponseGroup
        {
            [JsonProperty(PropertyName = "Permission")]
            public string Permission = "smartchatbot.response";
            
            [JsonProperty(PropertyName = "Auto Responses", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<AutoResponse> AutoResponses = new List<AutoResponse> { new AutoResponse() };
        }

        private class AutoResponse
        {
            [JsonProperty(PropertyName = "Is Enabled")]
            public bool Enabled = true;
            
            [JsonProperty(PropertyName = "Remove Message From Sender")]
            public bool RemoveMessage = false;
            
            [JsonProperty(PropertyName = "Send Response For Everyone (true) or Only For Sender (false)")]
            public bool SendPublic = true;
            
            [JsonProperty(PropertyName = "Triggers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<AutoResponseTrigger> Triggers = new List<AutoResponseTrigger> { new AutoResponseTrigger() };

            [JsonProperty(PropertyName = "Answers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Answers = new List<string> { "This bot really works.", "IT WORKS OMG!" };

            public bool IsValid() => Triggers.Count > 0 && Answers.Count > 0;
        }

        private class AutoResponseTrigger
        {
            [JsonProperty(PropertyName = "Percentage Of Contained Words")]
            public float ContainedWordsPercentage = 0.75f;

            [JsonProperty(PropertyName = "Regex Enabled")]
            public bool Regex = false;
            
            [JsonProperty(PropertyName = "Words", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Words = new List<string> { "How", "this", "bot", "works" };
        }
        
        #endregion
        
        #region Hooks

        private void OnServerInitialized()
        {
            LoadConfig();
            Unsubscribe(nameof(OnChatPlusMessage));
            Unsubscribe(nameof(OnBetterChat));
            Unsubscribe(nameof(OnPlayerChat));

            if (_config.ChatSystem == 0)
                Subscribe(nameof(OnPlayerChat));
            else if (_config.ChatSystem == 1)
                Subscribe(nameof(OnChatPlusMessage));
            else if (_config.ChatSystem == 2)
                Subscribe(nameof(OnBetterChat));

            var pl = plugins.GetAll();
            var plCount = pl.Length;
            for (var i = 0; i < plCount; i++)
            {
                var p = pl[i];
                // ReSharper disable once ConvertIfStatementToSwitchStatement
                if (p.Name == "BetterChat" || p.Name == "Better Chat")
                    PrintWarning("Detected Better Chat. Make sure you enabled it in your configuration.");
                else if (p.Name == "ChatPlus" || p.Name == "Chat Plus")
                    PrintWarning("Detected Chat Plus. Make sure you enabled it in your configuration.");
            }

            if (!ConvertToSeconds(_config.Cooldown, out _config.ParsedCooldown))
            {
                PrintError($"Unable to convert \"{_config.Cooldown}\" to seconds!");
                _config.ParsedCooldown = 0;
            }

            if (!ConvertToSeconds(_config.CooldownGlobal, out _config.ParsedCooldownGlobal))
            {
                PrintError($"Unable to convert \"{_config.CooldownGlobal}\" to seconds!");
                _config.ParsedCooldownGlobal = 0;
            }

            var messageGroupsCount = _config.AutoMessages.Count;
            for (var i = 0; i < messageGroupsCount; i++)
            {
                var messageGroup = _config.AutoMessages[i];
                PrintDebug($"Handling Message Group (ID: {i})");
                
                // Time Handling
                if (!ConvertToSeconds(messageGroup.Frequency, out messageGroup.ParsedFrequency))
                {
                    PrintError($"Unable to convert \"{messageGroup.Frequency}\" to seconds!");
                    messageGroup.ParsedFrequency = 60;
                }
                
                // Permissions
                permission.RegisterPermission(messageGroup.Permission, this);
                
                // Timers
                timer.Every(messageGroup.ParsedFrequency, () => HandleBroadcast(messageGroup));
            }

            var responseGroupsCount = _config.AutoResponses.Count;
            for (var i = 0; i < responseGroupsCount; i++)
            {
                PrintDebug($"Handling Response Group (ID: {i})");
                var responseGroup = _config.AutoResponses[i];
                
                // Permissions
                permission.RegisterPermission(responseGroup.Permission, this);
            }
        }
 
        // ReSharper disable once SuggestBaseTypeForParameter
        private object OnChatPlusMessage(Dictionary<string, object> data)
        {
            PrintDebug("Called OnChatPlusMessage");
            object playerObj, messageObj;
            if (!data.TryGetValue("Player", out playerObj) || !data.TryGetValue("Message", out messageObj))
                return null;
            
            var player = BasePlayer.Find((playerObj as IPlayer)?.Id);
            var message = messageObj?.ToString();
            if (player == null || !player.IsConnected || string.IsNullOrEmpty(message))
                return null;
            
            return HandleChatMessage(player, message);
        }

        private object OnChatPlusMessage(BasePlayer player, string message)
        {
            PrintDebug("Called OnChatPlusMessage");
            return HandleChatMessage(player, message);
        }

        // ReSharper disable once SuggestBaseTypeForParameter
        private object OnBetterChat(Dictionary<string, object> data)
        {
            PrintDebug("Called OnBetterChat");
            object playerObj, messageObj, chatChannel;
            if (!data.TryGetValue("Player", out playerObj) || !data.TryGetValue("Message", out messageObj) ||
                !data.TryGetValue("ChatChannel", out chatChannel))
            {
                return null;
            }

            if ((Chat.ChatChannel) chatChannel != Chat.ChatChannel.Global)
            {
                return null;
            }
            
            var player = BasePlayer.Find((playerObj as IPlayer)?.Id);
            var message = messageObj?.ToString();
            if (player == null || !player.IsConnected || string.IsNullOrEmpty(message))
                return null;

            if (HandleChatMessage(player, message) == null)
                return null;
            
            data["CancelOption"] = 2;
            return null;
        }

        private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            PrintDebug("Called OnPlayerChat");
            if (player == null || string.IsNullOrEmpty(message) || channel != Chat.ChatChannel.Global)
                return null;

            return HandleChatMessage(player, message);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (_config.JoiningMessage.Count > 0 && _config.JoiningMessageEnabled)
            {
                var message =
                    new StringBuilder(_config.JoiningMessage[Random.Next(0, _config.JoiningMessage.Count - 1)]);
                var ip = player.net.connection.ipaddress.Substring(0, player.net.connection.ipaddress.LastIndexOf(':'));
                message = message.Replace("{name}", player.displayName).Replace("{id}", player.UserIDString)
                    .Replace("{ip}", ip);

                var usePlayer = _config.JoiningMessageSelfEnabled ? null : player;
                if (message.ToString().IndexOf("{country}", StringComparison.CurrentCultureIgnoreCase) != -1 || message.ToString().IndexOf("{countrycode}", StringComparison.CurrentCultureIgnoreCase) != -1)
                    HandleCountryMessage(message, ip, usePlayer);
                else Publish(message.ToString(), player2: usePlayer);
            }

            if (_config.WelcomeMessage.Count <= 0 || !_config.WelcomeMessageEnabled) return;
            
            {
                var message = new StringBuilder(_config.WelcomeMessage[Random.Next(0, _config.WelcomeMessage.Count - 1)]);
                var ip = player.net.connection.ipaddress.Substring(0, player.net.connection.ipaddress.LastIndexOf(':'));
                message = message.Replace("{name}", player.displayName).Replace("{id}", player.UserIDString)
                    .Replace("{ip}", ip);
                
                if (message.ToString().IndexOf("{country}", StringComparison.CurrentCultureIgnoreCase) != -1 || message.ToString().IndexOf("{countrycode}", StringComparison.CurrentCultureIgnoreCase) != -1)
                    HandleCountryMessage(message, ip, player, false);
                else Publish(message.ToString(), player2: player, exclude: false);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (_config.LeavingMessage.Count <= 0 || !_config.LeavingMessageEnabled) return;
            
            var message =
                new StringBuilder(_config.LeavingMessage[Random.Next(0, _config.LeavingMessage.Count - 1)]);
            var ip = player.net.connection.ipaddress.Substring(0, player.net.connection.ipaddress.LastIndexOf(':'));
            message = message.Replace("{name}", player.displayName).Replace("{id}", player.UserIDString)
                .Replace("{ip}", ip).Replace("{reason}", reason);

            var usePlayer = _config.LeavingMessageSelfEnabled ? null : player;
            if (message.ToString().IndexOf("{country}", StringComparison.CurrentCultureIgnoreCase) != -1 ||
                message.ToString().IndexOf("{countrycode}", StringComparison.CurrentCultureIgnoreCase) != -1)
                HandleCountryMessage(message, ip, usePlayer);
            else Publish(message.ToString(), string.Empty, usePlayer);
        }

        #endregion
        
        #region Helpers

        private void HandleCountryMessage(StringBuilder message, string ip, BasePlayer player, bool exclude = true)
        {
            webrequest.Enqueue(CountryRequest.Replace("{ip}", ip), string.Empty, (status, result) =>
            {
                PrintDebug("Requested a country!");
                try
                {
                    // ReSharper disable once InvertIf
                    if (status == 200)
                    {
                        var info = JsonConvert.DeserializeObject<Dictionary<string, object>>(result);
                        if ((string) info["status"] == "success")
                        {
                            message = message.Replace("{country}", (string) info["country"])
                                .Replace("{countrycode}", (string) info["countryCode"]);
                        }
                    }
                }
                catch (Exception e)
                {
                    PrintError(e.ToString());
                }
                finally
                {
                    Publish(message.ToString(), string.Empty, player, exclude);
                }
            }, this);
        }

        private void PrintDebug(string message)
        {
            if (!_config.Debug) return;
            Puts($"DEBUG: {message}");
        }

        // ReSharper disable once SuggestBaseTypeForParameter
        private void Publish(string message, string perm = "", BasePlayer player2 = null, bool exclude = true)
        {
            PrintDebug($"Called Publish (Message: {message}; Permission: {perm})");
            var notRequirePermission = string.IsNullOrEmpty(perm);
            message = FormatMessage(message);

            if (exclude)
            {
                var players = BasePlayer.activePlayerList;
                var playersCount = players.Count;
                for (var i = 0; i < playersCount; i++)
                {
                    var player = players[i];
                    if (player != player2 &&
                        (notRequirePermission || permission.UserHasPermission(player.UserIDString, perm)))
                        SendMessage(player, RunPlaceholders(player.IPlayer, message));
                }
            }
            else
                SendMessage(player2, RunPlaceholders(player2?.IPlayer, message));
        }

        private void Publish(BasePlayer player, string message) => SendMessage(player, RunPlaceholders(player.IPlayer, FormatMessage(message)));

        private void SendMessage(BasePlayer player, string message)
        {
            PrintDebug($"SendMessage: {message}");
            player.SendConsoleCommand("chat.add", 2, _config.ChatSteamId, message);
        }

        private string FormatMessage(string message) => _config.ShowPrefix ? _config.Prefix + message : message;

        private string RunPlaceholders(IPlayer player, string message)
        {
            if (PlaceholderAPI == null || !PlaceholderAPI.IsLoaded)
                return message;
            
            var builder = new StringBuilder(message);
            PlaceholderAPI.CallHook("ProcessPlaceholders", player, builder);
            return builder.ToString();
        }
        
        #endregion
        
        #region Parsers
        
        private static readonly Regex RegexStringTime = new Regex(@"(\d+)([dhms])", RegexOptions.Compiled);
        private static bool ConvertToSeconds(string time, out uint seconds)
        {
            seconds = 0;
            if (time == "0" || string.IsNullOrEmpty(time)) return true;
            var matches = RegexStringTime.Matches(time);
            if (matches.Count == 0) return false;
            for (var i = 0; i < matches.Count; i++)
            {
                var match = matches[i];
                // ReSharper disable once SwitchStatementMissingSomeCases
                switch (match.Groups[2].Value)
                {
                    case "d":
                    {
                        seconds += uint.Parse(match.Groups[1].Value) * 24 * 60 * 60;
                        break;
                    }
                    case "h":
                    {
                        seconds += uint.Parse(match.Groups[1].Value) * 60 * 60;
                        break;
                    }
                    case "m":
                    {
                        seconds += uint.Parse(match.Groups[1].Value) * 60;
                        break;
                    }
                    case "s":
                    {
                        seconds += uint.Parse(match.Groups[1].Value);
                        break;
                    }
                }
            }
            return true;
        }
        
        #endregion

        #region Automated Messages

        private object HandleChatMessage(BasePlayer player, string msg)
        {
            PrintDebug("Called HandleChatMessage");

            var response = Interface.GetMod().CallHook("CanSmartHandleMessage", player, msg);
            if (response != null)
                return null;
            
            var autoResponseGroups = _config.AutoResponses;
            var autoResponseGroupsCount = autoResponseGroups.Count;

            var tNow = Time.GetUnixTimestamp();
            uint lastSent;
            _lastSent.TryGetValue(player, out lastSent);

            PrintDebug($"tNow: {tNow}");
            PrintDebug($"lastSent: {lastSent}");
            if (_config.ParsedCooldown != 0 && lastSent + _config.ParsedCooldown > tNow ||
                _config.ParsedCooldownGlobal != 0 && _lastSentGlobal + _config.ParsedCooldownGlobal > tNow)
                return null;

            var matched = false;
            var removeMessage = false;
            // Auto Response Groups
            for (var i1 = 0; i1 < autoResponseGroupsCount; i1++)
            {
                var autoResponseGroup = autoResponseGroups[i1];
                var perm = autoResponseGroup.Permission;
                if (!string.IsNullOrEmpty(perm) &&
                    !permission.UserHasPermission(player.UserIDString, autoResponseGroup.Permission))
                    continue;

                var autoResponses = autoResponseGroup.AutoResponses;
                var autoResponsesCount = autoResponses.Count;
                // Auto Responses
                for (var i2 = 0; i2 < autoResponsesCount; i2++)
                {
                    var autoResponse = autoResponses[i2];
                    if (!autoResponse.IsValid() || !autoResponse.Enabled)
                        continue;

                    var answersCount = autoResponse.Answers.Count;
                    var autoResponseTriggers = autoResponse.Triggers;
                    var autoResponseTriggersCount = autoResponseTriggers.Count;
                    // Triggers
                    for (var i3 = 0; i3 < autoResponseTriggersCount; i3++)
                    {
                        var trigger = autoResponseTriggers[i3];

                        float wordsCount = trigger.Words.Count;
                        ushort wordsMatches = 0;
                        var regex = trigger.Regex;
                        
                        // Each Word In Triggers
                        for (var i4 = 0; i4 < wordsCount; i4++)
                        {
                            if (regex && Regex.IsMatch(msg, trigger.Words[i4]) ||
                                msg.IndexOf(trigger.Words[i4], StringComparison.CurrentCultureIgnoreCase) != -1)
                                wordsMatches++;
                        }

                        var match = wordsMatches / wordsCount;
                        PrintDebug($"Matched: {match}");

                        if (wordsMatches / wordsCount < trigger.ContainedWordsPercentage) continue;

                        matched = true;
                        var answer = autoResponse.Answers[Random.Next(0, answersCount)];
                        PrintDebug("Matched message");

                        response = Interface.GetMod().CallHook("CanSmartAnswerMessage", player, msg, answer);
                        if (response != null)
                            return null;

                        if (_config.MinTime <= 0 && _config.MaxTime <= 0)
                            NextTick(() => TrySend(player, autoResponse.SendPublic, answer)); // Next Tick to be sure it's after player's message.
                        else
                            timer.Once(Mathf.Lerp(_config.MinTime, _config.MaxTime, (float) Random.NextDouble()), () => TrySend(player, autoResponse.SendPublic, answer));

                        if (autoResponse.RemoveMessage)
                            removeMessage = true;

                        break;
                    }

                    if (matched && !_config.MultipleAutoResponses)
                        break;
                }
            }

            if (matched)
            {
                _lastSent[player] = tNow;
                _lastSentGlobal = tNow;
                PrintDebug("Matched. Changing cooldown info.");
            }

            if (removeMessage)
                return false;
            
            return null;
        }

        private void TrySend(BasePlayer player, bool isPublic, string answer)
        {
            if (isPublic)
                Publish(answer, string.Empty);
            else
                Publish(player, answer);
        }

        private void HandleBroadcast(AutoMessageGroup group)
        {
            PrintDebug("Called HandleBroadcast");
            if (group.ActiveMessage > group.AutoMessages.Count - 1)
                group.ActiveMessage = 0;
            PrintDebug($"Active Message: {group.ActiveMessage}");

            var message = group.AutoMessages[group.ActiveMessage++];
            if (message.Enabled)
                Publish(message.Message, group.Permission);
        }

        #endregion
    }
}

// --- End of file: SmartChatBot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/sort-button ---
// --- Original File Path: S/SortButton/SortButton.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Pool = Facepunch.Pool;
using System.Collections.Generic;
using System.Linq;
using System;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Sort Button", "MON@H", "2.4.1")]
    [Description("Adds a sort button to storage boxes, allowing you to sort items by name or category")]
    internal class SortButton : CovalencePlugin
    {
        #region Fields

        private Configuration _config;

        [PluginReference]
        private readonly Plugin Clans, Friends;

        private const string PermissionUse = "sortbutton.use";
        private const string GUIPanelName = "UISortButton";

        private const int MaxRows = 8;
        private const float BaseYOffset = 113.5f;
        private const float YOffsetPerRow = 62;
        private const float SortButtonWidth = 79;
        private const float SortOrderButtonWidthString = 17;
        private const string ButtonHeightString = "23";

        // When calculating sort button position, do it based on the loot panel to simplify configuration.
        private readonly Dictionary<string, string> OffsetYByLootPanel = new()
        {
            ["dropboxcontents"] = (BaseYOffset + YOffsetPerRow * 2).ToString(),
            ["furnace"] = "277",
            ["generic"] = (BaseYOffset + YOffsetPerRow * 6).ToString(),
            ["genericsmall"] = (BaseYOffset + YOffsetPerRow).ToString(),
            ["largefurnace"] = "395",
            ["toolcupboard"] = "595",
            ["vendingmachine.storage"] = (BaseYOffset + YOffsetPerRow * 5).ToString(),
        };

        private readonly string[] OffsetYByRow = new string[MaxRows];

        // Since 2020/08, some loot panels still use 21px, while most other panels use 23px.
        private readonly Dictionary<string, string> HeightOverrideByLootPanel = new()
        {
            ["animal-storage"] = "21",
            ["dropboxcontents"] = "21",
            ["furnace"] = "21",
            ["largefurnace"] = "21",
            ["toolcupboard"] = "21.5",
            ["vendingmachine.storage"] = "21",
        };

        // When players sort by category, use numeric sort order for faster comparisons.
        private int[] _itemCategoryToSortIndex;

        // When players do not have data, use this shared object to avoid unnecessary heap allocations.
        private PlayerData _defaultPlayerData;

        // Cache the UI JSON to improve performance.
        private string _cachedUI;

        // Parameterize the cached UI JSON with the arguments stored in this array.
        private readonly string[] _uiArguments = new string[6];

        // Keep track of UI viewers to reduce unnecessary calls to destroy the UI.
        private readonly HashSet<ulong> _uiViewers = new();

        #endregion Fields

        #region OxideHooks

        private void Init()
        {
            UnsubscribeFromHooks();
            RegisterPermissions();
            AddCommands();
            LoadData();
            SetupItemCategories();

            _defaultPlayerData = new PlayerData
            {
                Enabled = _config.DefaultEnabled,
                SortByCategory = _config.DefaultSortByCategory,
            };

            for (var i = 0; i < MaxRows; i++)
            {
                OffsetYByRow[i] = (BaseYOffset + YOffsetPerRow * (i + 1)).ToString();
            }
        }

        private void OnServerInitialized()
        {
            _config.OnServerInitialized(this);

            SubscribeToHooks();
        }

        private void Unload()
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                DestroyUi(activePlayer);
            }
        }

        private void OnLootEntity(BasePlayer basePlayer, BaseEntity entity)
        {
            HandleOnLootEntity(basePlayer, entity, delay: true);
        }

        private void OnPlayerLootEnd(PlayerLoot inventory)
        {
            var player = inventory.baseEntity;
            if (player != null)
            {
                DestroyUi(player);
            }
        }

        // Only using this hook because some plugins don't call OnPlayerLootEnd.
        private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            DestroyUi(player);
        }

        #endregion OxideHooks

        #region Commands

        private void CmdSortButton(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer)
                return;

            var basePlayer = player.Object as BasePlayer;

            if (!permission.UserHasPermission(basePlayer.UserIDString, PermissionUse))
            {
                PlayerSendMessage(basePlayer, Lang(LangKeys.Error.NoPermission, basePlayer.UserIDString));
                return;
            }

            var playerData = GetPlayerData(basePlayer.userID, createIfMissing: true);

            if (args == null || args.Length == 0)
            {
                playerData.Enabled = !playerData.Enabled;
                SaveData();

                var enabledOrDisabledMessage = playerData.Enabled
                    ? Lang(LangKeys.Format.Enabled, basePlayer.UserIDString)
                    : Lang(LangKeys.Format.Disabled, basePlayer.UserIDString);

                PlayerSendMessage(basePlayer, Lang(LangKeys.Info.ButtonStatus, basePlayer.UserIDString, enabledOrDisabledMessage));
                return;
            }

            switch (args[0].ToLower())
            {
                case "sort":
                case "type":
                    playerData.SortByCategory = !playerData.SortByCategory;
                    SaveData();

                    var sortTypeLangKey = playerData.SortByCategory
                        ? LangKeys.Format.Category
                        : LangKeys.Format.Name;

                    PlayerSendMessage(basePlayer, Lang(LangKeys.Info.SortType, basePlayer.UserIDString, Lang(sortTypeLangKey, basePlayer.UserIDString)));
                    return;
            }

            PlayerSendMessage(basePlayer, Lang(LangKeys.Info.Help, basePlayer.UserIDString, _config.Commands[0]));
        }

        [Command("sortbutton.order")]
        private void Command_SortType(IPlayer player)
        {
            if (player.IsServer || !player.HasPermission(PermissionUse))
                return;

            var basePlayer = player.Object as BasePlayer;
            var playerData = GetPlayerData(basePlayer.userID, createIfMissing: true);

            playerData.SortByCategory = !playerData.SortByCategory;
            SaveData();

            RecreateSortButton(basePlayer);
        }

        [Command("sortbutton.sort")]
        private void Command_Sort(IPlayer player)
        {
            if (player.IsServer || !player.HasPermission(PermissionUse))
                return;

            var basePlayer = player.Object as BasePlayer;
            var containers = basePlayer.inventory.loot.containers;

            // Sorting loot panels with multiple containers is not supported at this time.
            if (containers.Count != 1)
                return;

            var entitySource = basePlayer.inventory.loot.entitySource;

            // Verify the container is supported.
            var containerConfiguration = _config.GetContainerConfiguration(entitySource);
            if (containerConfiguration is not { Enabled: true })
                return;

            // Verify entity-specific checks like for drop boxes and vending machines.
            if (!CanPlayerSortEntity(basePlayer, entitySource))
                return;

            // Verify the player hasn't disabled the sort button.
            var playerData = GetPlayerData(basePlayer.userID);
            if (!playerData.Enabled)
                return;

            // If the container is owned by another player, verify the looter is authorized to sort.
            var ownerID = entitySource.OwnerID;
            if (_config.CheckOwnership && ownerID != 0 && !IsAlly(basePlayer.userID, ownerID))
                return;

            foreach (var container in basePlayer.inventory.loot.containers)
            {
                if (!IsSortableContainer(container))
                    continue;

                SortContainer(container, basePlayer, playerData.SortByCategory);
            }
        }

        #endregion Commands

        #region Helpers

        private void UnsubscribeFromHooks()
        {
            Unsubscribe(nameof(OnLootEntity));
            Unsubscribe(nameof(OnPlayerLootEnd));
        }

        private void SubscribeToHooks()
        {
            Subscribe(nameof(OnLootEntity));
            Subscribe(nameof(OnPlayerLootEnd));
        }

        private void SetupItemCategories()
        {
            var itemCategories = Enum.GetValues(typeof(ItemCategory)).Cast<ItemCategory>().ToList();
            itemCategories.Sort((a, b) => a.ToString().CompareTo(b.ToString()));

            _itemCategoryToSortIndex = new int[itemCategories.Count];

            for (var i = 0; i < itemCategories.Count; i++)
            {
                var itemCategory = itemCategories[i];
                _itemCategoryToSortIndex[(int)itemCategory] = i;
            }
        }

        private void RegisterPermissions()
        {
            permission.RegisterPermission(PermissionUse, this);
        }

        private void AddCommands()
        {
            if (_config.Commands.Count == 0)
            {
                _config.Commands = new List<string>() { "sortbutton" };
                SaveConfig();
            }

            foreach (var command in _config.Commands)
            {
                AddCovalenceCommand(command, nameof(CmdSortButton));
            }
        }

        private bool IsPluginLoaded(Plugin plugin) => plugin is { IsLoaded: true };

        private bool IsAlly(ulong playerId, ulong targetId)
        {
            if (playerId == targetId || IsOnSameTeam(playerId, targetId))
                return true;

            var playerIdString = playerId.ToString();
            var targetIdString = targetId.ToString();

            return IsClanMemberOrAlly(playerIdString, targetIdString)
                || IsFriend(playerIdString, targetIdString);
        }

        private bool IsClanMemberOrAlly(string playerId, string targetId)
        {
            if (_config.UseClans)
            {
                if (IsPluginLoaded(Clans))
                    return Clans.Call<bool>("IsMemberOrAlly", playerId, targetId);

                PrintError("UseClans is set to true, but plugin Clans is not loaded!");
            }

            return false;
        }

        private bool IsFriend(string playerId, string targetId)
        {
            if (_config.UseFriends)
            {
                if (IsPluginLoaded(Friends))
                    return Friends.Call<bool>("HasFriend", targetId, playerId);

                PrintError("UseFriends is set to true, but plugin Friends is not loaded!");
            }

            return false;
        }

        private bool IsOnSameTeam(ulong playerId, ulong targetId)
        {
            if (!_config.UseTeams)
                return false;

            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerId);
            return playerTeam?.members.Contains(targetId) ?? false;
        }

        private void PlayerSendMessage(BasePlayer player, string message)
        {
            message = Lang(LangKeys.Format.Prefix, player.UserIDString) + message;
            player.SendConsoleCommand("chat.add", 2, _config.SteamIDIcon, message);
        }

        #endregion Helpers

        #region Core Methods

        private void HandleOnLootEntityDelayed(BasePlayer basePlayer, BaseEntity entity, string offsetXString, bool sortByCategory)
        {
            // Sorting loot panels with multiple containers is not supported at this time.
            if (basePlayer.inventory.loot.containers.Count != 1)
                return;

            var container = basePlayer.inventory.loot.containers.FirstOrDefault();

            // Don't show the sort button for the ridable horse equipment inventory.
            if ((entity is BaseRidableAnimal animal && container != animal.storageInventory)
                || (entity is RidableHorse2 horse && container != horse.storageInventory))
                return;

            var lootPanelName = DetermineLootPanelName(entity);
            if (!TryDetermineYOffset(container, lootPanelName, out var offsetYString))
                return;

            if (!HeightOverrideByLootPanel.TryGetValue(lootPanelName, out var heightString))
            {
                heightString = ButtonHeightString;
            }

            CreateButtonUI(basePlayer, offsetXString, offsetYString, heightString, sortByCategory);
        }

        private void HandleOnLootEntity(BasePlayer basePlayer, BaseEntity entity, bool delay = true)
        {
            if (basePlayer == null
                || !permission.UserHasPermission(basePlayer.UserIDString, PermissionUse))
                return;

            // Verify the container is supported.
            var containerConfiguration = _config.GetContainerConfiguration(entity);
            if (containerConfiguration == null || !containerConfiguration.Enabled)
                return;

            // Verify entity-specific checks like for drop boxes and vending machines.
            if (!CanPlayerSortEntity(basePlayer, entity))
                return;

            // Verify the player hasn't disabled the sort button.
            var playerData = GetPlayerData(basePlayer.userID);
            if (!playerData.Enabled)
                return;

            // If the container is owned by another player, verify the looter is authorized to sort.
            var ownerID = entity.OwnerID;
            if (_config.CheckOwnership && ownerID != 0 && !IsAlly(basePlayer.userID, ownerID))
                return;

            var offsetXString = containerConfiguration.OffsetXString;
            var sortByCategory = playerData.SortByCategory;

            if (delay)
            {
                // Delay showing the sort button, so that we can determine which containers the player is actually viewing.
                NextTick(() =>
                {
                    if (basePlayer == null
                        || basePlayer.IsDestroyed
                        || entity == null
                        || entity.IsDestroyed)
                        return;

                    HandleOnLootEntityDelayed(basePlayer, entity, offsetXString, sortByCategory);
                });
            }
            else
            {
                HandleOnLootEntityDelayed(basePlayer, entity, offsetXString, sortByCategory);
            }
        }

        private bool IsSortableContainer(ItemContainer container)
        {
            if (container.IsLocked()
                || container.PlayerItemInputBlocked()
                || container.HasFlag(ItemContainer.Flag.IsPlayer)
                || container.capacity <= 1)
                return false;

            return true;
        }

        private bool CanPlayerSortEntity(BasePlayer basePlayer, BaseEntity entity)
        {
            if (entity == null || entity.IsDestroyed)
                return false;

            var dropBox = entity as DropBox;
            if ((object)dropBox != null)
                return dropBox.PlayerBehind(basePlayer);

            var vendingMachine = entity as VendingMachine;
            if ((object)vendingMachine != null)
                return vendingMachine.PlayerBehind(basePlayer);

            return true;
        }

        private string DetermineLootPanelName(BaseEntity entity)
        {
            return entity switch
            {
                Mailbox mailbox => mailbox.ownerPanel,
                StorageContainer storageContainer => storageContainer.panelName,
                BaseRidableAnimal animal => animal.storagePanelName,
                RidableHorse2 horse => horse.storagePanelName,
                _ => "generic_resizable",
            };
        }

        private bool TryDetermineYOffset(ItemContainer container, string lootPanelName, out string offsetYString)
        {
            if (lootPanelName == "generic_resizable" || lootPanelName == "animal-storage")
            {
                var numRows = Math.Min(1 + (container.capacity - 1) / 6, MaxRows);
                offsetYString = OffsetYByRow[numRows - 1];
                return true;
            }

            if (OffsetYByLootPanel.TryGetValue(lootPanelName, out offsetYString))
                return true;

            return false;
        }

        private int CompareItems(Item a, Item b, bool byCategory = false)
        {
            if (byCategory)
            {
                var categoryIndex = _itemCategoryToSortIndex[(int)a.info.category];
                var otherCategoryIndex = _itemCategoryToSortIndex[(int)b.info.category];

                var categoryComparison = categoryIndex.CompareTo(otherCategoryIndex);
                if (categoryComparison != 0)
                    return categoryComparison;
            }

            var nameComparison = a.info.displayName.translated.CompareTo(b.info.displayName.translated);
            if (nameComparison != 0)
                return nameComparison;

            return a.amount.CompareTo(b.amount);
        }

        private void SortContainer(ItemContainer container, BasePlayer initiator, bool byCategory)
        {
            var itemList = Pool.GetList<Item>();

            if (container.entityOwner is BuildingPrivlidge)
            {
                for (var i = container.itemList.Count - 1; i >= 0; i--)
                {
                    var item = container.itemList[i];
                    if (item.position >= 24)
                        continue;

                    item.RemoveFromContainer();
                    itemList.Add(item);
                }
            }
            else
            {
                for (var i = container.itemList.Count - 1; i >= 0; i--)
                {
                    var item = container.itemList[i];
                    item.RemoveFromContainer();
                    itemList.Add(item);
                }
            }

            if (byCategory)
            {
                itemList.Sort((a, b) => CompareItems(a, b, byCategory: true));
            }
            else
            {
                itemList.Sort((a, b) => CompareItems(a, b, byCategory: false));
            }

            foreach (Item item in itemList)
            {
                if (!item.MoveToContainer(container))
                {
                    initiator.GiveItem(item);
                }
            }

            Pool.FreeList(ref itemList);
        }

        #endregion Core Methods

        #region GUI

        private void CreateButtonUI(BasePlayer player, string offsetXString, string offsetYString, string heightString, bool sortByCategory)
        {
            if (!_uiViewers.Add(player.userID))
                return;

            if (_cachedUI == null)
            {
                var elements = new CuiElementContainer();

                elements.Add(new CuiPanel
                {
                    Image =
                    {
                        Color = "0 0 0 0"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.5 0",
                        AnchorMax = "0.5 0",
                        OffsetMin = "{0} {1}",
                        OffsetMax = "{0} {1}",
                    },
                    CursorEnabled = false,
                }, "Overlay", GUIPanelName);

                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "sortbutton.order",
                        Color = "{2}",
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = "0 0",
                        OffsetMax = $"{SortOrderButtonWidthString} {{3}}",
                    },
                    Text =
                    {
                        Text = "{4}",
                        FontSize = 12,
                        Align = TextAnchor.MiddleCenter,
                        Color = "0.77 0.92 0.67 0.8",
                    },
                }, GUIPanelName);

                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "sortbutton.sort",
                        Color = "0.41 0.50 0.25 0.8",
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{SortOrderButtonWidthString} 0",
                        OffsetMax = $"{SortOrderButtonWidthString + SortButtonWidth} {{3}}",
                    },
                    Text =
                    {
                        Text = "{5}",
                        FontSize = 12,
                        Align = TextAnchor.MiddleCenter,
                        Color = "0.77 0.92 0.67 0.8",
                    },
                }, GUIPanelName);

                _cachedUI = CuiHelper.ToJson(elements);

                // Escape braces for string.Format.
                _cachedUI = _cachedUI.Replace("{", "{{").Replace("}", "}}");

                for (var i = 0; i < _uiArguments.Length; i++)
                {
                    // Unescape braces for intended placeholders.
                    _cachedUI = _cachedUI.Replace("{{" + i + "}}", "{" + i + "}");
                }
            }

            _uiArguments[0] = offsetXString;
            _uiArguments[1] = offsetYString;

            // Order button color.
            _uiArguments[2] = sortByCategory ? "0.75 0.43 0.18 0.8" : "0.26 0.58 0.80 0.8";

            // Button height.
            _uiArguments[3] = heightString;

            // Order button text.
            _uiArguments[4] = sortByCategory ? "C" : "N";

            // Sort button text.
            _uiArguments[5] = lang.GetMessage(LangKeys.Format.ButtonText, this, player.UserIDString);

            CuiHelper.AddUi(player, string.Format(_cachedUI, _uiArguments));
        }

        private void RecreateSortButton(BasePlayer player)
        {
            DestroyUi(player);

            var storage = player.inventory.loot?.entitySource as StorageContainer;
            if ((object)storage != null)
            {
                HandleOnLootEntity(player, storage, delay: false);
            }
        }

        private void DestroyUi(BasePlayer player)
        {
            if (!_uiViewers.Remove(player.userID))
                return;

            CuiHelper.DestroyUi(player, GUIPanelName);
        }

        #endregion GUI

        #region DataFile

        private StoredData _storedData;

        private class StoredData
        {
            public readonly Hash<ulong, PlayerData> PlayerData = new();
        }

        private class PlayerData
        {
            public bool Enabled;
            public bool SortByCategory;
        }

        private PlayerData GetPlayerData(ulong userID, bool createIfMissing = false)
        {
            var playerData = _storedData.PlayerData[userID];
            if (playerData != null)
                return playerData;

            if (createIfMissing)
            {
                playerData = new PlayerData()
                {
                    Enabled = _config.DefaultEnabled,
                    SortByCategory = _config.DefaultSortByCategory,
                };

                _storedData.PlayerData[userID] = playerData;

                return playerData;
            }

            return _defaultPlayerData;
        }

        private void LoadData()
        {
            try
            {
                _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                ClearData();
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);

        private void ClearData()
        {
            _storedData = new StoredData();
            SaveData();
        }

        #endregion DataFile

        #region Configuration

        private class ContainerConfiguration
        {
            [JsonProperty("Enabled")]
            public bool Enabled = true;

            [JsonProperty("OffsetX")]
            public float OffsetX = 476.5f;

            [JsonIgnore]
            private string _offsetXString;

            [JsonIgnore]
            public string OffsetXString
            {
                get
                {
                    if (_offsetXString == null)
                    {
                        _offsetXString = OffsetX.ToString();
                    }

                    return _offsetXString;
                }
            }
        }

        private class Configuration : BaseConfiguration
        {
            private static HashSet<string> OldRemovedPrefabs = new()
            {
                "assets/rust.ai/nextai/testridablehorse.prefab",
            };

            [JsonProperty("Default enabled")]
            public bool DefaultEnabled = true;

            [JsonProperty("Default sort by category")]
            public bool DefaultSortByCategory = true;

            [JsonProperty("Check ownership")]
            public bool CheckOwnership = true;

            [JsonProperty("Use Clans")]
            public bool UseClans = true;

            [JsonProperty("Use Friends")]
            public bool UseFriends = true;

            [JsonProperty("Use Teams")]
            public bool UseTeams = true;

            [JsonProperty("Chat steamID icon")]
            public ulong SteamIDIcon = 0;

            [JsonProperty("Chat command", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Commands = new()
            {
                "sortbutton"
            };

            [JsonProperty("Containers by short prefab name")]
            private Dictionary<string, ContainerConfiguration> ContainersByPrefabPath = new Dictionary<string, ContainerConfiguration>
            {
                ["assets/content/vehicles/boats/rhib/subents/rhib_storage.prefab"] = new(),
                ["assets/content/vehicles/boats/rowboat/subents/rowboat_storage.prefab"] = new(),
                ["assets/content/vehicles/modularcar/subents/modular_car_1mod_storage.prefab"] = new(),
                ["assets/content/vehicles/modularcar/subents/modular_car_camper_storage.prefab"] = new(),
                ["assets/content/vehicles/snowmobiles/subents/snowmobileitemstorage.prefab"] = new(),
                ["assets/content/vehicles/submarine/subents/submarineitemstorage.prefab"] = new(),
                ["assets/prefabs/deployable/composter/composter.prefab"] = new(),
                ["assets/prefabs/deployable/dropbox/dropbox.deployed.prefab"] = new(),
                ["assets/prefabs/deployable/fridge/fridge.deployed.prefab"] = new(),
                ["assets/prefabs/deployable/hitch & trough/hitchtrough.deployed.prefab"] = new(),
                ["assets/prefabs/deployable/hot air balloon/subents/hab_storage.prefab"] = new(),
                ["assets/prefabs/deployable/large wood storage/box.wooden.large.prefab"] = new(),
                ["assets/prefabs/deployable/large wood storage/skins/medieval_large_wood_box/medieval.box.wooden.large.prefab"] = new(),
                ["assets/prefabs/deployable/small stash/small_stash_deployed.prefab"] = new(),
                ["assets/prefabs/deployable/tool cupboard/cupboard.tool.deployed.prefab"] = new(),
                ["assets/prefabs/deployable/tool cupboard/retro/cupboard.tool.retro.deployed.prefab"] = new(),
                ["assets/prefabs/deployable/tool cupboard/shockbyte/cupboard.tool.shockbyte.deployed.prefab"] = new(),
                ["assets/prefabs/deployable/vendingmachine/vendingmachine.deployed.prefab"] = new(),
                ["assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab"] = new(),
                ["assets/prefabs/misc/halloween/coffin/coffinstorage.prefab"] = new(),
                ["assets/prefabs/misc/decor_dlc/storagebarrel/storage_barrel_b.prefab"] = new(),
                ["assets/prefabs/misc/decor_dlc/storagebarrel/storage_barrel_c.prefab"] = new(),
                ["assets/content/vehicles/horse/_old/testridablehorse.prefab"] = new(),
                ["assets/content/vehicles/horse/ridablehorse2.prefab"] = new(),
            };

            [JsonProperty("Containers by skin ID")]
            private Dictionary<ulong, ContainerConfiguration> ContainersBySkinId = new();

            [JsonIgnore]
            private Dictionary<uint, ContainerConfiguration> ContainersByPrefabId = new();

            public void OnServerInitialized(SortButton plugin)
            {
                List<string> prefabsToRemove = null;

                foreach (var (prefabPath, containerConfig) in ContainersByPrefabPath)
                {
                    var baseEntity = GameManager.server.FindPrefab(prefabPath)?.GetComponent<BaseEntity>();
                    if (baseEntity == null)
                    {
                        if (OldRemovedPrefabs.Contains(prefabPath))
                        {
                            prefabsToRemove ??= new List<string>();
                            prefabsToRemove.Add(prefabPath);
                        }
                        else
                        {
                            plugin.LogError($"Invalid prefab in configuration: {prefabPath}");
                        }

                        continue;
                    }

                    ContainersByPrefabId[baseEntity.prefabID] = containerConfig;
                }

                if (prefabsToRemove?.Count > 0)
                {
                    foreach (var prefabPath in prefabsToRemove)
                    {
                        ContainersByPrefabPath.Remove(prefabPath);
                    }

                    if (!UsingDefaults)
                    {
                        plugin.SaveConfig();
                    }
                }
            }

            public ContainerConfiguration GetContainerConfiguration(BaseEntity entity)
            {
                if (entity.skinID != 0 && ContainersBySkinId.TryGetValue(entity.skinID, out var containerConfiguration))
                    return containerConfiguration;

                if (ContainersByPrefabId.TryGetValue(entity.prefabID, out containerConfiguration))
                    return containerConfiguration;

                return null;
            }
        }

        #region Configuration Helpers

        private class BaseConfiguration
        {
            [JsonIgnore]
            public bool UsingDefaults;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigSection(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigSection(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigSection(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
                _config.UsingDefaults = true;
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion Configuration Helpers

        #endregion Configuration

        #region Localization

        private string Lang(string key, string userIDString = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, userIDString), args);
            }
            catch (Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception:\n{ex}");
                throw;
            }
        }

        private static class LangKeys
        {
            public static class Error
            {
                private const string Base = nameof(Error) + ".";
                public const string NoPermission = Base + nameof(NoPermission);
            }

            public static class Info
            {
                private const string Base = nameof(Info) + ".";
                public const string ButtonStatus = Base + nameof(ButtonStatus);
                public const string Help = Base + nameof(Help);
                public const string SortType = Base + nameof(SortType);
            }

            public static class Format
            {
                private const string Base = nameof(Format) + ".";
                public const string ButtonText = Base + nameof(ButtonText);
                public const string Category = Base + nameof(Category);
                public const string Disabled = Base + nameof(Disabled);
                public const string Enabled = Base + nameof(Enabled);
                public const string Name = Base + nameof(Name);
                public const string Prefix = Base + nameof(Prefix);
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Error.NoPermission] = "You do not have permission to use this command",
                [LangKeys.Format.ButtonText] = "Sort",
                [LangKeys.Format.Category] = "<color=#D2691E>Category</color>",
                [LangKeys.Format.Disabled] = "<color=#B22222>Disabled</color>",
                [LangKeys.Format.Enabled] = "<color=#228B22>Enabled</color>",
                [LangKeys.Format.Name] = "<color=#00BFFF>Name</color>",
                [LangKeys.Format.Prefix] = "<color=#00FF00>[Sort Button]</color>: ",
                [LangKeys.Info.ButtonStatus] = "Sort Button is now {0}",
                [LangKeys.Info.SortType] = "Sort Type is now {0}",
                [LangKeys.Info.Help] = "List Commands:\n" +
                "<color=#FFFF00>/{0}</color> - Enable/Disable Sort Button.\n" +
                "<color=#FFFF00>/{0} <sort | type></color> - change sort type.",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Error.NoPermission] = "Ð£ Ð²Ð°Ñ Ð½ÐµÑ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ñ Ð½Ð° Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÑÐ¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ",
                [LangKeys.Format.ButtonText] = "Ð¡Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ",
                [LangKeys.Format.Category] = "<color=#D2691E>ÐÐ°ÑÐµÐ³Ð¾ÑÐ¸Ñ</color>",
                [LangKeys.Format.Disabled] = "<color=#B22222>ÐÑÐºÐ»ÑÑÐµÐ½Ð°</color>",
                [LangKeys.Format.Enabled] = "<color=#228B22>ÐÐºÐ»ÑÑÐµÐ½Ð°</color>",
                [LangKeys.Format.Name] = "<color=#00BFFF>ÐÐ¼Ñ</color>",
                [LangKeys.Format.Prefix] = "<color=#00FF00>[Sort Button]</color>: ",
                [LangKeys.Info.ButtonStatus] = "ÐÐ½Ð¾Ð¿ÐºÐ° ÑÐ¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸ ÑÐµÐ¿ÐµÑÑ {0}",
                [LangKeys.Info.SortType] = "Ð¢Ð¸Ð¿ ÑÐ¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸ ÑÐµÐ¿ÐµÑÑ {0}",
                [LangKeys.Info.Help] = "Ð¡Ð¿Ð¸ÑÐ¾Ðº ÐºÐ¾Ð¼Ð°Ð½Ð´:\n" +
                "<color=#FFFF00>/{0}</color> - ÐÐºÐ»ÑÑÐ¸ÑÑ/ÐÑÐºÐ»ÑÑÐ¸ÑÑ ÐºÐ½Ð¾Ð¿ÐºÑ ÑÐ¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸.\n" +
                "<color=#FFFF00>/{0} <sort | type></color> - Ð¸Ð·Ð¼ÐµÐ½Ð¸ÑÑ ÑÐ¸Ð¿ ÑÐ¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸.",
            }, this, "ru");
        }

        #endregion Localization
    }
}


// --- End of file: SortButton.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/simple-logo ---
// --- Original File Path: S/SimpleLogo/SimpleLogo.cs ---

ï»¿//Requires: ImageLibrary

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("SimpleLogo", "Sami37", "1.2.8")]
    [Description("Place your own logo to your player screen.")]
    public class SimpleLogo : RustPlugin
    {
        #region config
        [PluginReference]
        ImageLibrary ImageLibrary;

        private string Perm = "simplelogo.display", NoDisplay = "simplelogo.nodisplay";
        List<object> _urlList = new List<object>();
        private int _currentlySelected, _intervals;
        private Dictionary<ulong, bool> playerHide = new Dictionary<ulong, bool>();

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadConfig();
        }

        string ListToString<T>(List<T> list, int first = 0, string seperator = ", ") => string.Join(seperator, (from val in list select val.ToString()).Skip(first).ToArray());
        void SetConfig(params object[] args) { List<string> stringArgs = (from arg in args select arg.ToString()).ToList(); stringArgs.RemoveAt(args.Length - 1); if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args); }
        T GetConfig<T>(T defaultVal, params object[] args) { List<string> stringArgs = (from arg in args select arg.ToString()).ToList(); if (Config.Get(stringArgs.ToArray()) == null) { PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin."); return defaultVal; } return (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T)); }

        private string GetImage(string shortname) => ImageLibrary.GetImage(shortname);

        void LoadConfig()
        {
            List<object> listUrl = new List<object> { "http://i.imgur.com/KVmbhyB.png" };
            SetConfig("UI", "GUIAnchorMin", "0.01 0.02");
            SetConfig("UI", "GUIAnchorMax", "0.15 0.1");
            SetConfig("UI", "BackgroundMainColor", "0 0 0 0");
            SetConfig("UI", "BackgroundMainURL", listUrl);
            SetConfig("UI", "IntervalBetweenImage", 30);

            SaveConfig();

            _intervals = GetConfig(30, "UI", "IntervalBetweenImage");
            _urlList = (List<object>)Config["UI", "BackgroundMainURL"];

            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();
            int i = 0;
            foreach (var url in _urlList)
            {
                newLoadOrder.Add("SimpleLogo"+i, url.ToString());
                i++;
            }

            LoadOrder(Title, newLoadOrder, 0, true);
        }

        private void LoadOrder(string title, Dictionary<string, string> importImageList, ulong skin, bool force) => ImageLibrary?.Call("ImportImageList", title, importImageList, skin, force);

        #endregion

        #region data_init

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                GUIDestroy(player);
            }
            if(playerHide != null)
                Interface.Oxide.DataFileSystem.WriteObject(Name, playerHide);
        }
        #endregion

        private CuiElement CreateImage(string panelName)
        {
            var element = new CuiElement();
            var url = GetImage($"SimpleLogo{_currentlySelected}");
            var image = new CuiRawImageComponent
            {
                Png = url
            };

            var rectTransform = new CuiRectTransformComponent
            {
                AnchorMin = "0 0",
                AnchorMax = "1 1"
            };
            element.Components.Add(image);
            element.Components.Add(rectTransform);
            element.Name = CuiHelper.GetGuid();
            element.Parent = panelName;
            return element;
        }

        void GUIDestroy(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "containerSimpleUI");
        }

        void CreateUi(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, Perm) && !permission.UserHasPermission(player.UserIDString, NoDisplay))
            {
                var panel = new CuiElementContainer
                {
                    {
                        new CuiPanel
                        {
                            Image =
                            {
                                Color = Config["UI", "BackgroundMainColor"].ToString()
                            },
                            RectTransform =
                            {
                                AnchorMin = Config["UI", "GUIAnchorMin"].ToString(),
                                AnchorMax = Config["UI", "GUIAnchorMax"].ToString()
                            },
                            CursorEnabled = false
                        },
                        "Hud", "containerSimpleUI"
                    }
                };
                var backgroundImageWin = CreateImage("containerSimpleUI");
                panel.Add(backgroundImageWin);
                CuiHelper.AddUi(player, panel);
            }
        }

        void RefreshUi()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                GUIDestroy(player);
                if (playerHide == null || !playerHide.ContainsKey(player.userID))
                    CreateUi(player);
                else if(playerHide.ContainsKey(player.userID) && !playerHide[player.userID])
                    CreateUi(player);
            }
            timer.In(_intervals, () =>
            {
                if (_currentlySelected >= _urlList.Count)
                    _currentlySelected = 0;
                RefreshUi();
                _currentlySelected += 1;
            });
        }

        void OnServerInitialized()
        {
            LoadConfig();
            NextTick(RefreshUi);
            permission.RegisterPermission(Perm, this);
            permission.RegisterPermission(NoDisplay, this);

            playerHide = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, bool>>(Name);
        }

        [ChatCommand("SL")]
        void chatCmd(BasePlayer player, string command, string[] args)
        {
            if(playerHide == null)
                playerHide = new Dictionary<ulong, bool>();
            if (!playerHide.ContainsKey(player.userID))
            {
                playerHide.Add(player.userID, true);
            }
            else
            {
                playerHide[player.userID] = !playerHide[player.userID];
            }
        }
    }
}

// --- End of file: SimpleLogo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/