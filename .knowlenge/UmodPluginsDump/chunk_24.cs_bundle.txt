                    { nameof(Key.CommandConfigAntiCheatWallHackSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.wallhack.ban [true|false]\n    {command} anticheat.wallhack.cooldown [SECONDS]\n    {command} anticheat.wallhack.enabled [true|false]\n    {command} anticheat.wallhack.sensitivity [0.0-1.0]\n    {command} anticheat.wallhack.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiFloodChatSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} antiflood.chat.ban [true|false]\n    {command} antiflood.chat.cooldown [SECONDS]\n    {command} antiflood.chat.enabled [true|false]\n    {command} antiflood.chat.sensitivity [0.0-1.0]\n    {command} antiflood.chat.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiFloodCommandSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} antiflood.command.ban [true|false]\n    {command} antiflood.command.cooldown [SECONDS]\n    {command} antiflood.command.enabled [true|false]\n    {command} antiflood.command.sensitivity [0.0-1.0]\n    {command} antiflood.command.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiFloodItemDropSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} antiflood.itemdrop.ban [true|false]\n    {command} antiflood.itemdrop.cooldown [SECONDS]\n    {command} antiflood.itemdrop.enabled [true|false]\n    {command} antiflood.itemdrop.sensitivity [0.0-1.0]\n    {command} antiflood.itemdrop.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiFloodSyntax), "<size=12><color=#ffc0c0>Syntax:</color><color=#c0c0ff>\n    {command} antiflood.chat\n    {command} antiflood.command\n    {command} antiflood.itemdrop</color></size>" },
                    { nameof(Key.CommandConfigBanSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} ban.inherit [true|false]\n    {command} ban.teleport [true|false]\n    {command} ban.time.enforce [true|false]\n    {command} ban.time.multiply [true|false]\n    {command} ban.time.seconds [AMOUNT[d|h|m|s]]</color></size>" },
                    { nameof(Key.CommandConfigCrippleSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} cripple.heal [true|false]\n    {command} cripple.inherit [true|false]</color></size>" },
                    { nameof(Key.CommandConfigDiscordSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} discord.enabled [true|false]\n    {command} discord.webhook [URL]\n    {command} discord.filters.anticheat.enabled [true|false]\n    {command} discord.filters.anticheat.webhook [URL]\n    {command} discord.filters.antiflood.enabled [true|false]\n    {command} discord.filters.antiflood.webhook [URL]\n    {command} discord.filters.ip.enabled [true|false]\n    {command} discord.filters.ip.webhook [URL]\n    {command} discord.filters.steam.enabled [true|false]\n    {command} discord.filters.steam.webhook [URL]\n    {command} discord.filters.vpn.enabled [true|false]\n    {command} discord.filters.vpn.webhook [URL]</color></size>" },
                    { nameof(Key.CommandConfigEntitySyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} entity.damage.animal [0.0-100.0]\n    {command} entity.damage.bradley [0.0-100.0]\n    {command} entity.damage.building [0.0-100.0]\n    {command} entity.damage.entity [0.0-100.0]\n    {command} entity.damage.friend [0.0-100.0]\n    {command} entity.damage.helicopter [0.0-100.0]\n    {command} entity.damage.npc [0.0-100.0]\n    {command} entity.damage.player [0.0-100.0]\n    {command} entity.damage.team [0.0-100.0]\n    {command} entity.damage.trap [0.0-100.0]</color></size>" },
                    { nameof(Key.CommandConfigIpSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} ip.filter.cooldown [SECONDS]\n    {command} ip.violation.ban [true|false]\n    {command} ip.violation.enabled [true|false]</color></size>" },
                    { nameof(Key.CommandConfigLogSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} log.anticheat.gravity [true|false]\n    {command} log.anticheat.meleerate [true|false]\n    {command} log.anticheat.projectile [true|false]\n    {command} log.anticheat.server [true|false]\n    {command} log.anticheat.stash [true|false]\n    {command} log.antiflood.itemdrop [true|false]\n    {command} log.ip.filter [true|false]\n    {command} log.projectile.collapse [true|false]\n    {command} log.projectile.verbose [true|false]\n    {command} log.user.connect [true|false]\n    {command} log.vpn.bypass [true|false]\n    {command} log.vpn.check [true|false]</color></size>" },
                    { nameof(Key.CommandConfigSaveSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} save</color></size>" },
                    { nameof(Key.CommandConfigSteamSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} steam.api.apikey [\"API-KEY\"]\n    {command} steam.api.enabled [true|false]\n    {command} steam.ban.active [true|false]\n    {command} steam.ban.community [true|false]\n    {command} steam.ban.days [DAYS]\n    {command} steam.ban.economy [true|false]\n    {command} steam.ban.game [NUMBER]\n    {command} steam.ban.vac [NUMBER]\n    {command} steam.game.count [NUMBER]\n    {command} steam.game.hours [HOURS]\n    {command} steam.profile.invalid [true|false]\n    {command} steam.profile.limited [true|false]\n    {command} steam.profile.private [true|false]\n    {command} steam.share.family [true|false]\n    {command} steam.violation.ban [true|false]\n    {command} steam.violation.enabled [true|false]\n    {command} steam.violation.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigSyntax), "<size=12><color=#ffc0c0>Syntax:</color><color=#c0c0ff>\n    {command} admin\n    {command} anticheat\n    {command} antiflood\n    {command} ban\n    {command} cripple\n    {command} discord\n    {command} entity\n    {command} ip\n    {command} log\n    {command} save\n    {command} steam\n    {command} user\n    {command} violation\n    {command} vpn</color></size>" },
                    { nameof(Key.CommandConfigTitle), "Configuration Settings" },
                    { nameof(Key.CommandConfigUserSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} user.bypass.dayssincelastban [DAYS]\n    {command} user.bypass.enabled [true|false]\n    {command} user.bypass.multiply [true|false]\n    {command} user.bypass.hoursplayed [HOURS]</color></size>" },
                    { nameof(Key.CommandConfigViolationSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} violation.ban [true|false]\n    {command} violation.cooldown [SECONDS]\n    {command} violation.enabled [true|false]\n    {command} violation.sensitivity [0.0-1.0]</size>" },
                    { nameof(Key.CommandConfigVpnSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} vpn.api.getipintel.apikey [\"API-KEY\"]\n    {command} vpn.api.getipintel.enabled [true|false]\n    {command} vpn.api.ipapi.enabled [true|false]\n    {command} vpn.api.iphub.apikey [\"API-KEY\"]\n    {command} vpn.api.iphub.enabled [true|false]\n    {command} vpn.api.ipqualityscore.apikey [\"API-KEY\"]\n    {command} vpn.api.ipqualityscore.enabled [true|false]\n    {command} vpn.cache.hours [HOURS]\n    {command} vpn.check.enabled [true|false]\n    {command} vpn.check.strict [true|false]\n    {command} vpn.violation.ban [true|false]\n    {command} vpn.violation.enabled [true|false]\n    {command} vpn.violation.warn [true|false]</color></size>" },
                    { nameof(Key.CommandHelp), "<size=12><color=#ffffc0>{name} v{version} - Help</color>{entries}</size>" },
                    { nameof(Key.CommandHelpEntry), "<color=#c0ffc0>\n{title}:</color><color=#c0c0ff>{aliases}</color>" },
                    { nameof(Key.CommandHelpTitle), "Help Information" },
                    { nameof(Key.CommandIp), "<size=12><color=#c0ffc0>{action} IP: </color><color=#c0c0ff>{info}</color></size>" },
                    { nameof(Key.CommandIpEntry), "<size=12><color=#c0ffc0>{action} IP entry: </color><color=#c0c0ff>{entry}</color></size>" },
                    { nameof(Key.CommandIpEntryFailed), "<size=12><color=#ffc0c0>Failed to {action} IP entry: </color><color=#c0c0ff>{entry}</color></size>" },
                    { nameof(Key.CommandIpList), "<size=12><color=#c0ffc0>{type} IP entries: </color><color=#c0c0ff>{addresses}</color></size>" },
                    { nameof(Key.CommandIpSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} allow\n    {command} allow IP[/BITS]\n    {command} allow add IP[/BITS]\n    {command} allow remove IP[/BITS]\n    {command} block IP\n    {command} bypass IP\n    {command} deny\n    {command} deny IP[/BITS]\n    {command} deny add IP[/BITS]\n    {command} deny remove IP[/BITS]\n    {command} save\n    {command} unblock IP</color></size>" },
                    { nameof(Key.CommandIpTitle), "IP Filtering" },
                    { nameof(Key.CommandLogHeading), "<size=12><color=#c0ffc0>Projectile Log for {playername}[{playerid}]:</color></size>" },
                    { nameof(Key.CommandLogLine), "<size=12><color=#c0c0c0>{info}</color></size>" },
                    { nameof(Key.CommandLogNoEntries), "<size=12><color=#ffffc0>No log data available for {playername}[{playerid}].</color></size>" },
                    { nameof(Key.CommandLogSeeConsole), "<size=12><color=#c0ffc0>Check the console (F1) for results.</color></size>" },
                    { nameof(Key.CommandLogSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} IP|NAME|STEAMID [LINES]</color></size>" },
                    { nameof(Key.CommandLogTitle), "Projectile Log" },
                    { nameof(Key.CommandNoPermission), "<color=#ffc0c0><size=12>You do not have permission to use this command.</size></color>" },
                    { nameof(Key.CommandServerSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} pardon\n    {command} unban\n    {command} uncripple</color></size>" },
                    { nameof(Key.CommandServerTitle), "Server Administration" },
                    { nameof(Key.CommandTeleport), "<size=12><color=#c0ffc0>Last seen location: </color><color=#c0c0ff>{position}</color></size>" },
                    { nameof(Key.CommandTeleportSyntax), "<size=12><color=#ffc0c0>Syntax:</color><color=#c0c0ff>\n    {command} IP|NAME|STEAMID</color></size>" },
                    { nameof(Key.CommandTeleportTitle), "Teleportation" },
                    { nameof(Key.CommandTeleportViolation), "<size=12><color=#c0ffc0>Violation location: </color><color=#c0c0ff>{position}</color></size>" },
                    { nameof(Key.CommandUnknown), "<size=12><color=#ffc0c0>Command unknown: </color><color=#c0c0ff>{command}</color></size>" },
                    { nameof(Key.CommandUser), "<size=12><color=#c0ffc0>{action} {playername}[{playerid}] {duration}: </color><color=#c0c0ff>{reason}</color></size>" },
                    { nameof(Key.CommandUserAction), "<size=12><color=#c0ffc0>{action} {playername}[{playerid}]</color></size>" },
                    { nameof(Key.CommandUserInfo), "<size=12><color=#c0ffc0>User information:</color><color=#c0c0ff>{info}</color></size>" },
                    { nameof(Key.CommandUserKick), "<size=12><color=#c0ffc0>{action} {playername}[{playerid}]: </color><color=#c0c0ff>{reason}</color></size>" },
                    { nameof(Key.CommandUserNotFound), "<size=12><color=#ffc0c0>User not found.</color></size>" },
                    { nameof(Key.CommandUserSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} IP|NAME|STEAMID [team]\n    {command} IP|NAME|STEAMID [team.]ban [\"REASON\"] [TIME[d|h|m|s]]\n    {command} IP|NAME|STEAMID [team.]ban.reset\n    {command} IP|NAME|STEAMID [team.]cripple [\"REASON\"] [TIME[d|h|m|s]]\n    {command} IP|NAME|STEAMID [team.]cripple.reset\n    {command} IP|NAME|STEAMID [team.]kick [\"REASON\"]\n    {command} IP|NAME|STEAMID [team.]pardon\n    {command} IP|NAME|STEAMID [team.]unban\n    {command} IP|NAME|STEAMID [team.]uncripple</color></size>" },
                    { nameof(Key.CommandUserTeam), "<size=12><color=#c0ffc0>Team members:</color><color=#c0c0ff>{users}</color></size>" },
                    { nameof(Key.CommandUserTitle), "User Administration" },
                    { nameof(Key.CommandUserTooMany), "<size=12><color=#ffc0c0>Found multiple users:</color><color=#c0c0ff>{users}</color></size>" },
                    { nameof(Key.CommandVpn), "<size=12><color=#c0ffc0>{action} VPN check: </color><color=#c0c0ff>{info}</color></size>" },
                    { nameof(Key.CommandVpnSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} bypass IP\n    {command} status IP\n    {command} unblock IP</color></size>" },
                    { nameof(Key.CommandVpnTitle), "VPN Detection" },
                    { nameof(Key.connected), "connected" },
                    { nameof(Key.CONSOLE), "CONSOLE" },
                    { nameof(Key.Cooldown), "<color=#ffc0c0><size=12>{type} cooldown: {cooldown}s</size></color>" },
                    { nameof(Key.Crafting), "Crafting" },
                    { nameof(Key.CrippleCount), "Cripple Count" },
                    { nameof(Key.Crippled), "Crippled" },
                    { nameof(Key.crippled), "crippled" },
                    { nameof(Key.CrippleReason), "Cripple Reason" },
                    { nameof(Key.CrippleReset), "Reset cripple data for" },
                    { nameof(Key.Current), "Current" },
                    { nameof(Key.data), "data" },
                    { nameof(Key.Denied), "Denied" },
                    { nameof(Key.Detected), "Detected" },
                    { nameof(Key.DurationDay), "day" },
                    { nameof(Key.DurationDays), "days" },
                    { nameof(Key.DurationHour), "hour" },
                    { nameof(Key.DurationHours), "hours" },
                    { nameof(Key.DurationMinute), "minute" },
                    { nameof(Key.DurationMinutes), "minutes" },
                    { nameof(Key.DurationSecond), "second" },
                    { nameof(Key.DurationSeconds), "seconds" },
                    { nameof(Key.DurationSecondsUnit), "s" },
                    { nameof(Key.empty), "empty" },
                    { nameof(Key.Entity), "Entity" },
                    { nameof(Key.EntityAnimal), "Animal" },
                    { nameof(Key.EntityAutoTurret), "Auto Turret" },
                    { nameof(Key.EntityBear), "Bear" },
                    { nameof(Key.EntityBoar), "Boar" },
                    { nameof(Key.EntityBradley), "Bradley APC" },
                    { nameof(Key.EntityBuilding), "Building" },
                    { nameof(Key.EntityChicken), "Chicken" },
                    { nameof(Key.EntityFlameTurret), "Flame Turret" },
                    { nameof(Key.EntityGunTrap), "Shotgun Trap" },
                    { nameof(Key.EntityHelicopter), "Helicopter" },
                    { nameof(Key.EntityMurderer), "Murderer" },
                    { nameof(Key.EntityNPC), "NPC" },
                    { nameof(Key.EntityPlayer), "Player" },
                    { nameof(Key.EntitySAMSite), "SAM Site" },
                    { nameof(Key.EntityScientist), "Scientist" },
                    { nameof(Key.EntityStag), "Stag" },
                    { nameof(Key.EntityTC), "Tool Cupboard" },
                    { nameof(Key.EntityTrap), "Trap" },
                    { nameof(Key.file), "file" },
                    { nameof(Key.For), "for" },
                    { nameof(Key.idle), "idle" },
                    { nameof(Key.InvalidSteamId), "Invalid SteamID" },
                    { nameof(Key.IP), "IP" },
                    { nameof(Key.IpBlocked), "<color=#ffc000><size=12>IP: Blocked</size></color>" },
                    { nameof(Key.IpCooldown), "<color=#ffc000><size=12>IP: Cooldown</size></color>" },
                    { nameof(Key.Kicked), "Kicked" },
                    { nameof(Key.LogAntiCheatAim), "<color=#ffc000><size=12>Hit info for {playername}[{playerid}]: {target} ({bodypart}; {distance}m; r={range_variance}; a={angle_variance}; p={pvp_variance}; {speed}m/s) {weapon}</size></color>" },
                    { nameof(Key.LogAntiCheatGravity), "<color=#ffc000><size=12>Gravity info for {playername}[{playerid}]: {amount} {position}</size></color>" },
                    { nameof(Key.LogAntiCheatMeleeRate), "<color=#ffc000><size=12>Melee info for {playername}[{playerid}]: {weapon} ({delay}) - {target}</size></color>" },
                    { nameof(Key.LogAntiCheatRecoil), "<color=#ffc000><size=12>Recoil [y: {yaw}({count_x})][p: {pitch}({count_y})][a: {swing}] {playername}[{playerid}] - {weapon}</size></color>" },
                    { nameof(Key.LogAntiCheatServer), "<color=#ffc000><size=12>Server AntiHack violation for {playername}[{playerid}]: {type}({amount}) {position}{colliders}</size></color>" },
                    { nameof(Key.LogAntiCheatStash), "<color=#ffc000><size=12>Stash discovery info for {playername}[{playerid}]: at {grid}{position} - owner={ownerid}</size></color>" },
                    { nameof(Key.LogAntiCheatTrajectory), "<color=#ffc000><size=12>Trajectory [t: {trajectory}] {playername}[{playerid}]: {weapon}({distance}m - {reported}m)</size></color>" },
                    { nameof(Key.LogAntiSpamItemDrop), "<color=#ffc000><size=12>Item drop by player {playername}[{playerid}] - {itemname}[{itemid}]</size></color>" },
                    { nameof(Key.LogConnect), "<color=#ffc000><size=12>{action} connection for {playername}[{playerid}]: {type}({reason})</size></color>" },
                    { nameof(Key.LogDiscordConfig), "<color=#ffc0c0><size=12>Discord: WebHook URL is not configured!</size></color>" },
                    { nameof(Key.LogDiscordMessage), "<color=#ffc0c0><size=12>Discord: Message requires at least one \'content\' or one \'embed\' field!</size></color>" },
                    { nameof(Key.LogIpFilter), "<color=#ffc000><size=12>IP Filter: {action} connection from {address}</size></color>" },
                    { nameof(Key.LogSteam), "<color=#ffc0c0><size=12>Steam Check[{api}]: {type} error for {playername}[{playerid}] - {info}</size></color>" },
                    { nameof(Key.LogSteamConfig), "<color=#ffc0c0><size=12>Steam Check[{api}]: APIKEY missing! Get one from here: {link}</size></color>" },
                    { nameof(Key.LogUserBypass), "<color=#ffc000><size=12>User Bypass: {playername}[{playerid}](address={address}; banned {bantime}; played {playtime}) - {status}</size></color>" },
                    { nameof(Key.LogVpnCheck), "<color=#ffc000><size=12>VPN Check[{api}]: {address}({info})</size></color>" },
                    { nameof(Key.LogVpnCheckConfig), "<color=#ffc0c0><size=12>VPN Check[{api}]: APIKEY missing! Get one from here: {link}</size></color>" },
                    { nameof(Key.LogVpnCheckError), "<color=#ffc0c0><size=12>VPN Check[{api}]: {type} error for {address} - {info}</size></color>" },
                    { nameof(Key.LogWebHook), "<color=#ffc0c0><size=12>WebHook({category}): {type} error - {info}</size></color>" },
                    { nameof(Key.Name), "Name" },
                    { nameof(Key.never), "never" },
                    { nameof(Key.NoReasonGiven), "no reason given" },
                    { nameof(Key.NULL), "null" },
                    { nameof(Key.offline), "offline" },
                    { nameof(Key.OnAntiCheatTriggered), "{action} for {category} - {type}" },
                    { nameof(Key.online), "online" },
                    { nameof(Key.OxideGroups), "Oxide Groups" },
                    { nameof(Key.Pardoned), "Pardoned" },
                    { nameof(Key.permanently), "permanently" },
                    { nameof(Key.Played), "Played" },
                    { nameof(Key.remove), "remove" },
                    { nameof(Key.Removed), "Removed" },
                    { nameof(Key.Saved), "Saved" },
                    { nameof(Key.Server), "Server" },
                    { nameof(Key.SERVER), "SERVER" },
                    { nameof(Key.Status), "Status" },
                    { nameof(Key.Steam), "Steam" },
                    { nameof(Key.SteamBanActive), "VAC Banned" },
                    { nameof(Key.SteamBanCommunity), "Community Banned" },
                    { nameof(Key.SteamBanDays), "Days Since Ban" },
                    { nameof(Key.SteamBanEconomy), "Economy Banned" },
                    { nameof(Key.SteamBanGame), "Game Bans" },
                    { nameof(Key.SteamBanVAC), "VAC Bans" },
                    { nameof(Key.SteamGameCount), "Game Count" },
                    { nameof(Key.SteamGameHours), "Hours Played" },
                    { nameof(Key.SteamID), "SteamID" },
                    { nameof(Key.SteamProfileInvalid), "Invalid Profile" },
                    { nameof(Key.SteamProfileLimited), "Limited Profile" },
                    { nameof(Key.SteamProfilePrivate), "Private Profile" },
                    { nameof(Key.SteamShareFamily), "Family Share" },
                    { nameof(Key.True), "True" },
                    { nameof(Key.Unbanned), "Unbanned" },
                    { nameof(Key.Unblocked), "Unblocked" },
                    { nameof(Key.Uncrippled), "Uncrippled" },
                    { nameof(Key.unknown), "unknown" },
                    { nameof(Key.UnknownKey), "<color=#ffc0c0><size=12>Text error: language={language}]; key={key}</size></color>" },
                    { nameof(Key.UserAction), "<color=#ffc000><size=12>{actor}: {action} {playername}[{playerid}]</size></color>" },
                    { nameof(Key.UserBanTeleport), "<color=#c0ffc0><size=12>A banned player was teleported to your location!</size></color>" },
                    { nameof(Key.UserBanTeleported), "<color=#c0ffc0><size=12>Teleported {playername}[{playerid}] to {victim}.</size></color>" },
                    { nameof(Key.UserConnectBanInherit), "<color=#ffff00><size=12>You are banned from this server (Inherited: {reason})</size></color>" },
                    { nameof(Key.UserConnectSteamIdInvalid), "<color=#ffff00><size=12>Connection denied (SteamID: Invalid)</size></color>" },
                    { nameof(Key.UserConnectIpBlocked), "<color=#ffff00><size=12>Connection denied (IP: Blocked)</size></color>" },
                    { nameof(Key.UserInfoText), "<color=#c0c0ff><size=12>{info}</size></color>" },
                    { nameof(Key.UserInfoTextBullet), "<color=#c0c0ff><size=12>\n    - {info}</size></color>" },
                    { nameof(Key.UserInfoTextLabel), "<color=#c0c0ff><size=12>\n    {label}: {info}</size></color>" },
                    { nameof(Key.UserPardonProgress), "<size=12><color=#ffc000>Pardoned users: </color><color=#ffffc0>{count}/{total}</color></size>" },
                    { nameof(Key.Violation), "<color=#ffffc0><size=12>{action} {playername}[{playerid}] for {category}({type}): {details}</size></color>" },
                    { nameof(Key.ViolationAim), "<color=#ffffc0><size=12>{target}, {weapon}, {bodypart}, {distance}m, {angle}deg</size></color>" },
                    { nameof(Key.ViolationFireRate), "<color=#ffffc0><size=12>{weapon}, {delay}s</size></color>" },
                    { nameof(Key.ViolationGravity), "<color=#ffffc0><size=12>{amount}m</size></color>" },
                    { nameof(Key.ViolationMeleeRate), "<color=#ffffc0><size=12>{weapon}, {delay}s, {target}</size></color>" },
                    { nameof(Key.ViolationRecoil), "<color=#ffffc0><size=12>{weapon}, yaw={yaw}, pitch={pitch}</size></color>" },
                    { nameof(Key.ViolationStash), "<color=#ffffc0><size=12>{grid}{position}</size></color>" },
                    { nameof(Key.ViolationTrajectory), "<color=#ffffc0><size=12>{weapon}, {distance}m, {reported}m</size></color>" },
                    { nameof(Key.ViolationWallHack), "<color=#ffffc0><size=12>{weapon}, {target}</size></color>" },
                    { nameof(Key.VPN), "VPN" },
                    { nameof(Key.VpnCache), "VPN Cache" },
                    { nameof(Key.VpnDetected), "<color=#ffc000><size=12>VPN: Detected</size></color>" },
                    { nameof(Key.Warning), "Warning" }
                }, _instance, "en");
            }

            private static string Replace(string message, Dictionary<string, string> parameters = null)
            {
                if((message != null) && (parameters != null))
                {
                    foreach(var entry in parameters)
                    {
                        message = message.Replace('{' + entry.Key + '}', entry.Value);
                    }
                }

                return message;
            }

            private static string Strip(string message)
            {
                if(string.IsNullOrEmpty(message))
                {
                    return string.Empty;
                }

                return RegEx.markup.Replace(message, (match) =>
                {
                    var tag = match.Value.ToLower();

                    switch(tag)
                    {
                    case "<b>":
                    case "<i>":
                    case "</b>":
                    case "</color>":
                    case "</i>":
                    case "</size>":
                        return string.Empty;
                    }

                    if(tag.StartsWith("<color=") || tag.StartsWith("<size="))
                    {
                        return string.Empty;
                    }

                    return match.Value;
                });
            }

            public static string Sanitize(string message)
            {
                if(string.IsNullOrEmpty(message))
                {
                    return string.Empty;
                }

                message = RegEx.clean1.Replace(message, " ");
                message = RegEx.clean2.Replace(message, " ");

                return Trim(message);
            }

            private static string Trim(string message)
            {
                if(string.IsNullOrEmpty(message))
                {
                    return string.Empty;
                }

                return RegEx.spaces.Replace(message, " ").Trim();
            }

            public static void Unload()
            {
                RegEx.Unload();

                foreach(var language in decorated)
                {
                    language.Value.Clear();
                }

                decorated.Clear();

                foreach(var language in unadorned)
                {
                    language.Value.Clear();
                }

                unadorned.Clear();

                server_language = null;
            }
        }

        #endregion _text_

        #region _timers_

        private class Timers
        {
            private static readonly List<Timer> timers = new List<Timer>();

            public static void Add(float interval, Action callback)
            {
                timers.Add(_instance.timer.Every(interval, callback));
            }

            public static void Destroy()
            {
                foreach(var timer in timers)
                {
                    timer.Destroy();
                }

                timers.Clear();
            }
        }

        #endregion _timers_

        #region _user_

        private class User
        {
            public class Settings
            {
                public UserBypass Bypass;
                public UserFriend Friend;
                public UserTeam   Team;

                public Settings()
                {
                    Bypass = new UserBypass();
                    Friend = new UserFriend();
                    Team   = new UserTeam();
                }

                public class UserBypass
                {
                    public ulong DaysSinceBan;
                    public bool  Enabled;
                    public ulong HoursPlayed;
                    public bool  Multiply;

                    public UserBypass()
                    {
                        DaysSinceBan = 10ul;
                        HoursPlayed  =  6ul;
                    }

                    public void Validate()
                    {
                        Configuration.Clamp(ref DaysSinceBan, 1ul,  365ul);
                        Configuration.Clamp(ref HoursPlayed,  1ul, 8760ul);
                    }
                }

                public class UserFriend
                {
                    public bool Damage;
                }

                public class UserTeam
                {
                    public bool Damage;
                }

                public void Validate()
                {
                    Configuration.Validate(ref Bypass, () => new UserBypass(), () => Bypass.Validate());
                    Configuration.Validate(ref Friend, () => new UserFriend());
                    Configuration.Validate(ref Team,   () => new UserTeam());
                }
            }

            private class Info
            {
                public ulong           userid;
                public string          name;
                public HashSet<string> names;
                public string          address;
                public HashSet<string> addresses;

                public DateTime time_connected;
                public DateTime time_disconnected;
                public TimeSpan time_played;

                public ulong    ban_count;
                public string   ban_reason;
                public DateTime ban_time;
                public DateTime ban_timer;
                public bool     is_banned;

                public ulong    cripple_count;
                public string   cripple_reason;
                public DateTime cripple_time;
                public DateTime cripple_timer;
                public bool     is_crippled;

                public Vector3 l_position;
                public Vector3 v_position;

                [JsonIgnore] public DateTime     access_time;
                [JsonIgnore] public ulong        attacked;
                [JsonIgnore] public ulong        attacker;
                [JsonIgnore] public bool         dirty;
                [JsonIgnore] public BasePlayer   player;
                [JsonIgnore] public Stack<ulong> teleport;
                [JsonIgnore] public List<ulong>  victims;

                public Info()
                {
                    userid = 0;

                    name      = string.Empty;
                    names     = new HashSet<string>();
                    address   = string.Empty;
                    addresses = new HashSet<string>();

                    time_connected    = DateTime.MaxValue;
                    time_disconnected = DateTime.MinValue;
                    time_played       = TimeSpan.Zero;

                    ban_count  = 0;
                    ban_reason = string.Empty;
                    ban_time   = DateTime.MaxValue;
                    ban_timer  = DateTime.MinValue;
                    is_banned  = false;

                    cripple_count  = 0;
                    cripple_reason = string.Empty;
                    cripple_time   = DateTime.MaxValue;
                    cripple_timer  = DateTime.MinValue;
                    is_crippled    = false;

                    l_position = Vector3.zero;
                    v_position = Vector3.zero;

                    attacked = 0;
                    attacker = 0;
                    victims  = new List<ulong>();

                    dirty = true;
                }
            }

            private static readonly DataFile<string, HashSet<ulong>> names = new DataFile<string, HashSet<ulong>>("user_names");

            private static ActionQueue teleport;

            private static readonly Dictionary<ulong, Info> users = new Dictionary<ulong, Info>();

            private static void Action(IPlayer actor, Key action, Info user = null)
            {
                var parameters = new Dictionary<string, string>
                {
                    { "action", Text.GetPlain(action) },
                    { "actor", Text.Actor(actor) },
                    { "playerid", user?.userid.ToString() ?? "*" },
                    { "playername", Text.Sanitize(user?.name ?? Text.GetPlain(Key.AllUsers)) }
                };

                Log.Console(Key.UserAction, parameters);

                if(config.Admin.Broadcast)
                {
                    foreach(var player in BasePlayer.activePlayerList)
                    {
                        if(Permissions.Admin(player.userID))
                        {
                            parameters["action"]     = Text.GetPlain(action, player);
                            parameters["actor"]      = Text.Actor(actor, player);
                            parameters["playername"] = Text.Sanitize(user?.name ?? Text.GetPlain(Key.AllUsers, player));

                            Chat.Send(player, Key.UserAction, parameters);
                        }
                    }
                }
            }

            public static string Address(ulong userid)
            {
                return Load(userid).address;
            }

            public static void AssignAttacker(BasePlayer attacker, BasePlayer victim)
            {
                if((attacker == null) || attacker.IsAdmin || victim.IsAdmin || !victim.IsConnected)
                {
                    return;
                }

                if((attacker == victim) || (victim.lastDamage == DamageType.Bleeding))
                {
                    return;
                }

                if(IsTeamMate(attacker, victim) || IsFriend(attacker, victim.userID))
                {
                    return;
                }

                Load(attacker.userID).attacked = victim.userID;

                Load(victim.userID).attacker = attacker.userID;
            }

            public static void AssignVictim(BasePlayer victim)
            {
                var user = Load(victim.userID);

                if(victim.IsConnected && (user.attacker != 0))
                {
                    var attacker = Load(user.attacker);

                    attacker.victims.Remove(victim.userID);
                    attacker.victims.Add(victim.userID);
                }

                user.attacker = 0;
            }
            private static void AssignVictims(Info user)
            {
                user.teleport = new Stack<ulong>();

                if((user.attacked != 0) && !user.victims.Contains(user.attacked))
                {
                    user.teleport.Push(user.attacked);

                    user.attacked = 0;
                }

                foreach(var victim in user.victims)
                {
                    user.teleport.Push(victim);
                }

                user.victims.Clear();
            }

            public static void Ban(ulong userid, string reason = null, ulong seconds = 0, IPlayer actor = null)
            {
                var user = Load(userid);

                if(user.is_banned)
                {
                    if(actor == null)
                    {
                        return;
                    }

                    user.is_banned = false;

                    _instance.server.Command("unban", user.userid.ToString());
                }
                else
                {
                    user.ban_count++;
                }

                _instance.NextTick(() =>
                {
                    user.ban_reason = string.IsNullOrEmpty(reason) ? Text.GetPlain(Key.NoReasonGiven) : reason;
                    user.ban_time   = DateTime.UtcNow;
                    user.ban_timer  = (seconds == 0) ? DateTime.MaxValue : user.ban_time.AddSeconds(seconds);
                    user.is_banned  = true;

                    user.dirty = true;

                    Action(actor, Key.Banned, user);

                    _instance.server.Command("banid", user.userid.ToString(), user.name, user.ban_reason);
                });
            }

            public static ulong BanCount(ulong userid)
            {
                return Load(userid).ban_count;
            }

            private static void BanInherit(ulong userid, string name, string address, Info copy)
            {
                var user = Load(userid);

                Update(user, name, address);

                user.ban_count  = copy.ban_count;
                user.ban_reason = copy.ban_reason;
                user.ban_time   = copy.ban_time;
                user.ban_timer  = copy.ban_timer;
                user.is_banned  = copy.is_banned;

                user.time_connected    = DateTime.UtcNow;
                user.time_disconnected = user.time_connected;

                user.dirty = true;

                Action(null, Key.Banned, user);

                _instance.server.Command("banid", user.userid.ToString(), user.name, user.ban_reason);
            }

            public static void BanReset(ulong userid, IPlayer actor = null)
            {
                var user = Load(userid);

                var was_banned = user.is_banned;

                user.ban_count  = 0;
                user.ban_reason = string.Empty;
                user.ban_time   = DateTime.MaxValue;
                user.ban_timer  = DateTime.MinValue;
                user.is_banned  = false;

                user.dirty = true;

                Action(actor, Key.BanReset, user);

                if(was_banned)
                {
                    _instance.server.Command("unban", user.userid.ToString());
                }
            }

            private static void BanTeleport(Info user, ulong count = 0)
            {
                Info victim = null;

                while((victim == null) && (user.teleport.Count > 0))
                {
                    victim = Load(user.teleport.Peek());

                    if(!(victim.player?.IsConnected ?? false))
                    {
                        count = 0; victim = null;

                        user.teleport.Pop();
                    }
                }

                if(victim == null)
                {
                    return;
                }

                user.access_time = DateTime.UtcNow;

                if(victim.player.IsSleeping() || victim.player.IsDead() || victim.player.HasParent())
                {
                    if(count < 10)
                    {
                        teleport.Enqueue(() => BanTeleport(user, count + 1));
                    }
                    else
                    {
                        user.teleport.Pop();

                        if(user.teleport.Count > 0)
                        {
                            teleport.Enqueue(() => BanTeleport(user));
                        }
                    }

                    return;
                }

                var attacker = BasePlayer.FindAwakeOrSleeping(user.userid.ToString());

                if(attacker == null)
                {
                    return;
                }

                var position = attacker.transform.position; position.y += 0.1f;

                RaycastHit hit;

                if(Physics.Raycast(position, Vector3.down, out hit))
                {
                    position.y -= hit.distance;
                }

                attacker.MovePosition(position);

                attacker.ClientRPCPlayer(null, attacker, "ForcePositionTo", position);

                attacker.SendNetworkUpdateImmediate();

                Chat.Admin(Key.UserBanTeleported, new Dictionary<string, string>
                {
                    { "playerid", user.userid.ToString() },
                    { "playername", Text.Sanitize(user.name) },
                    { "victim", Text.Sanitize(victim.name) }
                });

                Chat.Send(victim.player, Key.UserBanTeleport);
            }

            public static DateTime BanTime(ulong userid)
            {
                return Load(userid).ban_time;
            }

            private static void BanTimeEnforce(Info user)
            {
                if(!config.Ban.Time.Enforce)
                {
                    return;
                }

                var seconds = 0ul;

                if(config.Ban.Time.Seconds > 0)
                {
                    seconds = config.Ban.Time.Seconds;

                    if(config.Ban.Time.Multiply)
                    {
                        seconds *= user.ban_count;
                    }
                }

                if(seconds == 0)
                {
                    user.ban_timer = DateTime.MaxValue;
                }
                else
                {
                    user.ban_timer = user.ban_time.AddSeconds(seconds);
                }

                user.dirty = true;
            }

            private static bool CanBypass(Info user)
            {
                if(Permissions.Ignore(user.userid) || (config.Admin.Bypass && Permissions.Admin(user.userid)))
                {
                    return true;
                }
                else if(!config.User.Bypass.Enabled)
                {
                    return false;
                }

                bool never_banned = true;

                var days_since_banned = 0.0;

                var date_current = DateTime.UtcNow;

                var time_banned = TimeSpan.MaxValue;

                if(user.ban_time < date_current)
                {
                    time_banned = date_current.Subtract(user.ban_time);

                    days_since_banned = time_banned.TotalDays;

                    never_banned = false;
                }

                var time_played = TimePlayed(user);

                var hours_played = time_played.TotalHours;

                bool bypass = false;

                var days_banned_minimum  = config.User.Bypass.DaysSinceBan;
                var hours_played_minimum = config.User.Bypass.HoursPlayed;

                if(config.User.Bypass.Multiply)
                {
                    var multiplier = user.ban_count + 1;

                    days_banned_minimum  *= multiplier;
                    hours_played_minimum *= multiplier;
                }

                if(hours_played >= hours_played_minimum)
                {
                    bypass = never_banned || (days_since_banned >= days_banned_minimum);
                }

                if(config.Log.User.Bypass)
                {
                    Log.Console(Key.LogUserBypass, new Dictionary<string, string>
                    {
                        { "address", user.address },
                        { "bantime", never_banned ? Text.Get(Key.never) : $"{Text.Duration.Short(time_banned)} {Text.Get(Key.ago)}" },
                        { "playerid", user.userid.ToString() },
                        { "playername", Text.Sanitize(user.name) },
                        { "playtime", Text.Duration.Hours(time_played) },
                        { "status", bypass ? Text.Get(Key.Allowed) : Text.Get(Key.Denied) }
                    });
                }

                return bypass;
            }

            public static object CanConnect(string name, string id, string address)
            {
                if(IP.Cooldown(address))
                {
                    return Text.GetPlain(Key.IpCooldown);
                }

                ulong userid;

                if(!id.StartsWith("7656119") || !ulong.TryParse(id, out userid))
                {
                    if(config.Log.User.Connect)
                    {
                        Log.Console(Key.LogConnect, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Denied) },
                            { "playerid", id },
                            { "playername", Text.Sanitize(name) },
                            { "reason", address },
                            { "type", Text.GetPlain(Key.InvalidSteamId) }
                        });
                    }

                    return Text.GetPlain(Key.UserConnectSteamIdInvalid, Text.Language(id));
                }

                if(Permissions.Ignore(userid, true))
                {
                    return null;
                }

                else if(Permissions.Admin(userid, true) && config.Admin.Bypass)
                {
                    return null;
                }

                if(!IP.Filter(address, userid))
                {
                    if(config.Log.User.Connect)
                    {
                        Log.Console(Key.LogConnect, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Denied) },
                            { "playerid", id },
                            { "playername", Text.Sanitize(name) },
                            { "reason", address },
                            { "type", Text.GetPlain(Key.Blocked) }
                        });
                    }

                    return Text.GetPlain(Key.UserConnectIpBlocked, userid);
                }

                var cripple_inherit = config.Cripple.Inherit && !IsCrippled(userid);

                if(config.Ban.Inherit || cripple_inherit)
                {
                    var userids = IP.Find(address);

                    if(cripple_inherit)
                    {
                        foreach(var entry in userids)
                        {
                            var user = Load(entry);

                            if(user.is_crippled)
                            {
                                _instance.NextTick(() => CrippleInherit(userid, name, address, user));

                                break;
                            }
                        }
                    }

                    if(config.Ban.Inherit)
                    {
                        foreach(var entry in userids)
                        {
                            var user = Load(entry);

                            if(user.is_banned)
                            {
                                if(config.Log.User.Connect)
                                {
                                    Log.Console(Key.LogConnect, new Dictionary<string, string>
                                    {
                                        { "action", Text.GetPlain(Key.Denied) },
                                        { "playerid", id },
                                        { "playername", Text.Sanitize(name) },
                                        { "reason", user.ban_reason },
                                        { "type", Text.GetPlain(Key.BanInherited) }
                                    });
                                }

                                _instance.NextTick(() => BanInherit(userid, name, address, user));

                                return Text.GetPlain(Key.UserConnectBanInherit, userid, new Dictionary<string, string>
                                {
                                    { "reason", user.ban_reason }
                                });
                            }
                        }
                    }
                }

                return null;
            }

            public static bool CanFly(BasePlayer player) =>
                HasAuthLevel(player) || HasAdminFlag(player) || HasDeveloperFlag(player);

            private static bool CanLoot(ulong userid, ulong targetid)
            {
                if(userid == targetid)
                {
                    return true;
                }

                if(IsCrippled(userid))
                {
                    if(Permissions.Ignore(userid) || Permissions.Admin(userid))
                    {
                        return true;
                    }

                    return false;
                }

                return true;
            }
            public static object CanLoot(BasePlayer player, ulong targetid)
            {
                if(ShouldIgnore(player) || CanLoot(player.userID, targetid))
                {
                    return null;
                }

                return false;
            }

            public static void Cripple(ulong userid, string reason = null, ulong seconds = 0, IPlayer actor = null)
            {
                var user = Load(userid);

                if(!user.is_crippled)
                {
                    user.cripple_count++;
                }

                user.cripple_reason = string.IsNullOrEmpty(reason) ? Text.GetPlain(Key.NoReasonGiven) : reason;
                user.cripple_time   = DateTime.UtcNow;
                user.cripple_timer  = (seconds == 0) ? DateTime.MaxValue : user.cripple_time.AddSeconds(seconds);

                user.is_crippled = true;

                user.dirty = true;

                Action(actor, Key.Crippled, user);
            }

            private static void CrippleInherit(ulong userid, string name, string address, Info copy)
            {
                var user = Load(userid);

                Update(user, name, address);

                user.cripple_count  = copy.cripple_count;
                user.cripple_reason = copy.cripple_reason;
                user.cripple_time   = copy.cripple_time;
                user.cripple_timer  = copy.cripple_timer;
                user.is_crippled    = copy.is_crippled;

                user.dirty = true;

                Action(null, Key.Crippled, user);
            }

            public static void CrippleReset(ulong userid, IPlayer actor = null)
            {
                var user = Load(userid);

                user.cripple_count  = 0;
                user.cripple_reason = string.Empty;
                user.cripple_time   = DateTime.MaxValue;
                user.cripple_timer  = DateTime.MinValue;
                user.is_crippled    = false;

                user.dirty = true;

                Action(actor, Key.CrippleReset, user);
            }

            public static bool Exists(ulong userid) =>
                users.ContainsKey(userid) || Data.Exists($"Users/{userid}");

            public static HashSet<ulong> Find(string text)
            {
                var found = new HashSet<ulong>();

                if(IP.IsValid(text))
                {
                    foreach(var userid in IP.Find(text))
                    {
                        found.Add(userid);
                    }
                }
                else if(text.IsSteamId())
                {
                    ulong userid;

                    if(ulong.TryParse(text, out userid) && Exists(userid))
                    {
                        found.Add(userid);
                    }
                }
                else
                {
                    var key = text.Sanitize();

                    if(names.Contains(key))
                    {
                        foreach(var userid in names[key])
                        {
                            found.Add(userid);
                        }
                    }
                    else
                    {
                        var search = key.ToLower();

                        names.ForEach((name, userids) =>
                        {
                            if(name.ToLower().Contains(search))
                            {
                                foreach(var userid in userids)
                                {
                                    found.Add(userid);
                                }
                            }
                        });
                    }
                }

                return found;
            }

            public static Vector3 GetLastSeenPosition(ulong userid)
            {
                var player = BasePlayer.FindAwakeOrSleeping(userid.ToString());

                if(player != null)
                {
                    return player.transform.position;
                }

                return Load(userid).l_position;
            }

            public static Vector3 GetViolationPosition(ulong userid) =>
                Load(userid).v_position;

            public static bool HasAuthLevel(BasePlayer player) =>
                (player?.net?.connection?.authLevel ?? 0) > 0;

            public static bool HasAdminFlag(BasePlayer player) =>
                player.HasPlayerFlag(BasePlayer.PlayerFlags.IsAdmin);

            private static bool HasConnected(Info user) =>
                user.time_connected != DateTime.MaxValue;

            public static bool HasDeveloperFlag(BasePlayer player) =>
                player.HasPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper);

            public static bool HasParent<T>(BasePlayer player) =>
                player.GetParentEntity() is T;

            public static string InfoText(ulong userid) =>
                InfoText(userid, Text.Language());
            public static string InfoText(ulong userid, BasePlayer player) =>
                InfoText(userid, Text.Language(player.UserIDString));
            public static string InfoText(ulong userid, IPlayer iplayer) =>
                InfoText(userid, Text.Language(iplayer.IsServer ? null : iplayer.Id));
            public static string InfoText(ulong userid, ulong playerid) =>
                InfoText(userid, Text.Language(playerid.ToString()));
            public static string InfoText(ulong userid, string language)
            {
                if(!Exists(userid))
                {
                    return Text.GetPlain(Key.unknown, language);
                }

                var user = Load(userid);

                var info = new StringBuilder();

                var parameters = new Dictionary<string, string>();

                parameters["label"] = Text.GetPlain(Key.SteamID, language);
                parameters["info"] = user.userid.ToString();
                info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));

                parameters["label"] = Text.GetPlain(Key.Name, language);
                parameters["info"] = Text.Sanitize(user.name);
                info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));
                if(user.names.Count > 1)
                {
                    foreach(var name in user.names)
                    {
                        if(name != user.name)
                        {
                            parameters["info"] = Text.Sanitize(name);
                            info.Append(Text.GetPlain(Key.UserInfoTextBullet, language, parameters));
                        }
                    }
                }

                parameters["label"] = Text.GetPlain(Key.Played, language);
                parameters["info"] = Text.Duration.Hours(TimePlayed(user), language);
                info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));

                parameters["label"] = Text.GetPlain(Key.Status, language);
                parameters["info"] = StatusText(user, language);
                info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));

                if(user.ban_count > 0)
                {
                    parameters["label"] = Text.GetPlain(Key.BanCount, language);
                    parameters["info"] = user.ban_count.ToString();
                    info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));

                    if(user.is_banned)
                    {
                        parameters["label"] = Text.GetPlain(Key.BanReason, language);
                        parameters["info"] = user.ban_reason;
                        info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));
                    }
                }

                if(user.cripple_count > 0)
                {
                    parameters["label"] = Text.GetPlain(Key.CrippleCount, language);
                    parameters["info"] = user.cripple_count.ToString();
                    info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));

                    if(user.is_crippled)
                    {
                        parameters["label"] = Text.GetPlain(Key.CrippleReason, language);
                        parameters["info"] = user.cripple_reason;
                        info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));
                    }
                }

                parameters["label"] = Text.GetPlain(Key.Address, language);
                parameters["info"] = user.address;
                info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));
                if(user.addresses.Count > 1)
                {
                    foreach(var address in user.addresses)
                    {
                        if(address != user.address)
                        {
                            parameters["info"] = address;
                            info.Append(Text.GetPlain(Key.UserInfoTextBullet, language, parameters));
                        }
                    }
                }

                parameters["label"] = Text.GetPlain(Key.OxideGroups, language);
                parameters["info"] = string.Join(", ", Permissions.Groups(user.userid));
                info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));

                parameters["info"] = info.ToString();
                return Text.GetPlain(Key.UserInfoText, language, parameters);
            }

            public static bool IsBanned(ulong userid) =>
                Load(userid).is_banned;

            private static bool IsConnected(Info user) =>
                user.player?.IsConnected ?? false;
            public static bool IsConnected(ulong userid)
            {
                Info user;

                if(users.TryGetValue(userid, out user))
                {
                    return IsConnected(user);
                }

                return false;
            }

            public static bool IsCrippled(ulong userid) =>
                Load(userid).is_crippled;

            public static bool IsFriend(BasePlayer a, BasePlayer b) =>
                IsFriend(a, b.userID);
            public static bool IsFriend(BasePlayer player, ulong userid) =>
                (_instance?.Friends?.Call<bool>("IsFriend", player.userID, userid) ?? false);

            public static bool IsInactive(BasePlayer player) =>
                player.IsDead() || player.IsSleeping() || !player.IsConnected;

            private static bool IsStale(Info user) =>
                !(HasConnected(user) && (user.time_connected > SaveRestore.SaveCreatedTime.ToUniversalTime()));

            public static bool IsTeamMate(BasePlayer a, BasePlayer b)
                => (a.currentTeam != 0) && (a.currentTeam == b.currentTeam);
            public static bool IsTeamMate(BasePlayer player, ulong userid)
            {
                var team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);

                return team?.members?.Contains(userid) ?? false;
            }

            public static void Kick(ulong userid, string reason = null, IPlayer actor = null)
            {
                var user = Load(userid);

                if(IsConnected(user))
                {
                    reason = string.IsNullOrEmpty(reason) ? Text.GetPlain(Key.NoReasonGiven) : reason;

                    if(actor != null)
                    {
                        Action(actor, Key.Kicked, user);
                    }

                    _instance.server.Command("kick", user.userid.ToString(), reason);
                }
            }

            public static void Load()
            {
                names.Load();

                teleport = new ActionQueue(6.0f);

                Timers.Add(6.0f, () => Scan());
            }
            private static Info Load(ulong userid)
            {
                Info user;

                if(!userid.IsSteamId())
                {
                    throw new ArgumentException("Parameter must be a valid Steam ID", nameof(userid));
                }
                else if(users.ContainsKey(userid))
                {
                    user = users[userid];
                }
                else
                {
                    try
                    {
                        user = Data.ReadObject<Info>($"Users/{userid}");

                        if((user?.userid ?? 0) == 0)
                        {
                            throw new Exception();
                        }
                    }
                    catch
                    {
                        user = new Info
                        {
                            dirty  = true,
                            userid = userid
                        };
                    }

                    if(user.name == null)
                    {
                        user.dirty = true; user.name = string.Empty;
                    }

                    if(user.names == null)
                    {
                        user.dirty = true; user.names = new HashSet<string>();
                    }

                    if(user.address == null)
                    {
                        user.dirty = true; user.address = string.Empty;
                    }

                    if(user.addresses == null)
                    {
                        user.dirty = true; user.addresses = new HashSet<string>();
                    }

                    if(user.ban_reason == null)
                    {
                        user.dirty = true; user.ban_reason = string.Empty;
                    }

                    if(user.cripple_reason == null)
                    {
                        user.dirty = true; user.cripple_reason = string.Empty;
                    }

                    if(IsStale(user))
                    {
                        SetLastSeenPosition(user, Vector3.zero);
                        SetViolationPosition(user, Vector3.zero);
                    }

                    users.Add(userid, user);

                    Save(user);
                }

                user.access_time = DateTime.UtcNow;

                return user;
            }

            public static string Name(ulong userid) =>
                Load(userid).name;

            public static void OnBanned(ulong userid, bool banned)
            {
                var user = Load(userid);

                if(banned)
                {
                    if(!user.is_banned)
                    {
                        var serveruser = ServerUsers.Get(userid);

                        user.ban_count++;
                        user.ban_reason = string.IsNullOrEmpty(serveruser.notes) ? Text.GetPlain(Key.NoReasonGiven) : serveruser.notes;
                        user.ban_time = DateTime.UtcNow;
                        user.is_banned = true;

                        if(serveruser.expiry < 0)
                        {
                            user.ban_timer = DateTime.MaxValue;
                        }
                        else
                        {
                            user.ban_timer = user.ban_time.AddSeconds(serveruser.expiry - Epoch.Current);
                        }

                        user.dirty = true;
                    }

                    BanTimeEnforce(user);

                    if(config.Ban.Teleport)
                    {
                        AssignVictims(user);

                        if(user.teleport.Count > 0)
                        {
                            _instance.timer.In(6.0f, () => BanTeleport(user));
                        }
                    }
                }
                else
                {
                    if(user.is_banned && config.Ban.Time.Enforce)
                    {
                        if((user.ban_timer != DateTime.MaxValue) && (user.ban_timer > DateTime.UtcNow))
                        {
                            _instance.server.Command("banid", user.userid.ToString(), user.name, user.ban_reason);

                            return;
                        }
                    }

                    if(user.ban_count == 0)
                    {
                        user.ban_time = DateTime.MaxValue;
                    }

                    user.ban_reason = string.Empty;
                    user.ban_timer  = DateTime.MinValue;
                    user.is_banned  = false;

                    user.dirty = true;
                }
            }

            public static void OnConnected(BasePlayer player)
            {
                var user = Load(player.userID);

                var connected = TimeSpan.FromSeconds(user.player?.net?.connection?.GetSecondsConnected() ?? 0.0f);

                user.time_connected = DateTime.UtcNow.Subtract(connected);

                if(user.is_banned)
                {
                    user.is_banned = false;

                    user.ban_reason = string.Empty;
                    user.ban_timer  = DateTime.MinValue;
                }

                if(_instance.PlaytimeTracker)
                {
                    var result = _instance.PlaytimeTracker.Call("GetPlayTime", player.UserIDString);

                    if(result != null)
                    {
                        var time_played = TimeSpan.FromSeconds(Convert.ToDouble(result));

                        if(time_played > user.time_played)
                        {
                            user.time_played = time_played;
                        }
                    }
                }

                user.player = player;

                Update(user, player.displayName, IP.Parse(player?.Connection?.ipaddress));

                user.dirty = true;

                Permissions.Update(user.userid);

                if(!CanBypass(user))
                {
                    Steam.Check(user.userid);

                    VPN.Check(user.address, user.userid);
                }
            }

            public static void OnDisconnected(BasePlayer player)
            {
                var user = Load(player.userID);

                user.time_disconnected = DateTime.UtcNow;

                if(user.time_disconnected > user.time_connected)
                {
                    user.time_played += user.time_disconnected.Subtract(user.time_connected);
                }

                user.player = null;

                SetLastSeenPosition(user, player.transform.position);

                user.dirty = true;

                Permissions.Reset(user.userid);
            }

            public static void OnLoot(BasePlayer player, ulong targetid)
            {
                if(ShouldIgnore(player))
                {
                    return;
                }

                if(!CanLoot(player.userID, targetid))
                {
                    _instance.NextFrame(() => player.EndLooting());
                }
            }

            public static void Pardon(ulong userid, IPlayer actor = null) =>
                Pardon(Load(userid), actor);
            public static void Pardon(IPlayer actor)
            {
                var found = new HashSet<ulong>();

                names.ForEach((name, userids) =>
                {
                    found.UnionWith(userids);
                });

                var userid = new Queue<ulong>(found);

                Pardon(userid, actor);
            }
            private static void Pardon(Queue<ulong> userid, IPlayer actor, int total = 0)
            {
                if(total == 0)
                {
                    total = userid.Count;
                }

                if(userid.Count > 0)
                {
                    var user = Load(userid.Dequeue());

                    Pardon(user, actor, false);

                    Save(user);

                    var count = total - userid.Count;

                    if((count % ((total <= 100) ? 10 : 100)) == 0)
                    {
                        Chat.Reply(actor, Key.UserPardonProgress, new Dictionary<string, string>
                        {
                            { "count", count.ToString() },
                            { "total", total.ToString() }
                        });
                    }

                    _instance.NextTick(() => Pardon(userid, actor, total));
                }
                else
                {
                    if(total > 0)
                    {
                        Chat.Reply(actor, Key.UserPardonProgress, new Dictionary<string, string>
                        {
                            { "count", total.ToString() },
                            { "total", total.ToString() }
                        });
                    }

                    Action(actor, Key.Pardoned);
                }
            }
            private static void Pardon(Info user, IPlayer actor, bool broadcast = true)
            {
                if(user.is_banned)
                {
                    if(user.ban_count > 1)
                    {
                        user.dirty = true; user.ban_count = 1;

                        BanTimeEnforce(user);
                    }
                }
                else
                {
                    if(user.ban_count != 0)
                    {
                        user.dirty = true; user.ban_count = 0;
                    }

                    if(user.ban_time != DateTime.MaxValue)
                    {
                        user.dirty = true; user.ban_time = DateTime.MaxValue;
                    }

                    if(user.ban_timer != DateTime.MinValue)
                    {
                        user.dirty = true; user.ban_timer = DateTime.MinValue;
                    }
                }

                if(user.is_crippled)
                {
                    if(user.cripple_count > 1)
                    {
                        user.dirty = true; user.cripple_count = 1;
                    }
                }
                else
                {
                    if(user.cripple_count != 0)
                    {
                        user.dirty = true; user.cripple_count = 0;
                    }

                    if(user.cripple_time != DateTime.MaxValue)
                    {
                        user.dirty = true; user.cripple_time = DateTime.MaxValue;
                    }

                    if(user.cripple_timer != DateTime.MinValue)
                    {
                        user.dirty = true; user.cripple_timer = DateTime.MinValue;
                    }
                }

                if(broadcast)
                {
                    Action(actor, Key.Pardoned, user);
                }
            }

            public static void Save()
            {
                var current = DateTime.UtcNow;

                var expired = TimeSpan.FromMinutes(30.0);

                var remove = new List<ulong>();

                foreach(var entry in users)
                {
                    Save(entry.Value);

                    if(current.Subtract(entry.Value.access_time) >= expired)
                    {
                        remove.Add(entry.Key);
                    }
                }

                foreach(var entry in remove)
                {
                    users.Remove(entry);
                }

                names.Save();
            }
            private static void Save(Info user)
            {
                if(user.dirty)
                {
                    user.dirty = false;

                    Data.WriteObject($"Users/{user.userid}", user);
                }
            }

            private static void Scan()
            {
                var current = DateTime.UtcNow;

                foreach(var entry in users)
                {
                    var user = entry.Value;

                    if(user.is_banned && (user.ban_timer != DateTime.MaxValue))
                    {
                        if(user.ban_timer > current)
                        {
                            user.access_time = current;
                        }
                        else
                        {
                            Unban(user.userid);
                        }
                    }
                    else if(user.is_crippled && (user.cripple_timer != DateTime.MaxValue))
                    {
                        if(user.cripple_timer > current)
                        {
                            user.access_time = current;
                        }
                        else
                        {
                            Uncripple(user.userid);
                        }
                    }
                }
            }

            private static void SetLastSeenPosition(Info user, Vector3 position)
            {
                if(user.l_position != position)
                {
                    user.l_position = position;

                    user.dirty = true;
                }
            }

            private static void SetViolationPosition(Info user, Vector3 position)
            {
                if(user.v_position != position)
                {
                    user.v_position = position;

                    user.dirty = true;
                }
            }
            public static void SetViolationPosition(ulong userid)
            {
                Info user;

                if(users.TryGetValue(userid, out user))
                {
                    if(user.player != null)
                    {
                        SetViolationPosition(user, user.player.transform.position);
                    }
                }
            }

            public static bool ShouldIgnore(BasePlayer player) =>
                (player == null) || !player.userID.IsSteamId() || Permissions.Ignore(player.userID);

            public static string StatusText(ulong userid) =>
                StatusText(userid, Text.Language());
            public static string StatusText(ulong userid, BasePlayer player) =>
                StatusText(userid, Text.Language(player.UserIDString));
            public static string StatusText(ulong userid, IPlayer iplayer) =>
                StatusText(userid, Text.Language(iplayer.IsServer ? null : iplayer.Id));
            public static string StatusText(ulong userid, ulong playerid) =>
                StatusText(userid, Text.Language(playerid.ToString()));
            public static string StatusText(ulong userid, string language) =>
                Exists(userid) ? StatusText(Load(userid), language) : Text.GetPlain(Key.unknown, language);
            private static string StatusText(Info user, string language)
            {
                StringBuilder status = new StringBuilder();

                TimeSpan duration;

                if(user.is_banned)
                {
                    status.Append(Text.GetPlain(Key.banned, language));
                    status.Append(' ');

                    if(TimeSpan.MaxValue == (duration = TimeBanned(user)))
                    {
                        status.Append(Text.GetPlain(Key.permanently, language));
                    }
                    else
                    {
                        status.Append(Text.Duration.Short(duration, language));
                    }
                }
                else if(user.is_crippled)
                {
                    status.Append(Text.GetPlain(Key.crippled, language));
                    status.Append(' ');

                    if(TimeSpan.MaxValue == (duration = TimeCrippled(user)))
                    {
                        status.Append(Text.GetPlain(Key.permanently, language));
                    }
                    else
                    {
                        status.Append(Text.Duration.Short(duration, language));
                    }
                }
                else if(user.player?.IsConnected ?? false)
                {
                    status.Append(Text.GetPlain(Key.online, language));
                    status.Append(' ');

                    if(TimeSpan.MaxValue == (duration = TimeOnline(user)))
                    {
                        status.Append(Text.GetPlain(Key.never, language));
                    }
                    else
                    {
                        status.Append(Text.Duration.Short(duration, language));
                    }
                }
                else
                {
                    status.Append(Text.GetPlain(Key.offline, language));
                    status.Append(' ');

                    if(TimeSpan.MaxValue == (duration = TimeOffline(user)))
                    {
                        status.Append(Text.GetPlain(Key.never, language));
                    }
                    else
                    {
                        status.Append(Text.Duration.Short(duration, language));
                    }
                }

                return status.ToString();
            }

            public static List<ulong> Team(ulong userid)
            {
                ulong teamid = 0;

                var player = Load(userid).player;

                if(player != null)
                {
                    teamid = player.currentTeam;
                }
                else
                {
                    foreach(var team in RelationshipManager.ServerInstance.teams)
                    {
                        if(team.Value.members.Contains(userid))
                        {
                            teamid = team.Key;

                            break;
                        }
                    }
                }

                if(teamid != 0)
                {
                    return new List<ulong>(RelationshipManager.ServerInstance.teams[teamid].members);
                }

                return new List<ulong> { userid };
            }

            public static TimeSpan TimeBanned(ulong userid) =>
                TimeRemaining(Load(userid).ban_timer);
            private static TimeSpan TimeBanned(Info user) =>
                TimeRemaining(user.ban_timer);
            public static TimeSpan TimeCrippled(ulong userid) =>
                TimeRemaining(Load(userid).cripple_timer);
            private static TimeSpan TimeCrippled(Info user) =>
                TimeRemaining(user.cripple_timer);
            private static TimeSpan TimeRemaining(DateTime time)
            {
                if(time == DateTime.MaxValue)
                {
                    return TimeSpan.MaxValue;
                }

                var current = DateTime.UtcNow;

                if(time > current)
                {
                    return time.Subtract(current);
                }

                return TimeSpan.Zero;
            }

            public static TimeSpan TimeOffline(ulong userid) =>
                TimeSpent(Load(userid).time_disconnected);
            private static TimeSpan TimeOffline(Info user) =>
                TimeSpent(user.time_disconnected);
            public static TimeSpan TimeOnline(ulong userid) =>
                TimeSpent(Load(userid).time_connected);
            private static TimeSpan TimeOnline(Info user) =>
                TimeSpent(user.time_connected);
            private static TimeSpan TimeSpent(DateTime time)
            {
                if((time == DateTime.MaxValue) || (time == DateTime.MinValue))
                {
                    return TimeSpan.MaxValue;
                }

                var current = DateTime.UtcNow;

                if(time < current)
                {
                    return current.Subtract(time);
                }

                return TimeSpan.Zero;
            }

            public static TimeSpan TimePlayed(ulong userid) =>
                TimePlayed(Load(userid));
            private static TimeSpan TimePlayed(Info user)
            {
                var time_played = user.time_played;

                if(user.time_disconnected > user.time_connected)
                {
                    time_played += user.time_disconnected.Subtract(user.time_connected);
                }
                else if(user.player?.IsConnected ?? false)
                {
                    time_played += DateTime.UtcNow.Subtract(user.time_connected);
                }

                return time_played;
            }

            public static void Unban(ulong userid, bool manual = false, IPlayer actor = null) =>
                Unban(Load(userid), manual, actor);
            public static void Unban(IPlayer actor)
            {
                foreach(var entry in users)
                {
                    var user = entry.Value;

                    if(user.is_banned)
                    {
                        Unban(user, false, actor, false);
                    }
                }

                Action(actor, Key.Unbanned);
            }
            private static void Unban(Info user, bool manual, IPlayer actor, bool broadcast = true)
            {
                if(user.is_banned)
                {
                    if(manual)
                    {
                        user.ban_count -= (user.ban_count > 0) ? 1ul : 0ul;
                    }

                    user.is_banned = false;

                    user.dirty = true;

                    if(broadcast)
                    {
                        Action(actor, Key.Unbanned, user);
                    }

                    _instance.server.Command("unban", user.userid.ToString());
                }
            }

            public static void Uncripple(ulong userid, bool manual = false, IPlayer actor = null) =>
                Uncripple(Load(userid), manual, actor);
            public static void Uncripple(IPlayer actor)
            {
                foreach(var entry in users)
                {
                    var user = entry.Value;

                    if(user.is_crippled)
                    {
                        Uncripple(user, false, actor, false);
                    }
                }

                Action(actor, Key.Uncrippled);
            }
            private static void Uncripple(Info user, bool manual, IPlayer actor, bool broadcast = true)
            {
                if(user.is_crippled)
                {
                    if(manual)
                    {
                        user.cripple_count -= (user.cripple_count > 0) ? 1ul : 0ul;
                    }

                    user.cripple_reason = string.Empty;
                    user.cripple_timer = DateTime.MinValue;

                    user.is_crippled = false;

                    user.dirty = true;

                    if(broadcast)
                    {
                        Action(actor, Key.Uncrippled, user);
                    }
                }
            }

            public static void Unload()
            {
                foreach(var player in BasePlayer.activePlayerList)
                {
                    if(player.IsConnected)
                    {
                        OnDisconnected(player);
                    }
                }

                foreach(var player in BasePlayer.sleepingPlayerList)
                {
                    if(player.IsConnected)
                    {
                        OnDisconnected(player);
                    }
                }

                Save();

                names.Unload();
                users.Clear();

                teleport.Clear();
                teleport = null;
            }

            public static void Update()
            {
                _instance.NextTick(() =>
                {
                    foreach(var player in BasePlayer.activePlayerList)
                    {
                        if(player.IsConnected)
                        {
                            OnConnected(player);
                        }
                    }

                    foreach(var player in BasePlayer.sleepingPlayerList)
                    {
                        if(player.IsConnected)
                        {
                            OnConnected(player);
                        }
                    }

                    foreach(var serveruser in ServerUsers.GetAll(ServerUsers.UserGroup.Banned))
                    {
                        OnBanned(serveruser.steamid, true);
                    }
                });
            }
            private static void Update(Info user, string name, string address)
            {
                if(user.name != name)
                {
                    user.dirty = true; user.name = name;
                }

                if(user.names.Add(name))
                {
                    user.dirty = true;
                }

                if(!names.Contains(name))
                {
                    names.Add(name, new HashSet<ulong>());
                }

                if(names[name].Add(user.userid))
                {
                    names.SetDirty();
                }

                if(!string.IsNullOrEmpty(address = address ?? user.address))
                {
                    if(user.address != address)
                    {
                        user.dirty = true; user.address = address;
                    }

                    if(user.addresses.Add(address))
                    {
                        user.dirty = true;
                    }

                    IP.Update(address, user.userid);
                }
            }
        }

        #endregion _user_

        #region _version_

        private new class Version
        {
            public class Settings
            {
                public int Major;
                public int Minor;
                public int Patch;

                public Settings()
                {
                    Major = Minor = Patch = 0;
                }

                public int Compare(int major, int minor, int patch)
                {
                    return
                        (Major != major) ? (Major - major) :
                        (Minor != minor) ? (Minor - minor) :
                        (Patch != patch) ? (Patch - patch) : 0;
                }

                public void Validate()
                {
                    var current = (_instance as CovalencePlugin).Version;

                    if(Compare(current.Major, current.Minor, current.Patch) < 0)
                    {
                        Configuration.SetDirty();

                        Major = current.Major;
                        Minor = current.Minor;
                        Patch = current.Patch;

                        Configuration.SetUpgrade();
                    }
                    else
                    {
                        Configuration.SetUpgrade(false);
                    }

                    String = $"{Major}.{Minor}.{Patch}";
                }
            }

            public static string String { get; protected set; }
        }

        #endregion _version_

        #region _violation_

        private class Violation
        {
            public class Settings
            {
                public bool  Ban;
                public ulong Cooldown;
                public float Sensitivity;
                public bool  Warn;

                public Settings(bool ban = true, ulong cooldown = 7200, float sensitivity = 0.5f, bool warn = false)
                {
                    Ban         = ban;
                    Cooldown    = cooldown;
                    Sensitivity = sensitivity;
                    Warn        = warn;
                }

                public ulong Count(ulong min, ulong max, bool squared = false)
                {
                    if(squared)
                    {
                        return min + (ulong)((max - min) * (1.0f - Sensitivity * Sensitivity));
                    }
                    else
                    {
                        return min + (ulong)((max - min) * (1.0f - Sensitivity));
                    }
                }

                public Settings Validate(ulong max)
                {
                    Configuration.Clamp(ref Cooldown,     1ul,  max);
                    Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                    return this;
                }
            }

            private bool     ban;
            private Key      category;
            private ulong    cooldown;
            private ulong    count;
            private TimeSpan rate;
            private bool     warn;

            private Dictionary<ulong, History> histories;

            private static readonly Dictionary<string, Key> categories = new Dictionary<string, Key>();

            private static ActionQueue triggers;

            private static readonly Violation violation = new Violation(Key.NULL);

            private class History
            {
                public DateTime cooldown;
                public ulong    count;
                public DateTime time;
                public DateTime warned;
                public ulong    warnings;

                public History()
                {
                    cooldown = DateTime.MinValue;
                    count    = 0;
                    time     = DateTime.MinValue;
                    warned   = DateTime.MinValue;
                    warnings = 0;
                }
            }

            public Violation(Key category)
            {
                this.category = category;
            }

            private void Broadcast(ulong userid, Key action, Key type, string details, Dictionary<string, string> hook_details)
            {
                if((action == Key.Warning) && IsFlooding(userid))
                {
                    return;
                }

                var actionname   = Text.GetPlain(action);
                var categoryname = Text.GetPlain(category);
                var playerid     = userid.ToString();
                var playername   = Text.Sanitize(User.Name(userid));
                var typename     = Text.GetPlain(type);

                var parameters = new Dictionary<string, string>
                {
                    { "action", actionname },
                    { "category", categoryname },
                    { "details", details },
                    { "playerid", playerid },
                    { "playername", playername },
                    { "type", typename }
                };

                Chat.Admin(Key.Violation, parameters);

                switch(category)
                {
                case Key.AntiCheat: parameters["color"] = 0xff6060.ToString(); parameters["categoryicon"] = ":shield:"; break;
                case Key.AntiFlood: parameters["color"] = 0xffff60.ToString(); parameters["categoryicon"] = ":stopwatch:"; break;
                case Key.IP:        parameters["color"] = 0x00c0ff.ToString(); parameters["categoryicon"] = ":signal_strength:"; break;
                case Key.Steam:     parameters["color"] = 0xc0c0ff.ToString(); parameters["categoryicon"] = ":gear:"; break;
                case Key.VPN:       parameters["color"] = 0x00c0ff.ToString(); parameters["categoryicon"] = ":signal_strength:"; break;
                default:            parameters["color"] = 0x60ff60.ToString(); parameters["categoryicon"] = ":question:"; break;
                }

                switch(action)
                {
                case Key.Banned:  parameters["actionicon"] = ":no_entry:"; break;
                case Key.Kicked:  parameters["actionicon"] = ":x:"; break;
                case Key.Warning: parameters["actionicon"] = ":warning:"; break;
                }

                Interface.CallHook("OnGuardianViolation", playerid, parameters);

                if(category == Key.AntiCheat)
                {
                    Interface.CallHook("OnGuardian" + Enum.GetName(typeof(Key), type), playerid, hook_details);
                }
            }

            public static Key Category(string category)
            {
                Key key;

                if(string.IsNullOrEmpty(category) || !categories.TryGetValue(category, out key))
                {
                    key = Key.NULL;
                }

                return key;
            }

            public static void Configure()
            {
                var settings = config.Violation.Validate(86400);

                violation.ban      = settings.Ban;
                violation.cooldown = settings.Cooldown;
                violation.count    = settings.Count(2, 6);
                violation.rate     = TimeSpan.FromHours(1);
                violation.warn     = settings.Warn;

                violation.histories = new Dictionary<ulong, History>();
            }

            public void Configure(Settings settings, ulong trigger_min, ulong trigger_max, ulong trigger_rate)
            {
                ban      = settings.Ban;
                cooldown = settings.Cooldown;
                count    = settings.Count(trigger_min, trigger_max);
                rate     = TimeSpan.FromMilliseconds(trigger_rate);
                warn     = settings.Warn;

                histories = new Dictionary<ulong, History>();
            }

            public ulong Cooldown(ulong userid)
            {
                var history = Get(userid);

                var time = DateTime.UtcNow;

                if(history.cooldown > time)
                {
                    return (ulong)history.cooldown.Subtract(time).TotalSeconds + 1ul;
                }

                return 0;
            }

            public void Clear()
            {
                histories.Clear();

                histories = null;
            }

            private History Get(ulong userid)
            {
                History history;

                if(!histories.TryGetValue(userid, out history))
                {
                    histories.Add(userid, history = new History());
                }

                return history;
            }

            private bool IsFlooding(ulong userid)
            {
                var current = DateTime.UtcNow;
                var history = Get(userid);

                if(history.warnings > 6)
                {
                    if(current < history.warned)
                    {
                        return true;
                    }
                    else
                    {
                        history.warnings = 0;
                    }
                }
                else
                {
                    history.warnings++;
                }

                history.warned = current.AddSeconds(60.0);

                return false;
            }

            public static void Load()
            {
                Configure();

                categories.Add(Text.GetPlain(Key.AntiCheat), Key.AntiCheat);
                categories.Add(Text.GetPlain(Key.AntiFlood), Key.AntiFlood);
                categories.Add(Text.GetPlain(Key.IP),        Key.IP);
                categories.Add(Text.GetPlain(Key.Steam),     Key.Steam);
                categories.Add(Text.GetPlain(Key.VPN),       Key.VPN);

                triggers = new ActionQueue(1.0f);
            }

            private void Reduce(ulong userid)
            {
                Get(userid).count >>= 1;
            }

            private void Reset(ulong userid)
            {
                histories.Remove(userid);
            }

            public bool Trigger(ulong userid)
            {
                var history = Get(userid);

                var time = DateTime.UtcNow;

                var sent = history.time; history.time = time;

                var elapsed = time.Subtract(sent);

                if(elapsed <= rate)
                {
                    if(++history.count >= count)
                    {
                        if(history.cooldown < time)
                        {
                            history.cooldown = time.AddSeconds(cooldown);
                        }

                        return true;
                    }
                }
                else
                {
                    if(elapsed.TotalSeconds < cooldown)
                    {
                        history.count -= (history.count > 0ul) ? 1ul : 0ul;
                    }
                    else
                    {
                        history.count = 0;
                    }
                }

                if(history.cooldown > time)
                {
                    return true;
                }

                return false;
            }

            public void Trigger(ulong userid, Key type, string details, bool kick = false, Dictionary<string, string> hook_details = null)
            {
                Trigger(userid, type, details, 1ul, kick, hook_details);
            }
            public void Trigger(ulong userid, Key type, string details, ulong violations, bool kick = false, Dictionary<string, string> hook_details = null)
            {
                User.SetViolationPosition(userid);

                triggers.Enqueue(() => Triggered(userid, type, details, violations, kick, hook_details));
            }
            private void Triggered(ulong userid, Key type, string details, ulong violations, bool kick, Dictionary<string, string> hook_details)
            {
                if(User.IsBanned(userid))
                {
                    return;
                }

                Key action;

                if(config.Admin.Bypass && Permissions.Admin(userid))
                {
                    Reduce(userid);

                    action = Key.Warning;
                }
                else
                {
                    bool triggered = false;

                    if(violation.ban && ban)
                    {
                        while(violations-- > 0)
                        {
                            if(triggered = violation.Trigger(userid))
                            {
                                break;
                            }
                        }
                    }

                    if(triggered)
                    {
                        Reset(userid);

                        action = Key.Banned;

                        User.Ban(userid, $"{Text.GetPlain(category)}: {Text.GetPlain(type)}");

                        violation.Reset(userid);
                    }
                    else
                    {
                        if(!kick && (ban || (!ban && warn) || violation.warn))
                        {
                            action = Key.Warning;
                        }
                        else if(!User.IsConnected(userid))
                        {
                            return;
                        }
                        else
                        {
                            action = Key.Kicked;

                            User.Kick(userid, $"{Text.GetPlain(category)}: {Text.GetPlain(type)}");
                        }

                        Reduce(userid);
                    }
                }

                Broadcast(userid, action, type, details, hook_details);
            }

            public static void Unload()
            {
                categories.Clear();

                triggers.Clear();
                triggers = null;

                violation.Clear();
            }

            public void Warning(ulong userid, Key type, string details, Dictionary<string, string> hook_details = null)
            {
                triggers.Enqueue(() => Broadcast(userid, Key.Warning, type, details, hook_details));
            }

            public void Zero(ulong userid)
            {
                var history = Get(userid);

                history.cooldown = DateTime.MinValue;
                history.count    = 0;
                history.time     = DateTime.MinValue;
            }
        }

        #endregion _violation_

        #region _vpn_

        private class VPN
        {
            public class Settings
            {
                public VpnApi       API;
                public VpnCache     Cache;
                public VpnCheck     Check;
                public VpnViolation Violation;

                public Settings()
                {
                    API       = new VpnApi();
                    Cache     = new VpnCache();
                    Check     = new VpnCheck();
                    Violation = new VpnViolation();
                }

                public class VpnApi
                {
                    public Guardian.API.Settings GetIpIntel;
                    public Guardian.API.Settings IpApi;
                    public Guardian.API.Settings IpHub;
                    public Guardian.API.Settings IpQualityScore;

                    public VpnApi()
                    {
                        GetIpIntel     = new Guardian.API.Settings();
                        IpApi          = new Guardian.API.Settings();
                        IpHub          = new Guardian.API.Settings();
                        IpQualityScore = new Guardian.API.Settings();
                    }

                    public void Validate()
                    {
                        Configuration.Validate(ref GetIpIntel,     () => new Guardian.API.Settings(), () => GetIpIntel.Validate());
                        Configuration.Validate(ref IpApi,          () => new Guardian.API.Settings(), () => IpApi.Validate());
                        Configuration.Validate(ref IpHub,          () => new Guardian.API.Settings(), () => IpHub.Validate());
                        Configuration.Validate(ref IpQualityScore, () => new Guardian.API.Settings(), () => IpQualityScore.Validate());
                    }
                }

                public class VpnCache
                {
                    public ulong Hours;

                    public VpnCache()
                    {
                        Hours = 72ul;
                    }
                }

                public class VpnCheck
                {
                    public bool Enabled;
                    public bool Strict;
                }

                public class VpnViolation
                {
                    public bool Ban;
                    public bool Enabled;
                    public bool Warn;

                    public VpnViolation()
                    {
                        Ban     = false;
                        Enabled = true;
                        Warn    = false;
                    }
                }

                public void Validate()
                {
                    Configuration.Validate(ref API,       () => new VpnApi(), () => API.Validate());
                    Configuration.Validate(ref Cache,     () => new VpnCache());
                    Configuration.Validate(ref Check,     () => new VpnCheck());
                    Configuration.Validate(ref Violation, () => new VpnViolation());
                }
            }

            private static ActionQueue checks;

            private static readonly Violation violation = new Violation(Key.VPN);

            public class API
            {
                public class GetIpIntel
                {
                    [JsonProperty("message")]
                    public string Message { get; set; }
                    [JsonProperty("result")]
                    public float Result { get; set; }
                    [JsonProperty("status")]
                    public string Status { get; set; }

                    private const string api = "getipintel.net";

                    public static void Check(string address, ulong userid)
                    {
                        if(string.IsNullOrEmpty(config.VPN.API.GetIpIntel.ApiKey))
                        {
                            Log.Console(Key.LogVpnCheckConfig, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "link", $"http://getipintel.net/" }
                            });

                            return;
                        }

                        var url = $"http://check.getipintel.net/check.php?ip={address}&contact={config.VPN.API.GetIpIntel.ApiKey}&format=json";

                        _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                        {
                            if(code != 200 || string.IsNullOrEmpty(reply))
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                    { "address", address },
                                    { "api", api },
                                    { "info", $"({code}: {reply})" },
                                    { "type", "HTTP" }
                                });

                                return;
                            }

                            try
                            {
                                var response = JsonConvert.DeserializeObject<GetIpIntel>(reply);

                                if(string.IsNullOrEmpty(response.Status) || response.Status != "success")
                                {
                                    Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                    {
                                        { "address", address },
                                        { "api", api },
                                        { "info", response.Message },
                                        { "type", "STATUS" }
                                    });

                                    return;
                                }

                                if(config.Log.VPN.Check)
                                {
                                    Log.Console(Key.LogVpnCheck, new Dictionary<string, string>
                                    {
                                        { "address", address },
                                        { "api", api },
                                        { "info", $"result={response.Result}" },
                                    });
                                }

                                if(response.Result > 0.99)
                                {
                                    Violation(address, userid, api);
                                }
                                else if(config.VPN.Check.Strict && (response.Result > 0.95))
                                {
                                    Violation(address, userid, api);
                                }
                            }
                            catch
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                    { "address", address },
                                    { "api", api },
                                    { "info", reply },
                                    { "type", "JSON" }
                                });
                            }
                        }, _instance);
                    }
                }

                public class IpApi
                {
                    [JsonProperty("hosting")]
                    public bool Hosting { get; set; }
                    [JsonProperty("proxy")]
                    public bool Proxy { get; set; }
                    [JsonProperty("status")]
                    public string Status { get; set; }

                    private const string api = "ip-api.com";

                    public static void Check(string address, ulong userid)
                    {
                        var url = $"http://ip-api.com/json/{address}?fields=status,proxy,hosting";

                        _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                        {
                            if(code != 200 || string.IsNullOrEmpty(reply))
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                    { "address", address },
                                    { "api", api },
                                    { "info", $"({code}: {reply})" },
                                    { "type", "HTTP" }
                                });

                                return;
                            }

                            try
                            {
                                var response = JsonConvert.DeserializeObject<IpApi>(reply);

                                if(string.IsNullOrEmpty(response.Status) || response.Status != "success")
                                {
                                    Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                    {
                                        { "address", address },
                                        { "api", api },
                                        { "info", response.Status },
                                        { "type", "STATUS" }
                                    });

                                    return;
                                }

                                if(config.Log.VPN.Check)
                                {
                                    Log.Console(Key.LogVpnCheck, new Dictionary<string, string>
                                    {
                                        { "address", address },
                                        { "api", api },
                                        { "info", $"hosting={response.Hosting}; proxy={response.Proxy}" },
                                    });
                                }

                                if(response.Proxy)
                                {
                                    Violation(address, userid, api);
                                }
                                else if(config.VPN.Check.Strict && response.Hosting)
                                {
                                    Violation(address, userid, api);
                                }
                            }
                            catch
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                    { "address", address },
                                    { "api", api },
                                    { "info", reply },
                                    { "type", "JSON" }
                                });
                            }
                        }, _instance);
                    }
                }

                public class IpHub
                {
                    [JsonProperty("block")]
                    public int Block { get; set; }

                    [JsonIgnore]
                    private static readonly Dictionary<string, string> headers = new Dictionary<string, string>();

                    private const string api = "iphub.info";

                    public static void Check(string address, ulong userid)
                    {
                        if(string.IsNullOrEmpty(config.VPN.API.IpHub.ApiKey))
                        {
                            Log.Console(Key.LogVpnCheckConfig, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "link", $"http://iphub.info/" }
                            });

                            return;
                        }

                        var url = $"http://v2.api.iphub.info/ip/{address}";

                        _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                        {
                            if(code != 200 || string.IsNullOrEmpty(reply))
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                    { "address", address },
                                    { "api", api },
                                    { "info", $"({code}: {reply})" },
                                    { "type", "HTTP" }
                                });

                                return;
                            }

                            try
                            {
                                var response = JsonConvert.DeserializeObject<IpHub>(reply);

                                if(config.Log.VPN.Check)
                                {
                                    Log.Console(Key.LogVpnCheck, new Dictionary<string, string>
                                    {
                                    { "address", address },
                                    { "api", api },
                                    { "info", $"block={response.Block}" },
                                    });
                                }

                                if(response.Block == 1)
                                {
                                    Violation(address, userid, api);
                                }
                                else if(config.VPN.Check.Strict && (response.Block == 2))
                                {
                                    Violation(address, userid, api);
                                }
                            }
                            catch
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                    { "address", address },
                                    { "api", api },
                                    { "info", reply },
                                    { "type", "JSON" }
                                });
                            }
                        }, _instance, RequestMethod.GET, headers);
                    }

                    public static void Configure()
                    {
                        headers["X-Key"] = config.VPN.API.IpHub.ApiKey;
                    }

                    public static void Unload() => headers.Clear();
                }

                public class IpQualityScore
                {
                    [JsonProperty("fraud_score")]
                    public int FraudScore { get; set; }
                    [JsonProperty("message")]
                    public string Message { get; set; }
                    [JsonProperty("proxy")]
                    public bool Proxy { get; set; }
                    [JsonProperty("recent_abuse")]
                    public bool RecentAbuse { get; set; }
                    [JsonProperty("success")]
                    public bool Success { get; set; }
                    [JsonProperty("vpn")]
                    public bool VPN { get; set; }

                    private const string api = "ipqualityscore.com";

                    public static void Check(string address, ulong userid)
                    {
                        if(string.IsNullOrEmpty(config.VPN.API.IpQualityScore.ApiKey))
                        {
                            Log.Console(Key.LogVpnCheckConfig, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "link", $"http://ipqualityscore.com/" }
                            });

                            return;
                        }

                        var url = $"https://ipqualityscore.com/api/json/ip/{config.VPN.API.IpQualityScore.ApiKey}/{address}?allow_public_access_points=true&lighter_penalties=true&mobile=true&strictness=1";

                        _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                        {
                            if(code != 200 || string.IsNullOrEmpty(reply))
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                { "address", address },
                                { "api", api },
                                { "info", $"({code}: {reply})" },
                                { "type", "HTTP" }
                                });

                                return;
                            }

                            try
                            {
                                var response = JsonConvert.DeserializeObject<IpQualityScore>(reply);

                                if(!response.Success)
                                {
                                    Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                    {
                                    { "address", address },
                                    { "api", api },
                                    { "info", response.Message },
                                    { "type", "STATUS" }
                                    });

                                    return;
                                }

                                if(config.Log.VPN.Check)
                                {
                                    Log.Console(Key.LogVpnCheck, new Dictionary<string, string>
                                    {
                                    { "address", address },
                                    { "api", api },
                                    { "info", $"fraud_score={response.FraudScore}; proxy={response.Proxy}; recent_abuse={response.RecentAbuse}; vpn={response.VPN}" },
                                    });
                                }

                                if(response.VPN || (response.FraudScore >= 85))
                                {
                                    Violation(address, userid, api);
                                }
                                else if(config.VPN.Check.Strict && (response.Proxy || response.RecentAbuse || (response.FraudScore >= 75)))
                                {
                                    Violation(address, userid, api);
                                }
                            }
                            catch
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                { "address", address },
                                { "api", api },
                                { "info", reply },
                                { "type", "JSON" }
                                });
                            }
                        }, _instance);
                    }
                }

                public static void Configure() => IpHub.Configure();

                public static void Unload() => IpHub.Unload();
            }

            private class Cache
            {
                private static readonly DataFile<string, DateTime> blocks = new DataFile<string, DateTime>("vpn_blocks");
                private static readonly DataFile<string, DateTime> bypass = new DataFile<string, DateTime>("vpn_bypass");

                public static void Block(string address)
                {
                    bypass.Remove(address);

                    blocks[address] = DateTime.UtcNow;
                }

                public static void Bypass(string address, ulong _reserved = 0)
                {
                    blocks.Remove(address);

                    bypass[address] = DateTime.UtcNow;
                }

                public static bool IsBlocked(string address) => IsCached(blocks, address);

                public static bool IsBypassed(string address) => IsCached(bypass, address);

                private static bool IsCached(DataFile<string, DateTime> cache, string address)
                {
                    if(cache.Contains(address))
                    {
                        if(IsExpired(cache[address], DateTime.UtcNow))
                        {
                            cache.Remove(address);
                        }
                        else
                        {
                            return true;
                        }
                    }

                    return false;
                }

                private static bool IsExpired(DateTime timestamp, DateTime check)
                {
                    if(config.VPN.Cache.Hours == 0)
                    {
                        return false;
                    }

                    if(check == DateTime.MinValue)
                    {
                        check = DateTime.UtcNow;
                    }

                    return check >= timestamp.AddHours(config.VPN.Cache.Hours);
                }

                public static void Load()
                {
                    blocks.Load();
                    bypass.Load();

                    Update();
                }

                public static void Save()
                {
                    Update();

                    blocks.Save();
                    bypass.Save();
                }

                public static void Unblock(string address) => blocks.Remove(address);

                public static void Unload()
                {
                    Update();

                    blocks.Unload();
                    bypass.Unload();
                }

                private static void Update()
                {
                    var current = DateTime.UtcNow;

                    Update(blocks, current);
                    Update(bypass, current);
                }
                private static void Update(DataFile<string, DateTime> cache, DateTime current)
                {
                    List<string> expired = new List<string>();

                    cache.ForEach((address, timestamp) =>
                    {
                        if(IsExpired(timestamp, current))
                        {
                            expired.Add(address);
                        }
                    });

                    foreach(var address in expired)
                    {
                        cache.Remove(address);
                    }
                }
            }

            public static void Bypass(string address) => Cache.Bypass(address);

            public static void Check(string address, ulong userid)
            {
                if(!config.VPN.Check.Enabled || Permissions.Bypass.Vpn(userid) || string.IsNullOrEmpty(address))
                {
                    return;
                }
                else if(Cache.IsBypassed(address))
                {
                    return;
                }
                else if(Cache.IsBlocked(address))
                {
                    Violation(address, userid, Text.GetPlain(Key.VpnCache));
                }

                checks.Enqueue(() => Check(address, userid, 6.0f));
            }
            private static void Check(string address, ulong userid, float delay)
            {
                if(config.VPN.API.GetIpIntel.Enabled)
                {
                    Check(ref delay, address, userid, API.GetIpIntel.Check);
                }

                if(config.VPN.API.IpApi.Enabled)
                {
                    Check(ref delay, address, userid, API.IpApi.Check);
                }

                if(config.VPN.API.IpHub.Enabled)
                {
                    Check(ref delay, address, userid, API.IpHub.Check);
                }

                if(config.VPN.API.IpQualityScore.Enabled)
                {
                    Check(ref delay, address, userid, API.IpQualityScore.Check);
                }

                Check(ref delay, address, userid, Cache.Bypass);
            }
            private static void Check(ref float delay, string address, ulong userid, Action<string, ulong> callback)
            {
                _instance.timer.In(delay, () =>
                {
                    if(!Cache.IsBlocked(address))
                    {
                        callback(address, userid);
                    }
                });

                delay += 6.0f;
            }

            public static void Configure()
            {
                violation.Configure(new Violation.Settings(true, 3600, 0.5f, config.VPN.Violation.Warn), 1, 1, 1);

                API.Configure();
            }

            public static bool IsBlocked(string address) => Cache.IsBlocked(address);

            public static bool IsBypassed(string address) => Cache.IsBypassed(address);

            public static void Load()
            {
                Configure();

                Cache.Load();

                checks = new ActionQueue(6.0f);
            }

            public static void Save() => Cache.Save();

            public static void Unblock(string address) => Cache.Unblock(address);

            public static void Unload()
            {
                checks.Clear();
                checks = null;

                violation.Clear();

                API.Unload();
                Cache.Unload();
            }

            private static void Violation(string address, ulong userid, string api)
            {
                Cache.Block(address);

                if(!(config.VPN.Violation.Enabled && config.VPN.Violation.Warn))
                {
                    IP.Block(address);
                }

                foreach(var entry in IP.Find(address))
                {
                    if(!User.IsConnected(entry) || Permissions.Bypass.Vpn(entry))
                    {
                        continue;
                    }

                    if(config.VPN.Violation.Enabled)
                    {
                        ulong violations = config.VPN.Violation.Ban ? ulong.MaxValue : 1ul;

                        violation.Trigger(entry, Key.Detected, $"{api}, {address}", violations, true);
                    }
                    else
                    {
                        User.Kick(entry, Text.GetPlain(Key.VpnDetected));
                    }
                }
            }
        }

        #endregion _vpn_

        #region _weapon_

        private class Weapon
        {
            public float        Accuracy { get; protected set; }
            public Vector3      AimAngle { get; protected set; }
            public float        AimCone { get; protected set; }
            public float        AimSway { get; protected set; }
            public string       AmmoName { get; protected set; }
            public List<string> Attachments { get; protected set; }
            public bool         Automatic { get; protected set; }
            public DateTime     Fired { get; protected set; }
            public string       Name { get; protected set; }
            public float        Pitch { get; protected set; }
            public BasePlayer   Player { get; protected set; }
            public Vector3      Position { get; protected set; }
            public List<int>    Projectiles { get; protected set; }
            public float        Range { get; protected set; }
            public float        Repeat { get; protected set; }
            public bool         Shell { get; protected set; }
            public string       ShortName { get; protected set; }
            public float        Speed { get; protected set; }
            public bool         Spread { get; protected set; }
            public float        Swing { get; protected set; }
            public float        Velocity { get; protected set; }
            public float        Yaw { get; protected set; }
            public float        Zoom { get; protected set; }

            private static readonly Queue<Weapon> pool = new Queue<Weapon>();

            // Ammo ID's
            private static readonly int ArrowBone = ItemManager.FindItemDefinition("arrow.bone").itemid;
            private static readonly int ArrowFire = ItemManager.FindItemDefinition("arrow.fire").itemid;
            private static readonly int ArrowHV = ItemManager.FindItemDefinition("arrow.hv").itemid;
            private static readonly int ArrowWooden = ItemManager.FindItemDefinition("arrow.wooden").itemid;
            private static readonly int GrenadeHE = ItemManager.FindItemDefinition("ammo.grenadelauncher.he").itemid;
            private static readonly int GrenadeShotgun = ItemManager.FindItemDefinition("ammo.grenadelauncher.buckshot").itemid;
            private static readonly int GrenadeSmoke = ItemManager.FindItemDefinition("ammo.grenadelauncher.smoke").itemid;
            private static readonly int NailgunNails = ItemManager.FindItemDefinition("ammo.nailgun.nails").itemid;
            private static readonly int PistolBullet = ItemManager.FindItemDefinition("ammo.pistol").itemid;
            private static readonly int PistolHV = ItemManager.FindItemDefinition("ammo.pistol.hv").itemid;
            private static readonly int PistolIncendiary = ItemManager.FindItemDefinition("ammo.pistol.fire").itemid;
            private static readonly int RifleAmmo = ItemManager.FindItemDefinition("ammo.rifle").itemid;
            private static readonly int RifleExplosive = ItemManager.FindItemDefinition("ammo.rifle.explosive").itemid;
            private static readonly int RifleHV = ItemManager.FindItemDefinition("ammo.rifle.hv").itemid;
            private static readonly int RifleIncendiary = ItemManager.FindItemDefinition("ammo.rifle.incendiary").itemid;
            private static readonly int Rocket = ItemManager.FindItemDefinition("ammo.rocket.basic").itemid;
            private static readonly int RocketHV = ItemManager.FindItemDefinition("ammo.rocket.hv").itemid;
            private static readonly int RocketIncendiary = ItemManager.FindItemDefinition("ammo.rocket.fire").itemid;
            private static readonly int ShellBuckshot = ItemManager.FindItemDefinition("ammo.shotgun").itemid;
            private static readonly int ShellHandmade = ItemManager.FindItemDefinition("ammo.handmade.shell").itemid;
            private static readonly int ShellIncendiary = ItemManager.FindItemDefinition("ammo.shotgun.fire").itemid;
            private static readonly int ShellSlug = ItemManager.FindItemDefinition("ammo.shotgun.slug").itemid;

            // Weapon ID's
            private static readonly int AssaultRifle = ItemManager.FindItemDefinition("rifle.ak").itemid;
            private static readonly int BoltActionRifle = ItemManager.FindItemDefinition("rifle.bolt").itemid;
            private static readonly int CompoundBow = ItemManager.FindItemDefinition("bow.compound").itemid;
            private static readonly int Crossbow = ItemManager.FindItemDefinition("crossbow").itemid;
            private static readonly int CustomSMG = ItemManager.FindItemDefinition("smg.2").itemid;
            private static readonly int DoubleBarrelShotgun = ItemManager.FindItemDefinition("shotgun.double").itemid;
            private static readonly int EokaPistol = ItemManager.FindItemDefinition("pistol.eoka").itemid;
            private static readonly int HuntingBow = ItemManager.FindItemDefinition("bow.hunting").itemid;
            private static readonly int L96Rifle = ItemManager.FindItemDefinition("rifle.l96").itemid;
            private static readonly int LR300AssaultRifle = ItemManager.FindItemDefinition("rifle.lr300").itemid;
            private static readonly int M249 = ItemManager.FindItemDefinition("lmg.m249").itemid;
            private static readonly int M39Rifle = ItemManager.FindItemDefinition("rifle.m39").itemid;
            private static readonly int M92Pistol = ItemManager.FindItemDefinition("pistol.m92").itemid;
            private static readonly int MP5A4 = ItemManager.FindItemDefinition("smg.mp5").itemid;
            private static readonly int MultipleGrenadeLauncher = ItemManager.FindItemDefinition("multiplegrenadelauncher").itemid;
            private static readonly int Nailgun = ItemManager.FindItemDefinition("pistol.nailgun").itemid;
            private static readonly int PumpShotgun = ItemManager.FindItemDefinition("shotgun.pump").itemid;
            private static readonly int PythonRevolver = ItemManager.FindItemDefinition("pistol.python").itemid;
            private static readonly int Revolver = ItemManager.FindItemDefinition("pistol.revolver").itemid;
            private static readonly int RocketLauncher = ItemManager.FindItemDefinition("rocket.launcher").itemid;
            private static readonly int SemiAutomaticPistol = ItemManager.FindItemDefinition("pistol.semiauto").itemid;
            private static readonly int SemiAutomaticRifle = ItemManager.FindItemDefinition("rifle.semiauto").itemid;
            private static readonly int Spas12Shotgun = ItemManager.FindItemDefinition("shotgun.spas12").itemid;
            private static readonly int Thompson = ItemManager.FindItemDefinition("smg.thompson").itemid;
            private static readonly int WaterpipeShotgun = ItemManager.FindItemDefinition("shotgun.waterpipe").itemid;

            private class Ammo
            {
                public float AimCone { get; set; }
                public float Range { get; set; }
                public float Velocity { get; set; }

                public Ammo(float aimcone, float range, float velocity)
                {
                    AimCone = aimcone; Range = range; Velocity = velocity;
                }
            }

            private class Info
            {
                public float                 Accuracy { get; set; }
                public Dictionary<int, Ammo> Ammo { get; set; }
                public bool                  Automatic { get; set; }
                public string                Name { get; set; }
                public Recoil                Recoil { get; set; }
                public float                 Repeat { get; set; }
            }

            private class Recoil
            {
                public float Pitch { get; set; }
                public float Yaw { get; set; }

                public Recoil(float pitch, float yaw)
                {
                    Pitch = pitch; Yaw = yaw;
                }
            }

            private static Dictionary<int, Info> weapons;

            private Weapon()
            {
                Attachments = new List<string>();
                Projectiles = new List<int>();
            }

            private static Weapon Get()
            {
                if(pool.Count > 0)
                {
                    return pool.Dequeue();
                }
                else
                {
                    return new Weapon();
                }
            }
            public static Weapon Get(ulong userid, int projectileid) => Projectile.Weapon(userid, projectileid);
            public static Weapon Get(BaseProjectile weapon_fired, BasePlayer player, ProtoBuf.ProjectileShoot fired = null)
            {
                var item = weapon_fired.GetItem();

                Info info;

                if(!weapons.TryGetValue(item.info.itemid, out info))
                {
                    return null;
                }

                var ammo = weapon_fired.primaryMagazine.ammoType;

                Ammo ammoinfo;

                if(!info.Ammo.TryGetValue(ammo.itemid, out ammoinfo))
                {
                    return null;
                }

                var accuracy = info.Accuracy;

                var spread = (ammo.itemid == ShellBuckshot) || (ammo.itemid == ShellHandmade);

                var position = weapon_fired.MuzzlePoint?.transform?.position ?? weapon_fired.transform?.position ?? player.transform.position;

                var weapon = Get();

                weapon.Accuracy   = 1.0f;
                weapon.AimAngle   = player.eyes.HeadRay().direction;
                weapon.AimCone    = ammoinfo.AimCone;
                weapon.AimSway    = 1.0f;
                weapon.AmmoName   = ammo.shortname;
                weapon.Automatic  = info.Automatic;
                weapon.Fired      = DateTime.UtcNow;
                weapon.Name       = info.Name;
                weapon.Pitch      = info.Recoil.Pitch * (info.Automatic ? 0.25f : 0.5f);
                weapon.Player     = player;
                weapon.Position   = position;
                weapon.Range      = ammoinfo.Range;
                weapon.Repeat     = info.Repeat;
                weapon.Shell      = spread || (ammo.itemid == ShellIncendiary) || (ammo.itemid == ShellSlug);
                weapon.ShortName  = item.info.shortname;
                weapon.Speed      = player.estimatedSpeed;
                weapon.Spread     = spread || (ammo.itemid == GrenadeShotgun);
                weapon.Swing      = 0.0f;
                weapon.Velocity   = ammoinfo.Velocity;
                weapon.Yaw        = info.Recoil.Yaw * (info.Automatic ? 0.125f : 0.25f); ;
                weapon.Zoom       = 1.0f;

                var aimsway = 1.0f;

                foreach(var entry in player.inventory.containerWear.itemList)
                {
                    if(entry.info.itemid == -1108136649) // Tactical Gloves
                    {
                        aimsway = 0.2f;

                        break;
                    }
                }

                var aiming = player.IsAiming;

                var ducked = player.IsDucked();

                var recoil = ducked ? 0.9f : 1.0f;

                if(item?.contents?.itemList != null)
                {
                    bool muzzle_brake = false;

                    foreach(var mod in item.contents.itemList)
                    {
                        switch(mod.info.shortname)
                        {
                        case "weapon.mod.8x.scope":
                            accuracy *= 0.85f;
                            recoil -= 0.2f;
                            weapon.AimCone *= 0.7f;
                            weapon.Zoom = aiming ? 16.0f : 1.0f;
                            break;
                        case "weapon.mod.small.scope":
                            accuracy *= 0.85f;
                            recoil -= 0.2f;
                            weapon.AimCone *= 0.7f;
                            weapon.Zoom = aiming ? 8.0f : 1.0f;
                            break;
                        case "weapon.mod.holosight":
                            accuracy *= 0.3f;
                            weapon.AimCone *= 0.3f;
                            weapon.Zoom = aiming ? 2.0f : 1.0f;
                            break;
                        case "weapon.mod.muzzleboost":
                            weapon.Range *= 0.9f;
                            weapon.Repeat *= 0.9f;
                            weapon.Velocity *= 0.9f;
                            break;
                        case "weapon.mod.muzzlebrake":
                            accuracy *= 1.38f;
                            muzzle_brake = true;
                            recoil -= 0.5f;
                            break;
                        case "weapon.mod.silencer":
                            accuracy *= 0.67f;
                            aimsway -= 0.2f;
                            recoil -= 0.2f;
                            weapon.AimCone *= 0.7f;
                            break;
                        case "weapon.mod.simplesight":
                            weapon.Zoom = aiming ? 0.5f : 1.0f;
                            break;
                        case "weapon.mod.lasersight":
                            accuracy *= 0.56f;
                            aimsway -= 0.9f;
                            weapon.AimCone *= aiming ? 0.8f : 0.6f;
                            break;
                        }

                        weapon.Attachments.Add(mod.info.shortname);
                    }

                    if(muzzle_brake)
                    {
                        weapon.AimCone += aiming ? 0.5f : 2.0f;
                    }
                }

                weapon.Accuracy -= accuracy;
                weapon.AimSway  *= (aimsway > 0.0f) ? aimsway : 0.0f;
                weapon.Pitch    *= recoil;
                weapon.Yaw      *= recoil;

                if((fired?.projectiles?.Count ?? 0) > 0)
                {
                    foreach(var projectile in fired.projectiles)
                    {
                        weapon.Projectiles.Add(projectile.projectileID);
                    }

                    Projectile.Add(weapon);
                }

                return weapon;
            }

            public static bool IsValid(Item item) => weapons.ContainsKey(item?.info?.itemid ?? 0);

            public static void Load()
            {
                weapons = new Dictionary<int, Info>
                {
                    [AssaultRifle] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.2f, 187.5f, 375.0f) },
                            { RifleExplosive,  new Ammo(0.5f, 112.5f, 225.0f) },
                            { RifleHV,         new Ammo(0.2f, 225.0f, 450.0f) },
                            { RifleIncendiary, new Ammo(0.2f, 112.5f, 225.0f) }
                        },
                        Automatic = true,
                        Name = "Assault Rifle",
                        Recoil = new Recoil(13.000000f, 5.000000f),
                        Repeat = 0.1333f
                    },
                    [BoltActionRifle] = new Info
                    {
                        Accuracy = 0.02f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.0f, 328.0f, 656.0f) },
                            { RifleExplosive,  new Ammo(0.5f, 197.0f, 394.0f) },
                            { RifleHV,         new Ammo(0.0f, 394.0f, 788.0f) },
                            { RifleIncendiary, new Ammo(0.0f, 197.0f, 394.0f) }
                        },
                        Automatic = false,
                        Name = "Bolt Action Rifle",
                        Recoil = new Recoil(0.500000f, 4.000000f),
                        Repeat = 1.7f
                    },
                    [CompoundBow] = new Info
                    {
                        Accuracy = 0.00f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ArrowBone,   new Ammo(0.2f, 270.0f,  90.0f) },
                            { ArrowFire,   new Ammo(0.2f, 240.0f,  80.0f) },
                            { ArrowHV,     new Ammo(0.2f, 480.0f, 160.0f) },
                            { ArrowWooden, new Ammo(0.2f, 300.0f, 100.0f) }
                        },
                        Automatic = false,
                        Name = "Compound Bow",
                        Recoil = new Recoil(1.500000f, 3.000000f),
                        Repeat = 1.25f
                    },
                    [Crossbow] = new Info
                    {
                        Accuracy = 0.03f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ArrowBone,   new Ammo(1.0f, 202.5f,  67.5f) },
                            { ArrowFire,   new Ammo(1.0f, 180.0f,  60.0f) },
                            { ArrowHV,     new Ammo(1.0f, 360.0f, 120.0f) },
                            { ArrowWooden, new Ammo(1.0f, 225.0f,  75.0f) }
                        },
                        Automatic = false,
                        Name = "Crossbow",
                        Recoil = new Recoil(1.500000f, 3.000000f),
                        Repeat = 1.0f
                    },
                    [CustomSMG] = new Info
                    {
                        Accuracy = 0.03f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(0.5f, 200.0f, 240.0f) },
                            { PistolHV,         new Ammo(0.5f, 266.7f, 320.0f) },
                            { PistolIncendiary, new Ammo(0.5f, 150.0f, 180.0f) }
                        },
                        Automatic = true,
                        Name = "Custom SMG",
                        Recoil = new Recoil(6.500000f, 5.7500000f),
                        Repeat = 0.1f
                    },
                    [DoubleBarrelShotgun] = new Info
                    {
                        Accuracy = 0.15f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ShellBuckshot,   new Ammo(12.5f, 45.0f, 225.0f) },
                            { ShellHandmade,   new Ammo(12.5f, 30.0f, 100.0f) },
                            { ShellIncendiary, new Ammo(12.5f, 25.0f, 100.0f) },
                            { ShellSlug,       new Ammo( 0.5f, 60.0f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Double Barrel Shotgun",
                        Recoil = new Recoil(2.500000f, 3.500000f),
                        Repeat = 0.5f
                    },
                    [EokaPistol] = new Info
                    {
                        Accuracy = 0.17f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ShellBuckshot,   new Ammo(14.0f, 45.0f, 225.0f) },
                            { ShellHandmade,   new Ammo(14.0f, 30.0f, 100.0f) },
                            { ShellIncendiary, new Ammo(14.0f, 25.0f, 100.0f) },
                            { ShellSlug,       new Ammo( 2.0f, 60.0f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Eoka Pistol",
                        Recoil = new Recoil(15.00000f, 10.00000f),
                        Repeat = 1.5f
                    },
                    [HuntingBow] = new Info
                    {
                        Accuracy = 0.02f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ArrowBone,   new Ammo(1.0f, 135.0f, 45.0f) },
                            { ArrowFire,   new Ammo(1.0f, 120.0f, 40.0f) },
                            { ArrowHV,     new Ammo(1.0f, 240.0f, 80.0f) },
                            { ArrowWooden, new Ammo(1.0f, 150.0f, 50.0f) }
                        },
                        Automatic = false,
                        Name = "Hunting Bow",
                        Recoil = new Recoil(1.500000f, 3.000000f),
                        Repeat = 1.25f
                    },
                    [L96Rifle] = new Info
                    {
                        Accuracy = 0.02f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.0f, 562.5f, 1125.0f) },
                            { RifleExplosive,  new Ammo(0.5f, 337.5f, 675.0f) },
                            { RifleHV,         new Ammo(0.0f, 675.0f, 1350.0f) },
                            { RifleIncendiary, new Ammo(0.0f, 337.5f, 675.0f) }
                        },
                        Automatic = false,
                        Name = "L96 Rifle",
                        Recoil = new Recoil(0.250000f, 2.000000f),
                        Repeat = 2.6f
                    },
                    [LR300AssaultRifle] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.2f, 187.5f, 375.0f) },
                            { RifleExplosive,  new Ammo(0.7f, 112.5f, 225.0f) },
                            { RifleHV,         new Ammo(0.2f, 225.0f, 450.0f) },
                            { RifleIncendiary, new Ammo(0.2f, 112.5f, 225.0f) }
                        },
                        Automatic = true,
                        Name = "LR-300 Assault Rifle",
                        Recoil = new Recoil(4.750000f, 3.000000f),
                        Repeat = 0.12f
                    },
                    [M249] = new Info
                    {
                        Accuracy = 0.07f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.2f, 243.75f, 487.5f) },
                            { RifleExplosive,  new Ammo(0.7f, 146.25f, 292.5f) },
                            { RifleHV,         new Ammo(0.2f, 292.50f, 585.0f) },
                            { RifleIncendiary, new Ammo(0.2f, 146.25f, 292.5f) }
                        },
                        Automatic = true,
                        Name = "M249",
                        Recoil = new Recoil(0.500000f, 1.000000f),
                        Repeat = 0.12f
                    },
                    [M39Rifle] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.1f, 234.375f, 468.75f) },
                            { RifleExplosive,  new Ammo(0.6f, 140.625f, 281.25f) },
                            { RifleHV,         new Ammo(0.1f, 281.250f, 562.50f) },
                            { RifleIncendiary, new Ammo(0.1f, 140.625f, 281.25f) }
                        },
                        Automatic = false,
                        Name = "M39 Rifle",
                        Recoil = new Recoil(1.000000f, 1.500000f),
                        Repeat = 0.2f
                    },
                    [M92Pistol] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(1.0f,  90.0f, 300.0f) },
                            { PistolHV,         new Ammo(1.0f, 120.0f, 400.0f) },
                            { PistolIncendiary, new Ammo(1.0f,  67.5f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "M92 Pistol",
                        Recoil = new Recoil(0.500000f, 1.000000f),
                        Repeat = 0.15f
                    },
                    [MP5A4] = new Info
                    {
                        Accuracy = 0.05f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(0.5f, 200.0f, 240.0f) },
                            { PistolHV,         new Ammo(0.5f, 266.7f, 320.0f) },
                            { PistolIncendiary, new Ammo(0.5f, 150.0f, 180.0f) }
                        },
                        Automatic = true,
                        Name = "MP5A4",
                        Recoil = new Recoil(4.000000f, 3.625000f),
                        Repeat = 0.1f
                    },
                    [MultipleGrenadeLauncher] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { GrenadeHE,      new Ammo( 2.25f, 100.0f, 100.0f) },
                            { GrenadeShotgun, new Ammo(17.25f, 225.0f, 225.0f) },
                            { GrenadeSmoke,   new Ammo( 2.25f, 100.0f, 100.0f) }
                        },
                        Automatic = false,
                        Name = "Multiple Grenade Launcher",
                        Recoil = new Recoil(2.500000f, 2.500000f),
                        Repeat = 0.4f
                    },
                    [Nailgun] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { NailgunNails, new Ammo(0.75f, 25.0f, 50.0f) }
                        },
                        Automatic = false,
                        Name = "Nailgun",
                        Recoil = new Recoil(1.500000f, 1.000000f),
                        Repeat = 0.15f
                    },
                    [PumpShotgun] = new Info
                    {
                        Accuracy = 0.14f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ShellBuckshot,   new Ammo(12.0f, 101.25f, 225.0f) },
                            { ShellHandmade,   new Ammo(12.0f,  60.00f, 100.0f) },
                            { ShellIncendiary, new Ammo(12.0f,  45.00f, 100.0f) },
                            { ShellSlug,       new Ammo( 0.0f, 135.00f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Pump Shotgun",
                        Recoil = new Recoil(2.000000f, 2.000000f),
                        Repeat = 1.1f
                    },
                    [PythonRevolver] = new Info
                    {
                        Accuracy = 0.06f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(0.5f, 72.0f, 300.0f) },
                            { PistolHV,         new Ammo(0.5f, 96.0f, 400.0f) },
                            { PistolIncendiary, new Ammo(0.5f, 54.0f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Python Revolver",
                        Recoil = new Recoil(0.500000f, 2.000000f),
                        Repeat = 0.15f
                    },
                    [Revolver] = new Info
                    {
                        Accuracy = 0.05f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(0.75f, 54.0f, 300.0f) },
                            { PistolHV,         new Ammo(0.75f, 72.0f, 400.0f) },
                            { PistolIncendiary, new Ammo(0.75f, 40.5f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Revolver",
                        Recoil = new Recoil(1.500000f, 1.000000f),
                        Repeat = 0.175f
                    },
                    [RocketLauncher] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { Rocket,           new Ammo(2.25f, 250.0f, 18.0f) },
                            { RocketHV,         new Ammo(2.25f, 400.0f, 40.0f) },
                            { RocketIncendiary, new Ammo(2.25f, 250.0f, 18.0f) }
                        },
                        Automatic = false,
                        Name = "Rocket Launcher",
                        Recoil = new Recoil(2.500000f, 2.500000f),
                        Repeat = 2.0f
                    },
                    [SemiAutomaticPistol] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(0.75f, 54.0f, 300.0f) },
                            { PistolHV,         new Ammo(0.75f, 72.0f, 400.0f) },
                            { PistolIncendiary, new Ammo(0.75f, 40.5f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Semi-Automatic Pistol",
                        Recoil = new Recoil(1.000000f, 2.000000f),
                        Repeat = 0.15f
                    },
                    [SemiAutomaticRifle] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.25f, 187.5f, 375.0f) },
                            { RifleExplosive,  new Ammo(0.75f, 112.5f, 225.0f) },
                            { RifleHV,         new Ammo(0.25f, 225.0f, 450.0f) },
                            { RifleIncendiary, new Ammo(0.25f, 112.5f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Semi-Automatic Rifle",
                        Recoil = new Recoil(0.500000f, 1.000000f),
                        Repeat = 0.175f
                    },
                    [Spas12Shotgun] = new Info
                    {
                        Accuracy = 0.14f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ShellBuckshot,   new Ammo(12.0f, 101.25f, 225.0f) },
                            { ShellHandmade,   new Ammo(12.0f,  60.00f, 100.0f) },
                            { ShellIncendiary, new Ammo(12.0f,  45.00f, 100.0f) },
                            { ShellSlug,       new Ammo( 0.0f, 135.00f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Spas-12 Shotgun",
                        Recoil = new Recoil(2.000000f, 2.000000f),
                        Repeat = 0.25f
                    },
                    [Thompson] = new Info
                    {
                        Accuracy = 0.03f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(0.5f, 250.0f, 300.0f) },
                            { PistolHV,         new Ammo(0.5f, 333.3f, 400.0f) },
                            { PistolIncendiary, new Ammo(0.5f, 187.5f, 225.0f) }
                        },
                        Automatic = true,
                        Name = "Thompson",
                        Recoil = new Recoil(6.500000f, 5.750000f),
                        Repeat = 0.13f
                    },
                    [WaterpipeShotgun] = new Info
                    {
                        Accuracy = 0.15f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ShellBuckshot,   new Ammo(13.0f, 45.0f, 225.0f) },
                            { ShellHandmade,   new Ammo(13.0f, 30.0f, 100.0f) },
                            { ShellIncendiary, new Ammo(13.0f, 25.0f, 100.0f) },
                            { ShellSlug,       new Ammo( 1.0f, 60.0f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Waterpipe Shotgun",
                        Recoil = new Recoil(2.000000f, 2.000000f),
                        Repeat = 2.0f
                    }
                };
            }

            public void Release()
            {
                Attachments.Clear();
                Projectiles.Clear();

                pool.Enqueue(this);
            }

            public void SetSwing(float amount)
            {
                Swing = amount;
            }

            public static void Unload()
            {
                pool.Clear();

                weapons.Clear();
                weapons = null;
            }
        }

        #endregion _weapon_

        #region _webhook_

        private class WebHook
        {
            public static void Send(string url, string category, string message)
            {
                if(string.IsNullOrEmpty(url) || string.IsNullOrEmpty(message))
                {
                    return;
                }

                if(string.IsNullOrWhiteSpace(category))
                {
                    category = Text.GetPlain(Key.unknown);
                }

                _instance.webrequest.Enqueue(url, message, (code, reply) =>
                {
                    if((code < 200) || (204 < code))
                    {
                        Log.Console(Key.LogWebHook, new Dictionary<string, string>
                        {
                            { "category", category },
                            { "info", $"({code}: {reply})" },
                            { "type", "http" }
                        });
                    }
                }, _instance, RequestMethod.POST, new Dictionary<string, string> { { "Content-Type", "application/json" } });
            }
        }

        #endregion _webhook_
    }
}


// --- End of file: Guardian.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/game-tip-announcements ---
// --- Original File Path: G/GameTipAnnouncements/GameTipAnnouncements.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Game Tip Announcements", "redBDGR", "1.0.2")]
    [Description("Send notifications to players as gametips")]

    //
    // TODO:
    //
    //  - Add init messages
    //

    class GameTipAnnouncements : RustPlugin
    {
        private bool Changed;
        private const string permissionNameADMIN = "gametipannouncements.admin";

        private float defaultLengnth = 15f;

        private void Init()
        {
            permission.RegisterPermission(permissionNameADMIN, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                //chat
                ["NoPermission"] = "You are not allowed to use this command!",
                ["sentgt Invalid Format"] = "Invalid format! /sendgt <playername/id> <message> <length>",
                ["sendgtall Invalid Format"] = "Invalid format! /sendgtall <message> <length>",
                ["sentgt Invalid Format CONSOLE"] = "Invalid format! /sendgt <playername/id> <message> <length>",
                ["sendgtall Invalid Format CONSOLE"] = "Invalid format! /sendgtall <message> <length>",
                ["No Player Found"] = "No players were found with this name / ID",
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {
            defaultLengnth = Convert.ToSingle(GetConfig("Settings", "Default Fade Length", 15f));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        [ChatCommand("sendgt")]
        private void SendGameTipCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
            {
                player.ChatMessage(msg("NoPermission", player.UserIDString));
                return;
            }
            if (args.Length != 2 && args.Length != 3)
            {
                player.ChatMessage(msg("sentgt Invalid Format", player.UserIDString));
                return;
            }
            float length = defaultLengnth;
            if (args.Length == 3)
                float.TryParse(args[2], out length);
            BasePlayer receiver = BasePlayer.Find(args[0]);
            if (receiver == null)
            {
                player.ChatMessage(msg("No Player Found", player.UserIDString));
                return;
            }
            CreateGameTip(args[1], receiver, length);
        }

        [ChatCommand("sendgtall")]
        private void SendGameTipAllCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
            {
                player.ChatMessage(msg("NoPermission", player.UserIDString));
                return;
            }
            if (args.Length != 1 && args.Length != 2)
            {
                player.ChatMessage(msg("sendgtall Invalid Format", player.UserIDString));
                return;
            }
            float length = defaultLengnth;
            if (args.Length == 2)
                float.TryParse(args[1], out length);
            CreateGameTipAll(args[0], length);
        }

        [ConsoleCommand("sendgt")]
        private void SendGameTipAllCONSOLECMD(ConsoleSystem.Arg args)
        {
            if (args.Connection != null)
                return;
            if (args.Args.Length != 2 && args.Args.Length != 3)
            {
                Puts(msg("sentgt Invalid Format CONSOLE"));
                return;
            }
            float length = defaultLengnth;
            if (args.Args.Length == 3)
                float.TryParse(args.Args[2], out length);
            BasePlayer receiver = BasePlayer.Find(args.Args[0]);
            if (receiver == null)
            {
                Puts(msg("No Player Found"));
                return;
            }
            CreateGameTip(args.Args[1], receiver, length);
        }

        [ConsoleCommand("sendgtall")]
        private void SendGameTipCONSOLSECMD(ConsoleSystem.Arg args)
        {
            if (args.Connection != null)
                return;
            if (args.Args.Length != 1 && args.Args.Length != 2)
            {
                Puts(msg("sendgtall Invalid Format CONSOLE"));
                return;
            }
            float length = defaultLengnth;
            if (args.Args.Length == 2)
                float.TryParse(args.Args[1], out length);
            CreateGameTipAll(args.Args[0], length);
        }

        private void CreateGameTip(string text, BasePlayer player, float length = 30f)
        {
            if (player == null)
                return;
            player.SendConsoleCommand("gametip.hidegametip");
            player.SendConsoleCommand("gametip.showgametip", text);
            timer.Once(length, () => player?.SendConsoleCommand("gametip.hidegametip"));
        }

        private void CreateGameTipAll(string text, float length = 30f)
        {
            foreach(BasePlayer player in BasePlayer.activePlayerList)
                CreateGameTip(text, player, length);
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        string msg(string key, string id = null) => lang.GetMessage(key, this, id);
    }
}


// --- End of file: GameTipAnnouncements.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/global-progression ---
// --- Original File Path: G/GlobalProgression/GlobalProgression.cs ---


using Newtonsoft.Json;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace Oxide.Plugins
{
	[Info("Global Progression", "ignignokt84", "0.2.1")]
	[Description("Global blueprint learning")]
	class GlobalProgression : RustPlugin
	{
		Timer tickTimer;
		
		DataWrapper data = new DataWrapper();

		const string CommandRefresh = "refresh";
		const string CommandIgnore = "ignore";
		const string CommandUnignore = "unignore";

		const string PermAdministrate = "globalprogression.admin";
		const string PermIgnore = "globalprogression.ignore";

		#region Lang

		// load default messages to Lang
		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				{ "Prefix", "<color=#FFA500>[ GP ]</color>" },
				
				{ "Notify_BlueprintUnlocked", "<color=#00AA11>Blueprint(s) globally unlocked</color>: {0}" },
				{ "Notify_BlockedPrivileged", "<color=#EE0303>Blueprint for {0} has been queued for unlock and cannot be studied</color>" },
				{ "Notify_QueuedBlueprints", "<color=#00FFFF>Blueprint(s) queued for unlock</color>: {0}" },

				{ "Notify_TotalBlueprintCount", "Non-default blueprints found: {0}" },
				{ "Notify_BlueprintMissingCount", "Non-default blueprints to unlock: {0}" },
				{ "Notify_MissingBlueprintsUnlocked", "Missing blueprints unlocked: {0}" },
				{ "Notify_NoBlueprintsToUnlock", "No blueprints to unlock" },
				
				{ "Notify_RefreshComplete", "Refresh completed; took {0}ms" },

				{ "Error_InvalidCommand", "Invalid command" },

				{ "Wrapper_QueuedBlueprint", "{0} <color=#FF5522>({1})</color>" }
			}, this);
		}

		// send message to player (chat)
		void SendMessage(BasePlayer player, string key, object[] options = null)
		{
			if (player == null) return;
			SendReply(player, GetMessage("Prefix", player.UserIDString) + " " + GetMessage(key, player.UserIDString), options);
		}

		// send message to player (console)
		void SendMessage(ConsoleSystem.Arg arg, string key, object[] options = null)
		{
			string userIDString = arg?.Connection?.userid.ToString();
			if (arg != null)
				SendReply(arg, GetMessage("Prefix", userIDString) + " " + GetMessage(key, userIDString), options ?? new object[] { });
			else
				Puts(string.Format(GetMessage("Prefix") + " " + GetMessage(key), options));
		}

		// get message from Lang
		string GetMessage(string key, string userId = null) => lang.GetMessage(key, this, userId);

		#endregion

		#region Loading/Unloading

		// init
		void Init()
		{
			// register console/chat commands
			cmd.AddConsoleCommand("gp." + CommandRefresh, this, "CommandDelegator");
			cmd.AddConsoleCommand("gp." + CommandIgnore, this, "CommandDelegator");
			cmd.AddConsoleCommand("gp." + CommandUnignore, this, "CommandDelegator");
			cmd.AddChatCommand("gpq", this, "CheckQueue");

			permission.RegisterPermission(PermAdministrate, this);
			permission.RegisterPermission(PermIgnore, this);
		}

		// server initialized
		void OnServerInitialized()
		{
			LoadConfiguration();
			if (data.pendingBlueprints.Count > 0)
				tickTimer = timer.Every(data.tickRate, LocalTick);
			if (data.firstLoad)
			{
				RefreshBlueprints();
				data.firstLoad = false;
				SaveData();
			}
		}

		// on unloaded
		void Unload()
		{
			if (tickTimer != null)
				tickTimer.Destroy();

			SaveData();
		}

		#endregion

		#region Configuration/Data

		// load config
		void LoadConfiguration()
		{
			Config.Settings.NullValueHandling = NullValueHandling.Include;
			try
			{
				data = Config.ReadObject<DataWrapper>() ?? null;
			}
			catch (Exception)
			{
				LoadDefaultConfig();
			}
			if (data == null)
				LoadDefaultConfig();
		}

		// default config creation
		protected override void LoadDefaultConfig()
		{
			data = new DataWrapper();
			SaveData();
		}

		// save data
		void SaveData() => Config.WriteObject(data);

		#endregion

		#region Command Handling
		
		// delegation method for console commands
		void CommandDelegator(ConsoleSystem.Arg arg)
		{
			// return if user doesn't have access to run console command
			if (arg == null) return;
			string userIDString = arg?.Connection?.userid.ToString();

			if (userIDString == null || !HasPermission(userIDString, PermAdministrate)) return;

			// refresh globally unlocked blueprints by polling active/sleeping users and grant missing blueprints

			if (arg.cmd.Name.Equals(CommandRefresh, StringComparison.InvariantCultureIgnoreCase))
			{
				bool verbose = false;
				if (arg.HasArgs())
				{
					if (arg.Args[0].Equals("v") || arg.Args[0].Equals("verbose"))
						verbose = true;
				}

				RefreshBlueprints(arg, verbose);
				SaveData();
			}
			else
				SendMessage(arg, "Error_InvalidCommand");
		}

		// refresh blueprints by getting blueprints from all active players and sleepers
		void RefreshBlueprints(ConsoleSystem.Arg arg = null, bool verbose = false)
		{
			Stopwatch sw = new Stopwatch();
			sw.Start();
			if (arg == null)
				verbose = false;

			HashSet<string> playerBlueprints = new HashSet<string>();

			// get all blueprints from active players and sleepers
			List<BasePlayer> playerList = new List<BasePlayer>(BasePlayer.activePlayerList);
			playerList.AddRange(BasePlayer.sleepingPlayerList);

			foreach (BasePlayer player in playerList)
			{
				if (HasPermission(player.UserIDString, PermIgnore)) continue;
				PersistantPlayer playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
				playerBlueprints.UnionWith(playerInfo.unlockedItems.Select(i => ItemManager.FindItemDefinition(i)?.shortname));
			}

			// filter out default blueprints
			playerBlueprints.ExceptWith(ItemManager.defaultBlueprints.Select(i => ItemManager.FindItemDefinition(i)?.shortname));

			// couldn't hurt
			playerBlueprints.Remove(null);

			if (verbose)
				SendMessage(arg, "Notify_TotalBlueprintCount", new object[] { playerBlueprints.Count });

			// if empty, no blueprints to unlock
			if (playerBlueprints.Count == 0)
			{
				if (verbose)
					SendMessage(arg, "Notify_NoBlueprintsToUnlock");
				return;
			}

			if (verbose)
				SendMessage(arg, "Notify_BlueprintMissingCount", new object[] { data.unlockedBlueprints.Except(playerBlueprints).ToList().Count });

			// union global unlocked blueprints with the aggregated player blueprints
			data.unlockedBlueprints.UnionWith(playerBlueprints);

			int counter = 0;
			// force unlock for all players
			playerList = new List<BasePlayer>(BasePlayer.activePlayerList);

			foreach (BasePlayer player in playerList)
			{
				if (HasPermission(player.UserIDString, PermIgnore)) continue;
				counter += UnlockGlobalBlueprintsForPlayer(player, false);
			}

			// remove any pending blueprints that have been unlocked
			if(data.pendingBlueprints.Count > 0)
				foreach (string shortname in data.unlockedBlueprints)
					data.pendingBlueprints.Remove(shortname);

			if (verbose)
				SendMessage(arg, "Notify_MissingBlueprintsUnlocked", new object[] { counter });

			sw.Stop();
			SendMessage(arg, "Notify_RefreshComplete", new object[] { sw.ElapsedMilliseconds });
		}

		// handler for /gpq chat command (check bp queue)
		void CheckQueue(BasePlayer player, string command, string[] args)
		{
			List<ItemDefinition> pending = new List<ItemDefinition>();
			foreach (string shortname in data.pendingBlueprints.Keys)
			{
				ItemDefinition def = ItemManager.FindItemDefinition(shortname);
				if (def == null) continue;
				pending.Add(def);
			}
			DateTime now = DateTime.Now;
			string queuedString = "None";
			if(pending.Count > 0)
			{
				List<string> entries = new List<string>();
				foreach(ItemDefinition def in pending)
				{
					TimeSpan remainingTime = data.pendingBlueprints[def.shortname].unlockTime - now;
					int hours = remainingTime.Hours;
					int minutes = remainingTime.Minutes;
					int seconds = remainingTime.Seconds;
					string time = (hours > 0 ? hours + "h " : "") + (minutes > 0 ? minutes + "m " : "") + seconds + "s";
					entries.Add(string.Format(GetMessage("Wrapper_QueuedBlueprint", player.UserIDString), def.displayName.translated, time));
				}
				queuedString = string.Join(", ", entries);
			}
			SendMessage(player, "Notify_QueuedBlueprints", new object[] { queuedString });
		}

		#endregion

		#region Hooks/Methods

		// player joined - update with global blueprints
		void OnPlayerInit(BasePlayer player)
		{
			if (HasPermission(player.UserIDString, PermIgnore)) return;

			UnlockGlobalBlueprintsForPlayer(player, false);
			//if(data.sync)
			//	Sync(player);
		}

		// update unlocked blueprints for new player
		void Sync(BasePlayer player)
		{
			PersistantPlayer playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
			
			// get player unlocked blueprints; remove unlocked/pending blueprints from list, and immediately unlock any outstanding blueprints
			List<string> blueprintsToUnlock = playerInfo.unlockedItems.Select(i => ItemManager.FindItemDefinition(i)?.shortname)
												.Except(data.unlockedBlueprints)
												.Except(data.pendingBlueprints.Keys).ToList();

			if (blueprintsToUnlock.Count == 0) return;

			foreach (string shortname in blueprintsToUnlock)
				UnlockBlueprintForAllPlayers(shortname);
		}

		// when blueprint studied, queue blueprint for global learning
		object OnItemAction(Item item, string action, BasePlayer player)
		{
			if (!action.Equals("study")) return null;
			if (HasPermission(player.UserIDString, PermIgnore)) return null;

			string shortname = item.blueprintTargetDef.shortname;
			if (string.IsNullOrEmpty(shortname)) return null;

			if (data.unlockedBlueprints.Contains(shortname))
				return null;

			if(IsBlocked(shortname))
			{
				SendMessage(player, "Notify_BlockedPrivileged", new object[] { item.blueprintTargetDef.displayName.translated });
				return 0; // return non-null to block studying
			}
			
			// increment counter if blueprint is not already counting down to unlock
			if(!IsBlueprintUnlocking(shortname))
				Increment(shortname);
			
			return null;
		}

		// local tick - runs at interval defined by tickRate; terminated when no pending blueprints to unlock
		void LocalTick()
		{
			DateTime now = DateTime.Now;

			bool dirty = false;
			List<string> blueprintsToUnlock = GetBlueprintsToUnlock();
			foreach(string shortname in blueprintsToUnlock)
			{
				UnlockBlueprintForAllPlayers(shortname);
				data.pendingBlueprints.Remove(shortname);
				dirty = true;
			}

			if (dirty)
				SaveData();

			if (GetPendingUnlockCount() == 0)  // only continue tick if there are pending blueprints
				DestroyTimer();
		}

		// destroy timer
		void DestroyTimer()
		{
			tickTimer.Destroy();
			tickTimer = null;
		}

		// unlocks the specified blueprint for all players
		void UnlockBlueprintForAllPlayers(string shortname)
		{
			ItemDefinition itemDef = ItemManager.FindItemDefinition(shortname);
			if (itemDef == null) return;

			data.unlockedBlueprints.Add(shortname);

			List<BasePlayer> playerList = new List<BasePlayer>(BasePlayer.activePlayerList);
			foreach (BasePlayer player in playerList)
				UnlockBlueprintforPlayer(itemDef, player);
		}

		// unlocks the specified blueprint for a specific player
		void UnlockBlueprintforPlayer(ItemDefinition itemDef, BasePlayer player, bool notify = true)
		{
			if (HasPermission(player.UserIDString, PermIgnore)) return;
			if (player.blueprints.HasUnlocked(itemDef)) return;

			player.blueprints.Unlock(itemDef);
			if (notify)
				SendMessage(player, "Notify_BlueprintUnlocked", new object[] { itemDef.displayName.translated });
		}

		// unlocks all "global" blueprints for a specific player
		int UnlockGlobalBlueprintsForPlayer(BasePlayer player, bool notify = true)
		{
			List<string> itemNames = new List<string>();
			foreach(string shortname in data.unlockedBlueprints)
			{
				ItemDefinition itemDef = ItemManager.FindItemDefinition(shortname);
				if (itemDef == null) continue;

				itemNames.Add(itemDef.displayName.translated);
				UnlockBlueprintforPlayer(itemDef, player, false);
			}

			if(notify && itemNames.Count > 0)
				SendMessage(player, "Notify_BlueprintUnlocked", new object[] { string.Join(", ", itemNames.ToArray()) } );

			return itemNames.Count;
		}

		#endregion

		#region Helper Methods

		// check if player has permission
		private bool HasPermission(string userIDString, string permname)
		{
			return permission.UserHasPermission(userIDString, permname);
		}

		bool IsBlueprintUnlocked(string shortname)
		{
			return data.unlockedBlueprints.Contains(shortname);
		}

		// item is currently unlocking (timer running)
		bool IsBlueprintUnlocking(string shortname)
		{
			Blueprint b;
			if(!data.pendingBlueprints.TryGetValue(shortname, out b))
				return false;

			return b.counter >= data.threshold && b.unlockTime.CompareTo(DateTime.Now) > 0;
		}

		bool ShouldUnlock(string shortname)
		{
			Blueprint b;
			if (!data.pendingBlueprints.TryGetValue(shortname, out b))
				return false;
			
			return b.counter >= data.threshold && b.unlockTime.CompareTo(DateTime.Now) <= 0;
		}

		bool IsBlocked(string shortname)
		{
			if (!data.blocking) return false;

			return IsBlueprintUnlocking(shortname);
		}

		int GetPendingUnlockCount()
		{
			if (data.pendingBlueprints.Count == 0) return 0;
			return data.pendingBlueprints.Values.Count(b => b.counter >= data.threshold && b.unlockTime.CompareTo(DateTime.Now) > 0);
		}

		List<string> GetBlueprintsToUnlock()
		{
			if (data.pendingBlueprints == null || data.pendingBlueprints.Count == 0)
				return new List<string>();
			return data.pendingBlueprints.Values.Where(b => b.counter >= data.threshold && b.unlockTime.CompareTo(DateTime.Now) <= 0).Select(b => b.shortname).ToList();
		}

		void Increment(string shortname)
		{
			Blueprint b;
			if (!data.pendingBlueprints.TryGetValue(shortname, out b))
				b = new Blueprint() { shortname = shortname, counter = 0, unlockTime = DateTime.MaxValue };

			if (++b.counter >= data.threshold)
			{
				if (data.delay <= 0)
				{
					UnlockBlueprintForAllPlayers(shortname);
					data.pendingBlueprints.Remove(shortname);

					if (GetPendingUnlockCount() == 0)  // destroy timer if no pending unlocks
						DestroyTimer();

					return;
				}
				else
					b.unlockTime = DateTime.Now.AddSeconds(data.delay);
			}

			data.pendingBlueprints[shortname] = b;
			if (tickTimer == null && GetPendingUnlockCount() > 0)
				tickTimer = timer.Every(data.tickRate, LocalTick);

			SaveData();
		}

		#endregion

		#region Subclasses

		// config data wrapper class
		class DataWrapper
		{
			[JsonProperty(PropertyName = "First Load")]
			public bool firstLoad = true;
			[JsonProperty(PropertyName = "Blocking")]
			public bool blocking = false; // block other players from learning the blueprint until the global unlock timer finishes
			//[JsonProperty(PropertyName = "Sync on Player Join")]
			//public bool sync = true;
			[JsonProperty(PropertyName = "Global Unlock Threshold")]
			public int threshold = 1; // how many players need to study to start the global unlock countdown
			[JsonProperty(PropertyName = "Learning Delay")]
			public int delay = 600; // delay in seconds (realtime), default 600s (10min)
			[JsonProperty(PropertyName = "Tick Rate")]
			public float tickRate = 1f; // tick rate for internal checking
			[JsonProperty(PropertyName = "Unlocked Blueprints")]
			public HashSet<string> unlockedBlueprints = new HashSet<string>(); // unlocked blueprints
			[JsonProperty(PropertyName = "Pending Blueprints")]
			public Dictionary<string, Blueprint> pendingBlueprints = new Dictionary<string, Blueprint>(); // pending unlocks
		}

		// blueprint unlock container
		[Serializable]
		struct Blueprint
		{
			public string shortname;
			public short counter;
			public DateTime unlockTime;
		}

		#endregion
	}
}

// --- End of file: GlobalProgression.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/global-mail ---
// --- Original File Path: G/GlobalMail/GlobalMail.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Global Mail", "Hovmodet", "1.0.4")]
    [Description("Allows you to mail a single item from monuments back to your base.")]
    class GlobalMail : RustPlugin
    {
        List<BuildingPrivlidge> BuildingsWithMailBoxes = new List<BuildingPrivlidge>();
        Dictionary<ulong, StorageContainer> GlobalMailBoxes = new Dictionary<ulong, StorageContainer>();

        List<Vector3> SmallMonumentsPosition = new List<Vector3>();
        List<Vector3> MediumMonumentsPosition = new List<Vector3>();
        List<Vector3> LargeMonumentsPosition = new List<Vector3>();
        Vector3 OutpostPosition = new Vector3();
        Vector3 BanditCampPosition = new Vector3();
        #region Setup
        bool AutoPlaceMailbox = true;
        bool CanEmptyAtMonument = false;
        bool CanFillAtBase = false;
        bool CanPlaceMultipleMailBoxes = false;
        bool CanOpenMailBoxAtBuildingBlock = false;

        bool SpawnMailAtSmallMonuments = true;
        bool SpawnMailAtMediumMonuments = true;
        bool SpawnMailAtLargeMonuments = true;
        bool SpawnMailAtBanditCamp = true;
        bool SpawnMailAtOutpost = true;

        bool GivePlayersMailBoxBlueprint = false;

        int MaxStackSizeInMailbox = 0;

        protected override void LoadDefaultConfig()
        {
            Config["AutoPlaceMailbox"] = true;
            Config["CanEmptyAtMonument"] = false;
            Config["CanFillAtBase"] = false;
            Config["CanPlaceMultipleMailBoxes"] = false;
            Config["CanOpenMailBoxAtBuildingBlock"] = false;
            Config["SpawnMailAtSmallMonuments"] = true;
            Config["SpawnMailAtMediumMonuments"] = true;
            Config["SpawnMailAtLargeMonuments"] = true;
            Config["SpawnMailAtBanditCamp"] = true;
            Config["SpawnMailAtOutpost"] = true;
            Config["GivePlayersMailBoxBlueprint"] = false;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["en_CantPlace"] = "You dont have permission to place a mailbox here.",
                ["en_BuildingOccupied"] = "There is allready a mailbox at this building.",
                ["en_CantEmpty"] = "You can't empty your mailbox from here.",
                ["en_CantSend"] = "You can't send out mail from here.",
                ["en_MailFull"] = "Your mailbox is full, emtpy it at your base.",
                ["en_CantAccess"] = "You don't have permissions to use this mailbox.",
                ["en_NoPermission"] = "You don't have permissions to look into other players mailbox.",
                ["en_InvalidSteamID"] = "'{0}' is not a valid Steam ID",
                ["en_CantStack"] = "You cannot stack items in the mailbox.",
                ["en_NoUsePerm"] = "You dont have permissions to use mailboxes."
            }, this);
        }

        #endregion


        #region ChatCmd
        [ChatCommand("placemail")]
        private void cmdPlaceMail(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, "globalmail.placemail") == false)
            {
                SendReply(player, "no perm");
                return;
            }
            
            if (!previewMailBox.ContainsKey(player))
            {
                PlacementMailbox pm = new PlacementMailbox();
                pm.player = player;
                previewMailBox.Add(player, pm);
            }
        }
            [ChatCommand("mail")]
        private void cmdMail(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 1)
            {
                ulong id;
                if (ulong.TryParse(args[0], out id))
                {
                        OpenPlayersMailbox(player, id);
                }
                else
                {
                    SendReply(player, string.Format(lang.GetMessage("en_InvalidSteamID", this), args[0]));
                }
            }

        }
        #endregion

        #region Oxide Hooks


        object OnPlayerTick(BasePlayer player, PlayerTick msg, bool wasPlayerStalled)
        {
            if (previewMailBox.ContainsKey(player))
            {
                if (previewMailBox[player].placed == false)
                {
                    UpdateMailBoxPosition(player);
                }
            }
            return null;
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if(input.IsDown(BUTTON.FIRE_PRIMARY) & previewMailBox.ContainsKey(player))
            {
                previewMailBox[player].mailbox.OwnerID = 0;
                previewMailBox[player].placed = true;
                previewMailBox.Remove(player);
            }
            else if (input.IsDown(BUTTON.FIRE_SECONDARY) & previewMailBox.ContainsKey(player))
            {
                previewMailBox[player].mailbox.Kill();
                previewMailBox[player].placed = true;
                previewMailBox.Remove(player);
            }
        }

        private void Init()
        {
            permission.RegisterPermission("globalmail.lootmail", this);
            permission.RegisterPermission("globalmail.placemail", this);
            permission.RegisterPermission("globalmail.use", this);

            AutoPlaceMailbox = (bool)Config["AutoPlaceMailbox"];
            CanEmptyAtMonument = (bool)Config["CanEmptyAtMonument"];
            CanFillAtBase = (bool)Config["CanFillAtBase"];
            CanPlaceMultipleMailBoxes = (bool)Config["CanPlaceMultipleMailBoxes"];
            CanOpenMailBoxAtBuildingBlock = (bool)Config["CanOpenMailBoxAtBuildingBlock"];

            SpawnMailAtSmallMonuments = (bool)Config["SpawnMailAtSmallMonuments"];
            SpawnMailAtMediumMonuments = (bool)Config["SpawnMailAtMediumMonuments"];
            SpawnMailAtLargeMonuments = (bool)Config["SpawnMailAtLargeMonuments"];
            SpawnMailAtBanditCamp = (bool)Config["SpawnMailAtBanditCamp"];
            SpawnMailAtOutpost = (bool)Config["SpawnMailAtOutpost"];

            GivePlayersMailBoxBlueprint = (bool)Config["GivePlayersMailBoxBlueprint"];


        }

        object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            if (planner.GetOwnerPlayer() == null)
                return null;

            if(prefab.prefabID == 2697131904)
            {
                BasePlayer player = planner.GetOwnerPlayer();
                if(!player.IsBuildingAuthed())
                {
                    
                    SendReply(player, lang.GetMessage("en_CantPlace", this));
                    return false;
                }

                if(BuildingsWithMailBoxes.Contains(player.GetBuildingPrivilege()) & !CanPlaceMultipleMailBoxes )
                {
                    SendReply(player, lang.GetMessage("en_BuildingOccupied", this));
                    return false;
                }

                    BuildingsWithMailBoxes.Add(player.GetBuildingPrivilege());

            }
            return null;
        }

        private object CanAcceptItem(ItemContainer container, Item item)
        {
            if(container.entityOwner == null)
            return null;

            if (container.entityOwner.ShortPrefabName == "woodbox_deployed" & container.entityOwner.transform.position == new Vector3(0,0,0))
            {
                if (item.GetOwnerPlayer() == null)
                    return null;

                BasePlayer player = item.GetOwnerPlayer();

                if(player.IsBuildingAuthed() & !CanFillAtBase)
                {
                    SendReply(player, lang.GetMessage("en_CantSend", this));
                    return ItemContainer.CanAcceptResult.CannotAccept;
                }
                else if (container.itemList.Count > 0)
                {
                    if (container.itemList[0].IsLocked())
                    {
                        SendReply(player, lang.GetMessage("en_MailFull", this));
                        return ItemContainer.CanAcceptResult.CannotAccept;
                    }
                }

            }

            return null;
        }

        object CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer, int targetSlot, int amount)
        {
            if (item.IsLocked())
                return false;

            BasePlayer player = null;
            if (item.GetOwnerPlayer() != null)
                player = item.GetOwnerPlayer();
            else player = playerLoot.GetComponent<BasePlayer>();

            ItemContainer container = playerLoot.FindContainer(targetContainer);
            ItemContainer originalContainer = item.GetRootContainer();

            if (container == null) return null;
            if (originalContainer == null) return null;
            if (container == originalContainer)
                return null;

            string containerIs = "";
            string orginalContainerIs = "";
            if (container.entityOwner == null)
                containerIs = "player";

            else if(container.entityOwner.ShortPrefabName == "woodbox_deployed" & container.entityOwner.transform.position == new Vector3(0, 0, 0))
                containerIs = "mail";


            if (originalContainer.entityOwner == null)
                orginalContainerIs = "player";

            else if (originalContainer.entityOwner.ShortPrefabName == "woodbox_deployed" & originalContainer.entityOwner.transform.position == new Vector3(0, 0, 0))
                orginalContainerIs = "mail";


            if (containerIs != "mail" & orginalContainerIs != "mail")
                return null;

            if (containerIs == "mail" & item.amount > 1)
            {
                SendReply(player, lang.GetMessage("en_CantStack", this));
                return false;
            }

            Item i = container.GetSlot(targetSlot);

            if (i == null)
                return null;
            
            if (item.info.itemid != i.info.itemid)
                return false;

            if (item.info.itemid == i.info.itemid & item.amount + i.amount <= item.MaxStackable())
                return null;

            if (containerIs == "mail" & i.amount > 1)
            {
                SendReply(player, lang.GetMessage("en_CantStack", this));
                return false;
            }

            if (item.amount + i.amount > item.MaxStackable())
                return false;

            return null;
        }

        object CanStackItem(Item item, Item targetItem)
        {
            if (item.IsLocked() | targetItem.IsLocked())
                return false;


            return null;
        }

        void OnEntityKill(Mailbox mailBox)
        {
            if (BuildingsWithMailBoxes.Contains(mailBox.GetBuildingPrivilege()))
                BuildingsWithMailBoxes.Remove(mailBox.GetBuildingPrivilege());
        }

        object OnEntityTakeDamage(Mailbox mailBox, HitInfo info)
        {
            if (mailBox.OwnerID == 0)
                return false;
            return null;
        }

        object CanLootEntity(BasePlayer player, Mailbox container)
        {
            return false;
        }

        bool CanUseMailbox(BasePlayer player, Mailbox mailbox)
        {
            if (player.IsBuildingAuthed() | mailbox.OwnerID == 0)
            {
                if (permission.UserHasPermission(player.UserIDString, "globalmail.use") == true)
                    OpenContainer(player);
                else SendReply(player, lang.GetMessage("en_NoUsePerm", this));
            }
            else
                SendReply(player, lang.GetMessage("en_CantAccess", this));

            return false;
        }

        void OnServerInitialized(bool initial)
        {
            FindMonuments();
            LoadAllMailBoxes();

            if(AutoPlaceMailbox)
                FindRecyclers();
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if(GivePlayersMailBoxBlueprint)
            {
                learnMailBox(player);
            }
        }

        #endregion

        #region Functions

        Dictionary<BasePlayer,PlacementMailbox> previewMailBox = new Dictionary<BasePlayer, PlacementMailbox>();
        private void UpdateMailBoxPosition(BasePlayer player)
        {
            if (!previewMailBox.ContainsKey(player))
                return;

            if (previewMailBox[player].placed)
            {
                previewMailBox.Remove(player);
                return;
            }

            Mailbox m = previewMailBox[player].mailbox;

            RaycastHit hit;
            var layers = LayerMask.GetMask("Construction", "Default", "Resource", "Terrain", "Water", "World");
            Physics.Raycast(player.eyes.HeadRay(), out hit, 10f,layers);
            if (hit.point == Vector3.zero)
                return;

            Quaternion rot = player.GetNetworkRotation();
            rot.z = 0;
            rot.x = 0;
            if (previewMailBox[player].mailbox == null)
            {
                BaseEntity box = GameManager.server.CreateEntity("assets/prefabs/deployable/mailbox/mailbox.deployed.prefab", hit.point, rot);
                box.OwnerID = 1;
                UnityEngine.Object.Destroy(box.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.Destroy(box.GetComponent<GroundWatch>());
                box.Spawn();
                previewMailBox[player].mailbox = (Mailbox)box;
                m = previewMailBox[player].mailbox;
            }
            else
            {
                if (hit.point == m.transform.position & player.transform.rotation == m.transform.rotation)
                    return;

                m.transform.position = hit.point;
                m.transform.rotation = rot;
                m.SendNetworkUpdateImmediate();
            }
        }

        private void learnMailBox(BasePlayer player)
        {
            var playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
            if (playerInfo.unlockedItems.Contains(-586784898) == false)
            {
                playerInfo.unlockedItems.Add(-586784898);
                SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerInfo(player.userID, playerInfo);
                player.SendNetworkUpdateImmediate();
                player.ClientRPCPlayer(null, player, "UnlockedBlueprint", 0);
            }
        }

        private string FindMonumentClosestToRecycler(Vector3 RecyclerPosition)
        {
            float distance = float.MaxValue;
            float dist;

            dist = Vector3.Distance(BanditCampPosition, RecyclerPosition);
            if (dist < distance) distance = dist;
            if (distance < 150)
            {
                return "bandit";
            }

            dist = Vector3.Distance(OutpostPosition, RecyclerPosition);
            if (dist < distance) distance = dist;
            if (distance < 150)
            {
                return "outpost";
            }

            for (int i = 0; i < SmallMonumentsPosition.Count; i++)
            {
                dist = Vector3.Distance(SmallMonumentsPosition[i], RecyclerPosition);
                if (dist < distance) distance = dist;
            }
            if(distance < 150)
            {
                return "small";
            }

            for (int i = 0; i < MediumMonumentsPosition.Count; i++)
            {
                dist = Vector3.Distance(MediumMonumentsPosition[i], RecyclerPosition);
                if (dist < distance) distance = dist;
            }
            if (distance < 150)
            {
                return "medium";
            }

            for (int i = 0; i < LargeMonumentsPosition.Count; i++)
            {
                dist = Vector3.Distance(LargeMonumentsPosition[i], RecyclerPosition);
                if (dist < distance) distance = dist;
            }
            if (distance < 150)
            {
                return "large";
            }

            return "ingen "+ RecyclerPosition.ToString();
        }

        private void FindRecyclers()
        {
            Mailbox[] mBox = UnityEngine.Object.FindObjectsOfType<Mailbox>();
            foreach(Mailbox m in mBox)
            {
                if (m.OwnerID == 0)
                    m.Kill();
            }
            Recycler[] Recyclers = UnityEngine.Object.FindObjectsOfType<Recycler>();
            foreach(Recycler recycler in Recyclers)
            {
                string type = FindMonumentClosestToRecycler(recycler.transform.position);
                if (type == "small" & SpawnMailAtSmallMonuments || type == "medium" & SpawnMailAtMediumMonuments || type == "large" & SpawnMailAtLargeMonuments || type == "bandit" & SpawnMailAtBanditCamp || type == "outpost" & SpawnMailAtOutpost)
                {
                    BaseEntity box = GameManager.server.CreateEntity("assets/prefabs/deployable/mailbox/mailbox.deployed.prefab", recycler.transform.position - recycler.transform.right * 1.2f, recycler.transform.rotation);
                    box.OwnerID = 0;
                    UnityEngine.Object.Destroy(box.GetComponent<DestroyOnGroundMissing>());
                    UnityEngine.Object.Destroy(box.GetComponent<GroundWatch>());
                    box.Spawn();
                }
            }
        }

        private void FindMonuments()
        {
            GameObject[] allobjects = UnityEngine.Object.FindObjectsOfType<GameObject>();
            for (int i = 0; i < allobjects.Length; i++)
            {
                GameObject gobject = allobjects[i];

                if (gobject.name.Contains("autospawn/monument"))
                {
                    var pos = gobject.transform.position;
                    if (!pos.Equals(new Vector3(0, 0, 0)))
                    {
                        if (gobject.name.Contains("/small/") | gobject.name.Contains("lighthouse") | gobject.name.Contains("warehouse") | gobject.name.Contains("supermarket") | gobject.name.Contains("gas_station") && SpawnMailAtSmallMonuments)
                        {
                            if (!SmallMonumentsPosition.Contains(pos))
                                SmallMonumentsPosition.Add(pos);
                        }
                        else if (gobject.name.Contains("bandit_town") & SpawnMailAtBanditCamp)
                        {
                            BanditCampPosition = pos;
                        }
                        else if (gobject.name.Contains("compound") & SpawnMailAtOutpost)
                        {
                            OutpostPosition = pos;
                        }
                        else if (gobject.name.Contains("/medium/") & !gobject.name.Contains("bandit_town") & !gobject.name.Contains("compound") & SpawnMailAtMediumMonuments)
                        {
                            if (!MediumMonumentsPosition.Contains(pos))
                            { 
                                MediumMonumentsPosition.Add(pos);
                            }
                        }
                        else if (gobject.name.Contains("/large/") & SpawnMailAtLargeMonuments)
                        {
                            if (!LargeMonumentsPosition.Contains(pos))
                                LargeMonumentsPosition.Add(pos);
                        }
                    }
                }
            }
        }

        private void LoadAllMailBoxes()
        {
            BaseEntity[] Boxes = UnityEngine.Object.FindObjectsOfType<BaseEntity>();
            Mailbox[] MailBoxes = UnityEngine.Object.FindObjectsOfType<Mailbox>();
            foreach (BaseEntity Box in Boxes)
            {
                if(Box.ShortPrefabName == "woodbox_deployed" & Box.transform.position == new Vector3(0,0,0))
                {
                    if (!GlobalMailBoxes.ContainsKey(Box.OwnerID))
                    {
                        StorageContainer container = null;
                        container = Box.GetComponent<StorageContainer>();
                        GlobalMailBoxes.Add(Box.OwnerID, container);
                    }
                }
            }
            foreach (Mailbox Mail in MailBoxes)
            {
                if(Mail.OwnerID != 0 & Mail.GetBuildingPrivilege() != null)
                        if(!BuildingsWithMailBoxes.Contains(Mail.GetBuildingPrivilege()))
                            BuildingsWithMailBoxes.Add(Mail.GetBuildingPrivilege());
            }
        }

        private void OpenContainer(BasePlayer player, ulong steamid = 0)
        {
            StorageContainer container = null;
            if (steamid != 0)
            {
                if (GlobalMailBoxes.ContainsKey(steamid))
                    container = GlobalMailBoxes[steamid];
            }
            else
            {
                if (GlobalMailBoxes.ContainsKey(player.userID))
                    container = GlobalMailBoxes[player.userID];
            }
            
            if (container == null)
            {
                BaseEntity box = GameManager.server.CreateEntity("assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab", new Vector3(0, 0, 0));
                if (steamid == 0)
                    box.OwnerID = player.userID;
                else box.OwnerID = steamid;
                (box as BaseNetworkable).limitNetworking = true;
                UnityEngine.Object.Destroy(box.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.Destroy(box.GetComponent<GroundWatch>());
                box.Spawn();
                container = box.GetComponent<StorageContainer>();
                if (steamid == 0)
                {
                    if (!GlobalMailBoxes.ContainsKey(player.userID))
                        GlobalMailBoxes.Add(player.userID, container);
                }
                else
                {
                    if (!GlobalMailBoxes.ContainsKey(steamid))
                        GlobalMailBoxes.Add(steamid, container);
                }
            }

            container.inventory.capacity = 1;


            if (!CanEmptyAtMonument & steamid == 0)
            {
                foreach (Item i in container.inventory.itemList)
                {
                    i.LockUnlock(!player.IsBuildingAuthed());
                }
            }


          timer.Once(0.1f, () =>
            {
                player.EndLooting();
                if (!player.inventory.loot.StartLootingEntity(container, false)) { return; }
                player.inventory.loot.AddContainer(container.inventory);
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel",container.panelName);
                player.SendNetworkUpdate();
            });
        }

        private void OpenPlayersMailbox(BasePlayer player, ulong steamid)
        {
            if (permission.UserHasPermission(player.UserIDString, "globalmail.lootmail") == true)
                OpenContainer(player, steamid);
            else 
                SendReply(player, lang.GetMessage("en_NoPermission", this));
        }
        #endregion
    }
    #region Classes
    class PlacementMailbox
    {
       public Mailbox mailbox;
       public BasePlayer player;
       public bool placed;
    }
    #endregion
}


// --- End of file: GlobalMail.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/give ---
// --- Original File Path: G/Give/Give.cs ---

/***********************************************************************************************************************/
/*** DO NOT edit this file! Edit the files under `oxide/config` and/or `oxide/lang`, created once plugin has loaded. ***/
/*** Please note, support cannot be provided if the plugin has been modified. Please use a fresh copy if modified.   ***/
/***********************************************************************************************************************/

//#define DEBUG

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

// TODO: Add optional arg to put items in specific slots
// TODO: Add optional arg to use a custom name for items (Rust only)

namespace Oxide.Plugins
{
#if SEVENDAYSTODIE
    using UnityEngine;
#elif REIGNOFKINGS
    using CodeHatch.Engine.Networking;
    using CodeHatch.Inventory.Blueprints;
    using CodeHatch.Inventory.Blueprints.Components;
    using CodeHatch.ItemContainer;
    using UnityEngine;
#endif

    [Info("Give", "Wulf", "3.4.1")]
    [Description("Allows players with permission to give items or kits")]
    public class Give : CovalencePlugin
    {
        #region Configuration

        private Configuration _config;

        public class Configuration
        {
            // TODO: Add optional cooldown for commands

            [JsonProperty("Item blacklist (name or item ID)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> ItemBlacklist = new List<string>();

            [JsonProperty("Log usage to console")]
            public bool LogToConsole = false;

            //[JsonProperty("Log usage to file")] // TODO: Implement logging options
            //public bool LogToFile = false;

            //[JsonProperty("Rotate logs daily")] // TODO: Implement logging options
            //public bool RotateLogs = true;

            [JsonProperty("Show chat notices")]
            public bool ShowChatNotices = false;
#if RUST
            [JsonProperty("Show popup notices")]
            public bool ShowPopupNotices = false;
#endif
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandGive"] = "give",
                ["CommandGiveAll"] = "giveall",
                ["CommandGiveArm"] = "givearm",
                ["CommandGiveTo"] = "giveto",
                ["CommandGiveKit"] = "givekit",
                ["CommandGiveKitTo"] = "givekitto",
                ["CommandGiveKitAll"] = "givekitall",
                ["GiveKitAllFail"] = "Could not give kit '{0}' to {1} player(s)",
                ["GiveKitAllSuccess"] = "Gave kit '{0}' to {1} player(s)",
                ["GiveKitFail"] = "Could not give kit '{0}' to yourself",
                ["GiveKitSuccess"] = "Gave kit '{0}' to yourself",
                ["GiveKitToFail"] = "Could not give kit '{0}' to '{1}'",
                ["GiveKitToSuccess"] = "Gave kit '{0}' to '{1}'",
                ["GiveAllFail"] = "Could not give item {0} x {1} to {2} player(s)",
                ["GiveAllSuccess"] = "Gave item {0} x {1} to {2} player(s)",
                ["GiveFail"] = "Could not give item {0} x {1} to yourself",
                ["GiveSuccess"] = "Gave item {0} x {1} to yourself",
                ["GiveToFail"] = "Could not give item {0} x {1} to '{2}'",
                ["GiveToSuccess"] = "Gave item {0} x {1} to '{2}'",
                ["InvalidItem"] = "{0} is not a valid item or is blacklisted",
                ["InvalidKit"] = "{0} is not a valid kit",
                ["ItemNotFound"] = "Could not find any item by name or ID '{0}' to give",
                ["ItemReceived"] = "You've received {0} x {1}",
                ["KitsUnavailable"] = "Kits plugin is not installed or is not loaded",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["NoPlayersConnected"] = "There are no players connected to give items to",
                ["NoPlayersFound"] = "No players found with name or ID '{0}'",
                ["PlayersFound"] = "Multiple players were found, please specify: {0}",
                ["PlayersOnly"] = "Command '{0}' can only be used by a player",
                ["PlayerNotConnected"] = "Unable to give to player '{0} ({1})', not connected",
#if RUST
                ["UsageGive"] = "Usage: {0} <item id or name> [amount] [condition fraction] [skin id]",
                ["UsageGiveAll"] = "Usage: {0} <item id or name> [amount] [skin id]",
                ["UsageGiveTo"] = "Usage: {0} <player id or name> <item id or name> [amount] [skin id]",
                ["UsageGiveArm"] = "Usage: {0} <item id or name> [amount] [skin id]",
#else
                ["UsageGive"] = "Usage: {0} <item id or name> [amount]",
                ["UsageGiveAll"] = "Usage: {0} <item id or name> [amount]",
                ["UsageGiveTo"] = "Usage: {0} <player id or name> <item id or name> [amount]",
                ["UsageGiveArm"] = "Usage: {0} <item id or name> [amount]",
#endif
                ["UsageGiveKit"] = "Usage: {0} <kit name>",
                ["UsageGiveKitTo"] = "Usage: {0} <player id or name> <kit name>",
                ["UsageGiveKitAll"] = "Usage: {0} <kit name>"
            }, this);
        }

        #endregion Localization

        #region Initialization

#if HURTWORLD
        [PluginReference("HWKits")]
        private Plugin Kits;
#else
        [PluginReference]
        private Plugin Kits;
#endif

        private const string PermissionGive = "give.self";
        private const string PermissionGiveAll = "give.all";
#if REIGNOFKINGS || RUST
        private const string PermissionGiveArm = "give.arm";
#endif
        private const string PermissionGiveTo = "give.to";
        private const string PermissionGiveKit = "give.kit";
        private const string PermissionGiveKitAll = "give.kitall";
        private const string PermissionGiveKitTo = "give.kitto";
        private const string PermissionBypassBlacklist = "give.bypassblacklist";

        private void Init()
        {
            permission.RegisterPermission(PermissionGive, this);
            permission.RegisterPermission(PermissionGiveAll, this);
#if REIGNOFKINGS || RUST
            permission.RegisterPermission(PermissionGiveArm, this);
#endif
            permission.RegisterPermission(PermissionGiveTo, this);
            permission.RegisterPermission(PermissionGiveKit, this);
            permission.RegisterPermission(PermissionGiveKitAll, this);
            permission.RegisterPermission(PermissionGiveKitTo, this);
            permission.RegisterPermission(PermissionBypassBlacklist, this);

            AddLocalizedCommand(nameof(CommandGive));
            AddCovalenceCommand(new[] { "inventory.give", "inventory.giveid", "giveid" }, nameof(CommandGive));
            AddLocalizedCommand(nameof(CommandGiveAll));
            AddCovalenceCommand("inventory.giveall", nameof(CommandGiveAll));
            AddLocalizedCommand(nameof(CommandGiveAll));
#if REIGNOFKINGS || RUST
            AddCovalenceCommand("inventory.givearm", nameof(CommandGiveArm));
#endif
            AddLocalizedCommand(nameof(CommandGiveTo));
            AddCovalenceCommand("inventory.giveto", nameof(CommandGiveTo));
            AddLocalizedCommand(nameof(CommandGiveKit));
            AddCovalenceCommand("inventory.givekit", nameof(CommandGiveKit));
            AddLocalizedCommand(nameof(CommandGiveKitAll));
            AddCovalenceCommand("inventory.givekitall", nameof(CommandGiveKitAll));
            AddLocalizedCommand(nameof(CommandGiveKitTo));
            AddCovalenceCommand("inventory.givekitto", nameof(CommandGiveKitTo));
        }

        #endregion Initialization

        #region Item Giving

#if HURTWORLD
        private T GetObjectByGuid<T>(string guid) where T : UnityEngine.Object
        {
            HurtAssetDatabaseRecord databaseRecord;
            if (RuntimeHurtDB.Instance._objectDatabase.TryGetValue(guid, out databaseRecord))
            {
                return databaseRecord.Object as T;
            }

            return null;
        }

        private ItemGeneratorAsset FindItem(string itemNameOrId)
        {
            ItemGeneratorAsset item;
            int itemId;

            if (int.TryParse(itemNameOrId, out itemId))
            {
                item = GetItemGeneratorAsset(null, itemId);
            }
            else
            {
                item = GetObjectByGuid<ItemGeneratorAsset>(itemNameOrId);
                if (item == null)
                {
                    item = GetItemGeneratorAsset(itemNameOrId);
                }
            }

            return item;
        }

        private ItemGeneratorAsset GetItemGeneratorAsset(string itemName, int itemId = -1)
        {
            foreach (KeyValuePair<int, ItemGeneratorAsset> itemGenerator in GlobalItemManager.Instance.GetGenerators())
            {
                if (itemId != -1 && itemGenerator.Value.GeneratorId == itemId)
                {
                    return itemGenerator.Value;
                }

                if (itemName != null && (itemName == itemGenerator.Value.DataProvider.NameKey || itemGenerator.Value.DataProvider.NameKey.ToLower().Contains(itemName)))
                {
                    return itemGenerator.Value;
                }
            }

            return null;
        }
#elif RUST
        private ItemDefinition FindItem(string itemNameOrId)
        {
            ItemDefinition itemDef = ItemManager.FindItemDefinition(itemNameOrId.ToLower());
            if (itemDef == null)
            {
                int itemId;
                if (int.TryParse(itemNameOrId, out itemId))
                {
                    itemDef = ItemManager.FindItemDefinition(itemId);
                }
            }
            return itemDef;
        }
#endif

        private object GiveItem(IPlayer player, string itemNameOrId, int amount = 1, string container = "main", float condition = 1f, ulong skinId = 0uL)
        {
            if (!player.IsConnected)
            {
                return false;
            }

            if (_config.ItemBlacklist.Contains(itemNameOrId, StringComparer.OrdinalIgnoreCase) && !player.HasPermission(PermissionBypassBlacklist))
            {
                return null;
            }

            string itemName = itemNameOrId;
#if SEVENDAYSTODIE
            EntityPlayer entityPlayer = player.Object as EntityPlayer;
            if (entityPlayer == null)
            {
                return false;
            }

            ItemValue itemValue = ItemClass.GetItem(itemName, true);
            if (itemValue.type == ItemValue.None.type)
            {
                return null;
            }

            ClientInfo clientInfo = ConsoleHelper.ParseParamEntityIdToClientInfo(entityPlayer.entityId.ToString());
            if (clientInfo != null)
            {
                if (!entityPlayer.IsSpawned() || entityPlayer.IsDead())
                {
                    return false;
                }

                EntityItem entityItem = (EntityItem)EntityFactory.CreateEntity(new EntityCreationData
                {
                    entityClass = EntityClass.FromString("item"),
                    id = EntityFactory.nextEntityID++,
                    itemStack = new ItemStack(new ItemValue(itemValue.type, 6, 6), amount),
                    pos = entityPlayer.position,
                    rot = new Vector3(20f, 0f, 20f),
                    lifetime = 60f,
                    belongsPlayerId = clientInfo.entityId
                });
                GameManager.Instance.World.SpawnEntityInWorld(entityItem);
                clientInfo.SendPackage(NetPackageManager.GetPackage<NetPackageEntityCollect>().Setup(entityItem.entityId, clientInfo.entityId));
                GameManager.Instance.World.RemoveEntity(entityItem.entityId, EnumRemoveEntityReason.Despawned);
                itemName = itemValue.ItemClass.GetLocalizedItemName() ?? itemValue.ItemClass.Name;
            }
#elif HURTWORLD
            ItemGeneratorAsset generator = FindItem(itemName.ToLower());
            if (generator == null)
            {
                return null;
            }

            PlayerSession session = player.Object as PlayerSession;
            if (session == null)
            {
                return false;
            }

            PlayerInventory inventory = session.WorldPlayerEntity.GetComponent<PlayerInventory>();
            ItemObject itemObj;
            for (int i = 0; amount > 0 && (amount <= generator.DataProvider.MaxStackSize || generator.DataProvider.MaxStackSize <= amount); i++)
            {
                itemObj = GlobalItemManager.Instance.CreateItem(generator, generator.DataProvider.MaxStackSize < amount ? generator.DataProvider.MaxStackSize : amount);
                if (!inventory.GiveItemServer(itemObj))
                {
                    GlobalItemManager.SpawnWorldItem(itemObj, inventory);
                }
                amount -= generator.DataProvider.MaxStackSize < amount ? generator.DataProvider.MaxStackSize : amount;
            }
#elif REIGNOFKINGS
            Player rokPlayer = player.Object as Player;
            if (rokPlayer == null)
            {
                return false;
            }

            Container itemContainer;
            switch (container.ToLower())
            {
                case "belt":
                    itemContainer = rokPlayer.CurrentCharacter.Entity.GetContainerOfType(CollectionTypes.Hotbar);
                    break;

                default:
                    itemContainer = rokPlayer.CurrentCharacter.Entity.GetContainerOfType(CollectionTypes.Inventory);
                    break;
            }

            InvItemBlueprint blueprint = InvDefinitions.Instance.Blueprints.GetBlueprintForName(itemName, true, true);
            if (blueprint == null)
            {
                return null;
            }

            ContainerManagement containerManagement = blueprint.TryGet<ContainerManagement>();
            int stackableAmount = containerManagement != null ? containerManagement.StackLimit : 0;
            int amountGiven = 0;
            while (amountGiven < amount)
            {
                int amountToGive = Mathf.Min(stackableAmount, amount - amountGiven);
                InvGameItemStack itemStack = new InvGameItemStack(blueprint, amountToGive, null);
                if (!ItemCollection.AutoMergeAdd(itemContainer.Contents, itemStack))
                {
                    int stackAmount = amountToGive - itemStack.StackAmount;
                    if (stackAmount != 0)
                    {
                        amountGiven += stackAmount;
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    amountGiven += amountToGive;
                }
                if (itemContainer.Contents.FreeSlotCount == 0)
                {
                    break;
                }
            }
#elif RUST
            Item item = ItemManager.Create(FindItem(itemNameOrId), amount, skinId);
            if (item == null)
            {
                return null;
            }

            BasePlayer basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
            {
                return false;
            }

            ItemContainer itemContainer = null;
            switch (container.ToLower())
            {
                case "belt":
                    itemContainer = basePlayer.inventory.containerBelt;
                    break;

                default:
                    itemContainer = basePlayer.inventory.containerMain;
                    break;
            }

            item.amount = amount;
            item.conditionNormalized = condition;
            item.OnVirginSpawn();
            if (!item.MoveToContainer(itemContainer) && !basePlayer.inventory.GiveItem(item))
            {
                item.Remove();
                return false;
            }

            itemName = item.info.displayName.english;
            if (_config.ShowPopupNotices)
            {
                player.Command("note.inv", item.info.itemid, amount);
                player.Command("gametip.showgametip", GetLang("ItemReceived", player.Id, itemName, amount));
                timer.Once(2f, () => player.Command("gametip.hidegametip"));
            }
#endif
            if (_config.ShowChatNotices)
            {
                Message(player, "ItemReceived", itemName, amount);
            }
            if (_config.LogToConsole)
            {
                Log($"{player.Name} {amount} x {itemName}");
            }

            return true;
        }

        private void CommandGive(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionGive))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 1)
            {
                Message(player, "UsageGive", command);
                return;
            }

            if (player.IsServer)
            {
                Message(player, "PlayersOnly", command);
                return;
            }

            int amount = args.Length >= 2 && int.TryParse(args[1], out amount) ? amount : 1;
            float condition = args.Length >= 3 && float.TryParse(args[2], out condition) ? condition : 1f; // Currently only Rust
            ulong skinId = args.Length >= 4 && ulong.TryParse(args[3], out skinId) ? skinId : 0uL; // Currently only Rust
            object giveItem = GiveItem(player, args[0], amount, condition: condition, skinId: skinId);
            if (giveItem == null)
            {
                Message(player, "InvalidItem", args[0]);
            }
            else if (!(bool)giveItem)
            {
                Message(player, "GiveFail", args[0], amount);
            }
            else
            {
                Message(player, "GiveSuccess", args[0], amount);
            }
        }

        private void CommandGiveTo(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionGiveTo))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 2)
            {
                Message(player, "UsageGiveTo", command);
                return;
            }

            IPlayer target = FindPlayer(args[0], player);
            if (target == null)
            {
                target = player;
                if (target.IsServer)
                {
                    Message(player, "PlayersOnly", command);
                    return;
                }
            }

            int amount = args.Length >= 3 && int.TryParse(args[2], out amount) ? amount : 1;
            ulong skinId = args.Length >= 4 && ulong.TryParse(args[3], out skinId) ? skinId : 0uL; // Currently only Rust
            object giveItem = GiveItem(target, args[1], amount, skinId: skinId);
            if (giveItem == null)
            {
                Message(player, "InvalidItem", args[1]);
            }
            else if (!(bool)giveItem)
            {
                Message(player, "GiveToFail", args[1], amount, target.Name);
            }
            else
            {
                Message(player, "GiveToSuccess", args[1], amount, target.Name);
            }
        }

        private void CommandGiveAll(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionGiveAll))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 1)
            {
                Message(player, "UsageGive", command);
                return;
            }

            if (!players.Connected.Any())
            {
                Message(player, "NoPlayersConnected");
                return;
            }

            int itemsGiven = 0;
            int connectedPlayers = 0;
            int amount = args.Length >= 2 && int.TryParse(args[1], out amount) ? amount : 1;
            ulong skinId = args.Length >= 3 && ulong.TryParse(args[2], out skinId) ? skinId : 0uL; // Currently only Rust
            foreach (IPlayer target in players.Connected.ToArray())
            {
                object itemGiven = GiveItem(target, args[0], amount, skinId: skinId);
                if (itemGiven is bool && (bool)itemGiven)
                {
                    itemsGiven++;
                    connectedPlayers++;
                }
            }
            Message(player, itemsGiven > 0 ? "GiveAllSuccess" : "GiveAllFail", args[0], amount, connectedPlayers);
        }

#if REIGNOFKINGS || RUST
        private void CommandGiveArm(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionGiveArm))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 1)
            {
                Message(player, "UsageGiveArm", command);
                return;
            }

            int amount = args.Length >= 2 && int.TryParse(args[1], out amount) ? amount : 1;
            ulong skinId = args.Length >= 3 && ulong.TryParse(args[2], out skinId) ? skinId : 0uL; // Currently only Rust
            object giveItem = GiveItem(player, args[0], amount, "belt", skinId: skinId);
            if (giveItem == null)
            {
                Message(player, "InvalidItem", args[0]);
            }
            else if (!(bool)giveItem)
            {
                Message(player, "GiveFail", args[0], amount);
            }
            else
            {
                Message(player, "GiveSuccess", args[0], amount);
            }
        }
#endif

        #endregion Item Giving

        #region Kit Giving

        private bool TryGiveKit(IPlayer player, string kitName)
        {
            if (!Kits.Call<bool>("isKit", kitName))
            {
                Message(player, "InvalidKit", kitName);
                return false;
            }

            if (!player.IsConnected)
            {
                Message(player, "PlayerNotConnected", player.Name, player.Id);
                return false;
            }

            bool giveKit = false;
#if HURTWORLD
            giveKit = Kits.Call<bool>("GiveKit", player.Object as PlayerSession, kitName);
#elif REIGNOFKINGS
            giveKit = Kits.Call<bool>("GiveKit", player.Object as Player, kitName);
#elif RUST
            object kitGiven = Kits.Call<object>("GiveKit", player.Object as BasePlayer, kitName);
            giveKit = kitGiven is bool ? (bool)kitGiven : kitGiven == null;
#elif SEVENDAYSTODIE
            giveKit = Kits.Call<bool>("GiveKit", player.Object as EntityAlive, kitName);
#endif
            return giveKit;
        }

        private void CommandGiveKit(IPlayer player, string command, string[] args)
        {
            if (Kits == null || !Kits.IsLoaded)
            {
                Message(player, "KitsUnavailable");
                return;
            }

            if (!player.HasPermission(PermissionGiveKit))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 1)
            {
                Message(player, "UsageGiveKit", command);
                return;
            }

            if (player.IsServer)
            {
                Message(player, "PlayersOnly", command);
                return;
            }

            bool kitGiven = TryGiveKit(player, args[0]);
            Message(player, kitGiven ? "GiveKitSuccess" : "GiveKitFail", args[0]);
        }

        private void CommandGiveKitTo(IPlayer player, string command, string[] args)
        {
            if (Kits == null || !Kits.IsLoaded)
            {
                Message(player, "KitsUnavailable");
                return;
            }

            if (!player.HasPermission(PermissionGiveKitTo))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 2)
            {
                Message(player, "UsageGiveKitTo", command);
                return;
            }

            IPlayer target = FindPlayer(args[0], player);
            if (target != null)
            {
                bool kitGiven = TryGiveKit(target, args[1]);
                Message(player, kitGiven ? "GiveKitToSuccess" : "GiveKitToFail", args[1], target.Name);
            }
        }

        private void CommandGiveKitAll(IPlayer player, string command, string[] args)
        {
            if (Kits == null || !Kits.IsLoaded)
            {
                Message(player, "KitsUnavailable");
                return;
            }

            if (!player.HasPermission(PermissionGiveKitAll))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 1)
            {
                Message(player, "UsageGiveKitAll", command);
                return;
            }

            if (!Kits.Call<bool>("isKit", args[0]))
            {
                Message(player, "InvalidKit", args[0]);
                return;
            }

            if (!players.Connected.Any())
            {
                Message(player, "NoPlayersConnected");
                return;
            }

            int kitsGiven = 0;
            int connectedPlayers = 0;
            foreach (IPlayer target in players.Connected.ToArray())
            {
                if (TryGiveKit(target, args[0]))
                {
                    kitsGiven++;
                    connectedPlayers++;
                }
            }
            Message(player, kitsGiven > 0 ? "GiveKitAllSuccess" : "GiveKitAllFail", args[0], connectedPlayers);
        }

        #endregion Kit Giving

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                foreach (KeyValuePair<string, string> message in lang.GetMessages(language, this))
                {
                    if (message.Key.Equals(command) && !string.IsNullOrEmpty(message.Value))
                    {
                        AddCovalenceCommand(message.Value, command);
                    }
                }
            }
        }

        private IPlayer FindPlayer(string playerNameOrId, IPlayer player)
        {
            IPlayer[] foundPlayers = players.FindPlayers(playerNameOrId).ToArray();
            if (foundPlayers.Length > 1)
            {
                Message(player, "PlayersFound", string.Join(", ", foundPlayers.Select(p => p.Name).Take(10).ToArray()).Truncate(60));
                return null;
            }

            IPlayer target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target == null)
            {
                Message(player, "NoPlayersFound", playerNameOrId);
                return null;
            }

            return target;
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}


// --- End of file: Give.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/group-migrate ---
// --- Original File Path: G/GroupMigrate/GroupMigrate.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Group Migrate", "Wulf", "1.0.0")]
    [Description("Migrate players and permissions between groups")]
    class GroupMigrate : CovalencePlugin
    {
        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandMigrate"] = "migrate",
                ["GroupCreated"] = "Created a new group named '{0}'",
                ["GroupNotFound"] = "Could not find a group named '{0}'",
                ["GroupRemoved"] = "Removed the old group named '{0}'",
                ["MigratedPlayers"] = "Migrated {0} players from '{1}' to '{2}'",
                ["MigratedPerms"] = "Migrated {0} permissions from '{1}' to '{2}': {3}",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["UsageMigrate"] = "Usage: {0} <oldgroup> <newgroup>",
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string permUse = "groupmigrate.use";

        private void Init()
        {
            AddLocalizedCommand(nameof(CommandMigrate));

            permission.RegisterPermission(permUse, this);
        }

        #endregion Initialization

        #region Commands

        private void CommandMigrate(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length != 2)
            {
                Message(player, "UsageMigrate", command);
                return;
            }

            string oldGroup = args[0].ToLower();
            string newGroup = args[1].ToLower();

            // Check if old group exists or not
            if (!permission.GroupExists(oldGroup))
            {
                Message(player, "GroupNotFound", oldGroup);
                return;
            }

            // Check if new group exists or not
            if (!permission.GroupExists(newGroup))
            {
                permission.CreateGroup(newGroup, newGroup, 0);
                Message(player, "GroupCreated", newGroup);
            }

            // Migrate players from old group to new
            int targetCount = 0;
            foreach (IPlayer target in players.All)
            {
                if (target.BelongsToGroup(oldGroup) && !target.BelongsToGroup(newGroup))
                {
                    target.AddToGroup(newGroup);
                    target.RemoveFromGroup(oldGroup);
                    targetCount++;
                }
            }
            Message(player, "MigratedPlayers", targetCount, oldGroup, newGroup);

            // Migrate permissions from old group to new
            string[] oldPerms = permission.GetGroupPermissions(oldGroup);
            foreach (string perm in oldPerms)
            {
                permission.GrantGroupPermission(newGroup, perm, null);
                permission.RevokeGroupPermission(oldGroup, perm);
            }
            Message(player, "MigratedPerms", oldPerms.Length, oldGroup, newGroup, string.Join(", ", oldPerms));

            // Remove group if it is empty and not a default group
            if (permission.GetUsersInGroup(oldGroup).Length == 0 && !Interface.Oxide.Config.Options.DefaultGroups.Contains(oldGroup))
            {
                permission.RemoveGroup(oldGroup);
                Message(player, "GroupRemoved", oldGroup);
            }

            // Save group and player data
            permission.SaveData();
        }

        #endregion Commands

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string langKey, params object[] args)
        {
            if (player.IsConnected)
            {
                player.Message(GetLang(langKey, player.Id, args));
            }
        }

        #endregion Helpers
    }
}


// --- End of file: GroupMigrate.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/guess-the-word ---
// --- Original File Path: G/GuessTheWord/GuessTheWord.cs ---

using System.Collections.Generic;
using System;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Guess The Word", "Bazz3l", "1.0.7")]
    [Description("Guess the scrambled word and receive a reward.")]
    class GuessTheWord : CovalencePlugin
    {
        [PluginReference] Plugin ServerRewards, Economics;

        #region Fields
        List<string> wordList = new List<string>();
        bool eventActive = false;
        Timer eventRepeatTimer;
        Timer eventTimer;
        string currentScramble;
        string currentWord;
        #endregion

        #region Config
        PluginConfig config;

        PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                APIEndpoint = "https://raw.githubusercontent.com/instafluff/ComfyDictionary/master/wordlist.txt?raw=true",
                UseServerRewards = true,
                UseEconomics = false,
                ServerRewardPoints = 100,
                EconomicsPoints = 100.0,
                MinWordLength = 4,
                MaxWordLength = 6,
                MaxWords = 50,
                eventTime = 3600f,
                eventLength = 120f
            };
        }

        class PluginConfig
        {
            public string APIEndpoint;
            public bool UseServerRewards;
            public bool UseEconomics;
            public int ServerRewardPoints;
            public double EconomicsPoints;
            public int MinWordLength;
            public int MaxWordLength;
            public int MaxWords;
            public float eventTime;
            public float eventLength;
        }
        #endregion

        #region Oxide
        protected override void LoadDefaultConfig() => Config.WriteObject(GetDefaultConfig(), true);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string> {
                {"Prefix", "[#DC143C]Guess The Word[/#]: "},
                {"InvalidSyntax", "invalid syntax, /word <answer>"},
                {"NotActive", "not active."},
                {"Invalid", "incorrect answer."},
                {"StartEvent", "guess the word, [#DC143C]{0}[/#]"},
                {"EventEnded", "no one guessed, [#DC143C]{0}[/#]"},
                {"EventAward", "you received [#DC143C]{0}[/#]"},
                {"EventWinner", "[#DC143C]{0}[/#] guessed the word, [#DC143C]{1}[/#]"}
            }, this);
        }

        void OnServerInitialized()
        {
            FetchWordList();

            eventRepeatTimer = timer.Repeat(config.eventTime, 0, () => StartEvent());
        }

        void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }
        #endregion

        #region Core
        void StartEvent()
        {
            if (eventActive || wordList.Count == 0) return;

            eventActive     = true;
            currentWord     = wordList[Oxide.Core.Random.Range(0, wordList.Count)];
            currentScramble = ScrambleWord();

            MessageAll("StartEvent", currentScramble);

            eventTimer = timer.Once(config.eventLength, () => EventEnded());
        }

        void EventEnded()
        {
            ResetEvent();

            MessageAll("EventEnded", currentWord);
        }

        void ResetEvent()
        {
            eventActive = false;

            if(!eventRepeatTimer.Destroyed)
            {
                eventRepeatTimer.Destroy();
                eventRepeatTimer = timer.Repeat(config.eventTime, 0, () => StartEvent());
            }

            if(!eventTimer.Destroyed)
                eventTimer.Destroy();
        }

        void FetchWordList()
        {
            webrequest.EnqueueGet(config.APIEndpoint, (code, response) => {
                if (code != 200 || response == null) return;

                wordList = response.Split(',').ToList<string>()
                .Where(x => x.Length >= config.MinWordLength && x.Length <= config.MaxWordLength)
                .Take(config.MaxWords)
                .ToList();
            }, this);
        }

        string ScrambleWord()
        {
            List<char> wordChars = new List<char>(currentWord.ToCharArray());
            string scrambledWord = string.Empty;

            while(wordChars.Count > 0)
            {
                int index = UnityEngine.Random.Range(0, wordChars.Count - 1);
                scrambledWord += wordChars[index];
                wordChars.RemoveAt(index);
            }

            if (currentWord == scrambledWord)
                return ScrambleWord();

            return scrambledWord;
        }

        bool CheckGuess(string currentGuess)
        {
            return string.Equals(currentGuess, currentWord, StringComparison.OrdinalIgnoreCase);
        }

        void RewardPlayer(IPlayer player)
        {
            string message = string.Empty;

            if (ServerRewards && config.UseServerRewards)
            {
                ServerRewards?.Call("AddPoints", player.Id, config.ServerRewardPoints);

                message = Lang("EventAward", player.Id, string.Format("{0}RP", config.ServerRewardPoints));
            }

            if (Economics && config.UseEconomics)
            {
                Economics?.Call("Deposit", player.Id, config.EconomicsPoints);

                message = Lang("EventAward", player.Id, string.Format("${0}", (int)config.EconomicsPoints + "RP"));
            }

            if (ServerRewards || Economics)
            {
                MessageAll("EventWinner", player.Name, currentWord);

                player.Message(message);             
            }

            ResetEvent();
        }

        void MessageAll(string key, params object[] args)
        {
            foreach (IPlayer player in covalence.Players.Connected)
            {
                if (player == null) continue;

                player.Message(Lang("Prefix", player.Id) + Lang(key, player.Id, args));
            }
        }
        #endregion

        #region Commands
        [Command("word")]
        void WordCommand(IPlayer player, string command, string[] args)
        {
            if (args == null || args.Length < 1)
            {
                player.Message(Lang("Prefix", player.Id) + Lang("InvalidSyntax", player.Id));
                return;
            }

            if (!eventActive)
            {
                player.Message(Lang("Prefix", player.Id) + Lang("NotActive", player.Id));
                return;
            }

            if (!CheckGuess(args[0]))
            {
                player.Message(Lang("Prefix", player.Id) + Lang("Invalid", player.Id));
                return;
            }

            RewardPlayer(player);
        }
        #endregion

        #region Helpers
        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        #endregion
    }
}

// --- End of file: GuessTheWord.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gather-rewards ---
// --- Original File Path: G/GatherRewards/GatherRewards.cs ---

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Libraries;
using System;
using System.Collections.Generic;
using System.Linq;

//GatherRewards created with PluginMerge v(1.0.6.0) by MJSU @ https://github.com/dassjosh/Plugin.Merge
namespace Oxide.Plugins
{
    [Info("Gather Rewards", "Shady14u", "1.7.1")]
    [Description("Earn rewards through Economics/Server Rewards for killing and gathering")]
    public partial class GatherRewards : RustPlugin
    {
        #region GatherRewards.cs
        private const string _version = "1.7.0";
        
        private string _resource;
        
        [PluginReference] private Plugin Economics, ServerRewards, Friends, Clans, UINotify;
        #endregion

        #region GatherRewards.Config.cs
        private PluginConfig _config;
        
        PluginConfig DefaultConfig()
        {
            var defaultConfig = new PluginConfig
            {
                Settings = new PluginSettings
                {
                    ChatEditCommand = "gatherrewards",
                    ConsoleEditCommand = "gatherrewards",
                    EditPermission = "gatherrewards.canedit",
                    ShowMessagesOnKill = true,
                    ShowMessagesOnGather = true,
                    UseEconomics = true,
                    UseServerRewards = false,
                    PluginPrefix = "<color=#00FFFF>[GatherRewards]</color>",
                    AwardOnlyOnFullHarvest = false,
                    AddMissingRewards = false,
                    UseUINotify = false,
                    UINotifyMessageType = 1
                },
                Rewards = new Dictionary<string, float>
                {
                    { PluginRewards.Player, 0 },
                    { PluginRewards.PlayerFriend, -25 },
                    { PluginRewards.ClanMember, -25 },
                    { PluginRewards.Ore, 25 },
                    { PluginRewards.Wood, 25 },
                    { PluginRewards.Stone, 25 },
                    { PluginRewards.Corn, 25 },
                    { PluginRewards.Hemp, 25 },
                    { PluginRewards.Mushroom, 25 },
                    { PluginRewards.Pumpkin, 25 },
                    { PluginRewards.TeamMember, -25 },
                    { PluginRewards.Suicide, -100 }
                }
            };
            
            foreach (GameManifest.PooledString str in GameManifest.Current.pooledStrings)
            {
                if (str.str.StartsWith("assets/rust.ai/agents"))
                {
                    if (str.str.Contains("-") || str.str.Contains("_"))
                    {
                        continue;
                    }
                    
                    if (str.str.Contains("test"))
                    {
                        continue;
                    }
                    
                    if (str.str.Contains("npc"))
                    {
                        continue;
                    }
                    
                    var animal = str.str.Substring(str.str.LastIndexOf('/') + 1).Replace(".prefab", string.Empty);
                    if (animal.Contains("."))
                    {
                        continue;
                    }
                    
                    defaultConfig.Rewards[UppercaseFirst(animal)] = 25;
                }
            }
            
            defaultConfig.Rewards["Scientist"] = 25;
            defaultConfig.Rewards["Murderer"] = 25;
            return defaultConfig;
        }
        
        
        private bool _configChanged;
        
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(DefaultConfig(), true);
            PrintWarning("New configuration file created.");
        }
        
        private void LoadConfigValues()
        {
            _config = Config.ReadObject<PluginConfig>();
            var defaultConfig = DefaultConfig();
            Merge(_config.Rewards, defaultConfig.Rewards);
            if (_config.Settings.Version != _version)
            {
                _config.Settings.Version = _version;
                _configChanged = true;
            }
            if (!_configChanged) return;
            PrintWarning("Configuration file updated.");
            Config.WriteObject(_config);
        }
        
        private void Merge<T1, T2>(IDictionary<T1, T2> current, IDictionary<T1, T2> defaultDict)
        {
            foreach (var pair in defaultDict)
            {
                if (current.ContainsKey(pair.Key)) continue;
                current[pair.Key] = pair.Value;
                _configChanged = true;
            }
        }
        #endregion

        #region GatherRewards.Permissions.cs
        private bool CheckPermission(BasePlayer player, string perm)
        {
            return permission.UserHasPermission(player.UserIDString, perm);
        }
        
        private void RegisterPermsAndCommands()
        {
            permission.RegisterPermission(_config.Settings.EditPermission, this);
            foreach (var groupModifier in _config.Settings.GroupModifiers)
            {
                permission.RegisterPermission(groupModifier.Key,this);
            }
            
            var command = Interface.Oxide.GetLibrary<Command>();
            command.AddChatCommand(_config.Settings.ChatEditCommand, this, "cmdGatherRewards");
            command.AddConsoleCommand(_config.Settings.ConsoleEditCommand, this, "cmdConsoleGatherRewards");
        }
        #endregion

        #region GatherRewards.Lang.cs
        private string Lang(string key, string userId = null) =>
        lang.GetMessage(key, this, userId);
        
        private void Language()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "ReceivedForGather", "You have received ${0} for gathering {1}." },
                { "LostForGather", "You have lost ${0} for gathering {1}." },
                { "ReceivedForKill", "You have received ${0} for killing a {1}." },
                { "LostForKill", "You have lost ${0} for killing a {1}." },
                { "NoPermission", "You have no permission to use this command." },
                { "Usage", "Usage: /{0} [value] [amount]" },
                { "NotaNumber", "Error: value is not a number." },
                { "Success", "Successfully changed '{0}' to earn amount '{1}'." },
                { "ValueDoesNotExist", "Value '{0}' does not exist." }
            }, this);
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "ReceivedForGather", "  ${0}   {1}." },
                { "LostForGather", "  ${0}   {1}." },
                { "ReceivedForKill", "  ${0}   {1}." },
                { "LostForKill", "  $ {0}   {1}." },
                { "NoPermission", "      ." },
                { "Usage", ": / {0} [] []" },
                { "NotaNumber", ":    ." },
                { "Success", "  '{0}',    '{1}'." },
                { "ValueDoesNotExist", " '{0}'  ." }
            }, this, "ru");
        }
        #endregion

        #region GatherRewards.Hooks.cs
        private void Init()
        {
            LoadConfigValues();
            Language();
            RegisterPermsAndCommands();
        }
        
        private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
        {
            if (!Economics && !ServerRewards) return;
            if (player == null) return;
            _resource = null;
            var amount = 0f;
            
            foreach (var configValue in _config.Rewards)
            {
                if (!collectible.ToString().ToLower().Contains(configValue.Key.ToLower())) continue;
                amount = _config.Rewards[configValue.Key];
                _resource = configValue.Key;
                break;
            }
            
            if(Interface.CallHook("OnGatherRewardsGiveCredit", player, collectible,amount)!=null) return;
            
            if (_resource != null && amount != 0)
            {
                GiveCredit(player, "gather", amount, _resource);
            }
        }
        
        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (!Economics && !ServerRewards) return;
            var player = entity?.ToPlayer();
            if (player==null) return;
            var amount = 0f;
            var shortName = item.info.shortname;
            _resource = null;
            
            foreach (KeyValuePair<string, float> configValue in _config.Rewards)
            {
                if (!shortName.Contains(configValue.Key.ToLower())) continue;
                amount = CheckPoints(configValue.Key);
                _resource = item.info.shortname;
                break;
            }
            
            if (_resource == null || amount == 0) return;
            
            if (player.GetHeldEntity() is Jackhammer)
            {
                amount *= _config.Settings.JackHammerModifier;
            }
            if(player.GetHeldEntity() is Chainsaw)
            {
                amount *= _config.Settings.ChainsawModifier;
            }
            
            if (_config.Settings.AwardOnlyOnFullHarvest)
            {
                var ent = dispenser.GetComponent<BaseEntity>();
                NextTick(() =>
                {
                    
                    if (dispenser.gatherType == ResourceDispenser.GatherType.Tree && dispenser.fractionRemaining <=0)
                    {
                        GiveCredit(player, "gather", amount, "Tree");
                        return;
                    }
                    
                    if (ent != null)
                    {
                        return;
                    }
                    
                    GiveCredit(player, "gather", amount, item.info.shortname);
                });
                
            }
            else
            {
                GiveCredit(player, "gather", amount, _resource);
            }
            
            
        }
        
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null) return;
            if (!Economics && !ServerRewards) return;
            var player = info?.Initiator?.ToPlayer();
            if (player==null) return;
            
            string animal;
            float amount;
            
            if (entity.ToPlayer() != null && !(entity is NPCPlayer))
            {
                //Player Killed was a Real Player
                var victim = entity.ToPlayer();
                if (player == victim)
                {
                    GiveCredit(player, "suicide", CheckPoints(PluginRewards.Suicide), "suicide");
                    return;
                }
                
                amount = CheckPoints(PluginRewards.Player);
                animal = "player";
                
                if (Friends && _config.Rewards[PluginRewards.PlayerFriend] != 0)
                {
                    var isFriend = Friends.Call<bool>("HasFriend", victim.UserIDString, player.UserIDString);
                    var isFriendReverse = Friends.Call<bool>("HasFriend", player.UserIDString, victim.UserIDString);
                    if (isFriend || isFriendReverse)
                    {
                        amount = CheckPoints(PluginRewards.PlayerFriend);
                        animal = "friend";
                    }
                }
                
                if (Clans && _config.Rewards[PluginRewards.ClanMember] != 0)
                {
                    var victimClan = Clans.Call<string>("GetClanOf", victim.UserIDString);
                    var playerClan = Clans.Call<string>("GetClanOf", player.UserIDString);
                    if (victimClan == playerClan && !string.IsNullOrEmpty(playerClan))
                    {
                        amount = CheckPoints(PluginRewards.ClanMember);
                        animal = "clan member";
                    }
                }
                
                if(player.Team!=null && player.Team.members.Contains(victim.userID.Get()) && _config.Rewards[PluginRewards.TeamMember] != 0)
                {
                    amount = CheckPoints(PluginRewards.TeamMember);
                    animal = "team member";
                }
                
            }
            else
            {
                if (entity is NPCPlayer)
                {
                    var npcPlayer = (NPCPlayer)entity;
                    animal = npcPlayer.displayName ?? "Murderer";
                    
                    //Patch Tunnel Dwellers
                    if (entity.ShortPrefabName.Contains("npc_tunnel"))
                    {
                        animal = "Tunnel Dweller";
                    }
                    
                    //set the default amount to that of a murdered or 125
                    amount = CheckPoints(animal, CheckPoints("Murderer", 125));
                    
                    if (long.TryParse(animal, out var npcId))
                    {
                        //override names that are just numbers
                        amount = CheckPoints(entity.ShortPrefabName, CheckPoints("Murderer", 125));
                        animal = "Scientist";
                    }
                }
                else
                {
                    animal = entity.ShortPrefabName;
                    amount = CheckPoints(animal);
                }
            }
            
            if (amount != 0)
            {
                GiveCredit(player, "kill", amount, animal);
            }
        }
        #endregion

        #region GatherRewards.Helpers.cs
        private float CheckPoints(string animal, float defaultAmount = 0)
        {
            foreach (var configValue in _config.Rewards.Where(configValue =>
            string.Equals(animal, configValue.Key, StringComparison.CurrentCultureIgnoreCase)))
            {
                animal = configValue.Key;
                return _config.Rewards[configValue.Key];
            }
            
            if (defaultAmount == 0) return defaultAmount;
            
            if (_config.Settings.AddMissingRewards)
            {
                _config.Rewards.Add(animal, defaultAmount);
                Config.WriteObject(_config);
            }
            
            return defaultAmount;
        }
        
        private void GiveCredit(BasePlayer player, string type, float amount, string gathered)
        {
            if(amount==0) return;
            foreach (var groupModifier in _config.Settings.GroupModifiers.OrderByDescending(x=>x.Value))
            {
                if (permission.UserHasPermission(player.UserIDString, groupModifier.Key))
                {
                    amount *= float.Parse(groupModifier.Value.ToString());
                    break;
                }
            }
            
            if (amount > 0)
            {
                if (_config.Settings.UseEconomics && Economics)
                {
                    Economics.Call("Deposit", player.UserIDString, (double)amount);
                }
                
                if (_config.Settings.UseServerRewards && ServerRewards)
                {
                    ServerRewards.Call("AddPoints", new object[] { player.userID, (int)amount });
                }
                
                if (type == "gather" && _config.Settings.ShowMessagesOnGather)
                {
                    var message = _config.Settings.PluginPrefix + " " + string.Format(
                    Lang("ReceivedForGather", player.UserIDString), amount,
                    gathered.ToLower());
                    PrintToChat(player, message);
                    if (_config.Settings.UseUINotify)
                    {
                        UINotify?.Call("SendNotify", player.userID, _config.Settings.UINotifyMessageType, message);
                    }
                }
                else if (type == "kill" && _config.Settings.ShowMessagesOnKill)
                {
                    var message = _config.Settings.PluginPrefix + " " +
                    string.Format(Lang("ReceivedForKill", player.UserIDString), amount, gathered.ToLower());
                    PrintToChat(player, message);
                    if (_config.Settings.UseUINotify)
                    {
                        UINotify?.Call("SendNotify", player.userID, _config.Settings.UINotifyMessageType, message);
                    }
                }
            }
            else
            {
                amount = Math.Abs(amount);
                
                if (_config.Settings.UseEconomics && Economics)
                {
                    Economics.Call("Withdraw", player.UserIDString, (double)amount);
                }
                
                if (_config.Settings.UseServerRewards && ServerRewards)
                {
                    var points = ServerRewards.Call<int>("CheckPoints", player.userID);
                    if (points < amount && points > 0)
                    {
                        amount = points;
                    }
                    ServerRewards.Call("TakePoints", new object[] { player.userID, (int)amount });
                }
                
                if (type == "gather" && _config.Settings.ShowMessagesOnGather)
                {
                    var message = _config.Settings.PluginPrefix + " " +
                    string.Format(Lang("LostForGather", player.UserIDString), amount, gathered.ToLower());
                    PrintToChat(player,message);
                    if (_config.Settings.UseUINotify)
                    {
                        UINotify?.Call("SendNotify", player.userID, _config.Settings.UINotifyMessageType, message);
                    }
                }
                else if (type == "kill" && _config.Settings.ShowMessagesOnKill)
                {
                    var message = _config.Settings.PluginPrefix + " " +
                    string.Format(Lang("LostForKill", player.UserIDString), amount, gathered.ToLower());
                    PrintToChat(player,message);
                    if (_config.Settings.UseUINotify)
                    {
                        UINotify?.Call("SendNotify", player.userID, _config.Settings.UINotifyMessageType, message);
                    }
                }
            }
        }
        
        private static string UppercaseFirst(string s)
        {
            if (string.IsNullOrEmpty(s))
            return string.Empty;
            var a = s.ToCharArray();
            a[0] = char.ToUpper(a[0]);
            return new string(a);
        }
        #endregion

        #region GatherRewards.Commands.cs
        private void cmdGatherRewards(BasePlayer player, string command, string[] args)
        {
            if (!(CheckPermission(player, _config.Settings.EditPermission)))
            {
                SendReply(player, _config.Settings.PluginPrefix + " " + Lang("NoPermission", player.UserIDString));
                return;
            }
            
            if (args.Length < 2)
            {
                SendReply(player,
                _config.Settings.PluginPrefix + " " + string.Format(Lang("Usage", player.UserIDString),
                _config.Settings.ChatEditCommand));
                return;
            }
            
            float value;
            if (float.TryParse(args[1], out value) == false)
            {
                SendReply(player, _config.Settings.PluginPrefix + " " + Lang("NotaNumber", player.UserIDString));
                return;
            }
            
            switch (args[0].ToLower())
            {
                case "clan":
                {
                    _config.Rewards[PluginRewards.ClanMember] = value;
                    Config.WriteObject(_config);
                    SendReply(player,
                    _config.Settings.PluginPrefix + " " +
                    string.Format(Lang("Success", player.UserIDString), "clan member", value));
                    break;
                }
                case "friend":
                {
                    _config.Rewards[PluginRewards.PlayerFriend] = value;
                    Config.WriteObject(_config);
                    SendReply(player,
                    _config.Settings.PluginPrefix + " " +
                    string.Format(Lang("Success", player.UserIDString), "friend", value));
                    break;
                }
                default:
                {
                    if (!_config.Rewards.ContainsKey(UppercaseFirst(args[0].ToLower())))
                    {
                        SendReply(player,
                        _config.Settings.PluginPrefix + " " +
                        string.Format(Lang("ValueDoesNotExist", player.UserIDString), args[0].ToLower()));
                        break;
                    }
                    
                    _config.Rewards[UppercaseFirst(args[0].ToLower())] = float.Parse(args[1]);
                    Config.WriteObject(_config);
                    
                    SendReply(player,
                    _config.Settings.PluginPrefix + " " + string.Format(Lang("Success", player.UserIDString),
                    args[0].ToLower(), value));
                    
                    break;
                }
            }
        }
        
        private void cmdConsoleGatherRewards(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin != true)
            {
                return;
            }
            
            if (arg.Args == null)
            {
                Puts(string.Format(Lang("Usage"), _config.Settings.ConsoleEditCommand));
                return;
            }
            
            if (arg.Args.Length <= 1)
            {
                Puts(string.Format(Lang("Usage"), _config.Settings.ConsoleEditCommand));
                return;
            }
            
            float value = 0;
            if (float.TryParse(arg.Args[1], out value) == false)
            {
                Puts(Lang("NotaNumber"));
                return;
            }
            
            switch (arg.Args[0].ToLower())
            {
                case "clan":
                {
                    _config.Rewards[PluginRewards.ClanMember] = value;
                    Config.WriteObject(_config);
                    Puts(string.Format(Lang("Success"), "clan member", value));
                    break;
                }
                case "friend":
                {
                    _config.Rewards[PluginRewards.PlayerFriend] = value;
                    Config.WriteObject(_config);
                    Puts(string.Format(Lang("Success"), "friend", value));
                    break;
                }
                default:
                {
                    if (!_config.Rewards.ContainsKey(UppercaseFirst(arg.Args[0].ToLower())))
                    {
                        Puts(string.Format(Lang("ValueDoesNotExist"), arg.Args[0].ToLower()));
                        break;
                    }
                    
                    _config.Rewards[UppercaseFirst(arg.Args[0].ToLower())] = float.Parse(arg.Args[1]);
                    Config.WriteObject(_config);
                    Puts(string.Format(Lang("Success"), arg.Args[0].ToLower(), value));
                    
                    break;
                }
            }
        }
        #endregion

        #region GatherRewards.Class.PluginSettings.cs
        private class PluginSettings
        {
            public int UINotifyMessageType = 1;
            public bool AddMissingRewards { get; set; }
            
            public bool AwardOnlyOnFullHarvest { get; set; }
            public float ChainsawModifier { get; set; } = .25f;
            public string ChatEditCommand { get; set; }
            public string ConsoleEditCommand { get; set; }
            public string EditPermission { get; set; }
            
            public Dictionary<string, object> GroupModifiers { get; set; } = new Dictionary<string, object>
            {
                {"gatherrewards.vip1", 4.0},
                {"gatherrewards.vip2", 3.0},
                {"gatherrewards.vip3", 2.0}
            };
            
            public float JackHammerModifier { get; set; } = .25f;
            public string PluginPrefix { get; set; }
            public bool ShowMessagesOnGather { get; set; }
            public bool ShowMessagesOnKill { get; set; }
            public bool UseEconomics { get; set; }
            public bool UseServerRewards { get; set; }
            public bool UseUINotify { get; set; }
            public string Version { get; set; }
        }
        #endregion

        #region GatherRewards.Class.PluginRewards.cs
        private static class PluginRewards
        {
            public const string ClanMember = "Clan Member";
            public const string Corn = "Corn";
            public const string Hemp = "Hemp";
            public const string Mushroom = "Mushroom";
            public const string Ore = "Ore";
            public const string Player = "Player";
            public const string PlayerFriend = "Player's Friend";
            public const string Pumpkin = "Pumpkin";
            public const string Stone = "Stone";
            public const string TeamMember = "Team Member";
            public const string Wood = "Wood";
            public const string Suicide = "Suicide";
        }
        #endregion

        #region GatherRewards.Class.PluginConfig.cs
        private class PluginConfig
        {
            #region Properties and Indexers
            
            public Dictionary<string, float> Rewards { get; set; }
            public PluginSettings Settings { get; set; }
            
            #endregion
        }
        #endregion

    }

}


// --- End of file: GatherRewards.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gpay ---
// --- Original File Path: G/GPay/GPay.cs ---

using System;
using System.Collections.Generic;
using System.Collections;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using System.Text;

namespace Oxide.Plugins {

    [Info("GPay", "Soccerjunki", "2.0.2")]
    [Description("Auto donation system")]
    class GPay : CovalencePlugin {

        class GPayWebResponse
        {
            public string error { get; set; }
            public string[] commands { get; set; }
        }

        protected override void LoadDefaultConfig() {
            PrintWarning("Creating a new configuration file");
            Config.Clear();
            Config["Secret"] = "GPAY_SECRET_KEY";
            SaveConfig();
        }

        private new void LoadDefaultMessages(){
        	lang.RegisterMessages(new Dictionary<string, string>
                {
                    {"NoDonationMessage", "No Donation was found"},
                    {"DonationFoundMessage", "Thanks for donating, your items have been added to your inventory"},
                    {"NoInventorySpace", "Please empty your inventory before claiming your donation!"},
                    {"CouldNotConnect", "Could not connect to the donation server, please try again later!"},
                    {"DonationLink", "You can Donate at https://app.gpay.io/store/SERVERNAME"},
                    {"NoSecretKeyEntered", "This command requires a secret key, example usage : /setupgpay SECRETKEYHERE"},
                    {"PluginRequiresSetup", "Please setup this plugin by typing : /setupgpay SECRETKEYHERE"},
                    {"GPAYSETUPCOMPLETE", "[GPAY] Setup successfully!"},
                    {"PleaseWait", "Please Wait"},
            }, this);
        }

        string Lang(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());

        [Command("donate")]
        void DonateCommand(IPlayer player, string command, string[] args) {
            player.Reply(Lang("DonationLink", player.Id));
            return;
        }

        [Command("setupgpay")]
        void setupGpay(IPlayer player, string command, string[] args){
            if(args.Length > 0){
                string secret = Config["Secret"].ToString();
                if(secret.Equals("GPAY_SECRET_KEY")){
                    Config["Secret"] = args[0];
                    SaveConfig();
                    player.Reply(Lang("GPAYSETUPCOMPLETE", player.Id));
                }else{
                    Puts("SECRET KEY ALREADY SETUP, PLEASE CHANGE THE CONFIG FILE TO SET IT AGAIN!");
                }
            }else{
                player.Reply(Lang("NoSecretKeyEntered", player.Id));
            }
        }

        [Command("claimdonation")]
        void ClaimDonatCommand(IPlayer player, string command, string[] args) {
            if(Config["Secret"].ToString().Equals("GPAY_SECRET_KEY")){
                player.Reply(Lang("PluginRequiresSetup", player.Id));
                return;
            }
            player.Reply(Lang("PleaseWait", player.Id));
            string steamid = player.Id;
            string secret = Config["Secret"].ToString();
            webrequest.EnqueueGet("http://api.gpay.io/steam/online/" + steamid + "/" + secret , (code, response) => executeOnlineCommands(code, response, player), this);
        }


        private void Init()
        {
            /**
             * !WARNING PLEASE READ CAREFULLY!
             * It's not recommended to change this as you will probably hit our rate limiting service and get your server banned from our api server
             * Once you're banned it can take upto 30 days to get unbanned
             *
             **/
            timer.Repeat(60.0f, 0, () =>
            {
                RetrieveAllPendingOfflineCommands();
            });
        }
       
        private void RetrieveAllPendingOfflineCommands() {
            string secret = Config["Secret"].ToString();
            webrequest.EnqueueGet("http://api.gpay.io/steam/offline/" + secret, (code, response) => executeOfflineCommands(code, response), this);
        }

        private void executeOfflineCommands(int code, string response)
        {
            if (response == null || code != 200)
            {
                Puts($"Error: {code} - Could not contact GPAY server ");
                return;
            }
            else
            {
                var json = JsonConvert.DeserializeObject<GPayWebResponse>(response);
                if (json.error != null)
                {
                    Puts(json.error.ToString());
                }
                else
                {
                    if (json.commands.Length > 0)
                    {
                        foreach (string s in json.commands)
                        {
                            server.Command(s.ToString());
                        }
                    }
                }
            }
        }

        void executeOnlineCommands(int code, string response, IPlayer player) {
            if (response == null || code != 200) {
                Puts($"Error: {code} - Could not contact GPAY server ");
                player.Reply(Lang("CouldNotConnect", player.Id));
                return;
            }else{
                var json = JsonConvert.DeserializeObject<GPayWebResponse>(response);
                if(json.error != null){
                    player.Reply(Lang("CouldNotConnect", player.Id));
                    Puts(json.error.ToString());
                }else{
                    if(json.commands.Length > 0){
                            foreach (string s in json.commands){
                                StringBuilder buildertwo = new StringBuilder(s.ToString());
                                buildertwo.Replace("<username>", player.Name.ToString());
                                buildertwo.Replace("<steamid>", player.Id);
                                string commandToRunb = buildertwo.ToString();
                                server.Command(commandToRunb);
                            }
                    }else{
                        Puts("No commands to run found! Have you setup your commands on the GPay cpanel?");
                        player.Reply(Lang("NoDonationMessage", player.Id));
                    }
                }
            }

        }
    }
}


// --- End of file: GPay.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/get-slapped ---
// --- Original File Path: G/GetSlapped/GetSlapped.cs ---

// Requires: Slap

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Get Slapped", "klauz24", "1.0.3"), Description("Slaps players when they try to act tough in chat.")]
    internal class GetSlapped : CovalencePlugin
    {
        [PluginReference] private readonly Plugin Slap;

        private const string _slapBypass = "getslapped.bypass";

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Banned word, slap force (30 = 30% of health)")]
            public Dictionary<string, float> BannedWords = new Dictionary<string, float>()
            {
                {"Other word", 30f},
                {"Penalty word", 30f}
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }
                SaveConfig();
            }
            catch
            {
                PrintWarning("Could not load a valid configuration file, creating a new configuration file.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void LoadDefaultMessages() => lang.RegisterMessages(new Dictionary<string, string>() { { "Message", "HEEY! Saying '{0}' is not cool, take this slap as a lesson." } }, this);

        private void Init() => permission.RegisterPermission(_slapBypass, this);

        private void OnUserChat(IPlayer player, string message)
        {
            if (!permission.UserHasPermission(player.Id, _slapBypass))
            {
                foreach (var kvp in _config.BannedWords)
                {
                    if (message.Contains(kvp.Key))
                    {
                        SlapPlayer(player, kvp.Value, kvp.Key);
                        break;
                    }
                }
            }
        }

        private void SlapPlayer(IPlayer player, float value, string message)
        {
            player.Message(string.Format(lang.GetMessage("Message", this, player.Id), message));
            Slap?.Call("SlapPlayer", player, value);
        }
    }
}


// --- End of file: GetSlapped.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/guardian-adr ---
// --- Original File Path: G/GuardianADR/GuardianADR.cs ---

// Requires: Guardian
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Guardian ADR", "Rockioux", "1.0.2")]
    [Description("Starts demo recordings on Guardian Violations.")]
    class GuardianADR : CovalencePlugin
    {

        #region Config Classes

        private class GuardianADRConfig
        {
            [JsonProperty(PropertyName = "Gravity Violation Demo Config")]
            public HookConfig GravityHookConfig { get; set; } = new HookConfig(true);

            [JsonProperty(PropertyName = "Melee Rate Violation Demo Config")]
            public HookConfig MeleeRateConfig { get; set; } = new HookConfig(true);

            [JsonProperty(PropertyName = "NoClip Violation Demo Config")]
            public HookConfig NoClipConfig { get; set; } = new HookConfig(false);

            [JsonProperty(PropertyName = "InsideTerrain Violation Demo Config")]
            public HookConfig InsideTerrainConfig { get; set; } = new HookConfig(false);
        }

        private class HookConfig
        {
            [JsonProperty(PropertyName = "Enable Demo Recordings for this hook")]
            public bool HookEnabled { get; set; }

            [JsonProperty(PropertyName = "Demo Duration in minutes")]
            public int DemoDuration { get; set; } = 2;

            [JsonProperty(PropertyName = "Discord Webhook")]
            public string DiscordWebhook { get; set; } = "";

            public HookConfig()
            {
            }

            public HookConfig(bool enabled)
            {
                HookEnabled = enabled;
            }
        }

        #endregion // Config Classes

        #region Fields

        [PluginReference]
        private Plugin AutoDemoRecord;

        private GuardianADRConfig _config;

        #endregion // Fields

        #region Covalence Plugin Implemented Members

        private void Init()
        {
            if(!_config.GravityHookConfig.HookEnabled)
            {
                Unsubscribe(nameof(OnGuardianAntiCheatGravity));
            }

            if (!_config.MeleeRateConfig.HookEnabled)
            {
                Unsubscribe(nameof(OnGuardianAntiCheatMeleeRate));
            }

            if(!_config.NoClipConfig.HookEnabled && !_config.InsideTerrainConfig.HookEnabled)
            {
                Unsubscribe(nameof(OnGuardianServer));
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<GuardianADRConfig>();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig()
        {
            _config = new GuardianADRConfig();
        }

        #endregion // Covalence Plugin Implemented Members

        #region Guardian Hooks

        private void OnGuardianAntiCheatGravity(string playerID, Dictionary<string, string> details)
        {
            try
            {
                BasePlayer player;
                if (!GetBasePlayer(playerID, out player))
                {
                    return;
                }

                // Check if already recording
                if (player.Connection.IsRecording)
                {
                    return;
                }

                Vector3 pos = player.transform.position;
                string message = $"{player.displayName} ({playerID}) is defying gravity!\n\nElevation: {details["elevation"]}\nMovement speed: {details["movement_speed"]}\nViolation: {details["violation_id"]}\nPosition: teleportpos {pos.x}, {pos.y}, {pos.z}";
                AutoDemoRecord?.Call("API_StartRecording4", player, message, _config.GravityHookConfig.DemoDuration, _config.GravityHookConfig.DiscordWebhook);
            }
            catch(Exception ex)
            {
                LogError(ex.ToString());
            }
        }

        private void OnGuardianAntiCheatMeleeRate(string playerID, Dictionary<string, string> details)
        {
            try
            {
                BasePlayer player;
                if (!GetBasePlayer(playerID, out player))
                {
                    return;
                }

                // Check if already recording
                if (player.Connection.IsRecording)
                {
                    return;
                }

                string message = $"{player.displayName} ({playerID}) is meleeing too fast!\n\nWeapon Type: {details["weapon_type"]}\nMovement speed: {details["movement_speed"]}\nRate Percentage: {details["rate_percent"]}%\nViolation: {details["violation_id"]}";
                AutoDemoRecord?.Call("API_StartRecording4", player, message, _config.MeleeRateConfig.DemoDuration, _config.MeleeRateConfig.DiscordWebhook);
            }
            catch(Exception ex)
            {
                LogError(ex.ToString());
            }
        }

        private void OnGuardianServer(string playerID, Dictionary<string, string> details)
        {
            try
            {
                AntiHackType antihackType = (AntiHackType)Enum.Parse(typeof(AntiHackType), details["antihack_type"]);

                if ((antihackType != AntiHackType.NoClip || !_config.NoClipConfig.HookEnabled)
                    && (antihackType != AntiHackType.InsideTerrain || !_config.InsideTerrainConfig.HookEnabled))
                {
                    return;
                }

                BasePlayer player;
                if (!GetBasePlayer(playerID, out player))
                {
                    return;
                }

                // Check if already recording
                if (player.Connection.IsRecording)
                {
                    return;
                }

                Vector3 pos = player.transform.position;
                HookConfig config = antihackType == AntiHackType.NoClip ? _config.NoClipConfig : _config.InsideTerrainConfig;
                string actionStr = antihackType == AntiHackType.NoClip ? "no clipping" : "inside terrain";
                string message = $"{player.displayName} ({playerID}) is {actionStr}!\n\nViolation: {details["violation_id"]}\nPosition: teleportpos {pos.x}, {pos.y}, {pos.z}";

                AutoDemoRecord?.Call("API_StartRecording4", player, message, config.DemoDuration, config.DiscordWebhook);
            }
            catch(Exception ex)
            {
                LogError(ex.ToString());
            }
        }

        #endregion // Guardian Hooks

        #region Helper Methods

        private bool GetBasePlayer(string playerID, out BasePlayer player)
        {
            player = null;

            ulong steamID;
            if (!ulong.TryParse(playerID, out steamID))
            {
                LogError($"Unexpected error. Could not parse player steam id {playerID}.");
                return false;
            }

            player = BasePlayer.FindByID(steamID);
            if (player == null)
            {
                LogError($"Unexpected error. Player with steam id {playerID} was not found.");
                return false;
            }
            return true;
        }

        #endregion // Helper Methods

    }
}


// --- End of file: GuardianADR.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gst-report ---
// --- Original File Path: G/GSTReport/GSTReport.cs ---

using ConVar;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("GST Report", "mrcameron999", "1.0.5")]
    [Description("Extends F7 reporting with Discord Linker and gameservertools.com integration")]
    public class GSTReport : CovalencePlugin
    {
        private readonly string connection = "https://api.gameservertools.com/";

        private bool loggingEnabled = false;
        private readonly float timeout = 1000f;
        private int port;
        private Dictionary<string, string> headers = new Dictionary<string, string>();

        private Dictionary<ulong, List<string>> messages = new Dictionary<ulong, List<string>>();

        private void Init()
        {
            LoadConfigData();
        }

        private void LoadConfigData()
        {
            loggingEnabled = bool.Parse(Config["DebugLoggingEnabled"].ToString());
            port = int.Parse(Config["Port"].ToString());
            string apiKey = Config["APIKEY"].ToString();

            if (string.IsNullOrEmpty(apiKey))
                LogError("NO API KEY PROVIDED! Please ensure you have added your api key in the config file");
            else
            {
                headers.Add("Content-Type", "application/json");
                headers.Add("ApiKey", apiKey);
            }
        }

        #region Hooks

        private void OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            List<string> messageList;
            if (!messages.TryGetValue(player.userID, out messageList))
            {
                messageList = new List<string>();
                messages.Add(player.userID, messageList);
            }

            messageList.Insert(0, $"{DateTime.UtcNow} UTC | {channel} | {message}");
        }

        private void OnPlayerReported(BasePlayer reporter, string targetName, string targetId, string subject, string message, string type)
        {
            Dictionary<string, object> parameters = new Dictionary<string, object>();

            List<KeyValuePair<int, List<string>>> files = new List<KeyValuePair<int, List<string>>>();

            ReportType typeOfReport = GetTypeIdFromType(type);
            parameters.Add("ReporterId", reporter.userID.ToString());
            parameters.Add("ReportedPlayerId", targetId);
            parameters.Add("Subject", subject);

            parameters.Add("Reason", message);
            parameters.Add("ServerPort", port);
            parameters.Add("Type", GetTypeIdFromType(type));//find the type

            if (typeOfReport == ReportType.Abusive || typeOfReport == ReportType.Spam) // Get the chat log
            {
                ulong playerIdLong = ulong.Parse(targetId);
                if (messages.ContainsKey(playerIdLong))
                {
                    List<string> userMessages = messages[playerIdLong];
                    if(userMessages.Count > 100)
                    {
                        userMessages.RemoveRange(100, userMessages.Count);
                    }

                    files.Add(new KeyValuePair<int, List<string>>(0, messages[playerIdLong]));
                }
            }
            if (typeOfReport == ReportType.Cheat)
            {
                BasePlayer target = BasePlayer.Find(targetId);
                if (target != null)
                {
                    int oldDelay = ConVar.Server.combatlogdelay;
                    ConVar.Server.combatlogdelay = 0;
                    string combatLogString = target.stats.combat.Get(ConVar.Server.combatlogsize);
                    ConVar.Server.combatlogdelay = oldDelay;

                    files.Add(new KeyValuePair<int, List<string>>(1, combatLogString.Split(new string[] { "\r\n", "\r", "\n" }, StringSplitOptions.None).ToList()));
                }
            }
            parameters.Add("TextFiles", files);

            string body = JsonConvert.SerializeObject(parameters);

            if(loggingEnabled)
                Puts($"Sending report...");

            webrequest.Enqueue($"{connection}api/Report/AddReport", body, (code, response) =>
            {
                if(loggingEnabled)
                    Puts($"Got result back!\nCode: {code}\n Response: {response}");

            }, this, Core.Libraries.RequestMethod.POST, headers, timeout);
        }

        #endregion Hooks

        private ReportType GetTypeIdFromType(string type)
        {
            switch (type)
            {
                case "abusive":
                    return ReportType.Abusive;

                case "cheat":
                    return ReportType.Cheat;

                case "spam":
                    return ReportType.Spam;

                case "name":
                    return ReportType.Name;
            }
            return ReportType.Abusive;
        }

        #region config

        protected override void LoadDefaultConfig()
        {
            Config["DebugLoggingEnabled"] = false;
            Config["APIKEY"] = "";
            Config["Port"] = 28015;
        }

        #endregion config
        private enum ReportType
        {
            Abusive = 1,
            Cheat = 2,
            Spam = 3,
            Name = 4
        }
    }
}

// --- End of file: GSTReport.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gather-away ---
// --- Original File Path: G/GatherAway/GatherAway.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins;

[Info("Gather Away", "Notchu", "1.1.2")]
[Description("Automatically hits weak spot while gathering resources")]
internal class GatherAway : CovalencePlugin
{
    private class Configuration
    {
        [JsonProperty("Automatically gather X Markers")] 
        public bool XMarkerGather = true;

        [JsonProperty("Automatically gather Ore Weak spots")] 
        public bool OreWeakSpotsGather = true;

        [JsonProperty("BlackList - false, whitelist - true")]
        public bool ItemList = false;

        [JsonProperty("BlackList(false)")] 
        public List<string> BlackList = new List<string>();
        
        [JsonProperty("Whitelist(true)")] 
        public List<string> WhiteList = new List<string>();

        [JsonProperty("ignore blacklist during period")]
        public bool IgnoreBlackListDuringPeriod  = true;

        [JsonProperty("Give players ability to turn off plugin for themselves")]
        public bool TogglePluginByPlayer = true;

        [JsonProperty("period start hour")]
        public int PeriodStart  = 19;

        [JsonProperty("period end hour")]
        public int PeriodEnd  = 7;
    }
    private Configuration _config;
    
    private HashSet<string> disabledPlayers = new HashSet<string>();
    private const string DataFile = "GatherAwayDisabledPlayers";
    
    private void LoadData()
    {
        disabledPlayers = Interface.Oxide.DataFileSystem.ReadObject<HashSet<string>>(DataFile) ?? new HashSet<string>();
    }

    private void SaveData()
    {
        Interface.Oxide.DataFileSystem.WriteObject(DataFile, disabledPlayers);
    }
        
    protected override void LoadConfig()
    {
        base.LoadConfig();
        try
        {
            _config = Config.ReadObject<Configuration>();
            if (_config == null) throw new Exception();
            SaveConfig();
        }
        catch
        {
            PrintError("Your configuration file contains an error. Using default configuration values.");
            LoadDefaultConfig();
        }
    }
    protected override void SaveConfig() => Config.WriteObject(_config);

    protected override void LoadDefaultConfig() => _config = new Configuration();
    
    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            { "GatherAwayOn", "Now you will hit weak spots of ores and trees" },
            {"GatherAwayOff", "Now you will NOT hit weak spots of ores and trees"},
            {"NoRights", "You don't have rights to use this command." },
        }, this);
    }
    
    void Init()
    {
        if (_config.TogglePluginByPlayer)
        {
            Puts("Enabled plugin by player");
            AddCovalenceCommand("gatheraway", "ToggleGatherAway");
            LoadData(); 
        }
        if (!_config.OreWeakSpotsGather)
        {
            Unsubscribe(nameof(OnPlayerAttack));
        }
        if (!_config.XMarkerGather)
        {
            Unsubscribe(nameof(OnTreeMarkerHit));
        }
        permission.RegisterPermission("gatheraway.use", this);
    }

    void Unload()
    {
        SaveData();
        disabledPlayers.Clear();
    }
    void OnServerSave()
    {
        SaveData();
    }
    object  OnPlayerAttack(BasePlayer player, HitInfo info)
    {
        if (info == null || info.IsProjectile()) return null;
        
        if (player == null || info.HitEntity is not OreResourceEntity ore || info.InitiatorPlayer.IsBot) return null;
        
        if (_config.TogglePluginByPlayer && disabledPlayers.Contains(player.UserIDString)) return null;
        
        if (ore._hotSpot == null) return null;
        
        var userID = player.UserIDString;
        
        switch (_config.ItemList)
        {
            case true:
                if (IsWeaponWhitelisted(info)) break;
                return null;
            case false:
                if (IsWeaponBlacklisted(info))
                {
                    if (!_config.IgnoreBlackListDuringPeriod) return null;
            
                    if (IsInPeriod()) HitWeakSpotOnOre(info, userID, ore);
            
                    return null;
                }
                break;
        }
        
        HitWeakSpotOnOre(info, userID, ore);    

        return null;
    }
    bool? OnTreeMarkerHit(TreeEntity tree, HitInfo info)
    {
        var initiator = info.InitiatorPlayer;
        
        if (initiator.IsBot) return null;
        
        if (_config.TogglePluginByPlayer && disabledPlayers.Contains(initiator.UserIDString)) return null;

        switch (_config.ItemList)
        {
            case true:
                if (IsWeaponWhitelisted(info)) break;
                return null;
            case false:
                if (IsWeaponBlacklisted(info))
                {
                    if (!_config.IgnoreBlackListDuringPeriod) return null;

                    if (IsInPeriod()) break;

                    return null;
                }

                break;
        }
       
        
        if (!permission.UserHasPermission(initiator.UserIDString, "gatheraway.use") ) return null;
        
        return true;
    }

    private bool IsWeaponBlacklisted(HitInfo info)
    {
        return _config.BlackList.Contains(info.Weapon.ShortPrefabName);
    }
    private bool IsWeaponWhitelisted(HitInfo info)
    {
        return _config.WhiteList.Contains(info.Weapon.ShortPrefabName);
    }

    void HitWeakSpotOnOre(HitInfo info, string playerId, OreResourceEntity ore)
    {
        if (!permission.UserHasPermission(playerId, "gatheraway.use")) return;
        
        info.HitPositionWorld = ore._hotSpot.transform.position;
    }

    bool IsInPeriod()
    {
        var time = TOD_Sky.Instance.Cycle.DateTime;

        var hours = time.Hour;

        return hours >= _config.PeriodStart || hours <= _config.PeriodEnd;
    }

    void ToggleGatherAway(IPlayer player, string command, string[] args)
    {
        var userId = player.Id;
        if (_config.TogglePluginByPlayer && permission.UserHasPermission(userId, "gatheraway.use"))
        {
            if (disabledPlayers.Contains(userId))
            {
                disabledPlayers.Remove(userId);
                player.Reply(lang.GetMessage("GatherAwayOn", this));
            }
            else
            {
                disabledPlayers.Add(userId);
                player.Reply(lang.GetMessage("GatherAwayOff", this));
            }

        }
        else
        {
            player.Reply(lang.GetMessage("NoRights", this));
        }
    }
}

// --- End of file: GatherAway.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/graffiti-restriction ---
// --- Original File Path: G/GraffitiRestriction/GraffitiRestriction.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Graffiti Restriction", "Turtle In Black", "1.1.0")]
    [Description("Restricts drawing graffiti on buildings where players don't have building privilege.")]
    public class GraffitiRestriction : RustPlugin
    {
        #region Fields

        // Declare the bypass permission.
        private const string permBypass = "graffitirestriction.bypass";

        #endregion

        #region Initialization

        private void Init()
        {
            // Register the permission.
            permission.RegisterPermission(permBypass, this);
        }

        #endregion

        #region Hooks

        private object OnSprayCreate(SprayCan spray, Vector3 position, Quaternion rotation)
        {
            // Store the player holding the spray tool inside a variable.
            BasePlayer player = spray.GetOwnerPlayer();

            // Skip if the player has the bypass permission.
            if (permission.UserHasPermission(player.UserIDString, permBypass))
                return null;

            // Prevent drawing graffiti if the player doesn't have building privilege.
            if (player.IsBuildingBlocked())
            {
                SendReply(player, GetLang(Lang.NoGraffiti, player.UserIDString));
                return false;
            }

            // Otherwise, allow drawing graffiti.
            return null;
        }

        #endregion

        #region Localization

        /// <summary>
        /// Provides the keys to the messages.
        /// </summary>
        private static class Lang
        {
            public const string NoGraffiti = "No Graffiti";
        }

        /// <summary>
        /// Registers and populates the language file with the default messages.
        /// </summary>
        protected override void LoadDefaultMessages()
        {
            // English language.
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.NoGraffiti] = "You don't have permission to spray here."
            }, this, "en");
        }

        /// <summary>
        /// Gets the localized and formatted message from the localization file.
        /// </summary>
        /// <param name="messageKey"> The message key. </param>
        /// <param name="playerId"> The player to whom the message is to be sent. </param>
        /// <param name="args"> Any additional arguments required in the message. </param>
        /// <returns> The localized message for the stated key. </returns>
        private string GetLang(string messageKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerId), args);
        }

        #endregion
    }
}

// --- End of file: GraffitiRestriction.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/group-limits ---
// --- Original File Path: G/GroupLimits/GroupLimits.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core.Libraries;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Group Limits", "misticos", "3.0.4")]
    [Description("Prevent rulebreakers from breaking group limits on your server and notify your staff")]
    class GroupLimits : CovalencePlugin
    {
        #region Variables

        private const string PermissionIgnore = "grouplimits.ignore";

        private static GroupLimits _ins;

        private string _webhookBodyCached = null;

        private Dictionary<string, string> _cachedHeaders = new Dictionary<string, string>
            {{"Content-Type", "application/json"}};

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Limit> Limits = new List<Limit> {new Limit()};

            [JsonProperty(PropertyName = "Log Format")]
            public string LogFormat =
                "[{time}] {id} ({name}) authorized on {shortname}/{entid} ({type}) at ({position})";

            public class Limit
            {
                [JsonProperty(PropertyName = "Type Name")]
                public string Name = "Any";

                [JsonProperty(PropertyName = "Max Authorized")]
                public int MaxAuthorized = 3;

                [JsonProperty(PropertyName = "Shortnames", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<string> Shortnames = new List<string> {"global"};

                [JsonProperty(PropertyName = "Disable For Decaying Structures")]
                public bool NoDecaying = true;

                [JsonProperty(PropertyName = "Notify Player")]
                public bool NotifyPlayer = true;

                [JsonProperty(PropertyName = "Notify Owner")]
                public bool NotifyOwner = true;

                [JsonProperty(PropertyName = "Enforce")]
                public bool Enforce = false;

                [JsonProperty(PropertyName = "Deauthorize")]
                public bool Deauthorize = true;

                [JsonProperty(PropertyName = "Deauthorize All")]
                public bool DeauthorizeAll = false;

                [JsonProperty(PropertyName = "Discord")]
                public Discord Webhook = new Discord();

                [JsonProperty(PropertyName = "Log To File")]
                public bool File = false;

                public static Limit Find(string shortname)
                {
                    var cLimit = (Limit) null;
                    foreach (var limit in _ins._config.Limits)
                    {
                        if (limit.Shortnames.Contains("global"))
                            cLimit = limit;

                        if (limit.Shortnames.Contains(shortname))
                            return limit;
                    }

                    return cLimit;
                }

                public class Discord
                {
                    [JsonProperty(PropertyName = "Webhook")]
                    public string Webhook = string.Empty;

                    [JsonProperty(PropertyName = "Inline")]
                    public bool Inline = true;

                    [JsonProperty(PropertyName = "Title")]
                    public string Title = "Group Limit: Exceeded or deauthorized";

                    [JsonProperty(PropertyName = "Color")]
                    public int Color = 0;

                    [JsonProperty(PropertyName = "Player Title")]
                    public string PlayerTitle = "Player";

                    [JsonProperty(PropertyName = "Player")]
                    public string Player = "{name}/{id}";

                    [JsonProperty(PropertyName = "Authed Title")]
                    public string AuthedTitle = "Authorized Players";

                    [JsonProperty(PropertyName = "Authed")]
                    public string Authed = "{list}";

                    [JsonProperty(PropertyName = "Authed Entry")]
                    public string AuthedEntry = "{name}/{id}";

                    [JsonProperty(PropertyName = "Authed Separator")]
                    public string AuthedSeparator = "\n";

                    [JsonProperty(PropertyName = "Entity Title")]
                    public string EntityTitle = "Entity";

                    [JsonProperty(PropertyName = "Entity")]
                    public string Entity = "{shortname}/{id} ({type})";

                    [JsonProperty(PropertyName = "Position Title")]
                    public string PositionTitle = "Position";

                    [JsonProperty(PropertyName = "Position")]
                    public string Position = "teleportpos {position}";
                }
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #region Hooks

        private void Init()
        {
            _ins = this;

            permission.RegisterPermission(PermissionIgnore, this);

            _webhookBodyCached = JsonConvert.SerializeObject(new
            {
                embeds = new[]
                {
                    new
                    {
                        title = "{title}", color = -5,
                        fields = new[]
                        {
                            new {name = "{player.title}", value = "{player.value}", inline = true},
                            new {name = "{authed.title}", value = "{authed.value}", inline = true},
                            new {name = "{entity.title}", value = "{entity.value}", inline = true},
                            new {name = "{position.title}", value = "{position.value}", inline = true}
                        }
                    }
                }
            }, Formatting.None);
        }

        private void Unload()
        {
            _ins = null;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Notify: Player", "You are trying to exceed the group limit on our server."},
                {
                    "Notify: Owner",
                    "{name} tried to exceed the group limit on your entity at {position}. (Type: {type})"
                },
                {"Notify: Deauthorize Player", "One person was deauthorized, try to authorize again if you were not."},
                {
                    "Notify: Deauthorize Owner",
                    "{name} tried to authorize on your entity. One person was deauthorized on your entity at {position}. (Type: {type})"
                }
            }, this);
        }

        private object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            if (privilege.authorizedPlayers.Count == 0)
                return null;
            
            if (player.IPlayer.HasPermission(PermissionIgnore))
                return null;

            var limit = Configuration.Limit.Find(privilege.ShortPrefabName);
            if (limit == null)
                return null;

            privilege.authorizedPlayers.RemoveWhere(x => x.userid == player.userID);
            if (privilege.authorizedPlayers.Count < limit.MaxAuthorized)
                return null;

            if (limit.NoDecaying && IsDecaying(privilege))
                return null;

            var authed = privilege.authorizedPlayers.Select(x => x.userid);
            if (limit.Deauthorize)
            {
                // Make sure we send authed players before clearing
                authed = authed.ToArray();

                if (limit.DeauthorizeAll)
                    privilege.authorizedPlayers.Clear();
                else
                {
                    // Remove first, or any really
                    using var enumerator = privilege.authorizedPlayers.GetEnumerator();
                    if (enumerator.MoveNext())
                        privilege.authorizedPlayers.Remove(enumerator.Current);
                }

                privilege.SendNetworkUpdate();
            }

            Notify(limit, privilege, player, authed, limit.Deauthorize);

            if (limit.Enforce)
                return true;

            return null;
        }

        private object OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
        {
            if (codeLock.whitelistPlayers.Count == 0 && codeLock.guestCode.Length == 0)
                return null;

            var isCodeAdmin = codeLock.code == code;
            var isCodeGuest = codeLock.guestCode == code;
            if (!isCodeAdmin && !isCodeGuest)
                return null;
            
            if (player.IPlayer.HasPermission(PermissionIgnore))
                return null;

            var limit = Configuration.Limit.Find(codeLock.ShortPrefabName);
            if (limit == null)
                return null;

            var authed = codeLock.whitelistPlayers.Union(codeLock.guestPlayers).Distinct().ToArray();
            if (authed.Length < limit.MaxAuthorized)
                return null;

            var entity = codeLock.GetParentEntity();
            if (entity == null || !entity.IsValid())
                return null;

            if (limit.NoDecaying && IsDecaying(entity.GetBuildingPrivilege()))
                return null;

            if (limit.Deauthorize)
            {
                if (isCodeAdmin && codeLock.whitelistPlayers.Count > 0)
                {
                    if (limit.DeauthorizeAll)
                        codeLock.whitelistPlayers.Clear();
                    else
                        codeLock.whitelistPlayers.RemoveAt(0);
                }

                if (isCodeGuest && codeLock.guestPlayers.Count > 0)
                {
                    if (limit.DeauthorizeAll)
                        codeLock.guestPlayers.Clear();
                    else
                        codeLock.guestPlayers.RemoveAt(0);
                }

                codeLock.SendNetworkUpdate();
            }

            Notify(limit, entity, player, authed, limit.Deauthorize);

            if (limit.Enforce)
                return true;

            return null;
        }

        private object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
        {
            if (turret.authorizedPlayers.Count == 0)
                return null;
            
            if (player.IPlayer.HasPermission(PermissionIgnore))
                return null;

            var limit = Configuration.Limit.Find(turret.ShortPrefabName);
            if (limit == null)
                return null;

            turret.authorizedPlayers.RemoveWhere(x => x.userid == player.userID);
            if (turret.authorizedPlayers.Count < limit.MaxAuthorized)
                return null;

            if (limit.NoDecaying && IsDecaying(turret.GetBuildingPrivilege()))
                return null;

            var authed = turret.authorizedPlayers.Select(x => x.userid);
            if (limit.Deauthorize)
            {
                // Make sure we send authed players before clearing
                authed = authed.ToArray();

                if (limit.DeauthorizeAll)
                    turret.authorizedPlayers.Clear();
                else
                {
                    // Remove first, or any really
                    using var enumerator = turret.authorizedPlayers.GetEnumerator();
                    if (enumerator.MoveNext())
                        turret.authorizedPlayers.Remove(enumerator.Current);
                }
            }

            Notify(limit, turret, player, authed, limit.Deauthorize);

            if (limit.Enforce)
                return true;

            return null;
        }

        #endregion

        #region Helpers

        private void Notify(Configuration.Limit limit, BaseEntity entity, BasePlayer basePlayer,
            IEnumerable<ulong> authed, bool deauth)
        {
            if (limit.NotifyPlayer)
            {
                var player = basePlayer?.IPlayer;
                if (player != null && player.IsConnected)
                {
                    player.Message(GetMsg(deauth ? "Notify: Deauthorize Player" : "Notify: Player", player.Id));
                }
            }

            if (limit.NotifyOwner)
            {
                var player = players.FindPlayerById(entity.OwnerID.ToString());
                if (player != null && player.IsConnected)
                {
                    var sb = new StringBuilder(
                        GetMsg(deauth ? "Notify: Deauthorize Owner" : "Notify: Owner", player.Id));

                    sb.Replace("{position}", entity.transform.position.ToString());
                    sb.Replace("{type}", limit.Name);
                    sb.Replace("{name}", basePlayer?.displayName ?? "Unknown");

                    player.Message(sb.ToString());
                }
            }

            NotifyLog(limit, entity, basePlayer);
            NotifyDiscord(limit, entity, basePlayer, authed);
        }

        private void NotifyLog(Configuration.Limit limit, BaseNetworkable entity, BasePlayer player)
        {
            if (!limit.File)
                return;

            var builder = new StringBuilder(_config.LogFormat);
            builder.Replace("{time}", DateTime.Now.ToLongTimeString());
            builder.Replace("{name}", player?.displayName ?? "Unknown");
            builder.Replace("{id}", player?.UserIDString ?? "0");
            builder.Replace("{shortname}", entity.ShortPrefabName);
            builder.Replace("{entid}", entity.net.ID.ToString());
            builder.Replace("{type}", limit.Name);
            builder.Replace("{position}", FormattedCoordinates(entity.transform.position));

            LogToFile("Log", builder.ToString(), this);
        }

        private void NotifyDiscord(Configuration.Limit limit, BaseNetworkable entity, BasePlayer player,
            IEnumerable<ulong> authedPlayers)
        {
            var discord = limit.Webhook;
            if (string.IsNullOrEmpty(discord.Webhook))
                return;

            var builder = new StringBuilder();
            foreach (var authed in authedPlayers)
            {
                if (builder.Length != 0)
                    builder.Append(discord.AuthedSeparator);

                builder.Append(discord.AuthedEntry);
                builder.Replace("{id}", authed.ToString());
                builder.Replace("{name}", players.FindPlayerById(authed.ToString())?.Name ?? "Unknown");
            }

            var list = builder.ToString();
            list = builder.Clear().Append(discord.Authed).Replace("{list}", list).ToString();
            
            var body = builder.Clear().Append(_webhookBodyCached)
                .Replace("-5", discord.Color.ToString())
                .Replace(true.ToString(), discord.Inline.ToString().ToLower())
                .Replace("{title}", discord.Title)
                .Replace("{player.title}", discord.PlayerTitle)
                .Replace("{player.value}", discord.Player.Replace("{name}", player?.displayName ?? "Unknown")
                    .Replace("{id}", player?.UserIDString ?? "0"))
                .Replace("{authed.title}", discord.AuthedTitle)
                .Replace("{authed.value}", list)
                .Replace("{entity.title}", discord.EntityTitle)
                .Replace("{entity.value}", discord.Entity.Replace("{shortname}", entity.ShortPrefabName)
                    .Replace("{id}", entity.net.ID.ToString()).Replace("{type}", limit.Name))
                .Replace("{position.title}", discord.PositionTitle)
                .Replace("{position.value}",
                    discord.Position.Replace("{position}", FormattedCoordinates(entity.transform.position)))
                .Replace("\n", "\\n")
                .ToString();

            webrequest.Enqueue(discord.Webhook, body, (i, s) =>
            {
                if (i != 204)
                    PrintWarning($"Unable to finish Discord webhook request ({i}):\n{s}");
            }, this, RequestMethod.POST, _cachedHeaders);
        }

        private string FormattedCoordinates(Vector3 pos) => $"{pos.x},{pos.y},{pos.z}";

        private bool IsDecaying(BuildingPrivlidge privilege) =>
            privilege == null || privilege.GetProtectedMinutes(true) <= 0;

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

        #endregion
    }
}

// --- End of file: GroupLimits.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/grid ---
// --- Original File Path: G/Grid/Grid.cs ---

using UnityEngine;
using System.Collections.Generic;

namespace Oxide.Plugins {
	[Info("Grid", "yetzt", "0.0.3")]
	[Description("Get the map grid reference of a position")]

	public class Grid : RustPlugin {

		void LoadDefaultMessages() {
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "You are in {0}" }, this);
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Du bist in {0}" }, this, "de");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Je bent in {0}" }, this, "nl");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Dir sidd am {0}" }, this, "lu");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Tu estas en {0}" }, this, "es");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Voc est em {0}" }, this, "pt");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Vous tes en {0}" }, this, "fr");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Sei in {0}" }, this, "it");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Jeste w {0}" }, this, "pl");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Jste v {0}" }, this, "cz");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Ste v {0}" }, this, "sk");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Du er i {0}" }, this, "dk");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Du r i {0}" }, this, "se");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Du er i {0}" }, this, "no");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Olet paskainen {0}" }, this, "fi");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Konumunuz {0}" }, this, "tr");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "A helyed {0}" }, this, "hu");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "  {0}" }, this, "gr");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "Bn ang  {0}" }, this, "vi");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "{0}" }, this, "jp");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "{0} " }, this, "ko");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = " {0}" }, this, "zh-CN");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "  {0}" }, this, "ar");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "  {0}" }, this, "ru");
			lang.RegisterMessages(new Dictionary<string, string> { ["YouAreIn"] = "  {0}" }, this, "uk");
		}
		
		string getGrid(Vector3 pos) {
			char letter = 'A';
			var x = Mathf.Floor((pos.x+(ConVar.Server.worldsize/2)) / 146.3f)%26;
			var z = (Mathf.Floor(ConVar.Server.worldsize/146.3f))-Mathf.Floor((pos.z+(ConVar.Server.worldsize/2)) / 146.3f);
			letter = (char)(((int)letter)+x);
			return $"{letter}{z}";
		}

		[ChatCommand("grid")]
		void replyGrid(BasePlayer player, string cmd, string[] args) {
			string g = getGrid(player.transform.position);
			SendReply(player, string.Format(lang.GetMessage("YouAreIn", this, player.UserIDString), g));
		}
	
	}

}

// --- End of file: Grid.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gyrocopter ---
// --- Original File Path: G/Gyrocopter/Gyrocopter.cs ---

using Rust;
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Gyrocopter", "ColonBlow", "1.2.11")]
    [Description("Allows players to fly there very own scrap build gyrocopter")]
    class Gyrocopter : RustPlugin
    {

        // fix for basemountable error

        #region Load

        static LayerMask layerMask;
        private BaseEntity newCopter;

        static Dictionary<ulong, PlayerCopterData> loadplayer = new Dictionary<ulong, PlayerCopterData>();
        static List<ulong> pilotslist = new List<ulong>();

        public class PlayerCopterData
        {
            public BasePlayer player;
            public int coptercount;
        }

        private void Init()
        {
            lang.RegisterMessages(messages, this);
            LoadVariables();
            layerMask = (1 << 29);
            layerMask |= (1 << 18);
            layerMask = ~layerMask;
            permission.RegisterPermission("gyrocopter.build", this);
            permission.RegisterPermission("gyrocopter.unlimited", this);
        }

        private bool isAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        #endregion

        #region Configuration

        private bool UseMaxCopterChecks = true;
        public int maxcopters = 1;

        static float MinAltitude = 10f;
        static float RechargeRange = 12f; //Needs to be more than the MinAltitude

        static int NormalCost = 5;
        static int SprintCost = 12;

        static int BonusRechargeRate = 5;
        static int BaseRechargeRate = 1;

        static float NormalSpeed = 12f;
        static float SprintSpeed = 25f;

        static float bombdamageradius = 2f;
        static float bombdamage = 250f;

        static bool enablebombs = true;
        static bool enablestoragebox = true;
        static bool enablepassstoragebox = true;

        private bool OwnerLockPaint = true;

        private bool Changed;

        private void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        private void LoadConfigVariables()
        {
            CheckCfgFloat("Minimum Flight Altitude : ", ref MinAltitude);
            CheckCfgFloat("Recharge - Range - From substation (must be higher than Min Altitude) : ", ref RechargeRange);
            CheckCfgFloat("Speed - Normal Flight Speed is : ", ref NormalSpeed);
            CheckCfgFloat("Speed - Sprint Flight Speed is : ", ref SprintSpeed);

            CheckCfg("Recharge - Bonus Substation Rate : ", ref BonusRechargeRate);
            CheckCfg("Recharge - Base Rate : ", ref BaseRechargeRate);
            CheckCfg("Movement - Normal - Cost (normal speeed) : ", ref NormalCost);
            CheckCfg("Movement - Sprint - Cost (fast speed) : ", ref SprintCost);
            CheckCfg("Only the Builder (owner) of copter can lock paint job : ", ref OwnerLockPaint);
            CheckCfg("Deploy - Enable limited Gyrocopters per person : ", ref UseMaxCopterChecks);
            CheckCfg("Deploy - Limit of Copters players can build : ", ref maxcopters);
            CheckCfg("Bomb - Amount of Explosive Damage to deal : ", ref bombdamage);
            CheckCfg("Bomb - Radius the damage will effect : ", ref bombdamageradius);
            CheckCfg("Bomb - Enable the use of Bombs ? ", ref enablebombs);
            CheckCfg("Storage Box - Enable storage box under pilot seat ? ", ref enablestoragebox);
            CheckCfg("Storage Box - Enable storage box under passenger seats ? ", ref enablepassstoragebox);
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        private void CheckCfgFloat(string Key, ref float var)
        {
            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        #endregion

        #region Language Area

        private Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"helptext1", "type /copterbuild to spawn a gyrocopter and automount it." },
            {"helptext2", "type /copterlockpaint to lock copter paintjob and /copterunlockpaint to unlock" },
            {"helptext3", "use Spinner wheel while seated to start and stop flying copter." },
            {"helptext4", "Rehcharge - land copter to recharge, hover over substation to fast charge." },
            {"helptext5", "Locking codelock will prevent anyone from using copter (even owner)." },
            {"helptext6", "Once copter runs out of charge, it will autoland." },
            {"helptext7", "To reload the Bomb Barrel on back, use the Reload key while hovering over a barrel." },
            {"helptext8", "To Drop a Bomb, press or click mouse wheel down." },
            {"notauthorized", "You don't have permission to do that !!" },
            {"copterlocked", "You must unlock Copter to start engines !!" },
            {"tellabouthelp", "type /copterhelp to see a list of commands !!" },
            {"dropnet", "Dropping cargo netting !!" },
            {"raisenet", "Raising cargo netting !!" },
            {"notflyingcopter", "You are not piloting a gyrocopter !!" },
            {"maxcopters", "You have reached the maximum allowed copters" },
            {"landingcopter", "Gryocopter Landing Sequence started !!" }
        };

        #endregion

        #region Chat Commands

        [ChatCommand("copterhelp")]
        private void chatCopterHelp(BasePlayer player, string command, string[] args)
        {
            SendReply(player, lang.GetMessage("helptext1", this, player.UserIDString));
            SendReply(player, lang.GetMessage("helptext2", this, player.UserIDString));
            SendReply(player, lang.GetMessage("helptext3", this, player.UserIDString));
            SendReply(player, lang.GetMessage("helptext4", this, player.UserIDString));
            SendReply(player, lang.GetMessage("helptext5", this, player.UserIDString));
            SendReply(player, lang.GetMessage("helptext6", this, player.UserIDString));
            SendReply(player, lang.GetMessage("helptext7", this, player.UserIDString));
            SendReply(player, lang.GetMessage("helptext8", this, player.UserIDString));
        }

        [ChatCommand("copterbuild")]
        private void chatBuildCopter(BasePlayer player, string command, string[] args)
        {
            if (!isAllowed(player, "gyrocopter.build")) { SendReply(player, lang.GetMessage("notauthorized", this, player.UserIDString)); return; }
            if (CopterLimitReached(player)) { SendReply(player, lang.GetMessage("maxcopters", this, player.UserIDString)); return; }
            AddCopter(player, player.transform.position);
        }


        [ConsoleCommand("copterbuild")]
        private void cmdConsoleBuildCopter(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player == null) return;
            if (!isAllowed(player, "gyrocopter.build")) { SendReply(player, lang.GetMessage("notauthorized", this, player.UserIDString)); return; }
            if (CopterLimitReached(player)) { SendReply(player, lang.GetMessage("maxcopters", this, player.UserIDString)); return; }
            AddCopter(player, player.transform.position);
        }

        [ChatCommand("copterdropnet")]
        private void chatDropNetCopter(BasePlayer player, string command, string[] args)
        {
            if (!player.isMounted) return;
            var activecopter = player.GetMounted().GetComponentInParent<GyroCopter>();
            if (activecopter == null) return;
            if (activecopter.islanding || !activecopter.engineon) return;
            activecopter.DropNet();
        }

        [ChatCommand("copterlockpaint")]
        private void chatCopterLockPaint(BasePlayer player, string command, string[] args)
        {
            if (!player.isMounted) return;
            var activecopter = player.GetMounted().GetComponentInParent<GyroCopter>();
            if (activecopter == null) return;
            if (activecopter.islanding) return;
            if (OwnerLockPaint && activecopter.ownerid != player.userID) return;
            if (!activecopter.paintingsarelocked) { activecopter.LockPaintings(); return; }
        }

        [ChatCommand("copterunlockpaint")]
        private void chatCopterUnLockPaint(BasePlayer player, string command, string[] args)
        {
            if (!player.isMounted) return;
            var activecopter = player.GetMounted().GetComponentInParent<GyroCopter>();
            if (activecopter == null) return;
            if (activecopter.islanding) return;
            if (OwnerLockPaint && activecopter.ownerid != player.userID) return;
            if (activecopter.paintingsarelocked) { activecopter.UnLockPaintings(); return; }
        }

        private void AddCopter(BasePlayer player, Vector3 location)
        {
            if (player == null && location == null) return;
            if (location == null && player != null) location = player.transform.position;
            var spawnpos = new Vector3(location.x, location.y + 0.5f, location.z);
            string staticprefab = "assets/bundled/prefabs/static/chair.invisible.static.prefab";
            newCopter = GameManager.server.CreateEntity(staticprefab, spawnpos, new Quaternion(), true);
            var chairmount = newCopter.GetComponent<BaseMountable>();
            chairmount.isMobile = true;
            newCopter.enableSaving = false;
            newCopter.OwnerID = player.userID;
            newCopter.Spawn();
            var gyrocopter = newCopter.gameObject.AddComponent<GyroCopter>();
            AddPlayerID(player.userID);
            if (chairmount != null && player != null) { chairmount.MountPlayer(player); return; }
            var passengermount = newCopter.GetComponent<GyroCopter>().passengerchair1.GetComponent<BaseMountable>();
            if (passengermount != null && player != null && isAllowed(player, "gyrocopter.build")) { passengermount.MountPlayer(player); return; }
        }

        [ChatCommand("copterswag")]
        private void chatGetCopterSwag(BasePlayer player, string command, string[] args)
        {
            if (!isAllowed(player, "gyrocopter.build")) { SendReply(player, lang.GetMessage("notauthorized", this, player.UserIDString)); return; }
            Item num = ItemManager.CreateByItemID(-864578046, 1, 961776748);
            player.inventory.GiveItem(num, null);
            player.Command("note.inv", -864578046, 1);
        }

        [ChatCommand("coptercount")]
        private void cmdChatCopterCount(BasePlayer player, string command, string[] args)
        {
            if (!loadplayer.ContainsKey(player.userID))
            {
                SendReply(player, "You have no GyroCopters");
                return;
            }
            SendReply(player, "Current Copters : " + (loadplayer[player.userID].coptercount));
        }

        [ChatCommand("copterdestroy")]
        private void cmdChatCopterDestroy(BasePlayer player, string command, string[] args)
        {
            RemoveCopter(player);
            DestroyLocalCopter(player);
        }

        #endregion

        #region Hooks

        public bool PilotListContainsPlayer(BasePlayer player)
        {
            if (pilotslist.Contains(player.userID)) return true;
            return false;
        }

        private void AddPlayerToPilotsList(BasePlayer player)
        {
            if (PilotListContainsPlayer(player)) return;
            pilotslist.Add(player.userID);
        }

        public void RemovePlayerFromPilotsList(BasePlayer player)
        {
            if (PilotListContainsPlayer(player)) pilotslist.Remove(player.userID);
        }

        private void DestroyLocalCopter(BasePlayer player)
        {
            if (player == null) return;
            List<BaseEntity> copterlist = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(player.transform.position, 10f, copterlist);

            foreach (BaseEntity p in copterlist)
            {
                var foundent = p.GetComponentInParent<GyroCopter>() ?? null;
                if (foundent != null)
                {
                    if (foundent.ownerid != player.userID) return;
                    foundent.entity.Kill(BaseNetworkable.DestroyMode.Gib);
                }
            }
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (player == null || input == null) return;
            if (!player.isMounted) return;
            var activecopter = player.GetMounted().GetComponentInParent<GyroCopter>() ?? null;
            if (activecopter == null) return;
            if (player.GetMounted() != activecopter.entity) return;
            if (input != null)
            {
                activecopter.CopterInput(input, player);
            }
            return;
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo == null) return;
            var iscopter = entity.GetComponentInParent<GyroCopter>() ?? null;
            if (iscopter != null) hitInfo.damageTypes.ScaleAll(0);
            return;
        }

        private object OnEntityGroundMissing(BaseEntity entity)
        {
            var iscopter = entity.GetComponentInParent<GyroCopter>() ?? null;
            if (iscopter != null) return true;
            return null;
        }

        private void OnSpinWheel(BasePlayer player, SpinnerWheel wheel)
        {
            if (!player.isMounted) return;
            var activecopter = player.GetMounted().GetComponentInParent<GyroCopter>() ?? null;
            if (activecopter == null) return;
            if (activecopter.copterlock != null && activecopter.copterlock.IsLocked()) { SendReply(player, lang.GetMessage("copterlocked", this, player.UserIDString)); return; }
            if (player.GetMounted() != activecopter.entity) return;
            if (activecopter != null)
            {
                var ison = activecopter.engineon;
                if (ison) { activecopter.islanding = true; SendReply(player, lang.GetMessage("landingcopter", this, player.UserIDString)); wheel.velocity = 0f; return; }
                if (!ison)
                {
                    AddPlayerToPilotsList(player);
                    activecopter.SetBaseAltitude();
                    activecopter.islanding = false;
                    activecopter.engineon = true;
                    wheel.velocity = 0f; return;
                }
            }
        }

        private bool CopterLimitReached(BasePlayer player)
        {
            if (isAllowed(player, "gyrocopter.unlimited")) return false;
            if (UseMaxCopterChecks)
            {
                if (loadplayer.ContainsKey(player.userID))
                {
                    var currentcount = loadplayer[player.userID].coptercount;
                    var maxallowed = maxcopters;
                    if (currentcount >= maxallowed) return true;
                }
            }
            return false;
        }

        private object CanDismountEntity(BasePlayer player, BaseMountable entity)
        {
            if (player == null) return null;
            if (PilotListContainsPlayer(player)) return true;
            return null;
        }

        private void OnEntityMounted(BaseMountable mountable, BasePlayer player)
        {
            var activecopter = mountable.GetComponentInParent<GyroCopter>() ?? null;
            if (activecopter != null)
            {
                if (mountable.GetComponent<BaseEntity>() != activecopter.entity) return;
                player.gameObject.AddComponent<FuelControl>();
            }
        }

        private void OnEntityDismounted(BaseMountable mountable, BasePlayer player)
        {
            var activecopter = mountable.GetComponentInParent<GyroCopter>() ?? null;
            if (activecopter != null)
            {
                if (mountable.GetComponent<BaseEntity>() != activecopter.entity) return;
                var fuelcontrol = player.GetComponent<FuelControl>() ?? null;
                if (fuelcontrol != null) fuelcontrol.OnDestroy();
            }
        }

        private object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container == null || player == null) return null;
            var iscopter = container.GetComponentInParent<GyroCopter>() ?? null;
            if (iscopter != null)
            {
                if (iscopter.copterlock != null && iscopter.copterlock.IsLocked()) return true;
            }
            return null;
        }

        private object CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
        {
            if (entity == null || player == null) return null;
            if (entity.GetComponentInParent<GyroCopter>()) return false;
            return null;
        }

        private void AddPlayerID(ulong ownerid)
        {
            if (!loadplayer.ContainsKey(ownerid))
            {
                loadplayer.Add(ownerid, new PlayerCopterData
                {
                    coptercount = 1
                });
                return;
            }
            loadplayer[ownerid].coptercount = loadplayer[ownerid].coptercount + 1;
        }

        private void RemovePlayerID(ulong ownerid)
        {
            if (loadplayer.ContainsKey(ownerid)) loadplayer[ownerid].coptercount = loadplayer[ownerid].coptercount - 1;
            return;
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            RemovePlayerFromPilotsList(player);
        }

        private void RemoveCopter(BasePlayer player)
        {
            var hasgyro = player.GetComponent<FuelControl>() ?? null;
            if (hasgyro != null) GameObject.Destroy(hasgyro);
            RemovePlayerFromPilotsList(player);
            return;
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            RemoveCopter(player);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            RemoveCopter(player);
        }

        private void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        private void Unload()
        {
            DestroyAll<GyroCopter>();
            DestroyAll<FuelControl>();
        }

        #endregion

        #region Copter Antihack check

        private static List<BasePlayer> copterantihack = new List<BasePlayer>();

        private object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (player == null) return null;
            if (copterantihack.Contains(player)) return false;
            return null;
        }

        #endregion

        #region GyroCopter Entity

        private class GyroCopter : BaseEntity
        {
            public BaseEntity entity;
            public BasePlayer player;

            public BaseEntity wheel, deck1, deck2, barrel, barcenter;
            public BaseEntity rotor1, rotor2, rotor3, rotor4;
            public BaseEntity skid1, skid2, skid3, skid4, skidsupr, skidsupl;
            public BaseEntity tailrotor1, tailrotor2;
            public BaseEntity floor, nosesign, tail1, tail2;
            public BaseEntity passengerchair1, passengerchair2;
            public BaseEntity copterlock, panel;
            public BaseEntity dabomb;

            private BaseEntity fseat, fseatb, fseatl, fseatr;
            private BaseEntity rseat, rseatb, rseatl, rseatr;
            private BaseEntity lseat, lseatb, lseatl, lseatr;
            public BaseEntity pilotstorage;
            public BaseEntity passstorage1;
            public BaseEntity passstorage2;

            private Quaternion entityrot;
            private Vector3 entitypos;

            public bool moveforward;
            public bool movebackward;
            public bool moveup;
            public bool movedown;
            public bool rotright;
            public bool rotleft;
            public bool sprinting;
            public bool islanding;
            public bool hasbonuscharge;
            public bool paintingsarelocked;

            public ulong ownerid;
            private int count;
            public bool engineon;
            private float minaltitude;
            private Gyrocopter instance;
            public bool throttleup;
            private int sprintcost;
            private int normalcost;
            private float sprintspeed;
            private float normalspeed;
            public int currentfuel;
            private int baserechargerate;
            private int bonusrechargerate;
            private bool isenabled;
            private bool hasdabomb;
            private SphereCollider sphereCollider;

            private string prefabdeck = "assets/prefabs/deployable/signs/sign.post.town.prefab";
            private string prefabbar = "assets/prefabs/deployable/signs/sign.post.single.prefab";
            private string prefabrotor = "assets/prefabs/deployable/signs/sign.pictureframe.tall.prefab";
            private string prefabbarrel = "assets/bundled/prefabs/radtown/oil_barrel.prefab";
            private string prefabbomb = "assets/bundled/prefabs/radtown/oil_barrel.prefab";
            private string prefabfloor = "assets/prefabs/building/floor.grill/floor.grill.prefab";
            private string prefabnosesign = "assets/prefabs/deployable/signs/sign.medium.wood.prefab";
            private string prefabpanel = "assets/prefabs/deployable/signs/sign.small.wood.prefab";
            private string prefabskid = "assets/prefabs/deployable/signs/sign.post.single.prefab";
            private string wheelprefab = "assets/prefabs/deployable/spinner_wheel/spinner.wheel.deployed.prefab";
            private string copterlockprefab = "assets/prefabs/locks/keypad/lock.code.prefab";
            private string prefabchair = "assets/bundled/prefabs/static/chair.invisible.static.prefab";
            private string prefabnetting = "assets/prefabs/building/wall.frame.netting/wall.frame.netting.prefab";
            private string prefabdabomb = "assets/bundled/prefabs/radtown/oil_barrel.prefab";

            void Awake()
            {
                entity = GetComponentInParent<BaseEntity>();
                entityrot = Quaternion.identity;
                entitypos = entity.transform.position;
                minaltitude = MinAltitude;
                instance = new Gyrocopter();
                ownerid = entity.OwnerID;
                gameObject.name = "Gyrocopter";
                baserechargerate = BaseRechargeRate;
                bonusrechargerate = BonusRechargeRate;

                engineon = false;
                moveforward = false;
                movebackward = false;
                moveup = false;
                movedown = false;
                rotright = false;
                rotleft = false;
                sprinting = false;
                islanding = false;
                throttleup = false;
                hasbonuscharge = false;
                paintingsarelocked = false;
                sprintcost = SprintCost;
                sprintspeed = SprintSpeed;
                normalcost = NormalCost;
                normalspeed = NormalSpeed;
                currentfuel = 10000;
                isenabled = false;
                hasdabomb = false;
                SpawnCopter();
                if (enablestoragebox) SpawnFuelBox();
                ReloadDaBombs();

                sphereCollider = entity.gameObject.AddComponent<SphereCollider>();
                sphereCollider.gameObject.layer = (int)Layer.Reserved1;
                sphereCollider.isTrigger = true;
                sphereCollider.radius = 6f;
            }

            public void SetBaseAltitude()
            {
                moveup = true;
                instance.timer.Once(2f, () => moveup = false);
            }

            private BaseEntity SpawnPart(string prefab, BaseEntity entitypart, bool setactive, int eulangx, int eulangy, int eulangz, float locposx, float locposy, float locposz, BaseEntity parent, ulong skinid)
            {
                entitypart = new BaseEntity();
                entitypart = GameManager.server.CreateEntity(prefab, entitypos, entityrot, setactive);
                entitypart.transform.localEulerAngles = new Vector3(eulangx, eulangy, eulangz);
                entitypart.transform.localPosition = new Vector3(locposx, locposy, locposz);
                entitypart.SetParent(parent, 0);
                entitypart.skinID = skinid;
                entitypart?.Spawn();
                SpawnRefresh(entitypart);
                return entitypart;
            }

            private void SpawnRefresh(BaseEntity entity)
            {
                var hasstab = entity.GetComponent<StabilityEntity>() ?? null;
                if (hasstab != null)
                {
                    hasstab.grounded = true;
                }
                var hasmount = entity.GetComponent<BaseMountable>() ?? null;
                if (hasmount != null)
                {      
                    if (hasmount.IsFullySpawned() && !BaseMountable.FixedUpdateMountables.Contains(hasmount))
                    {
                        hasmount.isMobile = true;
                        BaseMountable.FixedUpdateMountables.Add(hasmount);
                    }
                }
                if (entity is SpinnerWheel) return;
                if (entity is Signage)
                {
                    entity.SetFlag(BaseEntity.Flags.Busy, true, true);
                }
            }

            public void SpawnCopter()
            {
                deck1 = SpawnPart(prefabdeck, deck1, false, 90, 0, 0, 0f, 0f, -0.4f, entity, 1);
                deck2 = SpawnPart(prefabdeck, deck2, false, -90, 0, 0, 0f, 0f, -0.2f, entity, 1);
                barrel = SpawnPart(prefabbarrel, barrel, false, 0, 180, 0, 0f, 0f, -1.1f, entity, 1);
                barcenter = SpawnPart(prefabbar, barcenter, false, 0, 0, 0, 0f, 1f, -1.1f, entity, 1);
                rotor1 = SpawnPart(prefabrotor, rotor1, false, 90, 0, 0, 0f, 2f, 0.6f, barcenter, 1);
                rotor2 = SpawnPart(prefabrotor, rotor2, false, 90, 0, 0, 0f, 2f, -3f, barcenter, 1);
                rotor3 = SpawnPart(prefabbar, rotor3, false, 90, 90, 0, -2f, 2f, 0f, barcenter, 1);
                rotor4 = SpawnPart(prefabbar, rotor4, false, -90, 90, 0, 2f, 2f, 0f, barcenter, 1);
                floor = SpawnPart(prefabdeck, floor, false, -90, 0, 0, 0f, 0f, 1.4f, entity, 1);
                nosesign = SpawnPart(prefabnosesign, nosesign, true, 310, 0, 0, 0f, -0.3f, 2.4f, entity, 1);

                tail1 = SpawnPart(prefabbar, tail1, false, 90, 90, -90, 0.5f, 0f, -2.5f, entity, 1);
                tail2 = SpawnPart(prefabbar, tail2, false, 90, 90, -90, -0.5f, 0f, -2.5f, entity, 1);
                tailrotor1 = SpawnPart(prefabbar, tailrotor1, false, 0, 90, -90, 0.5f, 0f, -2.5f, entity, 1);
                tailrotor2 = SpawnPart(prefabbar, tailrotor2, false, 0, 90, -90, -0.5f, 0f, -2.5f, entity, 1);

                skid1 = SpawnPart(prefabskid, skid1, false, -90, 0, 0, 0.8f, -0.5f, 0.8f, entity, 1);
                skid2 = SpawnPart(prefabskid, skid2, false, -90, 0, 0, -0.8f, -0.5f, 0.8f, entity, 1);
                skid3 = SpawnPart(prefabskid, skid3, false, -90, 180, 0, 0.8f, -0.5f, -2.6f, entity, 1);
                skid4 = SpawnPart(prefabskid, skid4, false, -90, 180, 0, -0.8f, -0.5f, -2.6f, entity, 1);
                skidsupl = SpawnPart(prefabpanel, skidsupl, false, 0, 90, 0, -0.8f, -0.5f, -1.1f, entity, 1);
                skidsupr = SpawnPart(prefabpanel, skidsupr, false, 0, 90, 0, 0.8f, -0.5f, -1.1f, entity, 1);

                fseat = SpawnPart(prefabpanel, fseat, false, 270, 0, 0, 0f, 0.3f, 0.2f, entity, 1);
                fseatb = SpawnPart(prefabpanel, fseatb, false, 0, 0, 0, 0f, 0.3f, -0.4f, entity, 1);
                fseatl = SpawnPart(prefabpanel, fseatl, false, 0, 90, 0, -0.4f, 0f, -0.2f, entity, 1);
                fseatr = SpawnPart(prefabpanel, fseatr, false, 0, 90, 0, 0.4f, 0f, -0.2f, entity, 1);

                rseat = SpawnPart(prefabpanel, rseat, false, 270, 270, 0, 0.4f, 0.2f, -2.1f, entity, 1);
                rseatb = SpawnPart(prefabpanel, rseatb, false, 0, 270, 0, 0.5f, 0.1f, -2.1f, entity, 1);
                rseatl = SpawnPart(prefabpanel, rseatl, false, 0, 0, 0, 0.4f, 0f, -2.5f, entity, 1);
                rseatr = SpawnPart(prefabpanel, rseatr, false, 0, 0, 0, 0.4f, 0f, -1.7f, entity, 1);

                lseat = SpawnPart(prefabpanel, lseat, false, 270, 270, 0, -0.9f, 0.2f, -2.1f, entity, 1);
                lseatb = SpawnPart(prefabpanel, lseatb, false, 0, 270, 0, -0.4f, 0.1f, -2.1f, entity, 1);
                lseatl = SpawnPart(prefabpanel, lseatl, false, 0, 0, 0, -0.4f, 0f, -2.5f, entity, 1);
                lseatr = SpawnPart(prefabpanel, lseatr, false, 0, 0, 0, -0.4f, 0f, -1.7f, entity, 1);

                wheel = SpawnPart(wheelprefab, wheel, true, 90, 0, 90, 0.8f, 0.4f, 0f, entity, 1);
                panel = SpawnPart(prefabpanel, panel, false, 210, 0, 0, 0f, 0.4f, 1.7f, entity, 1);
                copterlock = SpawnPart(copterlockprefab, copterlock, true, 0, 90, 30, 0f, 0.3f, 1.55f, entity, 1);

                passengerchair1 = SpawnPart(prefabchair, passengerchair1, true, 0, 90, 0, 0.7f, -0.1f, -2.1f, entity, 1);
                passengerchair2 = SpawnPart(prefabchair, passengerchair2, true, 0, 270, 0, -0.7f, -0.1f, -2.1f, entity, 1);
            }

            private void SpawnFuelBox()
            {
                var prefabfuelbox = "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab";
                pilotstorage = GameManager.server.CreateEntity(prefabfuelbox, entitypos, entityrot, true);
                pilotstorage.transform.localEulerAngles = new Vector3(0, 0, 0);
                pilotstorage.transform.localPosition = new Vector3(0f, -0.3f, 0f);
                pilotstorage.OwnerID = ownerid;
                pilotstorage?.Spawn();
                pilotstorage.SetParent(entity, 0);
                //var fuelboxcontainer = fuelbox.GetComponent<StorageContainer>();
                //fuelboxcontainer.inventory.capacity = 12;

                if (enablepassstoragebox)
                {
                    passstorage1 = GameManager.server.CreateEntity(prefabfuelbox, passengerchair1.transform.position, passengerchair1.transform.rotation, true);
                    passstorage1.transform.localEulerAngles = new Vector3(0, 0, 0);
                    passstorage1.transform.localPosition = new Vector3(0f, -0.3f, 0f);
                    passstorage1.OwnerID = ownerid;
                    passstorage1?.Spawn();
                    passstorage1.SetParent(passengerchair1, 0);
                    //var fuelboxcontainer = stashbox2.GetComponent<StorageContainer>();
                    //fuelboxcontainer.inventory.capacity = 12;


                    passstorage2 = GameManager.server.CreateEntity(prefabfuelbox, passengerchair2.transform.position, passengerchair2.transform.rotation, true);
                    passstorage2.transform.localEulerAngles = new Vector3(0, 0, 0);
                    passstorage2.transform.localPosition = new Vector3(0f, -0.3f, 0f);
                    passstorage2.OwnerID = ownerid;
                    passstorage2?.Spawn();
                    passstorage2.SetParent(passengerchair2, 0);
                    //var fuelboxcontainer = stashbox3.GetComponent<StorageContainer>();
                    //fuelboxcontainer.inventory.capacity = 12;
                }
            }

            private void OnTriggerEnter(Collider col)
            {
                var target = col.GetComponentInParent<BasePlayer>();
                if (target != null)
                {
                    copterantihack.Add(target);
                }
            }

            private void OnTriggerExit(Collider col)
            {
                var target = col.GetComponentInParent<BasePlayer>();
                if (target != null)
                {
                    copterantihack.Remove(target);
                }
            }

            public void DropNet()
            {
                var hasnet = entity.GetComponent<CopterNet>() ?? null;
                if (hasnet == null) { entity.gameObject.AddComponent<CopterNet>(); return; }
                GameObject.Destroy(hasnet);
            }

            public void LockPaintings()
            {
                floor.SetFlag(BaseEntity.Flags.Busy, true, true);
                deck1.SetFlag(BaseEntity.Flags.Busy, true, true);
                deck2.SetFlag(BaseEntity.Flags.Busy, true, true);
                barrel.SetFlag(BaseEntity.Flags.Busy, true, true);
                panel.SetFlag(BaseEntity.Flags.Busy, true, true);
                ServerMgr.Instance.StartCoroutine(RefreshCopter());
                paintingsarelocked = true;
            }

            public void UnLockPaintings()
            {
                floor.SetFlag(BaseEntity.Flags.Busy, false, true);
                deck1.SetFlag(BaseEntity.Flags.Busy, false, true);
                deck2.SetFlag(BaseEntity.Flags.Busy, false, true);
                barrel.SetFlag(BaseEntity.Flags.Busy, false, true);
                panel.SetFlag(BaseEntity.Flags.Busy, false, true);
                ServerMgr.Instance.StartCoroutine(RefreshCopter());
                paintingsarelocked = false;
            }

            private BasePlayer GetPilot()
            {
                player = entity.GetComponent<BaseMountable>().GetMounted() as BasePlayer;
                return player;
            }

            private void FuelCheck()
            {
                player = GetPilot();
                if (player != null && instance.isAllowed(player, "gyrocopter.unlimited")) { if (currentfuel <= 9999) currentfuel = 10000; return; }
                if (currentfuel >= 1 && !throttleup && engineon && !hasbonuscharge) { currentfuel = currentfuel - 1; return; }
                if (currentfuel >= 1 && throttleup && engineon && !hasbonuscharge) { currentfuel = currentfuel - sprintcost; return; }
                if (currentfuel <= 9999 && !hasbonuscharge) currentfuel = currentfuel + baserechargerate;
                if (currentfuel <= 9999 && hasbonuscharge) currentfuel = currentfuel + bonusrechargerate;
            }

            public void CopterInput(InputState input, BasePlayer player)
            {
                if (input == null || player == null) return;
                if (input.WasJustPressed(BUTTON.FORWARD)) moveforward = true;
                if (input.WasJustReleased(BUTTON.FORWARD)) moveforward = false;
                if (input.WasJustPressed(BUTTON.BACKWARD)) movebackward = true;
                if (input.WasJustReleased(BUTTON.BACKWARD)) movebackward = false;
                if (input.WasJustPressed(BUTTON.RIGHT)) rotright = true;
                if (input.WasJustReleased(BUTTON.RIGHT)) rotright = false;
                if (input.WasJustPressed(BUTTON.LEFT)) rotleft = true;
                if (input.WasJustReleased(BUTTON.LEFT)) rotleft = false;
                if (input.IsDown(BUTTON.SPRINT)) throttleup = true;
                if (input.WasJustReleased(BUTTON.SPRINT)) throttleup = false;
                if (input.WasJustPressed(BUTTON.JUMP)) moveup = true;
                if (input.WasJustReleased(BUTTON.JUMP)) moveup = false;
                if (input.WasJustPressed(BUTTON.DUCK)) movedown = true;
                if (input.WasJustReleased(BUTTON.DUCK)) movedown = false;
                if (!engineon) return;
                if (!enablebombs) return;
                if (input.WasJustPressed(BUTTON.RELOAD)) FindMoreDaBombs(player);
                if (input.WasJustPressed(BUTTON.FIRE_THIRD)) UseDaBombs(player);
            }

            public void UseDaBombs(BasePlayer player)
            {
                if (!enablebombs) return;
                if (dabomb == null) { instance.SendReply(player, "You do not have DA BOMB to drop !!!!"); return; }
                if (dabomb != null)
                {
                    dabomb.Invoke("KillMessage", 0.1f);
                    dabomb.transform.hasChanged = true;
                    dabomb.SendNetworkUpdateImmediate();
                    instance.SendReply(player, "You have dropped DA BOMD !!!!");
                    entity.gameObject.AddComponent<DaBomb>();
                }
                return;
            }

            public void ReloadDaBombs(BasePlayer player = null)
            {
                if (!enablebombs) return;
                if (dabomb == null)
                {
                    dabomb = GameManager.server.CreateEntity(prefabdabomb, entity.transform.position, Quaternion.identity, false);
                    dabomb.enableSaving = false;
                    dabomb?.Spawn();
                    dabomb.SetParent(entity);
                    dabomb.transform.localEulerAngles = new Vector3(90, 0, 0);
                    dabomb.transform.localPosition = new Vector3(0f, 0.5f, -2.7f);
                    dabomb.transform.hasChanged = true;
                    dabomb.SendNetworkUpdateImmediate();
                    hasdabomb = true;
                }
                return;
            }

            public void FindMoreDaBombs(BasePlayer player = null)
            {
                if (!enablebombs) return;
                List<BaseEntity> barrellist = new List<BaseEntity>();
                Vis.Entities<BaseEntity>(entity.transform.position, MinAltitude + 5f, barrellist);
                foreach (BaseEntity barrel in barrellist)
                {
                    if (barrel.name.Contains("barrel"))
                    {
                        if (dabomb != null) return;
                        barrel.Invoke("KillMessage", 0.1f);
                        ReloadDaBombs(player);
                        return;
                    }
                }
                instance.SendReply(player, "Unable to locate DA BOMB !!");
            }

            private void FixedUpdate()
            {
                FuelCheck();
                if (engineon)
                {
                    if (!GetPilot()) islanding = true;
                    var currentspeed = normalspeed;
                    var throttlespeed = 30;
                    if (throttleup) { throttlespeed = 60; currentspeed = sprintspeed; }
                    barcenter.transform.eulerAngles += new Vector3(0, throttlespeed, 0);
                    count = count + 1;
                    if (count == 3)
                    {
                        Effect.server.Run("assets/bundled/prefabs/fx/player/swing_weapon.prefab", this.transform.position + new Vector3(0f, 50f, 0f));
                    }
                    if (count == 6 && throttleup) Effect.server.Run("assets/bundled/prefabs/fx/player/swing_weapon.prefab", this.transform.position + new Vector3(0f, 50f, 0f));
                    throttleup = false;
                    if (count >= 6) count = 0;

                    if (!islanding && Physics.Raycast(new Ray(entity.transform.position + Vector3.down, Vector3.down), minaltitude, layerMask))
                    {
                        entity.transform.localPosition += transform.up * minaltitude * Time.deltaTime;
                        ServerMgr.Instance.StartCoroutine(RefreshCopter());
                        return;
                    }

                    if (islanding || currentfuel <= 0)
                    {
                        islanding = true;
                        var hasnet = entity.GetComponent<CopterNet>() ?? null;
                        if (hasnet != null) GameObject.Destroy(hasnet);
                        entity.transform.localPosition += (transform.up * -5f) * Time.deltaTime;
                        RaycastHit hit;
                        if (Physics.Raycast(new Ray(entity.transform.position, Vector3.down), out hit, 1f, layerMask))
                        {
                            islanding = false;
                            engineon = false;
                            if (pilotslist.Contains(player.userID))
                            {
                                pilotslist.Remove(player.userID);
                            }
                        }
                        ResetMovement();
                        ServerMgr.Instance.StartCoroutine(RefreshCopter());
                        return;
                    }

                    if (rotright) entity.transform.eulerAngles += new Vector3(0, 2, 0);
                    else if (rotleft) entity.transform.eulerAngles += new Vector3(0, -2, 0);

                    if (moveforward) entity.transform.localPosition += ((transform.forward * currentspeed) * Time.deltaTime);
                    else if (movebackward) entity.transform.localPosition = entity.transform.localPosition - ((transform.forward * currentspeed) * Time.deltaTime);

                    if (moveup) entity.transform.localPosition += ((transform.up * currentspeed) * Time.deltaTime);
                    else if (movedown) entity.transform.localPosition += ((transform.up * -currentspeed) * Time.deltaTime);

                    ServerMgr.Instance.StartCoroutine(RefreshCopter());
                }
            }

            private IEnumerator RefreshCopter()
            {
                entity.transform.hasChanged = true;
                for (int i = 0; i < entity.children.Count; i++)
                {
                    entity.children[i].transform.hasChanged = true;
                    entity.children[i].SendNetworkUpdateImmediate();
                    entity.children[i].UpdateNetworkGroup();
                }
                entity.SendNetworkUpdateImmediate();
                entity.UpdateNetworkGroup();
                yield return new WaitForEndOfFrame();
            }

            private void ResetMovement()
            {
                moveforward = false;
                movebackward = false;
                moveup = false;
                movedown = false;
                rotright = false;
                rotleft = false;
                throttleup = false;
            }

            public void OnDestroy()
            {
                if (loadplayer.ContainsKey(ownerid)) loadplayer[ownerid].coptercount = loadplayer[ownerid].coptercount - 1;
                if (entity != null) { entity.Invoke("KillMessage", 0.1f); }
            }
        }

        #endregion

        #region DaBomb Spawner

        private class DaBomb : MonoBehaviour
        {
            private BaseEntity entity;
            private GyroCopter copter;
            private Vector3 entitypos;
            private Quaternion entityrot;
            private BaseEntity dabomb;
            private bool onGround;
            private float damageradius;
            private float damageamount;

            private void Awake()
            {
                entity = GetComponentInParent<BaseEntity>();
                copter = entity.GetComponentInParent<GyroCopter>();
                entitypos = entity.transform.position;
                entityrot = Quaternion.identity;
                onGround = false;
                damageradius = bombdamageradius;
                damageamount = bombdamage;
                var dropfrom = copter.deck2.transform.position + new Vector3(0f, -3f, 0f);
                dabomb = GameManager.server.CreateEntity("assets/bundled/prefabs/radtown/oil_barrel.prefab", dropfrom, Quaternion.identity, true);
                dabomb.enableSaving = false;
                dabomb.Spawn();
                SpawnFireEffects();
            }

            private void ImpactDamage(Vector3 hitpos)
            {
                List<BaseCombatEntity> playerlist = new List<BaseCombatEntity>();
                Vis.Entities<BaseCombatEntity>(hitpos, damageradius, playerlist);
                foreach (BaseCombatEntity p in playerlist)
                {
                    if (!(p is BuildingPrivlidge))
                    {
                        p.Hurt(damageamount, Rust.DamageType.Explosion, null, false);
                    }
                }
            }

            private void ImpactFX(Vector3 pos)
            {
                Effect.server.Run("assets/bundled/prefabs/fx/weapons/landmine/landmine_explosion.prefab", pos);
                Effect.server.Run("assets/bundled/prefabs/napalm.prefab", pos);
                BaseEntity firebomb = GameManager.server.CreateEntity("assets/bundled/prefabs/oilfireballsmall.prefab", pos);
                firebomb?.Spawn();
            }

            private void SpawnFireEffects()
            {
                Effect.server.Run("assets/bundled/prefabs/fx/survey_explosion.prefab", dabomb.transform.position);
            }

            private void FixedUpdate()
            {
                if (onGround) return;
                var currentpos = dabomb.transform.position;
                if (Physics.Raycast(new Ray(currentpos + Vector3.down, Vector3.down), 1f, layerMask))
                {
                    ImpactDamage(currentpos);
                    ImpactFX(currentpos);
                    if (dabomb != null) { dabomb.Invoke("KillMessage", 0.1f); }
                    onGround = true;
                    GameObject.Destroy(this);
                }
                dabomb.transform.rotation = Quaternion.Slerp(dabomb.transform.rotation, dabomb.transform.rotation * Quaternion.Euler(new Vector3(15f, 15f, 15f)), Time.deltaTime * 3.0f);
                dabomb.transform.position = dabomb.transform.position + Vector3.down * (10f * Time.deltaTime);
                dabomb.transform.hasChanged = true;
                dabomb.SendNetworkUpdateImmediate();
            }

            private void OnDestroy()
            {
                if (dabomb != null) { dabomb.Invoke("KillMessage", 0.1f); }
                GameObject.Destroy(this);
            }
        }

        #endregion

        #region Copter Netting

        private class CopterNet : MonoBehaviour
        {
            public BaseEntity netting1;
            public BaseEntity netting2;
            public BaseEntity netting3;
            private BaseEntity entity;
            private GyroCopter copter;
            private Vector3 entitypos;
            private Quaternion entityrot;

            private void Awake()
            {
                entity = GetComponentInParent<BaseEntity>();
                copter = entity.GetComponentInParent<GyroCopter>();
                entitypos = entity.transform.position;
                entityrot = Quaternion.identity;
                string prefabnetting = "assets/prefabs/building/wall.frame.netting/wall.frame.netting.prefab";

                netting1 = GameManager.server.CreateEntity(prefabnetting, entitypos, entityrot, false);
                netting1?.Spawn();
                netting1.transform.localEulerAngles = new Vector3(0, 0, 0);
                netting1.transform.localPosition = new Vector3(0.9f, -2.9f, -1.4f);
                var netstab1 = netting1.GetComponent<StabilityEntity>();
                netstab1.grounded = true;
                netting1.enableSaving = false;
                netting1.SetParent(entity);

                netting2 = GameManager.server.CreateEntity(prefabnetting, entitypos, entityrot, false);
                netting2?.Spawn();
                netting2.transform.localEulerAngles = new Vector3(0, 0, 0);
                netting2.transform.localPosition = new Vector3(0.9f, -5.9f, -1.4f);
                var netstab2 = netting2.GetComponent<StabilityEntity>();
                netstab2.grounded = true;
                netting2.enableSaving = false;
                netting2.SetParent(entity);

                netting3 = GameManager.server.CreateEntity(prefabnetting, entitypos, entityrot, false);
                netting3?.Spawn();
                netting3.transform.localEulerAngles = new Vector3(0, 0, 0);
                netting3.transform.localPosition = new Vector3(0.9f, -8.9f, -1.4f);
                var netstab3 = netting3.GetComponent<StabilityEntity>();
                netstab3.grounded = true;
                netting3.enableSaving = false;
                netting3.SetParent(entity);
            }

            private void RefreshNetting()
            {
                if (netting1 != null) netting1.transform.hasChanged = true;
                if (netting1 != null) netting1.SendNetworkUpdateImmediate();
                if (netting1 != null) netting1.UpdateNetworkGroup();

                if (netting2 != null) netting2.transform.hasChanged = true;
                if (netting2 != null) netting2.SendNetworkUpdateImmediate();
                if (netting2 != null) netting2.UpdateNetworkGroup();

                if (netting3 != null) netting3.transform.hasChanged = true;
                if (netting3 != null) netting3.SendNetworkUpdateImmediate();
                if (netting3 != null) netting3.UpdateNetworkGroup();
            }

            private void FixedUpdate()
            {
                RefreshNetting();
            }

            private void OnDestroy()
            {
                if (netting3 != null) { netting3.Invoke("KillMessage", 0.1f); }
                if (netting2 != null) { netting2.Invoke("KillMessage", 0.1f); };
                if (netting1 != null) { netting1.Invoke("KillMessage", 0.1f); }
                GameObject.Destroy(this);
            }
        }

        #endregion

        #region FuelControl and Fuel Cui

        private class FuelControl : MonoBehaviour
        {
            private BasePlayer player;
            private GyroCopter copter;
            public string anchormaxstr;
            public string colorstr;
            private Vector3 playerpos;
            private Gyrocopter instance;
            private bool ischarging;
            private int count;
            private float rechargerange;
            private int rechargerate;

            private void Awake()
            {
                instance = new Gyrocopter();
                player = GetComponentInParent<BasePlayer>() ?? null;
                copter = player.GetMounted().GetComponentInParent<GyroCopter>() ?? null;
                playerpos = player.transform.position;
                rechargerange = RechargeRange;
                rechargerate = BonusRechargeRate;

                ischarging = false;
                count = 0;
            }

            private void Recharge()
            {
                var hits = Physics.OverlapSphere(copter.transform.position, rechargerange);
                foreach (var hit in hits)
                {
                    if (hit.name.Contains("substation"))
                    {
                        ischarging = true;
                        ChargingFX();
                        RechargeIndicator(player);
                        copter.hasbonuscharge = true;
                        return;
                    }
                }
                DestroyChargeCui(player);
                ischarging = false;
                copter.hasbonuscharge = false;
            }

            private void ChargingFX()
            {
                if (count == 15)
                {
                    Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.shock.prefab", playerpos + Vector3.down);
                    count = 0;
                    return;
                }
                count = count + 1;
            }

            private void FixedUpdate()
            {
                var copterfuel = copter.currentfuel;
                playerpos = player.transform.position;
                if (copterfuel >= 10000) copterfuel = 10000;
                if (copterfuel <= 0) copterfuel = 0;
                fuelIndicator(player, copterfuel);
                Recharge();
            }

            public void RechargeIndicator(BasePlayer player)
            {
                DestroyChargeCui(player);
                if (ischarging == false) return;
                var chargeindicator = new CuiElementContainer();
                chargeindicator.Add(new CuiButton
                {
                    Button = { Command = $"", Color = "1.0 1.0 0.0 0.8" },
                    RectTransform = { AnchorMin = "0.47 0.155", AnchorMax = "0.53 0.175" },
                    Text = { Text = ("CHARGING"), FontSize = 14, Color = "0.0 0.0 0.0 1.0", Align = TextAnchor.MiddleCenter }
                }, "Overall", "recharge");
                CuiHelper.AddUi(player, chargeindicator);
            }

            public void fuelIndicator(BasePlayer player, int fuel)
            {
                DestroyCui(player);
                var displayfuel = fuel;
                var fuelstr = displayfuel.ToString();
                var colorstrred = "0.6 0.1 0.1 0.8";
                var colorstryellow = "0.8 0.8 0.0 0.8";
                var colorstrgreen = "0.0 0.6 0.1 0.8";
                colorstr = colorstrgreen;
                if (fuel >= 9001) anchormaxstr = "0.60 0.145";
                if (fuel >= 8001 && fuel <= 9000) anchormaxstr = "0.58 0.145";
                if (fuel >= 7001 && fuel <= 8000) anchormaxstr = "0.56 0.145";
                if (fuel >= 6001 && fuel <= 7000) anchormaxstr = "0.54 0.145";
                if (fuel >= 5001 && fuel <= 6000) anchormaxstr = "0.52 0.145";
                if (fuel >= 4001 && fuel <= 5000) anchormaxstr = "0.50 0.145";
                if (fuel >= 3001 && fuel <= 4000) { anchormaxstr = "0.48 0.145"; colorstr = colorstryellow; }
                if (fuel >= 2001 && fuel <= 3000) { anchormaxstr = "0.46 0.145"; colorstr = colorstryellow; }
                if (fuel >= 1001 && fuel <= 2000) { anchormaxstr = "0.44 0.145"; colorstr = colorstrred; }
                if (fuel <= 1000) { anchormaxstr = "0.42 0.145"; colorstr = colorstrred; }
                var fuelindicator = new CuiElementContainer();
                fuelindicator.Add(new CuiButton
                {
                    Button = { Command = $"", Color = "0.0 0.0 0.0 0.3" },
                    RectTransform = { AnchorMin = "0.40 0.12", AnchorMax = "0.60 0.15" },
                    Text = { Text = (""), FontSize = 18, Color = "1.0 1.0 1.0 1.0", Align = TextAnchor.MiddleLeft }
                }, "Overall", "fuelGuia");

                fuelindicator.Add(new CuiButton
                {
                    Button = { Command = $"", Color = colorstr },
                    RectTransform = { AnchorMin = "0.40 0.125", AnchorMax = anchormaxstr },
                    Text = { Text = (fuelstr), FontSize = 14, Color = "1.0 1.0 1.0 0.6", Align = TextAnchor.MiddleRight }
                }, "Overall", "fuelGui");

                CuiHelper.AddUi(player, fuelindicator);
            }

            private void DestroyChargeCui(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, "recharge");
            }

            private void DestroyCui(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, "fuelGui");
                CuiHelper.DestroyUi(player, "fuelGuia");
            }

            public void OnDestroy()
            {
                DestroyChargeCui(player);
                DestroyCui(player);
                Destroy(this);
            }
        }

        #endregion
    }
}

// --- End of file: Gyrocopter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/join-message-plus ---
// --- Original File Path: J/JoinMessagePlus/JoinMessagePlus.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Join Message Plus", "MisterPixie", "1.0.54")]
    [Description("Advanced join/leave messages")]
    class JoinMessagePlus : CovalencePlugin
    {
        private System.Random _rnd = new System.Random();
        private const string _permission = "joinmessageplus.allow";

        #region Data
        private List<string> _joinMessagePlusData = new List<string>();

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("JoinMessagePlusData", _joinMessagePlusData);
        }
        #endregion

        #region Lang
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoCommandAccess"] = "You don't have access to this command.",
                ["ToggleOn"] = "You have turned your Join/Leave Messages [#50D703]ON![/#].",
                ["ToggleOff"] = "You have turned your Join/Leave Messages [#D60000]OFF![/#]."
            }, this);
        }
        #endregion

        #region Hooks
        private void Init()
        {
            LoadVariables();

            _joinMessagePlusData = Interface.Oxide.DataFileSystem.ReadObject<List<string>>(Name);

            permission.RegisterPermission(_permission, this);

            if (!configData.EnableJoinMsg)
                Unsubscribe("OnUserConnected");

            if (!configData.EnableLeaveMsg)
                Unsubscribe("OnUserDisconnected");

            AddCovalenceCommand(configData.VIPToggleCommand, "VIPToggle");
                
        }

        private void OnUserConnected(IPlayer player)
        {

            if (configData.IsAdminJoin && player.IsAdmin)
            {
                return;
            }

            if (!_joinMessagePlusData.Contains(player.Id))
            {
                int randomQuote = _rnd.Next(configData.JoinMessages.Count);
                string randomString = configData.JoinMessages[randomQuote];

                server.Broadcast(string.Format(randomString, player.Name));
            }

        }

        private void OnUserDisconnected(IPlayer player)
        {

            if (configData.IsAdminLeave && player.IsAdmin)
            {
                return;
            }

            if (!_joinMessagePlusData.Contains(player.Id))
            {
                int randomQuote = _rnd.Next(configData.LeaveMessages.Count);
                string randomString = configData.LeaveMessages[randomQuote];

                server.Broadcast(string.Format(randomString, player.Name));
            }

        }

        private void Unload()
        {
            SaveData();
        }

        private void OnServerSave()
        {
            SaveData();
        }
        #endregion

        #region Methods
        private void VIPToggle(IPlayer player, string command, string[] arg)
        {
            if (player == null || player.IsServer)
            {
                return;
            }

            if (configData.UseVIPTogglePerm == true && !permission.UserHasPermission(player.Id, _permission))
            {
                player.Reply(Lang("NoCommandAccess", player.Id));
                return;
            }

            if (!_joinMessagePlusData.Contains(player.Id))
            {
                _joinMessagePlusData.Add(player.Id);
                player.Reply(Lang("ToggleOff", player.Id));
            }
            else
            {
                _joinMessagePlusData.Remove(player.Id);
                player.Reply(Lang("ToggleOn", player.Id));
            }
        }
        #endregion

        #region Config
        private ConfigData configData;
        private class ConfigData
        {
            public bool EnableJoinMsg;
            public bool EnableLeaveMsg;
            public bool IsAdminJoin;
            public bool IsAdminLeave;
            public bool UseVIPTogglePerm;
            public string VIPToggleCommand;
            public List<string> JoinMessages;
            public List<string> LeaveMessages;
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                EnableJoinMsg = false,
                EnableLeaveMsg = false,
                IsAdminJoin = false,
                IsAdminLeave = false,
                UseVIPTogglePerm = false,
                VIPToggleCommand = "joinmessage",
                JoinMessages = new List<string>
                {
                    "{0} Joined the game!!!",
                    "Look out... its <color=red>{0}</color>",
                    "{0} Has joined the server!"
                },
                LeaveMessages = new List<string>
                {
                    "{0} Left the game!!!",
                    "It's sad to see you go <color=red>{0}</color>"
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}

// --- End of file: JoinMessagePlus.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/jpipes ---
// --- Original File Path: J/JPipes/JPipes.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using Object = UnityEngine.Object;
using Random = System.Random;

namespace Oxide.Plugins {

	[Info("JPipes", "TheGreatJ", "0.6.10")]
	[Description("Pipes that automatically transfer items between boxes, furnaces, turrets, quarries, etc.")]
	class JPipes : RustPlugin {

		[PluginReference]
		private Plugin FurnaceSplitter;

		private Dictionary<ulong, UserInfo> users;

		private Dictionary<ulong, jPipe> regpipes =
			new Dictionary<ulong, jPipe>();

		private Dictionary<ulong, jSyncBox> regsyncboxes =
			new Dictionary<ulong, jSyncBox>();

		private PipeSaveData storedData;

		private static Color blue = new Color(0.2f, 0.4f, 1);
		private static Color orange = new Color(1f, 0.4f, 0.2f);
		private static string bluestring = "0.5 0.75 1.0 1.0";
		private static string orangestring = "1.0 0.75 0.5 1.0";

		#region Hooks

		void Init() {

			lang.RegisterMessages(new Dictionary<string, string> {
				["ErrorFindFirst"] = "Failed to find first StorageContainer",
				["ErrorFindSecond"] = "Failed to find second StorageContainer",
				["ErrorAlreadyConnected"] =
					"Error: StorageContainers are already connected",
				["ErrorNotItemCont"] =
					"Error: Second Container does not accept Items",
				["ErrorNotLiquidCont"] =
					"Error: Second Container does not accept Liquid",
				["ErrorTooFar"] = "Error: StorageContainers are too far apart",
				["ErrorTooClose"] =
					"Error: StorageContainers are too close together",
				["ErrorPrivilegeAttach"] =
					"Error: You do not have building privilege to attach a pipe to this StorageContainer",
				["ErrorPrivilegeModify"] =
					"Error: You do not have building privilege to modify this pipe",
				["ErrorCmdPerm"] =
					"You don't have permission to use this command.",
				["ErrorPipeLimitReached"] =
					"Error: You have reached your pipe limit of {0}",
				["ErrorUpgradeLimit"] =
					"Error: You can only upgrade your pipes up to {0} level",

				["SelectFirst"] =
					"Use the Hammer to select the First Container",
				["SelectSecond"] =
					"Use the Hammer to select the Second Container",

				//["SelectCancel"] = "Canceled Pipe Creation",
				["SelectSubtextBind"] = "Press [{0}] to Cancel",
				["SelectSubtextCmd"] = "Do /{0} to Cancel",
				["PipeCreated"] = "Pipe has been created!",

				["CopyingTextFirst"] =
					"Use the Hammer to select the jPipe to copy from",
				["CopyingText"] = "Use the Hammer to Paste",
				["CopyingSubtext"] = "Do /{0} c to Exit",

				["RemovingText"] = "Use the Hammer to Remove Pipes",
				["RemovingSubtext"] = "Do /{0} r to Exit",

				["MenuTitle"] = "<color=#80c5ff>j</color>Pipe",
				["MenuTurnOn"] = "Turn On",
				["MenuTurnOff"] = "Turn Off",
				["MenuAutoStarter"] = "Auto Starter",
				["MenuChangeDirection"] = "Change Direction",
				["MenuSingleStack"] = "Single Stack",
				["MenuMultiStack"] = "Multi Stack",
				["MenuItemFilter"] = "Item Filter",
				["MenuInfo"] =
					"Owner  <color=#80c5ff>{0}</color>\nFlowrate  <color=#80c5ff>{1}/sec</color>\nLength  <color=#80c5ff>{2}</color>",

				["HelpCmdTitle"] =
					"<size=28><color=#80c5ff>j</color>Pipes</size> <size=10>by TheGreatJ</size>",
				["HelpCmdCommands"] =
					"<size=18>Commands</size>\n<color=#80c5ff>/{0} </color> start or stop placing a pipe\n<color=#80c5ff>/{0} c /{0}copy </color>or<color=#80c5ff> /{0} copy </color> copy pipe settings from one pipe to another\n <color=#80c5ff>/{0} r /{0}remove </color>or<color=#80c5ff> /{0} remove </color> remove pipe with hammer\n <color=#80c5ff>/{0} s /{0}stats </color>or<color=#80c5ff> /{0} stats </color> pipe status with how many pipes you are using\n <color=#80c5ff>/{0} h /{0}help </color>or<color=#80c5ff> /{0} help </color> JPipes in-game help",
				["HelpCmdMenu"] =
					"<size=18>Pipe Menu</size><size=12> - hit pipe with hammer to open</size>\n<color=#80c5ff>Turn On / Turn Off</color> toggle item/liquid transfer\n<color=#80c5ff>Auto Starter</color> after a pipe sends an item to a furnace, recycler, refinery, mining quarry, or pump jack, it will attempt to start it\n<color=#80c5ff>Change Direction</color> makes the items go the other direction through the pipe\n<color=#80c5ff>Multi Stack / Single Stack</color> Multi Stack mode allows the pipe to create multiple stacks of the same item. Single Stack mode prevents the pipe from creating more than one stack of an item. Single Stack mode is mostly just for fueling furnaces to leave room for other items.\n<color=#80c5ff>Item Filter</color> when items are in the filter, only those items will be transferred through the pipe. When the filter is empty, all items will be transferred.",
				["HelpCmdUpgrade"] =
					"<size=18>Upgrading Pipes</size>\nUse a Hammer and upgrade the pipe just like any other building\nEach upgrade level increases the pipe's flow rate and Item Filter size.",
				["HelpBindTip"] =
					"JPipes Tip:\nYou can bind the /{0} command to a hotkey by putting\n\"bind {1} jpipes.create\" into the F1 console",

				["StatsCmd"] =
					"<size=20><color=#80c5ff>j</color>Pipes Stats</size>\nYou have {0} jpipes currently in use.",
				["StatsCmdLimit"] =
					"<size=20><color=#80c5ff>j</color>Pipes Stats</size>\nYou have {0} of {1} jpipes currently in use."
			}, this);

			LoadConfig();
			LoadCommands();

			users = new Dictionary<ulong, UserInfo>();
			storedData = new PipeSaveData();
		}

		void OnServerInitialized() {
			LoadData(ref storedData);

			//PipeLazyLoad();

			foreach (var p in storedData.p) {
				jPipe newpipe = new jPipe();
				if (newpipe.init(this, p.Key, p.Value, RemovePipe, MoveItem))
					RegisterPipe(newpipe);
				else
					PrintWarning(newpipe.initerr);
			}

			LoadEnd();
		}

		private int loadindex = 0;

		void PipeLazyLoad() {
			var p = storedData.p.ElementAt(loadindex);
			jPipe newpipe = new jPipe();
			if (newpipe.init(this, p.Key, p.Value, RemovePipe, MoveItem))
				RegisterPipe(newpipe);
			else
				PrintWarning(newpipe.initerr);

			loadindex += 1;
			if (loadindex >= storedData.p.Keys.Count) {
				LoadEnd();
				return;
			}

			NextFrame(PipeLazyLoad);
		}

		void LoadEnd() {
			Puts($"{regpipes.Count} Pipes Loaded");

			//Puts($"{regsyncboxes.Count} SyncBoxes Loaded");
		}

		private void Loaded() {
			permission.RegisterPermission("jpipes.use", this);
			permission.RegisterPermission("jpipes.admin", this);
		}

		void Unload() {
			foreach (var player in BasePlayer.activePlayerList) {
				UserInfo userinfo;
				if (!users.TryGetValue(player.userID, out userinfo))
					continue;
				if (!string.IsNullOrEmpty(userinfo.menu))
					CuiHelper.DestroyUi(player, userinfo.menu);
				if (!string.IsNullOrEmpty(userinfo.overlay))
					CuiHelper.DestroyUi(player, userinfo.overlay);
			}

			SavePipes();
			UnloadPipes();

			//foreach (jPipeGroundWatch go in UnityEngine.Object.FindObjectsOfType<jPipeGroundWatch>()) {
			//	GameObject.Destroy(go);
			//}

		}

		void OnNewSave(string filename) {
			regpipes.Clear();
			regsyncboxes.Clear();
			SavePipes();
		}

		void OnServerSave() => SavePipes();


		void OnPlayerConnected(BasePlayer player) {

			GetUserInfo(player);

			player.SendConsoleCommand(
				$"echo {string.Format(lang.GetMessage("HelpBindTip", this, player.UserIDString), pipecommandprefix, pipehotkey)}");
		}

		void OnPlayerDisconnected(BasePlayer player) {
			users.Remove(player.userID);
		}

		void OnHammerHit(BasePlayer player, HitInfo hit) {

			//Puts(hit.HitEntity.ToString());
			//ListComponentsDebug(player, hit.HitEntity);
			//ListComponentsDebug(player, player);

			UserInfo userinfo = GetUserInfo(player);

			if (hit.HitEntity.GetComponent<StorageContainer>() != null) {
				// if we hit a StorageContainer

				if (userinfo.state == UserState.placing &&
				    userinfo.placeend == null &&
				    checkcontwhitelist(hit.HitEntity)) {
					if (checkcontprivlage(hit.HitEntity, player)) {
						// select first
						if (userinfo.placestart == null) {
							userinfo.placestart = hit.HitEntity;

							ShowOverlayText(player,
								lang.GetMessage("SelectSecond", this,
									player.UserIDString),
								string.Format(
									lang.GetMessage(
										userinfo.isUsingBind
											? "SelectSubtextBind"
											: "SelectSubtextCmd", this,
										player.UserIDString),
									userinfo.isUsingBind
										? pipehotkey.ToUpper()
										: pipecommandprefix));
						}
						else if (userinfo.placestart != null) {
							// select second
							userinfo.placeend = hit.HitEntity;
							NewPipe(player, userinfo);
						}
					}
					else {
						ShowOverlayText(player,
							lang.GetMessage("ErrorPrivilegeAttach", this,
								player.UserIDString));
						timer.Once(2f,
							() => {
								ShowOverlayText(player,
									lang.GetMessage(
										(userinfo.placestart == null)
											? "SelectFirst"
											: "SelectSecond", this,
										player.UserIDString),
									string.Format(
										lang.GetMessage(
											userinfo.isUsingBind
												? "SelectSubtextBind"
												: "SelectSubtextCmd", this,
											player.UserIDString),
										userinfo.isUsingBind
											? pipehotkey.ToUpper()
											: pipecommandprefix));
							});
					}
				}
			}
			else {
				jPipeSegChild s = hit.HitEntity.GetComponent<jPipeSegChild>();
				if (s != null) {
					// if we hit a pipe
					if (!commandperm(player))
						return;
					if (checkbuildingprivlage(player)) {
						if (userinfo.state == UserState.copying) {
							// if user is copying
							if (userinfo.clipboard == null) {

								userinfo.clipboard = new jPipeData();
								userinfo.clipboard.fromPipe(s.pipe);

								ShowOverlayText(player,
									lang.GetMessage("CopyingText", this,
										player.UserIDString),
									string.Format(
										lang.GetMessage("CopyingSubtext", this,
											player.UserIDString),
										pipecommandprefix));

							}
							else {
								userinfo.clipboard.s = s.pipe.sourcecont.net.ID;
								userinfo.clipboard.d = s.pipe.destcont.net.ID;

								s.pipe.Destroy();

								jPipe newpipe = new jPipe();

								// initalize pipe
								if (newpipe.init(this, pipeidgen(),
									userinfo.clipboard, RemovePipe, MoveItem)) {
									// pipe was created so register it
									RegisterPipe(newpipe);
								}
								else {
									// pipe error
									ShowOverlayText(player,
										lang.GetMessage(newpipe.initerr, this,
											player.UserIDString));
									newpipe = null;
								}
							}

						}
						else if (userinfo.state == UserState.removing) {
							// if user is removing

							s.pipe.Destroy();

						}
						else if (userinfo.state == UserState.none) {
							// if user is not in a command
							s.pipe.OpenMenu(player, userinfo);
						}
					}
					else {
						ShowOverlayText(player,
							lang.GetMessage("ErrorPrivilegeModify", this,
								player.UserIDString));
						HideOverlayText(player, 2f);
					}
				}
			}
		}

		void OnStructureDemolish(BaseCombatEntity entity, BasePlayer player) {
			jPipeSegChild p = entity.GetComponent<jPipeSegChild>();
			if (p != null && p.pipe != null)
				p.pipe.OnSegmentKilled();
		}

		void OnEntityDeath(BaseCombatEntity entity, HitInfo info) {
			if (entity is BuildingBlock) {
				jPipeSegChild p = entity.GetComponent<jPipeSegChild>();
				if (p != null && p.pipe != null)
					p.pipe.OnSegmentKilled();
			}
		}

		void OnEntityKill(BaseNetworkable entity) {
			if (entity is BuildingBlock) {
				jPipeSegChild p = entity.GetComponent<jPipeSegChild>();
				if (p != null && p.pipe != null)
					p.pipe.OnSegmentKilled();
			}
		}

		object OnEntityGroundMissing(BaseEntity entity) {

			foreach (var c in entity.GetComponents<Component>()) {
				if (c.GetType().ToString() ==
				    "Oxide.Plugins.JPipes.jPipeGroundWatch") {
					return true;
					break;
				}
			}

			//jPipeGroundWatch gw = entity?.gameObject?.GetComponent<jPipeGroundWatch>();
			//if (gw != null) {
			//	return true;
			//	gw.connectedpipes.Remove(null); // remove any null references
			//	if (gw.connectedpipes.Count > 0) { // if pipes are connected
			//		return true; // don't destroy container
			//	} else {
			//		GameObject.Destroy(gw);
			//		return null;
			//	}
			//}
			return null;
		}

		bool? OnStructureUpgrade(BaseCombatEntity entity,
			BasePlayer player,
			BuildingGrade.Enum grade) {
			jPipeSegChild p = entity?.GetComponent<jPipeSegChild>();
			if (p != null && p.pipe != null && player != null) {
				if (!commandperm(player))
					return false;
				int upgradelimit = getplayerupgradelimit(player);
				if (upgradelimit != -1 && upgradelimit < (int) grade) {
					//Puts(upgradelimit.ToString());
					//Puts(((int) grade).ToString());

					ShowOverlayText(player,
						string.Format(
							lang.GetMessage("ErrorUpgradeLimit", this,
								player.UserIDString),
							(BuildingGrade.Enum) upgradelimit));
					HideOverlayText(player, 2f);

					return false;
				}

				p.pipe.Upgrade(grade);
			}

			return null;
		}

		void OnStructureRepair(BaseCombatEntity entity, BasePlayer player) {
			if (GetUserInfo(player).state != UserState.none)
				return;

			jPipeSegChild p = entity.GetComponent<jPipeSegChild>();
			if (p != null && p.pipe != null)
				p.pipe.SetHealth(entity.GetComponent<BuildingBlock>().health);
		}

		// pipe damage handling
		bool? OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo) {

			if (entity != null && hitInfo != null) {

				jPipeSegChild p = entity.GetComponent<jPipeSegChild>();
				if (p != null && p.pipe != null) {

					if (nodecay)
						hitInfo.damageTypes.Scale(DamageType.Decay,
							0f); // no decay damage
					float damage = hitInfo.damageTypes.Total();
					if (damage > 0) {

						BuildingBlock block =
							entity.GetComponent<BuildingBlock>();
						if (block != null && p.pipe != null) {
							float newhealth = block.health - damage;
							if (newhealth >= 1f)
								p.pipe.SetHealth(newhealth);
							else
								p.pipe.OnSegmentKilled();
						}

					}

					return true;
				}
			}

			return null;
		}


		// disable xmas lights pickup
		bool? CanPickupEntity(BaseCombatEntity entity, BasePlayer player) {
			if (entity.GetComponent<jPipeSegChildLights>() != null)
				return false;
			return null;
		}


		// When item is added to filter
		ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer container,
			Item item) {

			if (container == null || item == null ||
			    container.entityOwner == null ||
			    container.entityOwner.GetComponent<jPipeFilterStash>() == null)
				return null;

			if (container.itemList.Exists(x => x.info == item.info))
				return ItemContainer.CanAcceptResult.CannotAccept;

			jPipeFilterStash f =
				container.entityOwner.GetComponent<jPipeFilterStash>();

			if (f.loading)
				return null;

			if (f.itemadded) {
				f.itemadded = false;
				return null;
			}

			f.itemadded = true;
			f.UpdateFilter(item);
			ItemManager.Create(item.info).MoveToContainer(container);

			return ItemContainer.CanAcceptResult.CannotAccept;
		}

		bool? CanVendingAcceptItem(VendingMachine container, Item item) {
			//Puts(item.ToString());

			BasePlayer ownerPlayer = item.GetOwnerPlayer();
			if (item.parent == null ||
			    container.inventory.itemList.Contains(item))
				return true;
			if ((Object) ownerPlayer == (Object) null)
				return true;
			return container.CanPlayerAdmin(ownerPlayer);
		}

		// when item is removed from filter it is destroyed
		void OnItemRemovedFromContainer(ItemContainer container, Item item) {
			if (container == null || item == null ||
			    container.entityOwner == null ||
			    container.entityOwner.GetComponent<jPipeFilterStash>() == null)
				return;
			item.Remove();
		}

		// when item is taken from filter, it can't be stacked
		bool? CanStackItem(Item targetItem, Item item) {
			if (item.parent == null || item.parent.entityOwner == null ||
			    item.parent.entityOwner.GetComponent<jPipeFilterStash>() ==
			    null)
				return null;
			return false;
		}

		#endregion

		#region Commands

		private bool commandperm(BasePlayer player) {
			if (!(permission.UserHasPermission(player.UserIDString,
				      "jpipes.use") ||
			      permission.UserHasPermission(player.UserIDString,
				      "jpipes.admin"))) {
				ShowOverlayText(player,
					lang.GetMessage("ErrorCmdPerm", this, player.UserIDString));
				HideOverlayText(player, 2f);
				return false;
			}

			return true;
		}

		private void LoadCommands() {
			AddCovalenceCommand(pipecommandprefix, "pipemainchat");
			AddCovalenceCommand($"{pipecommandprefix}help", "cmdpipehelp");
			AddCovalenceCommand($"{pipecommandprefix}copy", "cmdpipecopy");
			AddCovalenceCommand($"{pipecommandprefix}remove", "cmdpiperemove");
			AddCovalenceCommand($"{pipecommandprefix}stats", "cmdpipestats");

			//AddCovalenceCommand($"{pipecommandprefix}link", "cmdpipelink");
		}

		private void
			cmdpipehelp(IPlayer cmdplayer, string cmd, string[] args) =>
			pipehelp(BasePlayer.Find(cmdplayer.Id), cmd, args);

		private void
			cmdpipecopy(IPlayer cmdplayer, string cmd, string[] args) =>
			pipecopy(BasePlayer.Find(cmdplayer.Id), cmd, args);

		private void
			cmdpiperemove(IPlayer cmdplayer, string cmd, string[] args) =>
			piperemove(BasePlayer.Find(cmdplayer.Id), cmd, args);

		private void
			cmdpipestats(IPlayer cmdplayer, string cmd, string[] args) =>
			pipestats(BasePlayer.Find(cmdplayer.Id), cmd, args);

		private void
			cmdpipelink(IPlayer cmdplayer, string cmd, string[] args) =>
			pipelink(BasePlayer.Find(cmdplayer.Id), cmd, args);

		// [ChatCommand("p")]
		private void pipemainchat(IPlayer cmdplayer,
			string cmd,
			string[] args) {
			BasePlayer player = BasePlayer.Find(cmdplayer.Id);

			if (!commandperm(player))
				return;

			if (args.Length > 0) {
				switch (args[0]) {
					case "h":
					case "help":
						pipehelp(player, cmd, args);
						break;
					case "c":
					case "copy":
						pipecopy(player, cmd, args);
						break;
					case "r":
					case "remove":
						piperemove(player, cmd, args);
						break;
					case "s":
					case "stats":
						pipestats(player, cmd, args);
						break;
					case "l":
					case "link":
						pipelink(player, cmd, args);
						break;
				}
			}
			else {
				startplacingpipe(player, false);
			}
		}

		//[ChatCommand("phelp")]
		private void pipehelp(BasePlayer player, string cmd, string[] args) {
			if (!commandperm(player))
				return;
			PrintToChat(player,
				lang.GetMessage("HelpCmdTitle", this, player.UserIDString));
			PrintToChat(player,
				string.Format(
					lang.GetMessage("HelpCmdCommands", this,
						player.UserIDString), pipecommandprefix));
			PrintToChat(player,
				lang.GetMessage("HelpCmdMenu", this, player.UserIDString));
			PrintToChat(player,
				lang.GetMessage("HelpCmdUpgrade", this, player.UserIDString));
		}

		//[ChatCommand("pcopy")]
		private void pipecopy(BasePlayer player, string cmd, string[] args) {
			if (!commandperm(player))
				return;
			UserInfo userinfo = GetUserInfo(player);

			userinfo.state = userinfo.state == UserState.copying
				? UserState.none
				: UserState.copying;
			userinfo.placeend = null;
			userinfo.placestart = null;

			if (userinfo.state == UserState.copying) {
				ShowOverlayText(player,
					lang.GetMessage("CopyingTextFirst", this,
						player.UserIDString),
					string.Format(
						lang.GetMessage("CopyingSubtext", this,
							player.UserIDString), pipecommandprefix));
			}
			else {
				HideOverlayText(player);
				userinfo.clipboard = null;
			}

		}

		//[ChatCommand("premove")]
		private void piperemove(BasePlayer player, string cmd, string[] args) {
			if (!commandperm(player))
				return;
			UserInfo userinfo = GetUserInfo(player);

			userinfo.state = userinfo.state == UserState.removing
				? UserState.none
				: UserState.removing;
			userinfo.placeend = null;
			userinfo.placestart = null;
			userinfo.clipboard = null;

			if (userinfo.state == UserState.removing) {
				ShowOverlayText(player,
					lang.GetMessage("RemovingText", this, player.UserIDString),
					string.Format(
						lang.GetMessage("RemovingSubtext", this,
							player.UserIDString), pipecommandprefix));
			}
			else {
				HideOverlayText(player);
			}
		}

		//[ChatCommand("pstats")]
		private void pipestats(BasePlayer player, string cmd, string[] args) {
			if (!commandperm(player))
				return;
			UserInfo userinfo = GetUserInfo(player);
			int pipelimit = getplayerpipelimit(player);

			if (pipelimit == -1)
				PrintToChat(player,
					string.Format(
						lang.GetMessage("StatsCmd", this, player.UserIDString),
						userinfo.pipes.Count));
			else
				PrintToChat(player,
					string.Format(
						lang.GetMessage("StatsCmdLimit", this,
							player.UserIDString), userinfo.pipes.Count,
						pipelimit));
		}

		//[ChatCommand("plink")]
		private void pipelink(BasePlayer player, string cmd, string[] args) {
			if (!commandperm(player))
				return;
			startlinking(player, false);
		}

		[ConsoleCommand("jpipes.create")]
		private void pipecreate(ConsoleSystem.Arg arg) {
			BasePlayer p = arg.Player();
			if (!commandperm(p))
				return;
			startplacingpipe(p, true);
		}

		//[ConsoleCommand("jpipes.link")]
		//private void pipelink(ConsoleSystem.Arg arg) {
		//    BasePlayer p = arg.Player();
		//    if (!commandperm(p))
		//        return;
		//    startlinking(p, true);
		//}

		[ConsoleCommand("jpipes.openmenu")]
		private void pipeopenmenu(ConsoleSystem.Arg arg) {
			BasePlayer p = arg.Player();
			if (!commandperm(p))
				return;
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe)
			) {
				pipe.OpenMenu(p, GetUserInfo(p));
			}
		}

		[ConsoleCommand("jpipes.closemenu")]
		private void pipeclosemenu(ConsoleSystem.Arg arg) {
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe)
			) {
				BasePlayer p = arg.Player();
				pipe.CloseMenu(p, GetUserInfo(p));
			}
		}

		[ConsoleCommand("jpipes.closemenudestroy")]
		private void pipeclosemenudestroy(ConsoleSystem.Arg arg) {
			BasePlayer p = arg.Player();
			UserInfo userinfo = GetUserInfo(p);

			if (!string.IsNullOrEmpty(userinfo.menu))
				CuiHelper.DestroyUi(p, userinfo.menu);
			userinfo.isMenuOpen = false;
		}

		[ConsoleCommand("jpipes.refreshmenu")]
		private void piperefreshmenu(ConsoleSystem.Arg arg) {
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe)
			) {
				BasePlayer p = arg.Player();
				UserInfo userinfo = GetUserInfo(p);
				pipe.OpenMenu(p, userinfo);
			}
		}

		[ConsoleCommand("jpipes.changedir")]
		private void cmdpipechangedir(ConsoleSystem.Arg arg) {
			BasePlayer p = arg.Player();
			if (p == null)
				return;
			if (!commandperm(p))
				return;
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe)
			) {
				pipe.ChangeDirection();
			}
		}

		[ConsoleCommand("jpipes.openfilter")]
		private void cmdpipeopenfilter(ConsoleSystem.Arg arg) {
			BasePlayer p = arg.Player();
			if (p == null)
				return;
			if (!commandperm(p))
				return;
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe)
			) {
				UserInfo userinfo = GetUserInfo(p);
				pipe.OpenFilter(p);
				pipe.CloseMenu(p, userinfo);
			}
		}

		[ConsoleCommand("jpipes.turnon")]
		private void pipeturnon(ConsoleSystem.Arg arg) {
			BasePlayer p = arg.Player();
			if (!commandperm(p))
				return;
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe))
				pipe.mainlogic.pipeEnable(p);
		}

		[ConsoleCommand("jpipes.turnoff")]
		private void pipeturnoff(ConsoleSystem.Arg arg) {
			BasePlayer p = arg.Player();
			if (!commandperm(p))
				return;
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe))
				pipe.mainlogic.pipeDisable(p);
		}

		[ConsoleCommand("jpipes.autostarton")]
		private void pipeautostarton(ConsoleSystem.Arg arg) {
			if (!commandperm(arg.Player()))
				return;
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe))
				pipe.autostarter = true;
			pipe.RefreshMenu();
		}

		[ConsoleCommand("jpipes.autostartoff")]
		private void pipeautostartoff(ConsoleSystem.Arg arg) {
			if (!commandperm(arg.Player()))
				return;
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe))
				pipe.autostarter = false;
			pipe.RefreshMenu();
		}

		[ConsoleCommand("jpipes.stackon")]
		private void pipestackon(ConsoleSystem.Arg arg) {
			if (!commandperm(arg.Player()))
				return;
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe))
				pipe.singlestack = true;
			pipe.RefreshMenu();
		}

		[ConsoleCommand("jpipes.stackoff")]
		private void pipestackoff(ConsoleSystem.Arg arg) {
			if (!commandperm(arg.Player()))
				return;
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe))
				pipe.singlestack = false;
			pipe.RefreshMenu();
		}

		[ConsoleCommand("jpipes.fsenable")]
		private void pipeFSenable(ConsoleSystem.Arg arg) {
			if (!commandperm(arg.Player()))
				return;
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe))
				pipe.fsplit = true;
			pipe.RefreshMenu();
		}

		[ConsoleCommand("jpipes.fsdisable")]
		private void pipeFSdisable(ConsoleSystem.Arg arg) {
			if (!commandperm(arg.Player()))
				return;
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe))
				pipe.fsplit = false;
			pipe.RefreshMenu();
		}

		[ConsoleCommand("jpipes.fsstack")]
		private void pipeFSstack(ConsoleSystem.Arg arg) {
			if (!commandperm(arg.Player()))
				return;
			jPipe pipe;
			if (regpipes.TryGetValue((ulong) int.Parse(arg.Args[0]), out pipe))
				pipe.fsstacks = int.Parse(arg.Args[1]);
			pipe.RefreshMenu();
		}

		#endregion

		#region Classes

		// user data for chat commands
		private class UserInfo {
			public UserState state = UserState.none;
			public bool isUsingBind = false;
			public BaseEntity placestart;
			public BaseEntity placeend;

			public jPipeData clipboard;

			// menu stuff
			public bool isMenuOpen = false;
			public string menu;

			public string overlay;
			public string overlaytext;
			public string overlaysubtext;

			// pipes
			public Dictionary<ulong, jPipe> pipes =
				new Dictionary<ulong, jPipe>();
		}

		private UserInfo GetUserInfo(BasePlayer player) =>
			GetUserInfo(player.userID);

		private UserInfo GetUserInfo(ulong id) {
			UserInfo userinfo;
			if (!users.TryGetValue(id, out userinfo))
				users[id] = userinfo = new UserInfo();
			return userinfo;
		}

		private enum UserState {
			none,
			placing,
			copying,
			removing,
			linking
		};

		// main pipe class
		private class jPipe {

			public Action<ulong, bool> remover;
			public Action<Item, int, StorageContainer, int> moveitem;

			private JPipes pipeplugin;

			public ulong id;
			public string initerr = string.Empty;
			public string debugstring = string.Empty;

			public ulong ownerid;
			public string ownername;

			public bool isEnabled = true;
			public bool isWaterPipe = false;

			public BaseEntity mainparent;

			// parents of storage containers
			public BaseEntity source;
			public BaseEntity dest;

			public Vector3 sourcepos;
			public Vector3 endpos;

			public string sourceiconurl;
			public string endiconurl;

			// storage containers
			public StorageContainer sourcecont;
			public StorageContainer destcont;

			// storage container child id
			public uint sourcechild = 0;
			public uint destchild = 0;

			public jPipeLogic mainlogic;

			public BuildingGrade.Enum pipegrade = BuildingGrade.Enum.Twigs;
			public float health;

			public List<BaseEntity> pillars = new List<BaseEntity>();
			private BaseEntity filterstash;
			private StorageContainer stashcont;
			private int lookingatstash = 0;

			public bool
				singlestack = false; // change this to enum and add fuel mode

			public bool autostarter = false;

			private bool destisstartable = false;

			public List<int> filteritems = new List<int>();

			public bool fsplit = false;
			public int fsstacks = 2;

			public List<BasePlayer> playerslookingatmenu =
				new List<BasePlayer>();

			public List<BasePlayer> playerslookingatfilter =
				new List<BasePlayer>();

			private float distance;
			private Quaternion rotation;

			// constructor
			public jPipe() { }

			// init
			public bool init(JPipes pplug,
				ulong nid,
				jPipeData data,
				Action<ulong, bool> rem,
				Action<Item, int, StorageContainer, int> mover) {

				pipeplugin = pplug;

				data.toPipe(this);

				if (source == null || sourcecont == null) {
					initerr = "ErrorFindFirst";
					return false;
				}

				if (dest == null || destcont == null) {
					initerr = "ErrorFindSecond";
					return false;
				}

				jPipeGroundWatch.Attach(source, this);
				jPipeGroundWatch.Attach(dest, this);

				destisstartable = isStartable(dest);
				isWaterPipe = dest is LiquidContainer &&
				              source is LiquidContainer;

				remover = rem;
				moveitem = mover;
				id = nid;

				sourcepos = sourcecont.CenterPoint() +
				            containeroffset(sourcecont);
				endpos = destcont.CenterPoint() + containeroffset(destcont);

				distance = Vector3.Distance(sourcepos, endpos);
				rotation = Quaternion.LookRotation(endpos - sourcepos) *
				           Quaternion.Euler(0, 0, 0);

				// create pillars

				int segments = (int) Mathf.Ceil(distance / pipesegdist);
				float segspace = (distance - pipesegdist) / (segments - 1);
				sourcepos = sourcepos +
				            ((rotation * Vector3.forward) * pipesegdist *
				             0.5f) + ((rotation * Vector3.down) * 0.7f);

				initerr = "";

				for (int i = 0; i < segments; i++) {

					//float offset = (segspace * i);
					//Vector3 pos = sourcepos + ((rotation * Vector3.up) * offset);

					// create pillar

					BaseEntity ent;

					if (i == 0) {
						// the position thing centers the pipe if there is only one segment
						ent = GameManager.server.CreateEntity(
							"assets/prefabs/building core/wall.low/wall.low.prefab",
							(segments == 1)
								? (sourcepos +
								   ((rotation * Vector3.up) *
								    ((distance - pipesegdist) * 0.5f)))
								: sourcepos, rotation);
						mainlogic = jPipeLogic.Attach(ent, this, updaterate,
							pipeplugin.flowrates[0]);
						mainparent = ent;
					}
					else {
						//ent = GameManager.server.CreateEntity("assets/prefabs/building core/pillar/pillar.prefab", sourcepos + rotation * (Vector3.up * (segspace * i) + ((i % 2 == 0) ? Vector3.zero : pipefightoffset)), rotation);
						// position based on parent
						ent = GameManager.server.CreateEntity(
							"assets/prefabs/building core/wall.low/wall.low.prefab",
							Vector3.forward * (segspace * i) + ((i % 2 == 0)
								? Vector3.zero
								: pipefightoffset));

					}

					ent.enableSaving = false;

					BuildingBlock block = ent.GetComponent<BuildingBlock>();

					if (block != null) {
						block.grounded = true;
						block.grade = pipegrade;
						block.enableSaving = false;
						block.Spawn();
						block.SetHealthToMax();
					}

					jPipeSegChild.Attach(ent, this);

					if (i != 0)
						ent.SetParent(mainparent);

					if (pipeplugin.xmaslights) {

						BaseEntity lights = GameManager.server.CreateEntity(
							"assets/prefabs/misc/xmas/christmas_lights/xmas.lightstring.deployed.prefab",
							(Vector3.up * pipesegdist * 0.5f) +
							(Vector3.forward * 0.13f) +
							(Vector3.up * (segspace * i) + ((i % 2 == 0)
								? Vector3.zero
								: pipefightoffset)),
							Quaternion.Euler(0, -60, 90));
						lights.enableSaving = false;
						lights.Spawn();
						lights.SetParent(mainparent);
						jPipeSegChildLights.Attach(lights, this);
					}

					pillars.Add(ent);
					ent.enableSaving = false;

				}

				mainlogic.flowrate = ((int) pipegrade == -1)
					? pipeplugin.flowrates[0]
					: pipeplugin.flowrates[(int) pipegrade];

				if (health != 0)
					SetHealth(health);

				// cache container icon urls
				sourceiconurl = GetContIcon(source);
				endiconurl = GetContIcon(dest);

				return true;

			}

			private Vector3 containeroffset(BaseEntity e) {
				if (e is BoxStorage)
					return Vector3.zero;
				if (e is BaseOven) {
					string panel = e.GetComponent<BaseOven>().panelName;

					if (panel == "largefurnace")
						return contoffset.largefurnace;
					if (panel == "smallrefinery")
						return e.transform.rotation * contoffset.refinery;
					if (panel == "bbq")
						return contoffset.bbq;

					return contoffset.furnace;
				}

				if (e is AutoTurret) {
					return contoffset.turret;
				}

				if (e is SearchLight) {
					return contoffset.searchlight;
				}

				return Vector3.zero;
			}

			private bool isStartable(BaseEntity e) =>
				e is BaseOven || e is Recycler || destchild == 2;

			public void OpenFilter(BasePlayer player) {
				if (filterstash != null) {
					LookInFilter(player,
						filterstash.GetComponent<StashContainer>());
					return;
				}

				if (pipeplugin.filtersizes[(int) pipegrade] == 0)
					return;

				filterstash = GameManager.server.CreateEntity(
					"assets/prefabs/deployable/large wood storage/box.wooden.large.prefab",
					new Vector3(0, 0, -10000f), Quaternion.Euler(-90, 0, 0));

				filterstash.SetParent(mainparent);

				stashcont = filterstash.GetComponent<StorageContainer>();

				if (stashcont != null) {
					stashcont.inventorySlots =
						pipeplugin.filtersizes[(int) pipegrade];
					stashcont.SendNetworkUpdate();
					filterstash.Spawn();
				}

				// load content

				jPipeFilterStash f = jPipeFilterStash.Attach(filterstash,
					FilterCallback, UpdateFilterItems);

				foreach (int i in filteritems) {
					Item item = ItemManager.CreateByItemID(i, 1);
					item.MoveToContainer(stashcont.inventory);
				}

				f.loading = false;

				//stashcont.DecayTouch();
				stashcont.UpdateNetworkGroup();
				stashcont.SendNetworkUpdateImmediate();

				stashcont.globalBroadcast = true;

				LookInFilter(player, stashcont);
			}

			public void LookInFilter(BasePlayer player,
				StorageContainer stash) {
				stash.SetFlag(BaseEntity.Flags.Open, true, false);
				player.inventory.loot.StartLootingEntity(stash, false);
				player.inventory.loot.AddContainer(stash.inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel",
					stash.panelName);
				playerslookingatfilter.Add(player);
			}

			public void FilterCallback(BasePlayer player) {
				playerslookingatfilter.Remove(player);
				if (playerslookingatfilter.Count < 1)
					DestroyFilter();
			}

			private void DestroyFilter() {
				if (filterstash == null)
					return;

				filteritems.Clear();
				foreach (var i in stashcont.inventory.itemList)
					filteritems.Add(i.info.itemid);

				filterstash.Kill();
			}

			public void UpdateFilterItems(Item item) {
				filteritems.Clear();
				foreach (var i in stashcont.inventory.itemList)
					filteritems.Add(i.info.itemid);
			}

			public void ChangeDirection() {
				// swap the containers
				BaseEntity newdest = source;
				source = dest;
				dest = newdest;

				StorageContainer newdestcont = sourcecont;
				sourcecont = destcont;
				destcont = newdestcont;

				uint newdestchild = sourcechild;
				sourcechild = destchild;
				destchild = newdestchild;

				sourceiconurl = GetContIcon(source);
				endiconurl = GetContIcon(dest);

				destisstartable = isStartable(dest);
				RefreshMenu();
			}

			// destroy entire pipe when one segment fails
			public void OnSegmentKilled() {
				Destroy();
			}

			public void Destroy(bool removeme = true) {
				// close any open menus
				foreach (BasePlayer p in playerslookingatmenu)
					p.SendConsoleCommand("jpipes.closemenudestroy");

				DestroyFilter();

				remover(id, removeme);
			}

			public void Upgrade(BuildingGrade.Enum grade) {
				foreach (var seg in pillars) {
					BuildingBlock b = seg.GetComponent<BuildingBlock>();
					b.SetGrade(grade);
					b.SetHealthToMax();
					health = b.health;
					b.SendNetworkUpdate(BasePlayer.NetworkQueue.UpdateDistance);
				}

				pipegrade = grade;
				mainlogic.flowrate = ((int) grade == -1)
					? pipeplugin.flowrates[0]
					: pipeplugin.flowrates[(int) grade];

				RefreshMenu();

				DestroyFilter();
				foreach (BasePlayer p in playerslookingatfilter)
					OpenFilter(p);
			}

			public void SetHealth(float nhealth) {
				foreach (var seg in pillars) {
					BuildingBlock b = seg.GetComponent<BuildingBlock>();
					b.health = nhealth;
					b.SendNetworkUpdate(BasePlayer.NetworkQueue.UpdateDistance);
				}

				health = nhealth;
			}

			private static string ArrowString(int count) {
				if (count == 1)
					return ">>";
				if (count == 2)
					return ">>>";
				if (count == 3)
					return ">>>>";
				if (count == 4)
					return ">>>>>";
				return ">";
			}

			public void OpenMenu(BasePlayer player, UserInfo userinfo) {

				CloseMenu(player, userinfo);

				playerslookingatmenu.Add(player);

				Vector2 size = new Vector2(0.125f, 0.175f);
				float margin = 0.05f;

				var elements = new CuiElementContainer();

				userinfo.menu = elements.Add(
					new CuiPanel {
						Image = {Color = "0.15 0.15 0.15 0.86"},
						RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
						CursorEnabled = true
					}
				);

				// close when you click outside of the window
				elements.Add(
					new CuiButton {
						Button = {
							Command = $"jpipes.closemenu {id}",
							Color = "0 0 0 0"
						},
						RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
						Text = {Text = string.Empty}
					}, userinfo.menu
				);

				string window = elements.Add(new CuiPanel {
						Image = {Color = "0 0 0 0"},
						RectTransform = {
							AnchorMin = $"{0.5f - size.x} {0.5f - size.y}",
							AnchorMax = $"{0.5f + size.x} {0.5f + size.y}"
						}
					}, userinfo.menu
				);

				string contentleft = elements.Add(new CuiPanel {
						Image = {Color = "0 0 0 0"},
						RectTransform = {
							AnchorMin = $"{margin} {0 - margin * 0.25f}",
							AnchorMax = $"{0.5f - margin} {1 - margin * 0.5f}"
						},
						CursorEnabled = false
					}, window
				);

				string contentright = elements.Add(new CuiPanel {
						Image = {Color = "0 0 0 0"},
						RectTransform = {
							AnchorMin = "0.5 0",
							AnchorMax = "1 1"
						}
					}, window
				);

				// title
				elements.Add(
					CreateLabel(
						pipeplugin.lang.GetMessage("MenuTitle", pipeplugin,
							player.UserIDString), 1, 1, TextAnchor.UpperLeft,
						32, "0", "1", "1 1 1 0.8"),
					contentleft
				);

				// flow
				string FlowMain = elements.Add(new CuiPanel {
						Image = {Color = "1 1 1 0"},
						RectTransform = {
							AnchorMin = $"{margin * 0.75f} 0.59",
							AnchorMax = $"{0.5f - (margin * 0.75f)} 0.78"
						}
					}, window
				);

				string FlowPipe = elements.Add(new CuiPanel {
						Image = {Color = "1 1 1 0.04"},
						RectTransform = {
							AnchorMin = "0.2 0.33",
							AnchorMax = "0.8 0.66"
						}
					}, FlowMain
				);

				elements.Add(
					CreateLabel(ArrowString((int) pipegrade), 1, 1,
						TextAnchor.MiddleCenter, 12, "0", "1", "1 1 1 1"),
					FlowPipe
				);

				elements.Add(
					CreateItemIcon(FlowMain, "0 0", "0.35 1", sourceiconurl)
				);
				elements.Add(
					CreateItemIcon(FlowMain, "0.65 0", "1 1", endiconurl)
				);

				//Furnace Splitter
				if ((BaseEntity) destcont is BaseOven &&
				    pipeplugin.FurnaceSplitter != null) {

					string FSmain = elements.Add(new CuiPanel {
							Image = {Color = "1 1 1 0"},
							RectTransform = {
								AnchorMin = $"{margin * 0.5f} 0.23",
								AnchorMax = $"{0.5f - (margin * 0.5f)} 0.53"
							}
						}, window
					);

					elements.Add(
						CreateItemIcon(window, "0.348 0.538", "0.433 0.59",
							"http://i.imgur.com/BwJN0rt.png", "1 1 1 0.04")
					);

					string FShead = elements.Add(new CuiPanel {
							Image = {Color = "1 1 1 0.04"},
							RectTransform = {
								AnchorMin = "0 0.7",
								AnchorMax = "1 1"
							}
						}, FSmain
					);

					elements.Add(
						CreateLabel("Furnace Splitter", 1, 1,
							TextAnchor.MiddleCenter, 12, "0", "1", "1 1 1 0.8"),
						FShead
					);

					string FScontent = elements.Add(new CuiPanel {
							Image = {Color = "1 1 1 0"},
							RectTransform = {
								AnchorMin = "0 0",
								AnchorMax = "1 0.66"
							}
						}, FSmain
					);

					// elements.Add(
					//    CreateLabel("ETA: 0s (0 wood)", 1, 0.3f, TextAnchor.MiddleLeft, 10, $"{margin}", "1", "1 1 1 0.8"),
					//    FScontent
					// );

					if (fsplit) {
						elements.Add(
							CreateButton($"jpipes.fsdisable {id}", 1.2f, 0.4f,
								12,
								pipeplugin.lang.GetMessage("MenuTurnOff",
									pipeplugin, player.UserIDString),
								$"{margin}", $"{0.5f - (margin * 0.5f)}",
								"0.59 0.27 0.18 0.8", "0.89 0.49 0.31 1"),
							FScontent
						);
					}
					else {
						elements.Add(
							CreateButton($"jpipes.fsenable {id}", 1.2f, 0.4f,
								12,
								pipeplugin.lang.GetMessage("MenuTurnOn",
									pipeplugin, player.UserIDString),
								$"{margin}", $"{0.5f - (margin * 0.5f)}",
								"0.43 0.51 0.26 0.8", "0.65 0.76 0.47 1"),
							FScontent
						);
					}

					// elements.Add(
					//    CreateButton($"jpipes.autostartoff {id}", 2.2f, 0.25f, 11, "Trim fuel", $"{0.5f + (margin * 0.5f)}", $"{1 - (margin)}", "1 1 1 0.08", "1 1 1 0.8"),
					//    FScontent
					// );

					float arrowbuttonmargin = 0.1f;
					elements.Add(
						CreateButton($"jpipes.fsstack {id} {fsstacks - 1}",
							2.4f, 0.4f, 12, "<", $"{margin}",
							$"{margin + arrowbuttonmargin}", "1 1 1 0.08",
							"1 1 1 0.8"),
						FScontent
					);
					elements.Add(
						CreateLabel($"{fsstacks}", 3, 0.31f,
							TextAnchor.MiddleCenter, 12,
							$"{margin + arrowbuttonmargin}",
							$"{0.5f - (margin * 0.5f) - arrowbuttonmargin}",
							"1 1 1 0.8"),
						FScontent
					);

					//elements.Add(
					//    CuiInputField(FScontent,$"jpipes.fsstack {id} ",$"{fsstacks}",12,2)
					//);

					elements.Add(
						CreateButton($"jpipes.fsstack {id} {fsstacks + 1}",
							2.4f, 0.4f, 12, ">",
							$"{0.5f - (margin * 0.5f) - arrowbuttonmargin}",
							$"{0.5f - (margin * 0.5f)}", "1 1 1 0.08",
							"1 1 1 0.8"),
						FScontent
					);

					elements.Add(
						CreateLabel("Total Stacks", 3, 0.31f,
							TextAnchor.MiddleLeft, 12,
							$"{(margin * 0.5f) + 0.5f}", "1", "1 1 1 0.8"),
						FScontent
					);
				}

				string infostring = string.Format(
					pipeplugin.lang.GetMessage("MenuInfo", pipeplugin,
						player.UserIDString), ownername,
					isWaterPipe
						? $"{mainlogic.flowrate}ml"
						: mainlogic.flowrate.ToString(),
					Math.Round(distance, 2));

				// info
				elements.Add(
					CreateLabel(
						debugstring == string.Empty
							? infostring
							: $"{infostring}\nDebug:\n{debugstring}",
						1, 1, TextAnchor.LowerLeft, 16, "0", "1", "1 1 1 0.4"
					), contentleft
				);

				//elements.Add(
				//    CreateLabel(
				//        $"start {sourcecont.net.ID}\nend {destcont.net.ID}",
				//        1,1.2f,TextAnchor.LowerLeft,16,"0","1","1 1 1 0.4"
				//    ),contentleft
				//);

				// buttons

				//0.13 0.38 0.58

				float buttonspacing = 0.1f;
				float buttonratio = (destisstartable) ? 0.2f : 0.25f;
				float buttonsize = buttonratio - (buttonspacing * buttonratio);
				float buttonoffset =
					buttonspacing + (buttonspacing * buttonratio);

				// toggle button
				if (isEnabled) {
					elements.Add(
						CreateButton($"jpipes.turnoff {id}",
							1 + buttonoffset * 0, buttonsize, 18,
							pipeplugin.lang.GetMessage("MenuTurnOff",
								pipeplugin, player.UserIDString), "0", "1",
							"0.59 0.27 0.18 0.8", "0.89 0.49 0.31 1"),
						contentright
					);
				}
				else {
					elements.Add(
						CreateButton($"jpipes.turnon {id}",
							1 + buttonoffset * 0, buttonsize, 18,
							pipeplugin.lang.GetMessage("MenuTurnOn", pipeplugin,
								player.UserIDString), "0", "1",
							"0.43 0.51 0.26 0.8", "0.65 0.76 0.47 1"),
						contentright
					);
				}

				if (destisstartable) {
					if (autostarter) {
						elements.Add(
							CreateButton($"jpipes.autostartoff {id}",
								2 + buttonoffset * 1, buttonsize, 18,
								pipeplugin.lang.GetMessage("MenuAutoStarter",
									pipeplugin, player.UserIDString), "0", "1",
								"0.43 0.51 0.26 0.8", "0.65 0.76 0.47 1"),
							contentright
						);
					}
					else {
						elements.Add(
							CreateButton($"jpipes.autostarton {id}",
								2 + buttonoffset * 1, buttonsize, 18,
								pipeplugin.lang.GetMessage("MenuAutoStarter",
									pipeplugin, player.UserIDString), "0", "1",
								"0.59 0.27 0.18 0.8", "0.89 0.49 0.31 1"),
							contentright
						);
					}
				}

				elements.Add(
					CreateButton($"jpipes.changedir {id}",
						(destisstartable)
							? 3 + buttonoffset * 2
							: 2 + buttonoffset * 1, buttonsize, 18,
						pipeplugin.lang.GetMessage("MenuChangeDirection",
							pipeplugin, player.UserIDString), "0", "1",
						"1 1 1 0.08", "1 1 1 0.8"),
					contentright
				);

				if ((!fsplit || pipeplugin.FurnaceSplitter == null) &&
				    !isWaterPipe) {
					if (singlestack) {
						elements.Add(
							CreateButton($"jpipes.stackoff {id}",
								(destisstartable)
									? 4 + buttonoffset * 3
									: 3 + buttonoffset * 2, buttonsize, 18,
								pipeplugin.lang.GetMessage("MenuSingleStack",
									pipeplugin, player.UserIDString), "0", "1",
								"1 1 1 0.08", "1 1 1 0.8"),
							contentright
						);
					}
					else {
						elements.Add(
							CreateButton($"jpipes.stackon {id}",
								(destisstartable)
									? 4 + buttonoffset * 3
									: 3 + buttonoffset * 2, buttonsize, 18,
								pipeplugin.lang.GetMessage("MenuMultiStack",
									pipeplugin, player.UserIDString), "0", "1",
								"1 1 1 0.08", "1 1 1 0.8"),
							contentright
						);
					}
				}
				else {
					elements.Add(
						CreateButton("",
							(destisstartable)
								? 4 + buttonoffset * 3
								: 3 + buttonoffset * 2, buttonsize, 18,
							pipeplugin.lang.GetMessage("MenuMultiStack",
								pipeplugin, player.UserIDString), "0", "1",
							"1 1 1 0.08", "1 1 1 0.2"),
						contentright
					);
				}

				// disable filter button if filtersize is 0
				if (pipeplugin.filtersizes[(int) pipegrade] == 0 ||
				    isWaterPipe) {
					elements.Add(
						CreateButton("",
							(destisstartable)
								? 5 + buttonoffset * 4
								: 4 + buttonoffset * 3, buttonsize, 18,
							pipeplugin.lang.GetMessage("MenuItemFilter",
								pipeplugin, player.UserIDString), "0", "1",
							"1 1 1 0.08", "1 1 1 0.2"),
						contentright
					);
				}
				else {
					elements.Add(
						CreateButton($"jpipes.openfilter {id}",
							(destisstartable)
								? 5 + buttonoffset * 4
								: 4 + buttonoffset * 3, buttonsize, 18,
							pipeplugin.lang.GetMessage("MenuItemFilter",
								pipeplugin, player.UserIDString), "0", "1",
							"1 1 1 0.08", "1 1 1 0.8"),
						contentright
					);
				}


				CuiHelper.AddUi(player, elements);
				userinfo.isMenuOpen = true;
			}

			public void CloseMenu(BasePlayer player, UserInfo userinfo) {
				if (!string.IsNullOrEmpty(userinfo.menu))
					CuiHelper.DestroyUi(player, userinfo.menu);
				userinfo.isMenuOpen = false;

				playerslookingatmenu.Remove(player);
			}

			// this refreshes the menu for each playerslookingatmenu
			public void RefreshMenu() {
				foreach (BasePlayer p in playerslookingatmenu) {
					p.SendConsoleCommand($"jpipes.refreshmenu {id}");
				}
			}

			public string GetContIcon(BaseEntity e) {

				if (e is BoxStorage) {
					string panel = e.GetComponent<StorageContainer>().panelName;
					if (panel == "largewoodbox")
						return GetItemIconURL("Large_Wood_Box", 140);
					return GetItemIconURL("Wood_Storage_Box", 140);

				}

				if (e is BaseOven) {
					string panel = e.GetComponent<BaseOven>().panelName;

					if (panel == "largefurnace")
						return GetItemIconURL("Large_Furnace", 140);
					if (panel == "smallrefinery")
						return GetItemIconURL("Small_Oil_Refinery", 140);
					if (panel == "lantern")
						return GetItemIconURL("Lantern", 140);
					if (panel == "bbq")
						return GetItemIconURL("BBQ", 140);
					if (panel == "campfire")
						return GetItemIconURL("Camp_Fire", 140);

					return GetItemIconURL("Furnace", 140);
				}

				if (e is AutoTurret) {
					return GetItemIconURL("Auto_Turret", 140);
				}

				if (e is Recycler) {
					return GetItemIconURL("Recycler", 140);
				}

				if (e is FlameTurret) {
					return GetItemIconURL("Flame_Turret", 140);
				}

				if (e is GunTrap) {
					return GetItemIconURL("Shotgun_Trap", 140);
				}

				if (e is SearchLight) {
					return GetItemIconURL("Search_Light", 140);
				}

				if (e is VendingMachine) {
					return GetItemIconURL("Vending_Machine", 140);
				}

				if (e is DropBox) {
					return GetItemIconURL("Drop_Box", 140);
				}

				if (e is StashContainer) {
					return GetItemIconURL("Small_Stash", 140);
				}

				if (e is MiningQuarry) {
					if (e.ToString().Contains("pump"))
						return GetItemIconURL("Pump_Jack", 140);
					return GetItemIconURL("Mining_Quarry", 140);
				}

				if (e is BuildingPrivlidge) {
					return GetItemIconURL("Tool_Cupboard", 140);
				}

				return "http://i.imgur.com/BwJN0rt.png";
			}
		}

		// syncbox
		private class jSyncBox {
			private JPipes pipeplugin;

			public ulong id;
			public string initerr = string.Empty;

			public ulong ownerid;
			public string ownername;

			public bool isEnabled = true;
		}

		#endregion

		#region Pipe Parameters

		// length of a segment
		private static float pipesegdist = 3;

		// every other pipe segment is offset by this to remove z fighting
		private static Vector3 pipefightoffset =
			new Vector3(0.0001f, 0.0001f, 0);

		// offset of pipe inside different containers
		private static class contoffset {
			public static Vector3 turret = new Vector3(0, -0.58f, 0);
			public static Vector3 refinery = new Vector3(-1, 0, -0.1f);
			public static Vector3 furnace = new Vector3(0, -0.3f, 0);
			public static Vector3 largefurnace = new Vector3(0, -1.5f, 0);
			public static Vector3 searchlight = new Vector3(0, -0.5f, 0);
			public static Vector3 pumpfuel = Vector3.zero;
			public static Vector3 pumpoutput = new Vector3(-1, 2, 0);
			public static Vector3 recycler = Vector3.zero;
			public static Vector3 largewatercatcher = new Vector3(0, -0.6f, 0);
			public static Vector3 smallwatercatcher = new Vector3(0, -0.6f, 0);
			public static Vector3 waterbarrel = new Vector3(0, 0.2f, 0);
			public static Vector3 waterpurifier = new Vector3(0, 0.25f, 0);

			public static Vector3 bbq = Vector3.up * 0.03f;

			//public static Vector3 quarryfuel = new Vector3(1,-0.2f,0);
			//public static Vector3 quarryoutput = new Vector3(1,0,0);
		}

		readonly static Dictionary<string, string> ItemUrls =
			new Dictionary<string, string>() {
				{
					"Small_Stocking",
					"http://vignette2.wikia.nocookie.net/play-rust/images/9/97/Small_Stocking_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"SUPER_Stocking",
					"http://vignette1.wikia.nocookie.net/play-rust/images/6/6a/SUPER_Stocking_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Small_Present",
					"http://vignette2.wikia.nocookie.net/play-rust/images/d/da/Small_Present_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Medium_Present",
					"http://vignette3.wikia.nocookie.net/play-rust/images/6/6b/Medium_Present_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Large_Present",
					"http://vignette1.wikia.nocookie.net/play-rust/images/9/99/Large_Present_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Pump_Jack",
					"http://vignette2.wikia.nocookie.net/play-rust/images/c/c9/Pump_Jack_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Shop_Front",
					"http://vignette4.wikia.nocookie.net/play-rust/images/c/c1/Shop_Front_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Water_Purifier",
					"http://vignette3.wikia.nocookie.net/play-rust/images/6/6e/Water_Purifier_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Water_Barrel",
					"http://vignette4.wikia.nocookie.net/play-rust/images/e/e2/Water_Barrel_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Survival_Fish_Trap",
					"http://vignette2.wikia.nocookie.net/play-rust/images/9/9d/Survival_Fish_Trap_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Research_Table",
					"http://vignette2.wikia.nocookie.net/play-rust/images/2/21/Research_Table_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Small_Planter_Box",
					"http://vignette3.wikia.nocookie.net/play-rust/images/a/a7/Small_Planter_Box_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Large_Planter_Box",
					"http://vignette1.wikia.nocookie.net/play-rust/images/3/35/Large_Planter_Box_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Jack_O_Lantern_Happy",
					"http://vignette1.wikia.nocookie.net/play-rust/images/9/92/Jack_O_Lantern_Happy_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Jack_O_Lantern_Angry",
					"http://vignette4.wikia.nocookie.net/play-rust/images/9/96/Jack_O_Lantern_Angry_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Large_Furnace",
					"http://vignette3.wikia.nocookie.net/play-rust/images/e/ee/Large_Furnace_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Ceiling_Light",
					"http://vignette3.wikia.nocookie.net/play-rust/images/4/43/Ceiling_Light_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Hammer",
					"http://vignette4.wikia.nocookie.net/play-rust/images/5/57/Hammer_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Auto_Turret",
					"http://vignette2.wikia.nocookie.net/play-rust/images/f/f9/Auto_Turret_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Camp_Fire",
					"http://vignette4.wikia.nocookie.net/play-rust/images/3/35/Camp_Fire_icon.png/revision/latest/scale-to-width-down/{0}"
				},
				{"BBQ", "http://i.imgur.com/DfCm0EJ.png"}, {
					"Furnace",
					"http://vignette4.wikia.nocookie.net/play-rust/images/e/e3/Furnace_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Lantern",
					"http://vignette4.wikia.nocookie.net/play-rust/images/4/46/Lantern_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Large_Water_Catcher",
					"http://vignette2.wikia.nocookie.net/play-rust/images/3/35/Large_Water_Catcher_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Large_Wood_Box",
					"http://vignette1.wikia.nocookie.net/play-rust/images/b/b2/Large_Wood_Box_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Mining_Quarry",
					"http://vignette1.wikia.nocookie.net/play-rust/images/b/b8/Mining_Quarry_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Repair_Bench",
					"http://vignette1.wikia.nocookie.net/play-rust/images/3/3b/Repair_Bench_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Small_Oil_Refinery",
					"http://vignette2.wikia.nocookie.net/play-rust/images/a/ac/Small_Oil_Refinery_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Small_Stash",
					"http://vignette2.wikia.nocookie.net/play-rust/images/5/53/Small_Stash_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Small_Water_Catcher",
					"http://vignette2.wikia.nocookie.net/play-rust/images/0/04/Small_Water_Catcher_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Search_Light",
					"http://vignette2.wikia.nocookie.net/play-rust/images/c/c6/Search_Light_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Wood_Storage_Box",
					"http://vignette2.wikia.nocookie.net/play-rust/images/f/ff/Wood_Storage_Box_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Vending_Machine",
					"http://vignette2.wikia.nocookie.net/play-rust/images/5/5c/Vending_Machine_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Drop_Box",
					"http://vignette2.wikia.nocookie.net/play-rust/images/4/46/Drop_Box_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Fridge",
					"http://vignette2.wikia.nocookie.net/play-rust/images/8/88/Fridge_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Shotgun_Trap",
					"http://vignette2.wikia.nocookie.net/play-rust/images/6/6c/Shotgun_Trap_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Flame_Turret",
					"http://vignette2.wikia.nocookie.net/play-rust/images/f/f9/Flame_Turret_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Recycler",
					"http://vignette2.wikia.nocookie.net/play-rust/images/e/ef/Recycler_icon.png/revision/latest/scale-to-width-down/{0}"
				}, {
					"Tool_Cupboard",
					"http://vignette2.wikia.nocookie.net/play-rust/images/5/57/Tool_Cupboard_icon.png/revision/latest/scale-to-width-down/{0}"
				}
			};

		#endregion

		#region Pipe Functions

		private void startplacingpipe(BasePlayer player,
			bool isUsingBind = false) {

			UserInfo userinfo = GetUserInfo(player);

			int playerpipelimit;
			if (!checkplayerpipelimit(player, userinfo, out playerpipelimit)) {
				ShowOverlayText(player,
					string.Format(
						lang.GetMessage("ErrorPipeLimitReached", this,
							player.UserIDString), playerpipelimit.ToString()),
					"", orangestring);
				HideOverlayText(player, 2f);
				userinfo.placestart = null;
				userinfo.placeend = null;
				return;
			}

			userinfo.state = userinfo.state == UserState.placing
				? UserState.none
				: UserState.placing;
			userinfo.isUsingBind = isUsingBind;
			userinfo.clipboard = null;

			if (userinfo.state == UserState.placing) {
				if (!isUsingBind)
					PrintToChat(player,
						string.Format(
							lang.GetMessage("HelpBindTip", this,
								player.UserIDString), pipecommandprefix,
							pipehotkey));

				ShowOverlayText(player,
					lang.GetMessage("SelectFirst", this, player.UserIDString),
					string.Format(
						lang.GetMessage(
							userinfo.isUsingBind
								? "SelectSubtextBind"
								: "SelectSubtextCmd", this,
							player.UserIDString),
						userinfo.isUsingBind
							? pipehotkey.ToUpper()
							: pipecommandprefix));
			}
			else {
				//ShowOverlayText(player,"",lang.GetMessage("SelectCancel",this,player.UserIDString));
				HideOverlayText(player);
				userinfo.placestart = null;
				userinfo.placeend = null;
			}
		}

		private void startlinking(BasePlayer player, bool isUsingBind = false) {

			UserInfo userinfo = GetUserInfo(player);

			userinfo.state = userinfo.state == UserState.linking
				? UserState.none
				: UserState.linking;
			userinfo.isUsingBind = isUsingBind;
			userinfo.clipboard = null;

			if (userinfo.state == UserState.linking) {
				if (!isUsingBind)
					PrintToChat(player,
						string.Format(
							lang.GetMessage("HelpBindTip", this,
								player.UserIDString), pipecommandprefix,
							pipehotkey));

				ShowOverlayText(player,
					lang.GetMessage("SelectFirst", this, player.UserIDString),
					string.Format(
						lang.GetMessage(
							userinfo.isUsingBind
								? "SelectSubtextBind"
								: "SelectSubtextCmd", this,
							player.UserIDString),
						userinfo.isUsingBind
							? pipehotkey.ToUpper()
							: pipecommandprefix));
			}
			else {
				HideOverlayText(player);
				userinfo.placestart = null;
				userinfo.placeend = null;
			}
		}

		// called after second container has been selected
		private void NewPipe(BasePlayer player, UserInfo userinfo) {

			jPipeData newdata = new jPipeData();
			newdata.setContainers(userinfo.placestart, userinfo.placeend);

			bool destiswater = userinfo.placeend is LiquidContainer;

			if (userinfo.placestart is LiquidContainer == destiswater) {
				if (!checkpipeoverlap(regpipes, newdata)) {

					float dist = Vector3.Distance(
						userinfo.placestart.CenterPoint(),
						userinfo.placeend.CenterPoint());

					if (dist > maxpipedist) {
						ShowOverlayText(player,
							lang.GetMessage("ErrorTooFar", this,
								player.UserIDString), "", orangestring);
					}
					else if (dist <= minpipedist) {
						ShowOverlayText(player,
							lang.GetMessage("ErrorTooClose", this,
								player.UserIDString), "", orangestring);
					}
					else {

						jPipe newpipe = new jPipe();
						newdata.o = player.userID;
						newdata.on = player.displayName;

						// initalize pipe
						if (newpipe.init(this, pipeidgen(), newdata, RemovePipe,
							MoveItem)) {
							// pipe was created so register it
							RegisterPipe(newpipe);
							ShowOverlayText(player,
								lang.GetMessage("PipeCreated", this,
									player.UserIDString), "", bluestring);
						}
						else {
							// pipe error
							ShowOverlayText(player,
								lang.GetMessage(newpipe.initerr, this,
									player.UserIDString));
							newpipe = null;
						}
					}
				}
				else {
					ShowOverlayText(player,
						lang.GetMessage("ErrorAlreadyConnected", this,
							player.UserIDString), "", orangestring);
				}
			}
			else {
				ShowOverlayText(player,
					lang.GetMessage(
						destiswater ? "ErrorNotItemCont" : "ErrorNotLiquidCont",
						this, player.UserIDString), "", orangestring);
			}

			HideOverlayText(player, 3f);
			userinfo.state = UserState.none;
			userinfo.placestart = null;
			userinfo.placeend = null;
		}

		private void NewSyncBox(BasePlayer player, UserInfo userinfo) {

			//jSyncBoxData newdata = new jSyncBoxData();

			HideOverlayText(player, 3f);
			userinfo.state = UserState.none;
			userinfo.placestart = null;
			userinfo.placeend = null;
		}

		private Random randomidgen = new Random();

		private ulong pipeidgen() {
			ulong id = (ulong) randomidgen.Next(1000000, 9999999);
			if (regpipes.ContainsKey(id))
				return pipeidgen();
			return id;
		}

		private ulong syncboxidgen() {
			ulong id = (ulong) randomidgen.Next(1000000, 9999999);
			if (regsyncboxes.ContainsKey(id))
				return syncboxidgen();
			return id;
		}

		// TODO this could be improved by only compairing ids
		private static bool checkpipeoverlap(Dictionary<ulong, jPipe> rps,
			jPipeData data) {
			uint s = getcontfromid(data.s, data.cs).net.ID;
			uint e = getcontfromid(data.d, data.cd).net.ID;

			foreach (var p in rps)
				if ((p.Value.sourcecont.net.ID == s &&
				     p.Value.destcont.net.ID == e) ||
				    (p.Value.sourcecont.net.ID == e &&
				     p.Value.destcont.net.ID == s))
					return true;
			return false;
		}

		private static bool checkcontwhitelist(BaseEntity e) =>
			!(e is BaseFuelLightSource || e is Locker || e is ShopFront ||
			  e is RepairBench);

		private bool checkcontprivlage(BaseEntity e, BasePlayer p) =>
			e.GetComponent<StorageContainer>().CanOpenLootPanel(p,"") &&
			checkbuildingprivlage(p);

		private bool checkbuildingprivlage(BasePlayer p) {
			if (permission.UserHasPermission(p.UserIDString, "jpipes.admin"))
				return true;

			//BuildingPrivlidge priv = p.GetBuildingPrivilege();
			//return (priv != null) ? priv.IsAuthed(p) : true;
			return p.CanBuild();
		}

		private bool checkplayerpipelimit(BasePlayer p, UserInfo user) {
			int limit = getplayerpipelimit(p);
			return (limit >= (user.pipes.Keys.Count + 1)) || limit == -1;
		}

		private bool checkplayerpipelimit(BasePlayer p,
			UserInfo user,
			out int pipelimit) {
			pipelimit = getplayerpipelimit(p);
			return (pipelimit >= (user.pipes.Keys.Count + 1)) ||
			       pipelimit == -1;
		}

		// TODO combine limit functions into one

		private int getplayerpipelimit(BasePlayer p) {
			string id = p.UserIDString;
			if (permission.UserHasPermission(id, "jpipes.admin"))
				return -1;

			List<string> uperms =
				permission.GetUserPermissions(p.UserIDString).ToList();
			List<string> pperms = new List<string>();

			foreach (var s in permlevels.Keys) {
				if (uperms.Contains($"jpipes.level.{s}"))
					pperms.Add(s);
			}

			int curlimit = 0;
			foreach (var s in pperms) {
				int l = permlevels[s].pipelimit;
				if (l == -1)
					return -1;
				curlimit = Mathf.Max(curlimit, l);
			}

			return curlimit == 0 ? -1 : curlimit;
		}

		private int getplayerupgradelimit(BasePlayer p) {
			string id = p.UserIDString;
			if (permission.UserHasPermission(id, "jpipes.admin"))
				return -1;

			List<string> uperms =
				permission.GetUserPermissions(p.UserIDString).ToList();
			List<string> pperms = new List<string>();

			foreach (var s in permlevels.Keys) {
				if (uperms.Contains($"jpipes.level.{s}"))
					pperms.Add(s);
			}

			int curlimit = -1;
			foreach (var s in pperms) {
				int l = permlevels[s].upgradelimit;
				if (l == -1)
					return -1;
				curlimit = Mathf.Max(curlimit, l);
			}

			return curlimit > 3 ? -1 : curlimit;
		}

		// find storage container from id and child id
		private static StorageContainer getcontfromid(uint id, uint cid = 0) =>
			getchildcont((BaseEntity) BaseNetworkable.serverEntities.Find(id),
				cid);

		// find storage container from parent and child id
		private static StorageContainer getchildcont(BaseEntity parent,
			uint id = 0) {
			if (id != 0) {
				BaseResourceExtractor ext =
					parent?.GetComponent<BaseResourceExtractor>();
				if (ext != null) {
					foreach (var c in ext.children) {
						if (c is ResourceExtractorFuelStorage &&
						    c.GetComponent<ResourceExtractorFuelStorage>()
							    .panelName ==
						    ((id == 2) ? "fuelstorage" : "generic"))
							return c.GetComponent<StorageContainer>();
					}
				}

				//return parent.GetComponent<StorageContainer>();
			}

			return parent?.GetComponent<StorageContainer>();
		}

		private bool IsPipe(BaseEntity entity) {
			jPipeSegChild p = entity.GetComponent<jPipeSegChild>();
			return p != null && p.pipe != null;
		}

		private void RegisterPipe(jPipe pipe) {
			GetUserInfo(pipe.ownerid).pipes.Add(pipe.id, pipe);
			regpipes.Add(pipe.id, pipe);
		}

		private void UnRegisterPipe(jPipe pipe) {
			GetUserInfo(pipe.ownerid).pipes.Remove(pipe.id);
			regpipes.Remove(pipe.id);
		}

		private void UnRegisterPipe(ulong id) {
			jPipe pipe;
			if (regpipes.TryGetValue(id, out pipe)) {
				UnRegisterPipe(pipe);
			}
		}

		public void RemovePipe(ulong id, bool remove = true) {

			jPipe pipe;
			if (regpipes.TryGetValue(id, out pipe))
				UnloadPipe(pipe);

			if (remove)
				UnRegisterPipe(id);
		}

		private void UnloadPipes() {
			foreach (var p in regpipes)
				UnloadPipe(p.Value);
		}

		private void UnloadPipe(jPipe p) {
			NextFrame(() => {
				// destroy parent
				if (!p.mainparent.IsDestroyed)
					p.mainparent.Kill();

				//foreach (var pil in p.pillars)
				//    if (!pil.IsDestroyed)
				//        pil.Kill();
			});
		}

		private void SavePipes() {
			storedData.p = new Dictionary<ulong, jPipeData>();

			foreach (var p in regpipes) {
				if (!p.Value.mainparent.IsDestroyed) {
					jPipeData d = new jPipeData();
					d.fromPipe(p.Value);
					storedData.p[p.Key] = d; // creates or updates
				}
			}

			SaveData(storedData);

			Puts(storedData.p.Count.ToString() + " pipes saved");
		}

		public void MoveItem(Item itemtomove,
			int amounttotake,
			StorageContainer cont,
			int stacks) {

			if (itemtomove.amount > amounttotake)
				itemtomove = itemtomove.SplitItem(amounttotake);

			if ((BaseEntity) cont is BaseOven && stacks > -1) {
				if (FurnaceSplitter != null)
					FurnaceSplitter?.Call("MoveSplitItem", itemtomove,
						(BaseEntity) cont, stacks);
				else
					itemtomove.MoveToContainer(cont.inventory);
			}
			else {
				itemtomove.MoveToContainer(cont.inventory);
			}
		}

		#endregion

		#region Pipe Components

		private class jPipeLogic : MonoBehaviour {

			public jPipe pipe;
			public int tickdelay;
			public int flowrate;

			public static jPipeLogic Attach(BaseEntity entity,
				jPipe pipe,
				int tickdelay,
				int flowrate) {
				jPipeLogic n = entity.gameObject.AddComponent<jPipeLogic>();
				n.pipe = pipe;
				n.tickdelay = tickdelay;
				n.flowrate = flowrate;
				return n;
			}

			private float period = 0f;

			void Update() {

				// if either container is destroyed
				if (pipe.sourcecont == null || pipe.destcont == null)
					pipe.Destroy();

				if (period > tickdelay) {

					// source isn't empty
					if (pipe.isEnabled &&
					    pipe.sourcecont.inventory.itemList.Count > 0 &&
					    pipe.sourcecont.inventory.itemList[0] != null) {

						if (pipe.isWaterPipe) {

							int amounttotake = tickdelay * flowrate;
							Item itemtomove =
								pipe.sourcecont.inventory.itemList[0];

							if (pipe.destcont.inventory.itemList.Count == 1) {
								Item slot = pipe.destcont.inventory.itemList[0];

								if (slot.CanStack(itemtomove)) {

									int maxstack = slot.MaxStackable();
									if (slot.amount < maxstack) {
										if ((maxstack - slot.amount) <
										    amounttotake)
											amounttotake =
												maxstack - slot.amount;
										pipe.moveitem(itemtomove, amounttotake,
											pipe.destcont, -1);
									}
								}
							}
							else {
								pipe.moveitem(itemtomove, amounttotake,
									pipe.destcont, -1);
							}

							//if (pipe.destcont.inventory.itemList.Count == 1 && pipe.destcont.inventory.itemList[0] != null) {
							//    int destamount = pipe.destcont.inventory.itemList[0].amount;
							//    int sizeleft = pipe.dest.GetComponent<LiquidContainer>().maxStackSize - destamount;

							//    if (sizeleft > 0) {
							//        pipe.moveitem(itemtomove, destamount, pipe.destcont, -1);
							//    }
							//} else {
							//    pipe.moveitem(itemtomove, amounttotake, pipe.destcont, -1);
							//}

						}
						else {

							Item itemtomove = FindItem();

							// move the item
							if (itemtomove != null &&
							    CanAcceptItem(itemtomove)) {

								int amounttotake = tickdelay * flowrate;

								if (pipe.singlestack) {

									Item slot = pipe.destcont.inventory
										.FindItemsByItemID(itemtomove.info
											.itemid)
										.OrderBy<Item, int>(
											(Func<Item, int>) (x => x.amount))
										.FirstOrDefault<Item>();

									if (slot != null) {
										if (slot.CanStack(itemtomove)) {

											int maxstack = slot.MaxStackable();
											if (slot.amount < maxstack) {
												if ((maxstack - slot.amount) <
												    amounttotake)
													amounttotake =
														maxstack - slot.amount;
												pipe.moveitem(itemtomove,
													amounttotake, pipe.destcont,
													(pipe.fsplit)
														? pipe.fsstacks
														: -1);
												TurnOnDest();
											}
										}
									}
									else {
										pipe.moveitem(itemtomove, amounttotake,
											pipe.destcont,
											(pipe.fsplit) ? pipe.fsstacks : -1);
										TurnOnDest();
									}
								}
								else {
									pipe.moveitem(itemtomove, amounttotake,
										pipe.destcont,
										(pipe.fsplit) ? pipe.fsstacks : -1);
									TurnOnDest();
								}
							}

						}
					}

					period = 0;
				}

				period += Time.deltaTime;
			}

			public void pipeEnable(BasePlayer player) {
				if (!pipe.isEnabled)
					period = 0;
				pipe.isEnabled = true;
				pipe.RefreshMenu();
			}

			public void pipeDisable(BasePlayer player) {
				pipe.isEnabled = false;
				pipe.RefreshMenu();
			}

			private static Item FilterItem(List<Item> cont, List<int> filter) {
				foreach (Item i in cont)
					if (filter.Contains(i.info.itemid))
						return i;
				return null;
			}

			private bool CanAcceptItem(Item itemtomove) {
				//if (pipe.dest is VendingMachine) {
				//    bool result = pipe.destcont.inventory.CanAccept(itemtomove);
				//    pipe.debugstring = result.ToString() + (pipe.destcont.inventory.CanAcceptItem(itemtomove) == ItemContainer.CanAcceptResult.CanAccept).ToString();
				//    //return result;
				//}

				//if ( !((BaseEntity) pipe.destcont is Recycler) || (((BaseEntity) pipe.destcont is Recycler) && (i.position > 5))) {
				//FindPosition(Item item)

				return pipe.destcont.inventory.CanAcceptItem(itemtomove, -1) ==
				       ItemContainer.CanAcceptResult.CanAccept &&
				       pipe.destcont.inventory.CanAccept(itemtomove);
			}

			private Item FindItem() {

				foreach (Item i in pipe.sourcecont.inventory.itemList) {
					// for each item in source container
					if (pipe.filteritems.Count == 0 ||
					    pipe.filteritems.Contains(i.info.itemid)) {
						// if filter is empty or contains this item
						if (!(pipe.source is Recycler) ||
						    (pipe.source is Recycler && i.position > 5)) {
							// if source is recycler then only take items from the output

							if (pipe.dest is BaseOven) {
								// only send Burnable or Cookable to BaseOven
								if ((bool) ((Object) i.info
									    .GetComponent<ItemModBurnable>()) ||
								    (bool) ((Object) i.info
									    .GetComponent<ItemModCookable>()))
									return i;
							}
							else if (pipe.dest is Recycler) {
								// only send recyclables to recycler
								if ((Object) i.info.Blueprint !=
								    (Object) null)
									return i;
							}
							else {
								return i;
							}
						}
					}
				}

				return null;
			}

			private void TurnOnDest() {
				if (!pipe.autostarter)
					return;

				BaseEntity e = (BaseEntity) pipe.destcont;
				if (e is BaseOven) {
					e.GetComponent<BaseOven>().StartCooking();
				}
				else if (e is Recycler) {
					e.GetComponent<Recycler>().StartRecycling();
				}
				else if (pipe.destchild == 2) {
					BaseEntity ext =
						(BaseEntity) BaseNetworkable.serverEntities.Find(
							e.parentEntity.uid);
					if (ext != null)
						ext.GetComponent<MiningQuarry>().EngineSwitch(true);
				}
			}
		}

		private class jPipeSegChild : MonoBehaviour {

			public jPipe pipe;

			public static void Attach(BaseEntity entity, jPipe pipe) {
				jPipeSegChild n =
					entity.gameObject.AddComponent<jPipeSegChild>();
				n.pipe = pipe;
			}
		}

		private class jPipeSegChildLights : jPipeSegChild {

			public static void Attach(BaseEntity entity, jPipe pipe) {
				jPipeSegChildLights n =
					entity.gameObject.AddComponent<jPipeSegChildLights>();
				n.pipe = pipe;
			}
		}

		private class jPipeGroundWatch : MonoBehaviour {

			public HashSet<jPipe> connectedpipes = new HashSet<jPipe>();

			public static void Attach(BaseEntity entity, jPipe pipe) {

				jPipeGroundWatch n =
					entity.gameObject.GetComponent<jPipeGroundWatch>();

				if (n == null) {
					List<Component> comp = new List<Component>();

					foreach (var c in entity.GetComponents<Component>()) {
						if (c.GetType().ToString() ==
						    "Oxide.Plugins.JPipes.jPipeGroundWatch") {
							comp.Add(c);
						}
					}

					foreach (var c in comp)
						Destroy(c);

					n = entity.gameObject.AddComponent<jPipeGroundWatch>();
				}

				n.connectedpipes.Add(pipe);
			}
		}

		private class jPipeFilterStash : MonoBehaviour {

			private Action<BasePlayer> callback;
			private Action<Item> itemcallback;

			public BaseEntity entityOwner;

			public bool
				itemadded =
					false; // used to prevent stack overflow in CanAcceptItem

			public bool loading = true;

			public static jPipeFilterStash Attach(BaseEntity entity,
				Action<BasePlayer> callback,
				Action<Item> itemcallback) {
				jPipeFilterStash f =
					entity.gameObject.AddComponent<jPipeFilterStash>();
				f.callback = callback;
				f.itemcallback = itemcallback;
				f.entityOwner = entity;
				return f;
			}

			private void PlayerStoppedLooting(BasePlayer player) =>
				callback(player);

			public void UpdateFilter(Item item) => itemcallback(item);
		}

		private class jPipeVendingMachine : MonoBehaviour {
			public jPipe pipe;
			public VendingMachine vm;

			public static void Attach(VendingMachine entity, jPipe pipe) {
				jPipeVendingMachine n =
					entity.gameObject.AddComponent<jPipeVendingMachine>();
				n.vm = entity;
				n.pipe = pipe;
			}

			//private void CanAccept
		}

		private class jSyncBoxLogic : MonoBehaviour {

			public jSyncBox syncbox;

			public static jSyncBoxLogic Attach(BaseEntity entity,
				jSyncBox syncbox) {
				jSyncBoxLogic n =
					entity.gameObject.AddComponent<jSyncBoxLogic>();
				n.syncbox = syncbox;
				return n;
			}
		}

		private class jSyncBoxChild : MonoBehaviour {

			public jSyncBox syncbox;

			public static void Attach(BaseEntity entity, jSyncBox syncbox) {
				jSyncBoxChild n =
					entity.gameObject.AddComponent<jSyncBoxChild>();
				n.syncbox = syncbox;
			}
		}

		#endregion

		#region CUI elements

		private static CuiLabel CreateLabel(string text,
			int i,
			float rowHeight,
			TextAnchor align = TextAnchor.MiddleLeft,
			int fontSize = 15,
			string xMin = "0",
			string xMax = "1",
			string color = "1.0 1.0 1.0 1.0") {
			return new CuiLabel {
				Text = {
					Text = text, FontSize = fontSize, Align = align,
					Color = color
				},
				RectTransform = {
					AnchorMin = $"{xMin} {1 - rowHeight * i + i * .002f}",
					AnchorMax = $"{xMax} {1 - rowHeight * (i - 1) + i * .002f}"
				}
			};
		}

		private static CuiButton CreateButton(string command,
			float i,
			float rowHeight,
			int fontSize = 15,
			string content = "+",
			string xMin = "0",
			string xMax = "1",
			string color = "0.8 0.8 0.8 0.2",
			string textcolor = "1 1 1 1",
			float offset = -.005f) {
			return new CuiButton {
				Button = {Command = command, Color = color},
				RectTransform = {
					AnchorMin = $"{xMin} {1 - rowHeight * i + i * offset}",
					AnchorMax = $"{xMax} {1 - rowHeight * (i - 1) + i * offset}"
				},
				Text = {
					Text = content, FontSize = fontSize,
					Align = TextAnchor.MiddleCenter, Color = textcolor
				}
			};
		}

		private static CuiPanel CreatePanel(string anchorMin,
			string anchorMax,
			string color = "0 0 0 0") {
			return new CuiPanel {
				Image = {Color = color},
				RectTransform = {AnchorMin = anchorMin, AnchorMax = anchorMax}
			};
		}

		private static CuiElement CuiInputField(string parent = "Hud",
			string command = "",
			string text = "",
			int fontsize = 14,
			int charlimit = 100,
			string name = null) {

			if (string.IsNullOrEmpty(name))
				name = CuiHelper.GetGuid();
			CuiElement cuiElement = new CuiElement();
			cuiElement.Name = name;
			cuiElement.Parent = parent;
			cuiElement.Components.Add((ICuiComponent) new CuiInputFieldComponent {
				Text = "he", Align = TextAnchor.MiddleCenter,
				CharsLimit = charlimit, Command = command, FontSize = fontsize
			});
			cuiElement.Components.Add(
				(ICuiComponent) new CuiNeedsCursorComponent());

			return cuiElement;
		}

		private static CuiElement CuiLabelWithOutline(CuiLabel label,
			string parent = "Hud",
			string color = "0.15 0.15 0.15 0.43",
			string dist = "1.1 -1.1",
			bool usealpha = false,
			string name = null) {
			if (string.IsNullOrEmpty(name))
				name = CuiHelper.GetGuid();
			CuiElement cuiElement = new CuiElement();
			cuiElement.Name = name;
			cuiElement.Parent = parent;
			cuiElement.FadeOut = label.FadeOut;
			cuiElement.Components.Add((ICuiComponent) label.Text);
			cuiElement.Components.Add((ICuiComponent) label.RectTransform);
			cuiElement.Components.Add((ICuiComponent) new CuiOutlineComponent {
				Color = color,
				Distance = dist,
				UseGraphicAlpha = usealpha
			});
			return cuiElement;
		}

		private void ShowOverlayText(BasePlayer player,
			string text,
			string subtext = "",
			string textcolor = "1.0 1.0 1.0 1.0") {

			HideOverlayText(player);

			UserInfo userinfo = GetUserInfo(player);

			var elements = new CuiElementContainer();

			userinfo.overlay = elements.Add(
				CreatePanel("0.3 0.3", "0.7 0.35", "0 0 0 0")
			);

			elements.Add(
				CuiLabelWithOutline(
					new CuiLabel {
						Text = {
							Text = (subtext != "")
								? $"{text}\n<size=12>{subtext}</size>"
								: text,
							FontSize = 14, Align = TextAnchor.MiddleCenter,
							Color = textcolor
						},
						RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
						FadeOut = 2f
					},
					userinfo.overlay)
			);

			CuiHelper.AddUi(player, elements);

			userinfo.overlaytext = text;
			userinfo.overlaysubtext = subtext;
		}

		private void HideOverlayText(BasePlayer player, float delay = 0) {
			UserInfo userinfo = GetUserInfo(player);

			if (delay > 0) {
				string overlay = userinfo.overlay;
				string beforetext = userinfo.overlaytext;
				string beforesub = userinfo.overlaysubtext;
				timer.Once(delay, () => {
					if (!string.IsNullOrEmpty(overlay))
						CuiHelper.DestroyUi(player, overlay);
					if (beforetext == userinfo.overlaytext)
						userinfo.overlaytext = string.Empty;
					if (beforesub == userinfo.overlaysubtext)
						userinfo.overlaysubtext = string.Empty;
				});
			}
			else {
				if (!string.IsNullOrEmpty(userinfo.overlay))
					CuiHelper.DestroyUi(player, userinfo.overlay);
				userinfo.overlaytext = string.Empty;
				userinfo.overlaysubtext = string.Empty;
			}
		}

		private static CuiElement CreateItemIcon(string parent = "Hud",
			string anchorMin = "0 0",
			string anchorMax = "1 1",
			string imageurl = "",
			string color = "1 1 1 1") => new CuiElement {
			Parent = parent,
			Components = {
				new CuiRawImageComponent {
					Url = imageurl,
					Sprite =
						"assets/content/textures/generic/fulltransparent.tga",
					Color = color
				},
				new CuiRectTransformComponent {
					AnchorMin = anchorMin,
					AnchorMax = anchorMax
				},
			}
		};

		static string GetItemIconURL(string name, int size) {
			string url;
			if (ItemUrls.TryGetValue(name, out url)) {
				return string.Format(url, size);
			}

			return string.Empty;
		}

		#endregion

		#region Config

		private class permlevel {
			public int pipelimit;
			public int upgradelimit;
		}

		private void registerpermlevels() {
			foreach (var l in permlevels) {
				permission.RegisterPermission($"jpipes.level.{l.Key}", this);
			}
		}

		private static float maxpipedist;
		private static float minpipedist;
		private static int updaterate;
		private static bool drawflowarrows;
		private static bool animatearrows;
		private string pipecommandprefix;
		private string pipehotkey;
		private List<int> flowrates;
		private List<int> filtersizes;
		private bool nodecay;
		private bool xmaslights;

		private Dictionary<string, permlevel> permlevels =
			new Dictionary<string, permlevel>();


		protected override void LoadDefaultConfig() {
			PrintWarning("Creating a new configuration file");
			Config.Clear();
			LoadConfig();
		}

		private void LoadConfig() {

			maxpipedist = ConfigGet<float>("maxpipedist", 64);
			minpipedist = ConfigGet<float>("minpipedist", 2);
			updaterate = ConfigGet("updaterate", 2, (int x) => x > 0,
				"should be greater than 0");
			drawflowarrows = ConfigGet("drawflowarrows", true);
			animatearrows = ConfigGet("animatearrows", false);
			pipecommandprefix = ConfigGet("pipecommandprefix", "p");
			pipehotkey = ConfigGet("pipehotkey", "p");
			flowrates = ConfigGet("flowrates",
				new List<int>() {1, 5, 10, 30, 50},
				(List<int> l) => l.Count == 5, "should contain 5 integers");
			filtersizes = ConfigGet("filtersizes",
				new List<int>() {0, 6, 12, 18, 30},
				(List<int> l) =>
					l.Count == 5 && !l.Exists(x => x < 0 || x > 30),
				"should contain 5 integers with each val ue between 0 and 30");
			nodecay = ConfigGet("nodecay", true);
			xmaslights = ConfigGet("xmaslights", false);

			var permlevelsval = Config["permlevels"];

			if (permlevelsval != null) {

				IDictionary valueDictionary = (IDictionary) permlevelsval;
				Dictionary<string, object> levels =
					new Dictionary<string, object>();

				foreach (object key in valueDictionary.Keys) {

					IDictionary lvd = (IDictionary) valueDictionary[key];
					Dictionary<string, object> permvals =
						new Dictionary<string, object>();

					foreach (object lkey in lvd.Keys)
						permvals.Add((string) lkey, lvd[lkey]);

					permlevel npl = new permlevel();

					if (permvals.ContainsKey("pipelimit"))
						npl.pipelimit = (int) permvals["pipelimit"];
					else
						npl.pipelimit = 0;

					if (permvals.ContainsKey("upgradelimit"))
						npl.upgradelimit = (int) permvals["upgradelimit"];
					else
						npl.upgradelimit = -1;

					if (permvals.ContainsKey("pipelimit") ||
					    permvals.ContainsKey("upgradelimit"))
						permlevels.Add((string) key, npl);
				}
			}
			else {
				Config["permlevels"] = new Dictionary<string, object>();
				SaveConfig();
			}

			registerpermlevels();
		}

		// Config.Get<T>() with fallback, conditional warning, and saving
		// if val is null then set to fallback
		// if cond returns false then set to fallback (no saving) and print warning
		private T ConfigGet<T>(string configstring,
			T fallback,
			Func<T, bool> cond = null,
			string warning = null) {
			var val = Config.Get(configstring);
			if (val != null) {
				var valc = Config.ConvertValue<T>(val);
				if (cond != null && !cond(valc)) {
					if (warning != null)
						PrintWarning(
							$"Config Error: \"{configstring}\" {warning}.  Reverting to default value.");
					return fallback;
				}

				return valc;
			}

			Config[configstring] = fallback;
			SaveConfig();
			return fallback;
		}

		private bool IsNoDecayEnabled() {
			return nodecay;
		}

		#endregion

		#region Data

		// data structure for jPipeData.json file
		private class PipeSaveData {
			public Dictionary<ulong, jPipeData> p =
				new Dictionary<ulong, jPipeData>();

			public Dictionary<ulong, jSyncBoxData> s =
				new Dictionary<ulong, jSyncBoxData>();

			public PipeSaveData() { }
		}

		// data structure for pipe save data
		private class jPipeData {
			public bool e = true; // On/Off
			public int g; // grade
			public uint s; // source storage container id
			public uint d; // destination storage container id
			public uint cs; // source child storage container
			public uint cd; // destination child storage container
			public float h; // health
			public List<int> f; // filter item ids
			public bool st; // single stack mode
			public bool a; // auto starter
			public bool fs; // FurnaceSplitter On/Off
			public int fss; // FurnaceSplitter starter
			public ulong o; // Player ID of pipe owner
			public string on; // name of pipe owner

			public jPipeData() { }

			public void fromPipe(jPipe p) {
				e = p.isEnabled;
				g = ((int) p.pipegrade == -1) ? 0 : (int) p.pipegrade;
				s = p.source.net.ID;
				d = p.dest.net.ID;
				cs = p.sourcechild;
				cd = p.destchild;
				h = p.health;
				f = p.filteritems;
				st = p.singlestack;
				a = p.autostarter;
				fs = p.fsplit;
				fss = p.fsstacks;
				o = p.ownerid;
				on = p.ownername;
			}

			public void toPipe(jPipe p) {
				p.isEnabled = e;
				p.pipegrade = (BuildingGrade.Enum) g;

				p.source = (BaseEntity) BaseNetworkable.serverEntities.Find(s);
				p.dest = (BaseEntity) BaseNetworkable.serverEntities.Find(d);
				p.sourcecont = getchildcont(p.source, cs);
				p.destcont = getchildcont(p.dest, cd);
				p.sourcechild = cs;
				p.destchild = cd;
				p.health = h;
				if (f != null)
					p.filteritems = f;
				p.singlestack = st;
				p.autostarter = a;
				p.fsplit = fs;
				p.fsstacks = fss;
				p.ownerid = o;
				p.ownername = on;
			}

			public void setContainers(BaseEntity start, BaseEntity end) {
				s = setCont(start, out cs);
				d = setCont(end, out cd);
			}

			private uint setCont(BaseEntity cont, out uint cid) {

				ResourceExtractorFuelStorage stor =
					cont.GetComponent<ResourceExtractorFuelStorage>();

				if (stor != null) {
					switch (stor.panelName) {
						case "generic":
							cid = 1;
							break;
						case "fuelstorage":
							cid = 2;
							break;
						default:
							cid = 0;
							break;
					}

					return stor.parentEntity.uid;
				}

				cid = 0;
				return cont.net.ID;
			}
		}

		// data structure for pipe save data
		private class jSyncBoxData {
			public bool e = true; // On/Off
			public uint s; // source storage container id
			public uint d; // destination storage container id
			public float h; // health
			public ulong o; // Player ID of pipe owner
			public string on; // name of pipe owner

			public jSyncBoxData() { }

			public void fromSyncBox(jSyncBox p) {
				e = p.isEnabled;
			}

			public void toSyncBox(jSyncBox p) {
				p.isEnabled = e;
			}
		}

		private static void LoadData<T>(ref T data) => data =
			Interface.Oxide.DataFileSystem.ReadObject<T>("JPipes");

		private static void SaveData<T>(T data) =>
			Interface.Oxide.DataFileSystem.WriteObject("JPipes", data);

		#endregion

		#region Debug tools

		// Lists the ent's components and variables to player's chat

		//void ListComponentsDebug(BasePlayer player, BaseEntity ent) {

		//	List<string> lines = new List<string>();
		//	string s = "-----------------------------------------";
		//	string s = "<color=#80c5ff></color>";
		//	int limit = 1030;

		//	foreach (var c in ent.GetComponents<Component>()) {

		//		List<string> types = new List<string>();
		//		List<string> names = new List<string>();
		//		List<string> values = new List<string>();
		//		int typelength = 0;

		//		foreach (FieldInfo fi in c.GetType().GetFields()) {

		//			System.Object obj = (System.Object) c;
		//			string ts = fi.FieldType.Name;
		//			if (ts.Length > typelength)
		//				typelength = ts.Length;

		//			types.Add(ts);
		//			names.Add(fi.Name);

		//			var val = fi.GetValue(obj);
		//			if (val != null)
		//				values.Add(val.ToString());
		//			else
		//				values.Add("null");

		//		}

		//		if (s.Length > 0)
		//			s += "\n";
		//		s += types.Count > 0 ? "" : "";
		//		s += $" {c.GetType()} : {c.GetType().BaseType}";
		//		s += " <"+c.name+">\n";
		//		if (c.sharedMesh != null) s += "-> "+c.sharedMesh.triangles.Length.ToString()+"\n";

		//		for (int i = 0; i < types.Count; i++) {

		//			string ns = $"<color=#80c5ff> {types[i]}</color> {names[i]} = <color=#00ff00>{values[i]}</color>";

		//			if (s.Length + ns.Length >= limit) {
		//				lines.Add(s);
		//				s = "" + ns;
		//			} else {
		//				s += "\n" + ns;
		//			}
		//		}

		//		if (types.Count > 0) {
		//			s += "\n";
		//			lines.Add(s);
		//			s = string.Empty;
		//		}
		//	}

		//	lines.Add(s);

		//	foreach (string ls in lines)
		//		PrintToChat(player, ls);

		//}

		#endregion

	}

}

// --- End of file: JPipes.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/jail ---
// --- Original File Path: J/Jail/Jail.cs ---

using Facepunch;
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Jail", "Reneb / k1lly0u", "4.0.6")]
    [Description("Create a Jail system where all the naughty players go")]
    class Jail : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin ZoneManager, Spawns, Kits;

        private PrisonData prisonData;
        private PrisonerData prisonerData;
        private RestoreData restoreData;
        private DynamicConfigFile prisondata, prisonerdata, restoredata;

        private Dictionary<string, PrisonData.PrisonEntry> prisons = new Dictionary<string, PrisonData.PrisonEntry>();
        private Dictionary<ulong, PrisonerData.PrisonerEntry> prisoners = new Dictionary<ulong, PrisonerData.PrisonerEntry>();

        private static Jail ins;

        private LayerMask layerMask;

        const string UIJailTimer = "JailUI_TimeRemaining";
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            prisondata = Interface.Oxide.DataFileSystem.GetFile("Jail/prison_data");
            prisonerdata = Interface.Oxide.DataFileSystem.GetFile("Jail/prisoner_data");
            restoredata = Interface.Oxide.DataFileSystem.GetFile("Jail/restoration_data");

            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission("jail.canenter", this);
            permission.RegisterPermission("jail.admin", this);
        }

        private void OnServerInitialized()
        {
            LoadVariables();
            LoadData();
            ins = this;

            layerMask = (1 << 29);
            layerMask |= (1 << 18);
            layerMask = ~layerMask;            

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(1, () => OnPlayerConnected(player));
                return;
            }

            if (IsPrisoner(player))
            {
                double time = prisoners[player.userID].releaseDate - GrabCurrentTime();
                
                if (time <= 0)
                {
                    if (configData.AutoReleaseWhenExpired)
                        FreeFromJail(player);
                    else SendReply(player, msg("freetoleave", player.userID));
                }
                else
                {        
                    string prisonName = prisoners[player.userID].prisonName;

                    if (prisons.ContainsKey(prisonName))
                    {
                        PrisonData.PrisonEntry entry = prisons[prisonName];

                        if (!IsInZone(player, entry.zoneId) && !configData.AllowBreakouts)
                        {
                            object spawnLocation = GetSpawnLocation(prisonName, prisoners[player.userID].cellNumber);
                            if (spawnLocation is Vector3)
                            {
                                MovePosition(player, (Vector3)spawnLocation);                                
                            }
                        }
                        ShowJailTimer(player);
                    }                    
                }
            }
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null || !configData.DisablePrisonerDamage)
                return;

            BasePlayer player = info.InitiatorPlayer;
            if (player != null && IsPrisoner(player))
            {
                info.damageTypes = new Rust.DamageTypeList();
                info.HitEntity = null;
                info.HitMaterial = 0;
                info.PointStart = Vector3.zero;
            }
        }

        private void OnPlayerRespawned(BasePlayer player) => OnPlayerConnected(player);

        private object OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            if (player == null || player.IsAdmin)
                return null;

            if (IsPrisoner(player))
            {
                if (configData.BlockChat)
                {
                    if (configData.InmateChat)
                    {
                        string prisonName = prisoners[player.userID].prisonName;
                        foreach (KeyValuePair<ulong, PrisonerData.PrisonerEntry> prisoner in prisoners.Where(x => x.Value.prisonName == prisonName))
                        {
                            BasePlayer inmate = null;
                            IPlayer iPlayer = covalence.Players.FindPlayerById(prisoner.Key.ToString());
                            if (iPlayer != null && iPlayer.IsConnected)
                                inmate = iPlayer.Object as BasePlayer;

                            inmate?.SendConsoleCommand("chat.add", new object[] { 0, player.UserIDString, $"<color={(player.IsAdmin ? "#aaff55" : player.IsDeveloper ? "#fa5" : "#55AAFF")}>[Inmate Chat] {player.displayName}</color>: {message}" });
                        }
                    }
                    else SendReply(player, msg("chatblocked", player.userID));
                    return false;
                }
            }
            return null;
        }

        private object OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (player == null || player.IsAdmin || args == null)
                return null;

            if (IsPrisoner(player))
            {
                if (configData.CommandBlacklist.Any(x => x.StartsWith("/") ? x.Substring(1).ToLower() == command : x.ToLower() == command))
                {
                    SendReply(player, msg("blacklistcmd", player.userID));
                    return false;
                }
            }
            return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (player == null || player.IsAdmin || arg.Args == null)
                return null;

            if (IsPrisoner(player))
            {
                if (configData.CommandBlacklist.Any(x => arg.cmd.FullName.Contains(x.ToLower())))
                {
                    SendReply(player, msg("blacklistcmd", player.userID));
                    return false;
                }
            }

            return null;
        }

        private void OnServerSave() => SavePrisonerData();

        private void Unload()
        {
            foreach(BasePlayer player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, UIJailTimer);
        }
        #endregion

        #region Functions
        private void SendToPrison(BasePlayer player, string prisonName, double time)
        {
            int cellNumber = GetEmptyCell(prisonName);

            object spawnLocation = GetSpawnLocation(prisonName, cellNumber);
            if (spawnLocation is Vector3)
            {
                player.inventory.crafting.CancelAll();

                if (player.isMounted)                
                    player.GetMounted()?.DismountPlayer(player, false);                
                
                PrisonerData.PrisonerEntry entry = new PrisonerData.PrisonerEntry
                {
                    cellNumber = cellNumber,
                    prisonName = prisonName,
                    releaseDate = time + GrabCurrentTime()
                };

                prisoners[player.userID] = entry;
                restoreData.AddData(player);
                StripInventory(player);
                NextTick(() =>
                {                    
                    MovePosition(player, (Vector3)spawnLocation);
                    CheckIn(player, prisonName);
                });
            }
            SavePrisonerData();
        }

        private int GetEmptyCell(string prisonName)
        {
            int cellNumber = prisons[prisonName].occupiedCells.Where(x => x.Value == false).ToList().GetRandom().Key;
            prisons[prisonName].occupiedCells[cellNumber] = true;
            return cellNumber;
        }

        private void CheckIn(BasePlayer player, string prisonName)
        {
            if (player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(1, () => CheckIn(player, prisonName));
                return;
            }
            PrisonData.PrisonEntry entry = prisons[prisonName];
            if (configData.GiveInmateKits && !string.IsNullOrEmpty(entry.inmateKit))
                Kits.Call("GiveKit", player, entry.inmateKit);
                        
            ShowJailTimer(player);
        }

        private void FreeFromJail(BasePlayer player)
        {
            player.inventory.crafting.CancelAll();

            if (player.isMounted)
                player.GetMounted()?.DismountPlayer(player, false);

            PrisonerData.PrisonerEntry entry = prisoners[player.userID];
            prisons[entry.prisonName].occupiedCells[entry.cellNumber] = false;            
            
            CuiHelper.DestroyUi(player, UIJailTimer);
            prisoners.Remove(player.userID);

            restoreData.RestorePlayer(player, configData.ReturnHomeAfterRelease);

            if (!configData.ReturnHomeAfterRelease)
                MovePosition(player, CalculateFreePosition(entry.prisonName));

            SavePrisonerData();
        }
        #endregion

        #region Teleportation
        private object GetSpawnLocation(string prisonName, int cellNumber)
        {
            object success = Spawns.Call("GetSpawn", new object[] { prisons[prisonName].spawnFile, cellNumber });
            if (success is string)
            {
                PrintError($"There was a error retrieving spawn location. Cell #{cellNumber} at prison : {prisonName}");
                return null;
            }
            return (Vector3)success;
        }

        private Vector3 CalculateFreePosition(string prisonName)
        {
            PrisonData.PrisonEntry entry = prisons[prisonName];

            Vector3 exitPoint = new Vector3(entry.x, entry.y, entry.z) + (UnityEngine.Random.onUnitSphere * (entry.radius * 2));

            if (Physics.Raycast(exitPoint + (Vector3.up * 50), Vector3.down, out RaycastHit hitInfo, layerMask))
                exitPoint.y = hitInfo.point.y;

            float terrainHeight = TerrainMeta.HeightMap.GetHeight(exitPoint);
            if (exitPoint.y < terrainHeight)
                exitPoint.y = terrainHeight;

            return exitPoint;
        }

        private void PushBack(BasePlayer player, string prisonName)
        {
            PrisonData.PrisonEntry entry = prisons[prisonName];

            Vector3 prisonPos = new Vector3(entry.x, entry.y, entry.z);

            float direction = (prisonPos - player.transform.position).y;

            player.MovePosition(player.transform.position + (Quaternion.Euler(0, direction, 0) * (Vector3.back * 5)));
        }

        private void MovePosition(BasePlayer player, Vector3 destination)
        {
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "StartLoading");
            StartSleeping(player);
            player.MovePosition(destination);
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "ForcePositionTo", destination);
            if (player.net?.connection != null)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            try { player.ClearEntityQueue(null); } catch { }
            player.SendFullSnapshot();
        }

        private void StartSleeping(BasePlayer player)
        {
            if (player.IsSleeping())
                return;
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            if (!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);
            player.CancelInvoke("InventoryUpdate");
        }
        #endregion

        #region UI
        private class UI
        {
            static public CuiElementContainer Element(string panelName, string color, string aMin, string aMax)
            {
                CuiElementContainer NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        },
                        new CuiElement().Parent = "Hud",
                        panelName
                    }
                };
                return NewElement;
            }

            static public void Label(ref CuiElementContainer container, string panel, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
        }

        private void ShowJailTimer(BasePlayer player)
        {
            if (player != null)
            {
                CuiHelper.DestroyUi(player, UIJailTimer);
                if (prisoners.TryGetValue(player.userID, out PrisonerData.PrisonerEntry entry))
                {
                    double time = entry.releaseDate - GrabCurrentTime();
                    if (time > 0)
                    {
                        string clock = FormatTime(time);

                        CuiElementContainer container = UI.Element(UIJailTimer, "0.3 0.3 0.3 0.6", "0.4 0.965", "0.6 0.995");
                        UI.Label(ref container, UIJailTimer, ins.msg("remaining", player.userID) + clock, 14, "0 0", "1 1");
                        CuiHelper.AddUi(player, container);
                        timer.In(1, () => ShowJailTimer(player));
                    }
                    else
                    {
                        if (configData.AutoReleaseWhenExpired)
                            FreeFromJail(player);
                        else
                        {
                            CuiElementContainer container = UI.Element(UIJailTimer, "0.3 0.3 0.3 0.6", "0.35 0.965", "0.65 0.995");
                            UI.Label(ref container, UIJailTimer, ins.msg("freetoleave", player.userID), 14, "0 0", "1 1");
                            CuiHelper.AddUi(player, container);
                        }
                    }

                }
            }
        }

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            int days = dateDifference.Days;
            int hours = dateDifference.Hours;
            hours += (days * 24);
            int mins = dateDifference.Minutes;
            int secs = dateDifference.Seconds;
            if (hours > 0)
                return string.Format("{0:00}:{1:00}:{2:00}", hours, mins, secs);
            else return string.Format("{0:00}:{1:00}", mins, secs);
        }
        #endregion

        #region Zone Management
        private bool IsInZone(BasePlayer player, string zoneID)
        {
            if (ZoneManager == null) return false;
            return (bool)ZoneManager.Call("isPlayerInZone", zoneID, player);
        }

        private void OnEnterZone(string zoneID, BasePlayer player)
        {
            string prisonName = string.Empty;

            foreach(KeyValuePair<string, PrisonData.PrisonEntry> prison in prisons)
            {
                if (prison.Value.zoneId == zoneID)
                    prisonName = prison.Key;
            }

            if (!string.IsNullOrEmpty(prisonName))
            {
                if (!permission.UserHasPermission(player.UserIDString, "jail.canenter") && !IsPrisoner(player) && configData.BlockPublicAccessToPrisons)
                {
                    PushBack(player, prisonName);
                    SendReply(player, msg("trespassing", player.userID));
                }
                else SendReply(player, string.Format(msg("welcome", player.userID), prisonName, player.displayName));
            }
        }

        private void OnExitZone(string zoneID, BasePlayer player)
        {
            if (IsPrisoner(player))
            {
                PrisonerData.PrisonerEntry entry = prisoners[player.userID];

                if (prisons.ContainsKey(entry.prisonName) && zoneID == prisons[entry.prisonName].zoneId)
                {
                    if (configData.AllowBreakouts)
                    {
                        SendReply(player, string.Format(msg("escaped", player.userID), entry.prisonName));
                        prisons[entry.prisonName].occupiedCells[entry.cellNumber] = false;

                        if (configData.ReturnGearOnBreakout)
                            restoreData.RestorePlayer(player, false);

                        CuiHelper.DestroyUi(player, UIJailTimer);

                        prisoners.Remove(player.userID);
                    }
                    else
                    {
                        object spawnLocation = GetSpawnLocation(entry.prisonName, entry.cellNumber);
                        if (spawnLocation is Vector3)
                        {
                            MovePosition(player, (Vector3)spawnLocation);
                            SendReply(player, msg("noescape", player.userID));
                        }
                    }
                }
            }
        }
        #endregion

        #region Inventory Saving and Restoration
        public static void StripInventory(BasePlayer player)
        {
            List<Item> allItems = Pool.Get<List<Item>>();
            player.inventory.GetAllItems(allItems);

            for (int i = allItems.Count - 1; i >= 0; i--)
            {
                Item item = allItems[i];
                item.RemoveFromContainer();
                item.Remove();
            }
            
            Pool.FreeUnmanaged(ref allItems);
        }

        public class RestoreData
        {
            public Hash<ulong, PlayerData> restoreData = new Hash<ulong, PlayerData>();

            public void AddData(BasePlayer player)
            {
                restoreData[player.userID] = new PlayerData(player);
            }

            public void RemoveData(ulong playerId)
            {
                if (HasRestoreData(playerId))
                    restoreData.Remove(playerId);
            }

            public bool HasRestoreData(ulong playerId) => restoreData.ContainsKey(playerId);

            public void RestorePlayer(BasePlayer player, bool returnHome)
            {
                if (restoreData.TryGetValue(player.userID, out PlayerData playerData))
                {
                    StripInventory(player);

                    if (player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
                    {
                        ins.timer.Once(1, () => RestorePlayer(player, returnHome));
                        return;
                    }

                    ins.NextTick(() =>
                    {
                        playerData.SetStats(player);
                        if (returnHome)
                            ins.MovePosition(player, playerData.GetPosition());
                        RestoreAllItems(player, playerData);
                    });
                }
            }

            private void RestoreAllItems(BasePlayer player, PlayerData playerData)
            {
                if (player == null || !player.IsConnected)
                    return;

                if (RestoreItems(player, playerData.containerBelt, "belt") && RestoreItems(player, playerData.containerWear, "wear") && RestoreItems(player, playerData.containerMain, "main"))
                    RemoveData(player.userID);
            }

            private bool RestoreItems(BasePlayer player, ItemData[] itemData, string type)
            {
                ItemContainer container = type == "belt" ? player.inventory.containerBelt : type == "wear" ? player.inventory.containerWear : player.inventory.containerMain;

                for (int i = 0; i < itemData.Length; i++)
                {
                    Item item = CreateItem(itemData[i]);
                    item.position = itemData[i].position;
                    item.SetParent(container);
                }
                return true;
            }

            private Item CreateItem(ItemData itemData)
            {
                Item item = ItemManager.CreateByItemID(itemData.itemid, itemData.amount, itemData.skin);
                item.condition = itemData.condition;
                item.maxCondition = itemData.maxCondition;

                if (itemData.instanceData != null)
                    itemData.instanceData.Restore(item);

                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    if (!string.IsNullOrEmpty(itemData.ammotype))
                        weapon.primaryMagazine.ammoType = ItemManager.FindItemDefinition(itemData.ammotype);
                    weapon.primaryMagazine.contents = itemData.ammo;
                }

                FlameThrower flameThrower = item.GetHeldEntity() as FlameThrower;
                if (flameThrower != null)
                    flameThrower.ammo = itemData.ammo;


                if (itemData.contents != null)
                {
                    foreach (ItemData contentData in itemData.contents)
                    {
                        Item newContent = ItemManager.CreateByItemID(contentData.itemid, contentData.amount);
                        if (newContent != null)
                        {
                            newContent.condition = contentData.condition;
                            newContent.MoveToContainer(item.contents);
                        }
                    }
                }
                return item;
            }

            public class PlayerData
            {
                public float[] stats;
                public float[] position;
                public ItemData[] containerMain;
                public ItemData[] containerWear;
                public ItemData[] containerBelt;

                public PlayerData() { }

                public PlayerData(BasePlayer player)
                {
                    stats = GetStats(player);
                    position = GetPosition(player.transform.position);
                    containerBelt = GetItems(player.inventory.containerBelt).ToArray();
                    containerMain = GetItems(player.inventory.containerMain).ToArray();
                    containerWear = GetItems(player.inventory.containerWear).ToArray();
                }

                private IEnumerable<ItemData> GetItems(ItemContainer container)
                {
                    return container.itemList.Select(item => new ItemData
                    {
                        itemid = item.info.itemid,
                        amount = item.amount,
                        ammo = item.GetHeldEntity() is BaseProjectile ? (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents : item.GetHeldEntity() is FlameThrower ? (item.GetHeldEntity() as FlameThrower).ammo : 0,
                        ammotype = (item.GetHeldEntity() as BaseProjectile)?.primaryMagazine.ammoType.shortname ?? null,
                        position = item.position,
                        skin = item.skin,
                        condition = item.condition,
                        maxCondition = item.maxCondition,
                        instanceData = new ItemData.InstanceData(item),
                        contents = item.contents?.itemList.Select(item1 => new ItemData
                        {
                            itemid = item1.info.itemid,
                            amount = item1.amount,
                            condition = item1.condition
                        }).ToArray()
                    });
                }

                private float[] GetStats(BasePlayer player) => new float[] { player.health, player.metabolism.hydration.value, player.metabolism.calories.value };

                public void SetStats(BasePlayer player)
                {
                    player.health = stats[0];
                    player.metabolism.hydration.value = stats[1];
                    player.metabolism.calories.value = stats[2];
                    player.metabolism.SendChangesToClient();
                }

                private float[] GetPosition(Vector3 position) => new float[] { position.x, position.y, position.z };

                public Vector3 GetPosition() => new Vector3(position[0], position[1], position[2]);
            }

            public class ItemData
            {
                public int itemid;
                public ulong skin;
                public int amount;
                public float condition;
                public float maxCondition;
                public int ammo;
                public string ammotype;
                public int position;
                public InstanceData instanceData;
                public ItemData[] contents;

                public class InstanceData
                {
                    public int dataInt;
                    public int blueprintTarget;
                    public int blueprintAmount;

                    public InstanceData() { }
                    public InstanceData(Item item)
                    {
                        if (item.instanceData == null)
                            return;

                        dataInt = item.instanceData.dataInt;
                        blueprintAmount = item.instanceData.blueprintAmount;
                        blueprintTarget = item.instanceData.blueprintTarget;
                    }

                    public void Restore(Item item)
                    {
                        item.instanceData = new ProtoBuf.Item.InstanceData();
                        item.instanceData.blueprintAmount = blueprintAmount;
                        item.instanceData.blueprintTarget = blueprintTarget;
                        item.instanceData.dataInt = dataInt;
                    }
                }
            }
        }
        #endregion

        #region Helpers
        private double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private bool HasPermission(ulong playerId, string perm) => permission.UserHasPermission(playerId.ToString(), perm);

        private bool IsPrisoner(BasePlayer player) => prisoners.ContainsKey(player.userID);

        private bool HasEmptyCells(string prisonName) => prisons[prisonName].occupiedCells.Where(x => x.Value == false).Count() > 0;
        #endregion

        #region Commands
        [ChatCommand("leavejail")]
        private void cmdLeaveJail(BasePlayer player, string command, string[] args)
        {
            if (IsPrisoner(player))
            {
                double time = prisoners[player.userID].releaseDate - GrabCurrentTime();
                if (time <= 0)
                    FreeFromJail(player);
                else SendReply(player, string.Format(msg("timeremaining", player.userID), FormatTime(time)));
            }
        }

        [ChatCommand("jail")]
        private void cmdJail(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "jail.admin"))
                return;

            if (args.Length == 0)
            {
                SendReply(player, msg("help1", player.userID));
                SendReply(player, msg("help2", player.userID));
                SendReply(player, msg("help3", player.userID));
                SendReply(player, msg("help4", player.userID));
                SendReply(player, msg("help5", player.userID));
                SendReply(player, msg("help6", player.userID));
                return;
            }
            switch (args[0].ToLower())
            {
                case "create":
                    if (args.Length >= 4)
                    {
                        string name = args[1];                        
                        string kit = args.Length > 4 ? args[4] : "";

                        if (prisons.ContainsKey(name))
                        {
                            SendReply(player, msg("alreadyexists", player.userID));
                            return;
                        }

                        if (ValidateSpawnFile(args[2]) != null)
                        {
                            SendReply(player, msg("invalidspawns", player.userID));
                            return;
                        }

                        if (ValidateZoneID(args[3]) != null)
                        {
                            SendReply(player, msg("invalidzone", player.userID));
                            return;
                        }

                        if (!string.IsNullOrEmpty(kit) && ValidateKit(kit) != null)
                        {
                            SendReply(player, msg("invalidkit", player.userID));
                            return;
                        }

                        Vector3 location = Vector3.zero;
                        float radius = 20;
                        int spawnCount = 1;

                        object success = ZoneManager.Call("GetZoneLocation", args[3]);
                        if (success != null)
                            location = (Vector3)success;

                        success = ZoneManager.Call("GetZoneRadius", args[3]);
                        if (success == null)
                        {
                            success = ZoneManager.Call("GetZoneSize", args[3]);
                            if (success != null)
                            {
                                Vector3 v3 = (Vector3)success;
                                radius = v3.x;
                            }
                        }
                        else radius = Convert.ToSingle(success);

                        success = Spawns?.Call("GetSpawnsCount", args[2]);
                        if (success is int)
                            spawnCount = Convert.ToInt32(success);

                        prisons.Add(name, new PrisonData.PrisonEntry(args[3], args[2], kit, location, radius, spawnCount));
                        SendReply(player, msg("createsuccess", player.userID));
                        SavePrisonData();
                    }
                    else SendReply(player, msg("help1", player.userID));
                    return;

                case "remove":
                    if (args.Length == 2)
                    {
                        if (prisons.ContainsKey(args[1]))
                        {
                            FreePrisoners(args[1]);
                            prisons.Remove(args[1]);
                            SendReply(player, string.Format(msg("removesuccess", player.userID), args[1]));
                            SavePrisonData();
                        }
                    }
                    else SendReply(player, msg("help2", player.userID));
                    return;

                case "list":
                    SendReply(player, string.Format(msg("list", player.userID), prisons.Count));
                    foreach (KeyValuePair<string, PrisonData.PrisonEntry> prison in prisons)
                        SendReply(player, $"Name: {prison.Key} - Zone: {prison.Value.zoneId}, Location: {prison.Value.x} {prison.Value.y} {prison.Value.z}");
                    return;

                case "send":
                    if (args.Length >= 2)
                    {
                        BasePlayer inmate = null;
                        IPlayer iPlayer = covalence.Players.FindPlayer(args[1]);
                        if (iPlayer != null && iPlayer.IsConnected)
                            inmate = iPlayer.Object as BasePlayer;

                        if (inmate == null)
                        {
                            SendReply(player, string.Format(msg("noplayer", player.userID), args[1]));
                            return;
                        }

                        int time = int.MaxValue;
                        string reason = string.Empty;
                        string prisonName = string.Empty;

                        if (args.Length > 2)
                        {
                            if (!int.TryParse(args[2], out time))
                            {
                                SendReply(player, msg("notime", player.userID));
                                return;
                            }
                        }

                        if (args.Length > 3)
                            reason = args[3];

                        if (args.Length > 4)
                        {
                            if (!prisons.ContainsKey(args[4]))
                            {
                                SendReply(player, string.Format(msg("invalidprison", player.userID), args[4]));
                                return;
                            }
                            prisonName = args[4];
                        }
                        else prisonName = prisons.Keys.ToList().GetRandom();

                        SendToPrison(inmate, prisonName, time);
                        SavePrisonerData();

                        if (configData.BroadcastImprisonment)
                            PrintToChat(string.IsNullOrEmpty(reason) ? string.Format(msg("sent1"), inmate.displayName, FormatTime(time)) : string.Format(msg("sent2"), inmate.displayName, time, reason));
                        else
                        {
                            SendReply(inmate, string.IsNullOrEmpty(reason) ? string.Format(msg("sent3", inmate.userID), time) : string.Format(msg("sent4", inmate.userID), time ,reason));
                            SendReply(player, string.IsNullOrEmpty(reason) ? string.Format(msg("sent5", player.userID), inmate.displayName, time) : string.Format(msg("sent6", player.userID), inmate.displayName, time, reason));
                        }
                    }
                    else SendReply(player, msg("help4", player.userID));
                    return;
                case "free":
                    if (args.Length >= 2)
                    {
                        BasePlayer inmate = null;
                        IPlayer iPlayer = covalence.Players.FindPlayer(args[1]);
                        if (iPlayer != null && iPlayer.IsConnected)
                            inmate = iPlayer.Object as BasePlayer;

                        if (inmate == null)
                        {
                            SendReply(player, string.Format(msg("noplayer", player.userID), args[1]));
                            return;
                        }

                        if (!IsPrisoner(inmate))
                        {
                            SendReply(player, string.Format(msg("notinjail", player.userID), inmate.displayName));
                            return;
                        }

                        FreeFromJail(inmate);
                        SendReply(player, string.Format(msg("releasefromjail", player.userID), inmate.displayName));
                    }
                    else SendReply(player, msg("help5", player.userID));
                    return;
                case "clear":
                    if (args.Length == 2)
                    {
                        if (prisons.ContainsKey(args[1]))
                        {
                            FreePrisoners(args[1]);
                            SendReply(player, string.Format(msg("freedall", player.userID), args[1]));
                        }
                    }
                    else SendReply(player, msg("help6", player.userID));
                    return;
                default:
                    SendReply(player, msg("help1", player.userID));
                    SendReply(player, msg("help2", player.userID));
                    SendReply(player, msg("help3", player.userID));
                    SendReply(player, msg("help4", player.userID));
                    SendReply(player, msg("help5", player.userID));
                    SendReply(player, msg("help6", player.userID));
                    break;
            }
        }

        [ConsoleCommand("jail")]
        private void ccmdJail(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
                return;

            if (arg.Args == null || arg.Args.Length == 0)
            {                
                SendReply(arg, "jail list - List all jail names");
                SendReply(arg, "jail send <name or ID> <opt: time> \"<opt: reason>\" <opt: jailname> - Send a player to jail, with the option to specify time (in seconds), reason for incarceration and which jail to send them to");
                SendReply(arg, "jail free <name or ID> - Free a player from jail");
                SendReply(arg, "jail clear <jailname> - Free all inmates from the specified jail");
                return;
            }
            switch (arg.Args[0].ToLower())
            {                
                case "list":
                    SendReply(arg, $"Prison List ({prisons.Count} prison(s))");
                    foreach (KeyValuePair<string, PrisonData.PrisonEntry> prison in prisons)
                        SendReply(arg, $"Name: {prison.Key} - Zone: {prison.Value.zoneId}, Location: {prison.Value.x} {prison.Value.y} {prison.Value.z}");
                    return;
                case "send":
                    if (arg.Args.Length >= 2)
                    {
                        BasePlayer inmate = null;
                        IPlayer iPlayer = covalence.Players.FindPlayer(arg.Args[1]);
                        if (iPlayer != null && iPlayer.IsConnected)
                            inmate = iPlayer.Object as BasePlayer;

                        if (inmate == null)
                        {
                            SendReply(arg, string.Format("Unable to find a player with the name or ID : {0}", arg.Args[1]));
                            return;
                        }

                        int time = int.MaxValue;
                        string reason = string.Empty;
                        string prisonName = string.Empty;

                        if (arg.Args.Length > 2)
                        {
                            if (!int.TryParse(arg.Args[2], out time))
                            {
                                SendReply(arg, "You must enter a number for the amount of time (in seconds)");
                                return;
                            }
                        }

                        if (arg.Args.Length > 3)
                            reason = arg.Args[3];

                        if (arg.Args.Length > 4)
                        {
                            if (!prisons.ContainsKey(arg.Args[4]))
                            {
                                SendReply(arg, string.Format("{0} is not a valid prison name", arg.Args[4]));
                                return;
                            }
                            prisonName = arg.Args[4];
                        }
                        else prisonName = prisons.Keys.ToList().GetRandom();

                        SendToPrison(inmate, prisonName, time);
                        SavePrisonerData();

                        if (configData.BroadcastImprisonment)
                            PrintToChat(string.IsNullOrEmpty(reason) ? string.Format("{0} is doing {1} in jail", inmate.displayName, FormatTime(time)) : string.Format("{0} is doing {1} in jail for {2}", inmate.displayName, time, reason));
                        else
                        {
                            SendReply(inmate, string.IsNullOrEmpty(reason) ? string.Format("You have been sent to jail for {0}", time) : string.Format("You have been sent to jail for {0} because {1}", time, reason));
                            SendReply(arg, string.IsNullOrEmpty(reason) ? string.Format("You have sent {0} to jail for {1}", inmate.displayName, time) : string.Format("You have sent {0} to jail for {1} because {2}", inmate.displayName, time, reason));
                        }
                    }
                    else SendReply(arg, "/jail send <name or ID> <opt: time> \"<opt: reason>\" <opt: jailname> - Send a player to jail, with the option to specify time (in seconds), reason for incarceration and which jail to send them to");
                    return;
                case "free":
                    if (arg.Args.Length >= 2)
                    {
                        BasePlayer inmate = null;
                        IPlayer iPlayer = covalence.Players.FindPlayer(arg.Args[1]);
                        if (iPlayer != null && iPlayer.IsConnected)
                            inmate = iPlayer.Object as BasePlayer;

                        if (inmate == null)
                        {
                            SendReply(arg, string.Format("Unable to find a player with the name or ID : {0}", arg.Args[1]));
                            return;
                        }

                        if (!IsPrisoner(inmate))
                        {
                            SendReply(arg, string.Format("{0} is not in jail", inmate.displayName));
                            return;
                        }

                        FreeFromJail(inmate);
                        SendReply(arg, string.Format("You have released {0} from jail", inmate.displayName));
                    }
                    else SendReply(arg, "/jail free <name or ID> - Free a player from jail");
                    return;
                case "clear":
                    if (arg.Args.Length == 2)
                    {
                        if (prisons.ContainsKey(arg.Args[1]))
                        {
                            FreePrisoners(arg.Args[1]);
                            SendReply(arg, string.Format("You have successfully removed the prison: {0}", arg.Args[1]));
                        }
                    }
                    else SendReply(arg, "/jail clear <jailname> - Free all inmates from the specified jail");
                    return;
                default:                   
                    SendReply(arg, "jail list - List all jail names");

                    SendReply(arg, "jail send <name or ID> <opt: time> \"<opt: reason>\" <opt: jailname> - Send a player to jail, with the option to specify time (in seconds), reason for incarceration and which jail to send them to");
                    SendReply(arg, "jail free <name or ID> - Free a player from jail");
                    SendReply(arg, "jail clear <jailname> - Free all inmates from the specified jail");
                    break;
            }
        }

        private void FreePrisoners(string prisonName)
        {
            if (prisons.ContainsKey(prisonName))
            {
                KeyValuePair<ulong, PrisonerData.PrisonerEntry>[] release = prisoners.Where(x => x.Value.prisonName == prisonName).ToArray();
                if (release.Length > 0)
                {
                    for (int i = release.Length; i >= 0; i--)
                    {
                        BasePlayer inmate = null;
                        IPlayer iPlayer = covalence.Players.FindPlayerById(release[i].Key.ToString());
                        if (iPlayer != null && iPlayer.IsConnected)                        
                            inmate = iPlayer.Object as BasePlayer;
                        
                        if (inmate != null)
                            FreeFromJail(inmate);

                        else release[i].Value.releaseDate = 0;
                    }
                }
            }
        }

        public object ValidateSpawnFile(string name)
        {
            object success = Spawns?.Call("GetSpawnsCount", name);
            if (success is string)
                return false;
            else return null;
        }

        public object ValidateZoneID(string name)
        {
            object success = ZoneManager?.Call("CheckZoneID", name);
            if (name is string && !string.IsNullOrEmpty((string)name))
                return null;
            else return false;
        }

        public object ValidateKit(string name)
        {
            object success = Kits?.Call("isKit", name);
            if ((success is bool) && !(bool)success)               
                return false;
            return null;
        }
        #endregion

        #region Config        
        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Return prisoners to the position they were incarcerated at when released")]
            public bool ReturnHomeAfterRelease { get; set; }
            [JsonProperty(PropertyName = "Block chat for inmates")]
            public bool BlockChat { get; set; }
            [JsonProperty(PropertyName = "Allow chat between inmates (when chat is blocked)")]
            public bool InmateChat { get; set; }
            [JsonProperty(PropertyName = "Allow players to escape jail")]
            public bool AllowBreakouts { get; set; }
            [JsonProperty(PropertyName = "Return prisoners belongings if they escape jail")]
            public bool ReturnGearOnBreakout { get; set; }
            [JsonProperty(PropertyName = "Automatically release prisoners when their sentence has expired")]
            public bool AutoReleaseWhenExpired { get; set; }
            [JsonProperty(PropertyName = "Give prisoners a designated kit")]
            public bool GiveInmateKits { get; set; }
            [JsonProperty(PropertyName = "Disable damage dealt by prisoners")]
            public bool DisablePrisonerDamage { get; set; }
            [JsonProperty(PropertyName = "Broadcast player imprisonment globally")]
            public bool BroadcastImprisonment { get; set; }
            [JsonProperty(PropertyName = "Restrict public access to prison zones")]
            public bool BlockPublicAccessToPrisons { get; set; }
            [JsonProperty(PropertyName = "Blacklisted commands for prisoners")]
            public string[] CommandBlacklist { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                AllowBreakouts = false,
                BlockChat = false,
                InmateChat = true,
                AutoReleaseWhenExpired = true,
                BlockPublicAccessToPrisons = true,
                BroadcastImprisonment = true,
                DisablePrisonerDamage = true,
                GiveInmateKits = true,
                ReturnHomeAfterRelease = true,
                ReturnGearOnBreakout = true,
                CommandBlacklist = new string[] { "tp", "event", "tpa", "tpr", "s" }
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management
        private void SavePrisonData()
        {
            prisonData.prisons = prisons;
            prisondata.WriteObject(prisonData);
        }

        private void SavePrisonerData()
        {
            prisonerData.prisoners = prisoners;
            prisonerdata.WriteObject(prisonerData);
            restoredata.WriteObject(restoreData);
        }

        private void LoadData()
        {
            try
            {
                prisonData = prisondata.ReadObject<PrisonData>();
                prisons = prisonData.prisons;
            }
            catch
            {
                prisonData = new PrisonData();
            }
            try
            {
                prisonerData = prisonerdata.ReadObject<PrisonerData>();
                prisoners = prisonerData.prisoners;
            }
            catch
            {
                prisonerData = new PrisonerData();
            }
            try
            {
                restoreData = restoredata.ReadObject<RestoreData>();
            }
            catch
            {
                restoreData = new RestoreData();
            }
        }

        private class PrisonData
        {
            public Dictionary<string, PrisonEntry> prisons = new Dictionary<string, PrisonEntry>();

            public class PrisonEntry
            {
                public string zoneId, spawnFile, inmateKit;
                public float x, y, z, radius;
                public Dictionary<int, bool> occupiedCells = new Dictionary<int, bool>();

                public PrisonEntry() { }

                public PrisonEntry(string zoneId, string spawnFile, string inmateKit, Vector3 position, float radius, int spawnCount)
                {
                    this.zoneId = zoneId;
                    this.spawnFile = spawnFile;
                    this.inmateKit = inmateKit;
                    x = position.x;
                    y = position.y;
                    z = position.z;
                    this.radius = radius;

                    for (int i = 0; i < spawnCount; i++)                    
                        occupiedCells.Add(i, false);                    
                }
            }
        }

        private class PrisonerData
        {
            public Dictionary<ulong, PrisonerEntry> prisoners = new Dictionary<ulong, PrisonerEntry>();

            public class PrisonerEntry
            {
                public string prisonName;
                public int cellNumber;
                public double releaseDate;
            }
        }
        #endregion

        #region Localization
        private string msg(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId == 0U ? null : playerId.ToString());

        private Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["freetoleave"] = "You are free to leave jail! Type /leavejail when ready",
            ["remaining"] = "Remaining: ",
            ["trespassing"] = "You are trespassing on prison property!",
            ["welcome"] = "Welcome to {0} {1}",
            ["escaped"] = "You have broken out of {0} and are now on the run!",
            ["noescape"] = "There is no escape from this prison!",
            ["timeremaining"] = "You still have another {0} remaining on your sentence",
            ["help1"] = "/jail create <name> <spawnfile> <zoneId> <opt:kit> - Create a new jail",
            ["help2"] = "/jail remove <name> - Remove a jail",
            ["help3"] = "/jail list - List all jail names",
            ["help4"] = "/jail send <name or ID> <opt: time> \"<opt: reason>\" <opt: jailname> - Send a player to jail, with the option to specify time (in seconds), reason for incarceration and which jail to send them to",
            ["help5"] = "/jail free <name or ID> - Free a player from jail",
            ["help6"] = "/jail clear <jailname> - Free all inmates from the specified jail",
            ["alreadyexists"] = "There is already a jail with that name",
            ["invalidspawns"] = "Invalid spawnfile selected",
            ["invalidzone"] = "Invalid zone ID selected",
            ["invalidkit"] = "Invalid kit selected",
            ["createsuccess"] = "You have successfully created a new prison!",
            ["removesuccess"] = "You have successfully removed the prison: {0}",
            ["list"] = "Prison List ({0} prison(s))",
            ["noplayer"] = "Unable to find a player with the name or ID : {0}",
            ["notime"] = "You must enter a number for the amount of time (in seconds)",
            ["invalidprison"] = "{0} is not a valid prison name",
            ["sent1"] = "{0} is doing {1} in jail",
            ["sent2"] = "{0} is doing {1} in jail for {2}",
            ["sent3"] = "You have been sent to jail for {0}",
            ["sent4"] = "You have been sent to jail for {0} because {1}",
            ["sent5"] = "You have sent {0} to jail for {1}",
            ["sent6"] = "You have sent {0} to jail for {1} because {2}",
            ["notinjail"] = "{0} is not in jail",
            ["releasefromjail"] = "You have released {0} from jail",
            ["freedall"] = "You have successfully freed all the prisoners from : {0}",
            ["blacklistcmd"] = "You can not use that command whilst in jail",
            ["chatblocked"] = "Chat is blocked for inmates"
        };
        #endregion
    }
}


// --- End of file: Jail.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/junkyard-shredder ---
// --- Original File Path: J/JunkyardShredder/JunkyardShredder.cs ---

using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Junkyard Shredder", "Clearshot", "1.1.0")]
    [Description("Configure the items output by the junkyard shredder")]
    class JunkyardShredder : CovalencePlugin
    {
        private PluginConfig _config;
        private Dictionary<string, Dictionary<string, int>> _vanillaItemAmounts = new Dictionary<string, Dictionary<string, int>>();

        void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
        }

        void OnServerInitialized()
        {
            IEnumerable<MagnetLiftable> magnetLiftableList = BaseNetworkable.serverEntities
                .Where(e => !(e.GetComponent<MagnetLiftable>() == null))
                .Select(e => e.GetComponent<MagnetLiftable>());
            
            foreach (MagnetLiftable ml in magnetLiftableList)
            {
                var prefabName = ml.baseEntity.ShortPrefabName;
                if (!_vanillaItemAmounts.ContainsKey(prefabName))
                {
                    var shredRes = ml.shredResources.ToDictionary(i => i.itemDef.shortname, i => (int)i.amount);
                    _vanillaItemAmounts.Add(prefabName, shredRes);

                    if (!_config.shredderConfig.ContainsKey(prefabName))
                    {
                        _config.shredderConfig.Add(ml.baseEntity.ShortPrefabName, new ShredConfig {
                            vanilla = shredRes,
                            modified = shredRes
                        });
                    }
                    else
                        _config.shredderConfig[prefabName].vanilla = shredRes;
                }

                UpdateShredResources(ml, _config.shredderConfig[prefabName].modified);
            }

            Config.WriteObject(_config, true);
            Subscribe(nameof(OnEntitySpawned));
        }

        void OnEntitySpawned(BaseEntity ent)
        {
            if (ent == null) return;

            if (_config.shredderConfig.ContainsKey(ent.ShortPrefabName))
            {
                MagnetLiftable ml = ent.GetComponent<MagnetLiftable>();
                if (ml == null) return;

                UpdateShredResources(ml, _config.shredderConfig[ent.ShortPrefabName].modified);
            }
        }

        void Unload()
        {
            IEnumerable<MagnetLiftable> magnetLiftableList = BaseNetworkable.serverEntities
                .Where(e => !(e.GetComponent<MagnetLiftable>() == null))
                .Select(e => e.GetComponent<MagnetLiftable>());

            foreach (MagnetLiftable ml in magnetLiftableList)
            {
                var prefabName = ml.baseEntity.ShortPrefabName;
                if (_vanillaItemAmounts.ContainsKey(prefabName))
                {
                    UpdateShredResources(ml, _vanillaItemAmounts[prefabName]);
                }
            }
        }

        void UpdateShredResources(MagnetLiftable ml, Dictionary<string, int> list)
        {
            List<ItemAmount> itemAmts = new List<ItemAmount>();
            foreach (var item in list)
            {
                ItemDefinition itemDef = ItemManager.FindItemDefinition(item.Key);
                if (itemDef != null)
                {
                    itemAmts.Add(new ItemAmount(itemDef, item.Value));
                }
            }

            if (itemAmts.Count > 0)
            {
                ml.shredResources = itemAmts.ToArray();
            }
        }

        #region Config
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
            Config.WriteObject(_config, true);
        }

        private class PluginConfig
        {
            public Dictionary<string, ShredConfig> shredderConfig = new Dictionary<string, ShredConfig>();
        }

        private class ShredConfig
        {
            public Dictionary<string, int> vanilla;
            public Dictionary<string, int> modified;
        }
        #endregion
    }
}


// --- End of file: JunkyardShredder.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bypass-queue ---
// --- Original File Path: B/BypassQueue/BypassQueue.cs ---

using Network;

namespace Oxide.Plugins
{
    [Info("Bypass Queue", "Orange", "1.0.4")]
    public class BypassQueue : RustPlugin
    {
        private const string permUse = "bypassqueue.allow";

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }

        private object CanBypassQueue(Connection connection)
        {
            if (ConVar.Server.maxplayers == 0)
            {
                return null;
            }
        
            if (permission.UserHasPermission(connection.userid.ToString(), permUse) == true)
            {
                return true;
            }
            
            return null;
        }
    }
}


// --- End of file: BypassQueue.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/buoyant-supply-drops ---
// --- Original File Path: B/BuoyantSupplyDrops/BuoyantSupplyDrops.cs ---

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Buoyant Supply Drops", "Bazz3l", "1.0.2")]
    [Description("Allows supply drops to float on water")]
    class BuoyantSupplyDrops : RustPlugin
    {
        #region Config
        public PluginConfig _config;

        public PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                DetectionRate = 1,
            };
        }

        public class PluginConfig
        {
            public int DetectionRate;
        }
        #endregion

        #region Oxide
        protected override void LoadDefaultConfig() => Config.WriteObject(GetDefaultConfig(), true);

        void Init()
        {
            _config = Config.ReadObject<PluginConfig>();
        }

        void OnEntitySpawned(SupplyDrop supply)
        {
            if (supply == null) return;
            MakeBuoyant sfloat   = supply.gameObject.AddComponent<MakeBuoyant>();
            sfloat.buoyancyScale = 1f;
            sfloat.detectionRate = _config.DetectionRate;
        }
        #endregion

        #region Classes
        class MakeBuoyant : MonoBehaviour
        {
            public float buoyancyScale;
            public int detectionRate;
            private SupplyDrop _supplyDrop;

            void Awake()
            {
                _supplyDrop = GetComponent<SupplyDrop>();
                if(_supplyDrop == null) Destroy(this);
            }

            void FixedUpdate()
            {
                if(_supplyDrop == null)
                {
                    Destroy(this);
                    return;
                }
                
                if (UnityEngine.Time.frameCount % detectionRate == 0 && WaterLevel.Factor(_supplyDrop.WorldSpaceBounds().ToBounds()) > 0.65f)
                {
                    _supplyDrop.RemoveParachute();
                    _supplyDrop.MakeLootable();
                    BuoyancyComponent();
                    Destroy(this);
                }
            }

            void BuoyancyComponent()
            {
                Buoyancy buoyancy                  = gameObject.AddComponent<Buoyancy>();
                buoyancy.buoyancyScale             = buoyancyScale;
                buoyancy.rigidBody                 = gameObject.GetComponent<Rigidbody>();
                buoyancy.rigidBody.velocity        = Vector3.zero;
                buoyancy.rigidBody.angularVelocity = Vector3.zero;
                buoyancy.rigidBody.constraints     = RigidbodyConstraints.FreezePositionZ | RigidbodyConstraints.FreezeRotationZ | RigidbodyConstraints.FreezePositionX | RigidbodyConstraints.FreezeRotationX;
            }
        }
        #endregion
    }
}


// --- End of file: BuoyantSupplyDrops.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-chat-global-mute ---
// --- Original File Path: B/BetterChatGlobalMute/BetterChatGlobalMute.cs ---

// Requires: BetterChat

using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Better Chat Global Mute", "Whispers88", "1.0.3")]
    [Description("Allows players to toggle all Better Chat messages globally")]
    public class BetterChatGlobalMute : CovalencePlugin
    {
        [PluginReference]
        private Plugin BetterChat;

        private HashSet<string> GlobalChatMute = new HashSet<string>();

        void OnServerInitialized()
        {
            if (!BetterChat)
            {
                PrintWarning("BetterChat not detected");
            }

        }

        [Command("mutechat"), Permission("betterchatglobalmute.allowed")]
        private void MuteGlobalChat(IPlayer player, string command, string[] args)
        {
            GlobalChatMute.Add(player.Id);
            player.Reply(lang.GetMessage("Chat Muted", this, player.Id));
        }

        [Command("unmutechat"), Permission("betterchatglobalmute.allowed")]
        private void UnMuteGlobalChat(IPlayer player, string command, string[] args)
        {
            GlobalChatMute.Remove(player.Id);
            player.Reply(lang.GetMessage("Chat Unmuted", this, player.Id));
        }

        object OnBetterChat(Dictionary<string, object> messageData)
        {
            List<string> blockedReceivers = (List<string>)messageData["BlockedReceivers"];

            foreach (var player in covalence.Players.Connected)
            {
                if (GlobalChatMute.Contains(player.Id))
                {
                    blockedReceivers.Add(player.Id);
                }
            }

            messageData["BlockedReceivers"] = blockedReceivers;

            return messageData;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Chat Muted"] = "You have muted the Global Chat",
                ["Chat Unmuted"] = "You have unmuted the Global Chat"

            }, this, "en");
        }
    }
}


// --- End of file: BetterChatGlobalMute.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/boom-box-health ---
// --- Original File Path: B/BoomBoxHealth/BoomBoxHealth.cs ---

using Rust;

namespace Oxide.Plugins
{
    [Info("Boom Box Health", "Waldobert", "1.0.1")]
    [Description("Disables the playing-decay of the boombox")]


    class BoomBoxHealth : RustPlugin
    {

        void OnEntityTakeDamage(DeployableBoomBox entity, HitInfo info)
        {
            
            if (info.damageTypes.GetMajorityDamageType() == DamageType.Decay && entity.IsOn())
            {

                info.damageTypes.Scale(DamageType.Decay, 0.0f);

            }
            
        }

    }

}


// --- End of file: BoomBoxHealth.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bot-names ---
// --- Original File Path: B/BotNames/BotNames.cs ---

using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Bot Names", "birthdates", "1.0.6")]
    [Description("Ability to change bot names")]
    public class BotNames : RustPlugin
    {
        #region Hooks

        private void Init() => LoadConfig();

        private void OnEntitySpawned(BasePlayer Player)
        {
            if (!Player.IsNpc && Player.userID.IsSteamId()) return;
            Player.displayName = _config.Names.GetRandom();
            Player.EnablePlayerCollider();
        }

        #endregion

        #region Configuration

        private ConfigFile _config;

        private class ConfigFile
        {
            public readonly List<string> Names = new List<string>()
            {
                ":(",
                ":D"
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if(_config == null)
            {
                LoadDefaultConfig();
            }
        }
    
        protected override void LoadDefaultConfig()
        {
            _config = new ConfigFile();
            PrintWarning("Default configuration has been loaded.");
        }
    
        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion
    }
}
//Generated with birthdates' Plugin Maker


// --- End of file: BotNames.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bed-name-logs ---
// --- Original File Path: B/BedNameLogs/BedNameLogs.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;
using Oxide.Core.Libraries;


namespace Oxide.Plugins
{

    [Info("Bed Name Logs", "Zeeuss", "0.1.3")]
    [Description("A logger for beds and sleeping bags renames.")]

    public class BedNameLogs : RustPlugin
    {

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                //FORMAT: XYZ playername playerid renamed sleeping bag from previous to current
                ["SleepingBagRename"] = "{0} {1} ({2}) renamed sleeping bag from {3} to {4}",
                ["BedRename"] = "{0} {1} ({2}) renamed bed from {3} to {4}"

            }, this);
        }
        #endregion

        #region Json
        private const string DiscordJson = @"{
            ""embeds"":[{
                    ""color"": ""${discord.embed.color}"",
                    ""fields"": [
                    {
                        ""name"": ""${player.field.name}"",
                        ""value"": ""${player}""
                    },
                    {
                        ""name"": ""${message.field.name}"",
                        ""value"": ""${message}""
                    }
                ]
            }]
        }";
        #endregion

        #region Hooks

        void CanRenameBed(BasePlayer player, SleepingBag bed, string bedName)
        {

            if (player == null)
            {
                return;
            }


            if (bed == null)
            {
                return;
            }


            string xyzpos = $"X: {Math.Round((decimal)bed.ServerPosition.x)} Y: {Math.Round((decimal)bed.ServerPosition.y)} Z: {Math.Round((decimal)bed.ServerPosition.z)}";
            string playerName = $"{player?.displayName}";
            string playerID = $"{player?.UserIDString}";
            string bedPrevious = $"{bed?.niceName}";
            string bedCurrent = $"{bedName}";

            if (configData == null)
            {
                LoadConfigVariables();
            }

            if (bed?.ShortPrefabName == "sleepingbag_leather_deployed")
            {
                LogToFile("Renames", String.Format(lang.GetMessage("SleepingBagRename", this, null), xyzpos, playerName, playerID, bedPrevious, bedCurrent), this, true);

                if (configData.dcLogs != true)
                    return;

                logToDc(player, xyzpos, playerName, playerID, bedPrevious, bedCurrent, "SleepingBagRename");
            }
            else if (bed?.ShortPrefabName == "bed_deployed")
            {
                LogToFile("Renames", String.Format(lang.GetMessage("BedRename", this, null), xyzpos, playerName, playerID, bedPrevious, bedCurrent), this, true);

                if (configData.dcLogs != true)
                    return;

                logToDc(player, xyzpos, playerName, playerID, bedPrevious, bedCurrent, "BedRename");
                

            }

        }
        #endregion

        #region Config
        private ConfigData configData;
        class ConfigData
        {

            [JsonProperty(PropertyName = "log to discord?")]
            public bool dcLogs = true;
            [JsonProperty(PropertyName = "Discord webhook url")]
            public string discordWebHookURL = "Your discord webhook URL";

        }

        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
                return false;
            }
            SaveConfig(configData);
            return true;
        }

        protected override void LoadDefaultConfig()
        {
            configData = new ConfigData();
            SaveConfig(configData);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }
        #endregion

        #region Helper
        private void logToDc(BasePlayer player, string xyzpos, string playerName, string playerID, string bedPrevious, string bedCurrent, string langM)
        {


            string content = DiscordJson
                            .Replace("${discord.embed.color}", "16538684")
                            .Replace("${player.field.name}", "Player")
                            .Replace("${player}", $"{player?.displayName} ({player?.UserIDString})")
                            .Replace("${message.field.name}", "Rename Log")
                            .Replace("${message}", String.Format(lang.GetMessage(langM, this, null), xyzpos, playerName, playerID, bedPrevious, bedCurrent));

            if (configData == null)
            {
                LoadConfigVariables();
            }

            if (!configData.discordWebHookURL.Contains("/api/webhooks") || string.IsNullOrEmpty(configData.discordWebHookURL.ToString()) || content == null)
            {
                return;
            }

            webrequest.Enqueue(configData.discordWebHookURL, content, (code, response) =>
            {

                if (code != 204)
                {
                    Puts($"Discord.com responded with code {code}");
                }
            }, this, RequestMethod.POST, new Dictionary<string, string> { ["Content-Type"] = "application/json" });



        }
        #endregion

    }
}

// --- End of file: BedNameLogs.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/backpack-upgrader ---
// --- Original File Path: B/BackpackUpgrader/BackpackUpgrader.cs ---

using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Backpack Upgrader", "waayne", "1.0.2")]
    [Description("Allows players to upgrade their backpacks.")]
    internal class BackpackUpgrader : CovalencePlugin
    {
        private const string UPGRADE_PERMISSION = "backpackupgrader.upgrade";
        private const string SET_PERMISSION = "backpackupgrader.set";
        private const string BACKPACKS_PERMISSION = "backpacks.use";
        
        private const string UPGRADE_COMMAND = "bpupgrade";
        private const string SET_COMMAND = "bpset";
        
        private const int BACKPACKS_ROWS = 7;

        [PluginReference] private Plugin Backpacks;

        private void Init()
        {
            permission.RegisterPermission(UPGRADE_PERMISSION, this);
            permission.RegisterPermission(SET_PERMISSION, this);

            AddCovalenceCommand(UPGRADE_PERMISSION, nameof(UpgradeCommand), UPGRADE_PERMISSION);
            AddCovalenceCommand(SET_PERMISSION, nameof(SetCommand), SET_PERMISSION);

            AddCovalenceCommand(UPGRADE_COMMAND, nameof(UpgradeCommand), UPGRADE_PERMISSION);
            AddCovalenceCommand(SET_COMMAND, nameof(SetCommand), SET_PERMISSION);
        }

        private void OnServerInitialized(bool initial)
        {
            if (Backpacks == null || !Backpacks.IsLoaded)
                LogError(lang.GetMessage("BackpacksNotFound", this));
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BackpacksNotFound"] = "Backpacks is not loaded, get it at https://umod.org/plugins/backpacks",
                ["HelpSet"] = "Use backpackupgrader.set <name/id> <rows> to set a player's backpack to x rows.",
                ["HelpUpgrade"] = "Use backpackupgrader.upgrade <name/id> to upgrade a player's backpack.",
                ["Set"] = "Set {0}'s backpack to {1}x rows.",
                ["Upgraded"] = "Upgraded {0}'s backpack to {1}x rows."
            }, this);
        }

        private void OnNewSave(string filename)
        {
            foreach (IPlayer player in players.All)
            {
                for (var row = 1; row <= BACKPACKS_ROWS; row++)
                {
                    permission.RevokeUserPermission(player.Id, GetPermissionFromLevel(row));
                }
            }
        }

        private void UpgradeCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length <= 0)
            {
                player.Reply(lang.GetMessage("HelpUpgrade", this, player.Id));
                return;
            }

            IPlayer target = players.FindPlayer(args[0]);

            if (target == null)
                return;

            for (var row = 1; row <= BACKPACKS_ROWS; row++)
            {
                string perm = GetPermissionFromLevel(row);
                if (!target.HasPermission(perm))
                {
                    target.GrantPermission(perm);
                    player.Reply(string.Format(lang.GetMessage("Upgraded", this, player.Id), target.Name, row));
                    return;
                }
            }
        }

        private void SetCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length <= 1)
            {
                player.Reply(lang.GetMessage("HelpSet", this, player.Id));
                return;
            }

            IPlayer target = players.FindPlayer(args[0]);

            if (target == null)
                return;

            int newRows = int.Parse(args[1]);

            for (var row = 1; row <= BACKPACKS_ROWS; row++)
            {
                string perm = GetPermissionFromLevel(row);
                if (row <= newRows)
                {
                    if (!target.HasPermission(perm))
                        target.GrantPermission(perm);
                }
                else
                {
                    if (target.HasPermission(perm))
                        target.RevokePermission(perm);
                }
            }

            player.Reply(string.Format(lang.GetMessage("Set", this, player.Id), target.Name, newRows));
        }

        private static string GetPermissionFromLevel(int row)
        {
            return row == 1 ? BACKPACKS_PERMISSION : BACKPACKS_PERMISSION + "." + row;
        }
    }
}

// --- End of file: BackpackUpgrader.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/boombox-durability ---
// --- Original File Path: B/BoomboxDurability/BoomboxDurability.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Boombox Durability", "WhiteThunder", "2.0.1")]
    [Description("Allows configuring deployable boomboxes to decay while playing.")]
    internal class BoomboxDurability : CovalencePlugin
    {
        #region Fields

        private const string PermissionProfilePrefix = "boomboxdurability";
        private const float VanillaConditionLossRate = 0;

        private Configuration _pluginConfig;

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginConfig.Init(this);

            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var boomBox = entity as DeployableBoomBox;
                if (boomBox == null)
                    continue;

                OnEntitySpawned(boomBox);
            }

            Subscribe(nameof(OnEntitySpawned));
        }

        private void OnEntitySpawned(DeployableBoomBox boomBox)
        {
            if (boomBox.IsStatic)
                return;

            boomBox.BoxController.ConditionLossRate = GetPlayerDecayRate(boomBox.OwnerID);
        }

        private void Unload()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var boomBox = entity as DeployableBoomBox;
                if (boomBox == null || boomBox.IsStatic)
                    continue;

                boomBox.BoxController.ConditionLossRate = VanillaConditionLossRate;
            }
        }

        #endregion

        #region Configuration

        public float GetPlayerDecayRate(ulong userId)
        {
            if (userId == 0 || (_pluginConfig.ProfilesRequiringPermission?.Length ?? 0) == 0)
                return _pluginConfig.DefaultDecayRate;

            var userIdString = userId.ToString();

            for (var i = _pluginConfig.ProfilesRequiringPermission.Length - 1; i >= 0; i--)
            {
                var profile = _pluginConfig.ProfilesRequiringPermission[i];
                if (profile.Permission != null && permission.UserHasPermission(userIdString, profile.Permission))
                    return profile.DecayRate;
            }

            return _pluginConfig.DefaultDecayRate;
        }

        private class DurabilityProfile
        {
            [JsonProperty("PermissionSuffix")]
            public string PermissionSuffix;

            [JsonProperty("DecayRate")]
            public float DecayRate;

            [JsonIgnore]
            public string Permission;
        }

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("DefaultDecayRate")]
            public float DefaultDecayRate = 0.025f;

            [JsonProperty("ProfilesRequiringPermission")]
            public DurabilityProfile[] ProfilesRequiringPermission = new DurabilityProfile[]
            {
                new DurabilityProfile()
                {
                    PermissionSuffix = "fastdecay",
                    DecayRate = 0.111f,
                },
                new DurabilityProfile()
                {
                    PermissionSuffix = "slowdecay",
                    DecayRate = 0.007f,
                },
                new DurabilityProfile()
                {
                    PermissionSuffix = "nodecay",
                    DecayRate = 0,
                },
            };

            public void Init(BoomboxDurability pluginInstance)
            {
                if (ProfilesRequiringPermission == null)
                    return;

                foreach (var profile in ProfilesRequiringPermission)
                {
                    if (!string.IsNullOrEmpty(profile.PermissionSuffix))
                    {
                        profile.Permission = $"{PermissionProfilePrefix}.{profile.PermissionSuffix}";
                        pluginInstance.permission.RegisterPermission(profile.Permission, pluginInstance);
                    }
                }
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Boilerplate

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion
    }
}


// --- End of file: BoomboxDurability.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/building-restriction ---
// --- Original File Path: B/BuildingRestriction/BuildingRestriction.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Building Restriction", "Wulf/lukespragg", "1.5.8")]
    [Description("Restricts building height, building in water, number of foundations, and more")]
    public class BuildingRestriction : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Restrict build height (true/false)")]
            public bool RestrictBuildHeight { get; set; } = true;

            [JsonProperty(PropertyName = "Maximum build height")]
            public int MaxBuildHeight { get; set; } = 5;

            [JsonProperty(PropertyName = "Restrict foundations (true/false)")]
            public bool RestrictFoundations { get; set; } = true;

            [JsonProperty(PropertyName = "Maximum foundations")]
            public int MaxFoundations { get; set; } = 16;

            [JsonProperty(PropertyName = "Maximum triangle foundations")]
            public int MaxTriFoundations { get; set; } = 24;

            [JsonProperty(PropertyName = "Restrict tool cupboards (true/false)")]
            public bool RestrictToolCupboards { get; set; } = true;

            [JsonProperty(PropertyName = "Maximum tool cupboards")]
            public int MaxToolCupboards { get; set; } = 5;

            [JsonProperty(PropertyName = "Restrict water depth (true/false)")]
            public bool RestrictWaterDepth { get; set; } = true;

            [JsonProperty(PropertyName = "Maximum water depth")]
            public double MaxWaterDepth { get; set; } = 0.1;

            [JsonProperty(PropertyName = "Refund resources when restricted")]
            public bool RefundResources { get; set; } = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}";
                LogWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}.json");
                Config.WriteObject(config, false, $"{configPath}_invalid.json");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["MaxBuildHeight"] = "You have reached the max building height! ({0} building blocks)",
                ["MaxFoundations"] = "You have reached the max foundations allowed! ({0} foundations)",
                ["MaxTriFoundations"] = "You have reached the max triangle foundations allowed! ({0} foundations)",
                ["MaxWaterDepth"] = "You are not allowed to build in water!"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string foundation = "assets/prefabs/building core/foundation/foundation.prefab";
        private const string triFoundation = "assets/prefabs/building core/foundation.triangle/foundation.triangle.prefab";
        private const string permBypass = "buildingrestriction.bypass";

        private readonly Dictionary<ulong, List<BuildingBlock>> buildingIds = new Dictionary<ulong, List<BuildingBlock>>();
        private readonly Dictionary<ulong, List<PlayerNameID>> toolCupboards = new Dictionary<ulong, List<PlayerNameID>>();
        private readonly List<string> allowedBuildingBlocks = new List<string>
        {
            "assets/prefabs/building core/floor/floor.prefab",
            "assets/prefabs/building core/floor.frame/floor.frame.prefab",
            "assets/prefabs/building core/floor.triangle/floor.triangle.prefab",
            "assets/prefabs/building core/roof/roof.prefab",
            "assets/prefabs/building core/wall.low/wall.low.prefab"
        };

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permBypass, this);

            FindStructures();
            FindToolCupboards();
        }

        private void FindStructures()
        {
            Puts("Searching for structures, this may take awhile...");

            List<BuildingBlock> foundationBlocks = Resources.FindObjectsOfTypeAll<BuildingBlock>().Where(b => b.PrefabName == foundation || b.PrefabName == triFoundation).ToList();
            foreach (BuildingBlock block in foundationBlocks.Where(b => !buildingIds.ContainsKey(b.buildingID)))
            {
                IEnumerable<BuildingBlock> structure = UnityEngine.Object.FindObjectsOfType<BuildingBlock>().Where(b => b.buildingID == block.buildingID && b.PrefabName == foundation || b.PrefabName == triFoundation);
                buildingIds[block.buildingID] = structure.ToList();
            }

            Puts($"Search complete! Found {buildingIds.Count} structures");
        }

        private void FindToolCupboards()
        {
            Puts("Searching for tool cupboards, this may take awhile...");

            BuildingPrivlidge[] cupboards = UnityEngine.Object.FindObjectsOfType<BuildingPrivlidge>();
            foreach (BuildingPrivlidge cupboard in cupboards.Where(c => !toolCupboards.ContainsKey(c.net.ID.Value)))
            {
                toolCupboards.Add(cupboard.net.ID.Value, cupboard.authorizedPlayers);
            }

            Puts($"Search complete! Found {toolCupboards.Count} tool cupboards");
        }

        #endregion Initialization

        #region Refund Handling

        private void RefundResources(BasePlayer player, BuildingBlock buildingBlock)
        {
            foreach (ItemAmount item in buildingBlock.blockDefinition.grades[(int)buildingBlock.grade].CostToBuild())
            {
                Item newItem = ItemManager.CreateByItemID(item.itemid, (int)item.amount);
                if (newItem != null)
                {
                    player.inventory.GiveItem(newItem);
                    player.Command("note.inv", item.itemid, item.amount);
                }
            }
        }

        #endregion Refund Handling

        #region Building/Water Handling

        private void OnEntityBuilt(Planner planner, GameObject go)
        {
            BasePlayer basePlayer = planner?.GetOwnerPlayer();
            if (basePlayer == null)
            {
                return;
            }

            IPlayer player = basePlayer.IPlayer;
            if (player == null || player.HasPermission(permBypass))
            {
                return;
            }

            BaseEntity entity = go.ToBaseEntity();
            BuildingBlock buildingBlock = entity?.GetComponent<BuildingBlock>();
            if (buildingBlock == null)
            {
                return;
            }

#if DEBUG
            player.Message($"Water depth from base block: {buildingBlock.WaterFactor()}");
            player.Message($"Maximum water depth: {config.MaxWaterDepth}");
#endif
            if (config.RestrictWaterDepth && buildingBlock.WaterFactor() >= config.MaxWaterDepth)
            {
                if (config.RefundResources)
                {
                    RefundResources(basePlayer, buildingBlock);
                }

                buildingBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                Message(player, "MaxWaterDepth", config.MaxWaterDepth);
                return;
            }

            string blockName = buildingBlock.PrefabName;
            uint buildingId = buildingBlock.buildingID;
            if (buildingIds.ContainsKey(buildingId))
            {
                List<BuildingBlock> connectingStructure = buildingIds[buildingBlock.buildingID];
                if (config.RestrictFoundations && blockName == foundation || blockName == triFoundation)
                {
                    int foundationCount = GetCountOf(connectingStructure, foundation);
                    int triFoundationCount = GetCountOf(connectingStructure, triFoundation);
#if DEBUG
                    player.Message($"Foundation count: {foundationCount}");
                    player.Message($"Triangle foundation count: {triFoundationCount}");
#endif

                    if (blockName == foundation && foundationCount > config.MaxFoundations)
                    {
                        if (config.RefundResources)
                        {
                            RefundResources(basePlayer, buildingBlock);
                        }

                        buildingBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                        Message(player, "MaxFoundations", config.MaxFoundations);
                    }
                    else if (blockName == triFoundation && triFoundationCount > config.MaxTriFoundations)
                    {
                        if (config.RefundResources)
                        {
                            RefundResources(basePlayer, buildingBlock);
                        }

                        buildingBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                        Message(player, "MaxTriFoundations", config.MaxTriFoundations);
                    }
                    else
                    {
                        List<BuildingBlock> structure = new List<BuildingBlock>(connectingStructure) { buildingBlock };
                        buildingIds[buildingId] = structure;
                    }
                }
                else
                {
                    if (config.RestrictBuildHeight && !allowedBuildingBlocks.Contains(blockName))
                    {
                        BuildingBlock firstFoundation = null;
                        foreach (BuildingBlock block in connectingStructure)
                        {
                            if (block.name.Contains(triFoundation) || block.name.Contains(foundation))
                            {
                                firstFoundation = block;
                                break;
                            }
                        }

                        if (firstFoundation != null)
                        {
                            float height = (float)Math.Round(buildingBlock.transform.position.y - firstFoundation.transform.position.y, 0, MidpointRounding.AwayFromZero);
                            int maxHeight = config.MaxBuildHeight * 3;
#if DEBUG
                            player.Message($"Maximum building height: {maxHeight}");
                            player.Message($"Attempted building height: {height}");
#endif

                            if (height > maxHeight)
                            {
                                if (config.RefundResources)
                                {
                                    RefundResources(basePlayer, buildingBlock);
                                }

                                buildingBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                                Message(player, "MaxBuildHeight", config.MaxBuildHeight);
                            }
                        }
                    }
                }
            }
            else
            {
                List<BuildingBlock> structure = new List<BuildingBlock> { buildingBlock };
                buildingIds[buildingId] = structure;
            }
        }

        private void HandleRemoval(BaseCombatEntity entity)
        {
            BuildingBlock buildingBlock = entity?.GetComponent<BuildingBlock>();
            if (buildingBlock == null)
            {
                return;
            }

            string blockName = buildingBlock.PrefabName;
            if (blockName == null || blockName != foundation && blockName != triFoundation)
            {
                return;
            }

            if (buildingIds.ContainsKey(buildingBlock.buildingID))
            {
                List<BuildingBlock> blockList = buildingIds[buildingBlock.buildingID].Where(b => b == buildingBlock).ToList();
                foreach (BuildingBlock block in blockList)
                {
                    buildingIds[buildingBlock.buildingID].Remove(buildingBlock);
                }
            }
        }

        private void OnStructureDemolish(BaseCombatEntity entity) => HandleRemoval(entity);

        #endregion Building/Water Handling

        #region Tool Cupboard Handling

        private void OnItemDeployed(Deployer deployer, BaseEntity entity)
        {
            BuildingPrivlidge cupboard = entity as BuildingPrivlidge;
            if (cupboard == null)
            {
                return;
            }

            BasePlayer player = deployer.ToPlayer();
            if (config.RestrictToolCupboards && player != null)
            {
                IEnumerable<KeyValuePair<ulong, List<PlayerNameID>>> cupboards = toolCupboards.Where(c => c.Value.Contains(new PlayerNameID { userid = player.userID }));

                if (cupboards.Count() > config.MaxToolCupboards)
                {
                    cupboard.Kill();
                    Message(player.IPlayer, "MaxToolCupboards", config.MaxToolCupboards);
                }
            }
            else
            {
                if (!toolCupboards.ContainsKey(cupboard.net.ID.Value))
                {
                    toolCupboards.Add(cupboard.net.ID.Value, cupboard.authorizedPlayers);
                }
            }
        }

        private void OnEntityDeath(BaseCombatEntity entity)
        {
            BuildingPrivlidge cupboard = entity as BuildingPrivlidge;
            if (cupboard != null && toolCupboards.ContainsKey(cupboard.net.ID.Value))
            {
                toolCupboards.Remove(cupboard.net.ID.Value);
            }
            else
            {
                HandleRemoval(entity);
            }
        }

        #endregion Tool Cupboard Handling

        #region Helper Methods

        private int GetCountOf(List<BuildingBlock> ConnectingStructure, string buildingObject)
        {
            int count = 0;
            List<BuildingBlock> blockList = ConnectingStructure.ToList();
            foreach (BuildingBlock block in blockList)
            {
                if (block == null || block.IsDestroyed)
                {
                    ConnectingStructure.Remove(block);
                }
                else if (block.PrefabName == buildingObject)
                {
                    count++;
                }
            }
            return count;
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void Message(IPlayer player, string key, params object[] args) => player.Message(Lang(key, player.Id, args));

        #endregion Helper Methods
    }
}

// --- End of file: BuildingRestriction.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bank ---
// --- Original File Path: B/Bank/Bank.cs ---

using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;

using Oxide.Core;
using Oxide.Core.Plugins;

using UnityEngine;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Oxide.Plugins
{
    [Info ("Bank", "Calytic", "1.0.53")]
    [Description ("Safe player storage")]
    class Bank : RustPlugin
    {
        #region Variables

        string defaultBoxPrefab;
        int defaultSlots;

        Dictionary<string, object> boxPrefabs;
        Dictionary<string, object> boxSlots;
        bool keyring;
        float cooldownMinutes;
        bool npconly;
        List<string> npcids = new List<string> ();
        float radiationMax;
        bool allowSafeZone;

        public static DataFileSystem datafile;
        public static DataFileSystem configFile;

        Dictionary<string, object> itemLimits = new Dictionary<string, object> ();

        [PluginReference]
        Plugin MasterKey;

        #endregion

        #region Bank/Item Profile

        public class ItemProfile
        {
            public string id;
            public int amount;
            public int slot;
            public Item.Flag flags;
            public float condition;
            public ulong skin;
            public List<ItemProfile> contents;
            public int primaryMagazine;
            public int ammoType;
            public int dataInt;

            [JsonConstructor]
            public ItemProfile (string id, int amount, int slot, Item.Flag flags, float condition = 0.0f, ulong skin = 0, List<ItemProfile> contents = null, int primaryMagazine = 0, int ammoType = 0, int dataInt = 0)
            {
                this.id = id;
                this.amount = amount;
                this.slot = slot;
                this.flags = flags;
                this.condition = condition;
                this.skin = skin;
                this.contents = contents;
                this.primaryMagazine = primaryMagazine;
                this.ammoType = ammoType;
                this.dataInt = dataInt;
            }

            public static ItemProfile Create (Item item)
            {
                List<ItemProfile> contents = new List<ItemProfile> ();
                int primaryMagazine = 0;
                int ammoType = 0;

                if (item.contents != null) {
                    if (item.contents.itemList.Count > 0) {
                        foreach (Item content in item.contents.itemList) {
                            contents.Add (Create (content));
                        }
                    }
                }

                var weapon = item.GetHeldEntity () as BaseProjectile;
                if (weapon != null) {
                    BaseProjectile projectile = weapon as BaseProjectile;
                    primaryMagazine = projectile.primaryMagazine.contents;
                    ammoType = projectile.primaryMagazine.ammoType.itemid;
                }


                int dataInt = 0;
                if (item.instanceData != null && item.info.shortname == "door.key") {
                    dataInt = item.instanceData.dataInt;
                }

                ItemProfile newItem = new ItemProfile (item.info.itemid.ToString (), item.amount, item.position, item.flags, item.condition, item.skin, contents, primaryMagazine, ammoType, dataInt);

                return newItem;
            }
        }

        public class BankProfile
        {
            protected ulong playerID;

            public List<ItemProfile> items = new List<ItemProfile> ();

            [JsonIgnore]
            public bool open = false;

            [JsonIgnore]
            public bool dirty = false;

            [JsonIgnore]
            public BasePlayer Player {
                get {
                    return BasePlayer.Find (playerID.ToString ());
                }
                protected set {
                    playerID = value.userID;
                }
            }

            [JsonIgnore]
            public ulong PlayerID {
                get { return playerID; }
                private set { }
            }

            [JsonIgnore]
            public int Count {
                get {
                    return items.Count;
                }
                private set { }
            }

            public BankProfile ()
            {

            }

            public BankProfile (BasePlayer player, List<ItemProfile> items = null)
            {
                playerID = player.userID;
                if (items is List<ItemProfile>) {
                    this.items = items;
                }
            }

            [JsonConstructor]
            public BankProfile (ulong playerID, List<ItemProfile> items)
            {
                this.playerID = playerID;
                this.items = items;
            }

            public bool Add (Item item)
            {
                ItemProfile profile = ItemProfile.Create (item);
                items.Add (profile);
                dirty = true;

                return true;
            }

            public bool Add (Item [] items)
            {
                foreach (Item item in items) {
                    if (!Add (item)) {
                        return false;
                    }
                }

                return true;
            }

            public bool Add (List<Item> items)
            {
                return Add (items.ToArray ());
            }

            public bool Remove (Item item)
            {
                ItemProfile removing = null;
                foreach (ItemProfile profile in this.items) {
                    if (profile.id == item.info.itemid.ToString () && profile.amount == item.amount) {
                        removing = profile;
                        break;
                    }
                }

                if (removing is ItemProfile) {
                    dirty = true;
                    items.Remove (removing);
                    return true;
                }

                return false;
            }

            public bool Remove (Item [] items)
            {
                foreach (Item item in items) {
                    if (!Remove (item)) {
                        return false;
                    }
                }

                return true;
            }

            public bool Remove (List<Item> items)
            {
                return Remove (items.ToArray ());
            }

            [JsonIgnore]
            ItemContainer container;

            public ItemContainer GetContainer (BasePlayer player, int slots = 30)
            {

                if (this.container is ItemContainer) {
                    this.container.playerOwner = player;
                    this.container.itemList.Clear ();
                    PopulateContainer (player, this.container);
                    return this.container;
                }
                ItemContainer container = new ItemContainer ();
                container.ServerInitialize (null, slots);
                if (container.uid.Value == 0)
                    container.GiveUID ();
                container.playerOwner = player;
                PopulateContainer (player, container);

                return this.container = container;
            }

            void PopulateContainer (BasePlayer player, ItemContainer container, List<ItemProfile> items = null)
            {
                if (items == null) {
                    items = this.items;
                }

                foreach (ItemProfile profile in items) {
                    Item item = ItemManager.CreateByItemID (Convert.ToInt32 (profile.id), profile.amount);

                    if (item is Item) {
                        item.flags = profile.flags;
                        item.skin = profile.skin;

                        if (item.hasCondition) {
                            item.condition = profile.condition;
                        }

                        var held = item.GetHeldEntity ();
                        if (held is BaseEntity) {
                            held.skinID = profile.skin;
                        }
                        var weapon = held as BaseProjectile;
                        if (weapon != null) {
                            BaseProjectile projectile = weapon as BaseProjectile;
                            projectile.primaryMagazine.contents = profile.primaryMagazine;
                            if (profile.ammoType != 0) {
                                projectile.primaryMagazine.ammoType = ItemManager.FindItemDefinition (profile.ammoType);
                            }
                        }

                        if (profile.contents != null) {
                            if (profile.contents.Count > 0) {
                                PopulateContainer (player, item.contents, profile.contents);
                            }
                        }

                        if (item.info.shortname == "door.key" && profile.dataInt != 0) {
                            ProtoBuf.Item.InstanceData instanceData = Facepunch.Pool.Get<ProtoBuf.Item.InstanceData> ();
                            item.instanceData = instanceData;
                            item.instanceData.ShouldPool = false;
                            item.instanceData.dataInt = profile.dataInt;
                        }

                        item.MoveToContainer (container, profile.slot);
                    }
                }
            }
        }
        #endregion

        #region Configuration

        class ItemLimit
        {
            public bool enabled;
            public int minimum;
            public int maximum;

            [JsonConstructor]
            public ItemLimit (bool enabled, int minimum, int maximum)
            {
                this.enabled = enabled;
                this.minimum = minimum;
                this.maximum = maximum;
            }
        }

        #endregion

        #region State

        class OnlinePlayer
        {
            public BasePlayer Player;
            public BasePlayer Target;
            public StorageContainer View;
            public List<BasePlayer> Matches;

            public OnlinePlayer (BasePlayer player)
            {
            }
        }

        public Dictionary<ItemContainer, ulong> containers = new Dictionary<ItemContainer, ulong> ();
        public Dictionary<ulong, BankProfile> banks = new Dictionary<ulong, BankProfile> ();

        [OnlinePlayers]
        Hash<BasePlayer, OnlinePlayer> onlinePlayers = new Hash<BasePlayer, OnlinePlayer> ();
        Dictionary<string, DateTime> bankCooldowns = new Dictionary<string, DateTime> ();

        #endregion

        #region Initialization & Data

        void Init ()
        {
            Unsubscribe (nameof (CanNetworkTo));
            Unsubscribe (nameof (OnEntityTakeDamage));
            Unsubscribe (nameof (OnEntityGroundMissing));
            ////Unsubscribe(nameof(OnItemAddedToContainer));

            configFile = new DataFileSystem (Interface.Oxide.ConfigDirectory);
            itemLimits = configFile.ReadObject<Dictionary<string, object>> ("Bank_ItemLimits");
            permission.RegisterPermission ("bank.use", this);

            CheckConfig ();

            datafile = new DataFileSystem (Interface.Oxide.DataDirectory + "\\" + this.GetConfig<string> ("subDirectory", "banks"));

            boxPrefabs = GetConfig ("Settings", "boxes", GetDefaultBoxes ());
            boxSlots = GetConfig ("Settings", "slots", GetDefaultSlots ());

            defaultBoxPrefab = GetConfig ("Settings", "defaultBox", "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab");
            defaultSlots = GetConfig ("Settings", "defaultSlots", 4);

            cooldownMinutes = GetConfig ("Settings", "cooldownMinutes", 5f);
            radiationMax = GetConfig ("Settings", "radiationMax", 1f);
            allowSafeZone = GetConfig ("Settings", "allowSafeZone", true);

            npconly = GetConfig ("Settings", "NPCBankersOnly", false);
            List<object> lnpcids = GetConfig ("Settings", "NPCIDs", new List<object> ());

            foreach (object id in lnpcids) {
                npcids.Add (id.ToString ());
            }

            keyring = GetConfig ("Settings", "Keyring", true);

            foreach (KeyValuePair<string, object> kvp in boxPrefabs) {
                permission.RegisterPermission (kvp.Key, this);
            }

            foreach (KeyValuePair<string, object> kvp in boxSlots) {
                if (!boxPrefabs.ContainsKey (kvp.Key)) {
                    permission.RegisterPermission (kvp.Key, this);
                }
            }

            foreach (BasePlayer player in BasePlayer.activePlayerList) {
                LoadProfile (player.userID);
            }
        }

        new void LoadDefaultMessages ()
        {
            lang.RegisterMessages (new Dictionary<string, string>
            {
                {"Denied: Permission", "You lack permission to do that"},
                {"Denied: Privilege", "You lack build privileges and cannot do that"},
                {"Denied: Swimming", "You cannot do that while swimming"},
                {"Denied: Falling", "You cannot do that while falling"},
                {"Denied: Wounded", "You cannot do that while wounded"},
                {"Denied: Mounted", "You cannot do that while mounted"},
                {"Denied: Generic", "You cannot do that right now"},
                {"Denied: Irradiated", "You cannot do that while irradiated"},
                {"Denied: Ship", "You cannot do that while on a ship"},
                {"Denied: Lift", "You cannot do that while on a lift"},
                {"Denied: Balloon", "You cannot do that while on a balloon"},
                {"Denied: Safe Zone", "You cannot do that while in a safe zone"},
                {"Cooldown: Seconds", "You are doing that too often, try again in a {0} seconds(s)."},
                {"Cooldown: Minutes", "You are doing that too often, try again in a {0} minute(s)."},
                {"Limit: Return", "Some items were returned to your inventory"}
            }, this);
        }

        Dictionary<string, object> GetDefaultBoxes ()
        {
            return new Dictionary<string, object> () {
                {"bank.default", "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab"},
                {"bank.big", "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab"}
            };
        }

        Dictionary<string, object> GetDefaultSlots ()
        {
            return new Dictionary<string, object> () {
                {"bank.default", 4},
                {"bank.big", 30}
            };
        }

        Dictionary<string, object> GetDefaultItemLimits ()
        {
            return new Dictionary<string, object> () {
                {"explosive.timed", new ItemLimit(false, 0, 1)}
            };
        }

        protected override void LoadDefaultConfig ()
        {
            Config ["Settings", "boxes"] = GetDefaultBoxes ();
            Config ["Settings", "slots"] = GetDefaultSlots ();
            Config ["Settings", "defaultBox"] = "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab";
            Config ["Settings", "defaultSlots"] = 4;
            Config ["Settings", "keyring"] = true;
            Config ["Settings", "cooldownMinutes"] = 5;
            Config ["Settings", "radiationMax"] = 1;
            Config ["Settings", "NPCBankersOnly"] = false;
            Config ["Settings", "NPCIDs"] = new List<object> ();
            Config ["Settings", "allowSafeZone"] = true;

            if (configFile == null)
                configFile = new DataFileSystem (Interface.Oxide.ConfigDirectory);

            configFile.WriteObject ("Bank_ItemLimits", GetDefaultItemLimits ());

            Config ["VERSION"] = Version.ToString ();
        }

        void Unloaded ()
        {
            foreach (var player in BasePlayer.activePlayerList) {
                OnlinePlayer onlinePlayer;
                if (onlinePlayers.TryGetValue (player, out onlinePlayer) && onlinePlayer.View != null) {
                    SaveProfileByUser (player.userID);
                    CloseBank (player, onlinePlayer.View);
                }
            }
        }

        void OnServerSave ()
        {
            SaveData ();
        }

        void CheckConfig ()
        {
            if (Config ["VERSION"] == null) {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig ();
            } else if (GetConfig<string> ("VERSION", "") != Version.ToString ()) {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig ();
            }
        }

        protected void ReloadConfig ()
        {
            Config ["VERSION"] = Version.ToString ();

            // NEW CONFIGURATION OPTIONS HERE
            Config ["Settings", "radiationMax"] = GetConfig ("Settings", "radiationMax", 1f);
            Config ["Settings", "NPCBankersOnly"] = GetConfig ("Settings", "NPCBankersOnly", false);
            Config ["Settings", "NPCIDs"] = GetConfig ("Settings", "NPCIDs", new List<object> ());
            if (itemLimits.Count == 0) {
                itemLimits = GetDefaultItemLimits ();
            }
            configFile.WriteObject ("Bank_ItemLimits", itemLimits);
            // END NEW CONFIGURATION OPTIONS

            PrintWarning ("Upgrading configuration file");
            SaveConfig ();
        }

        void SaveProfileByUser (ulong userID)
        {
            if (banks.ContainsKey (userID)) {
                SaveProfile (userID, banks [userID]);
            }
        }

        void SaveData ()
        {
            int t = 0;

            foreach (KeyValuePair<ulong, BankProfile> kvp in banks) {
                if (kvp.Value.dirty) {
                    SaveProfile (kvp.Key, kvp.Value);
                    t++;
                }
            }

            PrintToConsole ("Saved " + t.ToString () + " banks");
        }

        protected bool LoadProfile (ulong playerID, bool reload = false)
        {
#if DEBUG
            Puts ($"Loading Bank {playerID}");
#endif

            if (playerID == 0) {
                return false;
            }

            //if (banks.ContainsKey (playerID)) {
            //    return true;
            //}

            string path = "bank_" + playerID.ToString ();

            BankProfile profile = datafile.ReadObject<BankProfile> (path);

            if (!(profile is BankProfile)) {
                return false;
            }

            if (profile.Count == 0) {
                return false;
            }

            if (banks.ContainsKey (playerID)) {
                banks [playerID] = profile;
            } else {
                banks.Add (playerID, profile);
            }

            return true;
        }

        void SaveProfile (ulong playerID, BankProfile profile = null)
        {
            if (profile == null) {
                if (!banks.ContainsKey (playerID)) {
                    return;
                }
                profile = banks [playerID];
            }

            string path = "bank_" + playerID.ToString ();
            int pc = profile.Count;
            datafile.WriteObject (path, profile);
            profile.dirty = false;
        }

        #endregion

        #region API

        bool IsBankBox (BaseNetworkable entity)
        {
            foreach (KeyValuePair<BasePlayer, OnlinePlayer> kvp in onlinePlayers) {
                if (kvp.Value?.View?.net != null && entity?.net != null && kvp.Value.View.net.ID == entity.net.ID) {
                    return true;
                }
            }

            return false;
        }

        bool TryGetPlayer(BaseNetworkable entity, out BasePlayer player)
        {
            player = null;
            foreach (KeyValuePair<BasePlayer, OnlinePlayer> kvp in onlinePlayers)
            {
                if (kvp.Value?.View?.net != null && entity?.net != null && kvp.Value.View.net.ID == entity.net.ID)
                {
                    player = kvp.Value.Player;
                    return true;
                }
            }

            return false;
        }

        void AddNpc (string id)
        {
            npcids.Add (id);
        }

        void AddNpc (ulong id)
        {
            AddNpc (id.ToString ());
        }

        void RemoveNpc (string id)
        {
            if (npcids.Contains (id)) {
                npcids.Remove (id);
            }
        }

        void RemoveNpc (ulong id)
        {
            RemoveNpc (id.ToString ());
        }

        #endregion

        #region Oxide Hooks

        void OnUseNPC (BasePlayer npc, BasePlayer player)
        {
            if (!npcids.Contains (npc.UserIDString)) return;
            ShowBank (player, player);
        }

        object CanNetworkTo (BaseNetworkable entity, BasePlayer target)
        {
            if (entity == null || target == null || entity == target || entity.net == null) return null;
            if (target.IsAdmin) return null;

            OnlinePlayer onlinePlayer;
            bool IsMyBank = false;
            if (onlinePlayers.TryGetValue (target, out onlinePlayer)) {
                if (onlinePlayer.View != null && onlinePlayer.View.net != null && onlinePlayer.View.net.ID == entity.net.ID) {
                    IsMyBank = true;
                }
            }

            if (IsBankBox (entity) && !IsMyBank) return false;

            return null;
        }

        object OnEntityTakeDamage (BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (hitInfo == null)
                return null;

            if (entity == null)
                return null;

            if (IsBankBox (entity))
                return false;

            return null;
        }

        object OnEntityGroundMissing(BaseEntity entity)
        {
            BasePlayer player;
            if (TryGetPlayer(entity, out player))
            {
#if DEBUG
                Puts("Bank ground missing");
#endif
                CloseBank(player, entity as StorageContainer);
                return false;
            }

            return null;
        }

        object CanUseLockedEntity (BasePlayer player, BaseLock lockItem)
        {
            if (player == null) {
                return null;
            }

            if (lockItem == null) {
                return null;
            }

            if (!keyring) {
                return null;
            }

            if (MasterKey != null) {
                var result = MasterKey.Call ("CanUseLockedEntity", player, lockItem);
                if (result is bool) {
                    return null;
                }
            }

            BankProfile bank;
            if (lockItem is KeyLock && banks.TryGetValue (player.userID, out bank) && bank.items != null) {
                KeyLock keyLock = (KeyLock)lockItem;

                List<int> codes = bank.items.Select (profile => profile.dataInt).Where (dataInt => dataInt != 0).ToList ();
                //foreach(ItemProfile profile in bank.items) {
                //    if (profile.dataInt != 0) {
                //        codes.Add(profile.dataInt);
                //    }
                //}

                if (!keyLock.IsLocked ()) {
                    return null;
                }

                if (keyLock.HasLockPermission (player)) {
                    return null;
                }

                foreach (int code in codes) {
                    if (code == keyLock.keyCode) {
                        return true;
                    }
                }

                return false;
            }

            return null;
        }

        void OnPlayerConnected (BasePlayer player)
        {
            onlinePlayers [player].View = null;
            onlinePlayers [player].Target = null;
            onlinePlayers [player].Matches = null;

            if (!LoadProfile (player.userID)) {
                if (!banks.ContainsKey (player.userID)) {
                    banks.Add (player.userID, new BankProfile (player));
                }
            }
        }

        void OnPlayerDisconnected (BasePlayer player)
        {
            if (onlinePlayers [player].View != null) {
                ShowBank (player, onlinePlayers [player].View);
                SaveProfile (player.userID);
            }
        }

        void OnPlayerLootEnd (PlayerLoot inventory)
        {
            BasePlayer player;
            if ((player = inventory.GetComponent<BasePlayer> ()) == null)
                return;

            if (onlinePlayers.ContainsKey (player) && onlinePlayers [player].View != null) {
                if (onlinePlayers [player].View == inventory.entitySource) {
                    CloseBank (player, (StorageContainer)inventory.entitySource);
                }
            }
        }

        //void OnItemAddedToContainer(ItemContainer container, Item item)
        //{
        //    BasePlayer player = container.playerOwner;
        //    OnlinePlayer onlinePlayer;
        //    if (player != null && onlinePlayers.TryGetValue(player, out onlinePlayer)) {
        //        if (onlinePlayer.View != null && onlinePlayer.View.inventory == container) {
        //            int validAmount = GetValidAmount(item, container);

        //            if (validAmount <= 0) {
        //                item.MoveToContainer(container.playerOwner.inventory.containerMain);
        //                return;
        //            }

        //            if (validAmount < item.amount) {
        //                Item splitItem = item.SplitItem(item.amount - validAmount);

        //                splitItem.MoveToContainer(container.playerOwner.inventory.containerMain);
        //            }
        //        }
        //    }
        //}

        #endregion

        #region Commands

        [ChatCommand ("viewbank")]
        void ViewBank (BasePlayer player, string command, string [] args)
        {
            if (!IsAllowed (player)) return;

            if (args.Length < 1) {
                return;
            }

            var name = args [0];
            var ply = onlinePlayers [player];
            if (name == "list") {
                if (ply.Matches == null) {
                    return;
                }

                if (args.Length == 1) {
                    ShowMatchingPlayers (player);
                    return;
                }

                int index;
                if (!int.TryParse (args [1], out index)) {
                    return;
                }

                if (index > ply.Matches.Count) { } else
                    ShowBank (player, ply.Matches [index - 1]);

                return;
            }

            var matches = FindPlayersByName (name);
            if (matches.Count < 1) {
                return;
            }

            if (matches.Count > 1) {
                ply.Matches = matches;
                ShowMatchingPlayers (player);
                return;
            }

            ShowBank (player, matches [0]);
        }

        [ConsoleCommand ("bank")]
        void ccBank (ConsoleSystem.Arg arg)
        {
            cmdBank (arg.Connection.player as BasePlayer, arg.cmd.Name, arg.Args);
        }

        [ChatCommand ("bank")]
        void cmdBank (BasePlayer player, string command, string [] args)
        {
            if (npconly) return;

            ShowBank (player, player);
        }

        #endregion

        #region Core methods

        ItemLimit GetItemLimit (Item item)
        {
            object limit;
            if (itemLimits.TryGetValue (item.info.shortname, out limit) && limit is JObject) {
                return ((JObject)limit).ToObject<ItemLimit> ();
            }

            return null;
        }

        //int GetValidAmount(Item item, ItemContainer container) {
        //    ItemLimit limit;
        //    int totalAmount = container.GetAmount(item.info.itemid, false) - item.amount;

        //    if (itemLimits.TryGetValue(item.info.shortname, out limit)) {
        //        if (!limit.enabled) {
        //            return 0;
        //        }

        //        if (totalAmount < limit.minimum) {
        //            return 0;
        //        }

        //        if (totalAmount == 0 && item.amount > limit.maximum) {
        //            return limit.maximum;
        //        }

        //        if (totalAmount > limit.maximum) {
        //            return totalAmount - limit.maximum;
        //        }

        //        if (totalAmount == limit.maximum) {
        //            return 0;
        //        }
        //    }

        //    return item.amount;
        //}

        bool CanPlayerBank (BasePlayer player)
        {
            if (player.IsAdmin) {
                return true;
            }

            if (!permission.UserHasPermission (player.UserIDString, "bank.use")) {
                SendReply (player, GetMsg ("Denied: Permission", player));
                return false;
            }

            if (!player.CanBuild () && !npconly) {
                SendReply (player, GetMsg ("Denied: Privilege", player));
                return false;
            }

            if (radiationMax > 0 && player.radiationLevel > radiationMax) {
                SendReply (player, GetMsg ("Denied: Irradiated", player));
                return false;
            }

            if (player.IsSwimming ()) {
                SendReply (player, GetMsg ("Denied: Swimming", player));
                return false;
            }

            if (!player.IsOnGround () || player.IsFlying || player.isInAir) {
                SendReply (player, GetMsg ("Denied: Falling", player));
                return false;
            }

            if (player.isMounted) {
                SendReply (player, GetMsg ("Denied: Mounted", player));
                return false;
            }

            if (player.IsWounded ()) {
                SendReply (player, GetMsg ("Denied: Wounded", player));
                return false;
            }

            if (player.GetComponentInParent<CargoShip> ()) {
                SendReply (player, GetMsg ("Denied: Ship", player));
                return false;
            }

            if (player.GetComponentInParent<HotAirBalloon> ()) {
                SendReply (player, GetMsg ("Denied: Balloon", player));
                return false;
            }

            if (player.GetComponentInParent<Lift> ()) {
                SendReply (player, GetMsg ("Denied: Lift", player));
                return false;
            }

            if (!allowSafeZone && player.InSafeZone ()) {
                SendReply (player, GetMsg ("Denied: Safe Zone", player));
                return false;
            }

            var canBank = Interface.Call ("CanBank", player);
            if (canBank != null) {
                if (canBank is string) {
                    SendReply (player, Convert.ToString (canBank));
                } else {
                    SendReply (player, GetMsg ("Denied: Generic", player));
                }
                return false;
            }

            return true;
        }

        void ShowBank (BasePlayer player, BaseEntity target)
        {
            if (!CanPlayerBank (player))
                return;

            string playerID = player.userID.ToString ();

            if (cooldownMinutes > 0 && player.net.connection.authLevel < 1) {
                if (bankCooldowns.ContainsKey (playerID)) {
                    DateTime startTime = bankCooldowns [playerID];
                    DateTime endTime = DateTime.Now;

                    TimeSpan span = endTime.Subtract (startTime);
                    if (span.TotalMinutes > 0 && span.TotalMinutes < Convert.ToDouble (cooldownMinutes)) {
                        double timeleft = System.Math.Round (Convert.ToDouble (cooldownMinutes) - span.TotalMinutes, 2);
                        if (timeleft < 1) {
                            double timelefts = System.Math.Round ((Convert.ToDouble (cooldownMinutes) * 60) - span.TotalSeconds);
                            SendReply (player, string.Format (GetMsg ("Cooldown: Seconds", player), timelefts.ToString ()));
                        } else {
                            SendReply (player, string.Format (GetMsg ("Cooldown: Minutes", player), System.Math.Round (timeleft).ToString ()));
                        }
                        return;
                    } else {
                        bankCooldowns.Remove (playerID);
                    }
                }
            }

            if (!LoadProfile (player.userID) && !banks.ContainsKey (player.userID)) {
                banks.Add (player.userID, new BankProfile (player));
            }

            if (!bankCooldowns.ContainsKey (player.userID.ToString ()) && player.net.connection.authLevel < 1) {
                bankCooldowns.Add (playerID, DateTime.Now);
            }
            var ply = onlinePlayers [player];
            if (ply.View == null) {
#if DEBUG
                Puts ($"Opening bank {player.userID}");
#endif
                OpenBank (player, target);
                return;
            }

            CloseBank (player, ply.View);
            timer.In (1f, () => OpenBank (player, target));
        }

        void HideBank (BasePlayer player)
        {
            player.EndLooting ();
            var ply = onlinePlayers [player];
            if (ply.View == null) {
                return;
            }

            CloseBank (player, ply.View);
        }

        string GetBox (BasePlayer player)
        {
            foreach (KeyValuePair<string, object> kvp in boxPrefabs) {
                if (permission.UserHasPermission (player.UserIDString, kvp.Key)) {
                    return kvp.Value.ToString ();
                }
            }

            return defaultBoxPrefab;
        }

        int GetSlots (BasePlayer player)
        {
            var availableSlots = new List<int> ();
            availableSlots.Add (defaultSlots);

            foreach (KeyValuePair<string, object> kvp in boxSlots) {
                if (permission.UserHasPermission (player.UserIDString, kvp.Key)) {
                    availableSlots.Add (Convert.ToInt32 (kvp.Value));
                }
            }

            return availableSlots.Max ();
        }

        void OpenBank (BasePlayer player, BaseEntity targArg)
        {
            Subscribe (nameof (CanNetworkTo));
            Subscribe (nameof (OnEntityTakeDamage));
            Subscribe (nameof (OnEntityGroundMissing));
            //Subscribe(nameof(OnItemAddedToContainer));
            var pos = new Vector3 (player.transform.position.x, player.transform.position.y - 1, player.transform.position.z);
            string box = GetBox (player);

            int slots = GetSlots (player);

            var view = GameManager.server.CreateEntity (box, pos) as StorageContainer;
            //view.GetComponent<DestroyOnGroundMissing> ().enabled = false;
            view.GetComponent<GroundWatch> ().enabled = false;

            if (!view) return;
            view.limitNetworking = true;
            view.transform.position = pos;
            view.OwnerID = player.userID;

            player.EndLooting ();
            if (targArg is BasePlayer) {
                BasePlayer target = targArg as BasePlayer;
                BankProfile profile = banks [target.userID];
                ItemContainer bank = profile.GetContainer (target, slots);
                if (!containers.ContainsKey (bank)) {
                    containers.Add (bank, player.userID);
                }
                view.enableSaving = false;
                view.Spawn ();
                view.inventory = bank;
                view.inventory.entityOwner = view;

                profile.open = true;
                onlinePlayers [player].View = view;
                onlinePlayers [player].Target = target;

                timer.In (0.1f, delegate () {
                    view.PlayerOpenLoot (player);
                });
            }
        }

        void CloseBank (BasePlayer player, StorageContainer view)
        {
            if (!onlinePlayers.ContainsKey (player)) return;
            if (onlinePlayers [player].View == null) return;

            if (!banks.ContainsKey (player.userID)) {
                return;
            }

            BankProfile profile = banks [player.userID];

            InvalidateBank (player, profile, view);

            profile.items.Clear ();
            foreach (Item item in view.inventory.itemList) {
                profile.Add (item);
            }

            SaveProfile (player.userID, profile);

            foreach (Item item in view.inventory.itemList.ToArray ()) {
                if (item.position != -1) {
                    item.RemoveFromContainer ();
                    item.Remove (0f);
                }
            }

            profile.open = false;

            if (containers.ContainsKey (view.inventory)) {
                containers.Remove (view.inventory);
            }

            player.inventory.loot.containers = new List<ItemContainer> ();
            view.inventory = new ItemContainer ();

            if (player.inventory.loot.IsLooting ()) {
                player.SendConsoleCommand ("inventory.endloot", null);
            }


            onlinePlayers [player].View = null;
            onlinePlayers [player].Target = null;

#if DEBUG
            Puts($"Closing Bank {player.userID}");
#endif

            view.Kill (BaseNetworkable.DestroyMode.None);

            timer.In (1f, delegate () {
                if (onlinePlayers.Values.Count (p => p.View != null) <= 0) {
                    Unsubscribe (nameof (CanNetworkTo));
                    Unsubscribe (nameof (OnEntityTakeDamage));
                    Unsubscribe (nameof (OnEntityGroundMissing));
                }
            });
        }

        void InvalidateBank (BasePlayer player, BankProfile profile, StorageContainer view)
        {
            bool returned = false;
            if (view != null && view.inventory != null && view.inventory.itemList != null) {
                foreach (var item in view.inventory.itemList.ToArray ()) {
                    ItemLimit limit = GetItemLimit (item);

                    if (limit != null && limit.enabled) {
                        if (item.amount < limit.minimum) {
                            returned = true;
                            if (player.inventory.containerMain == null || (player.inventory.containerMain != null && !item.MoveToContainer (player.inventory.containerMain))) {
                                if (player.inventory.containerBelt == null || (player.inventory.containerBelt != null && !item.MoveToContainer (player.inventory.containerBelt))) {
                                    item.Drop (player.eyes.HeadForward () * 2, default (Vector3));
                                }
                            }
                            continue;
                        }

                        if (item.amount > limit.maximum) {
                            returned = true;
                            Item invalidItem;

                            if (limit.maximum > 0) {
                                invalidItem = item.SplitItem (item.amount - limit.maximum);
                            } else {
                                invalidItem = item;
                            }
                            if (invalidItem != null) {
                                if (player.inventory.containerMain == null || (player.inventory.containerMain != null && !invalidItem.MoveToContainer (player.inventory.containerMain))) {
                                    if (player.inventory.containerBelt == null || (player.inventory.containerBelt != null && !invalidItem.MoveToContainer (player.inventory.containerBelt))) {
                                        invalidItem.Drop (player.eyes.HeadForward () * 2, default (Vector3));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (returned) {
                SendReply (player, GetMsg ("Limit: Return", player));
            }
        }

        #endregion

        #region HelpText
        void SendHelpText (BasePlayer player)
        {
            var sb = new StringBuilder ()
               .Append ("Bank by <color=#ce422b>Calytic</color>\n")
               .Append ("  ").Append ("<color=\"#ffd479\">/bank</color> - Open your bank box").Append ("\n");

            if (player.IsAdmin) {
                sb.Append ("  ").Append ("<color=\"#ffd479\">/viewbank \"Player Name\"</color> - View any players bank").Append ("\n");
            }
            player.ChatMessage (sb.ToString ());
        }
        #endregion

        #region Helper methods

        string GetMsg (string key, BasePlayer player = null)
        {
            return lang.GetMessage (key, this, player == null ? null : player.UserIDString);
        }

        List<BasePlayer> FindPlayersByName (string name)
        {
            List<BasePlayer> matches = new List<BasePlayer> ();

            foreach (var ply in BasePlayer.activePlayerList) {
                if (ply.displayName.ToLower ().Contains (name.ToLower ()))
                    matches.Add (ply);
            }

            foreach (var ply in BasePlayer.sleepingPlayerList) {
                if (ply.displayName.ToLower ().Contains (name.ToLower ()))
                    matches.Add (ply);
            }

            return matches;
        }

        void ShowMatchingPlayers (BasePlayer player)
        {
            int i = 0;
            foreach (var ply in onlinePlayers [player].Matches) {
                i++;
                player.ChatMessage ($"{i} - {ply.displayName} ({ply.userID})");
            }
        }

        bool IsAllowed (BasePlayer player)
        {
            if (player.IsAdmin) return true;
            SendReply (player, GetMsg ("Denied: Permission", player));
            return false;
        }

        T GetConfig<T> (string name, string name2, T defaultValue)
        {
            if (Config [name, name2] == null) {
                return defaultValue;
            }

            return (T)Convert.ChangeType (Config [name, name2], typeof (T));
        }

        T GetConfig<T> (string name, T defaultValue)
        {
            if (Config [name] == null) {
                return defaultValue;
            }

            return (T)Convert.ChangeType (Config [name], typeof (T));
        }

        #endregion
    }
}

// --- End of file: Bank.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-health ---
// --- Original File Path: B/BetterHealth/BetterHealth.cs ---

//Requires: Coroutines

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Better Health", "birthdates", "2.2.3")]
    [Description("Ability to customize the max health")]
    public class BetterHealth : RustPlugin
    {
        #region Variables

        private const string PermissionUse = "betterhealth.use";

        #endregion

        #region Helpers

        /// <summary>
        ///     Get the player's max health based on config permissions
        /// </summary>
        /// <param name="player">Target player</param>
        /// <returns>The default max health or the highest max health they have permission to</returns>
        private float GetMaxHealth(BasePlayer player)
        {
            //filter permissions & sort
            var healthPermission = _config.Permissions.Where(p => player.IPlayer.HasPermission($"betterhealth.{p.Key}"))
                .OrderBy(entry => entry.Value).FirstOrDefault();
            return string.IsNullOrEmpty(healthPermission.Key) ? _config.MaxHealth : healthPermission.Value;
        }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionUse, this);
            LoadConfig();

            foreach (var perm in _config.Permissions.Keys.Select(p => $"betterhealth.{p}")
                .Where(perm => !permission.PermissionExists(perm, this))) permission.RegisterPermission(perm, this);
        }

        private void OnServerInitialized()
        {
            CheckAllPlayers();
            StartChecking();
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            SetHealth(player);
        }

        /// <summary>
        ///     On consume of tea, if add booster is on, add it on to the current booster, if not, cancel
        /// </summary>
        /// <param name="item">Target item</param>
        /// <param name="action">Item action</param>
        /// <param name="player">Target player</param>
        /// <returns>Null if we should not cancel, true if we should cancel</returns>
        private object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (!action.Equals("consume") || !item.info.shortname.StartsWith("maxhealthtea")) return null;
            if (!_config.AddOldBooster) return true; //stop the tea from being consumed

            /*
             * Use next tick to wait for tea benefits
             * Set the health with the new booster
             */
            NextTick(() => SetHealth(player));
            return null;
        }

        #endregion

        #region Health

        /// <summary>
        ///     Check all players for health changes in a coroutine
        /// </summary>
        private void CheckAllPlayers()
        {
            const string id = "Check All Players";
            if (Coroutines.Instance.IsCoroutineRunning(id)) return;
            Coroutines.Instance.LoopListAsynchronously(this, new Action<BasePlayer>(SetHealth),
                new List<BasePlayer>(BasePlayer.allPlayerList), 0.2f, id: id, reverse: true, completePerTick: 5);
        }

        /// <summary>
        ///     Start a timer every 40 minutes to reset the boost timer
        /// </summary>
        private void StartChecking()
        {
            timer.Every(2400f /*40 minutes*/, CheckAllPlayers);
        }

        /// <summary>
        ///     Set the max health of a player
        /// </summary>
        /// <param name="player">Target player</param>
        private void SetHealth(BasePlayer player)
        {
            if (player == null || player.modifiers == null || !player.IPlayer.HasPermission(PermissionUse)) return;
            var startHealth = player.StartMaxHealth();
            var maxHealth = GetMaxHealth(player);
            var healthMultiplier = (maxHealth - startHealth) /
                                   startHealth; //get multiplier needed (i.e 150 max health should be 0.5)
            
            //add old booster on to multiplier if exists & not the same booster
            float healthBooster;
            if (_config.AddOldBooster &&
                (healthBooster = player.modifiers.GetValue(Modifier.ModifierType.Max_Health, -1000f)) > -1000f &&
                Math.Abs(healthBooster - healthMultiplier) > 0.1f) healthMultiplier += healthBooster;

            player.modifiers.Add(new List<ModifierDefintion>
            {
                new ModifierDefintion
                {
                    type = Modifier.ModifierType.Max_Health,
                    value = healthMultiplier, //the equation is startHealth * (1f + modifier)
                    duration = 999999f, //don't use float.MaxValue (will kick player) (max time seems to be ~45 minutes)
                    source = Modifier.ModifierSource.Tea
                }
            });
            player.modifiers.SendChangesToClient(); //update client
        }

        #endregion

        #region Configuration, Language & Data

        private ConfigFile _config;

        public class ConfigFile
        {
            [JsonProperty("Add booster if already has one?")]
            public bool AddOldBooster = true;

            [JsonProperty("Default Max Health")] public float MaxHealth = 150f;

            [JsonProperty("Max Health Permissions")]
            public Dictionary<string, float> Permissions = new Dictionary<string, float>
            {
                {"vip", 300f}
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null) LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = new ConfigFile();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
    }
}
//Generated with birthdates' Plugin Maker

// --- End of file: BetterHealth.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-healing ---
// --- Original File Path: B/BetterHealing/BetterHealing.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Better Healing", "Default", "2.0.0")]
    [Description("Customization of healing and food items.")]
    public class BetterHealing : RustPlugin
    {
        // Declares the permission to use this plugin
        private static string medicalPermission = "betterhealing.medical";
        private static string foodPermission = "betterhealing.food";

        private void Init()
        {
            permission.RegisterPermission(medicalPermission, this);
            permission.RegisterPermission(foodPermission, this);
        }

        private object OnHealingItemUse(MedicalTool tool, BasePlayer player)
        {
            var toolName = tool.GetItem()?.info?.shortname;
            if (toolName != null && permission.UserHasPermission(player.UserIDString, medicalPermission))
            {
                if (_config.healingItemSettings.medicalItems.ContainsKey(toolName))
                {
                    var HealAmount = _config.healingItemSettings.medicalItems[toolName].HealAmount;
                    player.health = player.health + HealAmount;
                    if (_config.healingItemSettings.medicalItems[toolName].HealOverTimeAmount > 0)
                    {
                        var HealOverTime = _config.healingItemSettings.medicalItems[toolName].HealOverTimeAmount;
                        player.metabolism.ApplyChange(MetabolismAttribute.Type.HealthOverTime, HealOverTime, 1f);
                    }
                    player.metabolism.poison.Subtract(Math.Abs(_config.healingItemSettings.medicalItems[toolName].Poison));
                    player.metabolism.bleeding.Subtract(Math.Abs(_config.healingItemSettings.medicalItems[toolName].Bleed));
                    player.metabolism.radiation_poison.Subtract(Math.Abs(_config.healingItemSettings.medicalItems[toolName].Radiation));
                    return true;
                }
            }
            return null;
        }

        private object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (action == "consume" && permission.UserHasPermission(player.UserIDString, foodPermission))
            {
                var name = item.info.shortname;
                if (_config.healingItemSettings.foodItems.ContainsKey(name))
                {
                    item.UseItem(1);
                    var chance = UnityEngine.Random.Range(_config.healingItemSettings.pickleChanceMin, _config.healingItemSettings.pickleChanceMax);
                    if (name.Contains("can"))
                    {
                        switch (name)
                        {
                            case "can.tuna":
                                player.GiveItem(ItemManager.CreateByPartialName("can.tuna.empty"));
                                break;
                            case "can.beans":
                                player.GiveItem(ItemManager.CreateByPartialName("can.beans.empty"));
                                break;
                        }
                    }
                    else if (name == "jar.pickle" && chance == _config.healingItemSettings.pickleEffect)
                    {
                        player.metabolism.poison.Add(8);
                        player.metabolism.hydration.Subtract(50);
                        player.metabolism.calories.Subtract(50);
                    }
                    player.health += (_config.healingItemSettings.foodItems[name].HealAmount);
                    player.metabolism.ApplyChange(MetabolismAttribute.Type.HealthOverTime, (_config.healingItemSettings.foodItems[name].HealOverTimeAmount), 1f);
                    player.metabolism.calories.Add(_config.healingItemSettings.foodItems[name].Calories);
                    if (_config.healingItemSettings.foodItems[name].Hydration > 0)
                    {
                        player.metabolism.hydration.Add(_config.healingItemSettings.foodItems[name].Hydration);
                    }
                    else
                    {
                        player.metabolism.hydration.Subtract(Math.Abs(_config.healingItemSettings.foodItems[name].Hydration));
                    }
                    if (_config.healingItemSettings.foodItems[name].Poison > 0)
                    {
                        player.metabolism.poison.Add(_config.healingItemSettings.foodItems[name].Poison);
                    }
                    else if (_config.healingItemSettings.foodItems[name].Poison < 0)
                    {
                        player.metabolism.poison.Subtract(Math.Abs(_config.healingItemSettings.foodItems[name].Poison));
                    }
                    if (name.Contains("raw") && !name.Contains("fish") || (name == "jar.pickle" && chance == 2))
                    {
                        Effect.server.Run("assets/bundled/prefabs/fx/gestures/drink_vomit.prefab", player.ServerPosition + new Vector3(0, 1, 0));
                    }
                    else
                    {
                        Effect.server.Run("assets/bundled/prefabs/fx/gestures/eat_generic.prefab", player.ServerPosition + new Vector3(0, 1, 0));
                    }
                    return true;
                }
            }
            return null;
        }


        #region Config handling

        public ConfigFile _config;

        public class ConfigFile
        {
            [JsonProperty("Health and metabolism settings (Healing items & food)")]
            public HealingItemSettings healingItemSettings = new HealingItemSettings();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = new ConfigFile();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion
    }

    #region Healing/Metabolism class

    public class HealingItemSettings
    {
        [JsonProperty("Medical")]
        public Dictionary<string, MedicalItem> medicalItems = new Dictionary<string, MedicalItem>
        {
            {"bandage", new MedicalItem(){HealAmount = 5, HealOverTimeAmount = 0, Bleed = -50, Poison = -2, Radiation = 0} },
            {"syringe.medical", new MedicalItem(){HealAmount = 15, HealOverTimeAmount = 20, Bleed = 0, Poison = -5, Radiation = -10}},
            {"largemedkit", new MedicalItem(){HealAmount = 0, HealOverTimeAmount = 100, Bleed = -100, Poison = -10, Radiation = 0}}
        };

        [JsonProperty("Food")]
        public Dictionary<string, FoodItem> foodItems = new Dictionary<string, FoodItem>
        {
            {"chicken.cooked", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 10f, Calories = 40f, Hydration = 3f, Poison = 0f}},
            {"chicken.raw", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 0f, Calories = 20f, Hydration = 0f, Poison = 10f}},
            {"meat.pork.burned", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 1f, Calories = 15f, Hydration = 0f, Poison = 0f}},
            {"wolfmeat.burned", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 1f, Calories = 15f, Hydration = 0f, Poison = 0f}},
            {"humanmeat.burned", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 0f, Calories = 6f, Hydration = -30f, Poison = 0f}},
            {"horsemeat.burned", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 2f, Calories = 10f, Hydration = 0f, Poison = 0f}},
            {"deermeat.burned", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 2f, Calories = 10f, Hydration = 0f, Poison = 0f}},
            {"chicken.burned", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 2f, Calories = 10f, Hydration = 0f, Poison = 0f}},
            {"bearmeat.burned", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 1f, Calories = 25f, Hydration = 0f, Poison = 0f}},
            {"cactusflesh", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 3f, Calories = 5f, Hydration = 20f, Poison = 0f}},
            {"bearmeat.cooked", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 5f, Calories = 100f, Hydration = 1f, Poison = 0f}},
            {"deermeat.cooked", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 10f, Calories = 40f, Hydration = 3f, Poison = 0f}},
            {"fish.cooked", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 5f, Calories = 60f, Hydration = 15f, Poison = 0f}},
            {"horsemeat.cooked", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 8f, Calories = 45f, Hydration = 3f, Poison = 0f}},
            {"blueberries", new FoodItem(){HealAmount = 10f, HealOverTimeAmount = 0f, Calories = 30f, Hydration = 20f, Poison = -5f}},
            {"black.raspberries", new FoodItem(){HealAmount = 10f, HealOverTimeAmount = 0f, Calories = 40f, Hydration = 20f, Poison = -5f}},
            {"apple", new FoodItem(){HealAmount = 2f, HealOverTimeAmount = 0f, Calories = 30f, Hydration = 15f, Poison = 0f}},
            {"corn", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 6f, Calories = 75f, Hydration = 10f, Poison = 0f}},
            {"pumpkin", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 10f, Calories = 100f, Hydration = 30f, Poison = 0f}},
            {"mushroom", new FoodItem(){HealAmount = 3f, HealOverTimeAmount = 0f, Calories = 15f, Hydration = 5f, Poison = 0f}},
            {"can.tuna", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 2f, Calories = 50f, Hydration = 15f, Poison = 0f}},
            {"jar.pickle", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 5f, Calories = 50f, Hydration = 20f, Poison = 0f}},
            {"granolabar", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 5f, Calories = 60f, Hydration = 0f, Poison = 0f}},
            {"can.beans", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 4f, Calories = 100f, Hydration = 25f, Poison = 0f}},
            {"chocholate", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 2f, Calories = 30f, Hydration = 1f, Poison = 0f}},
            {"humanmeat.cooked", new FoodItem(){HealAmount = 1f, HealOverTimeAmount = 1f, Calories = 100f, Hydration = 1f, Poison = 0f}},
            {"meat.pork.cooked", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 5f, Calories = 60f, Hydration = 1f, Poison = 0f}},
            {"wolfmeat.cooked", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 5f, Calories = 60f, Hydration = 1f, Poison = 0f}},
            {"fish.minnows", new FoodItem(){HealAmount = 1f, HealOverTimeAmount = 0f, Calories = 10f, Hydration = 1f, Poison = 0f}},
            {"apple.spoiled", new FoodItem(){HealAmount = 2f, HealOverTimeAmount = 0f, Calories = 15f, Hydration = 2f, Poison = 0f}},
            {"fish.raw", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 0f, Calories = 5f, Hydration = 1f, Poison = 0f}},
            {"bearmeat", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 0f, Calories = 10f, Hydration = 3f, Poison = 5f}},
            {"deermeat.raw", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 0f, Calories = 20f, Hydration = 0f, Poison = 10f}},
            {"horsemeat.raw", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 0f, Calories = 20f, Hydration = 0f, Poison = 10f}},
            {"humanmeat.raw", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 0f, Calories = 5f, Hydration = -3f, Poison = 10f}},
            {"wolfmeat.raw", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 0f, Calories = 20f, Hydration = 0f, Poison = 10f}},
            {"meat.boar", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 0f, Calories = 60f, Hydration = 0f, Poison = 5f}},
            {"grub", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 0f, Calories = 3f, Hydration = -15f, Poison = 0f}},
            {"worm", new FoodItem(){HealAmount = 0f, HealOverTimeAmount = 0f, Calories = 1f, Hydration = -10f, Poison = 0f}}
        };

        [JsonProperty("Pickle chance min")]
        public int pickleChanceMin = 1;

        [JsonProperty("Pickle chance max")]
        public int pickleChanceMax = 3;

        [JsonProperty("Pickle effect (Must be inbetween min and max")]
        public int pickleEffect = 2;

        public class FoodItem
        {
            [JsonProperty("Instant Heal")]
            public float HealAmount;
            [JsonProperty("Heal Over Time")]
            public float HealOverTimeAmount;
            [JsonProperty("Food")]
            public float Calories;
            [JsonProperty("Water")]
            public float Hydration;
            [JsonProperty("Poison")]
            public float Poison;
        }

        public class MedicalItem
        {
            [JsonProperty("Instant Heal")]
            public float HealAmount;
            [JsonProperty("Heal Over Time")]
            public float HealOverTimeAmount;
            [JsonProperty("Poison")]
            public float Poison;
            [JsonProperty("Bleed")]
            public float Bleed;
            [JsonProperty("Radiation")]
            public float Radiation;
        }
    }
    #endregion
}

// --- End of file: BetterHealing.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-chat-filter ---
// --- Original File Path: B/BetterChatFilter/BetterChatFilter.cs ---

// Requires: BetterChat
// Requires: BetterChatMute


using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System.Text.RegularExpressions;
using Oxide.Game.Rust.Libraries;

namespace Oxide.Plugins
{
    [Info("Better Chat Filter", "NooBlet", "1.7.4", ResourceId = 2403)]
    [Description("Filter for Better Chat")]
    public class BetterChatFilter : CovalencePlugin
    {
        [PluginReference] private Plugin BetterChat, BetterChatMute, EnhancedBanSystem;

        //////////////////////////////////////////////////////////////////////////////////

        #region BetterChatHook

        private object OnBetterChat(Dictionary<string, object> messageData) => Filter(messageData);

        private object Filter(Dictionary<string, object> messageData)
        {
            IPlayer player = (IPlayer)messageData["Player"];

            if (BlockSpecialCharacters && hasSpecialChar((string)messageData["Message"]))
            {
                player.Message(GetLang("CantUseSpecialCharacters", player.Id));
                messageData["CancelOption"] = 2;
                return messageData;
            }

            if (ExcludeTeamChat)
            {
                if (messageData["ChatChannel"].ToString() == "Team") { return messageData; }
            }
            if (MustExclude(player)) { return messageData; }

            if (WordFilter_Enabled)
            {
                var message = (string)messageData["Message"];
                if (!GetIsMuted(ref player)) { messageData["Message"] = FilterText(player, message); }
                if ((string)messageData["Message"] == "")
                {
                    messageData["CancelOption"] = 2;
                }
                return messageData;
            }

            return messageData;
        }

        #endregion

        //////////////////////////////////////////////////////////////////////////////////

        #region Data
        private readonly Player Player = Interface.Oxide.GetLibrary<Player>();
        private static OffenseData offensedata;
        public Dictionary<string, OffenseData> PlayerOffenses = new Dictionary<string, OffenseData>();
        public class OffenseData
        {
            public int offenses { get; set; }

            public DateTime timesinsoffense { get; set; }
            public OffenseData()
            {
                offenses = 1;
            }
            public OffenseData(int offenses)
            {
                this.offenses = offenses;
            }
        }
        #endregion

        #region Cached Variables
        private bool FilterAll = false;
        private bool WordFilter_Enabled = true;
        private string WordFilter_Replacement = "*";
        private bool WordFilter_UseCustomReplacement = false;
        private string WordFilter_CustomReplacement = "Unicorn";
        private List<object> WordFilter_Phrases = new List<object> {
                "bitch",
                "cunt",
                "nigger",
                "nig",
                "faggot",
                "fuck"
        };
        private List<object> GroupsToExclude = new List<object> {
                "admin",
        };
        private List<object> WordWhiteList = new List<object> {
                "night",
        };
        private int MuteCount = 3;
        private int KickCount = 3;
        private int BanCount = 20;
        private int BanTimeMin = 30;
        private bool BroadcastKick = true;
        private bool BroadcastBan = true;
        private int TimeToMute = 300;
        private bool UseRegex = false;
        private string regextouse = @"";
        private int clear = 0;
        private bool ExcludeTeamChat = false;
        private bool warnoffenseamount = false;
        private bool BlockSpecialCharacters = false;

        #endregion

        #region Plugin General

        public static bool hasSpecialChar(string input)
        {
            Regex r = new Regex("^[a-zA-Z0-9.,-_ \\[\\]\\\\'~`?<>;:/!()*&%$#@=+|{}\"-]*$");
            if (!r.IsMatch(input))
            {
                return true;
            }
            return false;
        }

        private string ListToString<T>(List<T> list, int first = 0, string seperator = ", ")
        {
            return string.Join(seperator, (from val in list select val.ToString()).Skip(first).ToArray());
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("BetterChatFilter", PlayerOffenses);

        private string GetLang(string key, string id) => lang.GetMessage(key, this, id);

        private void Loaded()
        {
            LoadConfiguration();
            LoadData();
            permission.RegisterPermission(Name + ".admin", this);
        }

        void Unload()
        {

        }

        private void Offsense(IPlayer player)
        {

            int offenseCount = 0;

            if (PlayerOffenses.ContainsKey(player.Id))
            {
                PlayerOffenses[player.Id].offenses++;
                offenseCount = PlayerOffenses[player.Id].offenses;
                SaveData();
            }
            else if (!(PlayerOffenses.ContainsKey(player.Id)))
            {
                PlayerOffenses.Add(player.Id, new OffenseData());
                offenseCount = PlayerOffenses[player.Id].offenses;
                SaveData();
            }
            if (offenseCount >= MuteCount && MuteCount != 0)
            {
                if (clear == 1 || clear == 3)
                {
                    ClearOffense(player);
                }
                //mute check suggested OuTSMoKE
                if (!GetIsMuted(ref player))
                {
                    server.Command("mute", player.Id, $"{TimeToMute}s", $"{GetLang("MuteReason", player.Id)}");
                }
            }
            if (offenseCount >= KickCount && KickCount != 0)
            {
                if (clear == 1 || clear == 2)
                {
                    ClearOffense(player);
                }
                if (BroadcastKick) server.Broadcast(string.Format(GetLang("BroadcastKickFormat", null), player.Name, GetLang("KickReason", null)));
                player.Kick(GetLang("KickReason", player.Id));
            }

            if (offenseCount >= BanCount && BanCount != 0)
            {
                if (clear == 1 || clear == 4)
                {
                    ClearOffense(player);
                }

                if (BroadcastBan) server.Broadcast(string.Format(GetLang("BroadcastBanFormat", null), player.Name, GetLang("BanReason", null)));

                BanPlayer(player, BanTimeMin, GetLang("BanReason", player.Id));
            }

            SaveData();
            return;
        }

        private void BanPlayer(IPlayer player, int time, string reason)
        {
            if (BanTimeMin == 0)
            {
                if (EnhancedBanSystem) { server.Command($"ban {player.Id} {reason}"); return; }
                player.Ban(reason);
            }
            else
            {
                if (EnhancedBanSystem) { server.Command($"ban {player.Id} {time}m {reason}"); return; }
                Player.Ban(player.Id, reason);
                float t = (float)BanTimeMin * 60;
                timer.Once(t, () =>
                {
                    Player.Unban(player.Id);
                });
            }
        }

        private void WarnPlayer(IPlayer player)
        {
            if (warnoffenseamount)
            {
                if (PlayerOffenses.ContainsKey(player.Id))
                {
                    if (MuteCount != 0)
                    {
                        player.Reply(string.Format(GetLang("OffenseWarning", player.Id), PlayerOffenses[player.Id].offenses + 1));
                    }
                    if (KickCount >= PlayerOffenses[player.Id].offenses)
                    {
                        if (BroadcastKick)
                        {
                            if (KickCount != 0)
                            {
                                player.Reply(string.Format(GetLang("OffenseWarningKick", player.Id), PlayerOffenses[player.Id].offenses + 1, KickCount));
                            }
                        }
                    }
                    if (BroadcastBan)
                    {
                        if (BanCount != 0)
                        {
                            player.Reply(string.Format(GetLang("OffenseWarningBan", player.Id), PlayerOffenses[player.Id].offenses + 1, BanCount));
                        }

                    }
                }
            }
        }

        private bool MustExclude(IPlayer player)
        {
            var list = GroupsToExclude.ToList();
            if (list == null) { return false; }
            if (list.Count < 1) { return false; }

            foreach (var group in list)
            {
                if (group == null) { continue; }
                if (group.ToString() == "" || group.ToString() == " ") { continue; }

                if (permission.UserHasGroup(player.Id, group.ToString()))
                {
                    return true;
                }
            }
            return false;
        }

        private bool GetIsMuted(ref IPlayer aPlayer)
        {
            bool isServerMuted = (bool)BetterChatMute.Call("API_IsMuted", aPlayer);

            return isServerMuted;
        }


        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["KickReason"] = "Bad Language",
                ["BanReason"] = "Bad Language",
                ["MuteReason"] = "Bad Language",
                ["BroadcastKickFormat"] = "{0} was kicked for {1}",
                ["BroadcastBanFormat"] = "{0} was banned for {1}",
                ["NoOffenses"] = "You have no offenses.",
                ["OffenseCount"] = "You have {0} offenses.",
                ["SyntaxError"] = "Invalid Syntax",
                ["HasOffenseCount"] = "{0} has {1} offenses.",
                ["HasNoOffenses"] = "{0} has no offenses.",
                ["Cleared"] = "Offenses for {0} cleared.",
                ["SelfCleared"] = "Your offenses have been cleared by {0}",
                ["NoPermission"] = "You do not have permission to use this.",
                ["OffenseWarning"] = "You currently have {0} Bad language offenses",
                ["OffenseWarningKick"] = "You currently have {0} of {1} Bad language Offenses till kick",
                ["OffenseWarningBan"] = "You currently have {0} of {1} Bad language Offenses till Ban",
                ["CantUseSpecialCharacters"] = "Special characters in your chat not allowed"
            }, this, "en");
        }
        private void ClearOffense(IPlayer player)
        {
            if (PlayerOffenses.ContainsKey(player.Id))
            {
                PlayerOffenses[player.Id].offenses = 0;
                SaveData();
            }
            else
            {
                return;
            }
        }

        private void LoadData()
        {
            PlayerOffenses = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, OffenseData>>(Name);
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating new config file...");
        }

        private void LoadConfiguration()
        {
            CheckCfg<bool>("Exclude Team Chat", ref ExcludeTeamChat);
            CheckCfg<bool>("Warn Players with offense amount", ref warnoffenseamount);
            CheckCfg<int>("Offenses - Time To Mute", ref TimeToMute);
            CheckCfg<int>("Offenses - Count To Mute", ref MuteCount);
            CheckCfg<int>("Offenses - Count To Kick", ref KickCount);
            CheckCfg<int>("Offenses - Count To Ban", ref BanCount);
            CheckCfg<int>("Time to Ban in Minutes", ref BanTimeMin);
            CheckCfg<bool>("Word Filter - Enabled", ref WordFilter_Enabled);
            CheckCfg<bool>("Whole Message Filter - Enabled", ref FilterAll);
            CheckCfg<string>("Word Filter - Replacement", ref WordFilter_Replacement);
            CheckCfg<bool>("Word Filter - Use Custom Replacement", ref WordFilter_UseCustomReplacement);
            CheckCfg<string>("Word Filter - Custom Replacement", ref WordFilter_CustomReplacement);
            CheckCfg<bool>("Advanced - Use REGEX", ref UseRegex);
            CheckCfg<string>("Advanced - Regex to use", ref regextouse);
            CheckCfg<List<object>>("Word Filter List", ref WordFilter_Phrases);
            CheckCfg<List<object>>("Word To White List", ref WordWhiteList);
            CheckCfg<List<object>>("UserGroups to exclude", ref GroupsToExclude);
            CheckCfg<int>("Clear Offense After (0 - Disabled, 1 - All Kick/Mute/ban, 2 - Kick,  3 - Mute,  4 - Ban", ref clear);
            CheckCfg<bool>("Offenses - Broadcast kick", ref BroadcastKick);
            CheckCfg<bool>("Offenses - Broadcast Ban", ref BroadcastBan);
            CheckCfg<bool>("Block Special Characters in Chat", ref BlockSpecialCharacters);
            SaveConfig();
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        #endregion

        //////////////////////////////////////////////////////////////////////////////////


        #region Command 

        [Command("clearfilters")]
        private void ClearFilter(IPlayer player, string command, string[] args)
        {
            if (player.HasPermission("betterchatfilter.admin"))
            {
                foreach (var p in players.Connected)
                {
                    ClearOffense(p);
                    player.Reply(string.Format(GetLang("Cleared", player.Id), p.Name));
                    p.Reply(string.Format(GetLang("SelfCleared", player.Id), player.Name));
                }
            }
        }

        [Command("filter")]
        private void CmdFilter(IPlayer player, string command, string[] args)
        {
            if (player.HasPermission("betterchatfilter.admin"))
            {

                if (args.Length == 0)
                {
                    int offenseCount = PlayerOffenses.ContainsKey(player.Id) == true ? PlayerOffenses[player.Id].offenses : 0;
                    if (offenseCount == 0)
                    {
                        player.Reply(GetLang("NoOffenses", player.Id));
                    }
                    else
                    {
                        player.Reply(string.Format(GetLang("OffenseCount", player.Id), offenseCount));
                    }
                    return;
                }
                if (args.Length != 2)
                {
                    player.Reply(GetLang("SyntaxError", player.Id));
                    return;
                }
                IPlayer target = GetPlayer(args[1], player);
                if (target == null)
                {
                    return;
                }
                switch (args[0])
                {

                    case "check":
                    case "info":
                        int offenseCount = PlayerOffenses.ContainsKey(target.Id) == true ? PlayerOffenses[target.Id].offenses : 0;
                        if (offenseCount == 0)
                        {
                            player.Reply(string.Format(GetLang("HasNoOffenses", player.Id), target.Name));
                        }
                        else
                        {
                            player.Reply(string.Format(GetLang("HasOffenseCount", player.Id), target.Name, offenseCount));
                        }
                        break;
                    case "remove":
                    case "clear":
                    case "delete":
                        ClearOffense(target);
                        player.Reply(string.Format(GetLang("Cleared", player.Id), target.Name));
                        target.Reply(string.Format(GetLang("SelfCleared", player.Id), player.Name));
                        break;
                }

            }
            else
            {
                if (args.Length > 0)
                {
                    player.Reply(GetLang("NoPermission", player.Id));
                    return;
                }
                int offenseCount = PlayerOffenses.ContainsKey(player.Id) == true ? PlayerOffenses[player.Id].offenses : 0;
                if (offenseCount == 0)
                {
                    player.Reply(GetLang("NoOffenses", player.Id));
                }
                else
                {
                    player.Reply(string.Format(GetLang("OffenseCount", player.Id), offenseCount));
                }
            }
        }


        #endregion

        #region Word Filter

        private string FilterText(IPlayer player, string original)
        {
            var filtered = original;
            int count = 0;
            bool WordMatch = false;
            Regex r = new Regex(regextouse, RegexOptions.IgnoreCase);
            foreach (var word in original.Split(' '))
            {
                if (DoWhiteList(word.ToLower())) { continue; }
                if (UseRegex)
                {
                    Match m = r.Match(word);
                    if (m.Success)
                    {
                        Puts($"REGEX MATCH : {player.Name} said: \"{original}\" which contained a bad word: \"{word}\"");
                        filtered = filtered.Replace(word, Replace(word));
                        count++;
                    }
                }

                foreach (string bannedword in WordFilter_Phrases)
                    if (TranslateLeet(word).ToLower().Contains(bannedword.ToLower()))
                    {

                        Puts($"BANNED WORDS MATCH :| {player.Name} said: \"{original}\" which contained a bad word: \"{word}\"");
                        filtered = filtered.Replace(word, Replace(word));
                        if (FilterAll)
                        {
                            filtered = "";
                        }

                        WordMatch = true;

                    }
            }
            if (WordMatch)
            {
                count++;
                WarnPlayer(player);
            }
            if (count > 0)
            {
                Offsense(player);
            }

            return filtered;
        }

        private bool DoWhiteList(string word)
        {
            if (word == null || word == "" || word == " ") { return false; }
            var endchar = word.Last();
            if (endchar == 0) { return false; }
            var _whitelist = WordWhiteList.ToList();
            if (Char.IsPunctuation(endchar))
            {
                foreach (var w in _whitelist)
                {
                    if (word.Contains(w.ToString().ToLower())) { return true; }
                }
                return false;
            }
            if (_whitelist.Contains(word.ToLower()))
            {
                return true;
            }
            foreach (var w in _whitelist)
            {
                if (word.Contains(w.ToString().ToLower())) { return true; }
            }
            return false;
        }

        private string Replace(string original)
        {
            var filtered = string.Empty;
            if (!WordFilter_UseCustomReplacement && WordFilter_Replacement == "") { return original; }
            if (!WordFilter_UseCustomReplacement)
                for (; filtered.Count() < original.Count();)
                    filtered += WordFilter_Replacement;
            else
                filtered = WordFilter_CustomReplacement;

            return filtered;
        }

        private string TranslateLeet(string original)
        {
            var translated = original;

            var leetTable = new Dictionary<string, string>
            {
                {"}{", "h"},
                {"|-|", "h"},
                {"]-[", "h"},
                {"/-/", "h"},
                {"|{", "k"},
                {"/\\/\\", "m"},
                {"|\\|", "n"},
                {"/\\/", "n"},
                {"()", "o"},
                {"[]", "o"},
                {"vv", "w"},
                {"\\/\\/", "w"},
                {"><", "x"},
                {"2", "z"},
                {"4", "a"},
                {"@", "a"},
                {"8", "b"},
                {"", "b"},
                {"(", "c"},
                {"<", "c"},
                {"{", "c"},
                {"3", "e"},
                {"", "e"},
                {"6", "g"},
                {"9", "g"},
                {"&", "g"},
                {"#", "h"},
                {"$", "s"},
                {"7", "t"},
                {"|", "l"},
                {"1", "i"},
                {"!", "i"},
                {"0", "o"}
            };

            foreach (var leet in leetTable)
                translated = translated.Replace(leet.Key, leet.Value);

            return translated;
        }

        #endregion

        //////////////////////////////////////////////////////////////////////////////////


        #region Finding Helper

        private IPlayer GetPlayer(string nameOrID, IPlayer player)
        {
            if (IsParseableTo<string, ulong>(nameOrID) && nameOrID.StartsWith("7656119") && nameOrID.Length == 17)
            {
                IPlayer result = players.All.ToList().Find((p) => p.Id == nameOrID);

                if (result == null)
                    player.Reply($"Could not find player with ID '{nameOrID}'");

                return result;
            }

            List<IPlayer> foundPlayers = new List<IPlayer>();

            foreach (IPlayer current in players.Connected)
            {
                if (current.Name.ToLower() == nameOrID.ToLower())
                    return current;

                if (current.Name.ToLower().Contains(nameOrID.ToLower()))
                    foundPlayers.Add(current);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    player.Reply($"Could not find player with name '{nameOrID}'");
                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    string[] names = (from current in foundPlayers select current.Name).ToArray();
                    player.Reply("Multiple matching players found: \n" + string.Join(", ", names));
                    break;
            }

            return null;
        }

        #endregion

        #region Convert Helper

        private bool IsParseableTo<S, R>(S s)
        {
            R result;
            return TryParse(s, out result);
        }

        private bool TryParse<S, R>(S s, out R c)
        {
            try
            {
                c = (R)Convert.ChangeType(s, typeof(R));
                return true;
            }
            catch
            {
                c = default(R);
                return false;
            }
        }

        #endregion

    }
}


// --- End of file: BetterChatFilter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/block-remover ---
// --- Original File Path: B/BlockRemover/BlockRemover.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Block Remover", "austinv900", "0.4.55")]
    [Description("Allows admins to count and remove building blocks outside of cupboard range")]
    class BlockRemover : RustPlugin
    {
        private ConfigData configData;
        private const string PermCount = "blockremover.count";
        private const string PermRemove = "blockremover.remove";

        class ConfigData
        {
            public bool WarnPlayers { get; set; }
            public VersionNumber Version { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new ConfigData
            {
                WarnPlayers = true,
                Version = Version
            }, true);
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(new Dictionary<string, string>
        {
            ["Block.Remove.Grade.Start"] = "Admin is removing all {block.Grade} blocks outside of Building Privilege...",
            ["Block.Remove.Grade.End"] = "Admin has removed {block.Count} {block.Grade} blocks from the map",
            ["Block.Remove.All.Start"] = "Admin is removing all blocks outside of Building Privilege...",
            ["Block.Remove.All.End"] = "Admin has removed {block.Count} blocks from the map"
        }, this);

        void OnServerInitialized()
        {
            configData = Config.ReadObject<ConfigData>();
            if (configData.Version != Version)
            {
                configData.Version = Version;
                Config.WriteObject(configData, true);
            }
            permission.RegisterPermission(PermCount, this);
            permission.RegisterPermission(PermRemove, this);
        }

        [ConsoleCommand("block.countall")]
        void cmdCountBlockAll(ConsoleSystem.Arg arg)
        {
            if (!CheckAccess(arg, PermCount)) return;
            var replyBuilder = new StringBuilder();
            var stabilityEntities = FindAllCupboardlessStabilityEntities(replyBuilder);
            replyBuilder.AppendLine($"There are {stabilityEntities.Count} blocks outside of Building Privilege");

            if (stabilityEntities.Count > 0)
            {
                var types = stabilityEntities.GroupBy(p => p.GetType());
                var vals = string.Join(", ", types.Select(kv => $"{kv.Key.FullName}({kv.Count()})"));
                replyBuilder.Append(vals);
            }

            SendReply(arg, replyBuilder.ToString().TrimEnd(' ', ','));
            Facepunch.Pool.FreeList(ref stabilityEntities);
        }

        [ConsoleCommand("block.count")]
        void cmdCountBlock(ConsoleSystem.Arg arg)
        {
            if (!CheckAccess(arg, PermCount)) return;
            BuildingGrade.Enum grade;
            if (!ParseGrade(arg, out grade)) return;

            var replyBuilder = new StringBuilder();
            var blocks = FindAllCupboardlessBlocks(grade, replyBuilder);
            replyBuilder.AppendLine($"There are {blocks.Count} {grade} blocks outside of Building Privilege");
            SendReply(arg, replyBuilder.ToString());
            Facepunch.Pool.FreeList(ref blocks);
        }

        [ConsoleCommand("block.remove")]
        void cmdRemoveBlock(ConsoleSystem.Arg arg)
        {
            if (!CheckAccess(arg, PermRemove)) return;
            BuildingGrade.Enum grade;
            if (!ParseGrade(arg, out grade)) return;
            

            var replyBuilder = new StringBuilder();
            var blocks = FindAllCupboardlessBlocks(grade, replyBuilder);

            if (blocks.Count > 0)
            {
                var keys = new Dictionary<string, string>();
                keys.Add("block.Count", blocks.Count.ToString());
                keys.Add("block.Grade", grade.ToString());
                keys.Add("task.StartTime", DateTime.UtcNow.ToShortTimeString());
                var started_at = Time.realtimeSinceStartup;
                WarnOnlineMembers("Block.Remove.Grade.Start", keys);
                ServerMgr.Instance.StartCoroutine(ProcessRemoval(blocks, l =>
                {
                    keys.Add("task.EndTime", DateTime.UtcNow.ToShortTimeString());
                    keys.Add("task.ElapseSeconds", (Time.realtimeSinceStartup - started_at).ToString("0.000"));
                    replyBuilder.AppendLine($"Destroyed {blocks.Count} {grade} blocks in {keys["task.ElapseSeconds"]} seconds");
                    WarnOnlineMembers("Block.Remove.Grade.End", keys);
                    SendReply(arg, replyBuilder.ToString());
                    Facepunch.Pool.FreeList(ref l);
                }));
            }
            else
            {
                SendReply(arg, replyBuilder.ToString());
                Facepunch.Pool.FreeList(ref blocks);
            }
        }

        [ConsoleCommand("block.removeall")]
        void cmdRemoveBlockAll(ConsoleSystem.Arg arg)
        {
            if (!CheckAccess(arg, PermRemove)) return;
            
            var replyBuilder = new StringBuilder();
            var stabilityEntities = FindAllCupboardlessStabilityEntities(replyBuilder);

            if (stabilityEntities.Count > 0)
            {
                var keys = new Dictionary<string, string>();
                keys.Add("block.Count", stabilityEntities.Count.ToString());
                keys.Add("task.StartTime", DateTime.UtcNow.ToShortTimeString());
                var started_at = Time.realtimeSinceStartup;
                WarnOnlineMembers("Block.Remove.All.Start", keys);

                ServerMgr.Instance.StartCoroutine(ProcessRemoval(stabilityEntities, l =>
                {
                    keys.Add("task.EndTime", DateTime.UtcNow.ToShortTimeString());
                    keys.Add("task.ElapseSeconds", (Time.realtimeSinceStartup - started_at).ToString("0.000"));
                    var type = stabilityEntities.GroupBy(e => e.GetType());
                    var vals = string.Join(", ", type.Select(kv => $"{kv.Key.FullName}({kv.Count()})"));
                    keys.Add("block.RemoveList", vals);
                    replyBuilder.AppendLine($"Destroyed {stabilityEntities.Count} blocks in {keys["task.ElapseSeconds"]} seconds");
                    replyBuilder.Append(vals);
                    WarnOnlineMembers("Block.Remove.All.End", keys);
                    SendReply(arg, replyBuilder.ToString().TrimEnd(' ', ','));
                    Facepunch.Pool.FreeList(ref stabilityEntities);
                }));
            }
            else
            {
                SendReply(arg, replyBuilder.ToString().TrimEnd(' ', ','));
                Facepunch.Pool.FreeList(ref stabilityEntities);
            }
        }

        List<BuildingBlock> FindAllCupboardlessBlocks(BuildingGrade.Enum grade, StringBuilder reply)
        {
            var blocks = FindAllBuildingBlocks(grade, reply);
            FilterAllCupboardless(blocks, reply);
            return blocks;
        }

        List<StabilityEntity> FindAllCupboardlessStabilityEntities(StringBuilder reply)
        {
            var stabilityEntities = FindAllStabilityEntities(reply);
            FilterAllCupboardless(stabilityEntities, reply);
            return stabilityEntities;
        }

        void FilterAllCupboardless<T>(List<T> blocks, StringBuilder reply) where T : StabilityEntity
        {
            var started_at = Time.realtimeSinceStartup;

            foreach (var ent in blocks.ToArray())
            {
                if (ent is BuildingPrivlidge)
                {
                    blocks.Remove(ent);
                    continue;
                }
                
                var priv = ent.GetBuildingPrivilege();

                if (priv != null)
                {
                    blocks.Remove(ent);
                    continue;
                }

                if (TerrainMeta.Path.Monuments.Any(m => m.Bounds.Contains(ent.transform.position)))
                {
                    blocks.Remove(ent);
                    continue;
                }

                if ((ent is Door || ent is Lift) && ent.OwnerID == 0)
                {
                    blocks.Remove(ent);
                    continue;
                }

                if (ent.transform.position == Vector3.zero)
                {
                    continue;
                }

                var bounds = new OBB(ent.transform.position, ent.transform.rotation, ent.bounds);
                priv = ent.GetBuildingPrivilege(bounds);

                if (priv != null)
                {
                    blocks.Remove(ent);
                    continue;
                }
            }

            reply?.AppendLine($"Finding {blocks.Count} cupboardless blocks took {Time.realtimeSinceStartup - started_at:0.000} seconds");
        }

        List<BuildingBlock> FindAllBuildingBlocks(BuildingGrade.Enum grade, StringBuilder reply)
        {
            var started_at = Time.realtimeSinceStartup;
            var blocks = Facepunch.Pool.GetList<BuildingBlock>();
            blocks.AddRange(BaseNetworkable.serverEntities.OfType<BuildingBlock>().Where(block => block.grade == grade));
            reply?.AppendLine($"Finding {blocks.Count} {grade} blocks took {Time.realtimeSinceStartup - started_at:0.000} seconds");
            return blocks;
        }

        List<StabilityEntity> FindAllStabilityEntities(StringBuilder reply)
        {
            var started_at = Time.realtimeSinceStartup;
            var stabilityEntities = Facepunch.Pool.GetList<StabilityEntity>();
            stabilityEntities.AddRange(BaseNetworkable.serverEntities.OfType<StabilityEntity>());
            reply?.AppendLine($"Finding {stabilityEntities.Count} blocks took {Time.realtimeSinceStartup - started_at:0.000} seconds");
            return stabilityEntities;
        }

        bool CheckAccess(ConsoleSystem.Arg arg, string perm)
        {
            if (arg != null && arg.Connection == null || arg.Player() != null && (arg.Player().IsAdmin || permission.UserHasPermission(arg.Player().UserIDString, perm)))
                return true;
            SendReply(arg, "You need to be admin to use that command");
            return false;
        }

        bool ParseGrade(ConsoleSystem.Arg arg, out BuildingGrade.Enum grade)
        {
            grade = BuildingGrade.Enum.Twigs;
            if (arg.HasArgs())
            {
                try
                {
                    grade = (BuildingGrade.Enum)Enum.Parse(typeof(BuildingGrade.Enum), arg.GetString(0), true);
                }
                catch (Exception)
                {
                    SendReply(arg, $"Unknown grade '{arg.GetString(0)}'");
                    return false;
                }
            }
            return true;
        }

        void WarnOnlineMembers(string langKey, Dictionary<string, string> args)
        {
            if (!configData.WarnPlayers)
                return;

            foreach (var player in BasePlayer.activePlayerList)
            {
                var msg = GetMessage(langKey, player.userID);

                if (args != null)
                {
                    foreach (var replacement in args)
                    {
                        msg = msg.Replace("{" + replacement.Key + "}", replacement.Value, StringComparison.InvariantCultureIgnoreCase);
                    }
                }

                player.ChatMessage(msg);
            }
        }

        string GetMessage(string key, ulong id) => lang.GetMessage(key, this, id == 0 ? null : id.ToString());

        private IEnumerator ProcessRemoval<T>(List<T> blocks, Action<List<T>> onFinish) where T : StabilityEntity
        {
            var current = 0;

            while (true)
            {
                var set = blocks.Skip(current);

                if (set.Count() == 0)
                {
                    break;
                }

                for (var i = 0; i < 10; i++)
                {
                    var c = set.ElementAtOrDefault(i);

                    c?.Kill();
                    current++;
                }

                yield return null;
            }

            onFinish(blocks);
        }
    }
}


// --- End of file: BlockRemover.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bouncy-c4 ---
// --- Original File Path: B/BouncyC4/BouncyC4.cs ---

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Bouncy C4", "VisEntities", "1.1.0")]
    [Description("Throw non-sticking bouncy explosives.")]
    public class BouncyC4 : RustPlugin
    {
        #region Fields

        private static BouncyC4 _plugin;

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            _plugin = this;
            PermissionUtil.RegisterPermissions();
        }

        private void Unload()
        {
            _plugin = null;
        }

        private object CanExplosiveStick(TimedExplosive explosive, BaseEntity entity)
        {
            BasePlayer entityOwner = FindPlayerById(entity.OwnerID);
            if (entityOwner != null && PermissionUtil.VerifyHasPermission(entityOwner, PermissionUtil.USE))
            {
                Rigidbody rb = explosive.GetComponent<Rigidbody>();
                if (rb == null)
                    rb = explosive.gameObject.AddComponent<Rigidbody>();

                Collider collider = explosive.gameObject.GetComponent<Collider>();
                if (collider != null)
                {
                    collider.material = new PhysicMaterial
                    {
                        bounciness = 1.0f,
                        bounceCombine = PhysicMaterialCombine.Maximum
                    };
                }

                // Slow down the rotation over time.
                rb.angularDrag = 0.05f;
                // Random spin in all directions.
                rb.angularVelocity = new Vector3(Random.Range(-15, 15), Random.Range(-15, 15), Random.Range(-15, 15));

                return false;
            }

            return null;
        }

        #endregion Oxide Hooks

        #region Helper Functions

        public static BasePlayer FindPlayerById(ulong playerId)
        {
            return RelationshipManager.FindByID(playerId);
        }

        #endregion Helper Functions

        #region Utility Classes

        private static class PermissionUtil
        {
            public const string USE = "bouncyc4.use";

            public static void RegisterPermissions()
            {
                _plugin.permission.RegisterPermission(USE, _plugin);
            }

            public static bool VerifyHasPermission(BasePlayer player, string permissionName = USE)
            {
                return _plugin.permission.UserHasPermission(player.UserIDString, permissionName);
            }
        }

        #endregion Utility Classes
    }
}

// --- End of file: BouncyC4.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ban-delete-by ---
// --- Original File Path: B/BanDeleteBy/BanDeleteBy.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Ban Delete By", "Ryan", "1.0.4")]
    [Description("Removes all entities placed by a player when they get banned.")]

    class BanDeleteBy : RustPlugin
    {
        private void OnUserBanned(string name, string id)
        {
            var ID = Convert.ToUInt64(id);
            if (ID.IsSteamId())
            {
                ConVar.Entity.DeleteBy(ID);
                LogToFile("", $"Deleting all entities owned by {name} ({id}) because they got banned", this, false);
            }
        }

        private IEnumerator Delete(IEnumerable<BaseNetworkable> list, HashSet<ulong> banList)
        {
            var count = 0;
            foreach (var networkable in list)
            {
                var entity = networkable as BaseEntity;
                if (entity != null && banList.Contains(entity.OwnerID))
                {
                    networkable.Kill();
                    count++;
                    yield return new WaitWhile(() => !networkable.IsDestroyed);
                }
            }
            if(count > 0)
                Puts($"Removed {count} entities belonging to {banList.Count} banned players");
            else
                NextTick(() => { Puts($"No entities found belonging to {banList.Count} banned players"); });
        }

        [ConsoleCommand("deleteby.removeall")]
        private void RemoveAllCommand(ConsoleSystem.Arg args)
        {
            var bannedPlayers = new HashSet<ulong>(ServerUsers.GetAll(ServerUsers.UserGroup.Banned).Select(x => x.steamid));
            ServerMgr.Instance.StartCoroutine(Delete(BaseNetworkable.serverEntities, bannedPlayers));
            args.ReplyWith($"Started to remove entities belonging to banned players");
        }
    }
}

// --- End of file: BanDeleteBy.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/big-wheel-spawn-fix ---
// --- Original File Path: B/BigWheelSpawnFix/BigWheelSpawnFix.cs ---

using UnityEngine;

namespace Oxide.Plugins
{
    // Creation date: 11-04-2021
    // Last update date: 27-08-2022
    [Info("Big Wheel Spawn Fix", "Orange and Smallo", "1.1.0")]
    [Description("Fixes big wheels spawned faced down")]
    public class BigWheelSpawnFix : RustPlugin
    {
        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));
        }

        private void OnEntitySpawned(BigWheelGame entity)
        {
            var transform = entity.transform;
            var old = transform.eulerAngles;
			var space = transform;
            old.x = 90;
            transform.eulerAngles = old;
			transform.Rotate(0.0f, -90.0f, 0.0f, Space.Self);
        }
    }
}

// --- End of file: BigWheelSpawnFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bodies-to-bags ---
// --- Original File Path: B/BodiesToBags/BodiesToBags.cs ---

using System.Linq;

namespace Oxide.Plugins
{
    [Info("Bodies to Bags", "Ryan", "2.0.0")]
    [Description("Modifies the time it takes for bodies to become bags")]
    public class BodiesToBags : RustPlugin
    {
        #region Configuration

        private bool ConfigChanged = false;
        private int _despawnTime;

        protected override void LoadDefaultConfig() => PrintWarning("Generating default configuration file...");

        private void InitConfig()
        {
            _despawnTime = GetConfig(5, "Settings", "Despawn time of bodies (seconds)");

            if (ConfigChanged)
            {
                PrintWarning("Updated configuration file with new/changed values.");
                SaveConfig();
            }
        }

        private T GetConfig<T>(T defaultVal, params string[] path)
        {
            var data = Config.Get(path);
            if (data != null)
            {
                return Config.ConvertValue<T>(data);
            }

            Config.Set(path.Concat(new object[] { defaultVal }).ToArray());
            ConfigChanged = true;
            return defaultVal;
        }

        #endregion

        private void Init()
        {
            InitConfig();
        }

        // Use the OnEntitySpawned hook with relevant overload vs OnPlayerCorpseSpawned as it doesn't work for Scientist NPCs
        private void OnEntitySpawned(LootableCorpse corpse)
        {
            corpse.ResetRemovalTime(_despawnTime);
        }

        private void OnLootEntityEnd(BasePlayer player, PlayerCorpse corpse)
        {
            // Next tick is required here due to the ordering of this hook call in "LootableCorpse"
            // It resets the removal time of the corpse based on the "corpsedespawn" convar, which impacts the animal corpse despawns as collateral
            NextTick(() =>
            {
                corpse.ResetRemovalTime(_despawnTime);
            });
        }
    }
}


// --- End of file: BodiesToBags.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-chinook-patrol ---
// --- Original File Path: B/BetterChinookPatrol/BetterChinookPatrol.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("Better Chinook Patrol", "WhiteThunder", "0.2.0")]
    [Description("Allows customizing which monuments chinooks will visit.")]
    internal class BetterChinookPatrol : CovalencePlugin
    {
        #region Fields

        private const float VanillaDropZoneDistanceTolerance = 200;

        private Configuration _config;
        private List<Vector3> _eligiblePatrolPoints = new List<Vector3>();

        #endregion

        #region Hooks

        private void Init()
        {
            _config.Init(this);
        }

        private void OnServerInitialized()
        {
            var sb = new StringBuilder();
            var dropZoneCount = 0;

            foreach (var monumentInfo in TerrainMeta.Path.Monuments)
            {
                if (_config.DisallowSafeZoneMonuments && monumentInfo.IsSafeZone)
                    continue;

                string monumentName;
                if (!_config.AllowsMonument(monumentInfo, out monumentName))
                    continue;

                var monumentPosition = monumentInfo.transform.position;
                _eligiblePatrolPoints.Add(monumentPosition);

                var hasDropZone = false;
                var closestDropZone = CH47DropZone.GetClosest(monumentPosition);
                if (closestDropZone != null)
                {
                    hasDropZone = Vector3Ex.Distance2D(closestDropZone.transform.position, monumentPosition) < VanillaDropZoneDistanceTolerance;
                }

                if (hasDropZone)
                {
                    dropZoneCount++;
                }

                var dropZoneInfo = hasDropZone ? " -- HAS DROP ZONE" : string.Empty;
                sb.AppendLine($"- {monumentName}{dropZoneInfo}");
            }

            Log($"{_eligiblePatrolPoints.Count} monuments on this map may be visited by Chinooks. {dropZoneCount} have drop zones.\n{sb}");
        }

        private void OnEntitySpawned(CH47HelicopterAIController ch47)
        {
            // Ignore reinforcement chinooks.
            if (ch47.ShouldLand())
                return;

            var brain = ch47.GetComponent<CH47AIBrain>();
            if (brain == null)
                return;

            NextTick(() =>
            {
                // If the brain doesn't have a path finder, perhaps another plugin is controlling it.
                var pathFinder = brain.PathFinder as CH47PathFinder;
                if (pathFinder == null)
                    return;

                if (ChinookWasBlocked(ch47))
                    return;

                brain.PathFinder = new BetterCH47PathFinder(_eligiblePatrolPoints);

                // If the chinook is already in a patrol state, its interest point must be updated.
                if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Patrol)
                {
                    brain.mainInterestPoint = brain.PathFinder.GetRandomPatrolPoint();
                }

                if (_config.MinCrateDropsPerChinook > 1 && _config.MaxCrateDropsPerChinook > 1)
                {
                    ch47.numCrates = UnityEngine.Random.Range(_config.MinCrateDropsPerChinook, _config.MaxCrateDropsPerChinook + 1);
                }
            });
        }

        #endregion

        #region Exposed Hooks

        private bool ChinookWasBlocked(CH47HelicopterAIController ch47)
        {
            var result = Interface.CallHook("OnBetterChinookPatrol", ch47);
            return result is bool && (bool)result == false;
        }

        #endregion

        #region Helpers

        private static class StringUtils
        {
            public static bool Equals(string a, string b) =>
                string.Compare(a, b, StringComparison.OrdinalIgnoreCase) == 0;

            public static bool Contains(string haystack, string needle) =>
                haystack.Contains(needle, CompareOptions.IgnoreCase);
        }

        #endregion

        #region Pathfinder

        private class BetterCH47PathFinder : CH47PathFinder
        {
            private const float RevisitMaxProximity = 100;

            public List<Vector3> _patrolPath;
            private int _patrolPathIndex;

            public BetterCH47PathFinder(List<Vector3> eligiblePatrolPoints)
            {
                // Randomly shuffle the patrol points.
                _patrolPath = eligiblePatrolPoints.OrderBy(x => UnityEngine.Random.Range(0, 1000)).ToList();

                for (var i = _patrolPath.Count - 1; i >= 0; i--)
                {
                    for (var j = 0; j < i; j++)
                    {
                        // Remove any patrol points that are close to previous patrol points.
                        if (Vector3Ex.Distance2D(_patrolPath[i], _patrolPath[j]) < RevisitMaxProximity)
                        {
                            _patrolPath.RemoveAt(i);
                            break;
                        }
                    }
                }
            }

            public override Vector3 GetRandomPatrolPoint()
            {
                if (_patrolPath.Count == 0)
                    return Vector3.zero;

                if (_patrolPathIndex >= _patrolPath.Count)
                {
                    _patrolPathIndex = 0;
                }

                return _patrolPath[_patrolPathIndex++];
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : SerializableConfiguration
        {
            [JsonIgnore]
            public List<MonumentType> DisallowedMonumentTypes = new List<MonumentType>();

            [JsonIgnore]
            public MonumentTier DisallowedMonumentTiersMask;

            [JsonProperty("Min crate drops per chinook")]
            public int MinCrateDropsPerChinook = 1;

            [JsonProperty("Max crate drops per chinook")]
            public int MaxCrateDropsPerChinook = 1;

            [JsonProperty("Disallow safe zone monuments")]
            public bool DisallowSafeZoneMonuments = true;

            [JsonProperty("Disallowed monument types")]
            private string[] DisallowedMonumentTypesNames =
            {
                "Cave",
                "WaterWell",
            };

            [JsonProperty("Disallowed monument tiers")]
            private string[] DisallowedMonumentTierNames =
            {
                "Tier0"
            };

            [JsonProperty("Disallowed monument prefabs (partial match)")]
            private string[] DisallowedMonumentPartialPrefabs = Array.Empty<string>();

            [JsonProperty("Disallowed monument prefabs (exact match)")]
            private string[] DisallowedMonumentExactPrefabs = Array.Empty<string>();

            [JsonProperty("Force allow monument prefabs (partial match)")]
            private string[] ForceAllowedMonumentPartialPrefabs = Array.Empty<string>();

            [JsonProperty("Force allow monument prefabs (exact match)")]
            private string[] ForceAllowedMonumentExactPrefabs = Array.Empty<string>();

            public void Init(BetterChinookPatrol pluginInstance)
            {
                if (DisallowedMonumentTypesNames != null)
                {
                    foreach (var monumentTypeName in DisallowedMonumentTypesNames)
                    {
                        MonumentType monumentType;
                        if (Enum.TryParse(monumentTypeName, ignoreCase: true, result: out monumentType))
                        {
                            DisallowedMonumentTypes.Add(monumentType);
                        }
                        else
                        {
                            pluginInstance.LogError($"Invalid monument type: {monumentTypeName}");
                        }
                    }
                }

                if (DisallowedMonumentTierNames != null)
                {
                    foreach (var monumentTierName in DisallowedMonumentTierNames)
                    {
                        MonumentTier monumentTier;
                        if (Enum.TryParse(monumentTierName, ignoreCase: true, result: out monumentTier))
                        {
                            DisallowedMonumentTiersMask |= monumentTier;
                        }
                        else
                        {
                            pluginInstance.LogError($"Invalid monument tier: {monumentTierName}");
                        }
                    }
                }
            }

            public bool AllowsMonument(MonumentInfo monumentInfo, out string monumentName)
            {
                monumentName = monumentInfo.name;
                if (monumentName.Contains("monument_marker.prefab"))
                {
                    monumentName = monumentInfo.transform.root.name;
                }

                if (ForceAllowedMonumentPartialPrefabs != null)
                {
                    foreach (var partialPrefab in ForceAllowedMonumentPartialPrefabs)
                    {
                        if (!string.IsNullOrWhiteSpace(partialPrefab) && StringUtils.Contains(monumentName, partialPrefab))
                            return true;
                    }
                }

                if (ForceAllowedMonumentExactPrefabs != null)
                {
                    foreach (var exactPrefab in ForceAllowedMonumentExactPrefabs)
                    {
                        if (!string.IsNullOrWhiteSpace(exactPrefab) && StringUtils.Equals(monumentName, exactPrefab))
                            return true;
                    }
                }

                if (DisallowedMonumentPartialPrefabs != null)
                {
                    foreach (var partialPrefab in DisallowedMonumentPartialPrefabs)
                    {
                        if (!string.IsNullOrWhiteSpace(partialPrefab) && StringUtils.Contains(monumentName, partialPrefab))
                            return false;
                    }
                }

                if (DisallowedMonumentExactPrefabs != null)
                {
                    foreach (var partialPrefab in DisallowedMonumentExactPrefabs)
                    {
                        if (!string.IsNullOrWhiteSpace(partialPrefab) && StringUtils.Equals(monumentName, partialPrefab))
                            return false;
                    }
                }

                if ((DisallowedMonumentTiersMask & monumentInfo.Tier) != 0)
                    return false;

                if (DisallowedMonumentTypes.Contains(monumentInfo.Type))
                    return false;

                return true;
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion
    }
}


// --- End of file: BetterChinookPatrol.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/building-wrapper ---
// --- Original File Path: B/BuildingWrapper/BuildingWrapper.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;
using Facepunch;

namespace Oxide.Plugins
{
	[Info("Building Wrapper", "Spiikesan", "0.1.7")]
	[Description("Utility to wrap zones around buildings neatly and efficiently")]
	class BuildingWrapper : RustPlugin
	{
		#region Variables
		// ZoneManager base permission
		private const string ZoneManagerPermZone = "zonemanager.zone";

		// link to ZoneManager
		[PluginReference]
		Plugin ZoneManager;
		
        private int layerMasks = LayerMask.GetMask("Construction", "Construction Trigger", "Trigger");
		// usage information string with formatting
		public string usageString;
		// command enum
		private enum Command { usage, wrap, rewrap, extend};
		// option enum
		private enum Option { box, sphere, square, undef };
		// vertical height adjustment
		private const float yAdjust = 2f;
		// collider buffer for finding building blocks
		private Collider[] colBuffer;

		const float previewTime = 15f;

		#endregion

		#region Lang

		// load default messages to Lang
		protected override void LoadDefaultMessages()
		{
			var messages = new Dictionary<string, string>
			{
				{"ChatCommand", "bw"},
				{"VersionString", "BuildingWrapper v. {0}"},

				{"UsageHeader", "---- BuildingWrapper usage ----"},
				{"CmdUsageWrap", "Wrap new or existing zone around the building being looked at"},
				{"CmdUsageRewrap", "Re-wrap all buildings within a zone"},
				{"CmdUsageExtend", "Extend an existing zone to include building being looked at"},
				{"CmdUsageShapes", "Valid shapes: box, sphere, square"},
				{"CmdUsageParamZoneId", "Note: [zone_id] is required, but can be entered as \"auto\" for automatic generation"},

				{"NoZoneManager", "ZoneManager not detected - BuildingWrapper disabled"},
				{"ZoneManagerLoaded", "ZoneManager loaded - BuildingWrapper enabled"},
				{"ZoneManagerUnloaded", "ZoneManager unloaded - BuildingWrapper disabled"},
				{"NoPermission", "You do not have permission to use this command"},

				{"NotSupported", "The command \"{0}\" is not currently supported"},

				{"InvalidParameter", "Invalid Parameter: {0}"},
				{"MissingZoneId", "Missing value for required parameter zone_id (use \"auto\" for automatic assignment)"},
				{"NoAutoZoneId", "Zone ID cannot be auto generated for the command \"{0}\""},
				{"ZoneNotFound", "Zone with ID \"{0}\" could not be found"},
				{"NoBuilding", "No building detected"},

				{"ZoneWrapSuccess", "Successfully created/updated zone {0}"},
				{"ZoneWrapFailure", "Failed to create/update zone {0}"},
				{"Stats", "Blocks: {0}" }
			};
			lang.RegisterMessages(messages, this);
		}

		// get message from Lang
		string GetMessage(string key, string userId = null) => lang.GetMessage(key, this, userId);

		#endregion

		#region Loading/Unloading

		// load
		void Loaded()
		{
			colBuffer = new Collider[8192];
			LoadDefaultMessages();
			string chatCommand = GetMessage("ChatCommand");
			cmd.AddChatCommand(chatCommand, this, "cmdChatDelegator");
			
			// build usage string
			usageString = wrapSize(14, wrapColor("orange", GetMessage("UsageHeader"))) + "\n" +
						  wrapSize(12, wrapColor("green", "/" + chatCommand + " " + Command.wrap + " [zone_id] <shape> <buffer>") + " - " + GetMessage("CmdUsageWrap") + "\n" +
						  wrapColor("green", "/" + chatCommand + " " + Command.rewrap + " [zone_id] <shape> <buffer>") + " - " + GetMessage("CmdUsageRewrap") + "\n" +
						  wrapColor("green", "/" + chatCommand + " " + Command.extend + " [zone_id] <shape> <buffer>") + " - " + GetMessage("CmdUsageExtend") + "\n" +
						  wrapColor("yellow", GetMessage("CmdUsageShapes")) + "\n" +
						  wrapColor("yellow", GetMessage("CmdUsageParamZoneId")));
			
		}
		
		// server initialized
		private void OnServerInitialized()
		{
			if(ZoneManager == null)
				PrintError(GetMessage("NoZoneManager"));
			// don't use popups yet
			//usePopups = (PopupNotifications != null);
		}
		
		// plugin loaded
		private void OnPluginLoaded(Plugin plugin)
		{
			if(plugin.Name == "ZoneManager")
			{
				ZoneManager = plugin;
				Puts(GetMessage("ZoneManagerLoaded"));
			}
		}
		
		// plugin unloaded
		private void OnPluginUnloaded(Plugin plugin)
		{
			if(plugin.Name == "ZoneManager")
			{
				ZoneManager = null;
				PrintWarning(GetMessage("ZoneManagerUnloaded"));
			}
		}

		#endregion

		#region Messaging

		// print usage string
		void showUsage(BasePlayer player)
		{
			SendReply(player, usageString);
		}

		// wrap a string in a <size> tag with the passed size
		static string wrapSize(int size, string input)
		{
			if (input == null || input.Length == 0)
				return input;
			return "<size=" + size + ">" + input + "</size>";
		}

		// wrap a string in a <color> tag with the passed color
		static string wrapColor(string color, string input)
		{
			if (input == null || input.Length == 0 || color == null || color.Length == 0)
				return input;
			return "<color=" + color + ">" + input + "</color>";
		}

		#endregion

		#region Command Handling

		// main delegator process - handles all commands
		void cmdChatDelegator(BasePlayer player, string command, string[] args)
		{
			if(ZoneManager == null)
			{
				SendReply(player, wrapSize(12, wrapColor("red", GetMessage("NoZoneManager", player.UserIDString))));
				return;
			}
			if(!hasPermission(player, ZoneManagerPermZone))
			{
				SendReply(player, wrapSize(12, wrapColor("red", GetMessage("NoPermission", player.UserIDString))));
				return;
			}
			if(args == null || args.Length == 0)
				showUsage(player);
			else if(!Enum.IsDefined(typeof(Command), args[0]))
				SendReply(player, wrapSize(12, wrapColor("red", String.Format(GetMessage("InvalidParameter", player.UserIDString), args[0]))));
			else
			{
				Command cmd = (Command) Enum.Parse(typeof(Command), args[0]);
				if(cmd == Command.usage)
				{
					showUsage(player);
					return;
				}
				
				float buffer = 1.0f;
				Option shape = Option.undef;
				if(args.Length < 2 || args[1].Length == 0)
				{
					SendReply(player, wrapSize(12, wrapColor("red", GetMessage("MissingZoneId", player.UserIDString))));
					return;
				}
				
				// get zone ID
				string zoneId = args[1];
				if(zoneId != null && zoneId == "preview")

				if(zoneId == null || zoneId == "auto")
				{
					if(cmd == Command.extend)
					{
						SendReply(player, wrapSize(12, wrapColor("red", String.Format(GetMessage("NoAutoZoneId", player.UserIDString), cmd.ToString()))));
						return;
					}
					zoneId = UnityEngine.Random.Range(1, 99999999).ToString();
				}
				int i = 2;
				
				// get shape and buffer values if they exist
				if(i < args.Length)
					if(Enum.IsDefined(typeof(Option), args[i]))
						shape = (Option) Enum.Parse(typeof(Option), args[i++]);
				if(i < args.Length)
					try {
						buffer = Convert.ToSingle(args[i++]);
					} catch(FormatException) {
						SendReply(player, wrapSize(12, wrapColor("red", String.Format(GetMessage("InvalidParameter", player.UserIDString), args[i-1]))));
						return;
					}
				
				// wrap building and show zone if successful
				if(WrapBuilding(player, zoneId, shape, buffer, cmd) && zoneId != "preview")
					ZoneManager?.Call("ShowZone", new object[] {player, zoneId});
			}
		}

		#endregion

		#region Entity Resolution

		// get zone entities from existing zone, returning zoneShape "undef" signals failure
		HashSet<BuildingBlock> getZoneEntities(BasePlayer player, string zoneId, out Option zoneShape)
		{
			HashSet<BuildingBlock> structure = new HashSet<BuildingBlock>();
			// get zone information
			Dictionary<string,string> zoneInfo = (Dictionary<string, string>) ZoneManager?.Call("ZoneFieldList", new object[] {zoneId});
			if(zoneInfo == null || zoneInfo.Count == 0)
			{
				// failed to find zone - send message, flag zoneShape as undef
				SendReply(player, wrapSize(12, wrapColor("red", String.Format(GetMessage("ZoneNotFound", player.UserIDString), zoneId))));
				zoneShape = Option.undef;
				return null;
			}
			// get zone values
			Vector3 zoneLocation = parseVector3(zoneInfo["Location"]);
			Vector3 zoneSize = parseVector3(zoneInfo["size"]);
			Vector3 rotation = parseVector3(zoneInfo["rotation"]);
			float zoneRadius = Convert.ToSingle(zoneInfo["radius"]);
			
			List<BaseEntity> list = Pool.GetList<BaseEntity>();
			// find intersecting entities
			if(zoneSize != Vector3.zero)
			{
				zoneShape = Option.box;
				BoxEntities<BaseEntity>(zoneLocation, zoneSize/2f, Quaternion.Euler(rotation), list, layerMasks);
			}
			else
			{
				zoneShape = Option.sphere;
				Vis.Entities<BaseEntity>(zoneLocation, zoneRadius, list, layerMasks);
			}
			
			// add building blocks to structure set
			BuildingBlock fbuildingblock;
			for (int i = 0; i < list.Count; i++)
			{
				BaseEntity hit = list[i];
				if (hit.GetComponentInParent<BuildingBlock>() != null)
				{
					fbuildingblock = hit.GetComponentInParent<BuildingBlock>();
					if (!(structure.Contains(fbuildingblock)))
						structure.Add(fbuildingblock);
				}
			}
			
			return structure;
		}
		
		// raycast and return the closest entity - returns true if a valid entity is found
		// amalgamation of processes from CopyPaste, and some adjustments
		bool GetRaycastTarget(BasePlayer player, out BaseEntity closestEntity)
		{
			closestEntity = null;
			var input = player.serverInput;
			if (input == null || input.current == null || input.current.aimAngles == Vector3.zero)
				return false;
			
			Vector3 sourceEye = player.transform.position + new Vector3(0f, 1.6f, 0f);
			Ray ray = new Ray(sourceEye, Quaternion.Euler(input.current.aimAngles) * Vector3.forward);
			
			var hits = Physics.RaycastAll(ray);
			float closestdist = 100f;
			foreach (var hit in hits)
			{
				if (hit.collider.isTrigger)
					continue;
				if (hit.distance < closestdist)
				{
					closestdist = hit.distance;
					closestEntity = hit.GetEntity();
				}
			}
			return closestEntity != null;
		}
		
		// get all BuildingBlock entities in structure
		// basic process replicated from CopyPaste, reduced to only handle BuildingBlocks
		bool GetStructure(HashSet<BuildingBlock> initialBlocks, out HashSet<BuildingBlock> structure)
		{
			structure = new HashSet<BuildingBlock>();
			List<Vector3> checkFrom = new List<Vector3>();
			BuildingBlock fbuildingblock;
			
			foreach(BuildingBlock block in initialBlocks)
			{
				checkFrom.Add(block.transform.position);
				structure.Add(block);
			}

			int current = 0;
			while (true)
			{
				current++;
				if (current > checkFrom.Count)
					break;
				List<BaseEntity> list = Pool.GetList<BaseEntity>();
				Vis.Entities<BaseEntity>(checkFrom[current - 1], 3f, list, layerMasks);
				for (int i = 0; i < list.Count; i++)
				{
					BaseEntity hit = list[i];
					if (hit.GetComponentInParent<BuildingBlock>() != null)
					{
						fbuildingblock = hit.GetComponentInParent<BuildingBlock>();
						if (!(structure.Contains(fbuildingblock)))
						{
							checkFrom.Add(fbuildingblock.transform.position);
							structure.Add(fbuildingblock);
						}
					}
				}
			}
			
			return true;
		}

		#endregion

		#region Wrapper Procedures

		// wrap building delegator
		bool WrapBuilding(BasePlayer player, string zoneId, Option shape, float buffer, Command cmd)
		{
			HashSet<BuildingBlock> initialBlocks = new HashSet<BuildingBlock>();
			Option zoneShape = Option.undef;
			if (cmd == Command.rewrap)
			{
				// if rewrap, get BuildingBlocks inside zone
				initialBlocks = getZoneEntities(player, zoneId, out zoneShape);
				if (zoneShape == Option.undef)
					return false; // failure in getZoneEntities
			}
			else
			{
				// default sphere
				zoneShape = Option.sphere;
				// raycast to find building
				BaseEntity closestEntity;
				if (!GetRaycastTarget(player, out closestEntity))
				{
					SendReply(player, wrapSize(12, wrapColor("red", GetMessage("NoBuilding", player.UserIDString))));
					return false;
				}
				BuildingBlock initialBlock = closestEntity as BuildingBlock;
				if (initialBlock == null)
				{
					SendReply(player, wrapSize(12, wrapColor("red", GetMessage("NoBuilding", player.UserIDString))));
					return false;
				}
				initialBlocks.Add(initialBlock);
			}
			// retrieve structure
			HashSet<BuildingBlock> all_blocks;
			if (!GetStructure(initialBlocks, out all_blocks))
			{
				SendReply(player, wrapSize(12, wrapColor("red", GetMessage("NoBuilding", player.UserIDString))));
				return false;
			}

			if (cmd == Command.extend)
			{
				// if extend, merge structure block coordinates
				all_blocks.UnionWith(getZoneEntities(player, zoneId, out zoneShape));
				if (zoneShape == Option.undef)
					return false; // failure in getZoneEntities
			}

			bool success = false;
			if (shape == Option.undef)
				shape = (Option)zoneShape;
			if (shape == Option.box || shape == Option.square)
				success = WrapBox(player, zoneId, all_blocks, buffer, shape);
			else if (shape == Option.sphere)
				success = WrapSphere(player, zoneId, all_blocks, buffer);

			string str = success ? "Success" : "Failure";

			if (zoneId != "preview")
            {
				SendReply(player, wrapSize(12, wrapColor(success ? "green" : "red", String.Format(GetMessage("ZoneWrap" + str, player.UserIDString), zoneId))));
            }
			return success;
		}

		// wrap building in a box zone
		bool WrapBox(BasePlayer player, string zoneId, HashSet<BuildingBlock> blocks, float buffer, Option shape)
		{
			float minY =  Mathf.Infinity;
			float maxY = -Mathf.Infinity;
			
			Vector2 origin = new Vector2(0f, 0f); // origin, for rotations
			
			float extents = 0f;
			HashSet<Vector2> points = new HashSet<Vector2>();
			for(int i=0; i<blocks.Count; i++)
			{
				Bounds b = blocks.ElementAt(i).WorldSpaceBounds().ToBounds();
				//float d = b.max;
				Vector3 v = blocks.ElementAt(i).CenterPoint();
				
				if(v == Vector3.zero)
					continue; // cannot get position?
				
				float d = Mathf.Abs(Vector3.Distance(v, b.max))*2f;
				if(d > extents) extents = d; // set max extents for buffering zone
				
				// flatten point to horizontal plane
				points.Add(new Vector2(v.x, v.z));
				
				if (v.y < minY) minY = v.y;
				if (v.y > maxY) maxY = v.y;
			}
			// get height (vertical axis)
			float sizeY = maxY - minY;

			// calculate hull
			Vector2[] hull = constructHull(points.ToArray());
			// extract center point from hull
			Vector2 center2 = getCenterFromHull(hull);
			Vector3 center = new Vector3(center2.x, minY + sizeY/2f, center2.y);
			//drawHull(player, hull, center); // draw hull for debugging
			
			// finds the smallest rectangle by traversing each edge in the hull,
			// rotating the hull to align the edge with the x axis, then finding
			// the minimum and maximum x and y values, and computing the area
			float minArea = Mathf.Infinity;
			float bestX = 0f;
			float bestY = 0f;
			float bestAngle = 0f;
			Vector2 bestCenter = center2; // initial "best" center point
			for(int i=0; i<hull.Length; i++)
			{
				int j = i+1;
				if(j == hull.Length)
					j = 0; // wrap j to first hull point
				
				// determine angle of current line segment
				float angle = getAngle(hull[i], hull[j]);
				// translate all points by rotating them by the specified angle
				Vector2[] rPoints = rotateAll(hull, angle, origin);
				float min_X =  Mathf.Infinity;
				float max_X = -Mathf.Infinity;
				float min_Y =  Mathf.Infinity;
				float max_Y = -Mathf.Infinity;
				// find min and max x/y values from points
				for(int k = 0; k<rPoints.Length; k++)
				{
					if(rPoints[k].x < min_X) min_X = rPoints[k].x;
					if(rPoints[k].x > max_X) max_X = rPoints[k].x;
					if(rPoints[k].y < min_Y) min_Y = rPoints[k].y;
					if(rPoints[k].y > max_Y) max_Y = rPoints[k].y;
				}
				float x = max_X - min_X;
				float y = max_Y - min_Y;
				if(shape == Option.square)
				{
					if(x > y)
						y = x;
					else if(y > x)
						x = y;
				}
				float area = x*y;
				// if square shape, set x and y to the larger of the two values
				if(area < minArea)
				{
					// smallest area so far - save key values
					minArea = area;
					bestX = x;
					bestY = y;
					bestAngle = angle;
					bestCenter = rotate(new Vector2(min_X + x/2f, min_Y + y/2f), -angle, origin);
					// draw box for debugging
					//drawHull(player, rotateAll(new Vector2[] {new Vector2(max_X, max_Y),
					//							   new Vector2(max_X, min_Y),
					//							   new Vector2(min_X, min_Y),
					//							   new Vector2(min_X, max_Y)}, -angle, origin), new Vector3(bestCenter.x, center.y, bestCenter.y));
				}
			}
			
			// add buffer value to extents
			extents += buffer;
			// convert angle to degrees
			bestAngle *= Mathf.Rad2Deg;
			// draw center point for debugging
			//drawCenter(player, new Vector3(bestCenter.x, center.y, bestCenter.y));
			
			// create zone with parameters: zoneId, args, position
			if(zoneId == "preview")
			{
				Vector3 b = new Vector3(bestX + extents, sizeY + extents, bestY + extents);
				Vector3 c = new Vector3(bestCenter.x, center.y, bestCenter.y);
				DrawHull(player, hull, c);
				DrawPreviewBox(player, b, c + (Vector3.up * yAdjust), bestAngle);
				//DrawText(player, center, String.Format(GetMessage("Stats", player.UserIDString), blocks.Count));
				return true;
			}
			return (bool) ZoneManager?.Call("CreateOrUpdateZone", new object[] {zoneId,
																				new string[] { "size", (bestX+extents) + " " + (sizeY+extents) + " " + (bestY+extents),
																							   "rotation", bestAngle.ToString()},
																				new Vector3(bestCenter.x, center.y+yAdjust, bestCenter.y)
																				});
		}
		
		// wrap building in a sphere zone
		bool WrapSphere(BasePlayer player, string zoneId, HashSet<BuildingBlock> blocks, float buffer)
		{
			float minX =  Mathf.Infinity;
			float maxX = -Mathf.Infinity;
			float minY =  Mathf.Infinity;
			float maxY = -Mathf.Infinity;
			float minZ =  Mathf.Infinity;
			float maxZ = -Mathf.Infinity;
			for(int i=0; i<blocks.Count; i++)
			{
				Vector3 v = blocks.ElementAt(i).CenterPoint();
				if(v == Vector3.zero)
					continue; // cannot get position?
				
				if (v.x < minX) minX = v.x;
				if (v.x > maxX) maxX = v.x;
				if (v.y < minY) minY = v.y;
				if (v.y > maxY) maxY = v.y;
				if (v.z < minZ) minZ = v.z;
				if (v.z > maxZ) maxZ = v.z;
			}
			
			float sizeX = maxX - minX;
			float sizeY = maxY - minY;
			float sizeZ = maxZ - minZ;

			// get center + yAdjust (y shift)
			Vector3 center = new Vector3(minX + sizeX / 2.0f, (minY + sizeY / 2.0f) + yAdjust, minZ + sizeZ / 2.0f);
			
			// find radius
			float radius = 0f;
			float extents = 0f;
			for(int i=0; i<blocks.Count; i++)
			{
				Bounds b = blocks.ElementAt(i).WorldSpaceBounds().ToBounds();
				Vector3 v = blocks.ElementAt(i).CenterPoint();
				if(v == Vector3.zero)
					continue; // cannot get position?
				// get distance from center
				float d = Vector3.Distance(center, v);
				if(d > radius)
				{
					radius = d; // set radius = distance
					extents = Vector3.Distance(v, b.max);
				}
			}
			
			radius += extents + buffer; // add extents and buffer
			if(zoneId == "preview")
			{
				DrawPreviewSphere(player, radius, center);
				//DrawText(player, center, String.Format(GetMessage("Stats", player.UserIDString), blocks.Count));
				return true;
			}
			// create zone with parameters: zoneId, args, position
			return (bool) ZoneManager?.Call("CreateOrUpdateZone", new object[] {zoneId,
																				new string[] { "radius", radius.ToString(),
																							   "size", "0 0 0"},
																				center
																				});
		}

		#endregion

		#region Maths Helpers

		// rotate all passed Vector2 (point) in the array around the center point to achieve the given angle
		private Vector2[] rotateAll(Vector2[] v, float angle, Vector2 center)
		{
			Vector2[] rotated = new Vector2[v.Length];
			for(int i=0; i<v.Length; i++)
				rotated[i] = rotate(v[i], angle, center);
			return rotated;
		}
		
		// rotate the passed Vector2 (point) around the center point to achieve the given angle
		private Vector2 rotate(Vector2 v, float angle, Vector2 center)
		{
			if(v == center || angle == 0f)
				return v;
			float x = center.x + (v.x-center.x)*Mathf.Cos(angle) - (v.y-center.y)*Mathf.Sin(angle);
			float y = center.y + (v.x-center.x)*Mathf.Sin(angle) + (v.y-center.y)*Mathf.Cos(angle);
			return new Vector2(x,y);

			//return new Vector2( (float)rx, (float)(v.x * sa + v.y * ca));
		}

		// calculate angle in radians of the line segment connnecting two points
		float getAngle(Vector2 p0, Vector2 p1)
		{
			return Mathf.Atan2(p1.x - p0.x,p1.y - p0.y);//*Mathf.Rad2Deg;
		}
		
		// construct 2d hull using Andrew's monotone chain 2d convex hull algorithm
		// converted from c++ algorithm implementation (c) softSurver/Dan Sunday
		// see http://geomalgorithms.com/a10-_hull-1.html#chainHull_2D() for c++
		Vector2[] constructHull(Vector2[] points)
		{
			if(points == null || points.Length == 0)
				return null;
			
			// sort points by x then y
			points = points.OrderBy(x => x.x).ThenBy(x => x.y).ToArray();
			
			int i; // array scan index
			
			Stack<Vector2> hullStack = new Stack<Vector2>();
			int minmin = 0;
			float xmin = points[0].x;
			
			for(i=1; i<points.Length; i++)
				if(points[i].x != xmin) break;
			int minmax = i-1;
			
			if(minmax == points.Length-1) // all x-coords = xmin
			{
				hullStack.Push(points[minmin]);
				if(points[minmax].y != points[minmin].y) // non-trivial segment
					hullStack.Push(points[minmax]);
				hullStack.Push(points[minmin]);
				return hullStack.ToArray();
			}
			
			int maxmax = points.Length-1;
			float xmax = points[points.Length-1].x;
			for(i=points.Length-2; i>=0; i--)
				if(points[i].x != xmax) break;
			int maxmin = i+1;
			
			// compute lower hull on stack
			hullStack.Push(points[minmin]);
			i = minmax;
			while(++i <= maxmin)
			{
				if(isLeft(points[minmin], points[maxmin], points[i]) >= 0 && i < maxmin)
					continue; // ignore point on or above lower line
				
				while(hullStack.Count > 1) // at least 2 points on stack
				{
					Vector2 topPoint = hullStack.Pop();
					if(isLeft(hullStack.Peek(), topPoint, points[i]) > 0)
					{
						hullStack.Push(topPoint); // new hull point
						break;
					}
				}
				hullStack.Push(points[i]); // push point to stack
			}
			
			// computer upper hull on stack
			if(maxmax != maxmin)
				hullStack.Push(points[maxmax]);
			int bot = hullStack.Count; // index for bottom of the stack
			i = maxmin;
			while(--i >= minmax)
			{
				if(isLeft(points[maxmax], points[minmax], points[i]) >= 0 && i > minmax)
					continue; // ignore point below or on upper line
				
				while(hullStack.Count > bot)
				{
					Vector2 topPoint = hullStack.Pop();
					if(isLeft(hullStack.Peek(), topPoint, points[i]) > 0)
					{
						hullStack.Push(topPoint); // new hull point
						break;
					}
				}
				hullStack.Push(points[i]);
			}
			
			if(minmax != minmin)
				hullStack.Push(points[minmin]);
			
			return hullStack.ToArray();
		}
		
		// tests if a point is left/on/right of a line
		// >0 p2 is left of line p0p1
		// =0 p2 on line p0p1
		// <0 p2 is right of line p0p1
		float isLeft(Vector2 p0, Vector2 p1, Vector2 p2)
		{
			return (p1.x - p0.x)*(p2.y - p0.y) - (p2.x - p0.x)*(p1.y - p0.y);
		}
		
		// gets the center point from a hull by finding the min/max x/y values and averaging them
		Vector2 getCenterFromHull(Vector2[] hull)
		{
			float min_X = Mathf.Infinity;
			float max_X = -Mathf.Infinity;
			float min_Y = Mathf.Infinity;
			float max_Y = -Mathf.Infinity;
			for(int i=0; i<hull.Length-1; i++)
			{
				if(hull[i].x < min_X) min_X = hull[i].x;
				if(hull[i].x > max_X) max_X = hull[i].x;
				if(hull[i].y < min_Y) min_Y = hull[i].y;
				if(hull[i].y > max_Y) max_Y = hull[i].y;
			}
			return new Vector2((min_X + max_X)/2f, (min_Y + max_Y)/2f);
		}

		#endregion

		#region Visuals

		// draw hull, for debugging - assumes array is an ordered set of perimiter vertices
		void DrawHull(BasePlayer player, Vector2[] hull, Vector3 center)
		{
			for (int i = 0; i < hull.Length; i++)
			{
				Vector3 from = new Vector3(hull[i].x, center.y + 1f, hull[i].y);
				int j = i + 1;
				if (j == hull.Length) j = 0;
				Vector3 to = new Vector3(hull[j].x, center.y + 1f, hull[j].y);
				DrawLine(player, from, to, Color.cyan);
			}
		}

		private static Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Quaternion rotation)
		{
			return rotation * (point - pivot) + pivot;
		}

		void DrawPreviewBox(BasePlayer player, Vector3 box, Vector3 center, float r)
		{
			Color color = Color.magenta;
			Quaternion rotation = Quaternion.AngleAxis(r, Vector3.up);
			Vector3 size = box / 2f;
			var point1 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z + size.z), center, rotation);
			var point2 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z + size.z), center, rotation);
			var point3 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z - size.z), center, rotation);
			var point4 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z - size.z), center, rotation);
			var point5 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z + size.z), center, rotation);
			var point6 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z + size.z), center, rotation);
			var point7 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z - size.z), center, rotation);
			var point8 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z - size.z), center, rotation);

			DrawLine(player, point1, point2, color);
			DrawLine(player, point1, point3, color);
			DrawLine(player, point1, point5, color);

			DrawLine(player, point2, point4, color);
			DrawLine(player, point2, point6, color);

			DrawLine(player, point3, point4, color);
			DrawLine(player, point3, point7, color);

			DrawLine(player, point4, point8, color);

			DrawLine(player, point5, point6, color);
			DrawLine(player, point5, point7, color);

			DrawLine(player, point6, point8, color);

			DrawLine(player, point7, point8, color);
		}

		void DrawLine(BasePlayer player, Vector3 from, Vector3 to, Color color, float duration = previewTime)
		{
			player.SendConsoleCommand("ddraw.line", duration, color, from, to);
		}

		void DrawPreviewSphere(BasePlayer player, float radius, Vector3 center, float duration = previewTime)
		{
			player.SendConsoleCommand("ddraw.sphere", duration, Color.magenta, center, radius);
		}

		void DrawText(BasePlayer player, Vector3 position, string text, float duration = previewTime)
		{
			player.SendConsoleCommand("ddraw.text", duration, Color.white, position, text);
		}

		// draw center point as xyz axis, for debugging
		void drawCenter(BasePlayer player, Vector3 center)
		{
			float length = 0.5f;
			Vector3 xP = new Vector3(length, 0, 0);
			Vector3 xN = new Vector3(-length, 0, 0);
			Vector3 yP = new Vector3(0, length, 0);
			Vector3 yN = new Vector3(0, -length, 0);
			Vector3 zP = new Vector3(0, 0, length);
			Vector3 zN = new Vector3(0, 0, -length);
			player.SendConsoleCommand("ddraw.line", 10f, Color.red, center + xN, center + xP);
			player.SendConsoleCommand("ddraw.line", 10f, Color.blue, center + yN, center + yP);
			player.SendConsoleCommand("ddraw.line", 10f, Color.green, center + zN, center + zP);
		}

		#endregion

		#region Helper Procedures

		// check if player is admin (copied from ZoneManager)
		private static bool isAdmin(BasePlayer player)
		{
			if (player?.net?.connection == null) return true;
			return player.net.connection.authLevel > 0;
        }
        
		// check permissions (copied from ZoneManager)
		private bool hasPermission(BasePlayer player, string permname)
		{
			return isAdmin(player) || permission.UserHasPermission(player.UserIDString, permname);
		}

		// parse Vector3 coordinates from a string in the format "(x, y, z)"
		Vector3 parseVector3(string str)
		{
			string[] strArray = str.Substring(1, str.Length - 2).Split(',');
			return new Vector3(float.Parse(strArray[0]), float.Parse(strArray[1]), float.Parse(strArray[2]));
		}

		// helper procedure for BoxEntities
		public void BoxColliders<T>(Vector3 position, Vector3 halfExtents, Quaternion orientation, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = QueryTriggerInteraction.Collide)
		where T : Collider
		{
			layerMask = GamePhysics.HandleIgnoreCollision(position, layerMask);
			int num = Physics.OverlapBoxNonAlloc(position, halfExtents, colBuffer, orientation, layerMask, triggerInteraction);
			if (num >= (int)colBuffer.Length)
			{
				Debug.LogWarning("Vis query is exceeding collider buffer length.");
			}
			for (int i = 0; i < num; i++)
			{
				T t = (T)(colBuffer[i] as T);
				colBuffer[i] = null;
				if (t != null)
				{
					if (!t.transform.CompareTag("MeshCollider"))
					{
						list.Add(t);
					}
					else
					{
						t.transform.GetComponent<MeshCollider>();//.LookupColliders<T>(position, 100f, list);
						list.Add(t);
					}
				}
			}
		}
		// Box Collider version of Vis.Entities procedure
		public void BoxEntities<T>(Vector3 position, Vector3 halfExtents, Quaternion orientation, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = QueryTriggerInteraction.Collide)
		where T : BaseEntity
		{
			List<Collider> colliders = Pool.GetList<Collider>();
			BoxColliders<Collider>(position, halfExtents, orientation, colliders, layerMask, triggerInteraction);
			for (int i = 0; i < colliders.Count; i++)
			{
				T baseEntity = (T)(colliders[i].gameObject.ToBaseEntity() as T);
				if (baseEntity != null)
				{
					list.Add(baseEntity);
				}
			}
			Pool.FreeList<Collider>(ref colliders);
    	}
		#endregion
	}
}


// --- End of file: BuildingWrapper.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/burn-it ---
// --- Original File Path: B/BurnIt/BurnIt.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using System.Collections.Generic;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Burn It", "marcuzz", "1.1.2")]
    [Description("Makes all wooden items burnable.")]
    public class BurnIt : RustPlugin
    {
        private static PluginConfig _config;
        private static readonly ItemDefinition _wood = ItemManager.FindItemDefinition(-151838493);

        private void OnServerInitialized()
        {
            if (!_config.ConditionLoss)
            {
                Unsubscribe(nameof(OnOvenCooked));
                Unsubscribe(nameof(OnEntityBuilt));
            }

            foreach (CustomBurnable customBurnable in _config.SpecificBurnableItems)
                AddCustomBurnable(customBurnable);

            if (_config.WoodenItems.AllowWoodenItems)
                ModifyWoodenItems();

            foreach (var oven in UnityEngine.Object.FindObjectsOfType<BaseOven>()) 
            {
                if (oven is BaseFuelLightSource)
                    continue;

                oven.fuelType = null;
            }
        }

        private void OnEntitySpawned(BaseOven oven)
        {
            if (oven is BaseFuelLightSource)
                return;

            oven.fuelType = null;
        }

        private void Unload()
        {
            foreach (var definition in ItemManager.itemList)
                ClearItemModBurnable(definition);

            foreach (var oven in UnityEngine.Object.FindObjectsOfType<BaseOven>())
            {
                if (oven is BaseFuelLightSource)
                    continue;

                oven.fuelType = _wood;
            }

            _config = null;
            Config.Clear();
        }

        private Item OnFindBurnable(BaseOven oven)
        {
            if (oven.inventory == null)
                return null;

            foreach (Item item in oven.inventory.itemList)
            {
                var burnable = item.info.GetComponent<ItemModBurnable>();
                if (burnable == null)
                    continue;

                if (burnable is ItemModBurnIt)
                {
                    if (item.IsOnFire())
                        return item;

                    return SetItemFuel(item, burnable.fuelAmount);
                }

                if (!_config.DisableOvenFuelTypeCheck) 
                {
                    if (item.info.itemid == -946369541 && oven.temperature == BaseOven.TemperatureType.Fractioning)
                        continue;
                }

                return item;
            }

            return null;
        }

        private object OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            if (oven.allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
            {
                Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount, 0uL);
                
                oven.fuelType = fuel.info;
                var moved = item.MoveToContainer(oven.inventory);
                oven.fuelType = null;

                if (!moved)
                {
                    oven.OvenFull();
                    item.Drop(oven.inventory.dropPosition, oven.inventory.dropVelocity);
                }
            }

            if (fuel.amount <= 1)
            {
                fuel.Remove();
                return true;
            }

            fuel.UseItem(1);
            fuel.fuel = burnable.fuelAmount;
            fuel.MarkDirty();
            Interface.CallHook("OnFuelConsumed", this, fuel, burnable);

            return true;
        }

        private object OnOvenCook(BaseOven oven, Item item)
        {
            if (oven.temperature == BaseOven.TemperatureType.Fractioning)
            {
                oven.fuelType = item.info;
                NextTick(() => { oven.fuelType = null; });
            }

            return null;
        }

        private void OnOvenCooked(BaseOven oven, Item fuel, BaseEntity slot)
        {
            if (fuel == null)
                return;

            var burnable = fuel.info.GetComponent<ItemModBurnIt>();
            if (burnable == null)
                return;

            if (!fuel.hasCondition)
                return;

            if (fuel.isBroken)
            {
                fuel.fuel = -1f;
                return;
            }

            if (fuel.condition < 1)
            {
                fuel.LoseCondition(1f);
                return;
            }

            var ratio = fuel.fuel / burnable.fuelAmount;
            var damage = fuel.condition - (fuel.maxCondition * ratio);

            if (damage > 0)
                fuel.LoseCondition(damage);
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            var item = plan.GetItem();
            if (item.hasCondition)
                return;

            if (item.fuel <= 0)
                return;

            var burnable = item.info.GetComponent<ItemModBurnIt>();
            if (burnable == null || burnable.fuelAmount == item.fuel)
                return;

            var combatEntity = (BaseCombatEntity)go.ToBaseEntity();
            if (combatEntity == null)
                return;

            if (combatEntity._maxHealth > 0)
            {
                var ratio = item.fuel / burnable.fuelAmount;
                var damage = combatEntity._maxHealth - (combatEntity._maxHealth * ratio);
                combatEntity.Hurt(damage * 10);
            }
        }

        private static void ModifyWoodenItems()
        {
            foreach (ItemDefinition definition in GenerateBurnableItemList().Values)
            {
                if (_config.WoodenItems.BlacklistedShortnames.Contains(definition.shortname))
                    continue;

                AddBurnableWoodenItem(definition);
            }
        }

        private static void ClearItemModBurnable(ItemDefinition definition)
        {
            var burnable = definition.GetComponent<ItemModBurnIt>();
            if (burnable != null)
                GameManager.DestroyImmediate(burnable);

            var mods = new List<ItemMod>();
            foreach (var mod in definition.itemMods) 
                if (!(mod is ItemModBurnIt))
                    mods.Add(mod);
            
            definition.itemMods = mods.ToArray();
        }

        private static Item SetItemFuel(Item item, float maxFuel)
        {
            if (item.hasCondition)
            {
                if (item.isBroken)
                {
                    item.fuel = 0;
                    return item;
                }

                if (item.condition < item.maxCondition)
                {
                    var ratio = item.condition / item.maxCondition;
                    item.fuel = maxFuel * ratio;
                }
            }

            if (item.fuel == 0)
                item.fuel = maxFuel;

            return item;
        }

        private static Dictionary<int, ItemDefinition> GenerateBurnableItemList()
        {
            var list = new Dictionary<int, ItemDefinition> { };

            foreach (var itemBlueprint in ItemManager.GetBlueprints())
            {
                if (ContainsModBurnable(itemBlueprint.targetItem))
                    continue;
                if (itemBlueprint.targetItem.GetComponent<ItemModBurnable>() != null)
                    continue;
                if (GetWoodAmount(itemBlueprint) == 0)
                    continue;
                if (itemBlueprint.targetItem.condition.enabled && !_config.ConditionLoss)
                    continue;

                list.Add(itemBlueprint.targetItem.itemid, itemBlueprint.targetItem);
            }

            return list;
        }

        private static int GetWoodAmount(ItemBlueprint blueprint)
        {
            foreach (var ingredient in blueprint.ingredients)
            {
                if (ingredient.itemDef == null)
                    continue;

                if (ingredient.itemDef.itemid == _wood.itemid)
                    return (int)ingredient.amount;
            }

            return 0;
        }

        private static void AddBurnableWoodenItem(ItemDefinition definition)
        {
            var woodBurnable = _wood.GetComponent<ItemModBurnable>();
            var woodAmount = (int)(GetWoodAmount(definition.Blueprint) * _config.WoodenItems.FuelAmountRatio);

            AddItemModBurnable(
                definition,
                woodBurnable.byproductItem,
                (int)(woodAmount * _config.WoodenItems.CharcoalRatio),
                -1f,
                woodAmount * woodBurnable.fuelAmount
                );
        }

        private static void AddCustomBurnable(CustomBurnable customBurnable)
        {
            var definition = ItemManager.FindItemDefinition(customBurnable.Shortname);
            if (definition == null)
                return;

            if (definition.condition.enabled && !_config.ConditionLoss)
                return;

            var byproduct = ItemManager.FindItemDefinition(customBurnable.ByproductShortname);
            if (byproduct == null)
                return;

            AddItemModBurnable(
                definition,
                byproduct,
                customBurnable.ByproductAmount,
                customBurnable.ByproductChance,
                customBurnable.FuelAmount
                );
        }

        private static bool ContainsModBurnable(ItemDefinition definition)
        {
            foreach (var mod in definition.itemMods)
                if (mod is ItemModBurnable)
                    return true;

            return false;
        }

        private static void AddItemModBurnable(
            ItemDefinition definition,
            ItemDefinition byproduct,
            int byproductAmount,
            float byproductChance,
            float fuelAmount
            )
        {
            if (definition.GetComponent<ItemModBurnable>() != null || ContainsModBurnable(definition))
                return;

            var burnable = definition.GetOrAddComponent<ItemModBurnIt>();
            burnable.byproductItem = byproduct;
            burnable.byproductAmount = byproductAmount;
            burnable.byproductChance = byproductChance;
            burnable.fuelAmount = fuelAmount;

            UpdateItemMods(definition, burnable);
        }

        private static void UpdateItemMods(ItemDefinition definition, ItemModBurnIt burnable)
        {
            var mods = new List<ItemMod>
            {
                burnable
            };

            foreach (var mod in definition.itemMods) 
            {
                if (mod is ItemModBurnIt)
                    return;

                mods.Add(mod);
            }
                
            definition.itemMods = mods.ToArray();
        }

        private class ItemModBurnIt : ItemModBurnable
        {
        }

        private static PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                ConditionLoss = true,
                WoodenItems = new WoodenItems
                {
                    AllowWoodenItems = true,
                    FuelAmountRatio = 0.2f,
                    CharcoalRatio = 0.5f,
                    BlacklistedShortnames = new List<string>
                    {
                        "small.oil.refinery",
                        "furnace.large",
                        "furnace",
                        "bbq",
                        "fireplace.stone",
                        "campfire",
                        "waterpump"
                    }
                },
                SpecificBurnableItems = new List<CustomBurnable>
                {
                    new CustomBurnable()
                    {
                        Shortname = "plantfiber",
                        ByproductShortname = "charcoal",
                        ByproductAmount = 1,
                        ByproductChance = 0.5f,
                        FuelAmount = 5f
                    },
                    new CustomBurnable()
                    {
                        Shortname = "horsedung",
                        ByproductShortname = "charcoal",
                        ByproductAmount = 1,
                        ByproductChance = 1f,
                        FuelAmount = 100f
                    }
                }
            };
        }

        private class WoodenItems
        {
            [JsonProperty("[a] Make wooden items burnable:")]
            public bool AllowWoodenItems;

            [JsonProperty("[b] Burnable wood ratio")]
            public float FuelAmountRatio;

            [JsonProperty("[c] Charcoal per burnable wood ratio")]
            public float CharcoalRatio;

            [JsonProperty("[d] Blacklisted shortnames")]
            public List<string> BlacklistedShortnames { get; set; }
        }

        private class CustomBurnable
        {
            [JsonProperty("[a] Item shortname")]
            public string Shortname;

            [JsonProperty("[b] Byproduct shortname")]
            public string ByproductShortname;

            [JsonProperty("[c] Byproduct amount")]
            public int ByproductAmount;

            [JsonProperty("[d] Byproduct loss chance")]
            public float ByproductChance;

            [JsonProperty("[e] Fuel amount (burn time)")]
            public float FuelAmount;
        }

        private class PluginConfig
        {
            [JsonProperty("[1] Condition loss feature (allow items with durability)")]
            public bool ConditionLoss { get; set; }

            [JsonProperty("[2] Allow lowgrade burning (disable oven fuel type check)")]
            public bool DisableOvenFuelTypeCheck { get; set; }

            [JsonProperty("[3] Wooden items")]
            public WoodenItems WoodenItems { get; set; }

            [JsonProperty("[4] Specified burnable items")]
            public List<CustomBurnable> SpecificBurnableItems { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            Config.WriteObject(GetDefaultConfig(), true);

            _config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            _config = Config.ReadObject<PluginConfig>();
        }
    }
}

// --- End of file: BurnIt.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/blood-trail ---
// --- Original File Path: B/BloodTrail/BloodTrail.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Blood Trail", "hoppel", "2.0.0")]
    [Description("Leaves a trail of blood behind players while bleeding")]
    public class BloodTrail : CovalencePlugin
    {
        #region Configuration

        private static Configuration config;

        public class Configuration
        {
            [JsonProperty("Blood trail refresh time")]
            public float RefreshTime = 0.2f;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Initialization

        private static BloodTrail instance;

        private const string permAllow = "bloodtrail.allow";
        private const string permBypass = "bloodtrail.bypass";

        private void Init()
        {
            instance = this;

            permission.RegisterPermission(permAllow, this);
            permission.RegisterPermission(permBypass, this);
        }

        private void OnServerInitialized()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        private void Unload()
        {
            Object[] objects = UnityEngine.Object.FindObjectsOfType(typeof(Blood));
            if (objects != null)
            {
                foreach (Object gameObj in objects)
                {
                    UnityEngine.Object.Destroy(gameObj);
                }
            }

            config = null;
            instance = null;
        }

        #endregion Initialization

        #region Blood Trail

        private void OnPlayerConnected(BasePlayer player)
        {
            if (HasPermission(player) && !player.gameObject.GetComponent<Blood>())
            {
                player.gameObject.AddComponent<Blood>();
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (player.gameObject.GetComponent<Blood>())
            {
                UnityEngine.Object.Destroy(player.gameObject.GetComponent<Blood>());
            }
        }

        public class Blood : MonoBehaviour
        {
            private BasePlayer player;
            private Vector3 position;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                position = player.transform.position;
                InvokeRepeating("Track", 0.2f, config.RefreshTime);
            }

            private void Track()
            {
                if (player == null || !instance.HasPermission(player))
                {
                    return;
                }

                {
                    if (position == player.transform.position)
                    {
                        return;
                    }

                    position = player.transform.position;

                    if (!player || !player.IsConnected)
                    {
                        Destroy(this);
                        return;
                    }

                    if (player.metabolism.bleeding.value > 0)
                    {
                        Effect.server.Run("assets/bundled/prefabs/fx/player/beartrap_blood.prefab", player.transform.position, Vector3.up, null, true);
                    }
                }
            }

            private void OnDestroy()
            {
                CancelInvoke("Track");
                Destroy(this);
            }
        }

        #endregion Blood Trail

        #region Helpers

        private bool HasPermission(BasePlayer player)
        {
            return permission.UserHasPermission(player.UserIDString, permAllow) && !permission.UserHasPermission(player.UserIDString, permBypass);
        }

        #endregion Helpers
    }
}


// --- End of file: BloodTrail.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-no-stability ---
// --- Original File Path: B/BetterNoStability/BetterNoStability.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Better No Stability", "Arainrr", "1.1.7")]
    [Description("Similar to 'server.stability false', but when an item loses its base, it does not levitate.")]
    public class BetterNoStability : RustPlugin
    {
        #region Fields

        private const string PERMISSION_USE = "betternostability.use";
        private static object False;

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            False = false;
            LoadData();
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnUserGroupAdded));
            Unsubscribe(nameof(OnEntityGroundMissing));
            Unsubscribe(nameof(OnUserPermissionGranted));
            Unsubscribe(nameof(OnGroupPermissionGranted));
            permission.RegisterPermission(PERMISSION_USE, this);

            cmd.AddChatCommand(configData.chatS.command, this, nameof(CmdToggle));
        }

        private void OnServerInitialized()
        {
            UpdateConfig();
            if (configData.pluginEnabled)
            {
                Subscribe(nameof(OnEntitySpawned));
                if (configData.usePermission)
                {
                    Subscribe(nameof(OnUserGroupAdded));
                    Subscribe(nameof(OnUserPermissionGranted));
                    Subscribe(nameof(OnGroupPermissionGranted));
                }

                if (configData.floatingS.enabled)
                {
                    Subscribe(nameof(OnEntityGroundMissing));
                }

                ConVar.Server.stability = true;
                foreach (var stabilityEntity in BaseNetworkable.serverEntities.OfType<StabilityEntity>())
                {
                    OnEntitySpawned(stabilityEntity);
                }
            }
        }

        private void Unload()
        {
            False = null;
        }

        private void OnEntitySpawned(StabilityEntity stabilityEntity)
        {
            if (stabilityEntity == null || stabilityEntity.OwnerID == 0) return;
            if (storedData.disabledPlayers.Contains(stabilityEntity.OwnerID)) return;
            bool enabled;
            if (configData.stabilityS.TryGetValue(stabilityEntity.ShortPrefabName, out enabled) && !enabled) return;
            if (configData.usePermission && !permission.UserHasPermission(stabilityEntity.OwnerID.ToString(), PERMISSION_USE)) return;
            stabilityEntity.grounded = true;
        }

        private object OnEntityGroundMissing(BaseEntity entity)
        {
            if (entity == null || entity.OwnerID == 0) return null;
            if (storedData.disabledPlayers.Contains(entity.OwnerID)) return null;
            if (configData.usePermission && !permission.UserHasPermission(entity.OwnerID.ToString(), PERMISSION_USE)) return null;
            if (configData.floatingS.floatingEntity.Contains(entity.ShortPrefabName)) return False;
            return null;
        }

        #endregion Oxide Hooks

        #region Methods

        private void UpdateConfig()
        {
            foreach (var prefab in GameManifest.Current.entities)
            {
                var stabilityEntity = GameManager.server.FindPrefab(prefab)?.GetComponent<StabilityEntity>();
                if (stabilityEntity != null && !string.IsNullOrEmpty(stabilityEntity.ShortPrefabName) &&
                    !configData.stabilityS.ContainsKey(stabilityEntity.ShortPrefabName))
                {
                    configData.stabilityS.Add(stabilityEntity.ShortPrefabName, stabilityEntity is BuildingBlock);
                }
            }

            SaveConfig();
        }

        #region PermissionChanged

        private void OnUserPermissionGranted(string playerID, string permName)
        {
            if (permName != PERMISSION_USE) return;
            UserPermissionChanged(new string[] { playerID });
        }

        private void OnGroupPermissionGranted(string groupName, string permName)
        {
            if (permName != PERMISSION_USE) return;
            var users = permission.GetUsersInGroup(groupName);
            var playerIDs = users.Select(x => x.Substring(0, x.IndexOf(' ')))
                .Where(x => RustCore.FindPlayerByIdString(x) != null).ToArray();
            UserPermissionChanged(playerIDs);
        }

        private void OnUserGroupAdded(string playerID, string groupName)
        {
            if (!permission.GroupHasPermission(groupName, PERMISSION_USE)) return;
            UserPermissionChanged(new string[] { playerID });
        }

        private void UserPermissionChanged(string[] playerIDs)
        {
            var stabilityEntities = BaseNetworkable.serverEntities.OfType<StabilityEntity>()
                .GroupBy(x => x.ShortPrefabName).ToDictionary(x => x.Key, y => y.ToList());
            foreach (var entry in stabilityEntities)
            {
                bool enabled;
                if (configData.stabilityS.TryGetValue(entry.Key, out enabled) && !enabled) continue;
                foreach (var stabilityEntity in entry.Value)
                {
                    if (stabilityEntity.OwnerID == 0) continue;
                    if (playerIDs.Any(x => x == stabilityEntity.OwnerID.ToString()))
                    {
                        if (!storedData.disabledPlayers.Contains(stabilityEntity.OwnerID))
                        {
                            stabilityEntity.grounded = true;
                        }
                    }
                }
            }
        }

        #endregion PermissionChanged

        #endregion Methods

        #region Commands

        private void CmdToggle(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            if (storedData.disabledPlayers.Contains(player.userID))
            {
                storedData.disabledPlayers.Remove(player.userID);
                Print(player, Lang("Toggle", player.UserIDString, Lang("Enabled", player.UserIDString)));
            }
            else
            {
                storedData.disabledPlayers.Add(player.userID);
                Print(player, Lang("Toggle", player.UserIDString, Lang("Disabled", player.UserIDString)));
            }
            SaveData();
        }

        #endregion Commands

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Enable Plugin")]
            public bool pluginEnabled = false;

            [JsonProperty(PropertyName = "Use Permission")]
            public bool usePermission = false;

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatSettings chatS = new ChatSettings();

            [JsonProperty(PropertyName = "Stability Entity Settings")]
            public Dictionary<string, bool> stabilityS = new Dictionary<string, bool>();

            [JsonProperty(PropertyName = "Floating Settings")]
            public FloatingS floatingS = new FloatingS();
        }

        public class ChatSettings
        {
            [JsonProperty(PropertyName = "Chat Command")]
            public string command = "ns";

            [JsonProperty(PropertyName = "Chat Prefix")]
            public string prefix = "<color=#00FFFF>[NoStability]</color>: ";

            [JsonProperty(PropertyName = "Chat SteamID Icon")]
            public ulong steamIDIcon;
        }

        public class FloatingS
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool enabled = false;

            [JsonProperty(PropertyName = "Floating Entity List (entity short prefab name)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> floatingEntity = new List<string>
            {
                "rug.deployed",
                "cupboard.tool.deployed"
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile

        #region DataFile

        private StoredData storedData;

        private class StoredData
        {
            public HashSet<ulong> disabledPlayers = new HashSet<ulong>();
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = null;
            }
            if (storedData == null)
            {
                ClearData();
            }
        }

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

        #endregion DataFile

        #region LanguageFile

        private void Print(BasePlayer player, string message) => Player.Message(player, message, configData.chatS.prefix, configData.chatS.steamIDIcon);

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You do not have permission to use this command",
                ["Toggle"] = "No Stability is {0}",
                ["Enabled"] = "<color=#8ee700>Enabled</color>",
                ["Disabled"] = "<color=#ce422b>Disabled</color>",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "",
                ["Toggle"] = " {0}",
                ["Enabled"] = "<color=#8ee700></color>",
                ["Disabled"] = "<color=#ce422b></color>",
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: BetterNoStability.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/blueprint-manager ---
// --- Original File Path: B/BlueprintManager/BlueprintManager.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("Blueprint Manager", "Whispers88", "2.1.3")]
    [Description("Allows you to manage and modify blueprints")]

    public class BlueprintManager : RustPlugin
    {
        #region Config
        private Configuration config;
        private static Dictionary<int, BlueprintData> defaultsetup = new Dictionary<int, BlueprintData>();
        public class BlueprintData
        {
            public bool defaultBP;
            public bool canResearch;
            public int scrapRequired;
            public int unlockMinutesAfterWipe;
            public bool autoUnlockMinutesAfterWipe;

            public BlueprintData()
            {
                defaultBP = false;
                canResearch = true;
                scrapRequired = 1;
                unlockMinutesAfterWipe = -1;
                autoUnlockMinutesAfterWipe = false;
            }
        }

        public class Configuration
        {

            [JsonProperty("Simple Mode (disables advance blueprint management options)")]
            public bool SimpleMode = true;

            [JsonProperty("Update players on permission change (automatically updates a players BPs when their permissions change)")]
            public bool updateBPs = true;

            [JsonProperty("Wipe BPs with Map Wipe")]
            public bool wipeOnMap = false;

            [JsonProperty("Blacklist (items from being automatically learnt)")]
            public List<string> Blacklist = new List<string>();

            [JsonProperty("DefaultBPs (Blueprints to be automatically learnt)")]
            public List<string> DefaultBPs = new List<string>();

            [JsonProperty("Assign custom BP unlocks to various perms (permission, BP List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, List<string>> BonusBPs = new Dictionary<string, List<string>> { { "customperm1", new List<string>() { "rock" } }, { "customperm2", new List<string>() { "torch" } } };

            [JsonProperty("Advanced Blueprint Management Options")]
            public Dictionary<string, BlueprintData> BlueprintOptions = new Dictionary<string, BlueprintData>();

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                Puts($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Config

        #region Init

        private const string permunlockall = "blueprintmanager.all";
        private const string permadmin = "blueprintmanager.admin";

        private DateTime _lastWipe;
        private Coroutine unlockAfterWipeCoroutine;
        private Coroutine updateAllPlayers;
        private List<string> _permissions = new List<string> { permadmin };
        private List<int> _blacklist = new List<int>();
        private List<int> _defaultBlueprints = new List<int>();
        private Dictionary<string, List<int>> _permissionBPs = new Dictionary<string, List<int>>();
        private Dictionary<ItemBlueprint, int> _unlockAfterWipe = new Dictionary<ItemBlueprint, int>();
        private List<string> commands = new List<string> { nameof(CMDBPReset), nameof(CMDUnlock), nameof(CMDUnlockAll), nameof(CMDWipeAll), nameof(CMDBPRemove) };
        private void OnServerInitialized()
        {

            //Unsub hooks
            if (!config.updateBPs)
            {
                Unsubscribe("OnUserGroupAdded");
                Unsubscribe("OnUserPermissionGranted");
            }

            //Register commands
            commands.ForEach(command => AddLocalizedCommand(command));

            //Check blacklist BPs in config
            config.Blacklist.ForEach(blacklistBP =>
            {
                ItemBlueprint bp = ItemManager.FindItemDefinition(blacklistBP)?.Blueprint;
                if (bp != null)
                    _blacklist.Add(bp.targetItem.itemid);
                else
                    Puts(GetLang("CannotFindBPConfig", null, blacklistBP, "Blacklist"));
            });

            //Create Default Permission Sets
            _permissionBPs.Add(permunlockall, new List<int>());

            foreach (ItemBlueprint bp in ItemManager.bpList)
            {
                if (_blacklist.Contains(bp.targetItem.itemid)) continue;
                //Add BPs to workbench permissions
                List<int> bpList;
                if (!_permissionBPs.TryGetValue($"blueprintmanager.WorkbenchLvL{bp.workbenchLevelRequired}", out bpList))
                    _permissionBPs.Add($"blueprintmanager.WorkbenchLvL{bp.workbenchLevelRequired}", new List<int>() { bp.targetItem.itemid });
                else
                    bpList.Add(bp.targetItem.itemid);

                //Add BPs to ItemCategory permissions
                if (!_permissionBPs.TryGetValue($"blueprintmanager.{Enum.GetName(typeof(ItemCategory), bp.targetItem.category)}", out bpList))
                    _permissionBPs.Add($"blueprintmanager.{Enum.GetName(typeof(ItemCategory), bp.targetItem.category)}", new List<int>() { bp.targetItem.itemid });
                else
                    bpList.Add(bp.targetItem.itemid);

                _permissionBPs[permunlockall].Add(bp.targetItem.itemid);
            }

            //Check default BPs in config
            foreach (string defaultBP in config.DefaultBPs)
            {
                ItemBlueprint bp = ItemManager.FindItemDefinition(defaultBP)?.Blueprint;
                if (bp == null)
                    Puts(GetLang("CannotFindBPConfig", null, defaultBP, "DefaultBPs"));
                else if (!_blacklist.Contains(bp.targetItem.itemid))
                    _defaultBlueprints.Add(bp.targetItem.itemid);
            }

            //Check custom perm BPs
            foreach (var key in config.BonusBPs.Keys)
            {
                _permissionBPs.Add($"blueprintmanager.{key}", new List<int>());
            }

            foreach (var bonusBPSet in config.BonusBPs)
            {
                bonusBPSet.Value.ForEach(bonusBP =>
                {
                    ItemBlueprint bp = ItemManager.FindItemDefinition(bonusBP)?.Blueprint;
                    if (bp == null)
                        Puts(GetLang("CannotFindBPConfig", null, bonusBP, $"Custom BPs set {bonusBPSet.Key}"));
                    else if (!_blacklist.Contains(bp.targetItem.itemid))
                        _permissionBPs[$"blueprintmanager.{bonusBPSet.Key}"].Add(bp.targetItem.itemid);
                });
            }

            //Register Perms
            foreach (var perm in _permissionBPs)
                permission.RegisterPermission(perm.Key, this);

            _permissions.ForEach(perm => permission.RegisterPermission(perm, this));

            if (!config.SimpleMode)
            {
                foreach (ItemBlueprint bp in ItemManager.bpList)
                {
                    defaultsetup.Add(bp.targetItem.itemid, new BlueprintData() { defaultBP = bp.defaultBlueprint, scrapRequired = bp.scrapRequired, canResearch = bp.isResearchable });
                    BlueprintData blueprintData;
                    if (!config.BlueprintOptions.TryGetValue(bp.targetItem.shortname, out blueprintData))
                        config.BlueprintOptions.Add(bp.targetItem.shortname, new BlueprintData() { defaultBP = bp.defaultBlueprint, scrapRequired = bp.scrapRequired, canResearch = bp.isResearchable });
                    else
                    {
                        bp.isResearchable = blueprintData.canResearch;
                        bp.scrapRequired = blueprintData.scrapRequired;
                        bp.defaultBlueprint = blueprintData.defaultBP;

                        if (blueprintData.unlockMinutesAfterWipe > 0)
                        {
                            _unlockAfterWipe[bp] = blueprintData.unlockMinutesAfterWipe;
                        }

                        if (blueprintData.defaultBP)
                        {
                            _defaultBlueprints.Add(bp.targetItem.itemid);
                        }
                    }
                }

                _lastWipe = SaveRestore.SaveCreatedTime;

                _unlockAfterWipe = _unlockAfterWipe.OrderBy(pair => pair.Value).ToDictionary(x => x.Key, x => x.Value);

                unlockAfterWipeCoroutine = ServerMgr.Instance.StartCoroutine(UnlockAfterWipe());
            }
            updateAllPlayers = ServerMgr.Instance.StartCoroutine(UpdateAllPlayers());
            SaveConfig();
        }
        private IEnumerator UpdateAllPlayers()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
                yield return CoroutineEx.waitForEndOfFrame;
            }
            updateAllPlayers = null;
        }

        IEnumerator UnlockAfterWipe()
        {
            float timetillUnlock = (_unlockAfterWipe.First().Value * 60) - Time.realtimeSinceStartup;
            if (timetillUnlock > 0)
                yield return new WaitForSeconds(timetillUnlock);
            bool changed = false;
            foreach (var bptounlock in _unlockAfterWipe.ToDictionary(x => x.Key, x => x.Value))
            {
                if (Time.realtimeSinceStartup - 1 > (bptounlock.Value * 60))
                {
                    ItemManager.FindBlueprint(bptounlock.Key.targetItem).isResearchable = true;
                    _unlockAfterWipe.Remove(bptounlock.Key);

                    BlueprintData blueprintData;
                    if (!config.BlueprintOptions.TryGetValue(bptounlock.Key.targetItem.shortname, out blueprintData))
                        continue;

                    if (blueprintData.autoUnlockMinutesAfterWipe && !_defaultBlueprints.Contains(bptounlock.Key.targetItem.itemid))
                    {
                        _defaultBlueprints.Add(bptounlock.Key.targetItem.itemid);
                        changed = true;
                    }
                }
            }

            if (changed && updateAllPlayers == null)
            {
                updateAllPlayers = ServerMgr.Instance.StartCoroutine(UpdateAllPlayers());
            }
            if (!_unlockAfterWipe.IsNullOrEmpty())
                unlockAfterWipeCoroutine = ServerMgr.Instance.StartCoroutine(UnlockAfterWipe());
        }

        private void Unload()
        {
            foreach (ItemBlueprint bp in ItemManager.bpList)
            {
                BlueprintData blueprintData;
                if (!defaultsetup.TryGetValue(bp.targetItem.itemid, out blueprintData)) continue;
                bp.isResearchable = blueprintData.canResearch;
                bp.scrapRequired = blueprintData.scrapRequired;
                bp.defaultBlueprint = blueprintData.defaultBP;
            }

            if (updateAllPlayers != null)
                ServerMgr.Instance.StopCoroutine(updateAllPlayers);

            if (unlockAfterWipeCoroutine != null)
                ServerMgr.Instance.StopCoroutine(unlockAfterWipeCoroutine);
        }

        #endregion Init

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPerms"] = "You don't have permission to use this command.",
                ["CMDBPResetArgs"] = "This command needs one argument in the format /bpreset playerName or playerID",
                ["CMDUnlockAllArgs"] = "This command needs one argument in the format /bplunlockall playerName or playerID",
                ["CMDRemoveArgs"] = "This command needs at least two arguments in the format /bpremove playerName or playerID item.shortname",
                ["PlayerNotFound"] = "Cannot find player by the {0} identifier",
                ["ResetPlayersBps"] = "{0} BPs were reset",
                ["ResetAllBps"] = "All BPs were reset",
                ["UnlockAllPlayersBps"] = "All BPs were unlocked for {0}",
                ["UnlockPlayersBps"] = "{0} was unlocked for {1}",
                ["RemovePlayersBps"] = "{0} was removed for {1}",
                ["CannotFindBPConfig"] = "Cannot find a blueprint for {0} in the {1} config. Use the item shortname or ID",
                ["CannotFindBP"] = "Cannot find a blueprint for {0}. Use the item shortname or ID",
                ["BlueprintLocked"] = "The {0} blueprint is locked for {1}",
                //Commands
                ["CMDUnlockAll"] = "bpunlockall",
                ["CMDUnlock"] = "bpunlock",
                ["CMDBPReset"] = "bpreset",
                ["CMDBPRemove"] = "bpremove",
                ["CMDWipeAll"] = "bpwipeall"
            }, this);
        }

        #endregion Localization

        #region Commands
        private void CMDBPReset(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permadmin))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length == 0)
            {
                Message(iplayer, "CMDBPResetArgs");
                return;
            }

            BasePlayer targetPlayer = BasePlayer.Find(args[0]);
            if (targetPlayer == null || !targetPlayer.IsConnected)
            {
                Message(iplayer, "PlayerNotFound", args[0]);
                return;
            }

            WipeBPs(targetPlayer);

            Message(iplayer, "ResetPlayersBps", targetPlayer.displayName);
        }

        private void CMDUnlockAll(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permadmin))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length == 0)
            {
                Message(iplayer, "CMDUnlockAllArgs");
                return;
            }

            BasePlayer targetPlayer = BasePlayer.Find(args[0]);
            if (targetPlayer == null || !targetPlayer.IsConnected)
            {
                Message(iplayer, "PlayerNotFound", args[0]);
                return;
            }

            UnlockAllBPs(targetPlayer);

            Message(iplayer, "UnlockAllPlayersBps", targetPlayer.displayName);
        }


        private void CMDUnlock(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permadmin))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length < 2)
            {
                Message(iplayer, "CMDUnlockAllArgs");
                return;
            }

            BasePlayer targetPlayer = BasePlayer.Find(args[0]);
            if (targetPlayer == null || !targetPlayer.IsConnected)
            {
                Message(iplayer, "PlayerNotFound", args[0]);
                return;
            }

            var BPlist = Pool.Get<List<int>>();

            for (int i = 1; i < args.Length; i++)
            {
                ItemBlueprint? bp = ItemManager.FindItemDefinition(args[i])?.Blueprint;
                if (bp == null)
                {
                    Message(iplayer, "CannotFindBP", args[i]);
                    continue;
                }

                if (!BPlist.Contains(bp.targetItem.itemid))
                    BPlist.Add(bp.targetItem.itemid);

                Message(iplayer, "UnlockPlayersBps", bp.name, targetPlayer.displayName);
            }

            if (BPlist.Count == 0)
            {
                Pool.FreeUnmanaged(ref BPlist);
                return;
            }
            UnlockBPs(targetPlayer, BPlist);
        }

        private void CMDBPRemove(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permadmin))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length < 2)
            {
                Message(iplayer, "CMDRemoveArgs");
                return;
            }

            BasePlayer targetPlayer = BasePlayer.Find(args[0]);
            if (targetPlayer == null || !targetPlayer.IsConnected)
            {
                Message(iplayer, "PlayerNotFound", args[0]);
                return;
            }

            var BPlist = Pool.Get<List<int>>();

            for (int i = 1; i < args.Length; i++)
            {
                ItemBlueprint? bp = ItemManager.FindItemDefinition(args[i])?.Blueprint;
                if (bp == null)
                {
                    Message(iplayer, "CannotFindBP", args[i]);
                    continue;
                }

                if (!BPlist.Contains(bp.targetItem.itemid))
                    BPlist.Add(bp.targetItem.itemid);

                Message(iplayer, "RemovePlayersBps", bp.name, targetPlayer.displayName);
            }

            if (BPlist.Count == 0)
            {
                Pool.FreeUnmanaged(ref BPlist);
                return;
            }
            RemoveBPs(targetPlayer, BPlist);
        }

        private void CMDWipeAll(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permadmin))
            {
                Message(iplayer, "NoPerms");
                return;
            }

            WipeAllBps();

            Message(iplayer, "ResetAllBps");
        }

        #endregion Commands

        #region Methods
        private void WipeAllBps()
        {
            foreach (var player in BasePlayer.allPlayerList)
            {
                WipeBPs(player);
            }
            if (updateAllPlayers == null)
                updateAllPlayers = ServerMgr.Instance.StartCoroutine(UpdateAllPlayers());
        }

        private void WipeBPs(BasePlayer player)
        {
            var persistantPlayerInfo = player.PersistantPlayerInfo;
            persistantPlayerInfo.unlockedItems.Clear();
            player.PersistantPlayerInfo = persistantPlayerInfo;
            player.SendNetworkUpdateImmediate();
            player.ClientRPC<int>(RpcTarget.Player("UnlockedBlueprint", player), 0);
        }

        private void RemoveBPs(BasePlayer player, List<int> bps)
        {
            var persistantPlayerInfo = player.PersistantPlayerInfo;
            for(int i = persistantPlayerInfo.unlockedItems.Count - 1; i >= 0; i--)
            {
                if (bps.Contains(persistantPlayerInfo.unlockedItems[i]))
                    persistantPlayerInfo.unlockedItems.RemoveAt(i);
            }
            player.PersistantPlayerInfo = persistantPlayerInfo;
            player.SendNetworkUpdateImmediate();
            player.ClientRPC<int>(RpcTarget.Player("UnlockedBlueprint", player), 0);
            Pool.FreeUnmanaged(ref bps);
        }

        private void UnlockBPs(BasePlayer player, List<int> bps)
        {
            var persistantPlayerInfo = player.PersistantPlayerInfo;
            foreach (var bp in bps)
            {
                if (persistantPlayerInfo.unlockedItems.Contains(bp))
                    continue;
                persistantPlayerInfo.unlockedItems.Add(bp);
            }
            player.PersistantPlayerInfo = persistantPlayerInfo;
            player.SendNetworkUpdateImmediate();
            player.ClientRPC<int>(RpcTarget.Player("UnlockedBlueprint", player), 0);
            Pool.FreeUnmanaged(ref bps);
        }

        private void UnlockAllBPs(BasePlayer player)
        {
            var persistantPlayerInfo = player.PersistantPlayerInfo;
            foreach (var bp in _permissionBPs[permunlockall])
            {
                if (persistantPlayerInfo.unlockedItems.Contains(bp))
                    continue;
                persistantPlayerInfo.unlockedItems.Add(bp);
            }
            player.PersistantPlayerInfo = persistantPlayerInfo;
            player.SendNetworkUpdateImmediate();
            player.ClientRPC<int>(RpcTarget.Player("UnlockedBlueprint", player), 0);
        }

        private void UpdatePlayerBPs(BasePlayer player, bool defaultOnly = false)
        {
            List<int> bpsToUnlock = Pool.Get<List<int>>();
            bpsToUnlock.AddRange(_defaultBlueprints);

            if (!defaultOnly)
            {
                foreach (var perm in _permissionBPs)
                {
                    if (!HasPerm(player.UserIDString, perm.Key)) continue;
                    foreach (var bp in perm.Value)
                    {
                        if (!bpsToUnlock.Contains(bp))
                            bpsToUnlock.Add(bp);
                    }
                }
            }

            var PersistantPlayerInfo = player.PersistantPlayerInfo;

            bool update = false;
            foreach (var bp in bpsToUnlock)
            {
                if (player.PersistantPlayerInfo.unlockedItems.Contains(bp)) continue;
                player.PersistantPlayerInfo.unlockedItems.Add(bp);
                update = true;
            }

            if (!update) return; //Nothing to update

            player.PersistantPlayerInfo = PersistantPlayerInfo;
            player.SendNetworkUpdateImmediate();
            player.ClientRPC<int>(RpcTarget.Player("UnlockedBlueprint", player), 0);
            Pool.FreeUnmanaged(ref bpsToUnlock);
        }

        #endregion Methods

        #region Hooks
        void OnNewSave(string filename)
        {
            if (!config.wipeOnMap)
                return;
            WipeAllBps();
        }

        object CanUnlockTechTreeNode(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTree)
        {
            ItemBlueprint itemBlueprint = node.itemDef.Blueprint;
            if (itemBlueprint != null && !itemBlueprint.isResearchable)
            {
                int mins = -1;
                _unlockAfterWipe.TryGetValue(itemBlueprint, out mins);
                Message(player.IPlayer, "BlueprintLocked", itemBlueprint.name, (mins == -1) ? "forever" : $"{TimeSpan.FromSeconds(mins * 60 - Time.realtimeSinceStartup):hh\\:mm}");
                return false;
            }
            return null;
        }
        private void OnUserPermissionGranted(string userId, string perm)
        {
            if (!perm.Contains("blueprintmanager")) return;
            BasePlayer player = BasePlayer.Find(userId);
            if (player == null) return;
            UpdatePlayerBPs(player);
        }

        private void OnUserGroupAdded(string userId, string groupname)
        {
            foreach (var groupperms in permission.GetGroupPermissions(groupname))
            {
                if (!groupperms.Contains("blueprintmanager")) continue;
                BasePlayer player = BasePlayer.Find(userId);
                if (player == null) return;
                UpdatePlayerBPs(player);
                return;
            }
        }

        private void OnPlayerConnected(BasePlayer player) => UpdatePlayerBPs(player);

        #endregion Hooks

        #region Helpers
        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }
        private void Message(IPlayer player, string langKey, params object[] args)
        {
            if (player.IsConnected) player.Message(GetLang(langKey, player.Id, args));
        }

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (!message.Key.Equals(command)) continue;

                    if (string.IsNullOrEmpty(message.Value)) continue;

                    AddCovalenceCommand(message.Value, command);
                }
            }
        }
        #endregion Helpers
    }
}

// --- End of file: BlueprintManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/box-sorter-lite ---
// --- Original File Path: B/BoxSorterLite/BoxSorterLite.cs ---

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Box Sorter Lite", "haggbart", "1.0.9")]
    [Description("Sort your loot in boxes using an intuitive interface.")]
    internal class BoxSorterLite : RustPlugin
    {
        private const string permUse = "boxsorterlite.use";
        private Dictionary<ulong, BoxCategory> _skinbox = new Dictionary<ulong, BoxCategory>();
        private string boxContentCommand;
        private string boxContentName;
        private CuiElementContainer cuiContainer;
        private List<Item> selectedItems;

        private struct BoxCategory
        {
            public string Name { get; set; }
            public HashSet<int> ItemIds { get; set; }
        }

        #region init

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["select"] = "Select category...",
                ["clothing"] = "Clothing",
                ["weapons"] = "Weapons",
                ["ammo"] = "Ammo",
                ["medicine"] = "Medicine",
                ["tools"] = "Tools",
                ["resources"] = "Resources",
                ["refined"] = "Refined",
                ["explosives"] = "Explosives",
                ["components"] = "Components",
                ["electronics"] = "Electronics",
                ["keys"] = "Keys",
                ["building"] = "Building",
                ["food"] = "Food"
            }, this);
        }

        private void OnServerInitialized()
        {
            _skinbox = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, BoxCategory>>("BoxSorterLite");
            if (_skinbox.Count != 12)
                InitSorters();
            permission.RegisterPermission(permUse, this);
        }

        private void InitSorters()
        {
            Puts("Generating default values...");
            var explosives = new HashSet<int>
            {
                -1878475007, // satchel charge
                1248356124, // c4
                -592016202, // explosives
                1840822026, // beancan grenade
                -1841918730, // high velocity rocket
                1638322904, // incendiary rocket
                -742865266, // rocket
                -1321651331, // explosive ammo
                349762871 // he grenade
            };
            var resources = new HashSet<int>(ItemManager.GetItemDefinitions()
                .Where(k => k.category == ItemCategory.Resources).Select(x => x.itemid));
            resources.Remove(1523195708); // targeting computer
            resources.Remove(634478325); // cctv
            var refined = new HashSet<int>
            {
                317398316, // hqm
                69511070, // metal fragments
                -1581843485, // sulfur
                -151838493, // wood
                -2099697608, // stone
                -946369541, // low grade fuel
                -1938052175, // charcoal
                -265876753 // gunpowder
            };
            resources.ExceptWith(refined);
            
            var electronics = new HashSet<int>(ItemManager.GetItemDefinitions()
                .Where(k => k.category == ItemCategory.Electrical).Select(x => x.itemid));
            
            var keys = new HashSet<int>
            {
                -629028935, // electric fuse
                37122747, // green keycard
                -484206264, // blue keycard
                -1880870149 // red keycard  
            };
            var misc = new HashSet<int>(ItemManager.GetItemDefinitions().Where(k => k.category == ItemCategory.Misc)
                .Select(x => x.itemid));
            misc.ExceptWith(keys);
            var itemids = new HashSet<int>(ItemManager.GetItemDefinitions()
                .Where(k => k.category == ItemCategory.Attire).Select(x => x.itemid));
            _skinbox.Add(576569265, new BoxCategory {Name = "clothing", ItemIds = itemids});
            itemids = new HashSet<int>(ItemManager.GetItemDefinitions().Where(k => k.category == ItemCategory.Weapon)
                .Select(x => x.itemid));
            itemids.Remove(1840822026); // remove beancan
            _skinbox.Add(854718942, new BoxCategory {Name = "weapons", ItemIds = itemids});
            itemids = new HashSet<int>(ItemManager.GetItemDefinitions()
                .Where(k => k.category == ItemCategory.Ammunition).Select(x => x.itemid));
            itemids.ExceptWith(explosives);
            _skinbox.Add(813269955, new BoxCategory {Name = "ammo", ItemIds = itemids});
            itemids = new HashSet<int>(ItemManager.GetItemDefinitions().Where(k => k.category == ItemCategory.Medical)
                .Select(x => x.itemid));
            _skinbox.Add(882223700, new BoxCategory {Name = "medicine", ItemIds = itemids});
            itemids = new HashSet<int>(ItemManager.GetItemDefinitions().Where(k => k.category == ItemCategory.Tool)
                .Select(x => x.itemid));
            itemids.ExceptWith(explosives);
            _skinbox.Add(1192724938, new BoxCategory {Name = "tools", ItemIds = itemids});
            _skinbox.Add(809171741, new BoxCategory {Name = "resources", ItemIds = resources});
            _skinbox.Add(1353721544, new BoxCategory {Name = "refined", ItemIds = refined});
            _skinbox.Add(798455489, new BoxCategory {Name = "explosives", ItemIds = explosives});
            itemids = new HashSet<int>(ItemManager.GetItemDefinitions().Where(k => k.category == ItemCategory.Component)
                .Select(x => x.itemid)) {1523195708, 634478325};
            // added targeting computer, cctv
            itemids.Remove(-629028935); // remove electric fuse
            _skinbox.Add(854002617, new BoxCategory {Name = "components", ItemIds = itemids});
            _skinbox.Add(1588282308, new BoxCategory {Name = "electronics", ItemIds = electronics});
            _skinbox.Add(1686299197, new BoxCategory {Name = "keys", ItemIds = keys});
            itemids = new HashSet<int>(ItemManager.GetItemDefinitions()
                .Where(k => k.category == ItemCategory.Construction).Select(x => x.itemid));
            itemids.UnionWith(new HashSet<int>(ItemManager.GetItemDefinitions()
                .Where(k => k.category == ItemCategory.Items).Select(x => x.itemid)));
            itemids.UnionWith(new HashSet<int>(ItemManager.GetItemDefinitions()
                .Where(k => k.category == ItemCategory.Traps).Select(x => x.itemid)));
            itemids.UnionWith(misc);
            _skinbox.Add(813563521, new BoxCategory {Name = "building", ItemIds = itemids});
            Interface.Oxide.DataFileSystem.WriteObject("BoxSorterLite", _skinbox);
        }

        #endregion init

        #region hooks

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (!player.IsBuildingAuthed() || !(entity is BoxStorage) ||
                !permission.UserHasPermission(player.UserIDString, permUse) || entity.prefabID == 1560881570) return;
            CreateBoxUI(player, entity);
        }

        private void OnPlayerLootEnd(PlayerLoot inventory)
        {
            var player = inventory.GetComponent<BasePlayer>();
            CuiHelper.DestroyUi(player, "BoxUIHeader");
            CuiHelper.DestroyUi(player, "BoxUIContent");
            CuiHelper.DestroyUi(player, "BoxUISort");
        }

        #endregion hooks

        #region CUI

        private void CreateBoxUI(BasePlayer player, BaseEntity entity, int header = 0)
        {
            if (header == 0)
                AddHeaderUI(player);
            cuiContainer = ContainerOffset("BoxUIContent", "0.65 0.65 0.65 0.06", "0.5 0", "0.5 0", "192.5 16",
                "423 75.9");
            if (_skinbox.ContainsKey(entity.skinID) || entity.prefabID == 1844023509)
                AddSelectedUI(player, entity);
            else
                AddCategoryUI(player, cuiContainer);
        }

        private void AddHeaderUI(BasePlayer player)
        {
            cuiContainer = ContainerOffset("BoxUIHeader", "0.86 0.86 0.86 0.2", "0.5 0", "0.5 0", "192.5 78.5",
                "423 98");
            Label(ref cuiContainer, "BoxUIHeader", "<b>BOX SORTING</b>", "0.91 0.87 0.83 1.0", 13, "0.051 0", "1 0.95",
                0f, TextAnchor.MiddleLeft);
            CuiHelper.DestroyUi(player, "BoxUIHeader");
            CuiHelper.AddUi(player, cuiContainer);
        }

        private readonly StringBuilder xY1 = new StringBuilder();
        private readonly StringBuilder xY2 = new StringBuilder();
        private readonly StringBuilder cD = new StringBuilder();

        private void AddCategoryUI(BasePlayer player, CuiElementContainer container)
        {
            Label(ref container, "BoxUIContent", lang.GetMessage("select", this, player.UserIDString),
                "0.91 0.87 0.83 1.0", 10, "0.02 0.76", "1 0.96", 0f, TextAnchor.UpperLeft);

            const float x20 = 0.246f;
            const float x10 = 1 - 4.0f * x20;
            const float yspace = 0.25f;

            float x1 = x10;
            float x2 = x20;
            var y2 = 0.75f;
            float y1 = y2 - 0.2f;
            var count = 0;
            foreach (var box in _skinbox)
            {
                xY1.Append(x1);
                xY1.Append(" ");
                xY1.Append(y1);
                xY2.Append(x2);
                xY2.Append(" ");
                xY2.Append(y2);
                cD.Append("boxsorter.select ");
                cD.Append(box.Key);
                Button(ref container, "BoxUIContent", "0.65 0.65 0.65 0.06",
                    lang.GetMessage(box.Value.Name, this, player.UserIDString), "0.77 0.77 0.77 1", 9, xY1.ToString(),
                    xY2.ToString(), cD.ToString());
                xY1.Length = 0;
                xY2.Length = 0;
                cD.Length = 0;
                count++;
                x1 += x20;
                x2 += x20;

                if (count % 4 != 0) continue;
                y1 -= yspace;
                y2 -= yspace;
                x1 = x10;
                x2 = x20;
            }

            CuiHelper.DestroyUi(player, "BoxUIContent");
            CuiHelper.AddUi(player, container);
        }

        private void AddSelectedUI(BasePlayer player, BaseEntity entity)
        {
            if (entity.prefabID == 1844023509) // refigerator
            {
                boxContentName = "food";
                boxContentCommand = string.Empty;
            }
            else
            {
                boxContentName = _skinbox[entity.skinID].Name;
                boxContentCommand = "boxsorter.select 969292267";
            }

            Button(ref cuiContainer, "BoxUIContent", "0.65 0.65 0.65 0.12",
                lang.GetMessage(boxContentName, this, player.UserIDString), "0.77 0.77 0.77 1", 20, "0 0", "1 1",
                boxContentCommand);
            CuiHelper.DestroyUi(player, "BoxUIContent");
            CuiHelper.AddUi(player, cuiContainer);
            cuiContainer = ContainerOffset("BoxUISort", "0.75 0.75 0.75 0", "0.5 0", "0.5 0", "75 341", "179 359");
            Button(ref cuiContainer, "BoxUISort", "0.75 0.75 0.75 0.1", "<b>></b>", "0.91 0.87 0.83 0.8", 11, "0 0",
                "0.48 1", "boxsorter.insert");
            Button(ref cuiContainer, "BoxUISort", "0.415 0.5 0.258 0.4", "<b>Sort</b>", "0.607 0.705 0.431", 11,
                "0.52 0", "1 1", "boxsorter.sort");
            CuiHelper.DestroyUi(player, "BoxUISort");
            CuiHelper.AddUi(player, cuiContainer);
        }

        [ConsoleCommand("boxsorter.sort")]
        private void CmdSort(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            BaseEntity entity = player.inventory.loot.entitySource;
            if (entity == null || !player.IsBuildingAuthed()) return;
            ItemContainer inventory = player.inventory.loot.entitySource.GetComponent<StorageContainer>()?.inventory;
            if (inventory == null) return;
            selectedItems = inventory.itemList.ToList();
            while (inventory.itemList.Count > 0)
                inventory.itemList[0].RemoveFromContainer();
            selectedItems.Sort((x, y) => x.info.itemid.CompareTo(y.info.itemid));
            if (_skinbox.ContainsKey(entity.skinID))
                foreach (Item item in selectedItems)
                    if (!_skinbox[entity.skinID].ItemIds.Contains(item.info.itemid) &&
                        !player.inventory.containerMain.IsFull())
                        item.MoveToContainer(player.inventory.containerMain);
                    else
                        item.MoveToContainer(inventory);
            else if (entity.prefabID == 1844023509)
                foreach (Item item in selectedItems)
                    item.MoveToContainer(inventory);
        }

        [ConsoleCommand("boxsorter.insert")]
        private void CmdInsert(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            BaseEntity entity = player.inventory.loot.entitySource;
            if (entity == null || !player.IsBuildingAuthed()) return;
            ItemContainer inventory = player.inventory.loot.entitySource.GetComponent<StorageContainer>()?.inventory;
            if (inventory == null) return;
            selectedItems = new List<Item>();
            if (_skinbox.ContainsKey(entity.skinID))
                selectedItems = player.inventory.containerMain.itemList
                    .Where(x => _skinbox[entity.skinID].ItemIds.Contains(x.info.itemid)).ToList();

            else if (entity.prefabID == 1844023509)
                selectedItems = player.inventory.containerMain.itemList.Where(x => x.info.category == ItemCategory.Food)
                    .ToList();
            foreach (Item item in selectedItems)
            {
                if (!item.CanMoveTo(inventory)) break;
                item.MoveToContainer(inventory);
            }
        }

        [ConsoleCommand("boxsorter.select")]
        private void CmdSelect(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            BaseEntity entity = player.inventory.loot.entitySource;
            if (entity == null || !player.IsBuildingAuthed()) return;
            ItemContainer inventory = player.inventory.loot.entitySource.GetComponent<StorageContainer>()?.inventory;
            if (inventory == null) return;
            uint skinid;
            uint.TryParse(arg.Args[0], out skinid);
            entity.skinID = skinid;
            entity.SendNetworkUpdate();
            CuiHelper.DestroyUi(player, "BoxUISort");
            CreateBoxUI(player, entity, 1);
        }

        #endregion CUI

        #region CUI Helper 

        //================================= [  ] =======================================

        private static CuiElementContainer ContainerOffset(string panelName, string color, string aMin, string aMax,
            string offSetMin = "0 0", string offSetMax = "0 0", float fadein = 0f, bool useCursor = false,
            string parent = "Overlay")
        {
            var newElement = new CuiElementContainer
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color, FadeIn = fadein},
                        RectTransform =
                            {AnchorMin = aMin, AnchorMax = aMax, OffsetMin = offSetMin, OffsetMax = offSetMax},
                        CursorEnabled = useCursor
                    },
                    new CuiElement().Parent = parent,
                    panelName
                }
            };
            return newElement;
        }

        private void Panel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax,
            float fadein = 0f, bool cursor = false)
        {
            container.Add(new CuiPanel
                {
                    Image = {Color = color, FadeIn = fadein},
                    RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                    CursorEnabled = cursor
                },
                panel);
        }

        private static void Label(ref CuiElementContainer container, string panel, string text, string color,
            int size, string aMin, string aMax, float fadein = 0f, TextAnchor align = TextAnchor.MiddleCenter)
        {
            container.Add(new CuiLabel
                {
                    Text =
                    {
                        FontSize = size,
                        Align = align,
                        Text = text,
                        Color = color,
                        Font = "robotocondensed-regular.ttf",
                        FadeIn = fadein
                    },
                    RectTransform = {AnchorMin = aMin, AnchorMax = aMax}
                },
                panel);
        }

        private static void Button(ref CuiElementContainer container, string panel, string color, string text,
            string color1, int size, string aMin, string aMax, string command,
            TextAnchor align = TextAnchor.MiddleCenter)
        {
            container.Add(new CuiButton
                {
                    Button = {Color = color, Command = command, FadeIn = 0f},
                    RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                    Text =
                    {
                        Text = text,
                        FontSize = size,
                        Align = align,
                        Color = color1,
                        Font = "robotocondensed-regular.ttf"
                    }
                },
                panel);
        }
        #endregion CUI Helper
    }
}

// --- End of file: BoxSorterLite.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-chat-flood ---
// --- Original File Path: B/BetterChatFlood/BetterChatFlood.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("BetterChatFlood", "Ryan", "1.0.5")]
    [Description("Adds a cooldown to chat to prevent flooding")]
    public class BetterChatFlood : CovalencePlugin
    {
        [PluginReference]
        private Plugin BetterChat;
        private ConfigFile _Config;
        private Dictionary<string, DateTime> cooldowns = new Dictionary<string, DateTime>();
        private Dictionary<string, int> thresholds = new Dictionary<string, int>();
        private bool canBetterChat = true;
        private const string permBypass = "betterchatflood.bypass";

        public class ConfigFile
        {
            [JsonProperty(PropertyName = "Cooldown Period (seconds)")]
            public float cooldown;

            [JsonProperty(PropertyName = "Number of messages before cooldown")]
            public int threshold;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    cooldown = 5f,
                    threshold = 3
                };
            }
        }

        protected override void LoadDefaultConfig() => _Config = ConfigFile.DefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _Config = Config.ReadObject<ConfigFile>();
        }

        protected override void SaveConfig() => Config.WriteObject(_Config);

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Cooldown"] = "Try again in {0} seconds"
            }, this);
        }

        private void Init() => permission.RegisterPermission(permBypass, this);

        private void OnServerInitialized()
        {
            if (!BetterChat) Unsubscribe(nameof(OnBetterChat));
            if (BetterChat && BetterChat.Version < new VersionNumber(5, 0, 6))
            {
                Unsubscribe(nameof(OnBetterChat));
                PrintWarning("This plugin is only compatable with BetterChat version 5.0.6 or greater!");
            }
        }

        private void Unload() => cooldowns.Clear();

        private double GetNextMsgTime(IPlayer player)
        {
            if (cooldowns[player.Id].AddSeconds(_Config.cooldown) > DateTime.Now)
                return Math.Ceiling((cooldowns[player.Id].AddSeconds(_Config.cooldown) - DateTime.Now).TotalSeconds);
            return 0;
        }

        private object IsFlooding(IPlayer player, string action = null)
        {
            if (cooldowns.ContainsKey(player.Id))
            {
                if (permission.UserHasPermission(player.Id, permBypass)) return null;

                var hasCooldown = GetNextMsgTime(player) > 0;
                if (hasCooldown)
                {
                    if (thresholds.ContainsKey(player.Id))
                    {
                        if (thresholds[player.Id] > _Config.threshold)
                        {
                            if (action != null)
                                player.Message(string.Format(lang.GetMessage("Cooldown", this, player.Id), GetNextMsgTime(player)));
                            return true;
                        }

                        if (action != null)
                        {
                            thresholds[player.Id] = ++thresholds[player.Id];
                            cooldowns.Remove(player.Id);
                            cooldowns.Add(player.Id, DateTime.Now);
                        }
                        return null;
                    }

                    if (!thresholds.ContainsKey(player.Id))
                        thresholds.Add(player.Id, 1);
                    return null;
                }

                if (!hasCooldown && cooldowns.ContainsKey(player.Id))
                {
                    cooldowns.Remove(player.Id);
                    if (thresholds.ContainsKey(player.Id))
                        thresholds.Remove(player.Id);
                }
            }

            if (action != null && !cooldowns.ContainsKey(player.Id))
                cooldowns.Add(player.Id, DateTime.Now);

            return null;
        }

        private object OnUserChat(IPlayer player, string message) => IsFlooding(player, "chat");

        private object OnBetterChat(Dictionary<string, object> data) => IsFlooding(data["Player"] as IPlayer);
    }
}


// --- End of file: BetterChatFlood.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/back-pump-jack ---
// --- Original File Path: B/BackPumpJack/BackPumpJack.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;
using UnityEngine.Networking;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Back Pump Jack", "Arainrr/Lorenzo", "1.4.33")]
    [Description("Allows players to use survey charges to create oil/mining crater")]
    public class BackPumpJack : CovalencePlugin
    {
        #region Fields

        [PluginReference] private Plugin Friends;
        [PluginReference] private Plugin Clans;
        [PluginReference] private Plugin Notify;

        private static BackPumpJack _instance;
        private static DiscordComponent _discord = null;

        private const string TraceFile = "Trace";     // file name in log directory

        private const uint FuelStoragePumpID = 4260630588;
        private const uint OutputHopperPumpID = 70163214;

        private const uint FuelStorageQuarryID = 362963830;
        private const uint OutputHopperQuarryID = 875142383;

        private const string PREFAB_CRATER_OIL = "assets/prefabs/tools/surveycharge/survey_crater_oil.prefab";

        private readonly HashSet<ulong> _checkedCraters = new HashSet<ulong>();
        private readonly List<QuarryData> _activeCraters = new List<QuarryData>();
        private readonly List<MiningQuarry> _miningQuarries = new List<MiningQuarry>();
        private readonly Dictionary<ulong, PermissionSettings> _activeSurveyCharges = new Dictionary<ulong, PermissionSettings>();

        private int QuarryDefaultDieselStack = 0;
        private int QuarryDefaultFuelCapacity = 6;
        private int QuarryDefaultHopperSlots = 18;

        private int PumpDefaultDieselStack = 0;
        private int PumpDefaultFuelCapacity = 6;
        private int PumpDefaultHopperSlots = 18;

        public Timer refilltimer = null;
        private readonly float PlayerRadius = 12f;
        private readonly float MatchRadius = 1.5f;

#if CARBON
        const char Platform = 'C';
#else
        const char Platform = 'O';
#endif

        struct QuarryRates
        {
            public float processRate;
            public float workToAdd;
            public float workPerFuel;
        }

        QuarryRates miningQuarryBackup;
        QuarryRates pumpjackbackup;

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            MiningQuarry staticQuarry;
            MiningQuarry miningQuarry;
            MiningQuarry staticpumpjack;
            MiningQuarry pumpjack;

            StorageContainer fuelstorage;
            StorageContainer hopper;
            _instance = this;

            LoadData();
            foreach (var permissionSetting in _configData.Permissions)
            {
                if (!permission.PermissionExists(permissionSetting.Permission, this))
                {
                    permission.RegisterPermission(permissionSetting.Permission, this);
                }
            }

            staticQuarry = GameManager.server.FindPrefab("assets/bundled/prefabs/static/miningquarry_static.prefab")?.GetComponent<MiningQuarry>();
            miningQuarry = GameManager.server.FindPrefab("assets/prefabs/deployable/quarry/mining_quarry.prefab")?.GetComponent<MiningQuarry>();
            staticpumpjack = GameManager.server.FindPrefab("assets/bundled/prefabs/static/pumpjack-static.prefab")?.GetComponent<MiningQuarry>();
            pumpjack = GameManager.server.FindPrefab("assets/prefabs/deployable/oil jack/mining.pumpjack.prefab")?.GetComponent<MiningQuarry>();

            if (_configData.ApplyPatchForMiningRates)
            {
                miningQuarryBackup.processRate = miningQuarry.processRate;
                miningQuarryBackup.workToAdd = miningQuarry.workToAdd;
                miningQuarryBackup.workPerFuel = miningQuarry.workPerFuel;

                miningQuarry.processRate = staticQuarry.processRate;
                miningQuarry.workToAdd = staticQuarry.workToAdd;
                miningQuarry.workPerFuel = staticQuarry.workPerFuel;

                pumpjackbackup.processRate = pumpjack.processRate;
                pumpjackbackup.workToAdd = pumpjack.workToAdd;
                pumpjackbackup.workPerFuel = pumpjack.workPerFuel;

                pumpjack.processRate = staticpumpjack.processRate;
                pumpjack.workToAdd = staticpumpjack.workToAdd;
                pumpjack.workPerFuel = staticpumpjack.workPerFuel;
            }

            if (staticQuarry != null)
            {
                fuelstorage = staticQuarry?.fuelStoragePrefab.prefabToSpawn.GetEntity() as StorageContainer;
                QuarryDefaultDieselStack = fuelstorage?.maxStackSize ?? 0;
                QuarryDefaultFuelCapacity = fuelstorage?.inventorySlots ?? 6;

                hopper = staticQuarry.hopperPrefab.prefabToSpawn.GetEntity() as StorageContainer;
                QuarryDefaultHopperSlots = hopper?.inventorySlots ?? 18;
            }

            if (staticpumpjack != null)
            {
                fuelstorage = staticpumpjack.fuelStoragePrefab.prefabToSpawn.GetEntity() as StorageContainer;
                PumpDefaultDieselStack = fuelstorage?.maxStackSize ?? 0;
                PumpDefaultFuelCapacity = fuelstorage?.inventorySlots ?? 6;

                hopper = staticpumpjack.hopperPrefab.prefabToSpawn.GetEntity() as StorageContainer;
                PumpDefaultHopperSlots = hopper?.inventorySlots ?? 18;
            }


            Unsubscribe(nameof(CanBuild));
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }

        private void Unload()
        {
            foreach (var serverEntity in BaseNetworkable.serverEntities)
            {
                if (serverEntity is MiningQuarry miningQuarry)
                {

                    if (miningQuarry.ShortPrefabName == "mining_quarry")
                    {
                        // restore default value
                        try
                        {
                            var fuelstorage = miningQuarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>();
                            if (_configData.DieselFuelMaxStackSize >= 0) fuelstorage.inventory.maxStackSize = QuarryDefaultDieselStack;
                            if (_configData.FuelSlots > 0) fuelstorage.inventory.capacity = QuarryDefaultFuelCapacity;
                        }
                        catch (Exception ex)
                        {
                            PrintError(ex.Message);
                            PrintError($"Quarry at location {miningQuarry.transform.position} is missing fuel storage container.");
                            miningQuarry.fuelStoragePrefab?.DoSpawn(miningQuarry);
                        }

                        // restore default value
                        try {
                            var hopper = miningQuarry.hopperPrefab.instance.GetComponent<StorageContainer>();
                            if (_configData.HopperSlots > 0) hopper.inventory.capacity = QuarryDefaultHopperSlots;
                        }
                        catch (Exception ex)
                        {
                            PrintError(ex.Message);
                            PrintError($"Quarry at location {miningQuarry.transform.position} is missing hopper storage container.");
                            miningQuarry.hopperPrefab?.DoSpawn(miningQuarry);
                        }
                    }

                    if (miningQuarry.ShortPrefabName == "mining.pumpjack")
                    {
                        try {
                            // restore default value
                            var fuelstorage = miningQuarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>();
                            if (_configData.DieselFuelMaxStackSize >= 0) fuelstorage.inventory.maxStackSize = PumpDefaultDieselStack;
                            if (_configData.FuelSlots > 0) fuelstorage.inventory.capacity = PumpDefaultFuelCapacity;
                        }
                        catch (Exception ex)
                        {
                            PrintError(ex.Message);
                            PrintError($"Quarry at location {miningQuarry.transform.position} is missing fuel storage container.");
                            miningQuarry.fuelStoragePrefab?.DoSpawn(miningQuarry);
                        }

                        // restore default value
                        try {
                            var hopper = miningQuarry.hopperPrefab.instance.GetComponent<StorageContainer>();
                            if (_configData.HopperSlots > 0) hopper.inventory.capacity = PumpDefaultHopperSlots;
                        }
                        catch (Exception ex)
                        {
                            PrintError(ex.Message);
                            PrintError($"Quarry at location {miningQuarry.transform.position} is missing hopper storage container.");
                            miningQuarry.hopperPrefab?.DoSpawn(miningQuarry);
                        }
                    }

                    if (miningQuarry.ShortPrefabName == "mining_quarry" || miningQuarry.ShortPrefabName == "mining.pumpjack")
                    {
                        if (_configData.TimePerBarrel > 0) miningQuarry.workPerFuel = 1000f;
                        if (miningQuarry.pendingWork > miningQuarry.workPerFuel) miningQuarry.pendingWork = miningQuarry.workPerFuel;
                    }

                    if (miningQuarry.isStatic)
                    {
                        miningQuarry.UpdateStaticDeposit();
                    }

                    QuarryStateDetector quarrydetector = miningQuarry.gameObject.GetComponent<QuarryStateDetector>();
                    // When server shutdown, onDestroy member never execute with Destroy(obj) 
                    // use DestroyImmediate instead to avoid execution delay
                    if (quarrydetector != null) UnityEngine.Object.DestroyImmediate(quarrydetector);

                }
            }

            if (_configData.ApplyPatchForMiningRates)
            {
                var miningQuarry = GameManager.server.FindPrefab("assets/prefabs/deployable/quarry/mining_quarry.prefab")?.GetComponent<MiningQuarry>();
                if (miningQuarry != null)
                {
                    miningQuarry.processRate = miningQuarryBackup.processRate;
                    miningQuarry.workToAdd = miningQuarryBackup.workToAdd;
                    miningQuarry.workPerFuel = miningQuarryBackup.workPerFuel;
                }
                var pumpjack = GameManager.server.FindPrefab("assets/prefabs/deployable/oil jack/mining.pumpjack.prefab")?.GetComponent<MiningQuarry>();
                if (pumpjack != null)
                {
                    pumpjack.processRate = pumpjackbackup.processRate;
                    pumpjack.workToAdd = pumpjackbackup.workToAdd;
                    pumpjack.workPerFuel = pumpjackbackup.workPerFuel;
                }
            }

            if (refilltimer != null) refilltimer.Destroy();

            SaveData();
            _instance = null;
            _discord = null;
        }

        private void OnServerInitialized(bool initial)
        {
            
            // setup discord info
            if (_configData.Global.Discordena && !string.IsNullOrEmpty(_configData.Global.DiscordHookUrl))
            {
                var loader = new GameObject("WebObject");
                _discord = loader.AddComponent<DiscordComponent>().Configure(_configData.Global.DiscordHookUrl);
            }
            PrintToLog($"Plugin BackPumpJack restarted");

            if (_configData.Global.CantDeploy)
            {
                Subscribe(nameof(CanBuild));
            }
            if (_configData.Global.CantDamage)
            {
                Subscribe(nameof(OnEntityTakeDamage));
            }

            AddCovalenceCommand(_configData.CommandRefill, nameof(CCmdRefresh));
            AddCovalenceCommand(_configData.CommandInfo, nameof(CCmdInfo));
            AddCovalenceCommand(_configData.CommandResetDeposits, nameof(CCmdResetDeposit));            

            var quarry = GameManager.server.FindPrefab("assets/prefabs/deployable/quarry/mining_quarry.prefab")?.GetComponent<MiningQuarry>();
            if (quarry != null)
            {
                QuarrySettings.WorkPerMinute = 60f / quarry.processRate * quarry.workToAdd;
            }
            var pumpjack = GameManager.server.FindPrefab("assets/prefabs/deployable/oil jack/mining.pumpjack.prefab")?.GetComponent<MiningQuarry>();
            if (pumpjack != null)
            {
                PumpJackSettings.WorkPerMinute = 60f / pumpjack.processRate * pumpjack.workToAdd;
            }

            if (_configData.Global.UseFriends && !IspluginLoaded(Friends))
            {
                PrintWarning("Optional Friend plugin not found. Friend disabled");
            }

            if (_configData.Global.UseClans && !IspluginLoaded(Clans))
            {
                PrintWarning("Optional Clans plugin not found. Clans disabled");
            }

            if (_configData.Global.useNotify && !IspluginLoaded(Notify))
            {
                PrintWarning("Optional Notify plugin not found. Notify disabled");
            }

            int CraterCount = 0;
            int QuaryCount = 0;
            timer.Once(2f, () =>
            {
                Subscribe(nameof(OnEntitySpawned));
                Subscribe(nameof(OnEntityKill));

                foreach (var serverEntity in BaseNetworkable.serverEntities)
                {
                    if (serverEntity is SurveyCrater surveyCrater)
                    {
                        CraterCount++;

                        var deposit = ResourceDepositManager.GetOrCreate(surveyCrater.transform.position);
                        if (deposit?._resources == null || deposit._resources.Count <= 0)
                        {
                            continue;
                        }
                        var mineralItems = deposit._resources.Select(depositEntry => new MineralItemData
                        {
                            amount = depositEntry.amount,
                            shortname = depositEntry.type.shortname,
                            workNeeded = depositEntry.workNeeded
                        }).ToList();
                        _activeCraters.Add(new QuarryData
                        {
                            position = surveyCrater.transform.position,
                            isLiquid = surveyCrater.ShortPrefabName == "survey_crater_oil",
                            mineralItems = mineralItems
                        });
                        continue;
                    }

                    if ((serverEntity is MiningQuarry miningQuarry) && !miningQuarry.IsDestroyed)
                    {

                        QuaryCount++;
                        OnEntitySpawned(miningQuarry);
                    }
                }

                CheckValidData();
            });
        }

        private void OnServerSave()
        {
            refilltimer = timer.Once(Random.Range(0f, 10f), () => { RefillMiningQuarries(); SaveData(); }); 
        }

        public readonly string[] QuarryTypeLookup = { "Oil", "Stone", "Sulfur", "HQM" };

        private void OnEntitySpawned(MiningQuarry miningQuarry)
        {
            if (miningQuarry == null) return;
            
            if ((miningQuarry.ShortPrefabName == "miningquarry_static" || miningQuarry.ShortPrefabName == "pumpjack-static") && !miningQuarry.OwnerID.IsSteamId())
            {
                if (_configData.StaticQuarryModifier)
                {
                    var type = QuarryTypeLookup[(int)miningQuarry.staticType];
                    StaticQuarrySettings QuarrySetting;
                    bool isLiquid = (miningQuarry.staticType == MiningQuarry.QuarryType.None);

                    float WorkPerMinute = miningQuarry.workToAdd * (60.0f / miningQuarry.processRate);
                    if (_configData.StaticQuarryType.TryGetValue(type, out QuarrySetting))
                    {
                        miningQuarry._linkedDeposit._resources.Clear();

                        QuarrySetting.RefillResourceDeposit(miningQuarry._linkedDeposit, WorkPerMinute, isLiquid);
                    }
                    else PrintWarning($"Missing resource definition of static quarry, from config file ({type})");
                }
                return;
            }

            _miningQuarries.Add(miningQuarry);
            UpdateAndRefill(miningQuarry);

            PrintToLog($"Resources for new mining quarry at {PositionToString(miningQuarry.transform.position)} / ({miningQuarry.transform.position}) : {getDepositInfo(miningQuarry._linkedDeposit)}");

            if (_configData.PatchLadder || _configData.PatchLightSignal)
            {
                QuarryStateDetector quarrydetector = miningQuarry.gameObject.GetComponent<QuarryStateDetector>();
                if (quarrydetector == null) miningQuarry.gameObject.AddComponent<QuarryStateDetector>();
            }

            try
            {
                var fuelstorage = miningQuarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>();
                if (_configData.DieselFuelMaxStackSize >= 0) fuelstorage.inventory.maxStackSize = _configData.DieselFuelMaxStackSize;
                if (_configData.FuelSlots > 0) fuelstorage.inventory.capacity = _configData.FuelSlots;
            }
            catch (Exception ex)
            {
                PrintError(ex.Message);
                PrintError($"Quarry at location {miningQuarry.transform.position} is missing fuel storage container.");
                miningQuarry.fuelStoragePrefab?.DoSpawn(miningQuarry);
            }

            try
            {
                var hopper = miningQuarry.hopperPrefab.instance.GetComponent<StorageContainer>();
                if (_configData.HopperSlots > 0) hopper.inventory.capacity = _configData.HopperSlots;
            }
            catch (Exception ex)
            {
                PrintError(ex.Message);
                PrintError($"Quarry at location {miningQuarry.transform.position} is missing hopper storage container.");
                miningQuarry.hopperPrefab?.DoSpawn(miningQuarry);
            }

            if (_configData.TimePerBarrel > 0.0f)
            {
                miningQuarry.workPerFuel = miningQuarry.workToAdd / miningQuarry.processRate * (float)_configData.TimePerBarrel;
            }
            if (miningQuarry.pendingWork > miningQuarry.workPerFuel) miningQuarry.pendingWork = miningQuarry.workPerFuel;
        }

        private bool UpdateAndRefill(MiningQuarry miningQuarry)
        {
            float minDistance = Math.Max(MatchRadius, _configData.ResourceDepositCheckRadius);
            QuarryData foundQuarryData = null;
            // scan stored data if entry exist
            foreach (var quarryData in _storedData.quarryDataList)
            {
                if (quarryData == null) continue;                
                var distance = Vector3Ex.Distance2D(quarryData.position, miningQuarry.transform.position);
                if (distance < minDistance)
                {
                    minDistance = distance;
                    foundQuarryData = quarryData;
                }
            }

            if (foundQuarryData == null)
            {
                // scan activecraters if entry exist
                foreach (var quarryData in _activeCraters)
                {
                    var distance = Vector3Ex.Distance2D(quarryData.position, miningQuarry.transform.position);
                    if (distance < minDistance)
                    {
                        minDistance = distance;
                        foundQuarryData = quarryData;
                    }
                }
                if (foundQuarryData != null)
                {
                    foundQuarryData.position = miningQuarry.transform.position;
                    _storedData.quarryDataList.Add(foundQuarryData);
                }
            }

            if (foundQuarryData != null)
            {
                CreateResourceDeposit(miningQuarry, foundQuarryData);
            }
            else
            {
                var permissionSetting = GetPermissionSetting(miningQuarry.OwnerID.ToString());
                if (permissionSetting == null) permissionSetting = _configData.Permissions[0];

                List<MineralItemData> mineralItems;
                miningQuarry._linkedDeposit._resources.Clear();
                if (miningQuarry.ShortPrefabName == "mining_quarry") mineralItems = permissionSetting.Quarry.RefillResourceDeposit(miningQuarry._linkedDeposit);
                else mineralItems = permissionSetting.PumpJack.RefillResourceDeposit(miningQuarry._linkedDeposit);

                if (mineralItems.Count == 0) PrintToLog("Deposit contain no mineral items !");
                else
                {
                    _storedData.quarryDataList.Add(new QuarryData
                    {
                        position = miningQuarry.transform.position,
                        isLiquid = miningQuarry._linkedDeposit._resources[0].isLiquid,
                        mineralItems = mineralItems
                    });
                }

                StringBuilder log = Pool.Get<StringBuilder>();
                log.AppendFormat("New deposit info for quarry at {0} ({1}), will be added to datafile\n{2}", 
                    PositionToString(miningQuarry.transform.position), miningQuarry.transform.position, getDepositInfo(miningQuarry._linkedDeposit));
                PrintToLog(log.ToString());
                Pool.FreeUnmanaged(ref log);
            }
            return (foundQuarryData != null);
        }

        private void OnEntityKill(MiningQuarry miningQuarry)
        {
            if (miningQuarry == null) return;

            if (miningQuarry.ShortPrefabName == "mining_quarry" || miningQuarry.ShortPrefabName == "mining.pumpjack")
            {
                _miningQuarries.Remove(miningQuarry);

                QuarryStateDetector quarrydetector = miningQuarry.gameObject.GetComponent<QuarryStateDetector>();
                if (quarrydetector != null) UnityEngine.Object.Destroy(quarrydetector);

                // cleanup datafile when quarry are removed
                CheckValidData();
                PrintToLog($"Mining Quarry was removed at location {PositionToString(miningQuarry.transform.position)} / ({miningQuarry.transform.position})");
            }
        }

        private void OnExplosiveThrown(BasePlayer player, SurveyCharge surveyCharge)
        {
            if (surveyCharge == null || surveyCharge.net == null) return;
            
            var permissionSetting = GetPermissionSetting(player.UserIDString);
            if (permissionSetting == null) return;
            surveyCharge.OwnerID = (ulong)player.userID;
            _activeSurveyCharges.Add(surveyCharge.net.ID.Value, permissionSetting);
        }

        private void OnEntityKill(SurveyCharge surveyCharge)
        {
            if (surveyCharge == null || surveyCharge.net == null) return;
            PrintToLog($"Survey charge at {PositionToString(surveyCharge.transform.position)} / ({surveyCharge.transform.position})");

            PermissionSettings permissionSettings;
            if (_activeSurveyCharges.TryGetValue(surveyCharge.net.ID.Value, out permissionSettings))
            {
                _activeSurveyCharges.Remove(surveyCharge.net.ID.Value);
                QuarryData craterinfo = findInactiveCraterData(surveyCharge);
                var position = surveyCharge.transform.position;
                var ownerId = surveyCharge.OwnerID;
                NextTick(() =>
                {
                    if (craterinfo == null) craterinfo = ModifyResourceDeposit(permissionSettings, position, ownerId);
                    else CopyResourceDepositInfo(permissionSettings, position, ownerId, craterinfo);
                    if (craterinfo != null) PrintToLog($"Resource deposit at {PositionToString(craterinfo.position)} / ({craterinfo.position}) : {getDepositInfo(craterinfo)}");
                });
            }
        }

        //private void OnEntitySpawned(SurveyCrater crater)
        //{
        //    if (crater == null || crater.net == null) return;
        //}

        private void OnEntityKill(SurveyCrater crater)
        {
            if (crater == null || crater.net == null) return;
            if (!_checkedCraters.Remove(crater.net?.ID.Value ?? 0))
                PrintWarning("OnEntityKill SurveyCrater not found");
        }

        private object OnEntityTakeDamage(SurveyCrater surveyCrater, HitInfo info)
        {
            if (surveyCrater == null || !surveyCrater.OwnerID.IsSteamId())
            {
                return null;
            }
            var player = info?.InitiatorPlayer;
            if (player == null || !player.userID.IsSteamId())
            {
                return true;
            }
            if (!AreFriends((ulong)player.userID, surveyCrater.OwnerID))
            {
                return true;
            }
            return null;
        }

        private object OnEntityTakeDamage(StorageContainer storage, HitInfo info)
        {
            if (storage?.GetParentEntity() is MiningQuarry)
            {
                var ShortPrefabName = (storage?.GetParentEntity() as MiningQuarry).ShortPrefabName;
                if (ShortPrefabName == "mining_quarry" || ShortPrefabName == "mining.pumpjack")
                    return true; // ignore damage on storage from mining quarry
            }
            return null;
        }

        private object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            if (planner == null)
            {
                return null;
            }
            var surveyCrater = target.entity as SurveyCrater;
            if (surveyCrater == null || !surveyCrater.OwnerID.IsSteamId())
            {
                return null;
            }
            var player = planner.GetOwnerPlayer();
            if (player == null)
            {
                return null;
            }
            if (!AreFriends((ulong)player.userID, surveyCrater.OwnerID))
            {
                SendChatMessage(player, "NoDeploy", player.UserIDString);
                return true;
            }
            return null;
        }

        private void CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (player == null || container == null) return;

            if (container.prefabID == OutputHopperPumpID ||
                container.prefabID == OutputHopperQuarryID)  LootQuarryOutput(player, container);
            return;
        }

        void OnLootEntityEnd(BasePlayer player, StorageContainer container)
        {
            if (container.prefabID == FuelStoragePumpID ||
                container.prefabID == FuelStorageQuarryID) LootDieselEngineEnd(player, container);   // fuelstorage for quarry or pumpjack
        }

        void LootQuarryOutput(BasePlayer player, StorageContainer container)
        {
            int hoppercnt = container.inventory.TotalItemAmount();
            PrintToLog($"Player {player.displayName}/{(ulong)player.userID} looting quarry [{PositionToString(container.transform.position)}], {ReportInventory(container)} items in hopper");
            return;
        }

        void LootDieselEngineEnd(BasePlayer player, StorageContainer fueltank)
        {
            var amount = fueltank.inventory.GetAmount(1568388703, true);    // lowgradefuel == -946369541, Diesel == 1568388703
            PrintToLog($"Player {player.displayName}/{(ulong)player.userID} looting fuel in engine at [{PositionToString(fueltank.transform.position)}],  {amount} diesel");
        }


        #endregion Oxide Hooks

        #region Methods

        private int RefillMiningQuarries(bool AddMissing = false)
        {
            var count = 0;
            foreach (var miningQuarry in _miningQuarries)
            {
                if ((miningQuarry == null || miningQuarry.IsDestroyed)) continue;


                if (UpdateAndRefill(miningQuarry)) count++;
            }
            return count;
        }

        private void CheckValidData()
        {
            int removals = 0;
            float minDistance = Math.Max(MatchRadius, _configData.ResourceDepositCheckRadius);
            List<MiningQuarry> quarryList = Pool.Get<List<MiningQuarry>>();

            for (int i = _storedData.quarryDataList.Count - 1; i >= 0; i--)
            {
                bool validData = false;
                quarryList.Clear();
				// Search radius must be >3 even if quarryData position exactly match miningQuarry position
				// don't use MatchRadius for Vis.Entities
                Vis.Entities(_storedData.quarryDataList[i].position, 5f, quarryList, Layers.Mask.Default);
                if (quarryList.Count == 0) PrintToLog($"CheckValidData, No quarry found matching _storedData at {_storedData.quarryDataList[i].position}");
                if (quarryList.Count > 1) PrintToLog($"CheckValidData, multiple quarry found matching _storedData at {_storedData.quarryDataList[i].position}");
                foreach (MiningQuarry miningQuarry in quarryList)
                {
                    if (miningQuarry == null || miningQuarry.IsDestroyed) continue;
                    if (Vector3Ex.Distance2D(_storedData.quarryDataList[i].position, miningQuarry.transform.position) < minDistance)
                    {
                        validData = true;
                        break;
                    }
                }
                if (!validData)
                {
                    _storedData.quarryDataList.RemoveAt(i);
                    removals++;
                }
            }
            if (removals != 0) PrintToLog($"CheckValidData: removing {removals} entrys,  quarrycount:{_miningQuarries.Count}");
            Pool.FreeUnmanaged(ref quarryList);
        }

        private static void CreateResourceDeposit(MiningQuarry miningQuarry, QuarryData quarryData)
        {
            if (quarryData.isLiquid) miningQuarry.canExtractLiquid = true;
            else miningQuarry.canExtractSolid = true;

            miningQuarry._linkedDeposit._resources.Clear();
            foreach (var mineralItem in quarryData.mineralItems)
            {
                var itemDefinition = ItemManager.FindItemDefinition(mineralItem.shortname);
                if (itemDefinition == null) continue;
                miningQuarry._linkedDeposit.Add(itemDefinition, 1f, mineralItem.amount, mineralItem.workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, quarryData.isLiquid);
            }
            miningQuarry.SendNetworkUpdateImmediate();
        }

        private static void CreateResourceDeposit(ResourceDepositManager.ResourceDeposit deposit, QuarryData quarryData)
        {
            deposit._resources.Clear();
            foreach (var mineralItem in quarryData.mineralItems)
            {
                var itemDefinition = ItemManager.FindItemDefinition(mineralItem.shortname);
                if (itemDefinition == null) continue;               
                deposit.Add(itemDefinition, 1f, mineralItem.amount, mineralItem.workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, quarryData.isLiquid);
            }
        }

        private QuarryData ModifyResourceDeposit(PermissionSettings permissionSettings, Vector3 checkPosition, ulong playerID)
        {
            QuarryData quarryData = null;
            var surveyCraterList = Pool.Get<List<SurveyCrater>>();
            Vis.Entities(checkPosition, 1f, surveyCraterList, Layers.Mask.Default);
            if (surveyCraterList.Count == 0) PrintToLog($"ModifyResourceDeposit, No survey crater found at {checkPosition}");
            if (surveyCraterList.Count > 1) PrintToLog($"More then one survey crater found at {checkPosition} ");
            foreach (var surveyCrater in surveyCraterList)
            {
                if (surveyCrater == null || surveyCrater.IsDestroyed) continue;
                if (_checkedCraters.Contains(surveyCrater.net?.ID.Value ?? 0)) continue;
                if (Random.Range(0f, 100f) < permissionSettings.OilCraterChance)
                {
                    // Set liquid resource
                    var oilCrater = GameManager.server.CreateEntity(PREFAB_CRATER_OIL, surveyCrater.transform.position) as SurveyCrater;
                    if (oilCrater == null) continue;
                    
                    surveyCrater.Kill();
                    oilCrater.Spawn();
                    _checkedCraters.Add(oilCrater.net?.ID.Value ?? 0);
                    
                    var deposit = ResourceDepositManager.GetOrCreate(oilCrater.transform.position);
                    if (deposit != null)
                    {
                        oilCrater.OwnerID = playerID;
                        deposit._resources.Clear();

                        var mineralItems = permissionSettings.PumpJack.RefillResourceDeposit(deposit);
                        _activeCraters.Add(quarryData = new QuarryData
                            {
                                position = oilCrater.transform.position,
                                isLiquid = permissionSettings.PumpJack.IsLiquid,
                                mineralItems = mineralItems
                            });
                    }
                    
                }
                else if (Random.Range(0f, 100f) < permissionSettings.Quarry.ModifyChance)
                {
                    // Set custom mineral resources
                    _checkedCraters.Add(surveyCrater.net?.ID.Value ?? 0);
                    var deposit = ResourceDepositManager.GetOrCreate(surveyCrater.transform.position);
                    if (deposit != null)
                    {
                        surveyCrater.OwnerID = playerID;
                        deposit._resources.Clear();

                        var mineralItems = permissionSettings.Quarry.RefillResourceDeposit(deposit);
                        _activeCraters.Add(quarryData = new QuarryData
                        {
                            position = surveyCrater.transform.position,
                            isLiquid = permissionSettings.Quarry.IsLiquid,
                            mineralItems = mineralItems
                        });
                    }

                }
                else
                {
                    // Default FP surveycrater resource
                    _checkedCraters.Add(surveyCrater.net?.ID.Value ?? 0);
                    var deposit = ResourceDepositManager.GetOrCreate(surveyCrater.transform.position);
                    if (deposit != null)
                    {
                        surveyCrater.OwnerID = playerID;

                        var mineralItems = deposit._resources.Select(depositEntry => new MineralItemData
                        {
                            amount = Random.Range(50000, 100000),
                            shortname = depositEntry.type.shortname,
                            workNeeded = depositEntry.workNeeded
                        }).ToList();

                        _activeCraters.Add(quarryData = new QuarryData
                        {
                            position = surveyCrater.transform.position,
                            isLiquid = deposit._resources[0].isLiquid,
                            mineralItems = mineralItems
                        });
                    }
                }
            }
            Pool.FreeUnmanaged(ref surveyCraterList);
            
            return quarryData;
        }

      
        private void CopyResourceDepositInfo(PermissionSettings permissionSettings, Vector3 checkPosition, ulong playerID, QuarryData crater)
        {
            var surveyCraterList = Pool.Get<List<SurveyCrater>>();
            Vis.Entities(checkPosition, 1f, surveyCraterList, Layers.Mask.Default);
            if (surveyCraterList.Count == 0) PrintToLog($"CopyResource, No survey crater found at {checkPosition}");
            if (surveyCraterList.Count > 1) PrintToLog("CopyResource, More then one survey crater found at one spot ");
            foreach (var surveyCrater in surveyCraterList)
            {
                if (surveyCrater == null || surveyCrater.IsDestroyed) continue;
                if (_checkedCraters.Contains(surveyCrater.net?.ID.Value ?? 0)) continue;
                SurveyCrater newsurveyCrater;

                if (crater.isLiquid)
                {
                    surveyCrater.Kill();
                    newsurveyCrater = GameManager.server.CreateEntity(PREFAB_CRATER_OIL, surveyCrater.transform.position) as SurveyCrater;
                    if (newsurveyCrater == null) continue;
                    newsurveyCrater.Spawn();
                }
                else newsurveyCrater = surveyCrater;

                _checkedCraters.Add(newsurveyCrater.net?.ID.Value ?? 0);
                    
                var deposit = ResourceDepositManager.GetOrCreate(newsurveyCrater.transform.position);
                if (deposit != null)
                {
                    newsurveyCrater.OwnerID = playerID;
                    deposit._resources.Clear();                    
                    CreateResourceDeposit(deposit, crater);
                }
                newsurveyCrater.SendNetworkUpdateImmediate();
            }
            
            Pool.FreeUnmanaged(ref surveyCraterList);
        }


        QuarryData findInactiveCraterData(SurveyCharge surveycharge)
        {
            float minDistance = Math.Max(MatchRadius, _configData.ResourceDepositCheckRadius);
            QuarryData targetcrater = null;
            foreach (var crater in _activeCraters)
            {
                var distance = Vector3Ex.Distance2D(crater.position, surveycharge.transform.position);
                if (distance < minDistance)
                {
                    minDistance = distance;
                    targetcrater = crater;                    
                }
            }

            if (targetcrater == null)
            {
                foreach (var crater in _storedData.quarryDataList)
                {
                    var distance = Vector3Ex.Distance2D(crater.position, surveycharge.transform.position);
                    if (distance < minDistance)
                    {
                        minDistance = distance;
                        targetcrater = crater;
                    }
                }
            }
            return targetcrater;
        }
        
        string ReportInventory(StorageContainer storage)
        {
            StringBuilder Report = Pool.Get<StringBuilder>();
            try
            {
                Report.Append(" [");
                int itemcount;
                int count = 0;
                foreach (var itemstr in _configData.ReportItems)
                {
                    Item item = storage.inventory.FindItemByItemName(itemstr);
                    if (item == null) continue;
                    itemcount = storage.inventory.GetTotalItemAmount(item, 0, storage.inventory.capacity - 1);
                    if (count != 0) Report.Append(", ");
                    Report.AppendFormat("{1} {0}", item.info.displayName.english, itemcount.ToString());
                    count++;
                }
                if (count == 0) Report.Append("Empty");
                Report.Append("]");
                return Report.ToString();
            }
            finally 
            { 
                Pool.FreeUnmanaged(ref Report);
            }
        }
        

        private PermissionSettings GetPermissionSetting(string UserIDString)
        {
            PermissionSettings permissionSettings = null;
            var priority = 0;
            foreach (var perm in _configData.Permissions)
            {
                if (perm.Priority >= priority && permission.UserHasPermission(UserIDString, perm.Permission))
                {
                    priority = perm.Priority;
                    permissionSettings = perm;
                }
            }
            return permissionSettings;
        }

        #region AreFriends

        private bool AreFriends(ulong playerID, ulong friendID)
        {
            if (playerID == friendID)
            {
                return true;
            }
            if (_configData.Global.UseTeams && SameTeam(playerID, friendID))
            {
                return true;
            }
            if (_configData.Global.UseFriends && HasFriend(playerID, friendID))
            {
                return true;
            }
            if (_configData.Global.UseClans && SameClan(playerID, friendID))
            {
                return true;
            }
            return false;
        }

        private bool HasFriend(ulong playerID, ulong friendID)
        {
            if (!IspluginLoaded(Friends))
            {
                return false;
            }
            return (bool)Friends.Call("HasFriend", playerID, friendID);
        }

        private bool SameTeam(ulong playerID, ulong friendID)
        {
            if (!RelationshipManager.TeamsEnabled())
            {
                return false;
            }
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerID);
            if (playerTeam == null) return false;
            
            if (playerTeam.members.Contains(friendID)) return true;
            return false;
        }

        private bool SameClan(ulong playerID, ulong friendID)
        {
            if (IspluginLoaded(Clans))
            {
                //Clans
                var isMember = Clans.Call("IsClanMember", playerID.ToString(), friendID.ToString());
                if (isMember != null && (bool)isMember) return true;

                //Rust:IO Clans
                var playerClan = Clans.Call("GetClanOf", playerID);
                var friendClan = Clans.Call("GetClanOf", friendID);
                if (playerClan != null && friendClan != null && (string)playerClan == (string)friendClan) return true;
            }

            if (_configData.Global.UseClanTable == true)
            {
                long playerclan = BasePlayer.FindAwakeOrSleeping(playerID.ToString())?.clanId ?? 0;
                IClan clan = null;
                if (playerclan!=0 && (ClanManager.ServerInstance.Backend?.TryGet(playerclan, out clan) ?? false))
                {
                    foreach (ClanMember member in clan.Members)
                    {
                        if (member.SteamId == friendID) return true;
                    }
                }
            }

            return false;
        }

        #endregion AreFriends

        private bool IsAdmin(ulong id) => permission.UserHasPermission(id.ToString(), _configData.PermissionAdmin);

        bool IspluginLoaded(Plugin a) => (a?.IsLoaded ?? false);

        #endregion Methods

        string getDepositInfo(ResourceDepositManager.ResourceDeposit deposit)
        {
            StringBuilder log = Pool.Get<StringBuilder>();
            try
            {
                foreach (var res in deposit._resources)
                {
                    if (res.isLiquid) log.AppendFormat("\nResource: {0,-14}, Rate: {1,5:F2} pM", res.type.shortname, PumpJackSettings.WorkPerMinute / res.workNeeded);
                    else log.AppendFormat("\nResource: {0,-14}, Rate: {1,5:F2} pM", res.type.shortname, QuarrySettings.WorkPerMinute / res.workNeeded);
                }
                return (log.ToString());
            }
            finally
            { 
                Pool.FreeUnmanaged(ref log); 
            }
        }

        string getDepositInfo(QuarryData deposit)
        {
            StringBuilder log = Pool.Get<StringBuilder>();
            try
            {
                foreach (var res in deposit.mineralItems)
                {
                    if (deposit.isLiquid) log.AppendFormat("\nResource: {0,-14}, Rate: {1,5:F2} pM", res.shortname, PumpJackSettings.WorkPerMinute / res.workNeeded);
                    else log.AppendFormat("\nResource: {0,-14}, Rate: {1,5:F2} pM", res.shortname, QuarrySettings.WorkPerMinute / res.workNeeded);
                }
                return (log.ToString());
            }
            finally
            {
                Pool.FreeUnmanaged(ref log);
            }
        }

        #region Commands

        private void CCmdRefresh(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;

            var count = RefillMiningQuarries(true);

            if (player != null) SendChatMessage(player, "Refreshed {0} of {1} quarry resources.", count, _miningQuarries.Count);
            PrintToLog($"Refreshed {count} of {_miningQuarries.Count} quarry resources.");
        }
        
        private void CCmdResetDeposit(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if (player == null) return;
            if (!player.IsAdmin &&  !IsAdmin((ulong)player.userID)) return;

            _storedData.quarryDataList.Clear();
            var count = RefillMiningQuarries(true);

            if (player != null) SendChatMessage(player, "Reset resource deposit of {0} quarry.", _miningQuarries.Count);
            else Puts($"Reset resource deposit of {_miningQuarries.Count} quarry.");
        }

        private void CCmdInfo(IPlayer iplayer, string command, string[] args)
        {
            if (iplayer.Id == "server_console") return;

            var player = iplayer.Object as BasePlayer;
            if (player == null) return;

            int count = 0;
            int loopcount = 0;
            StringBuilder log = Pool.Get<StringBuilder>();

            foreach (var miningQuarry in _miningQuarries)
            {
                if (miningQuarry == null || miningQuarry.IsDestroyed)
                {
                    continue;
                }
                var WorkPerMinute = 60f / miningQuarry.processRate * miningQuarry.workToAdd;
                if (Vector3Ex.Distance2D(player.transform.position, miningQuarry.transform.position) < PlayerRadius)
                {
                    int index = 0;
                    foreach (var quarryData in _storedData.quarryDataList)
                    {
                        if (quarryData == null)
                        {
                            continue;
                        }
                        if (Vector3Ex.Distance2D(quarryData.position, miningQuarry.transform.position) < MatchRadius)
                        {
                            count++;
                            log.AppendFormat("Datafile contain {0} entry,  Quarry count {1} \n", _storedData.quarryDataList.Count, _miningQuarries.Count);
                            log.AppendFormat("Datafile for Quarry at : {0}\n", PositionToString(quarryData.position));
                            log.Append(getDepositInfo(quarryData));
                        }
                        index++;
                    }

                    log.AppendFormat("\nDeposit info\n");
                    log.Append(getDepositInfo(miningQuarry._linkedDeposit));
                }
                loopcount++;
            }
            SendChatMessage(player, log.ToString());
            SendChatMessage(player, "Tested {0} entry, Found {1} quarry resources in data file.", loopcount, count);
            Pool.FreeUnmanaged(ref log);
            SaveData();
        }

        #endregion Commands

        #region ConfigurationFile

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Settings")]
            public GlobalSettings Global { get; set; } = new GlobalSettings();

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatSettings Chat { get; set; } = new ChatSettings();

            [JsonProperty(PropertyName = "Permission List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<PermissionSettings> Permissions { get; set; } = new List<PermissionSettings>
            {
                new PermissionSettings
                {
                    Permission = "backpumpjack.use",
                    Priority = 0,
                    OilCraterChance = 20f,
                    PumpJack = new PumpJackSettings
                    {
                        AmountMin = 1,
                        AmountMax = 1,
                        AllowDuplication = false,
                        MineralItems = new List<MineralItem>
                        {
                            new MineralItem
                            {
                                ShortName = "crude.oil",
                                Chance = 50f,
                                PmMin = 28.8f,
                                PmMax = 28.8f
                            },
                            new MineralItem
                            {
                                ShortName = "lowgradefuel",
                                Chance = 50f,
                                PmMin = 81.6f,
                                PmMax = 81.6f,
                            }
                        }
                    },
                    Quarry = new QuarrySettings
                    {
                        AmountMin = 1,
                        AmountMax = 2,
                        ModifyChance = 10,
                        AllowDuplication = false,
                        MineralItems = new List<MineralItem>
                        {
                            new MineralItem
                            {
                                ShortName = "stones",
                                Chance = 60f,
                                PmMin = 100f,
                                PmMax = 150f
                            },
                            new MineralItem
                            {
                                ShortName = "metal.ore",
                                Chance = 50f,
                                PmMin = 12f,
                                PmMax = 20f
                            },
                            new MineralItem
                            {
                                ShortName = "sulfur.ore",
                                Chance = 50f,
                                PmMin = 12f,
                                PmMax = 12f
                            },
                            new MineralItem
                            {
                                ShortName = "hq.metal.ore",
                                Chance = 50f,
                                PmMin = 1.0f,
                                PmMax = 1.5f
                            }
                        }
                    }
                },
                new PermissionSettings
                {
                    Permission = "backpumpjack.vip",
                    Priority = 1,
                    OilCraterChance = 40f,
                    PumpJack = new PumpJackSettings
                    {
                        AmountMin = 2,
                        AmountMax = 2,
                        AllowDuplication = false,
                        MineralItems = new List<MineralItem>
                        {
                            new MineralItem
                            {
                                ShortName = "crude.oil",
                                Chance = 50f,
                                PmMin = 38f,
                                PmMax = 38f
                            },
                            new MineralItem
                            {
                                ShortName = "lowgradefuel",
                                Chance = 50f,
                                PmMin = 100f,
                                PmMax = 100f,
                            }
                        }
                    },
                    Quarry = new QuarrySettings
                    {
                        AmountMin = 1,
                        AmountMax = 3,
                        ModifyChance = 50,
                        AllowDuplication = false,
                        MineralItems = new List<MineralItem>
                        {
                            new MineralItem
                            {
                                ShortName = "stones",
                                Chance = 60f,
                                PmMin = 120f,
                                PmMax = 180f
                            },
                            new MineralItem
                            {
                                ShortName = "metal.ore",
                                Chance = 50f,
                                PmMin = 15f,
                                PmMax = 25f
                            },
                            new MineralItem
                            {
                                ShortName = "sulfur.ore",
                                Chance = 50f,
                                PmMin = 15f,
                                PmMax = 15f
                            },
                            new MineralItem
                            {
                                ShortName = "hq.metal.ore",
                                Chance = 50f,
                                PmMin = 1.5f,
                                PmMax = 2f
                            }
                        }
                    }
                }
            };

            // Static quarry override
            [JsonProperty(PropertyName = "Static quarry settings", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, StaticQuarrySettings> StaticQuarryType { get; set; } = new Dictionary<string, StaticQuarrySettings>
            {
                {"Stone",
                    new StaticQuarrySettings
                    {
                        MineralItems = new List<StaticMineralItem>
                        {
                            new StaticMineralItem
                            {
                                ShortName = "stones",
                                pM = 2500f
                            },
                            new StaticMineralItem
                            {
                                ShortName = "metal.ore",
                                pM = 500f
                            }
                        }
                    }
                },
                {"HQM",
                    new StaticQuarrySettings
                    {
                        MineralItems = new List<StaticMineralItem>
                        {
                            new StaticMineralItem
                            {
                                ShortName = "hq.metal.ore",
                                pM = 25f
                            }
                        }
                    }
                },
                { "Sulfur",
                    new StaticQuarrySettings
                    {
                        MineralItems = new List<StaticMineralItem>
                        {
                            new StaticMineralItem
                            {
                                ShortName = "sulfur.ore",
                                pM = 500f
                            }
                        }
                    }
                },
                { "Oil",
                    new StaticQuarrySettings
                    {
                        MineralItems = new List<StaticMineralItem>
                        {
                            new StaticMineralItem
                            {
                                ShortName = "crude.oil",
                                pM = 30f
                            },
                            new StaticMineralItem
                            {
                                ShortName = "lowgradefuel",
                                pM = 85f,
                            }
                        }
                    }
                }
            };


            [JsonProperty(PropertyName = "Apply patch for mining rates for more precise pM config params")]
            public bool ApplyPatchForMiningRates = false;

            [JsonProperty(PropertyName = "Patch for ladder flyhack")]
            public bool PatchLadder = true;

            [JsonProperty(PropertyName = "Patch for light signal when quarry is running")]
            public bool PatchLightSignal = true;

            [JsonProperty(PropertyName = "Maximum stack size for diesel engine (-1 to disable function)")]
            public int DieselFuelMaxStackSize = -1;

            [JsonProperty(PropertyName = "Number of slots for diesel storage (-1 to disable function)")]
            public int FuelSlots = -1;

            [JsonProperty(PropertyName = "Number of slots for output storage (-1 to disable function)")]
            public int HopperSlots = -1;

            [JsonProperty(PropertyName = "Time per barrel of diesel in second (-1 to disable function, default time 125 sec)")]
            public int TimePerBarrel = -1;

            [JsonProperty(PropertyName = "Enable static quarry resource modifier")]
            public bool StaticQuarryModifier = false;

            [JsonProperty(PropertyName = "refill command name")]
            public string CommandRefill = "backpumpjack.refill";

            [JsonProperty(PropertyName = "Info command name")]
            public string CommandInfo = "backpumpjack.info";

            [JsonProperty(PropertyName = "Reset resource deposit command name")]
            public string CommandResetDeposits = "backpumpjack.reset";

            [JsonProperty(PropertyName = "Search radius for past resource deposit allocation (use 0.0 to disable)")]
            public float ResourceDepositCheckRadius = 0f;

            [JsonProperty(PropertyName = "Items in report list", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] ReportItems = { "stones", "metal.ore", "metal.fragments", "hq.metal.ore", "metal.refined", "sulfur.ore", "sulfur", "lowgradefuel", "crude.oil" };

            [JsonProperty(PropertyName = "Permission Admin")]
            public string PermissionAdmin { get; set; } = "backpumpjack.admin";

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber Version { get; set; }
        }

        private class GlobalSettings
        {
            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams { get; set; } = true;

            [JsonProperty(PropertyName = "Use Friends")]
            public bool UseFriends { get; set; } = true;

            [JsonProperty(PropertyName = "Use Clans")]
            public bool UseClans { get; set; } = false;

            [JsonProperty(PropertyName = "Use clan table")]
            public bool UseClanTable { get; set; } = false;

            [JsonProperty("Use Discord hook")]
            public bool Discordena = false;

            [JsonProperty("Use Discord timestamp")]
            public bool UseDiscordTimestamp = true;

            [JsonProperty("Discord hook url")]
            public string DiscordHookUrl = "";

            [JsonProperty(PropertyName = "Use Notify plugin")]
            public bool useNotify = false;

            [JsonProperty(PropertyName = "Debug")]
            public bool Debug = false;

            [JsonProperty(PropertyName = "Log to file")]
            public bool LogToFile = false;

            [JsonProperty(PropertyName = "Block damage another player's survey crater")]
            public bool CantDamage { get; set; } = true;

            [JsonProperty(PropertyName = "Block deploy a quarry on another player's survey crater")]
            public bool CantDeploy { get; set; } = true;
        }

        private class ChatSettings
        {
            [JsonProperty(PropertyName = "Chat Prefix")]
            public string Prefix { get; set; } = "<color=#00FFFF>[BackPumpJack]</color>: ";

            [JsonProperty(PropertyName = "Chat SteamID Icon")]
            public ulong SteamIdIcon { get; set; } = 0;
        }

        private class PermissionSettings
        {
            [JsonProperty(PropertyName = "Permission")]
            public string Permission { get; set; }

            [JsonProperty(PropertyName = "Priority")]
            public int Priority { get; set; }

            [JsonProperty(PropertyName = "Oil Crater Chance")]
            public float OilCraterChance { get; set; }

            [JsonProperty(PropertyName = "Oil Crater Settings")]
            public PumpJackSettings PumpJack { get; set; } = new PumpJackSettings();

            [JsonProperty(PropertyName = "Normal Crater Settings")]
            public QuarrySettings Quarry { get; set; } = new QuarrySettings();
        }

        private abstract class MiningSettings
        {
            [JsonProperty(PropertyName = "Minimum Mineral Amount")]
            public int AmountMin { get; set; }

            [JsonProperty(PropertyName = "Maximum Mineral Amount")]
            public int AmountMax { get; set; }

            [JsonProperty(PropertyName = "Allow Duplication Of Mineral Item")]
            public bool AllowDuplication { get; set; }

            [JsonProperty(PropertyName = "Mineral Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<MineralItem> MineralItems { get; set; } = new List<MineralItem>();

            [JsonIgnore]
            public abstract bool IsLiquid { get; }

            public abstract float GetWorkPerMinute();

            public List<MineralItemData> RefillResourceDeposit(ResourceDepositManager.ResourceDeposit deposit)
            {
                var amountsRemaining = Random.Range(AmountMin, AmountMax + 1);
                var mineralItems = new List<MineralItemData>();
                if (deposit == null) return mineralItems;
                if (MineralItems.Count == 0) return mineralItems;               

                
                for (var i = 0; i < 200; i++)
                {
                    if (amountsRemaining <= 0)
                    {
                        break;
                    }
                    var mineralItem = MineralItems.GetRandom();
                    if (mineralItem != null)
                    {
                        if (!AllowDuplication && deposit._resources.Any(x => x.type.shortname == mineralItem.ShortName))
                        {
                            continue;
                        }
                        if (Random.Range(0f, 100f) < mineralItem.Chance)
                        {
                            var itemDef = ItemManager.FindItemDefinition(mineralItem.ShortName);
                            if (itemDef != null)
                            {
                                var amount = Random.Range(5000000, 10000000);
                                var workNeeded = GetWorkPerMinute() / Random.Range(mineralItem.PmMin, mineralItem.PmMax);
                                deposit.Add(itemDef, 1, amount, workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, IsLiquid);
                                mineralItems.Add(new MineralItemData
                                {
                                    amount = amount,
                                    shortname = itemDef.shortname,
                                    workNeeded = workNeeded
                                });
                            }
                            amountsRemaining--;
                        }
                    }
                }
                return mineralItems;
            }
        }

        private class QuarrySettings : MiningSettings
        {
            [JsonProperty(PropertyName = "Modify Chance (If not modified, use default mineral)", Order = -1)]
            public float ModifyChance { get; set; }

            public static float WorkPerMinute { get; set; }
            public override bool IsLiquid => false;
            public override float GetWorkPerMinute() => WorkPerMinute;
        }

        private class PumpJackSettings : MiningSettings
        {
            public static float WorkPerMinute { get; set; }
            public override bool IsLiquid => true;
            public override float GetWorkPerMinute() => WorkPerMinute;
        }

        private class MineralItem
        {
            [JsonProperty(PropertyName = "Mineral Item Short Name")]
            public string ShortName { get; set; }

            [JsonProperty(PropertyName = "Chance")]
            public float Chance { get; set; }

            [JsonProperty(PropertyName = "Minimum pM")]
            public float PmMin { get; set; }

            [JsonProperty(PropertyName = "Maximum pM")]
            public float PmMax { get; set; }
        }

        private class StaticQuarrySettings
        {
            [JsonProperty(PropertyName = "Mineral Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<StaticMineralItem> MineralItems { get; set; } = new List<StaticMineralItem>();

            public void RefillResourceDeposit(ResourceDepositManager.ResourceDeposit deposit, float WorkPerMinute, bool IsLiquid = false)
            {
                if (deposit == null)
                {
                    _instance.PrintError("Static quarry refillResourceDeposit  Null deposit");
                    return;
                }
                for (var i = 0; i < MineralItems.Count; i++)
                {
                    var mineralItem = MineralItems[i];
                    if (mineralItem.pM < 10f) _instance.PrintToLog($"Item {mineralItem.ShortName} minimum production is 10 pM");

                    var itemDef = ItemManager.FindItemDefinition(mineralItem.ShortName);
                    if (itemDef != null)
                    {
                        var amount = 1000;
                        var workNeeded = WorkPerMinute / Math.Max(mineralItem.pM, 10f);
                        deposit.Add(itemDef, 1, amount, workNeeded, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, IsLiquid);
                    }
                    else _instance.PrintToLog("Static quarry refill, Item definition not found, check config syntax of Items");
                }
                return;
            }
        }


        private class StaticMineralItem
        {
            [JsonProperty(PropertyName = "Mineral Item Short Name")]
            public string ShortName { get; set; }

            [JsonProperty(PropertyName = "Resource per minutes (pM)")]
            public float pM { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted or missing. \n{ex}");
                LoadDefaultConfig();
            }

            foreach (var RessourcePermission in _configData.Permissions)
            {
                if (RessourcePermission.OilCraterChance != 0 && RessourcePermission.PumpJack.AmountMin == 0)
                    PrintWarning($"Warning: {RessourcePermission.Permission} Oil Crater Settings, AmountMin is zero");

                if (RessourcePermission.OilCraterChance != 0 && RessourcePermission.PumpJack.AmountMax > RessourcePermission.PumpJack.MineralItems.Count)
                    PrintWarning($"Warning: {RessourcePermission.Permission} Oil Crater Settings, AmountMax ({RessourcePermission.PumpJack.AmountMax}) larger then possible resource ({RessourcePermission.PumpJack.MineralItems.Count})");

                if (RessourcePermission.Quarry.ModifyChance != 0 && RessourcePermission.Quarry.AmountMin == 0)
                    PrintWarning($"Warning: {RessourcePermission.Permission} Normal Crater Settings, Chance AmountMin is zero");

                if (RessourcePermission.Quarry.ModifyChance != 0 && RessourcePermission.Quarry.AmountMax > RessourcePermission.Quarry.MineralItems.Count)
                    PrintWarning($"Warning: {RessourcePermission.Permission} Normal Crater Settings, AmountMax ({RessourcePermission.Quarry.AmountMax}) larger then possible resource  ({RessourcePermission.Quarry.MineralItems.Count})");

                if (RessourcePermission.Quarry.MineralItems.Count == 0)
                    PrintWarning($"Warning: {RessourcePermission.Permission} Mineral Item list is empty");

                if (RessourcePermission.Quarry.AmountMin > RessourcePermission.Quarry.AmountMax)
                    PrintWarning($"Warning: {RessourcePermission.Permission} AmountMin can not be larger ther AmountMax for Quarry");

                if (RessourcePermission.PumpJack.AmountMin > RessourcePermission.PumpJack.AmountMax)
                    PrintWarning($"Warning: {RessourcePermission.Permission} AmountMin can not be larger ther AmountMax for Pumpjack");

            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
            _configData.Version = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_configData);
        }

        private void UpdateConfigValues()
        {
            if (_configData.Version < Version)
            {
                if (_configData.Version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat Settings", "Chat Prefix") && GetConfigValue(out prefixColor, "Chat Settings", "Chat Prefix Color"))
                    {
                        _configData.Chat.Prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }
                }
                _configData.Version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue == null)
            {
                value = default(T);
                return false;
            }
            value = Config.ConvertValue<T>(configValue);
            return true;
        }

        #endregion ConfigurationFile

        #region DataFile

        private StoredData _storedData;

        private class StoredData
        {
            public readonly List<QuarryData> quarryDataList = new List<QuarryData>();
        }

        private class QuarryData
        {
            public Vector3 position;
            public bool isLiquid;
            public List<MineralItemData> mineralItems = new List<MineralItemData>();
        }

        private class MineralItemData
        {
            public string shortname;
            public int amount;
            public float workNeeded;
        }

        private void LoadData()
        {
            try
            {
                _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                PrintError("Data file did not load properly or is missing.");
                _storedData = null;
            }
            if (_storedData == null)
            {
                ClearData();
            }
        }

        private void ClearData()
        {
            _storedData = new StoredData();
            SaveData();
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);
        }


        #endregion DataFile

        #region LanguageFile

        private void PrintToLog(string message)
        {
            if (_configData.Global.Debug)
                UnityEngine.Debug.Log($"[{_instance.Name}] [{DateTime.Now.ToString("h:mm tt")}]{Platform} {message}");

            if (_configData.Global.LogToFile)
               LogToFile(TraceFile, $"[{DateTime.Now.ToString("h:mm tt")}]{Platform} {message}", this);

            if (_configData.Global.Discordena)
                PrintToDiscord(message);
        }


        private void BroadcastMessage(string msg, params object[] args)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                SendChatMessage(player, msg, args);
            }
        }

        public void SendChatMessage(BasePlayer player, string msg, params object[] args)
        {
            for (int i = 0; i < args.Length; i++)
            {
                if (args[i] is string) args[i] = (object)Lang(args[i] as string, player.UserIDString);
            }

            if (_configData.Global.useNotify && IspluginLoaded(Notify))
            {
                Notify.Call("SendNotify", player, 0, Lang(msg, player.UserIDString, args));
            }
            else
            {
                player.ChatMessage(Lang(msg, player.UserIDString, args));
            }
        }

        private void PrintToDiscord(string message, double seconds = 0)
        {
            if (_discord == null) return;

            if (_discord.MsgCooldown <= DateTime.Now.ToBinary())
            {
                _discord.MsgCooldown = DateTime.Now.AddSeconds(seconds).ToBinary();

                long unixTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
                if (_configData.Global.UseDiscordTimestamp)
                    _discord.SendTextMessage($"[<t:{unixTime}:t>]{Platform} {message}");
                else
                    _discord.SendTextMessage($"[{DateTime.Now.ToString("h:mm tt")}]{Platform} {message}");
            }
        }

        private string PositionToString(Vector3 position) => MapHelper.PositionToString(position);

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoDamage"] = "You can't damage another player's survey crater.",
                ["NoDeploy"] = "You can't deploy a quarry on another player's survey crater."
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoDamage"] = "",
                ["NoDeploy"] = ""
            }, this, "zh-CN");
        }

        #endregion LanguageFile


        #region statedetector

        const string _lampPrefab = "assets/prefabs/misc/permstore/industriallight/industrial.wall.lamp.green.deployed.prefab";
        const string _ladderprefab = "assets/prefabs/building/ladder.wall.wood/ladder.wooden.wall.prefab";


        // This component adds a method to evaluate if quarry is stopped from fuel or full output 
        public class QuarryStateDetector : MonoBehaviour
        {
            public MiningQuarry quarry;
            bool state;

            SimpleLight lamp1 = null;
            SimpleLight lamp2 = null;
            BaseLadder ladder1 = null;
            BaseLadder ladder2 = null;


            Vector3 QuarryLampPos1 = new Vector3(2.8f, 9.4f, 2.2f);
            Vector3 QuarryLampPos2 = new Vector3(2.8f, 9.4f, -2.0f);
            Vector3 PumpLampPos1 = new Vector3(-3.8f, 8.5f, 1.37f);
            Vector3 PumpLampPos2 = new Vector3(-3.8f, 8.5f, -1.37f);

            Vector3 LampRotation1 = new Vector3(0.0f, 0.0f, 0.0f);
            Vector3 LampRotation2 = new Vector3(0.0f, 180.0f, 0.0f);


            Vector3 LadderPosition1 = new Vector3(1.6f, 8.0f, -2.3f);
            Vector3 LadderPosition2 = new Vector3(1.6f, 4.8f, -2.6f);

            Vector3 LadderRotation = new Vector3(-5.0f, 180.0f, 0.0f);

            void Awake()
            {
                quarry = GetComponent<MiningQuarry>();
                state = quarry.IsEngineOn();

                if (quarry.ShortPrefabName == "mining_quarry")
                {
                    if (_instance._configData.PatchLadder)
                    {
                        ladder1 = GameManager.server.CreateEntity(_ladderprefab, quarry.transform.position, new Quaternion(), true) as BaseLadder;
                        if (ladder1 != null)
                        {
                            ladder1.Spawn();
                            ladder1.pickup.enabled = false;
                            ladder1.SetParent(quarry);
                            ladder1.transform.localPosition = LadderPosition1;
                            ladder1.transform.localEulerAngles = LadderRotation;
                            ladder1.InitializeHealth(10000, 10000);
                            ladder1.EnableSaving(false);
                            RemoveProblemComponents(ladder1);
                            ladder1.SendNetworkUpdateImmediate();
                        }

                        ladder2 = GameManager.server.CreateEntity(_ladderprefab, quarry.transform.position, new Quaternion(), true) as BaseLadder;
                        if (ladder2 != null)
                        {
                            ladder2.Spawn();
                            ladder2.pickup.enabled = false;
                            ladder2.SetParent(quarry);
                            ladder2.transform.localPosition = LadderPosition2;
                            ladder2.transform.localEulerAngles = LadderRotation;
                            ladder2.InitializeHealth(10000, 10000);
                            ladder2.EnableSaving(false);
                            RemoveProblemComponents(ladder2);
                            ladder2.SendNetworkUpdateImmediate();
                        }
                    }
                }

                if (_instance._configData.PatchLightSignal)
                {
                    lamp1 = GameManager.server.CreateEntity(_lampPrefab, quarry.transform.position, new Quaternion(), true) as SimpleLight;
                    if (lamp1 != null)
                    {
                        lamp1.Spawn();
                        lamp1.pickup.enabled = false;
                        lamp1.SetParent(quarry);
                        lamp1.transform.localPosition = (quarry.ShortPrefabName == "mining_quarry") ? QuarryLampPos1 : PumpLampPos1;
                        lamp1.transform.localEulerAngles = LampRotation1;
                        lamp1.InitializeHealth(10000, 10000);
                        HideInputsAndOutputs(lamp1);
                        RemoveProblemComponents(lamp1);
                        lamp1.CancelInvoke(lamp1.DecayTick);
                        lamp1.EnableSaving(false);
                        lamp1.SetFlag(IOEntity.Flags.On, state);
                        lamp1.SendNetworkUpdateImmediate();
                    }

                    lamp2 = GameManager.server.CreateEntity(_lampPrefab, quarry.transform.position, new Quaternion(), true) as SimpleLight;
                    if (lamp2 != null)
                    {
                        lamp2.Spawn();
                        lamp2.pickup.enabled = false;
                        lamp2.SetParent(quarry);
                        lamp2.transform.localPosition = (quarry.ShortPrefabName == "mining_quarry") ? QuarryLampPos2 : PumpLampPos2;
                        lamp2.InitializeHealth(10000, 10000);
                        lamp2.transform.localEulerAngles = LampRotation2;
                        HideInputsAndOutputs(lamp2);
                        RemoveProblemComponents(lamp2);
                        lamp2.CancelInvoke(lamp2.DecayTick);
                        lamp2.EnableSaving(false);
                        lamp2.SetFlag(IOEntity.Flags.On, state);
                        lamp2.SendNetworkUpdateImmediate();
                    }
                }

                // randomize the start of the invoke to avoid server lag if all quarry evaluate at the same time
                var delay = Oxide.Core.Random.Range(0f, 1.0f);
                InvokeRepeating("CheckMiningQuarry", delay, 1.0f);

            }

            void OnDestroy()
            {
                CancelInvoke("CheckMiningQuarry");
            }

            void CheckMiningQuarry()
            {                
                if (!quarry.IsEngineOn() && state)    // switch off
                {
                    lamp1?.SetFlag(IOEntity.Flags.On, false);
                    lamp2?.SetFlag(IOEntity.Flags.On, false);
                    state = false;
                }
                //else if (quarry.engineSwitchPrefab.instance.HasFlag(MiningQuarry.Flags.On) && !state) // switch on
                else if (quarry.engineSwitchPrefab.instance.HasFlag(MiningQuarry.Flags.On) && !state) // switch on
                {
                    lamp1?.SetFlag(IOEntity.Flags.On, true);
                    lamp2?.SetFlag(IOEntity.Flags.On, true);
                    state = true;
                }
            }


            private static void HideInputsAndOutputs(IOEntity ioEntity)
            {
                // Hide the inputs and outputs on the client.
                foreach (var input in ioEntity.inputs)
                    input.type = IOEntity.IOType.Generic;

                foreach (var output in ioEntity.outputs)
                    output.type = IOEntity.IOType.Generic;
            }

            private static void RemoveProblemComponents(BaseEntity entity)
            {
                UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());

                foreach (var collider in entity.GetComponentsInChildren<Collider>())
                {
                    if (!collider.isTrigger) UnityEngine.Object.DestroyImmediate(collider);
                }
            }
        }
        #endregion

        //######################################################
        #region Shared.Components

        private class DiscordComponent : MonoBehaviour
        {
            private const float PostDelay = 2.0f; // set 2 sec min delay between two discord post
            public long MsgCooldown = DateTime.Now.ToBinary();

            private readonly Queue<object> _queue = new Queue<object>();
            private string _url;
            private bool _busy = false;

            public DiscordComponent Configure(string url)
            {
                if (url == null) throw new ArgumentNullException(nameof(url));
                _url = url;

                return this;
            }

            public DiscordComponent SendTextMessage(string message, params object[] args)
            {
                message = args.Length > 0 ? string.Format(message, args) : message;
                return AddQueue(new MessageRequest(message));
            }

            #region Send requests to server

            private DiscordComponent AddQueue(object request)
            {
                _queue.Enqueue(request);

                if (!_busy)
                    StartCoroutine(ProcessQueue());

                return this;
            }

            private IEnumerator ProcessQueue()
            {
                if (_busy) yield break;
                _busy = true;

                while (_queue.Count != 0)
                {
                    var request = _queue.Dequeue();
                    yield return ProcessRequest(request);
                }

                _busy = false;
            }

            private IEnumerator ProcessRequest(object request)
            {
                if (string.IsNullOrEmpty(_url))
                {
                    print("[ERROR] Discord webhook URL wasn't specified");
                    yield break;
                }

                var data = System.Text.Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(request));
                var uh = new UploadHandlerRaw(data) { contentType = "application/json" };
                var www = UnityWebRequest.PostWwwForm(_url, UnityWebRequest.kHttpVerbPOST);
                www.uploadHandler = uh;

                yield return www.SendWebRequest();

                if (www.result == UnityWebRequest.Result.ConnectionError || www.result == UnityWebRequest.Result.ProtocolError)
                    print($"ERROR: {www.error} | {www.downloadHandler?.text}");

                www.Dispose();

                // to avoid spam requests to Discord
                yield return new WaitForSeconds(PostDelay);
            }

            #endregion


            #region Requests
            private class MessageRequest
            {
                [JsonProperty("content")]
                public string Content { get; set; }

                public MessageRequest(string content)
                {
                    if (content == null) throw new ArgumentNullException(nameof(content));
                    Content = content;
                }
            }

            #endregion
        }
        #endregion


    }

}

// --- End of file: BackPumpJack.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-turret-aim ---
// --- Original File Path: B/BetterTurretAim/BetterTurretAim.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Better Turret Aim", "WhiteThunder", "1.0.2")]
    [Description("Improves the speed at which auto turrets aim at their current target.")]
    internal class BetterTurretAim : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        Plugin ImprovedTurretAim;

        private static BetterTurretAim _pluginInstance;

        private const string PermissionUse = "betterturretaim.use";

        private Configuration _pluginConfig;

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginInstance = this;

            permission.RegisterPermission(PermissionUse, this);

            if (!_pluginConfig.RequirePermission)
            {
                Unsubscribe(nameof(OnGroupPermissionGranted));
                Unsubscribe(nameof(OnGroupPermissionRevoked));
                Unsubscribe(nameof(OnUserPermissionGranted));
                Unsubscribe(nameof(OnUserPermissionRevoked));
            }
        }

        private void OnServerInitialized(bool initialBoot)
        {
            if (!initialBoot)
                InitializeAutoTurrets();

            if (ImprovedTurretAim != null)
                LogWarning("Please remove ImprovedTurretAim.cs. The plugin was supposed to be renamed before release but a uMod website issue caused ImprovedTurretAim.cs to be downloaded instead of BetterTurretAim.cs.");
        }

        private void Unload()
        {
            DestroyAimComponents();
            _pluginInstance = null;
        }

        private void OnEntitySpawned(AutoTurret autoTurret) =>
            MaybeImproveAim(autoTurret);

        private void OnGroupPermissionGranted(string group, string perm)
        {
            if (perm != PermissionUse) return;
            OnUsagePermissionChanged();
        }

        private void OnGroupPermissionRevoked(string group, string perm)
        {
            if (perm != PermissionUse) return;
            OnUsagePermissionChanged();
        }

        private void OnUserPermissionGranted(string userId, string perm)
        {
            if (perm != PermissionUse) return;
            OnUsagePermissionChanged(userId);
        }

        private void OnUserPermissionRevoked(string userId, string perm)
        {
            if (perm != PermissionUse) return;
            OnUsagePermissionChanged(userId);
        }

        #endregion

        #region Helper Methods

        private void InitializeAutoTurrets()
        {
            foreach (var autoTurret in BaseNetworkable.serverEntities.OfType<AutoTurret>())
                MaybeImproveAim(autoTurret);
        }

        private bool ImproveAimWasBlocked(AutoTurret autoTurret)
        {
            object hookResult = Interface.CallHook("OnAutoTurretAimImprove", autoTurret);
            return hookResult is bool && (bool)hookResult == false;
        }

        private void OnUsagePermissionChanged(string userIdString = "")
        {
            foreach (var autoTurret in BaseNetworkable.serverEntities.OfType<AutoTurret>())
            {
                var ownerId = autoTurret.OwnerID;

                // If a userId was specified, skip updating any turrets that don't belong to that user
                if (userIdString != string.Empty && userIdString != ownerId.ToString())
                    continue;

                var aimComponent = autoTurret.GetComponent<TurretAimImprover>();
                if (aimComponent == null)
                    MaybeImproveAim(autoTurret);
                else if (ownerId == 0 || !permission.UserHasPermission(userIdString, PermissionUse))
                    UnityEngine.Object.Destroy(aimComponent);
            }
        }

        private void MaybeImproveAim(AutoTurret autoTurret)
        {
            if (autoTurret is NPCAutoTurret)
                return;

            if (_pluginConfig.OnlyVehicles && GetParentVehicle(autoTurret) == null)
                return;

            if (!_pluginConfig.RequirePermission)
            {
                ImproveAiming(autoTurret);
                return;
            }

            var ownerId = autoTurret.OwnerID;
            if (ownerId == 0 || !permission.UserHasPermission(ownerId.ToString(), PermissionUse))
                return;

            ImproveAiming(autoTurret);
        }

        private BaseVehicle GetParentVehicle(BaseEntity entity)
        {
            var parent = entity.GetParentEntity();
            return parent as BaseVehicle ?? (parent as BaseVehicleModule)?.Vehicle;
        }

        private void ImproveAiming(AutoTurret autoTurret)
        {
            if (ImproveAimWasBlocked(autoTurret))
                return;

            var aimComponent = autoTurret.gameObject.AddComponent<TurretAimImprover>();
        }

        private void DestroyAimComponents()
        {
            var aimComponents = UnityEngine.Object.FindObjectsOfType<TurretAimImprover>();
            if (aimComponents != null)
                foreach (var component in aimComponents)
                    UnityEngine.Object.Destroy(component);
        }

        #endregion

        #region Helper Classes

        private class TurretAimImprover : FacepunchBehaviour
        {
            private AutoTurret Turret;

            private void Awake()
            {
                Turret = GetComponent<AutoTurret>();

                var tickInterval = _pluginInstance._pluginConfig.UpdateIntervalSeconds;
                InvokeRandomized(MaybeUpdateAim, UnityEngine.Random.Range(0f, 1f), tickInterval, tickInterval * 0.25f);
            }

            private void MaybeUpdateAim()
            {
                _pluginInstance.TrackStart();

                if (Turret == null ||
                    Turret.GetAttachedWeapon() == null ||
                    !Turret.HasTarget() ||
                    Turret.aimDir == Vector3.zero)
                {
                    _pluginInstance.TrackEnd();
                    return;
                }

                var lookRotation = Quaternion.LookRotation(Turret.aimDir);
                var targetYaw = Quaternion.Euler(0, lookRotation.eulerAngles.y, 0);
                var targetPitch = Quaternion.Euler(lookRotation.eulerAngles.x, 0, 0);

                var gunYaw = Turret.gun_yaw.transform.rotation;
                var gunPitch = Turret.gun_pitch.transform.localRotation;

                var interpolation = _pluginInstance._pluginConfig.Interpolation;

                if (gunYaw != targetYaw)
                    Turret.gun_yaw.transform.rotation = Quaternion.Lerp(gunYaw, targetYaw, interpolation);

                if (gunPitch != targetPitch)
                    Turret.gun_pitch.transform.localRotation = Quaternion.Lerp(gunPitch, targetPitch, interpolation);

                _pluginInstance.TrackEnd();
            }
        }

        #endregion

        #region Configuration

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("RequirePermission")]
            public bool RequirePermission = true;

            [JsonProperty("OnlyVehicles")]
            public bool OnlyVehicles = false;

            [JsonProperty("UpdateIntervalSeconds")]
            public float UpdateIntervalSeconds = 0.015f;

            [JsonProperty("Interpolation")]
            public float Interpolation = 0.5f;
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Boilerplate

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion
    }
}


// --- End of file: BetterTurretAim.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bomb-trucks ---
// --- Original File Path: B/BombTrucks/BombTrucks.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Rust.Modular;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Bomb Trucks", "WhiteThunder", "0.9.0")]
    [Description("Allow players to spawn bomb trucks.")]
    internal class BombTrucks : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin NoEngineParts, NoEscape, SpawnModularCar;

        private const int RfReservedRangeMin = 4760;
        private const int RfReservedRangeMax = 4790;

        private const string DefaultTruckConfigName = "default";

        private const string PermissionSpawnFormat = "bombtrucks.spawn.{0}";
        private const string PermissionGiveBombTruck = "bombtrucks.give";
        private const string PermissionFreeDetonator = "bombtrucks.freedetonator";

        private const string PrefabExplosiveRocket = "assets/prefabs/ammo/rocket/rocket_basic.prefab";
        private const string PrefabRfReceiver = "assets/prefabs/deployable/playerioents/gates/rfreceiver/rfreceiver.prefab";

        private const int DetonatorItemId = 596469572;
        private const int InvalidFrequency = -1;

        private readonly object False = false;

        private readonly Vector3 RfReceiverPosition = new Vector3(0, -0.1f, 0);
        private readonly Quaternion RfReceiverRotation = Quaternion.Euler(0, 180, 0);

        private readonly RFReceiverManager _receiverManager;
        private readonly BombTruckTracker _bombTruckTracker;
        private readonly Dictionary<ulong, float> _dismountTimeByPlayer = new Dictionary<ulong, float>();

        private StoredData _pluginData;
        private Configuration _pluginConfig;
        private ProtectionProperties _immortalProtection;
        private bool _pluginUnloaded;

        public BombTrucks()
        {
            _receiverManager = new RFReceiverManager(this);
            _bombTruckTracker = new BombTruckTracker(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);

            foreach (var truckConfig in _pluginConfig.BombTrucks)
            {
                permission.RegisterPermission(GetSpawnPermission(truckConfig.Name), this);
            }

            permission.RegisterPermission(PermissionGiveBombTruck, this);
            permission.RegisterPermission(PermissionFreeDetonator, this);
        }

        private void OnServerInitialized()
        {
            _immortalProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
            _immortalProtection.name = "BombTrucksProtection";
            _immortalProtection.Add(1);

            VerifyDependencies();
            CleanStaleTruckData();
            InitializeBombTrucks();
        }

        private void Unload()
        {
            UnityEngine.Object.Destroy(_immortalProtection);

            _bombTruckTracker.Unload();

            // This is used to signal coroutines to stop early (simpler than keeping track of them).
            _pluginUnloaded = true;
        }

        private void OnNewSave() => ClearData();

        private void OnEntityDeath(ModularCar car)
        {
            if (IsBombTruck(car) && car.OwnerID != 0)
            {
                DetonateBombTruck(car);
            }
        }

        private void OnEntityMounted(ModularCarSeat seat, BasePlayer player)
        {
            var car = (seat.GetParentEntity() as BaseVehicleModule)?.GetParentEntity() as ModularCar;
            if (car == null || !IsBombTruck(car))
                return;

            if (car.GetFuelSystem() is EntityFuelSystem fuelSystem)
            {
                var fuelContainer = fuelSystem.GetFuelContainer();
                fuelContainer.inventory.AddItem(fuelContainer.allowedItem, fuelContainer.allowedItem.stackable);
            }
        }

        private void OnEntityDismounted(BaseMountable mountable, BasePlayer player)
        {
            _dismountTimeByPlayer[player.userID] = Time.time;
        }

        private object CanLootEntity(BasePlayer player, ModularCarGarage carLift)
        {
            if (!carLift.PlatformIsOccupied)
                return null;

            var car = carLift.carOccupant;
            if (car != null && IsBombTruck(car))
            {
                ChatMessage(player, "Lift.Edit.Error");
                return False;
            }

            return null;
        }

        // This hook is exposed by the deprecated plugin Modular Car Code Locks (CarCodeLocks).
        private object CanDeployCarCodeLock(ModularCar car, BasePlayer player) =>
            CanLockVehicle(car, player);

        private object CanDeployVehicleCodeLock(ModularCar car, BasePlayer player) =>
            CanLockVehicle(car, player);

        private object CanDeployVehicleKeyLock(ModularCar car, BasePlayer player) =>
            CanLockVehicle(car, player);

        private object CanLockVehicle(ModularCar car, BasePlayer player)
        {
            if (!IsBombTruck(car))
                return null;

            if (player != null)
            {
                player.ChatMessage(GetMessage(player.IPlayer, "Lock.Deploy.Error"));
            }

            return False;
        }

        private void OnRfBroadcasterAdded(IRFObject obj, int frequency) =>
            _receiverManager.DetonateFrequency(frequency);

        private void OnRfListenerAdded(IRFObject obj, int frequency)
        {
            var receiver = obj as RFReceiver;
            if (receiver != null)
            {
                var frequency2 = frequency;
                var receiver2 = receiver;

                // Need to delay checking for the car since the receiver is spawned unparented to mitigate rendering bug.
                NextTick(() =>
                {
                    var car = GetReceiverCar(receiver2);
                    if (car == null || !IsBombTruck(car))
                        return;

                    _receiverManager.AddReceiver(frequency2, receiver2);
                });
            }
        }

        private void OnRfListenerRemoved(IRFObject obj, int frequency)
        {
            var receiver = obj as RFReceiver;
            if (receiver == null)
                return;

            var car = GetReceiverCar(receiver);
            if (car == null || !IsBombTruck(car))
                return;

            _receiverManager.RemoveReceiver(frequency, receiver);
        }

        // This hook is exposed by Claim Vehicle Ownership (ClaimVehicle).
        private object OnVehicleUnclaim(BasePlayer player, ModularCar car)
        {
            if (car == null || !IsBombTruck(car))
                return null;

            ChatMessage(player, "Unclaim.Error");
            return False;
        }

        // This hook is exposed by Modular Car Turrets (CarTurrets).
        private object OnCarAutoTurretDeploy(BaseVehicleModule module, BasePlayer player, bool automatedDeployment)
        {
            if (module == null)
                return null;

            var car = module.Vehicle as ModularCar;
            if (car == null || !IsBombTruck(car))
                return null;

            if (player != null && !automatedDeployment)
            {
                ChatMessage(player, "AutoTurret.Deploy.Error");
            }

            return False;
        }

        // This hook is exposed by No Engine Parts (NoEngineParts).
        private object OnEngineLoadoutOverride(EngineStorage engineStorage)
        {
            var car = engineStorage.GetEngineModule()?.Vehicle as ModularCar;
            if (car == null || !IsBombTruck(car))
                return null;

            return False;
        }

        // This hook is exposed by Engine Parts Durability (EnginePartsDurability).
        private object OnEngineDamageMultiplierChange(EngineStorage engineStorage, float desiredMultiplier)
        {
            var car = engineStorage.GetEngineModule()?.Vehicle as ModularCar;
            if (car == null || !IsBombTruck(car))
                return null;

            return False;
        }

        // This hook is exposed by Auto Engine Parts (AutoEngineParts).
        private object OnEngineStorageFill(EngineStorage engineStorage, int enginePartsTier)
        {
            var car = engineStorage.GetEngineModule()?.Vehicle as ModularCar;
            if (car == null || !IsBombTruck(car))
                return null;

            return False;
        }

        #endregion

        #region Commands

        [Command("bombtruck", "bt", "boomer")]
        private void SpawnBombTruckCommand(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer)
                return;

            var basePlayer = player.Object as BasePlayer;
            if (!basePlayer.CanInteract())
                return;

            if (args.Length == 0)
            {
                SubCommand_SpawnBombTruck(player, args);
                return;
            }

            switch (args[0].ToLower())
            {
                case "help":
                    SubCommand_Help(player, args.Skip(1).ToArray());
                    return;

                default:
                    SubCommand_SpawnBombTruck(player, args);
                    return;
            }
        }

        private void SubCommand_Help(IPlayer player, string[] args)
        {
            var allowedTruckConfigs = _pluginConfig.BombTrucks
                .Where(config => permission.UserHasPermission(player.Id, GetSpawnPermission(config.Name)))
                .OrderBy(truckConfig => truckConfig.Name, Comparer<string>.Create(SortTruckNames))
                .ToList();

            if (allowedTruckConfigs.Count == 0)
            {
                ReplyToPlayer(player, "Generic.Error.NoPermission");
                return;
            }

            var messages = new List<string> { GetMessage(player, "Command.Help") };

            messages.AddRange(allowedTruckConfigs.Select(truckConfig =>
            {
                var message = (truckConfig.Name == DefaultTruckConfigName) ?
                    GetMessage(player, "Command.Help.Spawn.Default") :
                    GetMessage(player, "Command.Help.Spawn.Named", truckConfig.Name);

                var limitUsage = GetPlayerData(player.Id).GetTruckCount(truckConfig.Name);
                message += " - " + GetMessage(player, "Command.Help.LimitUsage", limitUsage, truckConfig.SpawnLimit);

                var remainingCooldown = GetPlayerRemainingCooldownSeconds(player.Id, truckConfig);
                if (remainingCooldown > 0)
                    message += " - " + GetMessage(player, "Command.Help.RemainingCooldown", FormatTime(remainingCooldown));

                return message;
            }));

            player.Reply(string.Join("\n", messages));
        }

        private void SubCommand_SpawnBombTruck(IPlayer player, string[] args)
        {
            var truckName = DefaultTruckConfigName;

            if (args.Length > 0)
                truckName = args[0];

            var basePlayer = player.Object as BasePlayer;

            TruckConfig truckConfig;
            if (!VerifyTruckConfigDefined(player, truckName, out truckConfig) ||
                !VerifyHasPermission(player, GetSpawnPermission(truckName)) ||
                !VerifyOffCooldown(player, truckConfig) ||
                !VerifyBelowTruckLimit(player, truckConfig) ||
                !VerifyNotInSafeZone(player, basePlayer) ||
                !VerifyNotBuildingBlocked(player, basePlayer) ||
                !VerifyNotMounted(player, basePlayer) ||
                !VerifyNotRecentlyDismounted(player, basePlayer) ||
                !VerifyOnGround(player, basePlayer) ||
                !VerifyNotParented(player, basePlayer) ||
                !VerifyNotRaidOrCombatBlocked(basePlayer) ||
                SpawnWasBlocked(basePlayer))
                return;

            SpawnBombTruck(basePlayer, truckConfig, shouldTrack: true);
        }

        [Command("givebombtruck")]
        private void GiveBombTruckCommand(IPlayer player, string cmd, string[] args)
        {
            if (!player.IsServer && !VerifyHasPermission(player, PermissionGiveBombTruck))
                return;

            if (args.Length < 1)
            {
                ReplyToPlayer(player, "Command.Give.Error.Syntax");
                return;
            }

            var playerNameOrIdArg = args[0];

            var truckName = DefaultTruckConfigName;
            if (args.Length > 1)
                truckName = args[1];

            var targetPlayer = BasePlayer.Find(playerNameOrIdArg);
            if (targetPlayer == null)
            {
                ReplyToPlayer(player, "Command.Give.Error.PlayerNotFound", playerNameOrIdArg);
                return;
            }

            TruckConfig truckConfig;
            if (!VerifyTruckConfigDefined(player, truckName, out truckConfig))
                return;

            SpawnBombTruck(targetPlayer, truckConfig, shouldTrack: false);
        }

        #endregion

        #region Helper Methods - Command Checks

        private static bool SpawnWasBlocked(BasePlayer player)
        {
            var hookResult = Interface.CallHook("CanSpawnBombTruck", player);
            return hookResult is bool && (bool)hookResult == false;
        }

        private bool VerifyNotRaidOrCombatBlocked(BasePlayer player)
        {
            if (!_pluginConfig.NoEscapeSettings.CanSpawnWhileRaidBlocked && IsRaidBlocked(player))
            {
                ChatMessage(player, "Command.Spawn.Error.RaidBlocked");
                return false;
            }

            if (!_pluginConfig.NoEscapeSettings.CanSpawnWhileCombatBlocked && IsCombatBlocked(player))
            {
                ChatMessage(player, "Command.Spawn.Error.CombatBlocked");
                return false;
            }

            return true;
        }

        private bool IsRaidBlocked(BasePlayer player) =>
            NoEscape != null && (bool)NoEscape.Call("IsRaidBlocked", player);

        private bool IsCombatBlocked(BasePlayer player) =>
            NoEscape != null && (bool)NoEscape.Call("IsCombatBlocked", player);

        private bool VerifyHasPermission(IPlayer player, string perm)
        {
            if (player.HasPermission(perm))
                return true;

            ReplyToPlayer(player, "Generic.Error.NoPermission");
            return false;
        }

        private bool VerifyTruckConfigDefined(IPlayer player, string truckName, out TruckConfig truckConfig)
        {
            truckConfig = GetTruckConfig(truckName);
            if (truckConfig == null)
            {
                ReplyToPlayer(player, "Command.Spawn.Error.NotFound", truckName);
                return false;
            }
            return true;
        }

        private bool VerifyNotBuildingBlocked(IPlayer player, BasePlayer basePlayer)
        {
            if (basePlayer.IsBuildingBlocked())
            {
                ReplyToPlayer(player, "Generic.Error.BuildingBlocked");
                return false;
            }
            return true;
        }

        private bool VerifyNotInSafeZone(IPlayer player, BasePlayer basePlayer)
        {
            if (!basePlayer.InSafeZone())
                return true;

            ReplyToPlayer(player, "Command.Spawn.Error.Generic");
            return false;
        }

        private bool VerifyOffCooldown(IPlayer player, TruckConfig truckConfig)
        {
            var secondsRemaining = GetPlayerRemainingCooldownSeconds(player.Id, truckConfig);
            if (secondsRemaining > 0)
            {
                ReplyToPlayer(player, "Generic.Error.Cooldown", FormatTime(secondsRemaining));
                return false;
            }
            return true;
        }

        private bool VerifyNotMounted(IPlayer player, BasePlayer basePlayer)
        {
            if (basePlayer.isMounted)
            {
                ReplyToPlayer(player, "Command.Spawn.Error.Mounted");
                return false;
            }
            return true;
        }

        private bool VerifyNotRecentlyDismounted(IPlayer player, BasePlayer basePlayer)
        {
            float dismountTime;
            if (_dismountTimeByPlayer.TryGetValue(basePlayer.userID, out dismountTime) && dismountTime + 0.2f > Time.time)
            {
                ReplyToPlayer(player, "Command.Spawn.Error.Generic");
                return false;
            }
            return true;
        }

        private bool VerifyOnGround(IPlayer player, BasePlayer basePlayer)
        {
            if (!basePlayer.IsOnGround())
            {
                ReplyToPlayer(player, "Command.Spawn.Error.NotOnGround");
                return false;
            }
            return true;
        }

        private bool VerifyNotParented(IPlayer player, BasePlayer basePlayer)
        {
            if (basePlayer.HasParent())
            {
                ReplyToPlayer(player, "Command.Spawn.Error.Generic");
                return false;
            }
            return true;
        }

        private bool VerifyBelowTruckLimit(IPlayer player, TruckConfig truckConfig)
        {
            if (GetPlayerData(player.Id).GetTruckCount(truckConfig.Name) >= truckConfig.SpawnLimit)
            {
                ReplyToPlayer(player, "Command.Spawn.Error.TooManyOfType", truckConfig.SpawnLimit);
                return false;
            }
            return true;
        }

        #endregion

        #region Helper Methods - Misc

        private static void DisableEnginePartDamage(ModularCar car)
        {
            foreach (var module in car.AttachedModuleEntities)
            {
                var engineStorage = GetEngineStorage(module);
                if (engineStorage == null)
                    continue;

                engineStorage.internalDamageMultiplier = 0;
            }
        }

        private static EngineStorage GetEngineStorage(BaseVehicleModule module)
        {
            var engineModule = module as VehicleModuleEngine;
            if (engineModule == null)
                return null;

            return engineModule.GetContainer() as EngineStorage;
        }

        private static string GetSpawnPermission(string truckName) =>
            string.Format(PermissionSpawnFormat, truckName);

        private static int SortTruckNames(string a, string b) =>
            a.ToLower() == DefaultTruckConfigName ? -1 :
            b.ToLower() == DefaultTruckConfigName ? 1 :
            string.Compare(a, b, StringComparison.Ordinal);

        private static ModularCar GetReceiverCar(RFReceiver receiver) =>
            (receiver.GetParentEntity() as VehicleModuleSeating)?.Vehicle as ModularCar;

        private static RFReceiver GetBombTruckReceiver(ModularCar car)
        {
            var driverModule = FindFirstDriverModule(car);
            if (driverModule == null)
                return null;

            return GetChildOfType<RFReceiver>(driverModule);
        }

        private static T GetChildOfType<T>(BaseEntity entity) where T : BaseEntity
        {
            foreach (var child in entity.children)
            {
                var childOfType = child as T;
                if (childOfType != null)
                    return childOfType;
            }
            return null;
        }

        private static void RemoveProblemComponents(BaseEntity entity)
        {
            foreach (var meshCollider in entity.GetComponentsInChildren<MeshCollider>())
                UnityEngine.Object.DestroyImmediate(meshCollider);

            UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());
        }

        private static VehicleModuleSeating FindFirstDriverModule(ModularCar car)
        {
            for (var socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                BaseVehicleModule module;
                if (car.TryGetModuleAt(socketIndex, out module))
                {
                    var seatingModule = module as VehicleModuleSeating;
                    if (seatingModule != null && seatingModule.HasADriverSeat())
                        return seatingModule;
                }
            }
            return null;
        }

        private static bool HasExistingDetonator(ItemContainer container, out int frequency)
        {
            var hasDetonator = false;
            frequency = InvalidFrequency;

            for (var slot = 0; slot < container.capacity; slot++)
            {
                var item = container.GetSlot(slot);
                if (item == null || item.info.itemid != DetonatorItemId)
                    continue;

                hasDetonator = true;

                frequency = item.instanceData?.dataInt ?? InvalidFrequency;
                if (frequency != InvalidFrequency)
                {
                    // Only exit early if the detonator has a valid frequency.
                    // Otherwise, keep searching for detonators with a valid frequency.
                    return true;
                }
            }

            return hasDetonator;
        }

        private static bool HasExistingDetonator(BasePlayer player, out int frequency)
        {
            var hasDetonator = false;
            frequency = -1;

            var activeDetonator = player.GetActiveItem();
            if (activeDetonator != null && activeDetonator.info.itemid == DetonatorItemId)
            {
                frequency = activeDetonator.instanceData?.dataInt ?? -1;
                hasDetonator = true;
            }

            // Only exit early if one of the belt detonators had a valid frequency.
            // Otherwise, keep searching for a detonator with a valid frequency.
            if (hasDetonator && frequency != InvalidFrequency)
                return true;

            if (HasExistingDetonator(player.inventory.containerBelt, out frequency))
                hasDetonator = true;

            if (hasDetonator && frequency != InvalidFrequency)
                return true;

            if (HasExistingDetonator(player.inventory.containerMain, out frequency))
                hasDetonator = true;

            return hasDetonator;
        }

        private static Item CreateRFTransmitter(int frequency)
        {
            var detonatorItem = ItemManager.CreateByItemID(DetonatorItemId);
            if (detonatorItem == null)
                return null;

            if (detonatorItem.instanceData == null)
            {
                detonatorItem.instanceData = new ProtoBuf.Item.InstanceData { ShouldPool = false };
            }

            detonatorItem.instanceData.dataInt = frequency;

            var detonator = detonatorItem.GetHeldEntity() as Detonator;
            if (detonator != null)
                detonator.frequency = frequency;

            return detonatorItem;
        }

        private static int GenerateRandomFrequency()
        {
            var frequency = Core.Random.Range(RFManager.minFreq, RFManager.maxFreq);
            return frequency >= RfReservedRangeMin && frequency <= RfReservedRangeMax
                ? RfReservedRangeMin - 1
                : frequency;
        }

        private static string FormatTime(double seconds) => TimeSpan.FromSeconds(seconds).ToString("g");

        private bool VerifyDependencies()
        {
            if (SpawnModularCar == null)
            {
                LogError("SpawnModularCar is not loaded, get it at https://umod.org");
                return false;
            }

            var requiredVersion = new VersionNumber(5, 0, 1);
            if (SpawnModularCar.Version < requiredVersion)
            {
                LogError($"SpawnModularCar {requiredVersion} or newer is required, get it at https://umod.org");
                return false;
            }

            return true;
        }

        private void SetupReceiver(RFReceiver receiver)
        {
            receiver.pickup.enabled = false;
            receiver.baseProtection = _immortalProtection;
            RemoveProblemComponents(receiver);
        }

        private void InitializeBombTrucks()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var car = entity as ModularCar;
                if (car == null || !IsBombTruck(car))
                    continue;

                _bombTruckTracker.TrackBombTruck(car);

                DisableEnginePartDamage(car);
                var receiver = GetBombTruckReceiver(car);
                if (receiver != null)
                {
                    _receiverManager.AddReceiver(receiver.GetFrequency(), receiver);
                    SetupReceiver(receiver);
                }
            }
        }

        private bool IsBombTruck(ModularCar car) =>
            _pluginData.PlayerData.Any(item => item.Value.BombTrucks.Any(data => data.ID == car.net.ID.Value));

        private ModularCar SpawnBombTruck(BasePlayer player, TruckConfig truckConfig, bool shouldTrack = false)
        {
            if (!VerifyDependencies())
                return null;

            var car = SpawnModularCar.Call("API_SpawnPreset", new Dictionary<string, object>
            {
                ["EnginePartsTier"] = truckConfig.EnginePartsTier,
                ["FuelAmount"] = -1,
                ["Modules"] = truckConfig.Modules
            }, player) as ModularCar;

            if (car == null)
                return null;

            _bombTruckTracker.TrackBombTruck(car);

            if (car.GetFuelSystem() is EntityFuelSystem fuelSystem)
            {
                fuelSystem.GetFuelContainer().SetFlag(BaseEntity.Flags.Locked, true);
            }

            foreach (var module in car.AttachedModuleEntities)
            {
                var engineStorage = GetEngineStorage(module);
                if (engineStorage != null)
                {
                    engineStorage.inventory.SetLocked(true);
                    engineStorage.internalDamageMultiplier = 0;
                }
            }

            var message = GetMessage(player.IPlayer, "Command.Spawn.Success");

            if (truckConfig.AttachRFReceiver)
            {
                int frequency;
                var hasDetonator = HasExistingDetonator(player, out frequency);

                var receiver = AttachRFReceiver(car, frequency);
                if (receiver != null)
                {
                    // Get the current frequency of the RF receiver, in case a new one was generated.
                    frequency = receiver.GetFrequency();

                    if (!hasDetonator && permission.UserHasPermission(player.UserIDString, PermissionFreeDetonator))
                    {
                        var detonatorItem = CreateRFTransmitter(frequency);
                        if (detonatorItem != null)
                            player.GiveItem(detonatorItem);
                    }

                    message += " " + GetMessage(player.IPlayer, "Command.Spawn.Success.Frequency", frequency);
                }
            }

            player.IPlayer.Reply(message);

            if (shouldTrack)
            {
                UpdatePlayerCooldown(player.UserIDString, truckConfig.Name);
            }

            GetPlayerData(player.UserIDString).BombTrucks.Add(new PlayerTruckData
            {
                Name = truckConfig.Name,
                ID = car.net.ID.Value,
                Tracked = shouldTrack
            });

            SaveData();

            if (NoEngineParts != null)
            {
                // Refresh engine stats on next tick to override NoEngineParts.
                // This has to be done on the next tick after the bomb truck id has been registered.
                NextTick(() =>
                {
                    if (car == null || car.IsDestroyed)
                        return;

                    foreach (var module in car.AttachedModuleEntities)
                    {
                        var engineStorage = GetEngineStorage(module);
                        if (engineStorage != null)
                        {
                            engineStorage.RefreshLoadoutData();
                        }
                    }
                });
            }

            return car;
        }

        private RFReceiver AttachRFReceiver(ModularCar car, int frequency = -1)
        {
            var module = FindFirstDriverModule(car);
            if (module == null)
                return null;

            var receiver = GameManager.server.CreateEntity(PrefabRfReceiver, module.transform.TransformPoint(RfReceiverPosition), module.transform.rotation * RfReceiverRotation) as RFReceiver;
            if (receiver == null)
                return null;

            if (frequency == -1)
                frequency = GenerateRandomFrequency();

            receiver.frequency = frequency;

            SetupReceiver(receiver);
            receiver.Spawn();
            receiver.SetParent(module, worldPositionStays: true);

            return receiver;
        }

        private double GetPlayerRemainingCooldownSeconds(string userID, TruckConfig truckConfig)
        {
            var playerCooldowns = GetPlayerData(userID).Cooldowns;
            if (!playerCooldowns.ContainsKey(truckConfig.Name))
                return 0;

            var lastUsed = playerCooldowns[truckConfig.Name];
            var cooldownDuration = truckConfig.CooldownSeconds;
            var currentTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

            return lastUsed + cooldownDuration - currentTime;
        }

        private void UpdatePlayerCooldown(string userID, string truckName) =>
            GetPlayerData(userID).UpdateCooldown(truckName, DateTimeOffset.UtcNow.ToUnixTimeSeconds());

        #endregion

        #region Unity Components

        private class BombTruckComponent : FacepunchBehaviour
        {
            public static BombTruckComponent AddToCar(BombTruckTracker tracker, ModularCar car)
            {
                var component = car.gameObject.AddComponent<BombTruckComponent>();
                component._tracker = tracker;
                component.Car = car;
                component.NetId = car.net.ID;
                component.OwnerId = car.OwnerID;
                return component;
            }

            public ModularCar Car { get; private set; }
            public NetworkableId NetId { get; private set; }
            public ulong OwnerId { get; private set; }
            private BombTruckTracker _tracker;

            private void OnDestroy()
            {
                _tracker.HandleBombTruckDestroyed(this);
            }
        }

        private class BombTruckTracker
        {
            private BombTrucks _plugin;
            private HashSet<Component> _bombTruckComponents = new HashSet<Component>();

            public BombTruckTracker(BombTrucks plugin)
            {
                _plugin = plugin;
            }

            public void TrackBombTruck(ModularCar car)
            {
                _bombTruckComponents.Add(BombTruckComponent.AddToCar(this, car));
            }

            public void HandleBombTruckDestroyed(BombTruckComponent component)
            {
                _bombTruckComponents.Remove(component);

                if (component.Car == null || component.Car.IsDestroyed)
                {
                    _plugin.GetPlayerData(component.OwnerId.ToString()).RemoveTruck(component.NetId.Value);
                    _plugin.SaveData();
                }
            }

            public void Unload()
            {
                foreach (var component in _bombTruckComponents.ToArray())
                {
                    UnityEngine.Object.DestroyImmediate(component);
                }
            }
        }

        #endregion

        #region RF Receiver Manager

        private class RFReceiverManager
        {
            private BombTrucks _plugin;
            private readonly Dictionary<int, List<RFReceiver>> Receivers = new Dictionary<int, List<RFReceiver>>();

            public RFReceiverManager(BombTrucks plugin)
            {
                _plugin = plugin;
            }

            public void AddReceiver(int frequency, RFReceiver receiver)
            {
                List<RFReceiver> receiverList;
                if (Receivers.TryGetValue(frequency, out receiverList))
                {
                    receiverList.Add(receiver);
                }
                else
                {
                    Receivers.Add(frequency, new List<RFReceiver> { receiver });
                }
            }

            public void RemoveReceiver(int frequency, RFReceiver receiver)
            {
                List<RFReceiver> receiverList;
                if (Receivers.TryGetValue(frequency, out receiverList))
                {
                    receiverList.Remove(receiver);
                }
            }

            public void DetonateFrequency(int frequency)
            {
                List<RFReceiver> receiverList;
                if (Receivers.TryGetValue(frequency, out receiverList))
                {
                    for (var i = receiverList.Count - 1; i >= 0; i--)
                    {
                        var receiver = receiverList[i];
                        var car = GetReceiverCar(receiver);
                        if (car != null)
                        {
                            _plugin.DetonateBombTruck(car);
                        }
                    }
                }
            }
        }

        #endregion

        #region Explosions

        private static void FireRocket(BasePlayer attackerPlayer, ulong attackerId, string rocketPrefab, Vector3 origin, Vector3 direction, float time, float damageRadiusMult = 1.0f, float damageMult = 1.0f)
        {
            var rocket = GameManager.server.CreateEntity(rocketPrefab, origin) as TimedExplosive;
            var rocketProjectile = rocket.GetComponent<ServerProjectile>();

            rocketProjectile.gravityModifier = 0;
            rocket.explosionRadius *= damageRadiusMult;
            rocket.timerAmountMin = time;
            rocket.timerAmountMax = time;

            for (var i = 0; i < rocket.damageTypes.Count; i++)
            {
                rocket.damageTypes[i].amount *= damageMult;
            }

            rocket.creatorEntity = attackerPlayer;
            rocket.OwnerID = attackerId;
            rocket.SendMessage("InitializeVelocity", direction);
            rocket.Spawn();
        }

        private void DetonateBombTruck(ModularCar car)
        {
            var playerConfig = GetPlayerData(car.OwnerID.ToString());

            var netID = car.net.ID.Value;
            var truckName = playerConfig.FindTruck(netID)?.Name;
            if (truckName == null)
            {
                LogError("Unable to determine truck name.");
                return;
            }

            var truckConfig = GetTruckConfig(truckName);
            if (truckConfig == null)
            {
                LogError("Unable to detonate '{0}' truck because its configuration is missing.", truckName);
                return;
            }

            // Remove the engine parts.
            foreach (var module in car.AttachedModuleEntities)
            {
                var engineStorage = GetEngineStorage(module);
                if (engineStorage != null)
                {
                    engineStorage.inventory.Kill();
  