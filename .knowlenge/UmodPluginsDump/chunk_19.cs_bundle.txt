trolEnded));
            }

            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnDroneCollisionImpact));
        }

        private void OnServerInitialized()
        {
            if (_pluginConfig.CollisionEffect.Enabled
                && !string.IsNullOrEmpty(_pluginConfig.CollisionEffect.EffectPrefab))
            {
                if (BetterDroneCollision != null)
                {
                    Subscribe(nameof(OnDroneCollisionImpact));
                }
                else
                {
                    Subscribe(nameof(OnEntitySpawned));
                    _usingCustomCollisionListener = true;
                }
            }

            // Delay this in case Drone Hover needs a moment to set the drones to being controlled.
            NextTick(() =>
            {
                foreach (var entity in BaseNetworkable.serverEntities)
                {
                    var drone = entity as Drone;
                    if (drone == null || !IsDroneEligible(drone))
                        continue;

                    if (_pluginConfig.Animation.Enabled)
                        MaybeStartAnimating(drone);

                    if (_usingCustomCollisionListener)
                        drone.GetOrAddComponent<DroneCollisionListener>();
                }
            });
        }

        private void Unload()
        {
            if (_pluginConfig.Animation.Enabled)
            {
                foreach (var deliveryDrone in BaseNetworkable.serverEntities.OfType<DeliveryDrone>().ToArray())
                {
                    if (deliveryDrone != null && deliveryDrone.GetParentEntity() is Drone)
                        deliveryDrone.Kill();
                }
            }

            if (_usingCustomCollisionListener)
                DroneCollisionListener.DestroyAll();

            _pluginConfig = null;
            _pluginInstance = null;
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin == BetterDroneCollision && _usingCustomCollisionListener)
            {
                Unsubscribe(nameof(OnEntitySpawned));
                DroneCollisionListener.DestroyAll();
                _usingCustomCollisionListener = false;

                Subscribe(nameof(OnDroneCollisionImpact));
            }
        }

        private void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string bookmarkName, Drone drone)
        {
            OnDroneControlStarted(drone);
        }

        private void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, Drone drone)
        {
            OnDroneControlEnded(drone);
        }

        private void OnEntitySpawned(Drone drone)
        {
            if (!IsDroneEligible(drone))
                return;

            drone.GetOrAddComponent<DroneCollisionListener>();
        }

        private void OnEntityDeath(Drone drone)
        {
            if (!IsDroneEligible(drone))
                return;

            Effect.server.Run(_pluginConfig.DeathEffect.EffectPrefab, drone.transform.position, Vector3.up);
        }

        // This hook is exposed by plugin: Better Drone Collision (BetterDroneCollision).
        private void OnDroneCollisionImpact(Drone drone, Collision collision)
        {
            ShowCollisionEffect(drone, collision);
        }

        // This hook is exposed by plugin: Ridable Drones (RidableDrones).
        private void OnDroneControlStarted(Drone drone)
        {
            MaybeStartAnimating(drone);
        }

        // This hook is exposed by plugin: Ridable Drones (RidableDrones).
        private void OnDroneControlEnded(Drone drone)
        {
            // Delay in case Drone Hover is going to keep the drone in the controlled state.
            NextTick(() =>
            {
                if (drone == null || drone.IsBeingControlled)
                    return;

                StopAnimating(drone);
            });
        }

        #endregion

        #region API

        private void API_StopAnimating(Drone drone)
        {
            StopAnimating(drone);
        }

        #endregion

        #region Helper Methods

        private static bool AnimateWasBlocked(Drone drone)
        {
            object hookResult = Interface.CallHook("OnDroneAnimationStart", drone);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool CollisionEffectWasBlocked(Drone drone, Collision collision)
        {
            object hookResult = Interface.CallHook("OnDroneCollisionEffect", drone);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool IsDroneEligible(Drone drone) =>
            !(drone is DeliveryDrone);

        private static Drone GetControlledDrone(ComputerStation computerStation) =>
            computerStation.currentlyControllingEnt.Get(serverside: true) as Drone;

        private static T GetChildOfType<T>(BaseEntity entity) where T : BaseEntity
        {
            foreach (var child in entity.children)
            {
                var childOfType = child as T;
                if (childOfType != null)
                    return childOfType;
            }
            return null;
        }

        private void ShowCollisionEffect(Drone drone, Collision collision)
        {
            if (CollisionEffectWasBlocked(drone, collision))
                return;

            var transform = drone.transform;
            var collisionPoint = collision.GetContact(0).point;
            collisionPoint += (transform.position - collisionPoint) * CollisionDistanceFraction;
            Effect.server.Run(_pluginConfig.CollisionEffect.EffectPrefab, collisionPoint, transform.up);
        }

        #endregion

        #region Helper Methods - Animation

        private static DeliveryDrone GetChildDeliveryDrone(Drone drone) =>
            GetChildOfType<DeliveryDrone>(drone);

        private static void SetupDeliveryDrone(DeliveryDrone deliveryDrone)
        {
            deliveryDrone.EnableSaving(false);
            deliveryDrone.EnableGlobalBroadcast(false);

            // Disable delivery drone AI.
            deliveryDrone.CancelInvoke(deliveryDrone.Think);

            // Prevent the Update() method from running.
            deliveryDrone.IsBeingControlled = true;

            // Prevent the FixedUpdate() method from running.
            deliveryDrone.lifestate = BaseCombatEntity.LifeState.Dead;

            // Remove physics.
            UnityEngine.Object.Destroy(deliveryDrone.body);

            if (deliveryDrone._mapMarkerInstance != null)
                deliveryDrone._mapMarkerInstance.Kill();
        }

        private static void StartAnimationg(Drone drone)
        {
            var deliveryDrone = GameManager.server.CreateEntity(DeliveryDronePrefab) as DeliveryDrone;
            if (deliveryDrone == null)
                return;

            deliveryDrone.SetParent(drone);
            deliveryDrone.CancelInvoke(deliveryDrone.Think);
            deliveryDrone.Spawn();
            SetupDeliveryDrone(deliveryDrone);
        }

        private static void MaybeStartAnimating(Drone drone)
        {
            if (!drone.IsBeingControlled)
                return;

            var deliveryDrone = GetChildDeliveryDrone(drone);
            if (deliveryDrone != null)
                return;

            if (AnimateWasBlocked(drone))
                return;

            StartAnimationg(drone);
        }

        private static void StopAnimating(Drone drone)
        {
            var deliveryDrone = GetChildDeliveryDrone(drone);
            if (deliveryDrone == null)
                return;

            deliveryDrone.Kill();
        }

        #endregion

        #region Collision Detection

        private class DroneCollisionListener : EntityComponent<Drone>
        {
            public static void DestroyAll()
            {
                foreach (var entity in BaseNetworkable.serverEntities)
                {
                    var drone = entity as Drone;
                    if (drone == null || !IsDroneEligible(drone))
                        continue;

                    var component = drone.GetComponent<DroneCollisionListener>();
                    if (component == null)
                        continue;

                    DestroyImmediate(component);
                }
            }

            private const float DelayBetweenCollisions = 0.25f;

            private float _nextCollisionFXTime;

            private void OnCollisionEnter(Collision collision)
            {
                var forceMagnitude = collision.impulse.magnitude / Time.fixedDeltaTime;
                if (forceMagnitude < _pluginConfig.CollisionEffect.RequiredMagnitude)
                    return;

                ShowCollisionFX(collision);
            }

            private void ShowCollisionFX(Collision collision)
            {
                if (Time.time < _nextCollisionFXTime)
                    return;

                _pluginInstance.ShowCollisionEffect(baseEntity, collision);
                _nextCollisionFXTime = Time.time + DelayBetweenCollisions;
            }
        }

        #endregion

        #region Configuration

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("Animation")]
            public AnimationSettings Animation = new AnimationSettings();

            [JsonProperty("CollisionEffect")]
            public CollisionSettings CollisionEffect = new CollisionSettings();

            [JsonProperty("DeathEffect")]
            public DeathSettings DeathEffect = new DeathSettings();
        }

        private class AnimationSettings
        {
            [JsonProperty("Enabled")]
            public bool Enabled = true;
        }

        private class CollisionSettings
        {
            [JsonProperty("Enabled")]
            public bool Enabled = true;

            [JsonProperty("RequiredMagnitude")]
            public int RequiredMagnitude = 40;

            [JsonProperty("EffectPrefab")]
            public string EffectPrefab = "assets/content/vehicles/modularcar/carcollisioneffect.prefab";
        }

        private class DeathSettings
        {
            [JsonProperty("Enabled")]
            public bool Enabled = true;

            [JsonProperty("EffectPrefab")]
            public string EffectPrefab = "assets/prefabs/ammo/40mmgrenade/effects/40mm_he_explosion.prefab";
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Boilerplate

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion
    }
}


// --- End of file: DroneEffects.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/diseases ---
// --- Original File Path: D/Diseases/Diseases.cs ---

ï»¿using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Diseases", "mr01sam", "2.1.1")]
	[Description("Players can be inflicted with disease that can be spread to others")]
	public class Diseases : CovalencePlugin
	{
		public static Diseases PLUGIN;

		/* Permissions */
		private const string PermissionUse = "diseases.use";
		private const string PermissionAdmin = "diseases.admin";

		/* Dependencies */
		[PluginReference]
		private Plugin ImageLibrary;

		/* Constants */
		private const float PLAYER_TICK_RATE = 1f;
		private static bool debug = false;

		/* Global data */
		private DiseaseManager diseaseManager;
		private EffectManager effectManager;
		private Dictionary<string, DiseaseStats> diseaseStats;

		#region Oxide Hooks
		void Init()
		{
			PLUGIN = this;
			/* Unsubscribe */
			Unsubscribe(nameof(OnEntityDeath));
			Unsubscribe(nameof(OnPlayerSleep));
			Unsubscribe(nameof(OnPlayerSleepEnded));
			Unsubscribe(nameof(OnItemUse));
			Unsubscribe(nameof(OnEntityTakeDamage));

			/* Init */
			InitCommands();
		}

		void Unload()
		{
			/* Clear effects and UI */
			foreach (BasePlayer player in BasePlayer.activePlayerList)
			{
				effectManager.ClearAllEffects(player);
				HideAllIndicators(player);
			}
		}

		void OnServerInitialized(bool initial)
		{
			/* Load images (if ImageLibrary is installed) */
			LoadImages();

			/* Register perms */
			permission.RegisterPermission(PermissionUse, this);

			/* Init */
			diseaseStats = new Dictionary<string, DiseaseStats>();
			diseaseManager = new DiseaseManager();
			effectManager = new EffectManager();

			/* Load disease files */
			diseaseManager.LoadAllDiseases(() =>
			{
				foreach (BasePlayer player in BasePlayer.activePlayerList)
					RefreshIndicator(player);
			});

			/* Unsubscribe */
			Subscribe(nameof(OnEntityDeath));
			Subscribe(nameof(OnPlayerSleep));
			Subscribe(nameof(OnPlayerSleepEnded));
			Subscribe(nameof(OnItemUse));
			Subscribe(nameof(OnEntityTakeDamage));
		}

		void OnEntityDeath(BasePlayer player, HitInfo info)
		{
			if (player.IsValid())
			{
				foreach (string diseasename in diseaseManager.GetPlayerInfections(player))
				{
					Disease disease = diseaseManager.GetDisease(diseasename);
					if (disease != null)
					{
						bool killedByDisease = WasCauseOfDeath(player, info, disease);
						if (killedByDisease)
						{
							diseaseStats[disease.name].playersKilled.count += 1;
							if (config.BroadcastDeathMessages)
								BasePlayer.activePlayerList.ToList().ForEach(x => x.ChatMessage(Lang("Death", player.UserIDString, player.displayName, Color(disease.name, config.DiseaseNameColor))));
						}
						if (debug)
							PLUGIN.Puts("Died: " + player.displayName + " removing of " + disease.name);

						diseaseStats[disease.name].activeInfected.count -= 1;
						diseaseManager.RemoveInfected(player, disease);
						Interface.CallHook("OnInfectedDeath", player, disease, killedByDisease);
					}
				}
				RefreshIndicator(player);
			}
		}

		object OnPlayerSleep(BasePlayer player)
		{
			if (player.IsValid())
			{
				foreach (string diseasename in diseaseManager.GetPlayerInfections(player))
				{
					diseaseStats[diseasename].sleepersInfected.count += 1;
					diseaseStats[diseasename].activeInfected.count -= 1;
				}
			}
			return null;
		}

		void OnPlayerSleepEnded(BasePlayer player)
		{
			if (debug)
				PLUGIN.Puts("Sleep ended for " + player.displayName);
			if (player.IsValid())
			{
				if (debug)
					PLUGIN.Puts("Is valid: " + player.displayName);
				foreach (string diseasename in diseaseManager.GetPlayerInfections(player))
				{
					Disease disease = diseaseManager.GetDisease(diseasename);
					if (debug)
						PLUGIN.Puts("Has active tick: " + diseaseManager.HasActiveTick(player, disease));
					if (disease != null && diseaseManager.HasActiveTick(player, disease))
					{
						if (diseaseManager.HasImmunity(player, disease))
						{
							if (debug)
								PLUGIN.Puts("Resuming recovery for " + player.displayName + " with " + disease.name);
							DoRecoverTick(player, disease);
						}
						else
						{
							if (debug)
								PLUGIN.Puts("Resuming infection for " + player.displayName + " with " + disease.name);
							DoInfectedTick(player, disease);
						}
						diseaseStats[disease.name].sleepersInfected.count -= 1;
						diseaseStats[disease.name].activeInfected.count += 1;
					}
				}
				RefreshIndicator(player);
			}
		}

		void OnItemUse(Item item, int amountToUse)
		{
			if (item == null) return;

			BasePlayer player = item.GetOwnerPlayer();

			if (!player.IsValid()) return;

			foreach (Disease disease in diseaseManager.LoadedDiseases.Values)
			{
				CureItem ci = diseaseManager.ItemsThatCure.Get(item.info.shortname, disease.name);
				if (ci != null && ci.cureChanceOnConsumption >= UnityEngine.Random.Range(0, 100))
				{
					RecoverPlayer(player, disease, () => {
						diseaseStats[disease.name].timesCuredFromItem.count += 1;
					});
				}

				InfectionItem ii = diseaseManager.ItemsThatInfect.Get(item.info.shortname, disease.name);
				if (ii != null && ii.infectionChanceOnConsumption >= UnityEngine.Random.Range(0, 100))
				{
					InfectPlayer(player, disease, () =>
					{
						diseaseStats[disease.name].infectedFromItem.count += 1;
					});
				}

				TreatmentItem ti = diseaseManager.ItemsThatTreat.Get(item.info.shortname, disease.name);
				if (ti != null)
				{
					TreatPlayer(player, disease, ti.Value(), ti.treatmentDelay, () =>
					{
						diseaseStats[disease.name].timesTreatedFromItem.count += 1;
					});
				}
			}
		}

		object OnEntityTakeDamage(BasePlayer player, HitInfo info)
		{
			if (!player.IsValid() || info == null || info.Initiator == null) return null;

			foreach (Disease disease in diseaseManager.LoadedDiseases.Values)
			{
				if (debug)
					Puts(disease.name);
				SpreaderEntity se = diseaseManager.EntitiesThatInfect.Get(info.Initiator.ShortPrefabName, disease.name);
				if (se != null && (se.shortPrefabName != "player" || !info.IsProjectile()) && se.infectionChanceOnHit >= UnityEngine.Random.Range(0, 100))
				{
					if (debug)
						Puts("Should infect: " + player.displayName + " with " + disease.name);
					InfectPlayer(player, disease, () =>
					{
						diseaseStats[disease.name].infectedFromEntity.count += 1;
					});
				}
			}
			return null;
		}
		#endregion

		#region Helper Functions
		private void LoadImages()
		{
			if (ImageLibrary != null && ImageLibrary.IsLoaded)
			{
				ImageLibrary.Call<bool>("AddImage", "https://i.imgur.com/BODiaSy.png", "DiseaseIndicatorIcon", 0UL);
			}
		}

		private void DoDiseaseTick(Disease disease)
		{
			if (disease.outbreakConditions.enabled)
			{
				timer.In(disease.outbreakConditions.timeInterval, () =>
				{
					/* Attempt outbreak */
					Outbreak(disease);

					/* Continue */
					DoDiseaseTick(disease);
				});
			}
		}

		private void DoInfectedTick(BasePlayer player, Disease disease)
		{
			if (player.IsConnected && player.IsAlive() && player.IsValid() && !player.IsSleeping() && disease != null && diseaseManager.HasDisease(player, disease) && !diseaseManager.HasImmunity(player, disease))
			{
				/* Show symptoms */
				if (debug)
					Puts("Showing symptom for: " + player.displayName);
				DoSymptomDamage(player, disease);
				DoSymptomEffects(player, disease);
				DoSymptomScreenEffects(player, disease);

				/* Spread to other players */
				foreach (BasePlayer entity in NearbyValidPlayers(player.transform.position, disease))
				{
					if (GetSpreadChance(entity, disease) >= UnityEngine.Random.Range(1, 100))
					{
						if (debug)
							Puts("Spread " + disease.name + " from " + player.name + " to " + entity.displayName);
						InfectPlayer(entity, disease, () =>
						{
							diseaseStats[disease.name].infectedFromSpreading.count += 1;
						});
					}
				}

                /* Continue timer */
				int spreadTime = disease.SpreadTime();
				timer.In(spreadTime, () =>
				{
					if (diseaseManager.UpdateInfectedTime(player, disease, spreadTime))
					{
						RecoverPlayer(player, disease);
					}
					else
					{
						DoInfectedTick(player, disease);
					}
				});
			}
			else
			{
				if (debug)
					Puts("Stopped infection tick for: " + player.displayName);
			}
		}

		private void DoRecoverTick(BasePlayer player, Disease disease)
		{
			if (player.IsConnected && player.IsAlive() && player.IsValid() && !player.IsSleeping())
			{
				diseaseManager.SetActiveTick(player, disease, true);
				RefreshIndicator(player);
				timer.In(disease.ImmunityTime(), () =>
				{
					if (player.IsConnected && player.IsAlive() && player.IsValid() && !player.IsSleeping())
					{
						CurePlayer(player, disease);
					}
				});
			}
			else
			{
				if (debug)
					Puts("Stopped recovery tick for: " + player.displayName);
			}
		}

		private List<BaseCombatEntity> NearbyValidPlayers(Vector3 position, Disease disease)
		{
			List<BaseCombatEntity> valid = new List<BaseCombatEntity>();
			List<BasePlayer> nearby = new List<BasePlayer>();
			Vis.Entities(position, disease.spreadDistance, nearby); foreach (BasePlayer entity in nearby)
			{
				if (diseaseManager.CanInfect(entity, disease))
				{
					valid.Add(entity);
				}
			}
			return valid;
		}

		private void InfectPlayer(BasePlayer player, Disease disease, Action callback = null)
		{
			if (Interface.CallHook("OnPlayerInfected", player, disease) != null) return;
			if (diseaseManager.AddInfected(player, disease))
			{
				if (debug)
					Puts("Started tick for: " + player.displayName);
				diseaseManager.SetActiveTick(player, disease, true);
				DoInfectedTick(player, disease);
				RefreshIndicator(player);
				StatusMessage(player, disease, Lang("StatusInfected", player.UserIDString, Color(disease.name, config.DiseaseNameColor)));
				diseaseStats[disease.name].activeInfected.count += 1;
				diseaseStats[disease.name].totalInfected.count += 1; ;
				callback?.Invoke();
			}
		}

		private void RecoverPlayer(BasePlayer player, Disease disease, Action callback = null)
		{
			if (diseaseManager.HasDisease(player, disease) && diseaseManager.SetRecovery(player, disease))
			{
				if (debug)
					Puts("Started recovery for: " + player.displayName);
				diseaseManager.SetActiveTick(player, disease, true);
				DoRecoverTick(player, disease);
				RefreshIndicator(player);
				StatusMessage(player, disease, Lang("StatusRecovered", player.UserIDString, Color(disease.name, config.DiseaseNameColor)));
				callback?.Invoke();
			}
		}

		private int Outbreak(Disease disease, int tries = 1)
		{
			if (Interface.CallHook("OnOutbreak", disease) != null) return 0;

			int infected = 0;
			if (debug)
				Puts("Attempting outbreak for " + disease.name);

			List<BasePlayer> activePlayerList = BasePlayer.activePlayerList.ToList().Where(p => diseaseManager.CanInfect(p, disease)).ToList();
			if (debug)
				Puts("Valid players: " + activePlayerList.Count);
			if (activePlayerList.Count > 0)
			{
				List<BasePlayer> filteredList = activePlayerList.ToArray().ToList(); // Make a copy
				foreach (StatFilter filter in disease.outbreakConditions.statFilters)
				{
					filteredList = filteredList.Where(p => CompareStat(p, filter.stat, filter.minValue, (x, y) => { return x >= y; }) && CompareStat(p, filter.stat, filter.maxValue, (x, y) => { return x <= y; })).ToList();
				}
				if (debug)
					Puts("Filters players: " + filteredList.Count);

				for (int i = 0; i < tries; i++)
				{
					if (filteredList.Count > 0)
					{
						BasePlayer randomPlayer = filteredList[UnityEngine.Random.Range(0, filteredList.Count - 1)];
						if (disease.outbreakConditions.outbreakChance >= UnityEngine.Random.Range(0, 100))
						{
							InfectPlayer(randomPlayer, disease);
							infected++;
							filteredList.Remove(randomPlayer);
						}
					}
				}
				diseaseStats[disease.name].infectedFromOutbreak.count += infected;
			}
			diseaseStats[disease.name].numOutbreaks.count += 1; ;
			if (infected > 0)
			{
				if (config.BroadcastOutbreaks)
					BasePlayer.activePlayerList.ToList().ForEach(x => x.ChatMessage(Lang("StatusOutbreak", x.UserIDString, Color(disease.name, config.DiseaseNameColor))));
			}
			return infected;
		}

		private void CurePlayer(BasePlayer player, Disease disease, Action callback = null)
		{
			if (Interface.CallHook("OnPlayerCured", player, disease) != null) return;
			if (diseaseManager.RemoveInfected(player, disease))
			{
				if (debug)
					Puts("Cured: " + player.displayName + " of " + disease.name);
				RefreshIndicator(player);
				diseaseManager.SetActiveTick(player, disease, false);
				StatusMessage(player, disease, Lang("StatusCured", player.UserIDString, Color(disease.name, config.DiseaseNameColor)));
				diseaseStats[disease.name].activeInfected.count -= 1;
				callback?.Invoke();
			}
		}

		private void TreatPlayer(BasePlayer player, Disease disease, int amount, int delay, Action callback = null)
		{
			if (Interface.CallHook("OnPlayerTreated", player, disease) != null) return;
			if (diseaseManager.HasDisease(player, disease) && !diseaseManager.HasTreatment(player, disease) && !diseaseManager.HasImmunity(player, disease))
			{
				if (debug)
					Puts("Treated: " + player.displayName + " of " + disease.name + " for " + amount);
				diseaseManager.SetTreatment(player, disease, true);
				RefreshIndicator(player);
				timer.In(delay, () =>
				{
					diseaseManager.SetTreatment(player, disease, false);
					RefreshIndicator(player);
				});
				if (diseaseManager.UpdateInfectedTime(player, disease, amount))
				{
					diseaseManager.SetActiveTick(player, disease, true);
					RecoverPlayer(player, disease);
				}
				StatusMessage(player, disease, Lang("StatusTreated", player.UserIDString, Color(disease.name, config.DiseaseNameColor)));
				callback?.Invoke();
			}
		}

		private void StatusMessage(BasePlayer player, Disease disease, string message)
		{
			if (config.ShowStatusMessages)
				player.ChatMessage(message);
		}

		private void DoSymptomEffects(BasePlayer player, Disease disease)
		{
			foreach (SymptomEffect effect in disease.symptomEffects)
			{
				effectManager.PlayEffect(player, effect.shortPrefabName, effect.LocalOnly);
			}
		}

		private void DoSymptomScreenEffects(BasePlayer player, Disease disease)
		{
			foreach (SymptomScreenEffect effect in disease.symptomScreenEffects)
			{
				effectManager.ShowScreenEffect(player, effect.shortPrefabName, effect.materialName, effect.opacity, effect.duration, effect.fadeOut);
			}
		}

		private void DoSymptomDamage(BasePlayer player, Disease disease)
		{
			foreach (SymptomDamage damage in disease.damageValues)
			{
				float value = damage.Value();
				switch (damage.stat)
				{
					case RustStat.health:
						player.Hurt(value, Rust.DamageType.Poison);
						break;
					case RustStat.bleeding:
						player.metabolism.ApplyChange(MetabolismAttribute.Type.Bleeding, value, 1);
						break;
					case RustStat.calories:
						player.metabolism.ApplyChange(MetabolismAttribute.Type.Calories, -value, 1);
						break;
					case RustStat.hydration:
						player.metabolism.ApplyChange(MetabolismAttribute.Type.Hydration, -value, 1);
						break;
					case RustStat.oxygen:
						player.metabolism.oxygen.value -= value;
						break;
					case RustStat.radiation:
						player.metabolism.ApplyChange(MetabolismAttribute.Type.Radiation, value, 1);
						break;
					case RustStat.temperature:
						player.metabolism.temperature.value += value;
						break;
					case RustStat.poison:
						player.metabolism.ApplyChange(MetabolismAttribute.Type.Poison, value, 1);
						break;
				}
			}
		}

		private bool WasCauseOfDeath(BasePlayer player, HitInfo info, Disease disease)
		{
			if (!diseaseManager.HasDisease(player, disease))
				return false;
			Rust.DamageType cause = info.damageTypes.GetMajorityDamageType();
			foreach (SymptomDamage damage in disease.damageValues)
				if (cause == damage.GetDamageType())
					return true;
			return false;
		}

		private float GetSpreadChance(BasePlayer player, Disease disease)
		{
			foreach (Item item in player.inventory.containerWear.itemList)
			{
				if (config.FaceCoveringItems.Contains(item.info.shortname))
					return disease.spreadChanceCovered;
			}
			return disease.spreadChanceUncovered;
		}

		private bool CompareStat(BasePlayer player, string statname, float value, Func<float, float, bool> comparison)
		{
			switch (statname)
			{
				case RustStat.health:
					return comparison(player.health, value);
				case RustStat.bleeding:
					return comparison(player.metabolism.bleeding.value, value);
				case RustStat.calories:
					return comparison(player.metabolism.calories.value, value);
				case RustStat.hydration:
					return comparison(player.metabolism.hydration.value, value);
				case RustStat.oxygen:
					return comparison(player.metabolism.oxygen.value, value);
				case RustStat.radiation:
					return comparison(player.metabolism.radiation_level.value, value);
				case RustStat.temperature:
					return comparison(player.metabolism.temperature.value, value);
				case RustStat.poison:
					return comparison(player.metabolism.poison.value, value);
			}
			return false;
		}

		private string AsTitle(string str) => str.ToLower().TitleCase();

		#endregion

		#region Data Structures
		class DoubleDictionary<TkeyA, TkeyB, Tvalue>
		{
			private Dictionary<TkeyA, Dictionary<TkeyB, Tvalue>> a2b;
			private Dictionary<TkeyB, Dictionary<TkeyA, Tvalue>> b2a;

			public DoubleDictionary()
			{
				a2b = new Dictionary<TkeyA, Dictionary<TkeyB, Tvalue>>();
				b2a = new Dictionary<TkeyB, Dictionary<TkeyA, Tvalue>>();
			}

			public void Set(TkeyA keyA, TkeyB keyB, Tvalue value)
			{
				if (!a2b.ContainsKey(keyA))
					a2b.Add(keyA, new Dictionary<TkeyB, Tvalue>());
				if (!b2a.ContainsKey(keyB))
					b2a.Add(keyB, new Dictionary<TkeyA, Tvalue>());
				if (!a2b[keyA].ContainsKey(keyB))
					a2b[keyA].Add(keyB, value);
				else
					a2b[keyA][keyB] = value;
				if (!b2a[keyB].ContainsKey(keyA))
					b2a[keyB].Add(keyA, value);
				else
					b2a[keyB][keyA] = value;
			}

			public Tvalue Get(TkeyA keyA, TkeyB keyB)
			{
				if (a2b.ContainsKey(keyA) && a2b[keyA].ContainsKey(keyB))
					return a2b[keyA][keyB];
				return default(Tvalue);
			}

			public Dictionary<TkeyB, Tvalue> Get(TkeyA keyA)
			{
				if (a2b.ContainsKey(keyA))
					return a2b[keyA];
				return new Dictionary<TkeyB, Tvalue>();
			}

			public Dictionary<TkeyA, Tvalue> Get(TkeyB keyB)
			{
				if (b2a.ContainsKey(keyB))
					return b2a[keyB];
				return new Dictionary<TkeyA, Tvalue>();
			}

			public bool ContainsKey(TkeyA keyA, TkeyB keyB)
			{
				return a2b.ContainsKey(keyA) && a2b[keyA].ContainsKey(keyB);
			}

			public void Delete(TkeyA keyA, TkeyB keyB)
			{
				if (a2b.ContainsKey(keyA) && a2b[keyA].ContainsKey(keyB))
					a2b[keyA].Remove(keyB);
				if (b2a.ContainsKey(keyB) && b2a[keyB].ContainsKey(keyA))
					b2a[keyB].Remove(keyA);
			}

			public void Delete(TkeyA keyA)
			{
				foreach (TkeyB keyB in b2a.Keys)
					if (b2a[keyB].ContainsKey(keyA))
						b2a[keyB].Remove(keyA);
				if (a2b.ContainsKey(keyA))
					a2b.Remove(keyA);
			}

			public void Delete(TkeyB keyB)
			{
				foreach (TkeyA keyA in a2b.Keys)
					if (a2b[keyA].ContainsKey(keyB))
						a2b[keyA].Remove(keyB);
				if (b2a.ContainsKey(keyB))
					b2a.Remove(keyB);
			}
		}

		class LookupList<TOne, TTwo>
		{
			private Dictionary<TOne, List<TTwo>> a2b;
			private Dictionary<TTwo, List<TOne>> b2a;

			public LookupList()
			{
				a2b = new Dictionary<TOne, List<TTwo>>();
				b2a = new Dictionary<TTwo, List<TOne>>();
			}

			public int Count()
			{
				return a2b.Count();
			}

			public void Add(TOne a, TTwo b)
			{
				if (!a2b.ContainsKey(a))
					a2b.Add(a, new List<TTwo>());
				if (!b2a.ContainsKey(b))
					b2a.Add(b, new List<TOne>());
				if (!a2b[a].Contains(b))
					a2b[a].Add(b);
				if (!b2a[b].Contains(a))
					b2a[b].Add(a);
			}

			public void AddAll(TOne[] listA, TTwo b)
			{
				foreach (TOne a in listA)
					Add(a, b);
			}

			public void AddAll(TTwo[] listB, TOne a)
			{
				foreach (TTwo b in listB)
					Add(a, b);
			}

			public void Remove(TOne a)
			{
				TTwo[] depends = Get(a).ToArray();
				foreach (TTwo b in depends)
					Remove(a, b);
			}

			public void Remove(TTwo b)
			{
				TOne[] depends = Get(b).ToArray();
				foreach (TOne a in depends)
					Remove(a, b);
			}

			public void Remove(TOne a, TTwo b)
			{
				if (a2b.ContainsKey(a) && a2b[a].Contains(b))
				{
					a2b[a].Remove(b);
					if (a2b[a].Count() <= 0)
						a2b.Remove(a);
				}

				if (b2a.ContainsKey(b) && b2a[b].Contains(a))
				{
					b2a[b].Remove(a);
					if (b2a[b].Count() <= 0)
						b2a.Remove(b);
				}
			}

			public List<TTwo> Get(TOne a)
			{
				if (a2b.ContainsKey(a))
					return a2b[a];
				return new List<TTwo>();
			}

			public List<TOne> Get(TTwo b)
			{
				if (b2a.ContainsKey(b))
					return b2a[b];
				return new List<TOne>();
			}

			public bool ContainsKey(TOne a)
			{
				return a2b.ContainsKey(a);
			}

			public bool ContainsKey(TTwo b)
			{
				return b2a.ContainsKey(b);
			}

			public bool Contains(TOne a, TTwo b)
			{
				return a2b.ContainsKey(a) && a2b[a].Contains(b);
			}

			public bool Contains(TTwo b, TOne a)
			{
				return b2a.ContainsKey(b) && b2a[b].Contains(a);
			}
		}
		#endregion

		#region Models
		class RustStat
		{
			public const string health = "health";
			public const string bleeding = "bleeding";
			public const string calories = "calories";
			public const string hydration = "hydration";
			public const string oxygen = "oxygen";
			public const string radiation = "radiation";
			public const string temperature = "temperature";
			public const string poison = "poison";
		}

		class SymptomEffect
		{
			[JsonProperty(PropertyName = "Asset path")]
			public string shortPrefabName;

			[JsonProperty(PropertyName = "Local only")]
			public bool LocalOnly = false;
		}
		class SymptomScreenEffect
		{
			[JsonProperty(PropertyName = "Sprite asset path")]
			public string shortPrefabName = "assets/content/textures/generic/fulltransparent.tga";
			[JsonProperty(PropertyName = "Opacity (0-1.0)")]
			public float opacity;
			[JsonProperty(PropertyName = "Duration (seconds)")]
			public float duration;
			[JsonProperty(PropertyName = "Fade out (seconds)")]
			public float fadeOut;
			[JsonProperty(PropertyName = "Material asset path (optional)")]
			public string materialName = "";
		}

		class SpreaderEntity
		{
			[JsonProperty(PropertyName = "Short prefab name")]
			public string shortPrefabName;
			[JsonProperty(PropertyName = "Infection chance on hit (0-100)")]
			public float infectionChanceOnHit;
		}

		class InfectionItem : ItemPrefab
		{
			[JsonProperty(PropertyName = "Infection chance on consumption (0-100)")]
			public float infectionChanceOnConsumption;
		}

		class TreatmentItem : ItemPrefab
		{
			[JsonProperty(PropertyName = "Min infection time decreased (seconds)")]
			public int minTimeDecrease;
			[JsonProperty(PropertyName = "Max infection time decreased (seconds)")]
			public int maxTimeDecrease;
			[JsonProperty(PropertyName = "Delay between reusing treament (seconds)")]
			public int treatmentDelay;

			public int Value() => UnityEngine.Random.Range(minTimeDecrease, maxTimeDecrease);
		}

		class CureItem : ItemPrefab
		{
			[JsonProperty(PropertyName = "Cure chance on consumption (0-100)")]
			public float cureChanceOnConsumption;
		}

		abstract class ItemPrefab
		{
			[JsonProperty(PropertyName = "Short prefab name")]
			public string shortPrefabName;
		}

		class SymptomDamage
		{
			[JsonProperty(PropertyName = "Stat name")]
			public string stat;
			[JsonProperty(PropertyName = "Min damage")]
			public float minValue;
			[JsonProperty(PropertyName = "Max damage")]
			public float maxValue;
			public float Value() => UnityEngine.Random.Range(minValue, maxValue);
			public Rust.DamageType GetDamageType()
			{
				switch (stat)
				{
					case "health":
						return Rust.DamageType.Poison;
					case "bleeding":
						return Rust.DamageType.Bleeding;
					case "calories":
						return Rust.DamageType.Hunger;
					case "hydration":
						return Rust.DamageType.Thirst;
					case "oxygen":
						return Rust.DamageType.Drowned;
					case "radiation":
						return Rust.DamageType.Radiation;
					case "temperature":
						return Rust.DamageType.Cold;
					case "poison":
						return Rust.DamageType.Poison;
					default:
						return Rust.DamageType.LAST;
				}
			}
		}

		class StatFilter
		{
			[JsonProperty(PropertyName = "Stat name")]
			public string stat;
			[JsonProperty(PropertyName = "Min value")]
			public float minValue;
			[JsonProperty(PropertyName = "Max value")]
			public float maxValue;
		}

		class OutbreakCondition
		{
			[JsonProperty(PropertyName = "Outbreaks enabled")]
			public bool enabled;
			[JsonProperty(PropertyName = "Outbreak chance (0-100)")]
			public float outbreakChance;
			[JsonProperty(PropertyName = "Time interval (seconds)")]
			public int timeInterval;
			[JsonProperty(PropertyName = "Only outbreak on players with the following stats")]
			public StatFilter[] statFilters;
		}

		class DiseaseStats
		{
			public class DiseaseStat
			{
				public string name;
				public int count;
			}

			public DiseaseStat activeInfected = new DiseaseStat { name = "Active players infected", count = 0 };
			public DiseaseStat sleepersInfected = new DiseaseStat { name = "Sleeping players infected", count = 0 };
			public DiseaseStat totalInfected = new DiseaseStat { name = "Total players infected", count = 0 };
			public DiseaseStat playersKilled = new DiseaseStat { name = "Total players killed", count = 0 };
			public DiseaseStat numOutbreaks = new DiseaseStat { name = "Number of outbreaks", count = 0 };
			public DiseaseStat infectedFromSpreading = new DiseaseStat { name = "Players infected from spreading", count = 0 };
			public DiseaseStat infectedFromEntity = new DiseaseStat { name = "Players infected from entities", count = 0 };
			public DiseaseStat infectedFromItem = new DiseaseStat { name = "Players infected from items", count = 0 };
			public DiseaseStat infectedFromOutbreak = new DiseaseStat { name = "Players infected from outbreaks", count = 0 };
			public DiseaseStat infectedFromCommand = new DiseaseStat { name = "Players infected from commands", count = 0 };
			public DiseaseStat timesTreatedFromItem = new DiseaseStat { name = "Times treated by items", count = 0 };
			public DiseaseStat timesCuredFromItem = new DiseaseStat { name = "Times cured by items", count = 0 };
		}

		#endregion

		#region Classes
		class Disease
		{
			[JsonProperty(PropertyName = "Disease name")]
			public string name { get; set; } = "";

			[JsonProperty(PropertyName = "Description")]
			public string info { get; set; } = "No information on this disease.";

			[JsonProperty(PropertyName = "Min time immune after recovery (seconds)")]
			public int minImmunityTime { get; set; } = 0;

			[JsonProperty(PropertyName = "Max time immune after recovery (seconds)")]
			public int maxImmunityTime { get; set; } = 0;

			[JsonProperty(PropertyName = "Min time infected (seconds)")]
			public int minInfectionTime { get; set; } = 0;

			[JsonProperty(PropertyName = "Max time infected (seconds)")]
			public int maxInfectionTime { get; set; } = 0;

			[JsonProperty(PropertyName = "Min time between symptoms (seconds)")]
			public int minSpreadTime { get; set; } = 0;

			[JsonProperty(PropertyName = "Max time between symptoms (seconds)")]
			public int maxSpreadTime { get; set; } = 0;

			[JsonProperty(PropertyName = "Spread distance (4.0 = 1 foundation)")]
			public float spreadDistance { get; set; } = 0;

			[JsonProperty(PropertyName = "Spread chance with mask (0-100)")]
			public float spreadChanceCovered { get; set; } = 0;

			[JsonProperty(PropertyName = "Spread chance without mask (0-100)")]
			public float spreadChanceUncovered { get; set; } = 0;

			[JsonProperty(PropertyName = "Symptom damage effects")]
			public SymptomDamage[] damageValues { get; set; } = new SymptomDamage[] { };

			[JsonProperty(PropertyName = "Items that cause infection on consumption")]
			public InfectionItem[] infectionItems { get; set; } = new InfectionItem[] { };

			[JsonProperty(PropertyName = "Items that cure on consumption")]
			public CureItem[] cureItems { get; set; } = new CureItem[] { };

			[JsonProperty(PropertyName = "Items that reduce infection time on consumption")]
			public TreatmentItem[] treatmentItems { get; set; } = new TreatmentItem[] { };

			[JsonProperty(PropertyName = "Entities that cause infection on hit")]
			public SpreaderEntity[] spreaderEntities { get; set; } = new SpreaderEntity[] { };

			[JsonProperty(PropertyName = "Random outbreak settings")]
			public OutbreakCondition outbreakConditions { get; set; } = new OutbreakCondition
			{
				enabled = false,
				outbreakChance = 0,
				timeInterval = 300,
				statFilters = new StatFilter[] { }
			};

			[JsonProperty(PropertyName = "Symptom effects")]
			public SymptomEffect[] symptomEffects { get; set; } = new SymptomEffect[] { };

			[JsonProperty(PropertyName = "Symptom screen effects")]
			public SymptomScreenEffect[] symptomScreenEffects { get; set; } = new SymptomScreenEffect[] { };

			[JsonProperty(PropertyName = "Version")]
			public VersionNumber version { get; set; } = new VersionNumber(0, 0, 0);

			public int SpreadTime() => UnityEngine.Random.Range(minSpreadTime, maxSpreadTime);

			public int InfectedTime() => UnityEngine.Random.Range(minInfectionTime, maxInfectionTime);

			public int ImmunityTime() => UnityEngine.Random.Range(minImmunityTime, maxImmunityTime);

			#region File IO
			public static Disease GenerateDefault()
			{
				Disease disease = new Disease
				{
					name = "Norovirus",
					info = "Highly contagious disease that causes vomitting and is caused by eating rotten food. Can be treated with tea and cured with pills.",
					minImmunityTime = 180,
					maxImmunityTime = 600,
					minInfectionTime = 180,
					maxInfectionTime = 600,
					minSpreadTime = 5,
					maxSpreadTime = 45,
					spreadDistance = 2f,
					spreadChanceCovered = 0,
					spreadChanceUncovered = 85,
					damageValues = new SymptomDamage[]
					{
						new SymptomDamage { stat=RustStat.health , minValue=1f, maxValue=5f},
						new SymptomDamage { stat=RustStat.calories , minValue=100f, maxValue=125f},
						new SymptomDamage { stat=RustStat.hydration , minValue=50f, maxValue=85f}
					},
					infectionItems = new InfectionItem[]
					{
						new InfectionItem { shortPrefabName="chicken.raw", infectionChanceOnConsumption=10f },
						new InfectionItem { shortPrefabName="chicken.spoiled", infectionChanceOnConsumption=85f },
						new InfectionItem { shortPrefabName="humanmeat.raw", infectionChanceOnConsumption=10f },
						new InfectionItem { shortPrefabName="humanmeat.spoiled", infectionChanceOnConsumption=85f }
					},
					cureItems = new CureItem[]
					{
						new CureItem { shortPrefabName="antiradpills", cureChanceOnConsumption=50f }
					},
					treatmentItems = new TreatmentItem[]
					{
						new TreatmentItem { shortPrefabName="healingtea", minTimeDecrease=5, maxTimeDecrease=10, treatmentDelay=10 },
						new TreatmentItem { shortPrefabName="healingtea.advanced", minTimeDecrease=10, maxTimeDecrease=40, treatmentDelay=40 },
						new TreatmentItem { shortPrefabName="healingtea.pure", minTimeDecrease=40, maxTimeDecrease=160, treatmentDelay=160 }
					},
					spreaderEntities = new SpreaderEntity[]
					{
						new SpreaderEntity { shortPrefabName="boar", infectionChanceOnHit=5f }
					},
					outbreakConditions = new OutbreakCondition
					{
						enabled = true,
						outbreakChance = 25f,
						timeInterval = 300,
						statFilters = new StatFilter[] {
							new StatFilter { stat=RustStat.health, minValue=0, maxValue=50 }
						}
					},
					symptomEffects = new SymptomEffect[]
					{
						new SymptomEffect { shortPrefabName="assets/bundled/prefabs/fx/gestures/drink_vomit.prefab" },
						new SymptomEffect { shortPrefabName="assets/bundled/prefabs/fx/water/midair_splash.prefab" },
						new SymptomEffect { shortPrefabName="assets/prefabs/weapons/cake/effects/strike_screenshake.prefab", LocalOnly=true }
					},
					symptomScreenEffects = new SymptomScreenEffect[]
					{
						new SymptomScreenEffect { shortPrefabName="assets/content/ui/overlay_poisoned.png", duration=1f, opacity=1f, fadeOut=1f }
					},
					version = PLUGIN.Version
				};
				return disease;
			}

			public static void SaveToFile(Disease disease)
			{
				Interface.Oxide.DataFileSystem.WriteObject("Diseases/" + disease.name, disease);
			}

			public static Disease ReadFromFile(string diseaseName)
			{
				try
				{
					Disease disease = Interface.Oxide.DataFileSystem.ReadObject<Disease>("Diseases/" + diseaseName);
					if (disease.name == null)
						disease.name = "null";
					if (PLUGIN.AsTitle(diseaseName) != PLUGIN.AsTitle(disease.name))
						PLUGIN.PrintWarning($"Disease file '{diseaseName}.json' does not match with disease name of '{disease.name}', the name '{diseaseName}' will be used instead.");
					disease.name = PLUGIN.AsTitle(diseaseName);
					if (disease.version.Major != PLUGIN.Version.Major || disease.version.Minor != PLUGIN.Version.Minor)
					{
						PLUGIN.PrintError($"The disease file '{disease.name}.json' is version {disease.version} but the plugin version is {PLUGIN.Version}. This disease cannot be loaded until it is updated.");
						return null;
					}
					else if (disease.version.Patch != PLUGIN.Version.Patch)
					{
						PLUGIN.PrintWarning($"Consider updating the 'Version' property in '{diseaseName}.json' from {disease.version} to {PLUGIN.Version}.");
					}
					return disease;
				}
				catch (Newtonsoft.Json.JsonSerializationException)
				{
					PLUGIN.PrintError($"The disease file '{diseaseName}.json' contains a syntax error. Please check to make sure it matches the syntax in 'Norovirus.json'.");
				}
				catch (Exception)
				{
					PLUGIN.PrintError($"The disease file '{diseaseName}.json' failed to load properly.");
				}
				return null;
			}
			#endregion
		}

		#endregion

		#region Manager
		class EffectManager
		{
			public readonly Dictionary<ulong, List<string>> ActiveEffects;

			private ulong idCount;

			public EffectManager()
			{
				ActiveEffects = new Dictionary<ulong, List<string>>();
				idCount = 0;
			}

			private void InitPlayer(ulong userid)
			{
				if (!ActiveEffects.ContainsKey(userid))
					ActiveEffects.Add(userid, new List<string>());
			}

			private void AddEffect(ulong userid, string effectString)
			{
				InitPlayer(userid);
				ActiveEffects[userid].Add(effectString + idCount);
				idCount++;
			}

			private void RemoveEffect(ulong userid, string effectString)
			{
				InitPlayer(userid);
				if (ActiveEffects[userid].Contains(effectString))
					ActiveEffects[userid].Remove(effectString);
			}

			public void PlayEffect(BasePlayer player, string effectString, bool local)
			{
				var effect = new Effect(effectString, player, 0, Vector3.zero, Vector3.forward);
				if (local)
					EffectNetwork.Send(effect, player.net.connection);
				else
					EffectNetwork.Send(effect);
			}

			public void ClearAllEffects(BasePlayer player)
			{
				InitPlayer(player.userID);
				foreach (string activeEffect in ActiveEffects[player.userID])
				{
					CuiHelper.DestroyUi(player, activeEffect);
					RemoveEffect(player.userID, activeEffect);
				}
			}

			public void ShowScreenEffect(BasePlayer player, string assetStringPath, string materialStringPath, float opacity = 1, float duration = 1, float fadeOut = 1)
			{
				CuiElementContainer container = new CuiElementContainer();
				ulong thisId = idCount;
				container.Add(new CuiElement
				{
					Name = assetStringPath + thisId,
					Parent = "Hud",
					FadeOut = fadeOut,
					Components =
					{
						new CuiRawImageComponent {
							Sprite = assetStringPath,
							Material = materialStringPath,
							Color = "1 1 1 " + opacity
						},
						new CuiRectTransformComponent
						{
							AnchorMin = "0 0",
							AnchorMax = "1 1"
						}
					},
				});

				if (debug)
					PLUGIN.Puts("Started screen effect for " + assetStringPath + thisId);
				CuiHelper.AddUi(player, container);
				AddEffect(player.userID, assetStringPath);
				PLUGIN.timer.In(duration, () =>
				{
					CuiHelper.DestroyUi(player, assetStringPath + thisId);
					if (debug)
						PLUGIN.Puts("Cleared screen effect for " + assetStringPath + thisId);
					RemoveEffect(player.userID, assetStringPath + thisId);
				});

			}
		}

		class DiseaseManager
		{
			public readonly LookupList<BasePlayer, string> InfectedPlayers;  /* playerid, diseasename */
			public readonly Dictionary<string, Disease> LoadedDiseases; /*diseasename, disease*/
			private DoubleDictionary<ulong, string, int> InfectedTimes;
			private DoubleDictionary<ulong, string, int> NextGoalTimes;
			private DoubleDictionary<ulong, string, bool> IsImmune;
			private DoubleDictionary<ulong, string, bool> IsTreated;
			private DoubleDictionary<ulong, string, bool> ActiveTick;
			private Dictionary<ulong, bool> SafeZone;
			public readonly DoubleDictionary<string, string, CureItem> ItemsThatCure;
			public readonly DoubleDictionary<string, string, InfectionItem> ItemsThatInfect;
			public readonly DoubleDictionary<string, string, TreatmentItem> ItemsThatTreat;
			public readonly DoubleDictionary<string, string, SpreaderEntity> EntitiesThatInfect;


			public DiseaseManager()
			{
				InfectedPlayers = new LookupList<BasePlayer, string>();
				LoadedDiseases = new Dictionary<string, Disease>();
				InfectedTimes = new DoubleDictionary<ulong, string, int>();
				NextGoalTimes = new DoubleDictionary<ulong, string, int>();
				IsImmune = new DoubleDictionary<ulong, string, bool>();
				IsTreated = new DoubleDictionary<ulong, string, bool>();
				ActiveTick = new DoubleDictionary<ulong, string, bool>();
				ItemsThatCure = new DoubleDictionary<string, string, CureItem>();
				ItemsThatInfect = new DoubleDictionary<string, string, InfectionItem>();
				ItemsThatTreat = new DoubleDictionary<string, string, TreatmentItem>();
				EntitiesThatInfect = new DoubleDictionary<string, string, SpreaderEntity>();
			}

			public void LoadAllDiseases(Action callback = null)
			{
				List<string> files = new List<string>();
				try
				{
					files = Interface.Oxide.DataFileSystem.GetFiles("Diseases/").ToList();
				}
				catch (Exception) {
					PLUGIN.PrintError("Failed to read files from /Diseases directory");
				};

				/* Generate Default Disease */
				if (PLUGIN.config.GenerateDefaultDisease)
				{
					Disease disease = Disease.GenerateDefault();
					LoadDisease(disease);
					Disease.SaveToFile(disease);
				}
				foreach (string filename in files)
				{
					string[] split = filename.Split('/');
					string diseaseName = split[split.Length - 1].Replace(".json", "");
					foreach (string nameInConfig in PLUGIN.config.DefaultLoadedDiseases)
					{
						
						if (PLUGIN.AsTitle(nameInConfig) == PLUGIN.AsTitle(diseaseName))
						{
							Disease disease = Disease.ReadFromFile(diseaseName);
							if (disease != null)
							{
								LoadDisease(disease);
								PLUGIN.Puts($"Loaded disease {disease.name}");
							}
								
						}
					}
				}
				callback?.Invoke();
			}

			public void LoadDisease(Disease disease, Action callback = null)
			{
				if (!LoadedDiseases.ContainsKey(disease.name))
				{
					LoadedDiseases.Add(disease.name, disease);
					LoadItems(disease);
					LoadEntities(disease);
					PLUGIN.diseaseStats.Add(disease.name, new DiseaseStats());

					if (debug)
						PLUGIN.Puts("Loaded " + disease.name);
					callback?.Invoke();
				}
			}

			public void UnloadDisease(string diseasename)
			{
				InfectedPlayers.Remove(diseasename);
				InfectedTimes.Delete(diseasename);
				NextGoalTimes.Delete(diseasename);
				IsImmune.Delete(diseasename);
				PLUGIN.diseaseStats.Remove(diseasename);
				LoadedDiseases.Remove(diseasename);
				if (debug)
					PLUGIN.Puts("Unloaded " + diseasename);
			}

			public Disease GetDisease(string diseasename)
			{
				if (LoadedDiseases.ContainsKey(diseasename))
					return LoadedDiseases[diseasename];
				return null;
			}

			// Called when a player is to be infected with the given disease
			public bool AddInfected(BasePlayer player, Disease disease)
			{
				if (CanInfect(player, disease))
				{
					InfectedPlayers.Add(player, disease.name);
					InfectedTimes.Set(player.userID, disease.name, 0);
					NextGoalTimes.Set(player.userID, disease.name, disease.InfectedTime());
					IsImmune.Set(player.userID, disease.name, false);
					if (debug)
						PLUGIN.Puts("Infected: " + player.displayName + " with " + disease.name + " for " + NextGoalTimes.Get(player.userID, disease.name) + " seconds");
					return true;
				}
				return false;
			}

			// Called when a player is to be no longer infected with the given disease
			public bool RemoveInfected(BasePlayer player, Disease disease)
			{
				if (InfectedPlayers.ContainsKey(player))
				{
					InfectedPlayers.Remove(player, disease.name);
					InfectedTimes.Delete(player.userID);
					NextGoalTimes.Delete(player.userID);
					IsImmune.Delete(player.userID);
					if (debug)
						PLUGIN.Puts("Uninfected: " + player.displayName + " from " + disease.name);
					return true;
				}
				return false;
			}

			public bool RemoveAllInfected(string diseasename)
			{
				if (InfectedPlayers.ContainsKey(diseasename))
				{
					InfectedPlayers.Remove(diseasename);
					if (debug)
						PLUGIN.Puts("Uninfected all of: " + diseasename);
					return true;
				}
				return false;
			}

			// Returns an iterable copy of all players infected by the disease
			public BasePlayer[] GetInfectedList(string diseasename)
			{
				return InfectedPlayers.Get(diseasename).ToArray();
			}

			// Returns an iterable copy of all diseases a player has
			public string[] GetPlayerInfections(BasePlayer player)
			{
				return InfectedPlayers.Get(player).ToArray();
			}

			public void SetActiveTick(BasePlayer player, Disease disease, bool value)
			{
				ActiveTick.Set(player.userID, disease.name, value);
			}

			public bool HasActiveTick(BasePlayer player, Disease disease)
			{
				if (ActiveTick.ContainsKey(player.userID, disease.name))
					return ActiveTick.Get(player.userID, disease.name);
				return false;
			}

			public bool CanInfect(BasePlayer player, Disease disease)
			{
				return player.IsValid() && player.IsConnected && PLUGIN.permission.UserHasPermission(player.UserIDString, PermissionUse) && !HasDisease(player, disease) && !HasImmunity(player, disease) && InfectedPlayers.Count() < PLUGIN.config.MaxInfectedEntities && !(player.InSafeZone() && PLUGIN.config.SafezoneInfectionSpread);
			}

			public bool HasDisease(BasePlayer player, Disease disease)
			{
				return InfectedPlayers.Contains(player, disease.name);
			}

			public bool HasImmunity(BasePlayer player, Disease disease)
			{
				return IsImmune.ContainsKey(player.userID, disease.name) && IsImmune.Get(player.userID, disease.name);
			}

			public void SetTreatment(BasePlayer player, Disease disease, bool value)
			{
				IsTreated.Set(player.userID, disease.name, value);
			}

			public bool HasTreatment(BasePlayer player, Disease disease)
			{
				return IsTreated.ContainsKey(player.userID, disease.name) && IsTreated.Get(player.userID, disease.name);
			}

			// Modifies the infected time for a user/disease combo with the modifier, returns true if goal is reached
			public bool UpdateInfectedTime(BasePlayer player, Disease disease, int modifier)
			{
				if (HasImmunity(player, disease)) return true;
				if (InfectedTimes.ContainsKey(player.userID, disease.name) && NextGoalTimes.ContainsKey(player.userID, disease.name) && LoadedDiseases.ContainsKey(disease.name))
				{
					InfectedTimes.Set(player.userID, disease.name, InfectedTimes.Get(player.userID, disease.name) + modifier);
					return InfectedTimes.Get(player.userID, disease.name) >= NextGoalTimes.Get(player.userID, disease.name);
				}
				return false;
			}

			public bool SetRecovery(BasePlayer player, Disease disease)
			{
				if (!HasImmunity(player, disease))
				{
					InfectedTimes.Set(player.userID, disease.name, 0);
					IsImmune.Set(player.userID, disease.name, true);
					return true;
				}
				return false;
			}

			private void LoadItems(Disease disease)
			{
				foreach (CureItem item in disease.cureItems)
					ItemsThatCure.Set(item.shortPrefabName, disease.name, item);
				foreach (InfectionItem item in disease.infectionItems)
					ItemsThatInfect.Set(item.shortPrefabName, disease.name, item);
				foreach (TreatmentItem item in disease.treatmentItems)
					ItemsThatTreat.Set(item.shortPrefabName, disease.name, item);
			}

			private void LoadEntities(Disease disease)
			{
				foreach (SpreaderEntity entity in disease.spreaderEntities)
				{
					if (debug)
						PLUGIN.Puts("Set " + entity.shortPrefabName + " " + disease.name);
					EntitiesThatInfect.Set(entity.shortPrefabName, disease.name, entity);
				}
			}

		}
		#endregion

		#region Commands
		private Dictionary<string, ChatCmd> commands = new Dictionary<string, ChatCmd>();
		void InitCommands()
		{
			commands.Add("help", new ChatCmd
			{
				perms = new List<string>() { PermissionUse },
				function = (IPlayer player, string command, string[] args) => { cmd_help(player, command, args); }
			});
			commands.Add("infect", new ChatCmd
			{
				usages = new List<string>() { "<player_name> <disease_name>" },
				perms = new List<string>() { PermissionAdmin },
				function = (IPlayer player, string command, string[] args) => { cmd_infect(player, command, args); }
			});
			commands.Add("cure", new ChatCmd
			{
				usages = new List<string>() { "<player_name> <disease_name>" },
				perms = new List<string>() { PermissionAdmin },
				function = (IPlayer player, string command, string[] args) => { cmd_cure(player, command, args); }
			});
			commands.Add("outbreak", new ChatCmd
			{
				usages = new List<string>() { "<player_name> <disease_name>", "<player_name> <disease_name> <number>" },
				perms = new List<string>() { PermissionAdmin },
				function = (IPlayer player, string command, string[] args) => { cmd_outbreak(player, command, args); }
			});
			commands.Add("eradicate", new ChatCmd
			{
				usages = new List<string>() { "<disease_name>" },
				perms = new List<string>() { PermissionAdmin },
				function = (IPlayer player, string command, string[] args) => { cmd_eradicate(player, command, args); }
			});
			commands.Add("list", new ChatCmd
			{
				perms = new List<string>() { PermissionUse, PermissionAdmin },
				function = (IPlayer player, string command, string[] args) => { cmd_list(player, command, args); }
			});
			commands.Add("info", new ChatCmd
			{
				usages = new List<string>() { "<disease_name>" },
				perms = new List<string>() { PermissionUse, PermissionAdmin },
				function = (IPlayer player, string command, string[] args) => { cmd_info(player, command, args); }
			});
			commands.Add("stats", new ChatCmd
			{
				usages = new List<string>() { "<disease_name>" },
				perms = new List<string>() { PermissionUse, PermissionAdmin },
				function = (IPlayer player, string command, string[] args) => { cmd_stats(player, command, args); }
			});
			commands.Add("config", new ChatCmd
			{
				usages = new List<string>() { "<disease_name>" },
				perms = new List<string>() { PermissionAdmin },
				function = (IPlayer player, string command, string[] args) => { cmd_config(player, command, args); }
			});
			commands.Add("load", new ChatCmd
			{
				usages = new List<string>() { "<disease_name>" },
				perms = new List<string>() { PermissionAdmin },
				function = (IPlayer player, string command, string[] args) => { cmd_load(player, command, args); }
			});
			commands.Add("unload", new ChatCmd
			{
				usages = new List<string>() { "<disease_name>" },
				perms = new List<string>() { PermissionAdmin },
				function = (IPlayer player, string command, string[] args) => { cmd_unload(player, command, args); }
			});
		}

		class ChatCmd
		{
			public string prefix = "";
			public List<string> usages = new List<string>();
			public List<string> perms = new List<string>();
			public Action<IPlayer, string, string[]> function;

			public bool HasPerms(string id)
			{
				foreach (string perm in perms)
					if (PLUGIN.permission.UserHasPermission(id, perm))
						return true;
				return false;
			}

			public string Usage(string prefix, string usg)
			{
				prefix = PLUGIN.Color(prefix, "orange");
				usg = PLUGIN.Color(usg, "#00ffff");
				return $"{prefix} {usg}";
			}
		}

		[Command("disease")]
		private void cmd_disease(IPlayer player, string command, string[] args)
		{
			if (args.Length == 0)
			{
				/* Help command */
				cmd_help(player, command, args);
			}
			if (args.Length >= 1)
			{
				string prefix = args[0];
				if (commands.ContainsKey(prefix))
				{
					args = args.Skip(1).ToArray();
					ChatCmd cmd = commands[prefix];
					if (cmd.HasPerms(player.Id))
					{
						try
						{
							commands[prefix].function(player, command, args);
							return;
						}
						catch { }
					}
				}
			}
			player.Reply(Lang("Invalid", player.Id));
		}

		[Command("disease.help"), Permission(PermissionAdmin)]
		private void cmd_help(IPlayer player, string command, string[] args)
		{
			string size = "16";
			string cmdList = Size(Color("Diseases", "green"), size) + "\n";
			foreach (string prefix in commands.Keys)
			{
				ChatCmd cmd = commands[prefix];
				if (cmd.HasPerms(player.Id))
				{
					foreach (string usg in cmd.usages)
					{
						cmdList += Color($"/disease {cmd.Usage(prefix, usg)}\n", "yellow");
					}
				}
			}
			player.Reply(cmdList);
		}

		[Command("infect"), Permission(PermissionAdmin)]
		private void cmd_infect(IPlayer player, string command, string[] args)
		{
			string playerName = args[0];
			string diseaseName = AsTitle(args[1]);
			BasePlayer target = BasePlayer.Find(playerName);
			Disease disease = diseaseManager.GetDisease(diseaseName);
			if (!target.IsValid())
			{
				player.Reply(Lang("NoPlayer", player.Id, playerName));
			}
			else if (disease == null)
			{
				player.Reply(Lang("NoExist", player.Id, diseaseName));
			}
			else
			{
				if (diseaseManager.CanInfect(target, disease))
				{
					InfectPlayer(target, disease, () =>
					{
						diseaseStats[disease.name].infectedFromCommand.count += 1; ;
					});
					player.Reply(Lang("Infect", player.Id, target.displayName, disease.name));
				}
				else
				{
					player.Reply(Lang("NoInfect", player.Id, target.displayName, disease.name));
				}
			}
		}

		[Command("cure"), Permission(PermissionAdmin)]
		private void cmd_cure(IPlayer player, string command, string[] args)
		{
			string playerName = args[0];
			string diseaseName = AsTitle(args[1]);
			BasePlayer target = BasePlayer.Find(playerName);
			Disease disease = diseaseManager.GetDisease(diseaseName);
			if (!target.IsValid())
			{
				player.Reply(Lang("NoPlayer", player.Id, playerName));
			}
			else if (disease == null)
			{
				player.Reply(Lang("NoExist", player.Id, diseaseName));
			}
			else
			{
				if (diseaseManager.HasDisease(target, disease))
				{
					CurePlayer(target, disease);
					player.Reply(Lang("Cure", player.Id, target.displayName, disease.name));
				}
				else
				{
					player.Reply(Lang("NoCure", player.Id, target.displayName, disease.name));
				}
			}
		}

		[Command("outbreak"), Permission(PermissionAdmin)]
		private void cmd_outbreak(IPlayer player, string command, string[] args)
		{
			string diseaseName = AsTitle(args[0]);
			int tries = args.Length >= 2 ? int.Parse(args[1]) : 1;
			Disease disease = diseaseManager.GetDisease(diseaseName);
			if (disease == null)
			{
				player.Reply(Lang("NoExist", player.Id, diseaseName));
			}
			else
			{
				int infected = Outbreak(disease, tries);
				player.Reply(Lang("Outbreak", player.Id, disease.name, infected));
			}
		}

		[Command("eradicate"), Permission(PermissionAdmin)]
		private void cmd_eradicate(IPlayer player, string command, string[] args)
		{
			string diseaseName = AsTitle(args[0]);
			Disease disease = diseaseManager.GetDisease(diseaseName);
			if (disease == null)
			{
				player.Reply(Lang("NoExist", player.Id, diseaseName));
			}
			else if (diseaseManager.RemoveAllInfected(diseaseName))
			{
				player.Reply(Lang("Eradicate", player.Id, disease.name));
			}
			else
			{
				player.Reply(Lang("NoEradicate", player.Id, disease.name));
			}
		}

		[Command("disease.load"), Permission(PermissionAdmin)]
		private void cmd_load(IPlayer player, string command, string[] args)
		{
			string diseaseName = AsTitle(args[0]);
			if (!diseaseManager.LoadedDiseases.ContainsKey(diseaseName))
			{
				Disease disease = Disease.ReadFromFile(diseaseName);
				if (disease != null)
				{
					diseaseManager.LoadDisease(disease, () =>
					{
						player.Reply(Lang("Load", player.Id, disease.name));
					});
				}
				return;
			}
			player.Reply(Lang("NoLoad", player.Id, diseaseName));
		}

		[Command("disease.unload"), Permission(PermissionAdmin)]
		private void cmd_unload(IPlayer player, string command, string[] args)
		{
			string diseaseName = AsTitle(args[0]);
			if (diseaseManager.LoadedDiseases.ContainsKey(diseaseName))
			{
				diseaseManager.UnloadDisease(diseaseName);
				player.Reply(Lang("Unload", player.Id, diseaseName));
				return;
			}
			player.Reply(Lang("NoUnload", player.Id, diseaseName));
		}

		[Command("disease.list"), Permission(PermissionAdmin)]
		private void cmd_list(IPlayer player, string command, string[] args)
		{
			player.Reply(Lang("List", player.Id, diseaseManager.LoadedDiseases.Keys.ToSentence()));
		}

		[Command("disease.info"), Permission(PermissionAdmin)]
		private void cmd_info(IPlayer player, string command, string[] args)
		{
			string diseaseName = AsTitle(args[0]);
			if (diseaseManager.LoadedDiseases.ContainsKey(diseaseName))
			{
				Disease disease = diseaseManager.GetDisease(diseaseName);
				player.Reply($"{Color(disease.name, config.DiseaseNameColor)}: {disease.info}");
				return;
			}
			else
			{
				player.Reply(Lang("NoExist", player.Id, diseaseName));
			}
		}

		[Command("disease.config"), Permission(PermissionAdmin)]
		private void cmd_config(IPlayer player, string command, string[] args)
		{
			string diseaseName = AsTitle(args[0]);
			if (diseaseManager.LoadedDiseases.ContainsKey(diseaseName))
			{
				Disease disease = diseaseManager.GetDisease(diseaseName);
				var jsonString = JsonConvert.SerializeObject(
				disease, Formatting.Indented,
				new JsonConverter[] { new StringEnumConverter() });
				player.Reply(jsonString);
			}
			else
			{
				player.Reply(Lang("NoExist", player.Id, diseaseName));
			}
		}

		[Command("disease.stats"), Permission(PermissionAdmin)]
		private void cmd_stats(IPlayer player, string command, string[] args)
		{
			string diseaseName = AsTitle(args[0]);
			if (diseaseManager.LoadedDiseases.ContainsKey(diseaseName))
			{
				DiseaseStats stats = diseaseStats[diseaseName];
				string entry = "{0}: " + Color("{1}", "yellow") + "\n";
				string message = $"{Color(diseaseName, config.DiseaseNameColor)}:\n";
				message += string.Format(entry, stats.activeInfected.name, stats.activeInfected.count);
				message += string.Format(entry, stats.sleepersInfected.name, stats.sleepersInfected.count);
				message += string.Format(entry, stats.totalInfected.name, stats.totalInfected.count);
				message += string.Format(entry, stats.playersKilled.name, stats.playersKilled.count);
				message += string.Format(entry, stats.numOutbreaks.name, stats.numOutbreaks.count);
				message += string.Format(entry, stats.infectedFromSpreading.name, stats.infectedFromSpreading.count);
				message += string.Format(entry, stats.infectedFromEntity.name, stats.infectedFromEntity.count);
				message += string.Format(entry, stats.infectedFromItem.name, stats.infectedFromItem.count);
				message += string.Format(entry, stats.infectedFromOutbreak.name, stats.infectedFromOutbreak.count);
				message += string.Format(entry, stats.infectedFromCommand.name, stats.infectedFromCommand.count);
				message += string.Format(entry, stats.timesTreatedFromItem.name, stats.timesTreatedFromItem.count);
				message += string.Format(entry, stats.timesCuredFromItem.name, stats.timesCuredFromItem.count);
				player.Reply(message);
				return;
			}
			else
			{
				player.Reply(Lang("NoExist", player.Id, diseaseName));
			}
		}
		#endregion

		#region Configuration

		private Configuration config;
		private class Configuration
		{
			[JsonProperty(PropertyName = "Generate default disease (true/false)")]
			public bool GenerateDefaultDisease = true;

			[JsonProperty(PropertyName = "Loaded diseases on startup")]
			public string[] DefaultLoadedDiseases { get; set; } = {
			  "Norovirus",
			};

			[JsonProperty(PropertyName = "Max number of infected entities")]
			public int MaxInfectedEntities { get; set; } = 100;

			[JsonProperty(PropertyName = "Disease name color in messages")]
			public string DiseaseNameColor { get; set; } = "green";

			[JsonProperty(PropertyName = "Face covering items")]
			public string[] FaceCoveringItems { get; set; } = {
			  "mask.bandana",
			  "burlap.headwrap",
			  "clatter.helmet",
			  "coffeecan.helmet",
			  "heavy.plate.helmet",
			  "hazmatsuit",
			  "hazmatsuit.spacesuit",
			  "metal.facemask",
			  "halloween.surgeonsuit"
			};

			[JsonProperty(PropertyName = "Show status chat messages")]
			public bool ShowStatusMessages { get; set; } = true;

			[JsonProperty(PropertyName = "Infections can spread in safe zones")]
			public bool SafezoneInfectionSpread { get; set; } = true;

			[JsonProperty(PropertyName = "Broadcast disease death messages")]
			public bool BroadcastDeathMessages { get; set; } = false;

			[JsonProperty(PropertyName = "Broadcast outbreaks")]
			public bool BroadcastOutbreaks { get; set; } = false;

			[JsonProperty(PropertyName = "HUD indicator list")]
			public PositionUI IndicatorHUD { get; set; } = new PositionUI { AnchorMin = "0.9 0.6", AnchorMax = "0.985 0.9", EntryHeight = 0.1f, ImgAnchorMin = "0.04 0.1", ImgAnchorMax = "0.22 0.85", ImgShow = true };
		}

		private class PositionUI
		{
			[JsonProperty(PropertyName = "Anchor min")]
			public string AnchorMin;
			[JsonProperty(PropertyName = "Anchor max")]
			public string AnchorMax;
			[JsonProperty(PropertyName = "Entry height")]
			public float EntryHeight;
			[JsonProperty(PropertyName = "Anchor min (image)")]
			public string ImgAnchorMin;
			[JsonProperty(PropertyName = "Anchor max (image)")]
			public string ImgAnchorMax;
			[JsonProperty(PropertyName = "Show image (requires ImageLibrary)")]
			public bool ImgShow;
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();

			try
			{
				config = Config.ReadObject<Configuration>();
				if (config == null) throw new Exception();
			}
			catch
			{
				PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
			}
		}

		protected override void SaveConfig() => Config.WriteObject(config);

		protected override void LoadDefaultConfig() => config = new Configuration();
		#endregion

		#region Localization
		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["StatusInfected"] = "You are infected with {0}",
				["StatusRecovered"] = "You have recovered from {0}",
				["StatusTreated"] = "You treated the {0} and will recover faster",
				["StatusCured"] = "You are not longer suffering from {0}",
				["StatusOutbreak"] = "An outbreak of {0} has started",
				["Infect"] = "Infected {0} with {1}",
				["NoInfect"] = "{0} is already infected with {1} or is immune",
				["Cure"] = "Cured {0} of {1}",
				["NoCure"] = "{0} is not infected with {0} or cannot be cured",
				["Outbreak"] = "Outbreak of {0} infected {1} players",
				["Eradicate"] = "Cured all players of {0}",
				["NoEradicate"] = "No players are infected with {0}",
				["Load"] = "Loaded disease {0}",
				["NoLoad"] = "Failed to load disease {0}, it is either already loaded or file is invalid",
				["Unload"] = "Unloaded disease {0}",
				["NoUnload"] = "Failed to unload disease {0}, it is not currently loaded",
				["List"] = "Loaded diseases: {0}",
				["NoExist"] = "The disease {0} is not currently loaded or doesn't exist on this server",
				["NoExist"] = "The disease {0} is not currently loaded or doesn't exist on this server",
				["NoPlayer"] = "There is no active player with the name {0}",
				["StatInfected"] = "Players infected: {0}",
				["StatInfectedTotal"] = "Total players infected: {0}",
				["StatKilled"] = "Total players killed: {0}",
				["Death"] = "{0} died from {1}",
				["Invalid"] = "Invalid command, try /disease help for a list of commands",
				["Treated"] = "Treated"
			}, this);
		}

		private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

		private string Color(string text, string colorCode)
		{
			return $"<color={colorCode}>{text}</color>";
		}

		private string Size(string text, string fontSize)
		{
			return $"<size={fontSize}>{text}</size>";
		}
		#endregion

		#region UI
		string COLOR_RED = "0.79 0.29 0.23 0.8";
		string COLOR_YELLOW = "0.79 0.59 0.23 0.8";

		void RefreshIndicator(BasePlayer player)
		{
			HideAllIndicators(player);
			CuiElementContainer container = new CuiElementContainer();
			container.Add(new CuiElement
			{
				Name = "diseasesIndicator",
				Parent = "Hud",
				Components =
				{
					new CuiImageComponent
					{
						Color = "0 0 0 0"
					},
					new CuiRectTransformComponent
					{
						AnchorMin = config.IndicatorHUD.AnchorMin,
						AnchorMax = config.IndicatorHUD.AnchorMax
					}
				}
			});
			int index = 0;
			foreach (String diseasename in diseaseManager.GetPlayerInfections(player))
			{
				Disease disease = diseaseManager.GetDisease(diseasename);
				if (disease != null)
				{
					AddIndicator(container, player, disease, index);
					index++;
				}
			}
			CuiHelper.AddUi(player, container);
		}

		void AddIndicator(CuiElementContainer container, BasePlayer player, Disease disease, int index)
		{
			float entryHeight = config.IndicatorHUD.EntryHeight;
			float padding = 0.02f;
			float bottom = 1 - ((padding + entryHeight) * (index + 1));
			string color = diseaseManager.HasImmunity(player, disease) ? COLOR_YELLOW : COLOR_RED;
			string txtcolor = diseaseManager.HasTreatment(player, disease) ? "0 1 0 1" : "1 1 1 1";
			string text = disease.name.ToUpper();
			if (diseaseManager.HasTreatment(player, disease))
				text += $" ({Lang("Treated", player.UserIDString)})";
			container.Add(new CuiElement
			{
				Name = "diseasesIndicatorEntry" + index.ToString(),
				Parent = "diseasesIndicator",
				Components =
				{
					new CuiImageComponent
					{
						Color = color
					},
					new CuiRectTransformComponent
					{
						AnchorMin = CalcUI(0, bottom),
						AnchorMax = CalcUI(1, bottom+entryHeight)
					}
				}
			});
			if (config.IndicatorHUD.ImgShow && ImageLibrary)
			{
				container.Add(new CuiElement
				{
					Name = "diseasesIndicatorEntryImage" + index.ToString(),
					Parent = "diseasesIndicatorEntry" + index.ToString(),
					Components =
					{
					new CuiRawImageComponent
					{
						Png = ImageLibrary?.Call<string>("GetImage", "DiseaseIndicatorIcon"),
						Color = "0.5 0.5 0.5 1"
					},
					new CuiRectTransformComponent
					{
						AnchorMin = config.IndicatorHUD.ImgAnchorMin,
						AnchorMax = config.IndicatorHUD.ImgAnchorMax
					}
					}
				});
			}

			container.Add(new CuiElement
			{
				Name = "diseasesIndicatorEntryText" + index.ToString(),
				Parent = "diseasesIndicatorEntry" + index.ToString(),
				Components =
				{
					new CuiTextComponent
					{
						Text = text,
						Align = (config.IndicatorHUD.ImgShow && ImageLibrary)? TextAnchor.MiddleLeft : TextAnchor.MiddleCenter,
						FontSize = 10,
						Color = txtcolor
					},
					new CuiRectTransformComponent
					{
						AnchorMin = (config.IndicatorHUD.ImgShow && ImageLibrary)?  "0.175 0" : "0 0",
						AnchorMax = (config.IndicatorHUD.ImgShow && ImageLibrary)? "0.99 1" : "1 1"
					}
				}
			});
		}

		void HideAllIndicators(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, "diseasesIndicator");
		}

		string CalcUI(float left, float right)
		{
			return $"{left} {right}";
		}
		#endregion
	}
}


// --- End of file: Diseases.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/donation-claim ---
// --- Original File Path: D/DonationClaim/DonationClaim.cs ---

// Reference: Oxide.Core.MySql

using System;
using System.Collections.Generic;
using System.Text;
using Oxide.Core.Database;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("DonationClaim", "Wulf/lukespragg", "1.0.2", ResourceId = 1923)]
    [Description("Players can claim rewards for automatic PayPal donations")]

    class DonationClaim : CovalencePlugin
    {
        readonly Core.MySql.Libraries.MySql mySql = new Core.MySql.Libraries.MySql();
        Connection connection;
        DefaultConfig config;

        #region Configuration

        class DefaultConfig
        {
            readonly List<string> exampleCommands = new List<string>();
            public readonly Dictionary<string, List<string>> Packages = new Dictionary<string, List<string>>();

            public DefaultConfig()
            {
                exampleCommands.Add("grant user {0} some.permission");
                exampleCommands.Add("grant user {0} another.permission");
                Packages.Add("Example", exampleCommands);
                Packages.Add("VIP", exampleCommands);
            }

            public string DatabaseHost = "localhost";
            public int DatabasePort = 3306;
            public string DatabaseName = "oxide";
            public string DatabaseUser = "root";
            public string DatabasePassword = "changeme";
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config.Clear();
            config = new DefaultConfig();
            Config.WriteObject(config, true);
            SaveConfig();
        }

        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>            {
                ["Claimed"] = "You claimed the {0} donation package. Thank you for your donation!",
                ["NoPackage"] = "Package {0} could not be found! Please notify an admin",
                ["NoUnclaimed"] = "No unclaimed rewards available for email address: {0}"
            }, this);
        }

        #endregion

        void Init()
        {
            try
            {
                config = Config.ReadObject<DefaultConfig>();
            }
            catch
            {
                PrintWarning("Could not read config, creating new default config");
                LoadDefaultConfig();
            }

            LoadDefaultMessages();
        }

        [Command("claim", "claimdonation", "claimreward")]
        void ChatCommand(IPlayer player, string command, string[] args)
        {
            var playerEmail = string.Join("", args).Replace("@", "@@");
            string packageClaimed;

            connection = mySql.OpenDb(config.DatabaseHost, config.DatabasePort, config.DatabaseName, config.DatabaseUser, config.DatabasePassword, this);
            var sql = Sql.Builder.Append($"call {config.DatabaseName}.claim_donation('" + playerEmail + "');");
            mySql.Query(sql, connection, list =>
            {
                var sb = new StringBuilder();
                foreach (var entry in list)
                {
                    sb.AppendFormat("{0}", entry["item_name"]);
                    sb.AppendLine();
                }

                packageClaimed = sb.ToString();
                var packageKey = GetPackageKey(packageClaimed, config.Packages);

                if (packageClaimed.Length < 3)
                {
                    player.Reply(Lang("NoUnclaimed", player.Id, playerEmail));
                }
                else
                {
                    List<string> consoleCommands;
                    if (config.Packages.TryGetValue(packageKey, out consoleCommands))
                    {
                        RunConsoleCommands(consoleCommands, player.Id);
                        player.Reply(Lang("Claimed", player.Id, packageClaimed));
                        Puts($"{player} has claimed donation package {packageClaimed}");
                    }
                    else
                    {
                        player.Reply(Lang("NoPackage", player.Id, packageClaimed));
                        Puts($"{player} tried to claim {packageClaimed}, but the package could not be found in the config!");
                    }
                }
            });
        }

        static string GetPackageKey(string packageName, Dictionary<string, List<string>> packages)
        {
            foreach (var entry in packages)
                if (packageName.Contains(entry.Key)) return entry.Key;
            return "";
        }

        void RunConsoleCommands(List<string> commandsList, string playerName)
        {
            foreach (var command in commandsList) server.Command(string.Format(command, playerName));
        }

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
    }
}

// --- End of file: DonationClaim.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-commands ---
// --- Original File Path: D/DiscordCommands/DiscordCommands.cs ---

ï»¿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;

namespace Oxide.Plugins
{
    [Info("Discord Commands", "MJSU", "2.1.1")]
    [Description("Allows using discord to execute commands")]
    internal class DiscordCommands : CovalencePlugin, IDiscordPlugin
    {
        #region Class Fields
        public DiscordClient Client { get; set; }

        private PluginConfig _pluginConfig; //Plugin Config

        private const string UsePermission = "discordcommands.use";

        private readonly DiscordCommand _dcCommands = Interface.Oxide.GetLibrary<DiscordCommand>();

        private readonly BotConnection _discordSettings = new BotConnection
        {
            Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers | GatewayIntents.MessageContent
        };

        private readonly Hash<Snowflake, StringBuilder> _playerLogs = new();
        private DiscordGuild _guild;

        private bool _logActive;
        
        private enum RestrictionMode {Blacklist, Whitelist}
        #endregion

        #region Setup & Loading
        private void Init()
        {
            permission.RegisterPermission(UsePermission, this);
            
            _discordSettings.ApiToken = _pluginConfig.DiscordApiKey;
            _discordSettings.LogLevel = _pluginConfig.ExtensionDebugging;
            
            if (_pluginConfig.CommandSettings.AllowInDm)
            {
                _discordSettings.Intents |= GatewayIntents.DirectMessages;
            }
            
            if (_pluginConfig.CommandSettings.AllowInGuild)
            {
                _discordSettings.Intents |= GatewayIntents.GuildMessages;
            }
            
            if (_pluginConfig.CommandSettings.Restrictions.EnableRestrictions)
            {
                foreach (string command in _pluginConfig.CommandSettings.Restrictions.Restrictions.Keys.ToList())
                {
                    _pluginConfig.CommandSettings.Restrictions.Restrictions[command.ToLower()] = _pluginConfig.CommandSettings.Restrictions.Restrictions[command];
                }
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.NoPermission] = "You do not have permission to use this command",
                [LangKeys.Blacklisted] = "This command is blacklisted and you do not have permission to use it.",
                [LangKeys.WhiteListedNotAdded] = "This command is not added to the command whitelist and cannot be used.",
                [LangKeys.WhiteListedNoPermission] = "You do not have the whitelisted permission to use this command.",
                [LangKeys.CommandInfoText] = "To execute a command on the server",
                [LangKeys.RanCommand] = "Ran Command: {0}",
                [LangKeys.ExecCommand] = "exec",
                [LangKeys.CommandLogging] = "{0} ran command '{1}'",
                [LangKeys.CommandHelpText] = "Send commands to the rust server:\n" +
                                             "Type /{0} {{command}} - to execute that command on the server\n" +
                                             "Example: /{0} o.reload DiscordCommand"
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.CommandSettings = new CommandSettings(config.CommandSettings);
            config.LogSettings = new LogSettings(config.LogSettings);
            return config;
        }

        private void OnServerInitialized()
        {
            if (string.IsNullOrEmpty(_pluginConfig.DiscordApiKey))
            {
                PrintWarning("Please set the Discord Bot Token and reload the plugin");
                return;
            }
            
            RegisterDiscordLangCommand(nameof(ExecCommand), LangKeys.ExecCommand, _pluginConfig.CommandSettings.AllowInDm, _pluginConfig.CommandSettings.AllowInGuild, _pluginConfig.CommandSettings.AllowedChannels);
            Client.Connect(_discordSettings);
        }

        private void Unload()
        {
            UnityEngine.Application.logMessageReceived -= HandleCommandLog;
        }
        
        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            _guild = null;
            if (ready.Guilds.Count == 1 && !_pluginConfig.GuildId.IsValid())
            {
                _guild = ready.Guilds.Values.FirstOrDefault();
            }

            if (_guild == null)
            {
                _guild = ready.Guilds[_pluginConfig.GuildId];
                if (_guild == null)
                {
                    PrintError("Failed to find a matching guild for the Discord Server Id. " +
                               "Please make sure your guild Id is correct and the bot is in the discord server.");
                    return;
                }
            }
            
            ApplicationFlags appFlags = Client.Bot.Application.Flags ?? ApplicationFlags.None;
            if (!appFlags.HasFlag(ApplicationFlags.GatewayMessageContentLimited) && !appFlags.HasFlag(ApplicationFlags.GatewayMessageContent))
            {
                PrintWarning($"You will need to enable \"Message Content Intent\" for {Client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n by April 2022." +
                             $" {Name} will stop function correctly after that date until that is fixed. Once updated please reload {Name}.");
            }
            
            Puts("Discord Commands Ready");
        }
        #endregion

        #region Discord Chat Command
        private void ExecCommand(DiscordMessage message, string cmd, string[] args)
        {
            IPlayer player = message.Author.Player;
            GuildMember member = _guild.Members[message.Author.Id];
            if (!HasCommandPermissions(message))
            {
                message.Reply(Client, Lang(LangKeys.NoPermission, player));
                return;
            }

            if (args.Length == 0)
            {
                message.Reply(Client, Lang(LangKeys.CommandHelpText, player, Lang(LangKeys.ExecCommand, player)));
                return;
            }
            
            string command = args[0];
            string[] commandArgs = args.Skip(1).ToArray();
            string commandString = string.Join(" ", args);

            if (!CanRunCommand(message, command, player, member))
            {
                return;
            }
            
            RunCommand(message, command, commandArgs, player, member, commandString);
        }
        
        public bool HasCommandPermissions(DiscordMessage message)
        {
            IPlayer player = message.Author.Player;
            if (player != null && player.HasPermission(UsePermission))
            {
                return true;
            }

            if (message.Member != null)
            {
                foreach (Snowflake role in _pluginConfig.CommandSettings.AllowedRoles)
                {
                    if (message.Member.Roles.Contains(role))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private bool CanRunCommand(DiscordMessage message, string command, IPlayer player, GuildMember member)
        {
            CommandRestrictions restrictions = _pluginConfig.CommandSettings.Restrictions;
            if (restrictions.EnableRestrictions)
            {
                if (restrictions.RestrictionMode == RestrictionMode.Blacklist && restrictions.Restrictions.ContainsKey(command.ToLower()))
                {
                    RestrictionSettings restriction = restrictions.Restrictions[command.ToLower()];
                    if (!IsPlayerAllowed(player, member, restriction))
                    {
                        message.Reply(Client, Lang(LangKeys.Blacklisted, player));
                        return false;
                    }
                }
                else if (restrictions.RestrictionMode == RestrictionMode.Whitelist)
                {
                    if (!restrictions.Restrictions.ContainsKey(command.ToLower()))
                    {
                        message.Reply(Client, Lang(LangKeys.WhiteListedNotAdded, player));
                        return false;
                    }

                    RestrictionSettings restriction = restrictions.Restrictions[command.ToLower()];
                    if (!IsPlayerAllowed(player, member, restriction))
                    {
                        message.Reply(Client, Lang(LangKeys.WhiteListedNoPermission, player));
                        return false;
                    }
                }
            }

            return true;
        }

        private static bool IsPlayerAllowed(IPlayer player, GuildMember member, RestrictionSettings restriction)
        {
            bool allowed = false;
            if (player != null)
            {
                foreach (string group in restriction.AllowedGroups)
                {
                    if (player.BelongsToGroup(group))
                    {
                        allowed = true;
                        break;
                    }
                }
            }

            if (!allowed && member != null)
            {
                foreach (Snowflake roleId in member.Roles)
                {
                    if (restriction.AllowedRoles.Contains(roleId))
                    {
                        allowed = true;
                        break;
                    }
                }
            }

            return allowed;
        }

        private void RunCommand(DiscordMessage message, string command, string[] commandArgs, IPlayer player, GuildMember member, string commandString)
        {
            if (_pluginConfig.LogSettings.DisplayServerLog)
            {
                if (!_logActive)
                {
                    UnityEngine.Application.logMessageReceived += HandleCommandLog;
                    _logActive = true;
                }

                _playerLogs[message.Id] = new StringBuilder();

                timer.In(_pluginConfig.LogSettings.DisplayServerLogDuration, () =>
                {
                    StringBuilder sb = _playerLogs[message.Id];
                    //Message content length is 2k characters
                    if (sb.Length > 2000)
                    {
                        sb.Length = 2000;
                    }
                    message.Reply(Client, sb.ToString());
                    _playerLogs.Remove(message.Id);

                    if (_playerLogs.Count == 0)
                    {
                        UnityEngine.Application.logMessageReceived -= HandleCommandLog;
                        _logActive = false;
                    }
                });
            }

            server.Command(command, commandArgs);
            message.Reply(Client, Lang(LangKeys.RanCommand, player, commandString));

            string log = Lang(LangKeys.CommandLogging, player, player?.Name ?? member?.Nickname ?? $"{member?.User.Username}#{member?.User.Discriminator}", commandString);

            if (_pluginConfig.LogSettings.LoggingChannel.IsValid())
            {
                DiscordMessage.Create(Client, _pluginConfig.LogSettings.LoggingChannel, log);
            }

            if (_pluginConfig.LogSettings.LogToConsole)
            {
                Puts(log);
            }
        }

        #endregion

        #region Log Handler
        private void HandleCommandLog(string message, string stackTrace, UnityEngine.LogType type)
        {
            foreach (StringBuilder sb in _playerLogs.Values)
            {
                sb.AppendLine(message);
            }
        }
        #endregion

        #region Helper Methods
        public void RegisterDiscordLangCommand(string command, string langKey, bool direct, bool guild, List<Snowflake> allowedChannels)
        {
            if (direct)
            {
                _dcCommands.AddDirectMessageLocalizedCommand(langKey, this, command);
            }

            if (guild)
            {
                _dcCommands.AddGuildLocalizedCommand(langKey, this, allowedChannels, command);
            }
        }

        public string Lang(string key, IPlayer player = null)
        {
            return lang.GetMessage(key, this, player?.Id);
        }
        
        public string Lang(string key, IPlayer player = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, player?.Id), args);
            }
            catch (Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception\n:{ex}");
                throw;
            }
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string DiscordApiKey { get; set; }
            
            [JsonProperty(PropertyName = "Discord Server ID (Optional if bot only in 1 guild)")]
            public Snowflake GuildId { get; set; }

            [JsonProperty(PropertyName = "Command Settings")]
            public CommandSettings CommandSettings { get; set; }

            [JsonProperty(PropertyName = "Log Settings")]
            public LogSettings LogSettings { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; }
        }
        
        private class LogSettings 
        {
            [JsonProperty(PropertyName = "Log command usage in server console")]
            public bool LogToConsole { get; set; }
            
            [JsonProperty(PropertyName = "Command Usage Logging Channel ID")]
            public Snowflake LoggingChannel { get; set; }

            [JsonProperty(PropertyName = "Display Server Log Messages to user after running command")]
            public bool DisplayServerLog { get; set; }
            
            [JsonProperty(PropertyName = "Display Server Log Messages Duration (Seconds)")]
            public float DisplayServerLogDuration { get; set; }

            public LogSettings(LogSettings settings)
            {
                LogToConsole = settings?.LogToConsole ?? true;
                LoggingChannel = settings?.LoggingChannel ?? default(Snowflake);
                DisplayServerLog = settings?.DisplayServerLog ?? true;
                DisplayServerLogDuration = settings?.DisplayServerLogDuration ?? 1f;
            }
        }

        private class CommandSettings
        {
            [JsonProperty(PropertyName = "Allow Discord Commands In Direct Messages")]
            public bool AllowInDm { get; set; }
            
            [JsonProperty(PropertyName = "Allow Discord Commands In Guild")]
            public bool AllowInGuild { get; set; }

            [JsonProperty(PropertyName = "Allow Guild Commands Only In The Following Guild Channel Or Category (Channel ID Or Category ID)")]
            public List<Snowflake> AllowedChannels { get; set; }

            [JsonProperty(PropertyName = "Allow Commands for members having role (Role ID)")]
            public List<Snowflake> AllowedRoles { get; set; }

            public CommandRestrictions Restrictions { get; set; }

            public CommandSettings(CommandSettings settings)
            {
                AllowInDm = settings?.AllowInDm ?? true;
                AllowInGuild = settings?.AllowInGuild ?? false;
                AllowedChannels = settings?.AllowedChannels ?? new List<Snowflake>();
                AllowedRoles = settings?.AllowedRoles ??  new List<Snowflake>();
                Restrictions = new CommandRestrictions(settings?.Restrictions);
            }
        }

        private class CommandRestrictions
        {
            [JsonProperty(PropertyName = "Enable Command Restrictions")]
            public bool EnableRestrictions { get; set; }

            [JsonProperty(PropertyName = "Blacklist = listed commands cannot be used without permission, Whitelist = Cannot use any commands unless listed and have permission")]
            [JsonConverter(typeof(StringEnumConverter))]
            public RestrictionMode RestrictionMode { get; set; }

            [JsonProperty(PropertyName = "Command Restrictions")]
            public Hash<string, RestrictionSettings> Restrictions { get; set; }

            public CommandRestrictions(CommandRestrictions settings)
            {
                EnableRestrictions = settings?.EnableRestrictions ?? false;
                RestrictionMode = settings?.RestrictionMode ?? RestrictionMode.Blacklist;
                Restrictions = settings?.Restrictions ?? new Hash<string, RestrictionSettings>
                {
                    ["command"] = new RestrictionSettings
                    {
                        AllowedGroups = new List<string> { "admin" },
                        AllowedRoles = new List<Snowflake> { new Snowflake(1234512321) }
                    }
                };
            }
        }

        private class RestrictionSettings
        {
            [JsonProperty(PropertyName = "Allowed Discord Roles")]
            public List<Snowflake> AllowedRoles { get; set; }

            [JsonProperty(PropertyName = "Allowed Server Groups")]
            public List<string> AllowedGroups { get; set; }
        }

        private static class LangKeys
        {
            public const string CommandInfoText = nameof(CommandInfoText);
            public const string CommandHelpText = nameof(CommandHelpText) + "V2";
            public const string RanCommand = nameof(RanCommand);
            public const string CommandLogging = nameof(CommandLogging);
            public const string ExecCommand = nameof(ExecCommand);
            public const string NoPermission = nameof(NoPermission);
            public const string Blacklisted = nameof(Blacklisted);
            public const string WhiteListedNotAdded = nameof(WhiteListedNotAdded);
            public const string WhiteListedNoPermission = nameof(WhiteListedNoPermission);
        }
        #endregion
    }
}

// --- End of file: DiscordCommands.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/dynamic-population ---
// --- Original File Path: D/DynamicPopulation/DynamicPopulation.cs ---

using Connection = Network.Connection;
using Oxide.Core.Libraries.Covalence;
using Exception = System.Exception;
using System.Collections.Generic;
using Newtonsoft.Json;
using ConVar;

namespace Oxide.Plugins {
    [Info("Dynamic Population", "Aspectdev", "2.1.6")]
    [Description("Automatically manage server MaxPlayers with customization options.")]
    class DynamicPopulation : CovalencePlugin {
        #region Fields

		public class PluginToggles {
			public bool Enable_Plugin = false;
			public bool Enable_Queueing = true;
			public bool OverageIsQueue = true;
			public bool FPS_Limiting = true;
			public bool Enable_Logs = true;
		};

		public class BaseServerVariables {
			public int Server_MinPlayers = 175;
			public int Server_MaxPlayers = 250;
			public int Average_FPS_Limit = 15;
		};

		public class DecreasePopOptions {
			public int Decrease_Pop_Threshold = 10;
			public int Pop_Decrease_Amount = 5;
		};

		public class QueuedEnabledOptions {
			public int Queue_Increase_Threshold = 10;
			public int Pop_Increase_Amount = 5;
		};

		public class QueueingDisabledOptions {
			public int Increase_Pop_Threshold = 5;
			public int Pop_Increase_Amount = 5;
		};

        private static Configuration _config;
        private class Configuration {
			public PluginToggles PluginToggles = new PluginToggles();
			public BaseServerVariables BaseServerVariables = new BaseServerVariables();
			public DecreasePopOptions DecreasePopOptions = new DecreasePopOptions();
			public QueuedEnabledOptions QueuedEnabledOptions = new QueuedEnabledOptions();
			public QueueingDisabledOptions QueueingDisabledOptions = new QueueingDisabledOptions();
        }

        #endregion

        #region Init

        private void Init() {
			if ( !_config.PluginToggles.Enable_Queueing && _config.QueueingDisabledOptions.Increase_Pop_Threshold > _config.DecreasePopOptions.Decrease_Pop_Threshold) {
				PrintError("Increase_Pop_Threshold cannot be greater than Decrease_Pop_Threshold, loading default config.");
				LoadDefaultConfig();
			};

			if (!_config.PluginToggles.Enable_Plugin) {
				PrintError("Config Variable enable_plugin is set to false. Please set your server's environmental variables and then reload the plugin.");
				Unsubscribe(nameof(OnPlayerConnected));
				Unsubscribe(nameof(CanClientLogin));
				Unsubscribe(nameof(OnPlayerDisconnected));
			};
        }

        #endregion

        #region Hooks

        void OnPlayerConnected(BasePlayer player) {
            UpdatePop();
        }

        void CanClientLogin(Connection connection) {
            UpdatePop();
        }

        void OnPlayerDisconnected(BasePlayer player, string reason) {
            UpdatePop();
        }

        #endregion

        #region Config

        protected override void LoadConfig() {
			base.LoadConfig();
			_config = Config.ReadObject<Configuration>();
			if (_config == null) throw new Exception();
			SaveConfig();
        }

		protected override void SaveConfig() => Config.WriteObject(_config);
		protected override void LoadDefaultConfig() => _config = new Configuration();

		#endregion

		# region Functions

        private void UpdatePop()
        {
			int PlaceHolder_Current_Players = covalence.Server.Players + ConVar.Admin.ServerInfo().Joining;
			int Base_Current_Player_Amount = (_config.PluginToggles.Enable_Queueing) ? PlaceHolder_Current_Players : PlaceHolder_Current_Players + ConVar.Admin.ServerInfo().Queued;
			int Base_Max_Player_Capacity = covalence.Server.MaxPlayers;
			int Base_Queued_Players = (_config.PluginToggles.OverageIsQueue) ? (Base_Current_Player_Amount - Base_Max_Player_Capacity) + ConVar.Admin.ServerInfo().Queued : ConVar.Admin.ServerInfo().Queued;

			float AverageServerFPS = Performance.current.frameRateAverage;

			int Manipulated_Max_Player_Capacity = Base_Max_Player_Capacity;
			int Manipulated_Queued_Players = Base_Queued_Players;

			if (Manipulated_Max_Player_Capacity < _config.BaseServerVariables.Server_MinPlayers || Manipulated_Max_Player_Capacity > _config.BaseServerVariables.Server_MaxPlayers) {
				Manipulated_Max_Player_Capacity = (Manipulated_Max_Player_Capacity < _config.BaseServerVariables.Server_MinPlayers) ? _config.BaseServerVariables.Server_MinPlayers : _config.BaseServerVariables.Server_MaxPlayers;
			};

			if (_config.PluginToggles.FPS_Limiting ? AverageServerFPS > _config.BaseServerVariables.Average_FPS_Limit : true) {
				if (_config.PluginToggles.Enable_Queueing) {
					if (Manipulated_Queued_Players >= _config.QueuedEnabledOptions.Queue_Increase_Threshold && Manipulated_Max_Player_Capacity + _config.QueuedEnabledOptions.Pop_Increase_Amount <= _config.BaseServerVariables.Server_MaxPlayers) {
						for (int i = 0; i < 50; i++) {
							bool IncreaseCheck = (Manipulated_Queued_Players >= _config.QueuedEnabledOptions.Queue_Increase_Threshold && Manipulated_Max_Player_Capacity + _config.QueuedEnabledOptions.Pop_Increase_Amount <= _config.BaseServerVariables.Server_MaxPlayers);
							if (!IncreaseCheck) break;
							Manipulated_Max_Player_Capacity += _config.QueuedEnabledOptions.Pop_Increase_Amount;
							Manipulated_Queued_Players -= _config.QueuedEnabledOptions.Pop_Increase_Amount;
						};
					};
				} else {
					if (Manipulated_Max_Player_Capacity - Base_Current_Player_Amount <= _config.QueueingDisabledOptions.Increase_Pop_Threshold && Manipulated_Max_Player_Capacity + _config.QueueingDisabledOptions.Pop_Increase_Amount <= _config.BaseServerVariables.Server_MaxPlayers) {
						for (int i = 0; i < 50; i++) {
							bool IncreaseCheck = (Manipulated_Max_Player_Capacity - Base_Current_Player_Amount <= _config.QueueingDisabledOptions.Increase_Pop_Threshold && Manipulated_Max_Player_Capacity + _config.QueueingDisabledOptions.Pop_Increase_Amount <= _config.BaseServerVariables.Server_MaxPlayers);
							if (!IncreaseCheck) break;
							Manipulated_Max_Player_Capacity += _config.QueueingDisabledOptions.Pop_Increase_Amount;
						};
					};
				};
			};

			if (Manipulated_Max_Player_Capacity - Base_Current_Player_Amount >= _config.DecreasePopOptions.Decrease_Pop_Threshold && Base_Max_Player_Capacity - _config.DecreasePopOptions.Pop_Decrease_Amount >= _config.BaseServerVariables.Server_MinPlayers) {
				for (int i = 0; i < 50; i++) {
					bool DecreaseCheck = (Manipulated_Max_Player_Capacity - Base_Current_Player_Amount > _config.DecreasePopOptions.Decrease_Pop_Threshold && Manipulated_Max_Player_Capacity - _config.DecreasePopOptions.Pop_Decrease_Amount >= _config.BaseServerVariables.Server_MinPlayers);
					if (!DecreaseCheck) break;
					Manipulated_Max_Player_Capacity -= _config.DecreasePopOptions.Pop_Decrease_Amount;
				};
			};

			if (Manipulated_Max_Player_Capacity != Base_Max_Player_Capacity) SendUpdateRequest(Base_Max_Player_Capacity, Manipulated_Max_Player_Capacity);
        }

		private void SendUpdateRequest(int oldMaxPop, int newMaxPop) {
			if (_config.PluginToggles.Enable_Logs) Puts(string.Format("{0} Max Pop from {1} to {2}", (oldMaxPop > newMaxPop) ? "Decreasing" : "Increasing", oldMaxPop, newMaxPop));
			covalence.Server.Command(string.Format("server.maxplayers {0}", newMaxPop));
		}

		#endregion
    }
}

// --- End of file: DynamicPopulation.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/drone-boombox ---
// --- Original File Path: D/DroneBoombox/DroneBoombox.cs ---

ï»¿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Drone Boombox", "WhiteThunder", "1.0.2")]
    [Description("Allows players to deploy boomboxes onto RC drones.")]
    internal class DroneBoombox : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private Plugin DroneSettings;

        private static DroneBoombox _pluginInstance;
        private Configuration _pluginConfig;

        private const string PermissionDeploy = "droneboombox.deploy";
        private const string PermissionDeployFree = "droneboombox.deploy.free";
        private const string PermissionAutoDeploy = "droneboombox.autodeploy";

        private const string BoomboxPrefab = "assets/prefabs/voiceaudio/boombox/boombox.static.prefab";
        private const string DeployEffectPrefab = "assets/prefabs/voiceaudio/boombox/effects/boombox-deploy.prefab";

        private const int PortableBoomboxItemId = 576509618;
        private const int DeployableBoomboxItemId = -1113501606;

        private const BaseEntity.Slot BoomboxSlot = BaseEntity.Slot.UpperModifier;

        private static readonly Vector3 BoomboxLocalPosition = new Vector3(0, 0.21f, 0.17f);
        private static readonly Quaternion BoomboxLocalRotation = Quaternion.Euler(270, 0, 0);

        // Subscribe to these hooks while there are boombox drones.
        private DynamicHookSubscriber<NetworkableId> _boomboxDroneTracker = new DynamicHookSubscriber<NetworkableId>(
            nameof(OnEntityKill),
            nameof(OnEntityTakeDamage),
            nameof(CanPickupEntity),
            nameof(canRemove)
        );

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginInstance = this;

            permission.RegisterPermission(PermissionDeploy, this);
            permission.RegisterPermission(PermissionDeployFree, this);
            permission.RegisterPermission(PermissionAutoDeploy, this);

            _boomboxDroneTracker.UnsubscribeAll();
        }

        private void Unload()
        {
            _pluginInstance = null;
        }

        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null || !IsDroneEligible(drone))
                    continue;

                var droneBoombox = GetDroneBoombox(drone);
                if (droneBoombox == null)
                    continue;

                SetupDroneBoombox(drone, droneBoombox);
            }
        }

        private void OnEntityBuilt(Planner planner, GameObject go)
        {
            if (planner == null || go == null)
                return;

            var drone = go.ToBaseEntity() as Drone;
            if (drone == null)
                return;

            var player = planner.GetOwnerPlayer();
            if (player == null)
                return;

            NextTick(() =>
            {
                // Delay this check to allow time for other plugins to deploy an entity to this slot.
                if (drone == null || player == null || drone.GetSlot(BoomboxSlot) != null)
                    return;

                if (permission.UserHasPermission(player.UserIDString, PermissionAutoDeploy))
                {
                    DeployBoombox(drone, player);
                }
                else if (permission.UserHasPermission(player.UserIDString, PermissionDeploy)
                    && UnityEngine.Random.Range(0, 100) < _pluginConfig.TipChance)
                {
                    ChatMessage(player, Lang.TipDeployCommand);
                }
            });
        }

        private void OnEntityKill(Drone drone)
        {
            _boomboxDroneTracker.Remove(drone.net.ID);
        }

        private void OnEntityKill(DeployableBoomBox boombox)
        {
            var drone = GetParentDrone(boombox);
            if (drone == null)
                return;

            _boomboxDroneTracker.Remove(drone.net.ID);
            drone.Invoke(() => RefreshDroneSettingsProfile(drone), 0);
        }

        // Redirect damage from the boombox to the drone.
        private bool? OnEntityTakeDamage(DeployableBoomBox boombox, HitInfo info)
        {
            var drone = GetParentDrone(boombox);
            if (drone == null)
                return null;

            drone.Hurt(info);
            HitNotify(drone, info);

            return true;
        }

        private bool? CanPickupEntity(BasePlayer player, Drone drone)
        {
            if (CanPickupInternal(player, drone))
                return null;

            ChatMessage(player, Lang.ErrorCannotPickupWithCassette);
            return false;
        }

        // This hook is exposed by plugin: Remover Tool (RemoverTool).
        private string canRemove(BasePlayer player, Drone drone)
        {
            if (CanPickupInternal(player, drone))
                return null;

            return GetMessage(player, Lang.ErrorCannotPickupWithCassette);
        }

        // This hook is exposed by plugin: Drone Settings (DroneSettings).
        private string OnDroneTypeDetermine(Drone drone)
        {
            return GetDroneBoombox(drone) != null ? Name : null;
        }

        #endregion

        #region API

        private DeployableBoomBox API_DeployBoombox(Drone drone, BasePlayer player)
        {
            if (GetDroneBoombox(drone) != null
                || drone.GetSlot(BoomboxSlot) != null
                || DeployBoomboxWasBlocked(drone, player))
                return null;

            return DeployBoombox(drone, player);
        }

        #endregion

        #region Commands

        [Command("droneboombox", "dronebb")]
        private void DroneBoomboxCommand(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer)
                return;

            var basePlayer = player.Object as BasePlayer;
            if (!basePlayer.CanInteract())
                return;

            Drone drone;
            if (!VerifyPermission(player, PermissionDeploy)
                || !VerifyDroneFound(player, out drone)
                || !VerifyCanBuild(player, drone)
                || !VerifyDroneHasNoBoombox(player, drone)
                || !VerifyDroneHasSlotVacant(player, drone))
                return;

            Item boomboxPaymentItem = null;

            if (!player.HasPermission(PermissionDeployFree))
            {
                boomboxPaymentItem = FindPlayerBoomboxItem(basePlayer);
                if (boomboxPaymentItem == null)
                {
                    ReplyToPlayer(player, Lang.ErrorNoBoomboxItem);
                    return;
                }
            }

            if (DeployBoomboxWasBlocked(drone, basePlayer))
                return;

            if (DeployBoombox(drone, basePlayer) == null)
            {
                ReplyToPlayer(player, Lang.ErrorDeployFailed);
                return;
            }

            if (boomboxPaymentItem != null)
                UseItem(basePlayer, boomboxPaymentItem);
        }

        #endregion

        #region Helper Methods - Command Checks

        private bool VerifyPermission(IPlayer player, string perm)
        {
            if (player.HasPermission(perm))
                return true;

            ReplyToPlayer(player, Lang.ErrorNoPermission);
            return false;
        }

        private bool VerifyDroneFound(IPlayer player, out Drone drone)
        {
            var basePlayer = player.Object as BasePlayer;
            drone = GetLookEntity(basePlayer, 3) as Drone;
            if (drone != null && IsDroneEligible(drone))
                return true;

            ReplyToPlayer(player, Lang.ErrorNoDroneFound);
            return false;
        }

        private bool VerifyCanBuild(IPlayer player, Drone drone)
        {
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer.CanBuild() && basePlayer.CanBuild(drone.WorldSpaceBounds()))
                return true;

            ReplyToPlayer(player, Lang.ErrorBuildingBlocked);
            return false;
        }

        private bool VerifyDroneHasNoBoombox(IPlayer player, Drone drone)
        {
            if (GetDroneBoombox(drone) == null)
                return true;

            ReplyToPlayer(player, Lang.ErrorAlreadyHasBoombox);
            return false;
        }

        private bool VerifyDroneHasSlotVacant(IPlayer player, Drone drone)
        {
            if (drone.GetSlot(BoomboxSlot) == null)
                return true;

            ReplyToPlayer(player, Lang.ErrorIncompatibleAttachment);
            return false;
        }

        #endregion

        #region Helper Method

        private static bool DeployBoomboxWasBlocked(Drone drone, BasePlayer deployer)
        {
            object hookResult = Interface.CallHook("OnDroneBoomboxDeploy", drone, deployer);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool IsDroneEligible(Drone drone) =>
            drone.skinID == 0 && !(drone is DeliveryDrone);

        private static BaseEntity GetLookEntity(BasePlayer basePlayer, float maxDistance = 3)
        {
            RaycastHit hit;
            return Physics.Raycast(basePlayer.eyes.HeadRay(), out hit, maxDistance, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore)
                ? hit.GetEntity()
                : null;
        }

        private static Drone GetParentDrone(BaseEntity entity) =>
            entity.GetParentEntity() as Drone;

        private static DeployableBoomBox GetDroneBoombox(Drone drone) =>
            drone.GetSlot(BoomboxSlot) as DeployableBoomBox;

        private static bool CanPickupInternal(BasePlayer player, Drone drone)
        {
            if (!IsDroneEligible(drone))
                return true;

            var boombox = GetDroneBoombox(drone);
            if (boombox == null)
                return true;

            // Prevent drone pickup while it has a boombox with a cassette in it (the cassette must be removed first).
            if (boombox != null && !boombox.inventory.IsEmpty() && !boombox.inventory.IsLocked())
                return false;

            return true;
        }

        private static void HitNotify(BaseEntity entity, HitInfo info)
        {
            var player = info.Initiator as BasePlayer;
            if (player == null)
                return;

            entity.ClientRPCPlayer(null, player, "HitNotify");
        }

        private static void RunOnEntityBuilt(Item boomboxItem, DeployableBoomBox boombox) =>
            Interface.CallHook("OnEntityBuilt", boomboxItem.GetHeldEntity(), boombox.gameObject);

        private static void UseItem(BasePlayer basePlayer, Item item, int amountToConsume = 1)
        {
            item.UseItem(amountToConsume);
            basePlayer.Command("note.inv", item.info.itemid, -amountToConsume);
        }

        private static Item FindPlayerBoomboxItem(BasePlayer basePlayer) =>
            basePlayer.inventory.FindItemByItemID(PortableBoomboxItemId) ??
            basePlayer.inventory.FindItemByItemID(DeployableBoomboxItemId);

        private void RefreshDroneSettingsProfile(Drone drone)
        {
            _pluginInstance.DroneSettings?.Call("API_RefreshDroneProfile", drone);
        }

        private void SetupDroneBoombox(Drone drone, DeployableBoomBox boombox)
        {
            // Damage will be processed by the drone.
            boombox.baseProtection = null;

            // These boomboxes should not decay while playing, since that would damage the drone.
            // Default is 0.025 for the static boomboxes, even though it's 0 for other deployable boomboxes.
            boombox.BoxController.ConditionLossRate = 0;

            RefreshDroneSettingsProfile(drone);
            _boomboxDroneTracker.Add(drone.net.ID);
        }

        private DeployableBoomBox DeployBoombox(Drone drone, BasePlayer basePlayer)
        {
            var boombox = GameManager.server.CreateEntity(BoomboxPrefab, BoomboxLocalPosition, BoomboxLocalRotation) as DeployableBoomBox;
            if (boombox == null)
                return null;

            if (basePlayer != null)
                boombox.OwnerID = basePlayer.userID;

            boombox.SetParent(drone);
            boombox.Spawn();

            drone.SetSlot(BoomboxSlot, boombox);
            SetupDroneBoombox(drone, boombox);

            Effect.server.Run(DeployEffectPrefab, boombox.transform.position);
            Interface.CallHook("OnDroneBoomboxDeployed", drone, boombox, basePlayer);

            if (basePlayer == null)
                return boombox;

            // Allow other plugins to detect the boombox being deployed (e.g., to set a default station).
            var boomboxItem = FindPlayerBoomboxItem(basePlayer);
            if (boomboxItem != null)
            {
                RunOnEntityBuilt(boomboxItem, boombox);
            }
            else
            {
                // Temporarily increase the player inventory capacity to ensure there is enough space.
                basePlayer.inventory.containerMain.capacity++;
                var temporaryItem = ItemManager.CreateByItemID(DeployableBoomboxItemId);
                if (basePlayer.inventory.GiveItem(temporaryItem))
                {
                    RunOnEntityBuilt(temporaryItem, boombox);
                    temporaryItem.RemoveFromContainer();
                }
                temporaryItem.Remove();
                basePlayer.inventory.containerMain.capacity--;
            }

            return boombox;
        }

        #endregion

        #region Dynamic Hook Subscriptions

        private class DynamicHookSubscriber<T>
        {
            private HashSet<T> _list = new HashSet<T>();
            private string[] _hookNames;

            public DynamicHookSubscriber(params string[] hookNames)
            {
                _hookNames = hookNames;
            }

            public void Add(T item)
            {
                if (_list.Add(item) && _list.Count == 1)
                    SubscribeAll();
            }

            public void Remove(T item)
            {
                if (_list.Remove(item) && _list.Count == 0)
                    UnsubscribeAll();
            }

            public void SubscribeAll()
            {
                foreach (var hookName in _hookNames)
                    _pluginInstance.Subscribe(hookName);
            }

            public void UnsubscribeAll()
            {
                foreach (var hookName in _hookNames)
                    _pluginInstance.Unsubscribe(hookName);
            }
        }

        #endregion

        #region Configuration

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("TipChance")]
            public int TipChance = 25;
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Boilerplate

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion

        #region Localization

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player.IPlayer, messageName), args));

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private string GetMessage(BasePlayer player, string messageName, params object[] args) =>
            GetMessage(player.UserIDString, messageName, args);

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private class Lang
        {
            public const string TipDeployCommand = "Tip.DeployCommand";
            public const string ErrorNoPermission = "Error.NoPermission";
            public const string ErrorNoDroneFound = "Error.NoDroneFound";
            public const string ErrorBuildingBlocked = "Error.BuildingBlocked";
            public const string ErrorNoBoomboxItem = "Error.NoBoomboxItem";
            public const string ErrorAlreadyHasBoombox = "Error.AlreadyHasBoombox";
            public const string ErrorIncompatibleAttachment = "Error.IncompatibleAttachment";
            public const string ErrorDeployFailed = "Error.DeployFailed";
            public const string ErrorCannotPickupWithCassette = "Error.CannotPickupWithCassette";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.TipDeployCommand] = "Tip: Look at the drone and run <color=yellow>/droneboombox</color> to deploy a boombox.",
                [Lang.ErrorNoPermission] = "You don't have permission to do that.",
                [Lang.ErrorNoDroneFound] = "Error: No drone found.",
                [Lang.ErrorBuildingBlocked] = "Error: Cannot do that while building blocked.",
                [Lang.ErrorNoBoomboxItem] = "Error: You need a boombox to do that.",
                [Lang.ErrorAlreadyHasBoombox] = "Error: That drone already has a boombox.",
                [Lang.ErrorIncompatibleAttachment] = "Error: That drone has an incompatible attachment.",
                [Lang.ErrorDeployFailed] = "Error: Failed to deploy boombox.",
                [Lang.ErrorCannotPickupWithCassette] = "Cannot pick up that drone while its boombox contains a cassette.",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: DroneBoombox.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/dynamic-config ---
// --- Original File Path: D/DynamicConfig/DynamicConfig.cs ---

using Oxide.Core;
using System.Collections.Generic;
using System;
using System.Text.RegularExpressions;
using System.IO;
using System.Linq;
using System.Text;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
    [Info("Dynamic Config", "FastBurst", "1.0.5")]
    [Description("Dynamically changes configs of other plugins depending on time from last wipe")]
    class DynamicConfig : RustPlugin
    {
        private static DynamicConfig Instance;
        private ConfigLibrary configLibrary;
        private Timer updateTimer;
        private DynamicConfigFile configHandler;
        private DateTime WipeDate;

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["WipeDate"] = "Detected last wipe at: {0}",
                ["NoConfigs"] = "There is no configs found, please create them in {0}",
                ["FoundPlugin"] = "\"{0}\": {1}",
                ["TimePassed"] = "Time passed from last wipe: {0}",
                ["ErrorTimeSpan"] = "Invalid config name: \"{0}\", unable to parse time span",
                ["Update"] = "Updating \"{0}\"",
                ["InvalidPlugin"] = "Plugin \"{0}\" doesn't exist, check the filename \"{1}\"",
                ["Scan"] = "Scanning directory {0}",
                ["Total"] = "Added {0} configs",
                ["PluginNotUnloaded"] = "Plugin \"{0}\" was failed to unload",
                ["PluginNotLoaded"] = "Plugin \"{0}\" was failed to load",

            }, this);
        }

        private static string _(string message, params object[] args)
        {
            return string.Format(Instance.lang.GetMessages(Instance.lang.GetServerLanguage(), Instance)[message], args);
        }
        #endregion

        #region Hooks
        private void Init()
        {
            Instance = this;
            configHandler = new DynamicConfigFile(null); // We use it only to get read/write access to oxide/config directory via filename
        }

        private void OnServerInitialized()
        {
            var saveCreated = ConVar.Admin.ServerInfo().SaveCreatedTime;
            DateTime.TryParse(saveCreated, out this.WipeDate);
            WipeDate = this.WipeDate.ToLocalTime();
            Puts(_("WipeDate", this.WipeDate));
            Puts(_("TimePassed", TimeSpanToString(DateTime.Now.Subtract(this.WipeDate))));
            configLibrary = new ConfigLibrary();
            timer.Once(5, this.configLibrary.Update);
            updateTimer = timer.Every(60, this.configLibrary.Update);
        }

        private void Unload()
        {
            if (updateTimer != null && !this.updateTimer.Destroyed)
                updateTimer.Destroy();
            Instance = null;
        }
        #endregion

        #region Misc
        private static string DataPath
        {
            get
            {
                return $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Instance.Name}{Path.DirectorySeparatorChar}";
            }
        }

        private static DataFileSystem DFS
        {
            get
            {
                return Interface.Oxide.DataFileSystem;
            }
        }
        #endregion

        #region Functions
        class ConfigLibrary
        {
            Dictionary<string, PluginInfo> pluginInfos = new();

            public ConfigLibrary()
            {
                int i = 1;
                try
                {
                    Instance.Puts(_("Scan", DataPath));
                    var files = DFS.GetFiles(DataPath);
                    foreach (var file in files)
                    {
                        var filename = file.Split(Path.DirectorySeparatorChar).Last();
                        filename = Utility.GetFileNameWithoutExtension(filename);
                        Match timespanRegex = new Regex(@"(\d+?[dhm])+", RegexOptions.IgnoreCase).Match(filename);
                        string timeSpanStr;
                        TimeSpan timeSpan = new TimeSpan();
                        var pluginName = filename;
                        if (timespanRegex.Success)
                        {
                            timeSpanStr = timespanRegex.Groups[0].ToString();
                            if (!TryParseTimeSpan(timeSpanStr, out timeSpan))
                            {
                                Instance.PrintError(_("ErrorTimeSpan", filename));
                                continue;
                            }

                            pluginName = filename.Replace(timeSpanStr, "");
                        }

                        if (!Instance.plugins.Exists(pluginName) && !Interface.Oxide.LoadPlugin(pluginName))
                        {
                            Instance.PrintWarning(_("InvalidPlugin", pluginName, filename));
                            continue;
                        }

                        var applyTime = Instance.WipeDate.Add(timeSpan);
                        Instance.Puts($"{i}. {_("FoundPlugin", pluginName, applyTime)}");
                        if (!pluginInfos.ContainsKey(pluginName))
                            pluginInfos[pluginName] = new PluginInfo(pluginName);

                        pluginInfos[pluginName].AddConfig(filename, applyTime);
                        i++;
                    }
                }
                catch (Exception ex)
                {
                    Instance.PrintWarning($"Error: {ex.Message}");
                }

                if (pluginInfos.Count == 0)
                {
                    Instance.PrintWarning(_("NoConfigs", DataPath));
                }
                else
                {
                    Instance.Puts(_("Total", i - 1));
                }
            }

            public void Update()
            {
                foreach (var info in pluginInfos)
                    info.Value.Update();
            }
        }

        class PluginInfo
        {
            private string pluginName;
            private List<ConfigInfo> configs = new List<ConfigInfo>();
            public PluginInfo(string pluginName)
            {
                this.pluginName = pluginName;
            }

            public void AddConfig(string filename, DateTime applyTime)
            {
                configs.Add(new ConfigInfo(filename, applyTime));
                configs.Sort((a, b) => a.applyTime.CompareTo(b.applyTime));
            }

            public void Update()
            {
                var pastConfigs = this.configs.Where(cfg => cfg.applyTime < DateTime.Now);
                if (pastConfigs.Count() == 0 || pastConfigs.Last() == null || pastConfigs.Last().applied)
                    return;
                pastConfigs.Last().Load(pluginName);
            }
        }

        class ConfigInfo
        {
            public string filename;
            public DateTime applyTime;
            public bool applied = false;

            public ConfigInfo(string filename, DateTime applyTime)
            {
                this.filename = filename;
                this.applyTime = applyTime;
            }

            public void Load(string pluginName)
            {
                Instance.Puts(_("Update", pluginName));
                if (!Interface.Oxide.UnloadPlugin(pluginName))
                    Instance.PrintWarning(_("PluginNotUnloaded", pluginName));
                var path = $"{DataPath}{filename}";
                var newConfig = DFS.ReadObject<object>(path);
                Instance.configHandler.WriteObject(newConfig, true, GetConfigPath(pluginName));
                if (!Interface.Oxide.LoadPlugin(pluginName))
                    Instance.PrintWarning(_("PluginNotLoaded", pluginName));
                this.applied = true;
            }
        }
        #endregion       

        #region Utilities
        private static bool TryParseTimeSpan(string source, out TimeSpan timeSpan)
        {
            int hours = 0;
            int days = 0;
            int minutes = 0;

            Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
            Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);
            Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);

            if (h.Success)
                hours = Convert.ToInt32(h.Groups[1].ToString());

            if (d.Success)
                days = Convert.ToInt32(d.Groups[1].ToString());

            if (m.Success)
                minutes = Convert.ToInt32(m.Groups[1].ToString());

            source = source.Replace(hours + "h", string.Empty);
            source = source.Replace(days + "d", string.Empty);
            source = source.Replace(minutes + "m", string.Empty);

            if (!string.IsNullOrEmpty(source) || !(h.Success || d.Success || m.Success))
            {
                timeSpan = new TimeSpan();
                return false;
            }

            timeSpan = new TimeSpan(days, hours, minutes, 0);
            return true;
        }

        private static string TimeSpanToString(TimeSpan timeSpan)
        {
            var result = new StringBuilder();
            if (timeSpan.Days > 0)
                result.Append($"{timeSpan.Days}d");

            if (timeSpan.Hours > 0)
                result.Append($"{timeSpan.Hours}h");

            if (timeSpan.Minutes > 0)
                result.Append($"{timeSpan.Minutes}m");

            return result.ToString();
        }

        private static string GetConfigPath(string pluginName)
        {
            return $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{pluginName}.json";
        }
        #endregion
    }
}

// --- End of file: DynamicConfig.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-pm ---
// --- Original File Path: D/DiscordPM/DiscordPM.cs ---

ï»¿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.Builders;
using Oxide.Ext.Discord.Cache;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;
using Oxide.Ext.Discord.Types;

#if RUST
using UnityEngine;
#endif

namespace Oxide.Plugins
{
    // ReSharper disable once UnusedType.Global
    [Info("Discord PM", "MJSU", "3.0.0")]
    [Description("Allows private messaging through discord")]
    internal class DiscordPM : CovalencePlugin, IDiscordPlugin, IDiscordPool
    {
        #region Class Fields
        public DiscordClient Client { get; set; }
        public DiscordPluginPool Pool { get; set; }
        
        private PluginConfig _pluginConfig;

        private const string AccentColor = "de8732";
        private const string PmCommand = "pm";
        private const string ReplyCommand = "r";
        private const string NameArg = "name";
        private const string MessageArg = "message";

        private readonly DiscordPlaceholders _placeholders = GetLibrary<DiscordPlaceholders>();
        private readonly DiscordMessageTemplates _templates = GetLibrary<DiscordMessageTemplates>();
        private readonly DiscordCommandLocalizations _localizations = GetLibrary<DiscordCommandLocalizations>();

        private readonly Hash<string, IPlayer> _replies = new();

        private readonly BotConnection  _discordSettings = new()
        {
            Intents = GatewayIntents.Guilds
        };

        private DiscordChannel _logChannel;
        private DiscordApplicationCommand _pmCommand;
        
#if RUST
        private Effect _effect;
#endif
        #endregion

        #region Setup & Loading
        // ReSharper disable once UnusedMember.Local
        private void Init()
        {
            RegisterServerLangCommand(nameof(DiscordPmChatCommand), LangKeys.ChatPmCommand);
            RegisterServerLangCommand(nameof(DiscordPmChatReplyCommand), LangKeys.ChatReplyCommand);

            _discordSettings.ApiToken = _pluginConfig.DiscordApiKey;
            _discordSettings.LogLevel = _pluginConfig.ExtensionDebugging;
        }

        [HookMethod(DiscordExtHooks.OnDiscordClientCreated)]
        private void OnDiscordClientCreated()
        {
            Client.Connect(_discordSettings);
                
            RegisterPlaceholders();
            RegisterGlobalTemplates();
            RegisterEnTemplates();
            RegisterRuTemplates();
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Chat] = $"[#BEBEBE][[#{AccentColor}]{Title}[/#]] {PlaceholderKeys.Chat}[/#]",
                [LangKeys.ToFormat] = $"[#BEBEBE][#{AccentColor}]PM to {DefaultKeys.PlayerTarget.NameClan}:[/#] {PlaceholderKeys.Message}[/#]",
                [LangKeys.FromFormat] = $"[#BEBEBE][#{AccentColor}]PM from {DefaultKeys.Player.NameClan}:[/#] {PlaceholderKeys.Message}[/#]",
                [LangKeys.LogFormat] = $"{DefaultKeys.Player.NameClan} -> {DefaultKeys.PlayerTarget.NameClan}: {PlaceholderKeys.Message}",
                
                [LangKeys.InvalidPmSyntax] = $"Invalid Syntax. Type [#{AccentColor}]/{DefaultKeys.Plugin.Lang.WithFormat(LangKeys.ChatPmCommand)} MJSU Hi![/#]",
                [LangKeys.InvalidReplySyntax] = $"Invalid Syntax. Ex: [#{AccentColor}]/{DefaultKeys.Plugin.Lang.WithFormat(LangKeys.ChatReplyCommand)} Hi![/#]",
                [LangKeys.NoPreviousPm] = $"You do not have any previous discord PM's. Please use /{DefaultKeys.Plugin.Lang.WithFormat(LangKeys.ChatPmCommand)} to be able to use this command.",
                [LangKeys.NoPlayersFound] = $"No players found with the name '{PlaceholderKeys.NotFound}'",
                [LangKeys.MultiplePlayersFound] = $"Multiple players found with the name '{PlaceholderKeys.NotFound}'.",

                [LangKeys.ChatPmCommand] = "pm",
                [LangKeys.ChatReplyCommand] = "r",
            }, this);
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Chat] = $"[#BEBEBE][[#{AccentColor}]{Title}[/#]] {PlaceholderKeys.Chat}[/#]",
                [LangKeys.ToFormat] = $"[#BEBEBE][#{AccentColor}]ÐÐ¡ Ð´Ð»Ñ {DefaultKeys.PlayerTarget.NameClan}:[/#] {PlaceholderKeys.Message}[/#]",
                [LangKeys.FromFormat] = $"[#BEBEBE][#{AccentColor}]ÐÐ¡ Ð¾Ñ {DefaultKeys.Player.NameClan}:[/#] {PlaceholderKeys.Message}[/#]",
                [LangKeys.LogFormat] = $"{DefaultKeys.Player.NameClan} -> {DefaultKeys.PlayerTarget.NameClan}: {PlaceholderKeys.Message}",
                
                [LangKeys.InvalidPmSyntax] = $"ÐÐµÐ´Ð¾Ð¿ÑÑÑÐ¸Ð¼ÑÐ¹ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸Ñ. ÐÐ²ÐµÐ´Ð¸ÑÐµ [#{AccentColor}]/{DefaultKeys.Plugin.Lang.WithFormat(LangKeys.ChatPmCommand)} MJSU, Ð¿ÑÐ¸Ð²ÐµÑ![/#]",
                [LangKeys.InvalidReplySyntax] = $"ÐÐµÐ´Ð¾Ð¿ÑÑÑÐ¸Ð¼ÑÐ¹ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸Ñ. ÐÑÐ¸Ð¼ÐµÑ: [#{AccentColor}]/{DefaultKeys.Plugin.Lang.WithFormat(LangKeys.ChatReplyCommand)} ÐÑÐ¸Ð²ÐµÑ![/#]",
                [LangKeys.NoPreviousPm] = $"Ð£ Ð²Ð°Ñ Ð½ÐµÑ Ð¿ÑÐµÐ´ÑÐ´ÑÑÐ¸Ñ Ð»Ð¸ÑÐ½ÑÑ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ð¹. ÐÐ¾Ð¶Ð°Ð»ÑÐ¹ÑÑÐ°, Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ /{DefaultKeys.Plugin.Lang.WithFormat(LangKeys.ChatPmCommand)} ÑÑÐ¾Ð±Ñ Ð¸Ð¼ÐµÑÑ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÑÑ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ.",
                [LangKeys.NoPlayersFound] = $"ÐÐ³ÑÐ¾ÐºÐ¸ Ñ Ð¸Ð¼ÐµÐ½ÐµÐ¼ '{PlaceholderKeys.NotFound}' Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ",
                [LangKeys.MultiplePlayersFound] = $"ÐÐ°Ð¹Ð´ÐµÐ½Ð¾ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð² Ñ Ð¸Ð¼ÐµÐ½ÐµÐ¼ '{PlaceholderKeys.NotFound}'.",

                [LangKeys.ChatPmCommand] = "pm",
                [LangKeys.ChatReplyCommand] = "r",
            }, this, "ru");
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Log = new LogSettings(config.Log);
            return config;
        }

        // ReSharper disable once UnusedMember.Local
        private void OnServerInitialized()
        {
            if (string.IsNullOrEmpty(_pluginConfig.DiscordApiKey))
            {
                PrintWarning("Please set the Discord Bot Token and reload the plugin");
                return;
            }

#if RUST
            if (_pluginConfig.EnableEffectNotification)
            {
                _effect = new Effect(_pluginConfig.EffectNotification, Vector3.zero, Vector3.zero);
                _effect.attached = true;
            }
#endif
        }
        #endregion

        #region Chat Commands
        // ReSharper disable once UnusedParameter.Local
        private void DiscordPmChatCommand(IPlayer player, string cmd, string[] args)
        {
            if (args.Length < 2)
            {
                Chat(player, LangKeys.InvalidPmSyntax, GetDefault());
                return;
            }

            IPlayer target;
            if (!TryFindPlayer(player, args[0], out target))
            {
                return;
            }

            _replies[player.Id] = target;
            _replies[target.Id] = player;

            string message = args.Length == 2 ? args[1] : string.Join(" ", args.Skip(1).ToArray());
            
            SendPrivateMessageFromServer(player, target, message);
        }

        // ReSharper disable once UnusedParameter.Local
        private void DiscordPmChatReplyCommand(IPlayer player, string cmd, string[] args)
        {
            if (args.Length < 1)
            {
                Chat(player, LangKeys.InvalidReplySyntax, GetDefault());
                return;
            }

            IPlayer target = _replies[player.Id];
            if (target == null)
            {
                Chat(player, LangKeys.NoPreviousPm, GetDefault());
                return;
            }
            
            string message = args.Length == 1 ? args[0] : string.Join(" ", args);
            SendPrivateMessageFromServer(player, target, message);
        }
        
        public void SendPrivateMessageFromServer(IPlayer sender, IPlayer target, string message)
        {
            using PlaceholderData data = GetPmDefault(sender, target, message);
            data.ManualPool();
            SendPlayerPrivateMessage(sender, LangKeys.ToFormat, TemplateKeys.Messages.To, data);
            SendPlayerPrivateMessage(target, LangKeys.FromFormat, TemplateKeys.Messages.From, data);
            LogPrivateMessage(data);
        }
        #endregion

        #region Discord Setup
        // ReSharper disable once UnusedMember.Local
        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady()
        {
            RegisterApplicationCommands();
            Puts($"{Title} Ready");
        }

        // ReSharper disable once UnusedMember.Local
        [HookMethod(DiscordExtHooks.OnDiscordGuildCreated)]
        private void OnDiscordGuildCreated(DiscordGuild guild)
        {
            _logChannel = guild.Channels[_pluginConfig.Log.LogToChannelId];
        }

        public void RegisterApplicationCommands()
        {
            CreatePmCommand();
            CreateReplyCommand();
        }

        public void CreatePmCommand()
        {
            ApplicationCommandBuilder pmCommand = new ApplicationCommandBuilder(PmCommand, "Private message a player", ApplicationCommandType.ChatInput)
                                                  .AddDefaultPermissions(PermissionFlags.None)
                                                  .AllowInDirectMessages(_pluginConfig.AllowInDm);
            AddCommandNameOption(pmCommand);
            AddCommandMessageOption(pmCommand);

            CommandCreate cmd = pmCommand.Build();
            DiscordCommandLocalization localization = pmCommand.BuildCommandLocalization();

            TemplateKey template = new("PM.Command");
            _localizations.RegisterCommandLocalizationAsync(this, template, localization, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0)).Then(_ =>
            {
                _localizations.ApplyCommandLocalizationsAsync(this, cmd, template).Then(() =>
                {
                    Client.Bot.Application.CreateGlobalCommand(Client, cmd).Then(c => _pmCommand = c);
                });
            });
        }

        public void CreateReplyCommand()
        {
            ApplicationCommandBuilder replyCommand = new ApplicationCommandBuilder(ReplyCommand, "Reply to the last received private message", ApplicationCommandType.ChatInput)
                                                     .AddDefaultPermissions(PermissionFlags.None)
                                                     .AllowInDirectMessages(_pluginConfig.AllowInDm);
            AddCommandMessageOption(replyCommand);

            CommandCreate cmd = replyCommand.Build();
            DiscordCommandLocalization localization = replyCommand.BuildCommandLocalization();

            TemplateKey template = new("Reply.Command");
            _localizations.RegisterCommandLocalizationAsync(this, template, localization, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0)).Then(_ =>
            {
                _localizations.ApplyCommandLocalizationsAsync(this, cmd, template).Then(() =>
                {
                    Client.Bot.Application.CreateGlobalCommand(Client, cmd);
                });
            });
        }

        public void AddCommandNameOption(ApplicationCommandBuilder builder)
        {
            builder.AddOption(CommandOptionType.String, NameArg, "Name of the player",
                options => options.Required().AutoComplete());
        }
        
        public void AddCommandMessageOption(ApplicationCommandBuilder builder)
        {
            builder.AddOption(CommandOptionType.String, MessageArg, "Message to send the player",
                options => options.Required());
        }
        #endregion

        #region Discord Commands
        // ReSharper disable once UnusedMember.Local
        [DiscordApplicationCommand(PmCommand)]
        private void HandlePmCommand(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            IPlayer player = interaction.User.Player;
            if (player == null)
            {
                interaction.CreateTemplateResponse(Client, InteractionResponseType.ChannelMessageWithSource, TemplateKeys.Errors.UnlinkedUser, GetInteractionCallback(interaction), GetDefault());
                return;
            }

            string targetId = parsed.Args.GetString(NameArg);
            string message = parsed.Args.GetString(MessageArg);

            IPlayer target = players.FindPlayerById(targetId);
            if (target == null)
            {
                interaction.CreateTemplateResponse(Client, InteractionResponseType.ChannelMessageWithSource, TemplateKeys.Errors.InvalidAutoCompleteSelection, GetInteractionCallback(interaction), GetDefault());
                return;
            }

            _replies[player.Id] = target;
            _replies[target.Id] = player;

            SendPrivateMessageFromDiscord(interaction, player, target, message);
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordApplicationCommand(ReplyCommand)]
        private void HandleReplyCommand(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            IPlayer player = interaction.User.Player;
            if (player == null)
            {
                interaction.CreateTemplateResponse(Client, InteractionResponseType.ChannelMessageWithSource, TemplateKeys.Errors.UnlinkedUser, GetInteractionCallback(interaction), GetDefault());
                return;
            }
            
            string message = parsed.Args.GetString(MessageArg);

            IPlayer target = _replies[player.Id];
            if (target == null)
            {
                interaction.CreateTemplateResponse(Client, InteractionResponseType.ChannelMessageWithSource, TemplateKeys.Errors.NoPreviousPm, GetInteractionCallback(interaction), GetDefault().AddCommand(_pmCommand));
                return;
            }
            
            _replies[target.Id] = player;
            
            SendPrivateMessageFromDiscord(interaction, player, target, message);
        }
        
        public void SendPrivateMessageFromDiscord(DiscordInteraction interaction, IPlayer player, IPlayer target, string message)
        {
            using PlaceholderData data = GetPmDefault(player, target, message);
            data.ManualPool();
            if (!interaction.GuildId.HasValue)
            {
                ServerPrivateMessage(player, LangKeys.ToFormat, data);
            }
            else
            {
                SendPlayerPrivateMessage(player, LangKeys.ToFormat, TemplateKeys.Messages.To, data);
            }
            interaction.CreateTemplateResponse(Client, InteractionResponseType.ChannelMessageWithSource, TemplateKeys.Messages.To, GetInteractionCallback(interaction), GetPmDefault(player, target, message));
            SendPlayerPrivateMessage(target, LangKeys.FromFormat, TemplateKeys.Messages.From, data);
            LogPrivateMessage(data);
        }

        // ReSharper disable once UnusedMember.Local
        [DiscordAutoCompleteCommand(PmCommand, NameArg)]
        private void HandleNameAutoComplete(DiscordInteraction interaction, InteractionDataOption focused)
        {
            string search = focused.GetString();
            InteractionAutoCompleteBuilder response = interaction.GetAutoCompleteBuilder();
            response.AddAllOnlineFirstPlayers(search, PlayerNameFormatter.ClanName);
            interaction.CreateResponse(Client, response);
        }

        public InteractionCallbackData GetInteractionCallback(DiscordInteraction interaction)
        {
            return new InteractionCallbackData
            {
                Flags = interaction.GuildId.HasValue ? MessageFlags.Ephemeral : MessageFlags.None
            };
        }
        #endregion

        #region Discord Placeholders
        public void RegisterPlaceholders()
        {
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.Message,  PlaceholderDataKeys.Message);
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.NotFound,  PlaceholderDataKeys.PlayerName);
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.Chat,  PlaceholderDataKeys.Chat);
        }

        public PlaceholderData GetPmDefault(IPlayer from, IPlayer to, string message)
        {
            return GetDefault()
                   .AddPlayer(from)
                   .AddTarget(to)
                   .Add(PlaceholderDataKeys.Message, message);
        }
        
        public PlaceholderData GetDefault()
        {
            return _placeholders.CreateData(this);
        }
        #endregion

        #region Discord Templates
        public void RegisterGlobalTemplates()
        {
            DiscordMessageTemplate logMessage = CreateTemplateEmbed($"[{DefaultKeys.TimestampNow.ShortTime}] {DefaultKeys.Player.NameClan} -> {DefaultKeys.PlayerTarget.NameClan}: {PlaceholderKeys.Message}", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Messages.Log, logMessage, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0 ,0));
        }
        
        public void RegisterEnTemplates()
        {
            DiscordMessageTemplate toMessage = CreateTemplateEmbed($"[{DefaultKeys.TimestampNow.ShortTime}] PM to {DefaultKeys.PlayerTarget.NameClan}: {PlaceholderKeys.Message}", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Messages.To, toMessage, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0 ,0));
            
            DiscordMessageTemplate fromMessage = CreateTemplateEmbed($"[{DefaultKeys.TimestampNow.ShortTime}] PM from {DefaultKeys.Player.NameClan}: {PlaceholderKeys.Message}", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Messages.From, fromMessage, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0 ,0));       
            
            DiscordMessageTemplate errorUnlinkedUser = CreatePrefixedTemplateEmbed("You cannot use this command until you're have linked your game and discord accounts", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.UnlinkedUser, errorUnlinkedUser, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0 ,0));
            
            DiscordMessageTemplate errorInvalidAutoComplete = CreatePrefixedTemplateEmbed("The name you have picked does not appear to be a valid auto complete value. Please make sure you select one of the auto complete options.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.InvalidAutoCompleteSelection, errorInvalidAutoComplete, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0 ,0));
            
            DiscordMessageTemplate errorNoPreviousPm = CreatePrefixedTemplateEmbed($"You do not have any previous discord PM's. Please use {DefaultKeys.AppCommand.Mention} to be able to use this command.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.NoPreviousPm, errorNoPreviousPm, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0 ,0));
        }

        public void RegisterRuTemplates()
        {
            DiscordMessageTemplate toMessage = CreateTemplateEmbed($"[{DefaultKeys.TimestampNow.ShortTime}] ÐÐ¡ Ð´Ð»Ñ {DefaultKeys.PlayerTarget.NameClan}: {PlaceholderKeys.Message}", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Messages.To, toMessage, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0 ,0), "ru");
            
            DiscordMessageTemplate fromMessage = CreateTemplateEmbed($"[{DefaultKeys.TimestampNow.ShortTime}] ÐÐ¡ Ð¾Ñ {DefaultKeys.Player.NameClan}: {PlaceholderKeys.Message}", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Messages.From, fromMessage, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0 ,0), "ru");       
            
            DiscordMessageTemplate errorUnlinkedUser = CreatePrefixedTemplateEmbed("ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÑÑ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ, Ð¿Ð¾ÐºÐ° Ð½Ðµ ÑÐ²ÑÐ¶ÐµÑÐµ Ð¸Ð³ÑÐ¾Ð²Ð¾Ð¹ Ð°ÐºÐºÐ°ÑÐ½Ñ Ñ Ð°ÐºÐºÐ°ÑÐ½ÑÐ¾Ð¼ Discord.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.UnlinkedUser, errorUnlinkedUser, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0 ,0), "ru");
            
            DiscordMessageTemplate errorInvalidAutoComplete = CreatePrefixedTemplateEmbed("ÐÐ¼Ñ, ÐºÐ¾ÑÐ¾ÑÐ¾Ðµ Ð²Ñ Ð²ÑÐ±ÑÐ°Ð»Ð¸, Ð½Ðµ ÑÐ²Ð»ÑÐµÑÑÑ Ð´Ð¾Ð¿ÑÑÑÐ¸Ð¼ÑÐ¼ Ð·Ð½Ð°ÑÐµÐ½Ð¸ÐµÐ¼ Ð°Ð²ÑÐ¾Ð·Ð°Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ. ÐÐ¾Ð¶Ð°Ð»ÑÐ¹ÑÑÐ°, ÑÐ±ÐµÐ´Ð¸ÑÐµÑÑ, ÑÑÐ¾ Ð²Ñ Ð²ÑÐ±Ð¸ÑÐ°ÐµÑÐµ Ð¾Ð´Ð¸Ð½ Ð¸Ð· Ð²Ð°ÑÐ¸Ð°Ð½ÑÐ¾Ð² Ð°Ð²ÑÐ¾Ð·Ð°Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.InvalidAutoCompleteSelection, errorInvalidAutoComplete, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0 ,0), "ru");
            
            DiscordMessageTemplate errorNoPreviousPm = CreatePrefixedTemplateEmbed($"Ð£ Ð²Ð°Ñ Ð½ÐµÑ Ð¿ÑÐµÐ´ÑÐ´ÑÑÐ¸Ñ Ð»Ð¸ÑÐ½ÑÑ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ð¹. ÐÐ¾Ð¶Ð°Ð»ÑÐ¹ÑÑÐ°, Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ {DefaultKeys.AppCommand.Mention}, ÑÑÐ¾Ð±Ñ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÑÑ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.NoPreviousPm, errorNoPreviousPm, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0 ,0), "ru");
        }
        
        public DiscordMessageTemplate CreateTemplateEmbed(string description, DiscordColor color)
        {
            return new DiscordMessageTemplate
            {
                Embeds = new List<DiscordEmbedTemplate>
                {
                    new()
                    {
                        Description = description,
                        Color = color.ToHex()
                    }
                }
            };
        }
        
        public DiscordMessageTemplate CreatePrefixedTemplateEmbed(string description, DiscordColor color)
        {
            return new DiscordMessageTemplate
            {
                Embeds = new List<DiscordEmbedTemplate>
                {
                    new()
                    {
                        Description = $"[{DefaultKeys.Plugin.Title}] {description}",
                        Color = color.ToHex()
                    }
                }
            };
        }
        #endregion
        
        #region Helpers
        public bool TryFindPlayer(IPlayer from, string name, out IPlayer target)
        {
            List<IPlayer> foundPlayers = Pool.GetList<IPlayer>();
            List<IPlayer> activePlayers = Pool.GetList<IPlayer>();
            List<IPlayer> linkedPlayers = Pool.GetList<IPlayer>();
            
            try
            {
                foreach (IPlayer player in ServerPlayerCache.Instance.GetOnlinePlayers(name))
                {
                    if (player.Name.Equals(name, StringComparison.OrdinalIgnoreCase))
                    {
                        target = player;
                        return true;
                    }
                
                    activePlayers.Add(player);
                }
            
                if (activePlayers.Count == 1)
                {
                    target = activePlayers[0];
                    return true;
                }
                
                IPlayer match = null;
                bool multiple = false;
                foreach (IPlayer player in ServerPlayerCache.Instance.GetAllPlayers(name))
                {
                    if (!multiple && player.Name.Equals(name, StringComparison.OrdinalIgnoreCase))
                    {
                        if (match == null)
                        {
                            match = player;
                        }
                        else
                        {
                            match = null;
                            multiple = true;
                        }
                    }
                
                    foundPlayers.Add(player);

                    if (player.IsLinked())
                    {
                        linkedPlayers.Add(player);
                    }

                    if (foundPlayers.Count > 1 && linkedPlayers.Count > 1)
                    {
                        break;
                    }
                }

                if (!multiple && match != null)
                {
                    target = match;
                    return true;
                }
                
                target = null;
                if (foundPlayers.Count == 1)
                {
                    target = foundPlayers[0];
                    return true;
                }
                
                if (linkedPlayers.Count == 1)
                {
                    target = linkedPlayers[0];
                    return true;
                }

                if (foundPlayers.Count > 1)
                {
                    Chat(from, LangKeys.MultiplePlayersFound, GetDefault().Add(PlaceholderDataKeys.PlayerName, name));
                    return false;
                }
                
                Chat(from, LangKeys.NoPlayersFound, GetDefault().Add(PlaceholderDataKeys.PlayerName, name));
                return false;
            }
            finally
            { 
                Pool.FreeList(foundPlayers);
                Pool.FreeList(linkedPlayers);
                Pool.FreeList(activePlayers);
            }
        }

        public void SendPlayerPrivateMessage(IPlayer player, string serverLang, TemplateKey templateKey, PlaceholderData data)
        {
            ServerPrivateMessage(player, serverLang, data);
            DiscordPrivateMessage(player, templateKey, data);
        }

        public void LogPrivateMessage(PlaceholderData data)
        {
            LogSettings settings = _pluginConfig.Log;
            if (!settings.LogToConsole && !settings.LogToFile && _logChannel == null)
            {
                return;
            }

            string log = Lang(LangKeys.LogFormat, null, data);
            if (_pluginConfig.Log.LogToConsole)
            {
                Puts(log);
            }

            if (_pluginConfig.Log.LogToFile)
            {
                LogToFile(string.Empty, log, this);
            }

            _logChannel?.CreateGlobalTemplateMessage(Client, TemplateKeys.Messages.Log, null, data);
        }
        
        public void SendEffectToPlayer(IPlayer player)
        {
#if RUST
            if (!_pluginConfig.EnableEffectNotification)
            {
                return;
            }
            
            if (!player.IsConnected)
            {
                return;
            }
            
            BasePlayer basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
            {
                return;
            }
            
            Effect effect = _effect;
            effect.entity = basePlayer.net.ID;
            
            EffectNetwork.Send(effect, basePlayer.net.connection);
#endif
        }
        
        public void ServerPrivateMessage(IPlayer player, string langKey, PlaceholderData data)
        {
            if (player.IsConnected && player.Object != null)
            {
                player.Message(Lang(langKey, player, data));
                SendEffectToPlayer(player);
            }
        }

        public void DiscordPrivateMessage(IPlayer player, TemplateKey templateKey, PlaceholderData data)
        {
            if (player.IsLinked())
            {
                player.SendDiscordTemplateMessage(Client, templateKey, null, data);
            }
        }

        public void RegisterServerLangCommand(string command, string langKey)
        {
            HashSet<string> registered = new();
            foreach (string langType in lang.GetLanguages(this))
            {
                Dictionary<string, string> langKeys = lang.GetMessages(langType, this);
                if (langKeys.TryGetValue(langKey, out string commandValue) && !string.IsNullOrEmpty(commandValue) && registered.Add(commandValue))
                {
                    AddCovalenceCommand(commandValue, command);
                }
            }
        }

        public void Chat(IPlayer player, string key, PlaceholderData data)
        {
            if (player.IsConnected)
            {
                player.Reply(Lang(LangKeys.Chat, player, GetDefault().Add(PlaceholderDataKeys.Chat, Lang(key, player, data))));
            }
        }
        
        public string Lang(string key, IPlayer player = null) => lang.GetMessage(key, this, player?.Id);

        public string Lang(string key, IPlayer player, PlaceholderData data)
        {
            string result = _placeholders.ProcessPlaceholders(Lang(key, player), data);
            return result;
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string DiscordApiKey { get; set; }

            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Allow Discord Commands In Direct Messages")]
            public bool AllowInDm { get; set; }

#if RUST
            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Enable Effect Notification")]
            public bool EnableEffectNotification { get; set; }
            
            [DefaultValue("assets/prefabs/tools/pager/effects/vibrate.prefab")]
            [JsonProperty(PropertyName = "Notification Effect")]
            public string EffectNotification { get; set; }
#endif

            [JsonProperty(PropertyName = "Log Settings")]
            public LogSettings Log { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; }
        }
        
        public class LogSettings
        {
            [JsonProperty(PropertyName = "Log To Console")]
            public bool LogToConsole { get; set; }

            [JsonProperty(PropertyName = "Log To File")]
            public bool LogToFile { get; set; }
            
            [JsonProperty(PropertyName = "Log To Channel ID")]
            public Snowflake LogToChannelId { get; set; }

            public LogSettings(LogSettings settings)
            {
                LogToConsole = settings?.LogToConsole ?? true;
                LogToFile = settings?.LogToFile ?? false;
                LogToChannelId = settings?.LogToChannelId ?? default(Snowflake);
            }
        }

        private static class LangKeys
        {
            public const string Base = "V3.";
            
            public const string Chat = Base + nameof(Chat);
            public const string FromFormat = Base + nameof(FromFormat);
            public const string ToFormat = Base + nameof(ToFormat);
            public const string InvalidPmSyntax = Base + nameof(InvalidPmSyntax);
            public const string InvalidReplySyntax = Base + nameof(InvalidReplySyntax);
            public const string NoPreviousPm = Base + nameof(NoPreviousPm);
            public const string MultiplePlayersFound =  Base + nameof(MultiplePlayersFound);
            public const string NoPlayersFound = Base + nameof(NoPlayersFound);
            public const string LogFormat = Base + nameof(LogFormat);

            public const string ChatPmCommand = Base + "Commands.Chat.PM";
            public const string ChatReplyCommand = Base + "Commands.Chat.Reply";
        }

        private static class TemplateKeys
        {
            public static class Messages
            {
                private const string Base = nameof(Messages) + ".";
                
                public static readonly TemplateKey To = new(Base + nameof(To));
                public static readonly TemplateKey From = new(Base + nameof(From));
                public static readonly TemplateKey Log = new(Base + nameof(Log));
            }
            
            public static class Errors
            {
                private const string Base = nameof(Errors) + ".";

                public static readonly TemplateKey UnlinkedUser = new(Base + nameof(UnlinkedUser));
                public static readonly TemplateKey InvalidAutoCompleteSelection = new(Base + nameof(InvalidAutoCompleteSelection));
                public static readonly TemplateKey NoPreviousPm = new(Base + nameof(NoPreviousPm));
            }
        }

        private static class PlaceholderKeys
        {
            public static readonly PlaceholderKey Message = new(nameof(DiscordPM), "message");
            public static readonly PlaceholderKey Chat = new(nameof(DiscordPM), "chat");
            public static readonly PlaceholderKey NotFound = new(nameof(DiscordPM), "player.notfound");
        }

        private class PlaceholderDataKeys
        {
            public static readonly PlaceholderDataKey Message = new("pm.message");
            public static readonly PlaceholderDataKey PlayerName = new("pm.name");
            public static readonly PlaceholderDataKey Chat = new("pm.chat");
        }
        #endregion
    }
}

// --- End of file: DiscordPM.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/door-limiter ---
// --- Original File Path: D/DoorLimiter/DoorLimiter.cs ---

ï»¿using System.Collections.Generic;
using UnityEngine;
using System;
using Oxide.Core;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("DoorLimiter", "redBDGR", "1.0.6", ResourceId = 2334)]
    [Description("Only allow a certain number of people to use one door")]
    class DoorLimiter : RustPlugin
    {
        bool Changed = false;

        public bool silentMode = false;
        public int authedPlayersAllowed = 5;
        public const string permissionName = "doorlimiter.exempt";
        public const string permissionNameADMIN = "doorlimiter.admin";
        public const string permissionNameREMOVE = "doorlimiter.remove";

        void Init()
        {
            permission.RegisterPermission(permissionName, this);
            permission.RegisterPermission(permissionNameADMIN, this);
            permission.RegisterPermission(permissionNameREMOVE, this);
            LoadVariables();
            DoLang();
        }

        void DoLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                //chat
                ["Max Authorised"] = "There are already too many players authorized to this door!",
                ["Auth Successful"] = "You have been successfully authorized to this door!",
                ["No Perms"] = "You are not allowed to use this command!",
                ["Invalid Syntax REMOVE"] = "Invalid syntax! /doorlimit remove <playername / id>",
                ["No Player Found"] = "No players with that name / steamid were found",
                ["No Entity Found"] = "No entity was found! make sure you are looking at a door",
                ["Entity Not Registered"] = "This door was not found in the database!",
                ["You Are Not The Owner"] = "You are not the owner of this door!",
                ["Player Not Authed To This Door"] = "The target player is not authorised to this door!",
                ["Player Removed"] = "The player was succesfully removed from the doors authorized list",
                ["doorlimit Help"] = "Type /doorlimit remove <playername / id> whilst looking at a door to remove them from the authorization list",

            }, this);
        }

        #region Handling

        object CanUseLockedEntity(BasePlayer player, BaseLock baselock)
        {
            if (player == null || baselock == null) return null;
            if (permission.UserHasPermission(player.UserIDString, permissionName)) return null;
            if (!(baselock.GetParentEntity() is BaseNetworkable)) return null;
            BaseNetworkable door = baselock.GetParentEntity() as BaseNetworkable;
            if (baselock.ShortPrefabName == "lock.code")
            {
                CodeLock codelock = (CodeLock)baselock;
                if (codelock.whitelistPlayers.Contains(player.userID))
                    return null;
                else
                {
                    if (codelock.whitelistPlayers.Count >= authedPlayersAllowed)
                    {
                        if (!silentMode)
                            player.ChatMessage(msg("Max Authorised", player.UserIDString));
                        return false;
                    }
                    else
                    {
                        if (!silentMode)
                            player.ChatMessage(msg("Auth Successful", player.UserIDString));
                        return null;
                    }
                }
            }
            else
                return null;
        }

        #endregion

        void LoadVariables()
        {
            silentMode = Convert.ToBoolean(GetConfig("Settings", "Silent Mode", true));
            authedPlayersAllowed = Convert.ToInt32(GetConfig("Settings", "Authed Players Allowed", 5));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        [ChatCommand("doorlimit")]
        void doorlimitCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionNameREMOVE))
            {
                player.ChatMessage(msg("No Perms", player.UserIDString));
                return;
            }

            if (args.Length == 2)
            {
                if (args[0] == "remove")
                {
                    RaycastHit hitInfo;
                    if (!UnityEngine.Physics.Raycast(player.eyes.HeadRay(), out hitInfo, 3.0f))
                    {
                        player.ChatMessage(msg("No Entity Found", player.UserIDString));
                        return;
                    }
                    BaseEntity entity = hitInfo.transform.GetComponentInParent<BaseEntity>();
                    if (!entity) return;
                    CodeLock codelock = entity as CodeLock;
                    if (!codelock) return;
                    if (codelock.OwnerID != player.userID)
                    {
                        player.ChatMessage(msg("You Are Not The Owner", player.UserIDString));
                        return;
                    }
                    BasePlayer targetplayer = FindPlayer(args[1]);
                    if (DoPlayerChecks(codelock, player) == false)
                        return;

                    codelock.whitelistPlayers.Remove(targetplayer.userID);
                    player.ChatMessage(msg("Player Removed", player.UserIDString));
                }
                else
                {
                    player.ChatMessage(msg("Invalid Syntax REMOVE", player.UserIDString));
                    return;
                }
            }
            else
                DoDoorLimitHelp(player);
        }

        bool DoPlayerChecks(CodeLock codelock, BasePlayer player)
        {
            if (player == null)
            {
                player.ChatMessage(msg("No Player Found", player.UserIDString));
                return false;
            }
            else if (!codelock.whitelistPlayers.Contains(player.userID))
            {
                player.ChatMessage(msg("Player Not Authed To This Door", player.UserIDString));
                return false;
            }
            else
                return true;
        }

        void DoDoorLimitHelp(BasePlayer player)
        {
            player.ChatMessage(msg("doorlimit Help", player.UserIDString));
            return;
        }

        private static BasePlayer FindPlayer(string nameOrId)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == nameOrId)
                    return activePlayer;
                if (activePlayer.displayName.Contains(nameOrId, CompareOptions.OrdinalIgnoreCase))
                    return activePlayer;
                if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress == nameOrId)
                    return activePlayer;
            }
            return null;
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        string msg(string key, string id = null) => lang.GetMessage(key, this, id);
    }
}

// --- End of file: DoorLimiter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/disable-temperature-functions ---
// --- Original File Path: D/DisableTemperatureFunctions/DisableTemperatureFunctions.cs ---

using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Disable Temperature Functions", "The Friendly Chap", "1.0.2")]
    [Description("Prevents cold/heat damage/overlay for players")]
    public class DisableTemperatureFunctions : RustPlugin
    {
        #region ConfigFileStuff
        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Debug Mode")]
            public bool debug = false;
            [JsonProperty(PropertyName = "Set Temprature to (°C)")]
            public float usertemp = 30.0f;
            [JsonProperty(PropertyName = "Use permission : ")]
            public bool usePerm = false;
        }

        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
                return false;
            }
            SaveConfig(configData);
            return true;
        }

        void Init()
        {
            if (!LoadConfigVariables())
            {
                Puts("Config file issue detected. Please delete file, or check syntax and fix.");
                return;
            }
            permission.RegisterPermission(permDisable, this);
        }
            

        protected override void LoadDefaultConfig()
        {
            Puts("Creating new config file.");
            configData = new ConfigData();
            SaveConfig(configData);
        }
        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }
        #endregion

        private const string permDisable = "disabletemperaturefunctions.use";
		
        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList.ToList())
            {
                OnPlayerSleepEnded(player);
            }
            
            foreach (var player in BasePlayer.sleepingPlayerList.ToList())
            {
                OnPlayerSleep(player);
            }
        }
        
        private void OnPlayerSleep(BasePlayer player)
        {
            Check(player);
        }
        
        private void OnPlayerSleepEnded(BasePlayer player)
        {
            Check(player);
        }

        private void FixTemp(BasePlayer player)
        {
            if (configData.debug) Puts($"Initial Values : {player.metabolism.temperature.max}, {player.metabolism.temperature.min}, {player.metabolism.temperature.value}");
            if (configData.debug) Puts($" Adjusting Tolerance for {player.displayName}");
            player.metabolism.temperature.max = configData.usertemp;
            player.metabolism.temperature.min = configData.usertemp;
            player.metabolism.temperature.value = configData.usertemp;
            player.SendNetworkUpdate();
            if (configData.debug) Puts($"Changed Values : {player.metabolism.temperature.max}, {player.metabolism.temperature.min}, {player.metabolism.temperature.value}");
            return;
        }

        private void Check(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, permDisable))
            {
                FixTemp(player);
                return;
            }
            else if (!configData.usePerm)
            {
                FixTemp(player);
                return;
            }
        }
    }
}

// --- End of file: DisableTemperatureFunctions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/dance ---
// --- Original File Path: D/Dance/Dance.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Dance", "senyaa", "1.2.0")]
    [Description("This plugin allows players to dance, even if they don't own a VoiceProps DLC")]
    class Dance : RustPlugin
    {
        #region Configuration
        private class PluginConfig
        {
            public uint[] gestureIds;
        }
        PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                gestureIds = new uint[] {478760625, 1855420636, 1702547860}
            };
        }

        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["notAllowed"] = "You are not allowed to use this command",
                ["usage"] = "Usage: /dance 1/2/3"
            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["notAllowed"] = "Ð£ Ð²Ð°Ñ Ð½ÐµÑ Ð´Ð¾ÑÑÑÐ¿Ð° Ðº ÑÑÐ¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ðµ",
                ["usage"] = "ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ: /dance 1/2/3"
            }, this, "ru");
            
        }
        #endregion

        private void Init()
        {
            permission.RegisterPermission("dance.use", this);
            config = Config.ReadObject<PluginConfig>();
        }
		
        private bool? CanUseGesture(BasePlayer player, GestureConfig gesture)
        {
            if (config.gestureIds.Contains(gesture.gestureId) && player.IPlayer.HasPermission("dance.use"))
                return true;
            return null;
        }
		
        [ChatCommand("dance")]
        private void DanceCommand(BasePlayer player, string command, string[] args)
        {
            if(args.Length != 1 || args[0].Length != 1 || !("123".Contains(args[0]))) {
				
                player.IPlayer.Reply(lang.GetMessage("usage", this, player.IPlayer.Id));
                return;
            }

            if (!player.IPlayer.HasPermission("dance.use"))
            {
                player.IPlayer.Reply(lang.GetMessage("notAllowed", this, player.IPlayer.Id));
                return;
            }
            
            foreach (var gesture in player.gestureList.AllGestures)
            {
                if (gesture.gestureId == config.gestureIds[Convert.ToInt64(args[0]) - 1])
                {
                    player.Server_StartGesture(gesture);
                }
            }
        }
    }
}

// --- End of file: Dance.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/door-logs ---
// --- Original File Path: D/DoorLogs/DoorLogs.cs ---

using Oxide.Core;
using System.Collections.Generic;
using UnityEngine;
using System;
using Newtonsoft.Json;
using System.Text.RegularExpressions;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Door Logs", "mvrb", "0.2.1")]
    [Description("Check who opens/closes doors.")]
    class DoorLogs : RustPlugin
    {
        private const string PermissionUse = "doorlogs.allowed";

        private StoredData storedData = new StoredData();

        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoDoorFound"] = "No door found.",
                ["NoDataFound"] = "No data found for this door.",
                ["DoorData"] = "Data for this door [{0}]: \n",
                ["Error: NoPermission"] = "You do not have permission to use this command."
            }, this);
        }

        private void OnServerInitialized()
        {
            LoadData();
            LoadVariables();

            permission.RegisterPermission(PermissionUse, this);
        }

        [ChatCommand("door")]
        private void ChatCmdCheckDoor(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            RaycastHit hit;
            var raycast = Physics.Raycast(player.eyes.HeadRay(), out hit, 15f, 2097409);
            BaseEntity door = raycast ? hit.GetEntity() : null;

            if (door == null || door as Door == null)
            {
                player.ChatMessage(Lang("NoDoorFound", player.UserIDString));
                return;
            }

            if (!storedData.Doors.ContainsKey(door.net.ID.Value) || storedData.Doors[door.net.ID.Value].Entries.Count == 0)
            {
                player.ChatMessage(Lang("NoDataFound", player.UserIDString));
                return;
            }

            int entries = 1;
            string msg1 = Lang("DoorData", player.UserIDString, door.net.ID);
            string msg2 = string.Empty;

            foreach (KeyValuePair<ulong, PlayerData> entry in storedData.Doors[door.net.ID.Value].Entries.Reverse())
            {
                string last = string.Empty;
                if (entry.Value.L > 0) last = $"L: <color=#FFA500>{UnixToDateTime(entry.Value.L)}</color>";

                if (entries < 6)
                {
                    msg1 += $"[{entries}] <color=#FFFF00>{GetNameFromId(entry.Key.ToString())}</color> ({entry.Key})\n ";
                    msg1 += $"F: <color=#FFA500>{UnixToDateTime(entry.Value.F)}</color> {last}\n";
                }
                else
                {
                    msg2 += $"[{entries}] <color=#FFFF00>{GetNameFromId(entry.Key.ToString())}</color> ({entry.Key})\n ";
                    msg2 += $"F: <color=#FFA500>{UnixToDateTime(entry.Value.F)}</color> {last}\n";
                }

                entries++;
            }

            player.ChatMessage(msg1);
            if (!string.IsNullOrEmpty(msg2)) player.ChatMessage(msg2);

            if (!configData.LogToConsole) return;

            msg1 = Regex.Replace(msg1, @"<color=#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})>|<\/color>", "");
            Puts(msg1);

            if (string.IsNullOrEmpty(msg2)) return;

            msg2 = Regex.Replace(msg2, @"<color=#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})>|<\/color>", "");
            Puts(msg2);
        }

        private void OnDoorClosed(Door door, BasePlayer player) => UpdateDoor(door, player);

        private void OnDoorOpened(Door door, BasePlayer player) => UpdateDoor(door, player);

        private void UpdateDoor(Door door, BasePlayer player)
        {
            if (door.OwnerID == 0) return;

            int timestamp = GetUnix();

            PlayerData playerData = new PlayerData();
            playerData.F = timestamp;

            if (!storedData.Doors.ContainsKey(door.net.ID.Value))
            {
                DoorData doorData = new DoorData();
                doorData.Entries.Add(player.userID, playerData);

                storedData.Doors.Add(door.net.ID.Value, doorData);
            }
            else
            {
                if (!storedData.Doors[door.net.ID.Value].Entries.ContainsKey(player.userID))
                {
                    storedData.Doors[door.net.ID.Value].Entries.Add(player.userID, playerData);
                }
                else
                {
                    storedData.Doors[door.net.ID.Value].Entries[player.userID].L = timestamp;
                }

                if (storedData.Doors[door.net.ID.Value].Entries.Count >= configData.MaxEntries)
                {
                    storedData.Doors[door.net.ID.Value].Entries.Remove(storedData.Doors[door.net.ID.Value].Entries.Keys.First());
                }
            }
        }

        private class StoredData
        {
            public readonly Dictionary<ulong, DoorData> Doors = new Dictionary<ulong, DoorData>();
        }

        private class DoorData
        {
            public readonly Dictionary<ulong, PlayerData> Entries = new Dictionary<ulong, PlayerData>();
        }

        private class PlayerData
        {
            public Int32 F, L;
        }

        #region Config
        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Log /door output to console")]
            public bool LogToConsole { get; set; }

            [JsonProperty(PropertyName = "Max entries to log per door")]
            public int MaxEntries { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                LogToConsole = false,
                MaxEntries = 10
            };

            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        private string UnixToDateTime(double unixTimeStamp) => new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc).AddSeconds(unixTimeStamp).ToLocalTime().ToString("MM/dd HH:mm:ss");

        private Int32 GetUnix() => (Int32)(DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;

        private string GetNameFromId(string id) => covalence.Players.FindPlayer(id)?.Name;

        private void LoadData() => storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Name);

        private void SaveData() => Interface.GetMod().DataFileSystem.WriteObject(this.Name, storedData);

        private void OnNewSave(string name)
        {
            PrintWarning("Map wipe detected - clearing DoorLogs...");

            storedData.Doors.Clear();
            SaveData();
        }

        private void OnServerSave() => SaveData();

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
    }
}

// --- End of file: DoorLogs.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/damage-mod-players ---
// --- Original File Path: D/DMPlayers/DMPlayers.cs ---

ï»¿using System.Collections.Generic;
using System;
using Rust;

namespace Oxide.Plugins
{
    [Info("DMPlayers", "ColonBlow", "1.2.5")]
    internal class DMPlayers : RustPlugin
    {
        private const int DamageTypeMax = (int)DamageType.LAST;
        private readonly float[] _modifiers = new float[DamageTypeMax];
        private bool _didConfigChange;

        private void Loaded() => LoadConfigValues();
        protected override void LoadDefaultConfig() => Puts("New configuration file created.");

        private void LoadConfigValues()
        {
            foreach (DamageType val in Enum.GetValues(typeof(DamageType)))
            {
                if (val == DamageType.LAST) continue;
                _modifiers[(int)val] = Convert.ToSingle(GetConfigValue("Player_Multipliers", val.ToString(), 1.0));
            }

            if (!_didConfigChange) return;
            Puts("Configuration file updated.");
            SaveConfig();
        }

        private object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                _didConfigChange = true;
            }

            if (data.TryGetValue(setting, out value)) return value;
            value = defaultValue;
            data[setting] = value;
            _didConfigChange = true;
            return value;
        }

        private void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (player.net?.connection?.authLevel >= 0 && hitInfo.damageTypes != null)
            {
                for (var i = 0; i < DamageTypeMax; i++)
                {
                    hitInfo.damageTypes.Scale((DamageType)i, _modifiers[i]);
                }
            }
        }
    }
}

// --- End of file: DMPlayers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/deathmatch ---
// --- Original File Path: D/Deathmatch/Deathmatch.cs ---

ï»¿// Requires: EventManager
using Newtonsoft.Json;
using Oxide.Plugins.EventManagerEx;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Deathmatch", "k1lly0u", "3.0.1"), Description("Deathmatch event mode for EventManager")]
    class Deathmatch : RustPlugin, IEventPlugin
    {
        #region Oxide Hooks
        private void OnServerInitialized()
        {
            EventManager.RegisterEvent(Title, this);

            GetMessage = Message;
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);
        
        private void Unload()
        {
            if (!EventManager.IsUnloading)
                EventManager.UnregisterEvent(Title);

            Configuration = null;
        }
        #endregion

        #region Event Checks
        public bool InitializeEvent(EventManager.EventConfig config) => EventManager.InitializeEvent<DeathmatchEvent>(this, config);
        
        public bool CanUseClassSelector => true;

        public bool RequireTimeLimit => true;

        public bool RequireScoreLimit => false;

        public bool UseScoreLimit => true;

        public bool UseTimeLimit => true;

        public bool IsTeamEvent => false;

        public void FormatScoreEntry(EventManager.ScoreEntry scoreEntry, ulong langUserId, out string score1, out string score2)
        {
            score1 = string.Format(Message("Score.Kills", langUserId), scoreEntry.value1);
            score2 = string.Format(Message("Score.Deaths", langUserId), scoreEntry.value2);
        }

        public List<EventManager.EventParameter> AdditionalParameters { get; } = new List<EventManager.EventParameter>
        {
            new EventManager.EventParameter
            {
                DataType = "bool",
                Field = "closeOnStart",
                Input = EventManager.EventParameter.InputType.Toggle,
                IsRequired = false,
                Name = "Close Event On Start",
                DefaultValue = false
            }
        };

        public string ParameterIsValid(string fieldName, object value) => null;
        #endregion

        #region Event Classes
        public class DeathmatchEvent : EventManager.BaseEventGame
        {
            public EventManager.BaseEventPlayer winner;

            internal override void PrestartEvent()
            {
                if (Config.GetParameter<bool>("closeEventOnStart"))
                    CloseEvent();

                base.PrestartEvent();
            }

            internal override void OnEventPlayerDeath(EventManager.BaseEventPlayer victim, EventManager.BaseEventPlayer attacker = null, HitInfo info = null)
            {
                if (victim == null)
                    return;

                victim.OnPlayerDeath(attacker, Configuration.RespawnTime);

                if (attacker != null && victim != attacker)
                {
                    attacker.OnKilledPlayer(info);

                    if (Config.ScoreLimit > 0 && attacker.Kills >= Config.ScoreLimit)
                    {
                        winner = attacker;
                        InvokeHandler.Invoke(this, EndEvent, 0.1f);
                        return;
                    }
                }

                UpdateScoreboard();
                base.OnEventPlayerDeath(victim, attacker);
            }

            protected override void GetWinningPlayers(ref List<EventManager.BaseEventPlayer> winners)
            {
                if (winner == null)
                {
                    if (eventPlayers.Count > 0)
                    {
                        int kills = 0;
                        int deaths = 0;

                        for (int i = 0; i < eventPlayers.Count; i++)
                        {
                            EventManager.BaseEventPlayer eventPlayer = eventPlayers[i];
                            if (eventPlayer == null)
                                continue;

                            if (eventPlayer.Kills > kills)
                            {
                                winner = eventPlayer;
                                kills = eventPlayer.Kills;
                                deaths = eventPlayer.Deaths;
                            }
                            else if (eventPlayer.Kills == kills)
                            {
                                if (eventPlayer.Deaths < deaths)
                                {
                                    winner = eventPlayer;
                                    kills = eventPlayer.Kills;
                                    deaths = eventPlayer.Deaths;
                                }
                            }
                        }
                    }
                }

                if (winner != null)
                    winners.Add(winner);
            }

            #region Scoreboards
            protected override void BuildScoreboard()
            {
                scoreContainer = EMInterface.CreateScoreboardBase(this);

                int index = -1;

                if (Config.ScoreLimit > 0)                
                    EMInterface.CreatePanelEntry(scoreContainer, string.Format(GetMessage("Score.Limit", 0UL), Config.ScoreLimit), index += 1);
                
                EMInterface.CreateScoreEntry(scoreContainer, string.Empty, "K", "D", index += 1);

                for (int i = 0; i < Mathf.Min(scoreData.Count, 15); i++)
                {
                    EventManager.ScoreEntry score = scoreData[i];
                    EMInterface.CreateScoreEntry(scoreContainer, score.displayName, ((int)score.value1).ToString(), ((int)score.value2).ToString(), i + index + 1);
                }
            }

            protected override float GetFirstScoreValue(EventManager.BaseEventPlayer eventPlayer) => eventPlayer.Kills;

            protected override float GetSecondScoreValue(EventManager.BaseEventPlayer eventPlayer) => eventPlayer.Deaths;

            protected override void SortScores(ref List<EventManager.ScoreEntry> list)
            {
                list.Sort(delegate (EventManager.ScoreEntry a, EventManager.ScoreEntry b)
                {
                    int primaryScore = a.value1.CompareTo(b.value1);

                    if (primaryScore == 0)
                        return a.value2.CompareTo(b.value2) * -1;

                    return primaryScore;
                });
            }
            #endregion
        }
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Respawn time (seconds)")]
            public int RespawnTime { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                RespawnTime = 5,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Localization
        public string Message(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId != 0U ? playerId.ToString() : null);
        
        private static Func<string, ulong, string> GetMessage;

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Score.Kills"] = "Kills: {0}",
            ["Score.Deaths"] = "Deaths: {0}",
            ["Score.Name"] = "Kills",
            ["Score.Limit"] = "Score Limit : {0}"
        };
        #endregion
    }
}


// --- End of file: Deathmatch.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bulletin-degree-tags ---
// --- Original File Path: D/DegreeTags/DegreeTags.cs ---

ï»¿// Requires: BetterChat
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Oxide.Plugins
{
    [Info("Bulletin Degree Tags", "Yoshi", 0.2)]
    class DegreeTags : CovalencePlugin
    {
        [PluginReference]
        private Plugin BetterChat;

        private void OnPluginLoaded(Plugin plugin)
        {
            Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(GetBulletinTags));
        }

        void OnServerInitialized()
        {

            UpdateDegreeCache();
            timer.Every(300f, () =>
            {
                UpdateDegreeCache();
            });

            BetterChat?.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(GetBulletinTags));
        }
    
        private string GetBulletinTags(IPlayer player)
        {
            List<Degrees> tagInfo = new List<Degrees>();
            if (playerDegrees.TryGetValue(Convert.ToUInt64(player.Id), out tagInfo))
            {
                string formatedString = "";

                if (config.highestDegree)
                {
                    var highestDegree = tagInfo.Last();
                    formatedString = covalence.FormatText($"[#{GetTagColor(highestDegree)}][{highestDegree}][/#]");
                }
                else
                {
                    foreach (var degree in tagInfo)
                        formatedString += covalence.FormatText($"[#{GetTagColor(degree)}][{degree}][/#] ");
                    formatedString = formatedString.Remove(formatedString.Length - 1, 1);
                }

                return formatedString;
            }

            return null;
        }

        private string GetTagColor(Degrees degree)
        {
            switch(degree)
            {
                case Degrees.Bachelors:
                    return config.BachelorsColor;
                case Degrees.Masters:
                    return config.MastersColor;
                case Degrees.PhD:
                    return config.PhDColor;
                case Degrees.Professor:
                    return config.ProfessorColor;
                default:
                    return config.BachelorsColor;
            }
        }

        Dictionary<ulong, List<Degrees>> playerDegrees = new Dictionary<ulong, List<Degrees>>();
        void UpdateDegreeCache()
        {
            webrequest.Enqueue("http://api.bbontop.com:5001/", null, (code, response) =>
            {
                if (code != 200 || response == null)
                {
                    Puts($"Couldn't get an answer from the bulletin API!");
                    return;
                }

                var degreeData = JsonConvert.DeserializeObject<List<DegreeData>>(response);
                foreach (var cache in degreeData)
                {
                    if(!playerDegrees.ContainsKey(cache.UserID))
                    {
                        playerDegrees.Add(cache.UserID, cache.Degrees);
                        continue;
                    }

                    foreach(var degree in cache.Degrees)
                    {
                        if (!playerDegrees[cache.UserID].Contains(degree))
                            playerDegrees[cache.UserID].Add(degree);
                    }    
                }

            }, this, RequestMethod.GET);

        }

        #region data

        public class DegreeData
        {
            public ulong UserID { get; set; }
            public List<Degrees> Degrees { get; set; }
        }

        public enum Degrees
        {
            Bachelors,
            Masters,
            PhD,
            Professor
        }
        #endregion

        #region Config

        private Configuration config;
        public class Configuration
        {
            [JsonProperty(PropertyName = "Bachelors tag color")]
            public string BachelorsColor = "0061EE";

            [JsonProperty(PropertyName = "Masters tag color")]
            public string MastersColor = "00E3C0";

            [JsonProperty(PropertyName = "PhD tag color")]
            public string PhDColor = "C914BE";

            [JsonProperty(PropertyName = "Professor tag color")]
            public string ProfessorColor = "14E2EC";

            [JsonProperty(PropertyName = "Only show highest degree")]
            public bool highestDegree = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadDefaultConfig() => config = new Configuration();
        #endregion
    }
}


// --- End of file: DegreeTags.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/dynamic-player-limit ---
// --- Original File Path: D/DynamicPlayerLimit/DynamicPlayerLimit.cs ---

ï»¿using ConVar;
using Newtonsoft.Json;
using System;

namespace Oxide.Plugins
{
    [Info("Dynamic Player Limit", "Pho3niX90", "0.0.7")]
    [Description("Increases the player limit by demand")]
    class DynamicPlayerLimit : RustPlugin
    {
        int _originalLimit = 0;
        Timer updateTimer = null;
        void OnServerInitialized(bool serverInitialized) {
            _originalLimit = Admin.ServerInfo().MaxPlayers;

            int startPlayerLimit = Math.Max(Admin.ServerInfo().Players, config.startPlayerSlots);
            UpdatePlayerLimit(startPlayerLimit);
            updateTimer = timer.Every(config.incrementInterval * 60, () => AdjustPlayers());
        }

        void Unload() {
            UpdatePlayerLimit(Math.Max(BasePlayer.activePlayerList.Count, _originalLimit));
            if (updateTimer != null) updateTimer.Destroy();
        }

        #region Helpers
        private void AdjustPlayers() {
            int currentSlots = Admin.ServerInfo().MaxPlayers;

            int slotsOpen = (currentSlots - (Admin.ServerInfo().Players + Admin.ServerInfo().Joining));
            if (slotsOpen <= config.incrementSlotsOpen && currentSlots < config.maxPlayerSlots) {
                int newSlots = Math.Min(config.incrementPlayerSlots + currentSlots, config.maxPlayerSlots);

                if (Performance.report.frameRate > config.fpsLimit) {
                    Puts($"Incrementing player slots from `{currentSlots}` to `{newSlots}\n Queued players `{Admin.ServerInfo().Queued}`\n Joining players `{Admin.ServerInfo().Joining}`");
                    UpdatePlayerLimit(newSlots);
                } else {
                    Puts($"Server FPS too low {Performance.report.frameRate} to adjust");
                }

            } else if (config.doAutoDecrease && slotsOpen > config.incrementSlotsOpen && currentSlots > config.startPlayerSlots) {
                int newSlots = Math.Max(Math.Max(currentSlots - config.incrementPlayerSlots, config.startPlayerSlots), Admin.ServerInfo().Players);

                Puts($"Decreasing player slots from `{currentSlots}` to `{newSlots}\n Queued players `{Admin.ServerInfo().Queued}`\n Joining players `{Admin.ServerInfo().Joining}`");
                UpdatePlayerLimit(newSlots);
            }
        }

        private void UpdatePlayerLimit(int limit) => covalence.Server.MaxPlayers = limit;
        #endregion

        #region Configuration
        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Starting Player Slots")]
            public int startPlayerSlots = 75;

            [JsonProperty(PropertyName = "Maximum Player Slots")]
            public int maxPlayerSlots = 125;

            [JsonProperty(PropertyName = "Increment Player Slots")]
            public int incrementPlayerSlots = 2;

            [JsonProperty(PropertyName = "Increment Interval Minutes")]
            public int incrementInterval = 3;

            [JsonProperty(PropertyName = "Increment When Slots Available")]
            public int incrementSlotsOpen = 0;

            [JsonProperty(PropertyName = "Only increment when FPS above")]
            public int fpsLimit = 45;

            [JsonProperty(PropertyName = "Auto decrease again")]
            public bool doAutoDecrease = true;
        }

        protected override void LoadConfig() {
            base.LoadConfig();

            try {
                config = Config.ReadObject<ConfigData>();
                if (config == null) LoadDefaultConfig();
            } catch {
                PrintError("Your config seems to be corrupted. Will load defaults.");
                LoadDefaultConfig();
                return;
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() {
            config = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
    }
}


// --- End of file: DynamicPlayerLimit.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-players ---
// --- Original File Path: D/DiscordPlayers/DiscordPlayers.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.Builders;
using Oxide.Ext.Discord.Cache;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;
using Oxide.Ext.Discord.Types;
using ProtoBuf;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using UnityEngine;

//DiscordPlayers created with PluginMerge v(1.0.9.0) by MJSU @ https://github.com/dassjosh/Plugin.Merge
namespace Oxide.Plugins
{
    [Info("Discord Players", "MJSU", "3.0.0")]
    [Description("Displays online players in discord")]
    public partial class DiscordPlayers : CovalencePlugin, IDiscordPlugin, IDiscordPool
    {
        #region Plugins\DiscordPlayers.Config.cs
        protected override void LoadDefaultConfig() { }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }
        
        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.CommandMessages ??= new List<CommandSettings>();
            if (config.CommandMessages.Count == 0)
            {
                config.CommandMessages.Add(new CommandSettings
                {
                    Command = "players",
                    ShowAdmins = true,
                    AllowInDm = true,
                    EmbedFieldLimit = 25
                });
                
                config.CommandMessages.Add(new CommandSettings
                {
                    Command = "playersadmin",
                    ShowAdmins = true,
                    AllowInDm = true,
                    EmbedFieldLimit = 25
                });
            }
            
            config.Permanent ??= new List<PermanentMessageSettings>
            {
                new()
                {
                    Enabled = false,
                    ChannelId = new Snowflake(0),
                    UpdateRate = 1f,
                    EmbedFieldLimit = 25
                }
            };
            
            for (int index = 0; index < config.CommandMessages.Count; index++)
            {
                CommandSettings settings = new(config.CommandMessages[index]);
                config.CommandMessages[index] = settings;
            }
            
            for (int index = 0; index < config.Permanent.Count; index++)
            {
                PermanentMessageSettings settings = new(config.Permanent[index]);
                config.Permanent[index] = settings;
            }
            
            return config;
        }
        #endregion

        #region Plugins\DiscordPlayers.DiscordHooks.cs
        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            DiscordApplication app = Client.Bot.Application;
            
            foreach (CommandSettings command in _pluginConfig.CommandMessages)
            {
                CreateApplicationCommand(command);
            }
            
            foreach (KeyValuePair<string, Snowflake> command in _pluginData.RegisteredCommands.ToList())
            {
                if (_pluginConfig.CommandMessages.All(c => c.Command != command.Key))
                {
                    if (command.Value.IsValid())
                    {
                        app.GetGlobalCommand(Client, command.Value).Then(oldCommand => oldCommand.Delete(Client).Then(() =>
                        {
                            _pluginData.RegisteredCommands.Remove(command);
                            SaveData();
                        }).Catch<ResponseError>(error =>
                        {
                            if (error.DiscordError?.Code == 10063)
                            {
                                _pluginData.RegisteredCommands.Remove(command);
                                SaveData();
                                error.SuppressErrorMessage();
                            }
                        }));
                    }
                }
            }
            
            Puts($"{Title} Ready");
        }
        
        public void CreateApplicationCommand(CommandSettings settings)
        {
            string command = settings.Command;
            if (string.IsNullOrEmpty(command))
            {
                return;
            }
            
            ApplicationCommandBuilder builder = new(command, "Shows players currently on the server", ApplicationCommandType.ChatInput);
            builder.AllowInDirectMessages(settings.AllowInDm);
            builder.AddDefaultPermissions(PermissionFlags.None);
            
            CommandCreate cmd = builder.Build();
            DiscordCommandLocalization loc = builder.BuildCommandLocalization();
            
            _commandCache[command] = settings;
            
            _localizations.RegisterCommandLocalizationAsync(this, settings.GetTemplateName(), loc, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0)).Then(_ =>
            {
                _localizations.ApplyCommandLocalizationsAsync(this, cmd, settings.GetTemplateName()).Then(() =>
                {
                    Client.Bot.Application.CreateGlobalCommand(Client, builder.Build()).Then(appCommand =>
                    {
                        _pluginData.RegisteredCommands[command] = appCommand.Id;
                        SaveData();
                    });
                });
            });
            
            _appCommand.AddApplicationCommand(this, Client.Bot.Application.Id, HandleApplicationCommand, command);
        }
        
        [HookMethod(DiscordExtHooks.OnDiscordGuildCreated)]
        private void OnDiscordGuildCreated(DiscordGuild created)
        {
            foreach (PermanentMessageSettings config in _pluginConfig.Permanent)
            {
                if (!config.Enabled || !config.ChannelId.IsValid())
                {
                    continue;
                }
                
                DiscordChannel channel = created.GetChannel(config.ChannelId);
                if (channel == null)
                {
                    PrintWarning($"Failed to find channel ID: {config.ChannelId} in Guild: {created.Name}");
                    continue;
                }
                
                _commandCache[config.GetTemplateName().Name] = config;
                PermanentMessageData existing = _pluginData.GetPermanentMessage(config);
                if (existing != null)
                {
                    channel.GetMessage(Client, existing.MessageId)
                    .Then(message =>
                    {
                        _permanentHandler[message.Id] = new PermanentMessageHandler(Client, new MessageCache(config), config.UpdateRate, message);
                    })
                    .Catch<ResponseError>(error =>
                    {
                        if (error.HttpStatusCode == DiscordHttpStatusCode.NotFound)
                        {
                            CreatePermanentMessage(config, channel);
                            error.SuppressErrorMessage();
                        }
                    });
                }
                else
                {
                    CreatePermanentMessage(config, channel);
                }
            }
        }
        
        private void CreatePermanentMessage(PermanentMessageSettings config, DiscordChannel channel)
        {
            MessageCache cache = new(config);
            
            CreateMessage<MessageCreate>(cache, null, null, create =>
            {
                channel.CreateMessage(Client, create).Then(message =>
                {
                    _pluginData.SetPermanentMessage(config, new PermanentMessageData
                    {
                        MessageId = message.Id
                    });
                    _permanentHandler[message.Id] = new PermanentMessageHandler(Client, cache, config.UpdateRate, message);
                    SaveData();
                });
            });
        }
        
        private void HandleApplicationCommand(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            MessageCache cache = GetCache(interaction);
            if (cache == null)
            {
                PrintError("Cache is null!!");
                return;
            }
            
            CreateMessage<InteractionCallbackData>(cache, interaction, null, create =>
            {
                interaction.CreateResponse(Client, new InteractionResponse
                {
                    Type = InteractionResponseType.ChannelMessageWithSource,
                    Data = create
                });
            });
        }
        
        [DiscordMessageComponentCommand(BackCommand)]
        private void HandleBackCommand(DiscordInteraction interaction)
        {
            MessageCache cache = GetCache(interaction);
            if (cache == null)
            {
                return;
            }
            
            cache.State.PreviousPage();
            HandleUpdate(interaction, cache);
        }
        
        [DiscordMessageComponentCommand(RefreshCommand)]
        private void HandleRefreshCommand(DiscordInteraction interaction)
        {
            MessageCache cache = GetCache(interaction);
            if (cache == null)
            {
                return;
            }
            
            HandleUpdate(interaction, cache);
        }
        
        [DiscordMessageComponentCommand(ForwardCommand)]
        private void HandleForwardCommand(DiscordInteraction interaction)
        {
            MessageCache cache = GetCache(interaction);
            if (cache == null)
            {
                return;
            }
            
            cache.State.NextPage();
            HandleUpdate(interaction, cache);
        }
        
        [DiscordMessageComponentCommand(ChangeSort)]
        private void HandleChangeSortCommand(DiscordInteraction interaction)
        {
            MessageCache cache = GetCache(interaction);
            if (cache == null)
            {
                return;
            }
            
            cache.State.NextSort();
            HandleUpdate(interaction, cache);
        }
        
        private void HandleUpdate(DiscordInteraction interaction, MessageCache cache)
        {
            CreateMessage<InteractionCallbackData>(cache, interaction, null, create =>
            {
                interaction.CreateResponse(Client, new InteractionResponse
                {
                    Type = InteractionResponseType.UpdateMessage,
                    Data = create
                });
            });
        }
        #endregion

        #region Plugins\DiscordPlayers.Fields.cs
        public DiscordClient Client { get; set; }
        public DiscordPluginPool Pool { get; set; }
        
        private PluginConfig _pluginConfig; //Plugin Config
        private PluginData _pluginData;
        
        private readonly DiscordAppCommand _appCommand = GetLibrary<DiscordAppCommand>();
        private readonly DiscordPlaceholders _placeholders = GetLibrary<DiscordPlaceholders>();
        private readonly DiscordMessageTemplates _templates = GetLibrary<DiscordMessageTemplates>();
        private readonly DiscordEmbedTemplates _embed = GetLibrary<DiscordEmbedTemplates>();
        private readonly DiscordEmbedFieldTemplates _field = GetLibrary<DiscordEmbedFieldTemplates>();
        private readonly DiscordCommandLocalizations _localizations = GetLibrary<DiscordCommandLocalizations>();
        
        private readonly BotConnection _discordSettings = new();
        
        private readonly Hash<Snowflake, MessageCache> _messageCache = new();
        private readonly Hash<string, BaseMessageSettings> _commandCache = new();
        private readonly OnlinePlayerCache _playerCache = new();
        
        private readonly Hash<Snowflake, PermanentMessageHandler> _permanentHandler = new();
        
        private const string BaseCommand = nameof(DiscordPlayers) + ".";
        private const string BackCommand = BaseCommand + "B";
        private const string RefreshCommand = BaseCommand + "R";
        private const string ForwardCommand = BaseCommand + "F";
        private const string ChangeSort = BaseCommand + "S";
        
        public static DiscordPlayers Instance;
        
        public PluginTimers Timer => timer;
        #endregion

        #region Plugins\DiscordPlayers.Helpers.cs
        private const string PluginIcon = "https://assets.umod.org/images/icons/plugin/61354f8bd5faf.png";
        
        public MessageCache GetCache(DiscordInteraction interaction)
        {
            DiscordMessage message = interaction.Message;
            BaseMessageSettings command;
            if (interaction.Type == InteractionType.ApplicationCommand)
            {
                InteractionDataParsed args = interaction.Parsed;
                command = _commandCache[args.Command];
                return command != null ? new MessageCache(command) : null;
            }
            
            string customId = interaction.Data.CustomId;
            MessageCache cache = _messageCache[message.Id];
            if (cache != null)
            {
                return cache;
            }
            
            ReadOnlySpan<char> base64 = customId.AsSpan()[(customId.LastIndexOf(" ", StringComparison.Ordinal) + 1)..];
            MessageState state = MessageState.Create(base64);
            if (state == null)
            {
                SendResponse(interaction, TemplateKeys.Errors.UnknownState, GetDefault(interaction));
                return null;
            }
            
            command = _commandCache[state.Command];
            if (command == null)
            {
                SendResponse(interaction, TemplateKeys.Errors.UnknownCommand, GetDefault(interaction).Add(PlaceholderDataKeys.CommandName, state.Command));
                return null;
            }
            
            cache = new MessageCache(command, state);
            _messageCache[message.Id] = cache;
            return cache;
        }
        
        public void SendResponse(DiscordInteraction interaction, TemplateKey templateName, PlaceholderData data, MessageFlags flags = MessageFlags.Ephemeral)
        {
            interaction.CreateTemplateResponse(Client, InteractionResponseType.ChannelMessageWithSource, templateName, new InteractionCallbackData { Flags = flags }, data);
        }
        
        public string Lang(string key)
        {
            return lang.GetMessage(key, this);
        }
        
        public string Lang(string key, params object[] args)
        {
            try
            {
                return string.Format(Lang(key), args);
            }
            catch(Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception\n:{ex}");
                throw;
            }
        }
        
        private void SaveData()
        {
            if (_pluginData != null)
            {
                Interface.Oxide.DataFileSystem.WriteObject(Name, _pluginData);
            }
        }
        
        public new void PrintError(string format, params object[] args) => base.PrintError(format, args);
        #endregion

        #region Plugins\DiscordPlayers.Lang.cs
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.SortByEnumName] = "Name",
                [LangKeys.SortByEnumTime] = "Time",
            }, this);
        }
        #endregion

        #region Plugins\DiscordPlayers.MessageHandling.cs
        public void CreateMessage<T>(MessageCache cache, DiscordInteraction interaction, T create, Action<T> callback) where T : class, IDiscordMessageTemplate, new()
        {
            List<IPlayer> allList = GetPlayerList(cache);
            int perPage = cache.Settings.EmbedFieldLimit;
            List<IPlayer> pageList = allList.Skip(cache.State.Page * perPage).Take(perPage).ToPooledList(Pool);
            
            int maxPage = (allList.Count - 1) / cache.Settings.EmbedFieldLimit;
            cache.State.ClampPage((short)maxPage);
            
            PlaceholderData data = GetDefault(cache, interaction, maxPage + 1);
            data.ManualPool();
            
            T message = CreateMessage(cache.Settings, data, interaction, create);
            message.AllowedMentions = AllowedMentions.None;
            SetButtonState(message, BackCommand, cache.State.Page > 0);
            SetButtonState(message, ForwardCommand, cache.State.Page < maxPage);
            
            DiscordEmbed embed = CreateEmbeds(cache.Settings, data, interaction);
            
            message.Embeds = new List<DiscordEmbed>{embed};
            CreateFields(cache, data, interaction, pageList).Then(fields =>
            {
                ProcessEmbeds(embed, fields);
            }).Finally(() =>
            {
                callback.Invoke(message);
                data.Dispose();
                Pool.FreeList(pageList);
            });
        }
        
        public List<IPlayer> GetPlayerList(MessageCache cache)
        {
            return _playerCache.GetList(cache.State.Sort, cache.Settings.ShowAdmins);
        }
        
        public T CreateMessage<T>(BaseMessageSettings settings, PlaceholderData data, DiscordInteraction interaction, T message) where T : class, IDiscordMessageTemplate, new()
        {
            if (settings.IsPermanent())
            {
                return _templates.GetGlobalTemplate(this, settings.GetTemplateName()).ToMessage(data, message);
            }
            
            return _templates.GetLocalizedTemplate(this, settings.GetTemplateName(), interaction).ToMessage(data, message);
        }
        
        public void SetButtonState(IDiscordMessageTemplate message, string command, bool enabled)
        {
            for (int index = 0; index < message.Components.Count; index++)
            {
                ActionRowComponent row = message.Components[index];
                for (int i = 0; i < row.Components.Count; i++)
                {
                    BaseComponent component = row.Components[i];
                    if (component is ButtonComponent)
                    {
                        ButtonComponent button = (ButtonComponent)component;
                        if (button.CustomId.StartsWith(command))
                        {
                            button.Disabled = !enabled;
                            return;
                        }
                    }
                }
            }
        }
        
        public DiscordEmbed CreateEmbeds(BaseMessageSettings settings, PlaceholderData data, DiscordInteraction interaction)
        {
            TemplateKey name = settings.GetTemplateName();
            return settings.IsPermanent() ? _embed.GetGlobalTemplate(this, name).ToEntity(data) : _embed.GetLocalizedTemplate(this, name, interaction).ToEntity(data);
        }
        
        public IPromise<List<EmbedField>> CreateFields(MessageCache cache, PlaceholderData data, DiscordInteraction interaction, List<IPlayer> onlineList)
        {
            DiscordEmbedFieldTemplate template;
            if (cache.Settings.IsPermanent())
            {
                template = _field.GetGlobalTemplate(this, cache.Settings.GetTemplateName());
            }
            else
            {
                template = _field.GetLocalizedTemplate(this, cache.Settings.GetTemplateName(), interaction);
            }
            
            List<PlaceholderData> placeholders = new(onlineList.Count);
            
            for (int index = 0; index < onlineList.Count; index++)
            {
                PlaceholderData playerData = CloneForPlayer(data, onlineList[index], cache.State.Page * cache.Settings.EmbedFieldLimit + index + 1);
                playerData.ManualPool();
                placeholders.Add(playerData);
            }
            
            return template.ToEntityBulk(placeholders).Finally(() =>
            {
                foreach (PlaceholderData data in placeholders)
                {
                    data.Dispose();
                }
            });
        }
        
        public void ProcessEmbeds(DiscordEmbed embed, List<EmbedField> fields)
        {
            embed.Fields ??= new List<EmbedField>();
            embed.Fields.AddRange(fields);
        }
        #endregion

        #region Plugins\DiscordPlayers.Placeholders.cs
        public void RegisterPlaceholders()
        {
            _placeholders.RegisterPlaceholder<int>(this,PlaceholderKeys.PlayerIndex, PlaceholderDataKeys.PlayerIndex);
            _placeholders.RegisterPlaceholder<MessageState, int>(this, PlaceholderKeys.Page, PlaceholderDataKeys.MessageState, GetPage);
            _placeholders.RegisterPlaceholder<MessageState, string>(this, PlaceholderKeys.SortState, PlaceholderDataKeys.MessageState, GetSort);
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.CommandId, PlaceholderDataKeys.CommandId);
            _placeholders.RegisterPlaceholder<string>(this,PlaceholderKeys.CommandName, PlaceholderDataKeys.CommandName);
            _placeholders.RegisterPlaceholder<int>(this, PlaceholderKeys.MaxPage, PlaceholderDataKeys.MaxPage);
        }
        
        public int GetPage(MessageState embed) => embed.Page + 1;
        public string GetSort(PlaceholderState state, MessageState embed)
        {
            DiscordInteraction interaction = state.Data.Get<DiscordInteraction>();
            string key = embed.Sort == SortBy.Name ? LangKeys.SortByEnumName : LangKeys.SortByEnumTime;
            return interaction != null ? interaction.GetLangMessage(this, key) : Lang(key);
        }
        
        public PlaceholderData CloneForPlayer(PlaceholderData source, IPlayer player, int index)
        {
            DiscordUser user = player.GetDiscordUser();
            TimeSpan onlineDuration = _playerCache.GetOnlineDuration(player);
            return source.Clone()
            .RemoveUser()
            .AddUser(user)
            .AddPlayer(player)
            .Add(PlaceholderDataKeys.PlayerIndex, index)
            .Add(PlaceholderDataKeys.PlayerDuration, onlineDuration)
            .AddTimestamp(DateTimeOffset.UtcNow - onlineDuration);
        }
        
        public PlaceholderData GetDefault(DiscordInteraction interaction)
        {
            return _placeholders.CreateData(this).AddInteraction(interaction);
        }
        
        public PlaceholderData GetDefault(MessageCache cache, DiscordInteraction interaction)
        {
            return GetDefault(interaction)
            .Add(PlaceholderDataKeys.MessageState, cache.State);
        }
        
        public PlaceholderData GetDefault(MessageCache cache, DiscordInteraction interaction, int maxPage)
        {
            return GetDefault(cache, interaction)
            .Add(PlaceholderDataKeys.MaxPage, maxPage)
            .Add(PlaceholderDataKeys.CommandId, cache.State.CreateBase64String());
        }
        #endregion

        #region Plugins\DiscordPlayers.Setup.cs
        private void Init()
        {
            Instance = this;
            _discordSettings.ApiToken = _pluginConfig.DiscordApiKey;
            _discordSettings.LogLevel = _pluginConfig.ExtensionDebugging;
            _discordSettings.Intents = GatewayIntents.Guilds;
            
            _pluginData = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name) ?? new PluginData();
        }
        
        private void OnServerInitialized()
        {
            if (string.IsNullOrEmpty(_pluginConfig.DiscordApiKey))
            {
                PrintWarning("Please set the Discord Bot Token and reload the plugin");
                return;
            }
            
            _playerCache.Initialize(players.Connected);
            
            RegisterPlaceholders();
            RegisterTemplates();
            
            foreach (CommandSettings message in _pluginConfig.CommandMessages)
            {
                if (message.EmbedFieldLimit > 25)
                {
                    PrintWarning($"Players For Embed cannot be greater than 25 for command {message.Command}");
                }
                else if (message.EmbedFieldLimit < 0)
                {
                    PrintWarning($"Players For Embed cannot be less than 0 for command {message.Command}");
                }
                
                message.EmbedFieldLimit = Mathf.Clamp(message.EmbedFieldLimit, 0, 25);
            }
            
            Client.Connect(_discordSettings);
        }
        
        private void OnUserConnected(IPlayer player)
        {
            _playerCache.OnUserConnected(player);
        }
        
        private void OnUserDisconnected(IPlayer player)
        {
            _playerCache.OnUserDisconnected(player);
        }
        
        private void Unload()
        {
            SaveData();
            Instance = null;
        }
        #endregion

        #region Plugins\DiscordPlayers.Templates.cs
        public void RegisterTemplates()
        {
            foreach (CommandSettings command in _pluginConfig.CommandMessages)
            {
                DiscordEmbedFieldTemplate embed = command.Command == "playersadmin" ? GetDefaultAdminFieldTemplate() : GetDefaultFieldTemplate();
                CreateCommandTemplates(command, embed, false);
            }
            
            foreach (PermanentMessageSettings permanent in _pluginConfig.Permanent)
            {
                DiscordEmbedFieldTemplate embed = permanent.TemplateName == "PermanentAdmin" ? GetDefaultAdminFieldTemplate() : GetDefaultFieldTemplate();
                CreateCommandTemplates(permanent, embed, true);
            }
            
            DiscordMessageTemplate unknownState = CreateTemplateEmbed("Error: Failed to find a state for this message. Please create a new message.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.UnknownState, unknownState, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unknownCommand = CreateTemplateEmbed($"Error: Command not found '{PlaceholderKeys.CommandName}'. Please create a new message", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.UnknownCommand, unknownCommand, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
        }
        
        private void CreateCommandTemplates(BaseMessageSettings command, DiscordEmbedFieldTemplate @default, bool isGlobal)
        {
            DiscordMessageTemplate template = CreateBaseMessage();
            TemplateKey name = command.GetTemplateName();
            RegisterTemplate(_templates, name, template, isGlobal, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            RegisterTemplate(_field, name, @default, isGlobal, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordEmbedTemplate embed = GetDefaultEmbedTemplate();
            RegisterTemplate(_embed, name, embed, isGlobal, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
        }
        
        public void RegisterTemplate<TTemplate>(BaseMessageTemplateLibrary<TTemplate> library, TemplateKey name, TTemplate template, bool isGlobal, TemplateVersion version, TemplateVersion minVersion) where TTemplate : class, new()
        {
            if (isGlobal)
            {
                library.RegisterGlobalTemplateAsync(this, name, template, version, minVersion);
            }
            else
            {
                library.RegisterLocalizedTemplateAsync(this, name, template, version, minVersion);
            }
        }
        
        public DiscordMessageTemplate CreateBaseMessage()
        {
            return new DiscordMessageTemplate
            {
                Content = string.Empty,
                Components =
                {
                    new ButtonTemplate("Back", ButtonStyle.Primary, $"{BackCommand} {PlaceholderKeys.CommandId}", "â¬"),
                    new ButtonTemplate($"Page: {PlaceholderKeys.Page}/{PlaceholderKeys.MaxPage}", ButtonStyle.Primary, "PAGE", false),
                    new ButtonTemplate("Next", ButtonStyle.Primary, $"{ForwardCommand} {PlaceholderKeys.CommandId}", "â¡"),
                    new ButtonTemplate("Refresh", ButtonStyle.Primary, $"{RefreshCommand} {PlaceholderKeys.CommandId}", "ð"),
                    new ButtonTemplate($"Sorted By: {PlaceholderKeys.SortState}", ButtonStyle.Primary, $"{ChangeSort} {PlaceholderKeys.CommandId}")
                }
            };
        }
        
        public DiscordEmbedTemplate GetDefaultEmbedTemplate()
        {
            return new DiscordEmbedTemplate
            {
                Title = $"{DefaultKeys.Server.Name}",
                Description = $"{DefaultKeys.Server.Players}/{DefaultKeys.Server.MaxPlayers} Online Players | {{server.players.loading}} Loading | {{server.players.queued}} Queued",
                Color = DiscordColor.Blurple.ToHex(),
                TimeStamp = true,
                Footer =
                {
                    Enabled = true,
                    Text = $"{DefaultKeys.Plugin.Name} V{DefaultKeys.Plugin.Version} by {DefaultKeys.Plugin.Author}",
                    IconUrl = PluginIcon
                }
            };
        }
        
        public DiscordEmbedFieldTemplate GetDefaultFieldTemplate()
        {
            return new DiscordEmbedFieldTemplate($"#{PlaceholderKeys.PlayerIndex} {DefaultKeys.Player.NameClan}", $"**Connected:** {DefaultKeys.Timespan.Hours}h {DefaultKeys.Timespan.Minutes}m {DefaultKeys.Timespan.Seconds}s");
        }
        
        public DiscordEmbedFieldTemplate GetDefaultAdminFieldTemplate()
        {
            return new DiscordEmbedFieldTemplate($"#{PlaceholderKeys.PlayerIndex} {DefaultKeys.Player.NameClan}",
            $"**Steam ID:**{DefaultKeys.Player.Id}\n" +
            $"**Connected:** {DefaultKeys.Timespan.Hours}h {DefaultKeys.Timespan.Minutes}m {DefaultKeys.Timespan.Seconds}s\n" +
            $"**Ping:** {DefaultKeys.Player.Ping}ms\n" +
            $"**Country:** {DefaultKeys.Player.Country}\n" +
            $"**User:** {DefaultKeys.User.Mention}");
        }
        
        public DiscordMessageTemplate CreateTemplateEmbed(string description, DiscordColor color)
        {
            return new DiscordMessageTemplate
            {
                Embeds = new List<DiscordEmbedTemplate>
                {
                    new()
                    {
                        Description = $"[{DefaultKeys.Plugin.Title}] {description}",
                        Color = color.ToHex()
                    }
                }
            };
        }
        #endregion

        #region Cache\MessageCache.cs
        public class MessageCache
        {
            public readonly BaseMessageSettings Settings;
            public readonly MessageState State;
            
            public MessageCache(BaseMessageSettings settings, MessageState state = null)
            {
                Settings = settings;
                State = state ?? MessageState.CreateNew(Settings.GetTemplateName());
            }
        }
        #endregion

        #region Cache\OnlinePlayerCache.cs
        public class OnlinePlayerCache
        {
            private readonly PlayerListCache _byNameCache = new(new NameComparer());
            private readonly PlayerListCache _byOnlineTime;
            private readonly Hash<string, DateTime> _onlineSince = new();
            
            public OnlinePlayerCache()
            {
                _byOnlineTime = new PlayerListCache(new OnlineSinceComparer(_onlineSince));
            }
            
            public void Initialize(IEnumerable<IPlayer> connected)
            {
                #if RUST
                foreach (Network.Connection connection in Network.Net.sv.connections)
                {
                    _onlineSince[connection.ownerid.ToString()] = DateTime.UtcNow - TimeSpan.FromSeconds(connection.GetSecondsConnected());
                }
                #endif
                
                foreach (IPlayer player in connected)
                {
                    OnUserConnected(player);
                }
            }
            
            public TimeSpan GetOnlineDuration(IPlayer player)
            {
                return DateTime.UtcNow - _onlineSince[player.Id];
            }
            
            public List<IPlayer> GetList(SortBy sort, bool includeAdmin)
            {
                List<IPlayer> list = sort == SortBy.Time ? _byOnlineTime.GetList(includeAdmin) : _byNameCache.GetList(includeAdmin);
                //return Enumerable.Range(0, 100).Select(i => list[0]).ToList();
                return list;
            }
            
            public void OnUserConnected(IPlayer player)
            {
                _onlineSince.TryAdd(player.Id, DateTime.UtcNow);
                _byNameCache.Add(player);
                _byOnlineTime.Add(player);
            }
            
            public void OnUserDisconnected(IPlayer player)
            {
                _onlineSince.Remove(player.Id);
                _byNameCache.Remove(player);
                _byOnlineTime.Remove(player);
            }
            
            class NameComparer : IComparer<IPlayer>
            {
                public int Compare(IPlayer x, IPlayer y)
                {
                    return string.Compare(x?.Name, y?.Name, StringComparison.Ordinal);
                }
            }
            
            class OnlineSinceComparer : IComparer<IPlayer>
            {
                private readonly Hash<string, DateTime> _onlineSince;
                
                public OnlineSinceComparer(Hash<string, DateTime> onlineSince)
                {
                    _onlineSince = onlineSince;
                }
                
                public int Compare(IPlayer x, IPlayer y)
                {
                    return _onlineSince[x.Id].CompareTo(_onlineSince[y.Id]);
                }
            }
        }
        #endregion

        #region Cache\PlayerListCache.cs
        public class PlayerListCache
        {
            private readonly List<IPlayer> _allList = new();
            private readonly List<IPlayer> _nonAdminList = new();
            
            private readonly IComparer<IPlayer> _comparer;
            
            public PlayerListCache(IComparer<IPlayer> comparer)
            {
                _comparer = comparer;
            }
            
            public void Add(IPlayer player)
            {
                Remove(player);
                Insert(_allList, player);
                Insert(_nonAdminList, player);
            }
            
            public void Insert(List<IPlayer> list, IPlayer player)
            {
                int index = list.BinarySearch(player, _comparer);
                if (index < 0)
                {
                    list.Insert(~index, player);
                }
                else
                {
                    list[index] = player;
                }
            }
            
            public void Remove(IPlayer player)
            {
                _allList.Remove(player);
                _nonAdminList.Remove(player);
            }
            
            public List<IPlayer> GetList(bool includeAdmin)
            {
                return includeAdmin ? _allList : _nonAdminList;
            }
        }
        #endregion

        #region Configuration\BaseMessageSettings.cs
        public abstract class BaseMessageSettings
        {
            [JsonProperty(PropertyName = "Display Admins In The Player List", Order = 1001)]
            public bool ShowAdmins { get; set; }
            
            [DefaultValue(25)]
            [JsonProperty(PropertyName = "Players Per Embed (0 - 25)", Order = 1002)]
            public int EmbedFieldLimit { get; set; }
            
            public abstract bool IsPermanent();
            public abstract TemplateKey GetTemplateName();
            
            [JsonConstructor]
            public BaseMessageSettings() { }
            
            public BaseMessageSettings(BaseMessageSettings settings)
            {
                ShowAdmins = settings?.ShowAdmins ?? true;
                EmbedFieldLimit = settings?.EmbedFieldLimit ?? 25;
            }
        }
        #endregion

        #region Configuration\CommandSettings.cs
        public class CommandSettings : BaseMessageSettings
        {
            [JsonProperty(PropertyName = "Command Name (Must Be Unique)")]
            public string Command { get; set; }
            
            [JsonProperty(PropertyName = "Allow Command In Direct Messages")]
            public bool AllowInDm { get; set; }
            
            [JsonConstructor]
            public CommandSettings() { }
            
            public CommandSettings(CommandSettings settings) : base(settings)
            {
                Command = settings?.Command ?? "players";
                AllowInDm = settings?.AllowInDm ?? true;
            }
            
            public override bool IsPermanent() => false;
            public override TemplateKey GetTemplateName() => new(Command);
        }
        #endregion

        #region Configuration\PermanentMessageSettings.cs
        public class PermanentMessageSettings : BaseMessageSettings
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; }
            
            [JsonProperty(PropertyName = "Template Name (Must Be Unique)")]
            public string TemplateName { get; set; }
            
            [JsonProperty(PropertyName = "Permanent Message Channel ID")]
            public Snowflake ChannelId { get; set; }
            
            [JsonProperty(PropertyName = "Update Rate (Minutes)")]
            public float UpdateRate { get; set; }
            
            [JsonConstructor]
            public PermanentMessageSettings() { }
            
            public PermanentMessageSettings(PermanentMessageSettings settings) : base(settings)
            {
                Enabled = settings?.Enabled ?? false;
                TemplateName = settings?.TemplateName ?? "Permanent";
                ChannelId = settings?.ChannelId ?? default(Snowflake);
                UpdateRate = settings?.UpdateRate ?? 1f;
            }
            
            public override bool IsPermanent() => true;
            public override TemplateKey GetTemplateName() => new(TemplateName);
        }
        #endregion

        #region Configuration\PluginConfig.cs
        public class PluginConfig
        {
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string DiscordApiKey { get; set; }
            
            [JsonProperty(PropertyName = "Command Messages")]
            public List<CommandSettings> CommandMessages { get; set; }
            
            [JsonProperty(PropertyName = "Permanent Messages")]
            public List<PermanentMessageSettings> Permanent { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; }
        }
        #endregion

        #region Data\PermanentMessageData.cs
        public class PermanentMessageData
        {
            public Snowflake MessageId { get; set; }
        }
        #endregion

        #region Data\PluginData.cs
        public class PluginData
        {
            public Hash<string, PermanentMessageData> PermanentMessageIds = new();
            public Hash<string, Snowflake> RegisteredCommands = new();
            
            public PermanentMessageData GetPermanentMessage(PermanentMessageSettings config)
            {
                return PermanentMessageIds[config.TemplateName];
            }
            
            public void SetPermanentMessage(PermanentMessageSettings config, PermanentMessageData data)
            {
                PermanentMessageIds[config.TemplateName] = data;
            }
        }
        #endregion

        #region Enums\SortBy.cs
        public enum SortBy : byte
        {
            Name,
            Time
        }
        #endregion

        #region Handlers\PermanentMessageHandler.cs
        public class PermanentMessageHandler
        {
            private readonly DiscordClient _client;
            private readonly MessageCache _cache;
            private readonly DiscordMessage _message;
            private readonly MessageUpdate _update = new();
            private readonly Timer _timer;
            private DateTime _lastUpdate;
            
            public PermanentMessageHandler(DiscordClient client, MessageCache cache, float updateRate, DiscordMessage message)
            {
                _client = client;
                _cache = cache;
                _message = message;
                _timer = DiscordPlayers.Instance.Timer.Every(updateRate * 60f, SendUpdate);
                SendUpdate();
            }
            
            private void SendUpdate()
            {
                if (_lastUpdate + TimeSpan.FromSeconds(5) > DateTime.UtcNow)
                {
                    return;
                }
                
                _lastUpdate = DateTime.UtcNow;
                
                DiscordPlayers.Instance.CreateMessage(_cache, null, _update, message =>
                {
                    _message.Edit(_client, message).Catch<ResponseError>(error =>
                    {
                        if (error.HttpStatusCode == DiscordHttpStatusCode.NotFound)
                        {
                            _timer?.Destroy();
                        }
                    });
                });
            }
        }
        #endregion

        #region Lang\LangKeys.cs
        public static class LangKeys
        {
            public const string SortByEnumName = nameof(SortByEnumName);
            public const string SortByEnumTime = nameof(SortByEnumTime);
        }
        #endregion

        #region Placeholders\PlaceholderDataKeys.cs
        public static class PlaceholderDataKeys
        {
            public static readonly PlaceholderDataKey CommandId = new("command.id");
            public static readonly PlaceholderDataKey CommandName = new("command.name");
            public static readonly PlaceholderDataKey PlayerIndex = new("player.index");
            public static readonly PlaceholderDataKey PlayerDuration = new("timespan");
            public static readonly PlaceholderDataKey MaxPage = new("page.max");
            public static readonly PlaceholderDataKey MessageState = new("message.state");
        }
        #endregion

        #region Placeholders\PlaceholderKeys.cs
        public class PlaceholderKeys
        {
            public static readonly PlaceholderKey PlayerIndex = new(nameof(DiscordPlayers), "player.index");
            public static readonly PlaceholderKey Page = new(nameof(DiscordPlayers), "state.page");
            public static readonly PlaceholderKey SortState = new(nameof(DiscordPlayers), "state.sort");
            public static readonly PlaceholderKey CommandId = new(nameof(DiscordPlayers), "command.id");
            public static readonly PlaceholderKey CommandName = new(nameof(DiscordPlayers), "command.name");
            public static readonly PlaceholderKey MaxPage = new(nameof(DiscordPlayers), "page.max");
        }
        #endregion

        #region State\MessageState.cs
        [ProtoContract]
        public class MessageState
        {
            [ProtoMember(1)]
            public short Page;
            
            [ProtoMember(2)]
            public SortBy Sort;
            
            [ProtoMember(3)]
            public string Command;
            
            private MessageState() { }
            
            public static MessageState CreateNew(TemplateKey command)
            {
                return new MessageState
                {
                    Command = command.Name
                };
            }
            
            public static MessageState Create(ReadOnlySpan<char> base64)
            {
                try
                {
                    Span<byte> buffer = stackalloc byte[64];
                    Convert.TryFromBase64Chars(base64, buffer, out int written);
                    MemoryStream stream = DiscordPlayers.Instance.Pool.GetMemoryStream();
                    stream.Write(buffer[..written]);
                    stream.Flush();
                    stream.Position = 0;
                    MessageState state = Serializer.Deserialize<MessageState>(stream);
                    DiscordPlayers.Instance.Pool.FreeMemoryStream(stream);
                    return state;
                }
                catch (Exception ex)
                {
                    DiscordPlayers.Instance.PrintError($"An error occured parsing state. State: {base64.ToString()}. Exception:\n{ex}");
                    return null;
                }
            }
            
            public string CreateBase64String()
            {
                MemoryStream stream = DiscordPlayers.Instance.Pool.GetMemoryStream();
                Serializer.Serialize(stream, this);
                stream.TryGetBuffer(out ArraySegment<byte> buffer);
                string base64 = Convert.ToBase64String(buffer.AsSpan());
                DiscordPlayers.Instance.Pool.FreeMemoryStream(stream);
                return base64;
            }
            
            public void NextPage() => Page++;
            
            public void PreviousPage() => Page--;
            
            public void ClampPage(short maxPage) => Page = Page.Clamp((short)0, maxPage);
            
            public void NextSort() => Sort = EnumCache<SortBy>.Instance.Next(Sort);
            
            public override string ToString()
            {
                return $"{{ Command = '{Command}' Sort = {Sort.ToString()} Page = {Page} }}";
            }
        }
        #endregion

        #region Templates\TemplateKeys.cs
        public static class TemplateKeys
        {
            public static class Errors
            {
                private const string Base = nameof(Errors) + ".";
                
                public static readonly TemplateKey UnknownState = new(Base + nameof(UnknownState));
                public static readonly TemplateKey UnknownCommand = new(Base + nameof(UnknownCommand));
            }
        }
        #endregion

    }

}


// --- End of file: DiscordPlayers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/disable-damage ---
// --- Original File Path: D/DisableDamage/DisableDamage.cs ---

ï»¿using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Disable Damage", "2CHEVSKII", "0.4.0")]
    [Description("Allows players with permission to disable other player's damage.")]
    class DisableDamage : RustPlugin
    {

        #region [Fields]


        //////////////////////////////////////////
        //// Config variables                 ////
        //////////////////////////////////////////
        bool displayerdmg = true;
        bool disNPCdmg = true;
        bool disStructdmg = true;
        bool disAnimaldmg = true;
        bool disBarreldmg = true;
        bool disHelidmg = true;
        bool disTransportdmg = true;
        bool announceTarget = true;
        bool announceName = true;
        bool savedisabled = true;

        bool disDefaultdmg = false;

        /// <summary>
        /// Players with disabled damage
        /// </summary>
        List<ulong> DisabledDamage { get; set; }

        /// <summary>
        /// Permission to use the chat command
        /// </summary>
        const string PERMISSION_USE = "disabledamage.use";

        //////////////////////////////////////////
        //// Strings                          ////
        //////////////////////////////////////////
        const string M_PREFIX = "Prefix";
        const string M_SELF_DAMAGE_ENABLED = "Self damage enabled";
        const string M_SELF_DAMAGE_DISABLED = "Self damage disabled";
        const string M_PLAYER_DAMAGE_ENABLED = "Player's damage enabled";
        const string M_PLAYER_DAMAGE_DISABLED = "Player's damage disabled";
        const string M_ENABLED_BY = "Player enabled your damage";
        const string M_DISABLED_BY = "Player disabled your damage";
        const string M_NO_PERMISSION = "No permission";
        const string M_PLAYER_NOT_FOUND = "No player found";
        const string M_HELP = "Help message";
        const string M_UNAVAILABLE = "Command unavailable";


        #endregion

        #region [Configuration]


        void CheckConfig<T>(string menu, string key, ref T value)
        {
            if (Config[menu, key] is T)
                value = (T)Config[menu, key];
            else
                Config[menu, key] = value;
        }

        protected override void LoadDefaultConfig() { }

        void LoadConfiguration()
        {
            CheckConfig("General", "Save disabled players to data", ref savedisabled);
            CheckConfig("General", "Announce target player", ref announceTarget);
            CheckConfig("General", "Display name of user to target player", ref announceName);
            CheckConfig("General", "Damage disabled by default", ref disDefaultdmg);
            CheckConfig("Types", "Disable damage to players", ref displayerdmg);
            CheckConfig("Types", "Disable damage to NPCs", ref disNPCdmg);
            CheckConfig("Types", "Disable damage to Buildings and structures", ref disStructdmg);
            CheckConfig("Types", "Disable damage to animals", ref disAnimaldmg);
            CheckConfig("Types", "Disable damage to barrels", ref disBarreldmg);
            CheckConfig("Types", "Disable damage to transport", ref disTransportdmg);
            CheckConfig("Types", "Disable damage to helicopter", ref disHelidmg);
            SaveConfig();
        }


        #endregion

        #region [Localization]


        protected override void LoadDefaultMessages() => lang.RegisterMessages(defmessages, this, "en");

        void Replier(BasePlayer player, string message, params string[] args) => player.ChatMessage($"{lang.GetMessage(M_PREFIX, this)} {string.Format(lang.GetMessage(message, this), args)}");

        Dictionary<string, string> defmessages = new Dictionary<string, string>
        {
            [M_PREFIX] = "<color=red>[</color>DISABLE DAMAGE<color=red>]</color>",
            [M_NO_PERMISSION] = "<color=red>Y</color>ou have no permission to use this command<color=red>!</color>",
            [M_SELF_DAMAGE_ENABLED] = "Your damage has been <color=#36d859>enabled</color>.",
            [M_SELF_DAMAGE_DISABLED] = "Your damage has been <color=red>disabled</color>.",
            [M_PLAYER_DAMAGE_ENABLED] = "You <color=#36d859>enabled</color> damage for player <color=#36a1d8>{0}</color>.",
            [M_PLAYER_DAMAGE_DISABLED] = "You <color=red>disabled</color> damage for player <color=#36a1d8>{0}</color>.",
            [M_ENABLED_BY] = "Your damage has been <color=#36d859>enabled</color> by <color=#36a1d8>{0}</color>.",
            [M_DISABLED_BY] = "Your damage has been <color=red>disabled</color> by <color=#36a1d8>{0}</color>.",
            [M_PLAYER_NOT_FOUND] = "<color=red>N</color>o player found with that name<color=red>!</color>",
            [M_HELP] = "<color=yellow>Wrong command usage!</color>\n<color=#36a1d8>/dd</color> - enable/disable your damage\n<color=#36a1d8>/dd <username or userid></color> - disable damage for specific user.",
            [M_UNAVAILABLE] = "This command is <color=yellow>unavailable</color> while \"<color=#F2BC14>Damage disabled by default</color>\" is \"<color=#195FFF>true</color>\" in the config file!"
        };


        #endregion

        #region [Commands]


        [ChatCommand("dd")]
        void CmdDD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Replier(player, M_NO_PERMISSION);
            }
            else if (disDefaultdmg)
            {
                Replier(player, M_UNAVAILABLE);
            }
            else
            {
                switch (args.Length)
                {
                    case 0:
                        if (!DisabledDamage.Contains(player.userID))
                        {
                            DisabledDamage.Add(player.userID);
                            Replier(player, M_SELF_DAMAGE_DISABLED);
                        }
                        else
                        {
                            DisabledDamage.Remove(player.userID);
                            Replier(player, M_SELF_DAMAGE_ENABLED);
                        }
                        break;
                    case 1:
                        BasePlayer findplayer = BasePlayer.Find(args[0].ToLower());
                        if (findplayer != null)
                        {
                            if (!DisabledDamage.Contains(player.userID))
                            {
                                DisabledDamage.Add(findplayer.userID);
                                Replier(player, M_PLAYER_DAMAGE_DISABLED, findplayer.displayName);
                                if (announceTarget)
                                {
                                    if (announceName)
                                        Replier(findplayer, M_DISABLED_BY, player.displayName);
                                    else
                                        Replier(findplayer, M_SELF_DAMAGE_DISABLED);
                                }
                            }
                            else
                            {
                                DisabledDamage.Remove(findplayer.userID);
                                Replier(player, M_PLAYER_DAMAGE_ENABLED, findplayer.displayName);
                                if (announceTarget)
                                {
                                    if (announceName)
                                        Replier(findplayer, M_ENABLED_BY, player.displayName);
                                    else
                                        Replier(findplayer, M_SELF_DAMAGE_ENABLED);
                                }
                            }
                        }
                        else
                            Replier(player, M_PLAYER_NOT_FOUND);
                        break;
                    default:
                        Replier(player, M_HELP);
                        break;
                }
            }
        }


        #endregion

        #region [Hooks]


        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (info != null && info.InitiatorPlayer != null && entity != null)
            {
                BasePlayer player = info.InitiatorPlayer;
                if ((disDefaultdmg || (player.IsConnected && player.userID.IsSteamId() && DisabledDamage.Contains(player.userID)))
                        && ((entity is BasePlayer && displayerdmg)
                                || (entity is BaseNpc && disNPCdmg)
                                || (entity is BaseAnimalNPC && disAnimaldmg)
                                || (entity is BuildingBlock && disStructdmg)
                                || ((entity.GetComponent<Deployable>() != null) && disStructdmg)
                                || (entity.PrefabName.Contains("barrel") && disBarreldmg)
                                || (entity is BaseHelicopter && disHelidmg)
                                || ((entity is BaseVehicle) && disTransportdmg)))
                {
                    info.damageTypes.ScaleAll(0);
                }
            }
        }

        void Init()
        {
            permission.RegisterPermission(PERMISSION_USE, this);
            LoadConfiguration();
            if (!disDefaultdmg)
            {
                if (Interface.Oxide.DataFileSystem.ExistsDatafile("DisableDamage"))
                {
                    try
                    {
                        DisabledDamage = Interface.Oxide.DataFileSystem.GetFile("DisableDamage").ReadObject<List<ulong>>();
                    }
                    catch
                    {
                        DisabledDamage = new List<ulong>();
                    }
                }
                else
                    DisabledDamage = new List<ulong>();
            }
        }

        void Unload() { if (!disDefaultdmg && savedisabled) Interface.Oxide.DataFileSystem.GetFile("DisableDamage").WriteObject(DisabledDamage); }


        #endregion

    }
}


// --- End of file: DisableDamage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/data-logging-kills-deaths ---
// --- Original File Path: D/DataLoggingDeaths/DataLoggingDeaths.cs ---

ï»¿// Requires: DataLogging

using System;
using System.Collections.Generic;
using System.Linq;
using JetBrains.Annotations;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Data Logging: Kills / Deaths", "Rustoholics", "0.1.3")]
    [Description("Log all kills and deaths")]

    public class DataLoggingDeaths : DataLogging
    {
        #region Object
        public class DeathObject
        {
            public bool Naked;
            public string KillerType;
            public ulong KillerId;
            public string VictimType = "";
            public ulong VictimId;
            public int WeaponId;
            public DateTime Date;
            
            [JsonIgnore]
            public bool Animal { get { return IsAnimal();} }
            [JsonIgnore]
            public bool Npc { get { return IsNpc();} }
             

            [CanBeNull]
            public DeathObject SetHitInfo(HitInfo hitinfo, bool naked)
            {
                Date = DateTime.Now;
                
                Naked = naked;

                if(hitinfo == null) return null;

                if(hitinfo.InitiatorPlayer == null && (hitinfo.HitEntity == null || hitinfo.HitEntity.ToPlayer() == null)) return null;

                if(hitinfo.InitiatorPlayer != null) KillerId = hitinfo.InitiatorPlayer.userID;

                if (hitinfo.HitEntity.ToPlayer() != null) VictimId = hitinfo.HitEntity.ToPlayer().userID;
                
                if (hitinfo.Weapon != null) WeaponId = hitinfo.Weapon.GetItem().info.itemid;

                if (hitinfo.InitiatorPlayer != null)
                {
                    if (hitinfo.InitiatorPlayer.userID.IsSteamId())
                    {
                        KillerType = "player";
                    }
                    else
                    {
                        KillerType = "npc";
                    }
                }
                else if (hitinfo.Initiator != null && hitinfo.Initiator.ShortPrefabName != null)
                {
                    KillerType = hitinfo.HitEntity.ShortPrefabName;
                }

                if (hitinfo.HitEntity != null)
                {
                    if (VictimId.IsSteamId())
                    {
                        VictimType = "player";
                        
                    }else if (hitinfo.HitEntity.ShortPrefabName != null)
                    {
                        VictimType = hitinfo.HitEntity.ShortPrefabName;
                    }
                }

                return this;
            }

            private bool IsAnimal()
            {
                var animals = new List<string>
                {
                    "boar","stag","bear","chicken","wolf","horse"
                };
                return (animals.Contains(VictimType)) ;
            }

            private bool IsNpc()
            {
                if (VictimType == "player") return false;
                if (Animal) return false;
                return true;
            }

            public string WeaponName()
            {
                if (WeaponId != 0)
                {
                    var def = ItemManager.FindItemDefinition(WeaponId);
                    if (def != null)
                    {
                        return def.displayName.english;
                    }
                }

                return "";
            }
        }

        public class PvpData
        {
            public KillData Kills = new KillData();
            public KillData Deaths = new KillData();
            public int NakedKills = 0;
            public int KilLStreak = 0;
            
            public class KillData
            {
                public int Player = 0;
                public int Animal = 0;
                public int Npc = 0;
            }
        }
        
        #endregion
        
        #region Setup
        
        DataManager<DeathObject> _deathData;
        DataManager<DeathObject> _killData;
        private Dictionary<string, bool> _hadWeapon = new Dictionary<string, bool>();

        private void OnServerInitialized()
        {
            _deathData = new DataManager<DeathObject>("death");
            _killData = new DataManager<DeathObject>("kill");
        }

        private void Unload()
        {
            _deathData.Save();
            _killData.Save();
        }
        
        private void OnServerSave() { timer.Once(UnityEngine.Random.Range(0f, 60f), () =>
        {
            _deathData.Save();
            _killData.Save();
        });}
        
        #endregion
        
        #region Language
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TotalPlayerKills"] = "Total Player Kills {0}",
                ["TotalPlayerDeaths"] = "Total Player Deaths {0}",
                ["PlayerKilLStreak"] = "Player Kill Streak {0}",
                ["NakedPercentage"] = "Naked Percentage {0}",
                ["AnimalKills"] = "Animal Kills {0}",
                ["NPCKills"] = "NPC Kills {0}",
                ["KillsForPlayer"] = "Kills for {0}",
                ["HasNoKills"] = "{0} has no kills",
                ["KillDetails"] = "{0}: Killed {1} using a {2}",
                ["InvalidPlayer"] = "Invalid Player",
                ["HasNoDeaths"] = "{0} has no deaths",
                ["DeathsForPlayer"] = "Deaths for {0}",
                ["DeathDetails"] = "{0}: Died to {1} using a {2}",
            }, this);
        }
        
        #endregion
        
        #region Hooks
        
        void OnEntityDeath(BasePlayer entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            if (!(entity.GetEntity() is BasePlayer) && (info.InitiatorPlayer == null)) return; // No players involved

            var naked = false;
            if (entity.GetEntity() is BasePlayer)
            {
                if (entity.GetEntity().ToPlayer().userID.IsSteamId())
                {
                    naked = IsNaked(entity.GetEntity() as BasePlayer);
                    
                    var death = new DeathObject().SetHitInfo(info, naked);

                    if (death == null || (death.KillerId == 0 && death.KillerType == "player")) return;
                    
                    _deathData.AddData(entity.GetEntity().ToPlayer().UserIDString, death);
                }
            }
            


            if (info.InitiatorPlayer != null && info.InitiatorPlayer.userID.IsSteamId()) // There is a kill
            {
                // Record player kill
                if (info.HitEntity.IsNpc || (info.HitEntity.ToPlayer() != null)) // && info.HitEntity.ToPlayer().userID.IsSteamId()))
                {
                    if (info.HitEntity.ToPlayer() == null || info.InitiatorPlayer.UserIDString != info.HitEntity.ToPlayer().UserIDString)
                    {
                        _killData.AddData(info.InitiatorPlayer.UserIDString, new DeathObject().SetHitInfo(info, naked));
                    }
                }
            }
        }
        
        #endregion
        
        #region Data Analysis
        
        private int GetKillStreak(string playerId, DateTime startDate = default(DateTime), DateTime endDate = default(DateTime))
        {
            var recentDeath = _deathData.GetDataLast(playerId);
            var kills = _killData.GetData(playerId).Where(kill => kill.VictimType == "player");
            if (startDate != default(DateTime)) kills = kills.Where(kill => kill.Date > startDate);
            if (endDate != default(DateTime)) kills = kills.Where(kill => kill.Date < endDate);
            
            if (recentDeath == null)
            {
                return kills.Count();
            }

            return kills.Count(kill => kill.Date > recentDeath.Date);
        }

        private int GetTotalKills(string playerId, string victimType="player")
        {
            var kills = _killData.GetData(playerId);
            if (victimType != "")
            {
                if (victimType == "animal")
                {
                    return kills.Count(kill => kill.Animal);
                }else if (victimType == "npc")
                {
                    return kills.Count(kill => kill.Npc);
                }
                return kills.Count(kill => kill.VictimType == victimType);
            }
            return kills.Count;
        }
        
        private int GetTotalDeaths(string playerId, string killerType="player", DateTime startDate = default(DateTime), DateTime endDate = default(DateTime))
        {
            var deaths = _deathData.GetData(playerId).Where(d => d.KillerId > 0 && d.KillerId != d.VictimId);
            if (deaths == null || !deaths.Any()) return 0;

            if (startDate != default(DateTime)) deaths = deaths.Where(d => d.Date > startDate);
            if (endDate != default(DateTime)) deaths = deaths.Where(d => d.Date < endDate);
            
            if (killerType != "" ) deaths = deaths.Where(d => d.KillerType == killerType);

            try
            {
                return deaths.Count();
            }
            catch (Exception e)
            {
                return 0;
            }
        }

        private double PercentageNakedKills(string playerId, int lastNKills=10, int secondsAgo=0)
        {
            var kills = _killData.GetData(playerId);
            if (kills.Count == 0) return 0d;

            var results = kills
                .Where(kill => kill.VictimType == "player")
                .OrderByDescending(kill => kill.Date).Take(lastNKills);
            
            if (secondsAgo > 0) results = results.Where(kill => kill.Date > DateTime.Now.AddSeconds(-secondsAgo));

            if (!results.Any())
            {
                return 0;
            }

            var naked = 0d;
            foreach (var kill in kills)
            {
                if (kill.Naked) naked++;
            }
            return naked / results.Count();
        }
        
        public Dictionary<string, PvpData> AllPVPData(DateTime startDate=default(DateTime), DateTime endDate=default(DateTime))
        {
            Dictionary<string, PvpData> result = new Dictionary<string, PvpData>();
            foreach (var data in _killData.GetAllData())
            {
                if (!result.ContainsKey(data.Key))
                {
                    result.Add(data.Key, new PvpData());
                }

                var killdata = data.Value.GetData().AsEnumerable();
                if (startDate != default(DateTime)) killdata = killdata.Where(k => k.Date > startDate);
                if (endDate != default(DateTime)) killdata = killdata.Where(k => k.Date < endDate);

                foreach (var kill in killdata)
                {
                    if (kill.Animal)
                    {
                        result[data.Key].Kills.Animal++;
                    }else if (kill.Npc)
                    {
                        result[data.Key].Kills.Npc++;
                    }
                    else
                    {
                        result[data.Key].Kills.Player++;
                    }

                    if (kill.Naked)
                    {
                        result[data.Key].NakedKills++;
                    }
                }

                result[data.Key].KilLStreak = GetKillStreak(data.Key, startDate, endDate);
            }
            
            foreach (var uid in _deathData.GetKeys())
            {
                if (!result.ContainsKey(uid))
                {
                    result.Add(uid, new PvpData());
                }

                result[uid].Deaths.Player = GetTotalDeaths(uid, "player", startDate, endDate);
            }

            return result;
        }
        
        #endregion
        
        #region Commands

        [Command("datalogging.kills")]
        private void KillsCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = GetCommandPlayer(iplayer, args);
            
            if (player == null) {
                iplayer.Reply(Lang("InvalidPlayer", iplayer.Id));
                return;
            }
            
            var kills = _killData.GetData(player.Id);
            if (kills.Count == 0)
            {
                iplayer.Reply(Lang("HasNoKills", iplayer.Id, player.Name));
                return;
            }
            
            iplayer.Reply(Lang("KillsForPlayer", iplayer.Id, player.Name));
            
            foreach (var kill in kills)
            {
                iplayer.Reply(Lang("KillDetails", iplayer.Id, kill.Date, kill.VictimType, kill.WeaponName()));                
            }
        }
        
        [Command("datalogging.deaths")]
        private void DeathsCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = GetCommandPlayer(iplayer, args);
            
            if (player == null) {
                iplayer.Reply(Lang("InvalidPlayer", iplayer.Id));
                return;
            }

            var deaths = _deathData.GetData(player.Id);
            if (deaths.Count == 0)
            {
                iplayer.Reply(Lang("HasNoDeaths", iplayer.Id, player.Name));
                return;
            }
            
            iplayer.Reply(Lang("DeathsForPlayer", iplayer.Id, player.Name));
            
            foreach (var death in deaths)
            {
                iplayer.Reply(Lang("DeathDetails", iplayer.Id, death.Date, death.KillerType, death.WeaponName()));                
            }
        }
        
        [Command("datalogging.pvp")]
        private void PVPCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = GetCommandPlayer(iplayer, args);
            
            if (player == null) {
                iplayer.Reply(Lang("InvalidPlayer", iplayer.Id));
                return;
            }

            iplayer.Reply(Lang("TotalPlayerKills", iplayer.Id, GetTotalKills(player.Id)));
            iplayer.Reply(Lang("TotalPlayerDeaths", iplayer.Id, GetTotalDeaths(player.Id)));
            iplayer.Reply(Lang("PlayerKilLStreak", iplayer.Id, GetKillStreak(player.Id)));
            iplayer.Reply(Lang("NakedPercentage", iplayer.Id, PercentageNakedKills(player.Id)));
            iplayer.Reply(Lang("AnimalKills", iplayer.Id, GetTotalKills(player.Id, "animal")));
            iplayer.Reply(Lang("NPCKills", iplayer.Id, GetTotalKills(player.Id, "npc")));
        }
        
        #endregion
        
        #region Helpers
        private bool IsNaked(BasePlayer bp)
        {
            if (bp.inventory.containerWear.itemList.Count > 0)
            {
                return false;
            }

            return (!HasWeapon(bp));
        }
        
        private bool HasWeapon(BasePlayer player)
        {
            bool weapon;
            if (_hadWeapon.TryGetValue(player.userID.ToString(), out weapon))
            {
                if (weapon)
                {
                    return true;
                }
            }
            
            foreach (Item obj in player.inventory.containerBelt.itemList.ToArray())
            {
                if (isWeapon(obj))
                {
                    return true;
                }
            }
            
            foreach (Item obj in player.inventory.containerMain.itemList.ToArray())
            {
                if (isWeapon(obj))
                {
                    return true;
                }
            }

            return false;
        }

        private bool isWeapon(Item item)
        {
            var name = item.info.shortname;
            if (name == "rock" || name == "torch")
            {
                return false;
            }
            
            var cat = item.info.category.ToString("G");
            if (cat == "Weapon" || cat == "Tool")
            {
                return true;
            }
            
            return false;
        }
        
        private void SetHasWeapon(string userid, bool weapon)
        {
            _hadWeapon[userid] = weapon;
        }
        
        #endregion

        #region API
        
        private JObject API_AllPVPData(DateTime startDate=default(DateTime), DateTime endDate=default(DateTime))
        {
            return JObject.FromObject(AllPVPData(startDate, endDate));
        }

        private int API_TotalKills(string playerId)
        {
            return GetTotalKills(playerId);
        }

        private int API_GetKillStreak(string playerId)
        {
            return GetKillStreak(playerId);
        }

        private double API_PercentageNakedKills(string playerid)
        {
            return PercentageNakedKills(playerid);
        }

        private bool API_Helper_IsNaked(BasePlayer player)
        {
            return IsNaked(player);
        }

        private JObject API_GetPlayerKills(string playerId)
        {
            return JObject.FromObject(_killData.GetData(playerId));
        }
        
        private JObject API_GetPlayerDeaths(string playerId)
        {
            return JObject.FromObject(_deathData.GetData(playerId));
        }

        #endregion
    }
}

// --- End of file: DataLoggingDeaths.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/death-notes ---
// --- Original File Path: D/DeathNotes/DeathNotes.cs ---

// #define DEBUG

using Newtonsoft.Json;
using Oxide.Core;
using Rust;
using Rust.Ai.Gen2;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Death Notes", "Terceran/Mr. Blue", "6.4.3")]
	[Description("Broadcasts deaths to chat along with detailed information")]
	class DeathNotes : RustPlugin
	{
		#region Fields

		private const string WildcardCharacter = "*";
		private const string CanSeePermission = "deathnotes.cansee";
        private const string SuppressPermission = "deathnotes.suppress";

		private static DeathNotes _instance;

		private PluginConfiguration _configuration;

		private readonly Dictionary<string, string> _enemyPrefabs = new()
		{
			["spikes.floor"] = "Wooden Floor Spikes",
			["barricade.woodwire"] = "Barbed Wooden Barricade",
			["barricade.metal"] = "Metal Barricade",
			["wall.external.high.wood"] = "High External Wooden Wall",
			["wall.external.high.stone"] = "High External Stone Wall",
			["gates.external.high.stone"] = "High External Stone Gate",
			["campfire"] = "Campfire",
			["skull_fire_pit"] = "Skull Fire Pit",
			["heavyscientist"] = "Heavy Scientist"
		};
		private readonly Dictionary<string, string> _weaponPrefabs = new()
		{
			["rocket_basic"] = "Rocket",
			["rocket_hv"] = "High Velocity Rocket",
			["rocket_fire"] = "Incendiary Rocket",
			["grenade.f1.deployed"] = "F1 Grenade",
			["grenade.beancan.deployed"] = "Beancan Grenade",
			["survey_charge.deployed"] = "Survey Charge",
			["explosive.satchel.deployed"] = "Satchel Charge",
			["explosive.timed.deployed"] = "Timed Explosive Charge",
			["rock.entity"] = "Rock",
			["longsword.entity"] = "Longsword",
			["mace.entity"] = "Mace",
			["spear_stone.entity"] = "Stone Spear",
			["spear_wooden.entity"] = "Wooden Spear",
			["machete.weapon"] = "Machete",
			["knife_bone.entity"] = "Bone Knife",
			["bone_club.entity"] = "Bone Club",
			["salvaged_cleaver.entity"] = "Salvaged Cleaver",
			["salvaged_sword.entity"] = "Salvaged Sword",
			["candy_cane.entity"] = "Candy Cane Club",
			["flamethrower.entity"] = "Flame Thrower",
			["snowball.entity"] = "Snowball",
			["combat.knife.entity"] = "Combat Knife"
		};
		private readonly Dictionary<string, CombatEntityType> _combatEntityTypes = new()
		{
			["GunTrap"]  = CombatEntityType.Trap,
			["FlameTurret"]  = CombatEntityType.Turret,
			["AutoTurret"]  = CombatEntityType.Turret,
			["BaseHelicopter"]  = CombatEntityType.Helicopter,
			["BradleyAPC"]  = CombatEntityType.Bradley,
			["BasePlayer"]  = CombatEntityType.Player,
			["NPCMurderer"]  = CombatEntityType.Murderer,
			["CodeLock"]  = CombatEntityType.Lock,
			["Scientist"]  = CombatEntityType.Scientist,
			["ScientistNPC"]  = CombatEntityType.Scientist,
			["HTNPlayer"]  = CombatEntityType.Scientist,
			["NPCAutoTurret"]  = CombatEntityType.Sentry,
			["FireBall"]  = CombatEntityType.Fire,
			["scarecrow"]  = CombatEntityType.ScarecrowNPC,
			["ScientistNPCNew"]  = CombatEntityType.Scientist,
			["tunneldweller"]  = CombatEntityType.TunnelDweller,
			["underwaterdweller"]  = CombatEntityType.UnderwaterDweller
		};

		private readonly Regex _colorTagRegex =
			new Regex(@"<color=.{0,7}>", RegexOptions.Compiled | RegexOptions.IgnoreCase);

		private readonly Regex _sizeTagRegex =
			new Regex(@"<size=\d*>", RegexOptions.Compiled | RegexOptions.IgnoreCase);

		private readonly List<string> _richTextLiterals = new List<string>
		{
			"</color>", "</size>", "<b>", "</b>", "<i>", "</i>"
		};

		private readonly Dictionary<ulong, AttackInfo> _previousAttack = new Dictionary<ulong, AttackInfo>();

        private Dictionary<ulong, HitInfo> _patrolHeliTagTracker = new Dictionary<ulong, HitInfo>();
        private HashSet<ulong> _bradleyApcTagTracker = new HashSet<ulong>();

		private readonly Func<PluginConfiguration.DeathMessage, DeathData, bool>[] _messageMatchingStages =
		{
			(m, d) => MatchesCombatEntityType(d.KillerEntityType, m.KillerType) &&
			          MatchesCombatEntityType(d.VictimEntityType, m.VictimType) &&
			          MatchesDamageType(d.DamageType, m.DamageType),

			(m, d) => MatchesCombatEntityType(d.KillerEntityType, m.KillerType) &&
			          MatchesCombatEntityType(d.VictimEntityType, m.VictimType) &&
			          m.DamageType == WildcardCharacter,

			(m, d) => MatchesCombatEntityType(d.KillerEntityType, m.KillerType) &&
			          m.VictimType == WildcardCharacter &&
			          MatchesDamageType(d.DamageType, m.DamageType),

			(m, d) => m.KillerType == WildcardCharacter &&
			          MatchesCombatEntityType(d.VictimEntityType, m.VictimType) &&
			          MatchesDamageType(d.DamageType, m.DamageType),

			(m, d) => MatchesCombatEntityType(d.KillerEntityType, m.KillerType) &&
			          m.VictimType == WildcardCharacter &&
			          m.DamageType == WildcardCharacter,

			(m, d) => m.KillerType == WildcardCharacter &&
			          MatchesCombatEntityType(d.VictimEntityType, m.VictimType) &&
			          m.DamageType == WildcardCharacter,

			(m, d) => m.KillerType == WildcardCharacter &&
			          m.VictimType == WildcardCharacter &&
			          MatchesDamageType(d.DamageType, m.DamageType),

			(m, d) => m.KillerType == WildcardCharacter &&
			          m.VictimType == WildcardCharacter &&
			          m.DamageType == WildcardCharacter
		};

		#endregion

		#region Hooks

		private void Init()
		{
			_instance = this;

			permission.RegisterPermission(CanSeePermission, this);
            permission.RegisterPermission(SuppressPermission, this);

			_configuration = Config.ReadObject<PluginConfiguration>();
			_configuration.LoadDefaults();
			Config.WriteObject(_configuration);
		}

		private void Unload()
		{
			_instance = null;
		}

		private void OnEntityTakeDamage(BasePlayer victimEntity, HitInfo hitInfo)
		{
			if (victimEntity == null || hitInfo == null)
            	return;

			// Don't track bleeding
			if (victimEntity.lastDamage == DamageType.Bleeding)
				return;

            var userId = victimEntity.ToPlayer().userID;

			_previousAttack[userId] = new AttackInfo
			{
				HitInfo = hitInfo,
				Attacker = victimEntity.lastAttacker ?? hitInfo?.Initiator,
				DamageType = victimEntity.lastDamage
			};
		}

        //This method tracks Bradley APC damage and reports whoever tagged it.
        private void OnEntityTakeDamage(BradleyAPC victimEntity, HitInfo hitInfo) => HandleEntityDamage(victimEntity, hitInfo);
        
        //This method tracks Patrol Helicopter damage and reports whoever tagged it.
		private void OnPatrolHelicopterTakeDamage(PatrolHelicopter victimEntity, HitInfo hitInfo) => HandleEntityDamage(victimEntity, hitInfo);

		private void HandleEntityDamage( BaseCombatEntity victimEntity, HitInfo hitInfo )
		{
			if (victimEntity == null || hitInfo == null)
				return;

			bool isPatrolHeli = victimEntity is PatrolHelicopter;

			HitInfo storedHitInfo;
			ulong netID = victimEntity.net.ID.Value;

			if (isPatrolHeli)
			{
				bool wasHeliIdFound = _patrolHeliTagTracker.TryGetValue(netID, out storedHitInfo);
				if (!wasHeliIdFound)
				{
					storedHitInfo = new HitInfo();
					_patrolHeliTagTracker.Add(netID, storedHitInfo);
				}

				if (hitInfo.WeaponPrefab != null)
					storedHitInfo.WeaponPrefab = hitInfo.WeaponPrefab;

				if (hitInfo.Weapon != null)
					storedHitInfo.Weapon = hitInfo.Weapon;

				if (wasHeliIdFound || (victimEntity.lastAttackedTime != float.NegativeInfinity))
					return;
				
				if (storedHitInfo.Initiator == null && hitInfo.Initiator != null)
					storedHitInfo.Initiator = hitInfo.Initiator;
			}
			else //If it's a Bradley APC
			{
				if ((victimEntity.lastAttackedTime != float.NegativeInfinity) || (_bradleyApcTagTracker.Contains(netID)))
					return;
				_bradleyApcTagTracker.Add(netID);
				storedHitInfo = hitInfo;
			}

			var attackerPlayer = hitInfo.Initiator?.ToPlayer();
			if( attackerPlayer?.displayName == null )
			{
				return;
			}

			storedHitInfo.Initiator = hitInfo.Initiator;

			if( (isPatrolHeli ? !_configuration.ShowPatrolHeliTags : !_configuration.ShowBradleyTags) || permission.UserHasPermission( attackerPlayer.UserIDString, SuppressPermission ) )
			{
				return;
			}

			var data = new DeathData
			{
				VictimEntity = victimEntity,
				KillerEntity = victimEntity.lastAttacker ?? hitInfo.Initiator,
				VictimEntityType = GetCombatEntityType(victimEntity),
				KillerEntityType = GetCombatEntityType(victimEntity.lastAttacker),
				DamageType = victimEntity.lastDamage,
				HitInfo = storedHitInfo
			};

			if (data.KillerEntity != null)
				data.KillerEntityType = CombatEntityType.Player;
					
			string message = PopulateMessageVariables(isPatrolHeli ? _configuration.PatrolHeliTagMessage : _configuration.BradleyTagMessage, data);

			object hookResult = false;
			try
			{
				hookResult = Interface.Call("OnDeathNotice", data.ToDictionary(), message);
			}
			catch (NullReferenceException)
			{
				return;
			}
			
			if (hookResult?.Equals(false) ?? false)
				return;

			if( _configuration.ShowInChat )
			{
				foreach (var player in BasePlayer.activePlayerList)
				{
					if (_configuration.RequirePermission &&
					    !permission.UserHasPermission(player.UserIDString, CanSeePermission))
						continue;

					if (_configuration.MessageRadius != -1 &&
					    player.Distance(data.VictimEntity) > _configuration.MessageRadius)
						continue;

					Player.Reply(
						player,
						_configuration.ChatFormat.Replace("{message}", message),
						ulong.Parse(_configuration.ChatIcon)
					);
				}
			}

			if (_configuration.ShowInConsole)
				Puts(StripRichText(message));
		}
		
		//This method tracks when Patrol Helicopters are killed or despawns naturally, and cleans them from the tag trackers.
		private void OnEntityKill(PatrolHelicopter entity)
		{
			_patrolHeliTagTracker.Remove(entity.net.ID.Value);
		}

		//This method tracks when Bradley APCs are killed or despawns naturally, and cleans them from the tag trackers.
		private void OnEntityKill(BradleyAPC entity)
		{
			_bradleyApcTagTracker.Remove(entity.net.ID.Value);
		}
		
		private void OnEntityDeath(BaseCombatEntity victimEntity, HitInfo hitInfo)
		{
			//There is no victim information for some reason.
			//Note: If someone is wounded and dies, there will be null hitInfo
			if (victimEntity == null)
				return;

			// Try to avoid error when entity was destroyed
			if (victimEntity.gameObject == null)
				return;

			ulong netID = victimEntity.net.ID.Value;
			
			var data = new DeathData
			{
				VictimEntity = victimEntity,
				KillerEntity = victimEntity.lastAttacker ?? hitInfo?.Initiator,
				VictimEntityType = GetCombatEntityType(victimEntity),
				KillerEntityType = GetCombatEntityType(victimEntity.lastAttacker),
				DamageType = victimEntity.lastDamage,
				HitInfo = hitInfo
			};
			
			if (victimEntity is PatrolHelicopter && _patrolHeliTagTracker.TryGetValue( netID, out var value ))
				data.HitInfo = value;

			// Handle inconsistencies/exceptions
			HandleInconsistencies(ref data);

#if DEBUG
			LogDebug("[DEATHNOTES DEBUG]");
			LogDebug(
				$"VictimEntity: {data.VictimEntity?.GetType().Name ?? "NULL"} / {data.VictimEntity?.ShortPrefabName ?? "NULL"} / {data.VictimEntity?.PrefabName ?? "NULL"}");
			LogDebug(
				$"KillerEntity: {data.KillerEntity?.GetType().Name ?? "NULL"} / {data.KillerEntity?.ShortPrefabName ?? "NULL"} / {data.KillerEntity?.PrefabName ?? "NULL"}");
			LogDebug($"VictimEntityType: {data.VictimEntityType}");
			LogDebug($"KillerEntityType: {data.KillerEntityType}");
			LogDebug($"DamageType: {data.DamageType}");
			LogDebug($"Bodypart: {GetCustomizedBodypartName(data.HitInfo)}");
			LogDebug($"Weapon: {hitInfo?.WeaponPrefab?.ShortPrefabName ?? "NULL"}");
#endif
			
			// Change entity type for dwellers
			RepairEntityTypes(ref data);

			// Need do this before we cancel out of the method, as we need to track all these entities dying. Even if it's not a player killing them.
			if (victimEntity is PatrolHelicopter)
				_patrolHeliTagTracker.Remove(netID);
			else if (victimEntity is BradleyAPC)
				_bradleyApcTagTracker.Remove(netID);
			
			// Ignore deaths of other entities
			if (data.KillerEntityType == CombatEntityType.Other || data.VictimEntityType == CombatEntityType.Other)
				return;

			// Ignore deaths which don't involve players or the helicopter which usually does not track a player as killer
			if (data.VictimEntityType != CombatEntityType.Player && data.KillerEntityType != CombatEntityType.Player &&
				data.VictimEntityType != CombatEntityType.Helicopter)
				return;

			// Populate the variables in the message
			string message = PopulateMessageVariables(
				// Find the best matching death message for this death
				GetDeathMessage(data),
				data
			);

			if (message == null)
				return;

			object hookResult = false;
			try
			{ 
				hookResult = Interface.Call("OnDeathNotice", data.ToDictionary(), message);
			}
			catch (NullReferenceException)
			{
				return;
			}

			if (hookResult?.Equals(false) ?? false)
				return;
			
			if ((_configuration.ShowInChat || _configuration.ShowInConsole) &&
				((data.KillerEntityType == CombatEntityType.Player && !permission.UserHasPermission(data.KillerEntity?.ToPlayer()?.UserIDString, SuppressPermission)) ||
				 (data.VictimEntityType == CombatEntityType.Player && !permission.UserHasPermission(data.VictimEntity?.ToPlayer()?.UserIDString, SuppressPermission))))
			{

				if (_configuration.ShowInChat)
				{

					foreach (var player in BasePlayer.activePlayerList)
					{

						if (_configuration.RequirePermission &&
							!permission.UserHasPermission(player.UserIDString, CanSeePermission))
							continue;

						if (_configuration.MessageRadius != -1 &&
							player.Distance(data.VictimEntity) > _configuration.MessageRadius)
							continue;

						Player.Reply(
							player,
							_configuration.ChatFormat.Replace("{message}", message),
							ulong.Parse(_configuration.ChatIcon)
						);
					}
				}

				if (_configuration.ShowInConsole)
					Puts(StripRichText(message));
			}
		}

		private void RepairEntityTypes(ref DeathData data)
		{
			if (data.VictimEntity != null)
			{
				string victimPrefabName = data.VictimEntity.ShortPrefabName.ToLower();
				if (victimPrefabName.Contains("underwaterdweller"))
				{
					data.VictimEntityType = CombatEntityType.UnderwaterDweller;
				}
				else if (victimPrefabName.Contains("tunneldweller"))
				{
					data.VictimEntityType = CombatEntityType.TunnelDweller;
				}
				else if (victimPrefabName.Contains("bradleyapc"))
				{
					data.VictimEntityType = CombatEntityType.Bradley;
				}
			}

			if (data.KillerEntity != null)
			{
				string killerPrefabName = data.KillerEntity.ShortPrefabName.ToLower();

				if (killerPrefabName.Contains("underwaterdweller"))
				{
					data.KillerEntityType = CombatEntityType.UnderwaterDweller;
				}
				else if (killerPrefabName.Contains("tunneldweller"))
				{
					data.KillerEntityType = CombatEntityType.TunnelDweller;
				}
				else if (killerPrefabName.Contains("bradleyapc"))
				{
					data.KillerEntityType = CombatEntityType.Bradley;
				}
			}
		}

		private void OnFlameThrowerBurn(FlameThrower flameThrower, BaseEntity baseEntity)
		{
			if (flameThrower == null || baseEntity == null) return;

			var flame = baseEntity.gameObject.AddComponent<Flame>();
			flame.Source = Flame.FlameSource.Flamethrower;
			flame.SourceEntity = flameThrower;
			flame.Initiator = flameThrower.GetOwnerPlayer();
		}

		private void OnFlameExplosion(FlameExplosive explosive, BaseEntity baseEntity)
		{
			if (explosive == null || baseEntity == null) return;

			var flame = baseEntity.gameObject.AddComponent<Flame>();
			flame.Source = Flame.FlameSource.IncendiaryProjectile;
			flame.SourceEntity = explosive;
			flame.Initiator = explosive.creatorEntity;
		}

		private void OnFireBallSpread(FireBall fireBall, BaseEntity newFire)
		{
			if (fireBall == null) return;

			var flame = fireBall.GetComponent<Flame>();
			if (flame == null) return;

			var newFlame = newFire.gameObject.AddComponent<Flame>();
			newFlame.Source = flame.Source;
			newFlame.SourceEntity = flame.SourceEntity;
			newFlame.Initiator = flame.Initiator;
		}

		private void OnFireBallDamage(FireBall fireBall, BaseCombatEntity target, HitInfo hitInfo) =>
			hitInfo.Initiator = fireBall;

		#endregion

		#region Death Messages

		private string GetDeathMessage(DeathData data)
		{
			foreach (var matchingStage in _messageMatchingStages)
			{
				var match = _configuration.Translations.Messages.Find(m => matchingStage.Invoke(m, data));

				if (match != null)
					return match.Messages.GetRandom((uint) DateTime.UtcNow.Millisecond);
			}

			return null;
		}

		private string PopulateMessageVariables(string message, DeathData data)
		{
			if (string.IsNullOrEmpty(message))
				return null;

			var replacements = new Dictionary<string, string>
			{
				["victim"] = GetCustomizedEntityName(data.VictimEntity, data.VictimEntityType)
			};

			if (data.KillerEntityType != CombatEntityType.None)
			{
				replacements.Add("killer", GetCustomizedEntityName(data.KillerEntity, data.KillerEntityType));
				replacements.Add("bodypart", GetCustomizedBodypartName(data.HitInfo));

				if (data.KillerEntity != null)
				{
					var distance = data.KillerEntity.Distance(data.VictimEntity);
					replacements.Add("distance", GetDistance(distance, _configuration.UseMetricDistance));
				}

				if (data.KillerEntityType == CombatEntityType.Player)
				{
					replacements.Add("hp", data.KillerEntity.Health().ToString("#0.#"));
					replacements.Add("weapon", GetCustomizedWeaponName(data));
					replacements.Add("attachments", string.Join(", ", GetCustomizedAttachmentNames(data.HitInfo)));
				}
				else if (data.KillerEntityType == CombatEntityType.Turret
						 || data.KillerEntityType == CombatEntityType.Lock
						 || data.KillerEntityType == CombatEntityType.Trap)
				{
					replacements.Add("owner",
						covalence.Players.FindPlayerById(data.KillerEntity.OwnerID.ToString())?.Name ?? "unknown owner"
					); // TODO: Work on the potential unknown owner case
				}
			}

			message = InsertPlaceholderValues(message, replacements);

			replacements = null;
			return message;
		}

		private struct DeathData
		{
			public CombatEntityType VictimEntityType { get; set; }
			[JsonIgnore] public BaseCombatEntity VictimEntity { get; set; }

			public CombatEntityType KillerEntityType { get; set; }
			[JsonIgnore] public BaseEntity KillerEntity { get; set; }

			public DamageType DamageType { get; set; }
			[JsonIgnore] public HitInfo HitInfo { get; set; }

			public Dictionary<string, object> ToDictionary() => new Dictionary<string, object>
			{
				["VictimEntityType"] = VictimEntityType,
				["VictimEntity"] = VictimEntity,
				["KillerEntityType"] = KillerEntityType,
				["KillerEntity"] = KillerEntity,
				["DamageType"] = DamageType,
				["HitInfo"] = HitInfo
			};
		}

		#endregion

		#region Entity Identification

		private CombatEntityType GetCombatEntityType(BaseEntity entity)
		{
			
			if (entity == null)
				return CombatEntityType.None;
			
			string entityTypeName = entity.GetType().Name;
			if (entityTypeName != "ScientistNPC" && _combatEntityTypes.TryGetValue( entityTypeName, out var entityType ))
				return entityType;

			if (_combatEntityTypes.TryGetValue( entity.ShortPrefabName, out var type ))
				return type;

			//For those plugins that do not correctly type ZombieNPCs as Zombies.
			if (entityTypeName.StartsWith("Zombie"))
				return CombatEntityType.ZombieNPC;
			
 			switch (entity)
			{
				case ScientistNPC:
				{
					if (entity.ShortPrefabName.EndsWith("heavy"))
						return CombatEntityType.HeavyScientist;
					return CombatEntityType.Scientist;
				}

				case Zombie:
					return CombatEntityType.ZombieNPC;
				
				case PatrolHelicopter:
					return CombatEntityType.Helicopter;
				
				case BaseAnimalNPC:
				case SimpleShark:
				case Wolf2:
				case FarmableAnimal:
					return CombatEntityType.Animal;
				
				case BaseOven:
					return CombatEntityType.HeatSource;
				
				case SimpleBuildingBlock:
					return CombatEntityType.ExternalWall;
				
				case Barricade:
					return CombatEntityType.Barricade;
				
				case BaseTrap:
				case IOEntity:
					return CombatEntityType.Trap;

				case GingerbreadNPC:
					return CombatEntityType.GingerbreadNPC;
				
				case Minicopter:
					return CombatEntityType.Minicopter;
				
				case ScrapTransportHelicopter:
					return CombatEntityType.ScrapTransportHelicopter;
				
				case AttackHelicopter:
					return CombatEntityType.AttackHelicopter;
				
				case BeeSwarmAI:
					return CombatEntityType.BeeSwarm;
				
				default:
					return CombatEntityType.Other;
			}
		}

		private string GetCustomizedEntityName(BaseEntity entity, CombatEntityType combatEntityType)
		{
			var name = GetEntityName(entity, combatEntityType);

			if (string.IsNullOrEmpty(name))
				return null;

			// Don't load player names into config
			if (combatEntityType == CombatEntityType.Player)
				return name;

			if (!_configuration.Translations.Names.ContainsKey(name))
			{
				_configuration.Translations.Names.Add(name, name);
				Config.WriteObject(_configuration);
			}

			return _configuration.Translations.Names[name];
		}

		private string GetEntityName(BaseEntity entity, CombatEntityType combatEntityType)
		{
			// Entity may be null for helicopter or bradley, see HandleExceptions(...)
			if (entity == null &&
				combatEntityType != CombatEntityType.Helicopter &&
				combatEntityType != CombatEntityType.Bradley)
				return null;

			switch (combatEntityType)
			{
				case CombatEntityType.Player:
					return StripRichText(entity.ToPlayer().displayName);
				
				case CombatEntityType.Murderer:
				case CombatEntityType.ScarecrowNPC:
				case CombatEntityType.Scientist:
				case CombatEntityType.HeavyScientist:
				case CombatEntityType.ZombieNPC:
				case CombatEntityType.GingerbreadNPC:
					var name = entity.ToPlayer()?.displayName;
					
					if ((combatEntityType == CombatEntityType.HeavyScientist) && (name == "Scientist"))
						name = "Heavy Scientist";
					
					if (!string.IsNullOrEmpty(name) && name != entity.ToPlayer()?.userID.ToString())
					{
						return name;
					}

					if (!_enemyPrefabs.ContainsKey(entity.ShortPrefabName))
					{
						return combatEntityType.ToString();
					}

					break;

				case CombatEntityType.TunnelDweller:
					return "Tunnel Dweller";

				case CombatEntityType.UnderwaterDweller:
					return "Underwater Dweller";

				case CombatEntityType.Helicopter:
					return "Patrol Helicopter";

				case CombatEntityType.Bradley:
					return "Bradley APC";

				case CombatEntityType.Sentry:
					return "Sentry";
				
				case CombatEntityType.Fire:
					return entity.creatorEntity?.ToPlayer()?.displayName ?? "Fire";
					
				case CombatEntityType.Minicopter:
					return "Minicopter";
				
				//NOTE: Scrappy reporting can't work because a death results in two death notices. One is where the Scrappy is both the killer and the victim,
				//and the other is where it shows the player as having committed suicide, even though they did not.
				case CombatEntityType.ScrapTransportHelicopter:
					return "ScrapTransportHelicopter";
				
				case CombatEntityType.AttackHelicopter:
					return "AttackHelicopter";
				
				case CombatEntityType.BeeSwarm:
					return "BeeSwarm";
			}

			if (_enemyPrefabs.TryGetValue( entity.ShortPrefabName, out string entityName ))
				return entityName;

			return HumanizePascalCase(entity.GetType().Name);
		}

		internal enum CombatEntityType
		{
			Helicopter = 0,
			Bradley = 1,
			Animal = 2,
			Murderer = 3,
			Scientist = 4,
			Player = 5,
			Trap = 6,
			Turret = 7,
			Barricade = 8,
			ExternalWall = 9,
			HeatSource = 10,
			Fire = 11,
			Lock = 12,
			Sentry = 13,
			Other = 14,
			None = 15,
			ScarecrowNPC = 16,
			TunnelDweller = 17,
			UnderwaterDweller = 18,
			ZombieNPC = 19,
			GingerbreadNPC = 20,
			HeavyScientist = 21,
			Minicopter = 22,
			ScrapTransportHelicopter = 23,
			AttackHelicopter = 24,
			BeeSwarm = 25
		}

		#endregion

		#region Workarounds and Inconsistency Handling

		private void HandleInconsistencies(ref DeathData data)
		{
			// Deaths of other entity types are not of interest and might cause errors
			if (data.VictimEntityType == CombatEntityType.Other)
				return;

			if (data.KillerEntity is FireBall)
				data.DamageType = DamageType.Heat;

			// If the killer entity is null, but a weapon is given, we might be able to fall back to the parent entity of that weapon
			// Notably for the auto turret after the changes it has had
			if (data.KillerEntity == null && data.HitInfo?.Weapon != null)
			{
				data.KillerEntity = data.HitInfo.Weapon.GetParentEntity();
				data.KillerEntityType = GetCombatEntityType(data.KillerEntity);
			}

			// Get previous attacker when bleeding out
			if (data.VictimEntityType == CombatEntityType.Player &&
				(data.DamageType == DamageType.Bleeding || data.HitInfo == null))
			{
				var userId = data.VictimEntity.ToPlayer().userID;

				if (_previousAttack.ContainsKey(userId))
				{
					var attack = _previousAttack[userId];
					data.KillerEntity = attack.Attacker;
					data.KillerEntityType = GetCombatEntityType(data.KillerEntity);

					// Restore previous hitInfo for weapon determination
					if (attack.HitInfo != null)
						data.HitInfo = attack.HitInfo;

					// Use previous damagetype if this is a selfinflicted death,
					// so falling to death etc. is also shown when wounded and bleeding out
					if (data.KillerEntity == null || data.KillerEntity == data.VictimEntity)
						data.DamageType = attack.DamageType;
					else
						data.DamageType = DamageType.Bleeding;
				}
			}

			if (data.KillerEntityType != CombatEntityType.None && data.KillerEntity != null)
			{
				// Workaround for deaths caused by flamethrower or rocket fire 
				var flame = data.KillerEntity.gameObject.GetComponent<Flame>();
				if (flame != null && flame.Initiator != null)
				{
					data.KillerEntity = flame.Initiator;
					data.KillerEntityType = CombatEntityType.Player;
					return;
				}
			}

			// Bradley kill with main cannon
			if (data.HitInfo?.WeaponPrefab?.ShortPrefabName == "maincannonshell")
			{
				data.KillerEntityType = CombatEntityType.Bradley;
				return;
			}

			if (data.HitInfo?.WeaponPrefab?.ShortPrefabName?.StartsWith("rocket_heli") ?? false)
			{
				data.KillerEntityType = CombatEntityType.Helicopter;
				return;
			}
			
			// Vehicle Kills
			if (data.KillerEntityType == CombatEntityType.Player
				&& data.DamageType == DamageType.Generic
				&& data.KillerEntity.ToPlayer().isMounted)
			{
				data.DamageType = DamageType.Collision;
				return;
			}
		}

		private struct AttackInfo
		{
			public HitInfo HitInfo { get; set; }
			public DamageType DamageType { get; set; }
			public BaseEntity Attacker { get; set; }
		}

		private class Flame : MonoBehaviour
		{
			public FlameSource Source { get; set; }
			public BaseEntity SourceEntity { get; set; }
			public BaseEntity Initiator { get; set; }

			public enum FlameSource
			{
				Flamethrower,
				IncendiaryProjectile
			}
		}

		#endregion

		#region Weapons

		private string GetCustomizedWeaponName(DeathData deathData)
		{
			var name = GetWeaponName(deathData);

			if (string.IsNullOrEmpty(name))
				return null;

			if (!_configuration.Translations.Weapons.ContainsKey(name))
			{
				_configuration.Translations.Weapons.Add(name, name);
				Config.WriteObject(_configuration);
			}

			return _configuration.Translations.Weapons[name];
		}

		private string GetWeaponName(DeathData deathData)
		{
			if (deathData.HitInfo == null)
				return null;

			Item item = deathData.HitInfo.Weapon?.GetItem();
			/*var parentEntity = hitInfo.Weapon?.GetParentEntity();
			Item item = null;

			if (parentEntity is BasePlayer)
			{
				(parentEntity as BasePlayer).inventory.FindItemUID(hitInfo.Weapon.ownerItemUID);
			}
			else if (parentEntity is ContainerIOEntity)
			{
				(parentEntity as ContainerIOEntity).inventory.FindItemByUID(hitInfo.Weapon.ownerItemUID);
			}*/

			if (item != null)
				return item.info.displayName.english;

			var prefab = deathData.HitInfo.Initiator?.GetComponent<Flame>()?.SourceEntity?.ShortPrefabName ??
						 deathData.HitInfo.WeaponPrefab?.ShortPrefabName;

			if (prefab != null)
			{
				if (_weaponPrefabs.TryGetValue( prefab, out string weaponName ))
					return weaponName;

				return prefab;
			}
			
			//Added by Terceran 20250215. Ballistas are a special case because they are considered a vehicle and
			//not a weapon.
			if (deathData.HitInfo.ProjectilePrefab?.name?.StartsWith("ballista") ?? false)
			{
				return "Ballista";
			}

			// Vehicles are the only thing we classify as a weapon, while not being classified as such by the game.
			// TODO: Having this here kinda sucks, make this better.
			if (deathData.DamageType == DamageType.Collision)
			{
				return "Vehicle";
			}

			return null;
		}

		private string[] GetCustomizedAttachmentNames(HitInfo info)
		{
			var items = info?.Weapon?.GetItem()?.contents?.itemList;

			if (items == null)
			{
				return Array.Empty<string>();
			}

			return items.Select(i => GetCustomizedAttachmentName(i.info.displayName.english)).ToArray();
		}

		private string GetCustomizedAttachmentName(string name)
		{
			if (!_configuration.Translations.Attachments.ContainsKey(name))
			{
				_configuration.Translations.Attachments.Add(name, name);
				Config.WriteObject(_configuration);
			}

			return _configuration.Translations.Attachments[name];
		}

		#endregion

		#region Bodyparts

		private string GetCustomizedBodypartName(HitInfo hitInfo)
		{
			var name = GetBodypartName(hitInfo);

			if (string.IsNullOrEmpty(name))
				return null;

			if (!_configuration.Translations.Bodyparts.ContainsKey(name))
			{
				_configuration.Translations.Bodyparts.Add(name, name);
				Config.WriteObject(_configuration);
			}

			return _configuration.Translations.Bodyparts[name];
		}

		private string GetBodypartName(HitInfo hitInfo)
		{
			var hitArea = hitInfo?.boneArea ?? (HitArea) (-1);
			return (int) hitArea == -1 ? "Body" : hitArea.ToString();
		}

		#endregion

		#region Helper

#if DEBUG
		private static void LogDebug(string text)
		{
			if (BasePlayer.activePlayerList.Count >= 1)
			{
				BasePlayer.activePlayerList[0].ConsoleMessage($"<color=orange>{text}</color>");
			}
		}
#endif

		private static string GetDistance(float meters, bool useMetric)
		{
			double value = Math.Round(useMetric ? meters : meters * 3.28f, 1);
			string unit = value == 1
				? _instance.lang.GetMessage("Distance Unit Singular", _instance)
				: _instance.lang.GetMessage("Distance Unit Plural", _instance);

			return $"{value} {unit}";
		}

		private static string ApplyVariableFormat(string text, string variableName)
		{
			if (_instance._configuration.VariableFormats.ContainsKey(variableName))
			{
				var format = _instance._configuration.VariableFormats[variableName];
				text = format.Replace("{value}", text);
			}

			return text;
		}

		private static string InsertPlaceholderValues(string text, Dictionary<string, string> values)
		{
			foreach (var kvp in values)
			{
				string value = ApplyVariableFormat(kvp.Value, kvp.Key);
				if (string.IsNullOrEmpty(kvp.Value))
				{
					text = text.Replace($"{{{kvp.Key}}}", string.Empty);
				}
				else if (_instance._configuration.VariableColors.ContainsKey(kvp.Key))
				{
					var color = _instance._configuration.VariableColors[kvp.Key];
					text = text.Replace($"{{{kvp.Key}}}", $"<color={color}>{value}</color>");
					color = null;
				}
				else
				{
					text = text.Replace($"{{{kvp.Key}}}", value);
				}
			}

			return text;
		}

		private static string HumanizePascalCase(string text)
		{
			if (string.IsNullOrEmpty(text))
				return string.Empty;

			var sb = new StringBuilder();

			foreach (char c in text)
			{
				if (char.IsUpper(c) && sb.Length != 0 && !char.IsUpper(sb[sb.Length - 1]))
					sb.Append(" ");

				sb.Append(c);
			}

			return sb.ToString();
		}

		private string StripRichText(string text)
		{
			if (string.IsNullOrEmpty(text))
				return string.Empty;

			text = _colorTagRegex.Replace(text, string.Empty);
			text = _sizeTagRegex.Replace(text, string.Empty);

			foreach (var richTextLiteral in _richTextLiterals)
				text = text.Replace(richTextLiteral, string.Empty);

			return text;
		}

		private static bool MatchesCombatEntityType(CombatEntityType combatEntityType, string text)
		{
			if (combatEntityType == CombatEntityType.None && text == "-")
				return true;

			return combatEntityType.ToString().Equals(text);
		}

		private static bool MatchesDamageType(DamageType damageType, string text)
		{
			return damageType.ToString().Equals(text);
		}

		#endregion

		#region Configuration

		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["Distance Unit Singular"] = "meter",
				["Distance Unit Plural"] = "meters"
			}, this);
		}

		protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file...");

		private sealed class PluginConfiguration
		{
			[JsonProperty("Translations")] public Translation Translations = new Translation();

			[JsonProperty("Variable Formats")] public Dictionary<string, string> VariableFormats =
				new Dictionary<string, string>
				{
					["attachments"] = " ({value})"
				};

			[JsonProperty("Variable Colors")] public Dictionary<string, string> VariableColors =
				new Dictionary<string, string>
				{
					["killer"] = "#C4FF00",
					["victim"] = "#C4FF00",
					["weapon"] = "#C4FF00",
					["attachments"] = "#C4FF00",
					["distance"] = "#C4FF00",
					["owner"] = "#C4FF00"
				};

			[JsonProperty("Chat Format")]
			public string ChatFormat = "<color=#838383>[<color=#80D000>DeathNotes</color>] {message}</color>";

			[JsonProperty("Chat Icon (SteamID)")] public string ChatIcon = "76561198077847390";

			[JsonProperty("Show Kills in Console")]
			public bool ShowInConsole = true;

			[JsonProperty("Show Kills in Chat")] public bool ShowInChat = true;
			
			[JsonProperty("Show Patrol Heli Tags")] public bool ShowPatrolHeliTags = true;
			[JsonProperty("Show Bradley APC Tags")] public bool ShowBradleyTags = true;
			
			[JsonProperty("Patrol Helicopter Tag Message")]
			public string PatrolHeliTagMessage = "{killer} has tagged the {victim} with their {weapon} over a distance of {distance}.";
		   
			[JsonProperty("Bradley Tag Message")]
			public string BradleyTagMessage = "{killer} has tagged the {victim} with their {weapon} over a distance of {distance}.";

			[JsonProperty("Message Broadcast Radius (in meters)")]
			public int MessageRadius = -1;

			[JsonProperty("Use Metric Distance")] public bool UseMetricDistance = true;

			[JsonProperty("Require Permission (deathnotes.cansee)")]
			public bool RequirePermission = false;

			public void LoadDefaults()
			{
				Translations.Names.TryAdd("Chicken", "Chicken");
				Translations.Names.TryAdd("Boar", "Boar");
				Translations.Names.TryAdd("Stag", "Stag");
				Translations.Names.TryAdd("Bear", "Bear");
				Translations.Names.TryAdd("Wolf", "Wolf");
				Translations.Names.TryAdd("Simple Shark", "Shark");
				Translations.Names.TryAdd("Scientist", "Scientist");
				Translations.Names.TryAdd("Heavy Scientist", "Heavy Scientist");
				Translations.Names.TryAdd("HeavyScientist", "Heavy Scientist");
				Translations.Names.TryAdd("scientistnpc_heavy", "Heavy Scientist");
				Translations.Names.TryAdd("Helicopter", "Patrol Helicopter");
				Translations.Names.TryAdd("Bradley APC", "Bradley APC");
				Translations.Names.TryAdd("Polarbear", "Polar Bear");
				Translations.Names.TryAdd("Code Lock", "Code Lock");
				Translations.Names.TryAdd("Fire", "Fire");
				Translations.Names.TryAdd("Sentry", "Sentry");
				Translations.Names.TryAdd("Sam Site", "SAM Site");
				Translations.Names.TryAdd("ScarecrowNPC", "Scarecrow");
				Translations.Names.TryAdd("Tunnel Dweller", "Tunnel Dweller");
				Translations.Names.TryAdd("Barbed Wooden Barricade", "Barbed Wooden Barricade");
				Translations.Names.TryAdd("Barricade", "Barricade");
				Translations.Names.TryAdd("Auto Turret", "Auto Turret");
				Translations.Names.TryAdd("Patrol Helicopter", "Patrol Helicopter");
				Translations.Names.TryAdd("GRAF", "GRAF");
				Translations.Names.TryAdd("Underwater Dweller", "Underwater Dweller");
				Translations.Names.TryAdd("Campfire", "Campfire");
				Translations.Names.TryAdd("Wolf2", "Wolf");
				Translations.Names.TryAdd("Horse", "Horse");
				Translations.Names.TryAdd("Landmine", "Landmine");
				Translations.Names.TryAdd("Tesla Coil", "Tesla Coil");
				Translations.Names.TryAdd("Gun Trap", "Shotgun Trap");
				Translations.Names.TryAdd("Flame Turret", "Flame Turret");
				Translations.Names.TryAdd("GingerbreadNPC", "Gingerbread Man");
				Translations.Names.TryAdd("ScrapTransportHelicopter", "Scrap Transport Helicopter");
				Translations.Names.TryAdd("AttackHelicopter", "Attack Helicopter");
				Translations.Names.TryAdd("Minicopter", "Minicopter");
				Translations.Names.TryAdd("Metal Barricade", "Metal Barricade");
				Translations.Names.TryAdd("ZombieNPC", "Zombie");
				Translations.Names.TryAdd("Bear Trap", "Bear Trap");
				Translations.Names.TryAdd("Custom Bradley", "Custom Bradley");
				Translations.Names.TryAdd("Farmable Animal", "Farm Animal");
				Translations.Names.TryAdd("BeeSwarm", "Bee Swarm");
				Translations.Names.TryAdd("Custom Animal Npc", "Custom Animal NPC");

				Translations.Bodyparts.TryAdd("Body", "Body");
				Translations.Bodyparts.TryAdd("Leg", "Leg");
				Translations.Bodyparts.TryAdd("Chest", "Chest");
				Translations.Bodyparts.TryAdd("Stomach", "Stomach");
				Translations.Bodyparts.TryAdd("Head", "Head");
				Translations.Bodyparts.TryAdd("Arm", "Arm");
				Translations.Bodyparts.TryAdd("Hand", "Hand");
				Translations.Bodyparts.TryAdd("Foot", "Foot");
				
				Translations.Weapons.TryAdd("Salvaged Sword", "Salvaged Sword");
				Translations.Weapons.TryAdd("Revolver", "Revolver");
				Translations.Weapons.TryAdd("Salvaged Cleaver", "Salvaged Cleaver");
				Translations.Weapons.TryAdd("Mace", "Mace");
				Translations.Weapons.TryAdd("Assault Rifle", "Assault Rifle");
				Translations.Weapons.TryAdd("Double Barrel Shotgun", "Double Barrel Shotgun");
				Translations.Weapons.TryAdd("Bolt Action Rifle", "Bolt Action Rifle");
				Translations.Weapons.TryAdd("M92 Pistol", "M92 Pistol");
				Translations.Weapons.TryAdd("Custom SMG", "Custom SMG");
				Translations.Weapons.TryAdd("LR-300 Assault Rifle", "LR-300 Assault Rifle");
				Translations.Weapons.TryAdd("Timed Explosive Charge", "Timed Explosive Charge (C4)");
				Translations.Weapons.TryAdd("Pump Shotgun", "Pump Shotgun");
				Translations.Weapons.TryAdd("Prototype 17", "Prototype 17");
				Translations.Weapons.TryAdd("Hunting Bow", "Hunting Bow");
				Translations.Weapons.TryAdd("Thompson", "Thompson");
				Translations.Weapons.TryAdd("M39 Rifle", "M39 Rifle");
				Translations.Weapons.TryAdd("Hatchet", "Hatchet");
				Translations.Weapons.TryAdd("hatchet.entity", "Hatchet");
				Translations.Weapons.TryAdd("M4 Shotgun", "M4 Shotgun");
				Translations.Weapons.TryAdd("HMLMG", "HMLMG");
				Translations.Weapons.TryAdd("l96.entity", "L96 Rifle");
				Translations.Weapons.TryAdd("L96 Rifle", "L96 Rifle");
				Translations.Weapons.TryAdd("m249.entity", "M249");
				Translations.Weapons.TryAdd("M249", "M249");
				Translations.Weapons.TryAdd("Pickaxe", "Pickaxe");
				Translations.Weapons.TryAdd("Bone Knife", "Bone Knife");
				Translations.Weapons.TryAdd("Semi-Automatic Pistol", "Semi-Automatic Pistol");
				Translations.Weapons.TryAdd("Stone Hatchet", "Stone Hatchet");
				Translations.Weapons.TryAdd("Rock", "Rock");
				Translations.Weapons.TryAdd("Skinning Knife", "Skinning Knife");
				Translations.Weapons.TryAdd("Crossbow", "Crossbow");
				Translations.Weapons.TryAdd("Combat Knife", "Combat Knife");
				Translations.Weapons.TryAdd("Semi-Automatic Rifle", "Semi-Automatic Rifle");
				Translations.Weapons.TryAdd("MP5A4", "MP5A4");
				Translations.Weapons.TryAdd("Jackhammer", "Jackhammer");
				Translations.Weapons.TryAdd("SKS", "SKS");
				Translations.Weapons.TryAdd("militaryflamethrower.entity", "Military Flamethrower");
				Translations.Weapons.TryAdd("High Velocity Rocket", "High Velocity Rocket");
				Translations.Weapons.TryAdd("Spas-12 Shotgun", "Spas-12 Shotgun");
				Translations.Weapons.TryAdd("knife.combat.entity", "Combat Knife");
				Translations.Weapons.TryAdd("2module_car_spawned.entity", "2-module Vehicle");
				Translations.Weapons.TryAdd("car_chassis_2module.entity", "2-module Vehicle");
				Translations.Weapons.TryAdd("car_2mod_01", "2-module Vehicle");
				Translations.Weapons.TryAdd("car_2mod_02", "2-module Vehicle");
				Translations.Weapons.TryAdd("car_2mod_03", "2-module Vehicle");
				Translations.Weapons.TryAdd("car_2mod_04", "2-module Vehicle");
				Translations.Weapons.TryAdd("car_2mod_05", "2-module Vehicle");
				Translations.Weapons.TryAdd("car_2mod_06", "2-module Vehicle");
				Translations.Weapons.TryAdd("car_2mod_07", "2-module Vehicle");
				Translations.Weapons.TryAdd("car_2mod_08", "2-module Vehicle");
				Translations.Weapons.TryAdd("3module_car_spawned.entity", "3-module Vehicle");
				Translations.Weapons.TryAdd("car_chassis_3module.entity", "3-module Vehicle");
				Translations.Weapons.TryAdd("car_3mod_01", "3-module Vehicle");
				Translations.Weapons.TryAdd("car_3mod_02", "3-module Vehicle");
				Translations.Weapons.TryAdd("car_3mod_03", "3-module Vehicle");
				Translations.Weapons.TryAdd("car_3mod_04", "3-module Vehicle");
				Translations.Weapons.TryAdd("car_3mod_05", "3-module Vehicle");
				Translations.Weapons.TryAdd("car_3mod_06", "3-module Vehicle");
				Translations.Weapons.TryAdd("car_3mod_07", "3-module Vehicle");
				Translations.Weapons.TryAdd("car_3mod_08", "3-module Vehicle");
				Translations.Weapons.TryAdd("car_3mod_09", "3-module Vehicle");
				Translations.Weapons.TryAdd("car_3mod_10", "3-module Vehicle");
				Translations.Weapons.TryAdd("car_3mod_11", "3-module Vehicle");
				Translations.Weapons.TryAdd("car_3mod_12", "3-module Vehicle");
				Translations.Weapons.TryAdd("4module_car_spawned.entity", "4-module Vehicle");
				Translations.Weapons.TryAdd("car_chassis_4module.entity", "4-module Vehicle");
				Translations.Weapons.TryAdd("car_4mod_01", "4-module Vehicle");
				Translations.Weapons.TryAdd("car_4mod_02", "4-module Vehicle");
				Translations.Weapons.TryAdd("car_4mod_03", "4-module Vehicle");
				Translations.Weapons.TryAdd("car_4mod_04", "4-module Vehicle");
				Translations.Weapons.TryAdd("car_4mod_05", "4-module Vehicle");
				Translations.Weapons.TryAdd("car_4mod_06", "4-module Vehicle");
				Translations.Weapons.TryAdd("car_4mod_07", "4-module Vehicle");
				Translations.Weapons.TryAdd("car_4mod_08", "4-module Vehicle");
				Translations.Weapons.TryAdd("car_4mod_09", "4-module Vehicle");
				Translations.Weapons.TryAdd("car_4mod_10", "4-module Vehicle");
				Translations.Weapons.TryAdd("car_4mod_11", "4-module Vehicle");
				Translations.Weapons.TryAdd("motorbike", "Motorbike");
				Translations.Weapons.TryAdd("motorbike_sidecar", "Motorbike with Sidecar");
				Translations.Weapons.TryAdd("pedalbike", "Bicycle");
				Translations.Weapons.TryAdd("pedaltrike", "Tricycle");
				Translations.Weapons.TryAdd("snowmobile", "Snowmobile");
				Translations.Weapons.TryAdd("F1 Grenade", "F1 Grenade");
				Translations.Weapons.TryAdd("Satchel Charge", "Satchel Charge");
				Translations.Weapons.TryAdd("Wooden Spear", "Wooden Spear");
				Translations.Weapons.TryAdd("Stone Spear", "Stone Spear");
				Translations.Weapons.TryAdd("Compound Bow", "Compound Bow");
				Translations.Weapons.TryAdd("Machete", "Machete");
				Translations.Weapons.TryAdd("Pitchfork", "Pitchfork");
				Translations.Weapons.TryAdd("Stone Pickaxe", "Stone Pickaxe");
				Translations.Weapons.TryAdd("stone_pickaxe.entity", "Stone Pickaxe");
				Translations.Weapons.TryAdd("Legacy bow", "Legacy Bow");
				Translations.Weapons.TryAdd("Rocket", "Rocket");
				Translations.Weapons.TryAdd("Incendiary Rocket", "Incendiary Rocket");
				Translations.Weapons.TryAdd("Salvaged Axe", "Salvaged Axe");
				Translations.Weapons.TryAdd("Torch", "Torch");
				Translations.Weapons.TryAdd("pickaxe.entity", "Pickaxe");
				Translations.Weapons.TryAdd("Salvaged Hammer", "Salvaged Hammer");
				Translations.Weapons.TryAdd("40mm_grenade_he", "40mm HE Grenade");
				Translations.Weapons.TryAdd("Minigun", "Minigun");
				Translations.Weapons.TryAdd("Assault Rifle - ICE", "Ice Assault Rifle");
				Translations.Weapons.TryAdd("Python Revolver", "Python Revolver");
				Translations.Weapons.TryAdd("Nailgun", "Nailgun");
				Translations.Weapons.TryAdd("Salvaged Icepick", "Salvaged Icepick");
				Translations.Weapons.TryAdd("Longsword", "Longsword");
				Translations.Weapons.TryAdd("Waterpipe Shotgun", "Waterpipe Shotgun");
				Translations.Weapons.TryAdd("Chainsaw", "Chainsaw");
				Translations.Weapons.TryAdd("workcart.entity", "Work Cart");
				Translations.Weapons.TryAdd("locomotive.entity", "Locomotive");
				Translations.Weapons.TryAdd("workcart_aboveground.entity", "Above Ground Work Cart");
				Translations.Weapons.TryAdd("Paddle", "Paddle");
				Translations.Weapons.TryAdd("workcart_aboveground2.entity", "Above Ground Work Cart");
				Translations.Weapons.TryAdd("hammer_salvaged.entity", "Salvaged Hammer");
				Translations.Weapons.TryAdd("Multiple Grenade Launcher", "Multiple Grenade Launcher");
				Translations.Weapons.TryAdd("minigun.entity", "Minigun");
				Translations.Weapons.TryAdd("rocket_mlrs", "MLRS Rocket");
				Translations.Weapons.TryAdd("Eoka Pistol", "Eoka Pistol");
				Translations.Weapons.TryAdd("High Caliber Revolver", "High Caliber Revolver");
				Translations.Weapons.TryAdd("Abyss Assault Rifle", "Abyss Assault Rifle");
				Translations.Weapons.TryAdd("Blunderbuss", "Blunderbuss");
				Translations.Weapons.TryAdd("Sickle", "Sickle");
				Translations.Weapons.TryAdd("Butcher Knife", "Butcher Knife");
				Translations.Weapons.TryAdd("pitchfork.entity", "Pitchfork");
				Translations.Weapons.TryAdd("Snowball Gun", "Snowball Gun");
				Translations.Weapons.TryAdd("vampirestake.entity", "Vampire Stake");
				Translations.Weapons.TryAdd("Baseball Bat", "Baseball Bat");
				Translations.Weapons.TryAdd("Handmade SMG", "Handmade SMG");
				Translations.Weapons.TryAdd("Beancan Grenade", "Beancan Grenade");
				Translations.Weapons.TryAdd("Candy Cane Club", "Candy Cane Club");
				Translations.Weapons.TryAdd("Snowball", "Snowball");
				Translations.Weapons.TryAdd("Flashlight", "Flashlight");
				Translations.Weapons.TryAdd("Speargun", "Speargun");
				Translations.Weapons.TryAdd("double_shotgun.entity", "Double Barrel Shotgun");
				Translations.Weapons.TryAdd("Skull", "Skull");
				Translations.Weapons.TryAdd("Mini Crossbow", "Mini Crossbow");
				Translations.Weapons.TryAdd("Ice Assault Rifle", "Ice Assault Rifle");
				Translations.Weapons.TryAdd("Frontier Hatchet", "Frontier Hatchet");
				Translations.Weapons.TryAdd("Medieval Assault Rifle", "Medieval Assault Rifle");
				Translations.Weapons.TryAdd("boulder_explosive_deployed", "Propane Explosive Bomb");
				Translations.Weapons.TryAdd("Ballista", "Ballista");
				Translations.Weapons.TryAdd("boulder_explosive", "Propane Explosive Bomb");
				Translations.Weapons.TryAdd("boulder_mid", "Scattershot");
				Translations.Weapons.TryAdd("boulder_incendiary", "Firebomb");
				Translations.Weapons.TryAdd("Flame Thrower", "Flame Thrower");
				Translations.Weapons.TryAdd("grenade.molotov.deployed", "Molotov Cocktail");
				Translations.Weapons.TryAdd("Concrete Pickaxe", "Concrete Pickaxe");
				Translations.Weapons.TryAdd("Bone Club", "Bone Club");
				Translations.Weapons.TryAdd("scraptransporthelicopter", "Scrap Transport Helicopter");
				Translations.Weapons.TryAdd("grenade.bee.deployed", "Bee Grenade");
				Translations.Weapons.TryAdd("Lunar New Year Spear", "Lunar New Year Spear");
				
				Translations.Attachments.TryAdd("Weapon flashlight", "Weapon Flashlight");
				Translations.Attachments.TryAdd("Extended Magazine", "Extended Magazine");
				Translations.Attachments.TryAdd("16x Zoom Scope", "16x Zoom Scope");
				Translations.Attachments.TryAdd("Weapon Lasersight", "Weapon Lasersight");
				Translations.Attachments.TryAdd("Silencer", "Silencer");
				Translations.Attachments.TryAdd("8x Zoom Scope", "8x Zoom Scope");
				Translations.Attachments.TryAdd("Holosight", "Holosight");
				Translations.Attachments.TryAdd("Muzzle Boost", "Muzzle Boost");
				Translations.Attachments.TryAdd("Muzzle Brake", "Muzzle Brake");
				Translations.Attachments.TryAdd("Simple Handmade Sight", "Simple Handmade Sight");
				Translations.Attachments.TryAdd("Gas Compression Overdrive", "Gas Compression Overdrive");
				Translations.Attachments.TryAdd("Burst Module", "Burst Module");
				Translations.Attachments.TryAdd("Variable Zoom Scope", "Variable Zoom Scope");
				
				if (Translations.Messages == null)
				{
					Translations.Messages = new List<DeathMessage>
					{
						new("Player", "Player", "Bullet", "{killer} shot {victim} using their {weapon} over a distance of {distance}."),
						new("Player", "Player", "Arrow", "{victim} was shot by {killer} with their {weapon} over a distance of {distance}."),
						new("Player", "Player", "Heat", "{killer} inflamed {victim} with their {weapon}."),
						new("Player", "Player", "*", "{killer} killed {victim} using their {weapon}."),
						new("Player", "Player", "Slash", "{killer} slashed {victim} into pieces with their {weapon}."),
						new("Player", "Animal", "*", "{killer} killed a {victim} using their {weapon}."),
						new("Player", "SimpleShark", "*", "{killer} killed a {victim} using their {weapon}."),
						new("Player", "Animal", "Bullet", "{killer} shot a {victim} using their {weapon} over a distance of {distance}."),
						new("Player", "Animal", "Arrow", "{killer} shot a {victim} using their {weapon} over a distance of {distance}."),
						new("Player", "ZombieNPC", "*", "{killer} fought off a spooky {victim} with their {weapon}."),
						new("ZombieNPC", "Player", "*", "{killer} killed {victim} and ate their brains!"),
						new("Player", "ZombieNPC", "Bullet", "{killer} shot a {victim} with their {weapon} over a distance of {distance}."),
						new("Player", "ScarecrowNPC", "*", "{killer} fought off a spooky {victim} with their {weapon}."),
						new("ScarecrowNPC", "Player", "*", "{killer} scared {victim} to death!"),
						new("Player", "ScarecrowNPC", "Bullet", "{killer} did some scaring of their own against a {victim} with their {weapon} over a distance of {distance}."),
						new("Player", "GingerbreadNPC", "*", "{killer} fought off a deliciously deadly {victim} with their {weapon}."),
						new("GingerbreadNPC", "Player", "*", "Death was sweet for {victim}, who was killed by a {killer}."),
						new("Player", "GingerbreadNPC", "Bullet", "{killer} took a bite out of a deliciously deadly {victim} with their {weapon} over a distance of {distance}."),
						new("Player", "Scientist", "*", "{killer} did not want to be a part of the {victim}'s experiments, and did some science of their own with their {weapon}."),
						new("Player", "Scientist", "Bullet", "{killer} did some research of their own against a {victim} with their {weapon} over a distance of {distance}."),
						new("Player", "Scientist", "Arrow", "{killer} did some research of their own against a {victim} with their {weapon} over a distance of {distance}."),
						new("Player", "HeavyScientist", "*", "{killer} did not want to be a part of the {victim}'s experiments, and did some science of their own with their {weapon}."),
						new("Player", "HeavyScientist", "Bullet", "{killer} did some research of their own against a {victim} with their {weapon} over a distance of {distance}."),
						new("Player", "HeavyScientist", "Arrow", "{killer} did some research of their own against a {victim} with their {weapon} over a distance of {distance}."),
						new("Player", "Bradley", "*", "{killer} blew up the {victim} with their {weapon}."),
						new("*", "Helicopter", "*", "The {victim} was destroyed. Good riddance."),
						new("Player", "Helicopter", "*", "The world is a safer place now that {killer} shot down the {victim} with their {weapon}. Good riddance."),
						new("Animal", "Player", "*", "{victim} couldn't run away from the {killer}."),
						new("Shark", "Player", "*", "Baby Shark, doo-doo, doo-doo, doo-doo ate {victim}."),
						new("SimpleShark", "Player", "*", "Baby Shark, doo-doo, doo-doo, doo-doo ate {victim}."),
						new("BeeSwarm", "Player", "*", "A {killer} just reminded {victim} that they are allergic to bee stings."),
						new("Player", "BeeSwarm", "*", "{killer} just swatted a {victim} out of existence."),
						new("Bradley", "Player", "*", "{victim} was blasted by the {killer}."),
						new("Helicopter", "Player", "*", "{victim} had no chance against the {killer}."),
						new("Trap", "Player", "*", "{victim} was reckless and ran into a {killer}."),
						new("Barricade", "Player", "*", "{victim} was impaled by a {killer}."),
						new("Turret", "Player", "*", "{owner}'s {killer} did its job, killing intruder {victim}."),
						new("Murderer", "Player", "*", "A {killer} haunted down {victim}."),
						new("TunnelDweller", "Player", "*", "{victim} was taken out by a {killer}."),
						new("Player", "TunnelDweller", "*", "{killer} took out a {victim} with their {weapon}."),
						new("Player", "TunnelDweller", "Bullet", "{killer} took out a {victim} with their {weapon} over a distance of {distance}."),
						new("UnderwaterDweller", "Player", "*", "{victim} was taken out by an {killer}."),
						new("Player", "UnderwaterDweller", "*", "{killer} took out an {victim} with their {weapon}."),
						new("Player", "UnderwaterDweller", "Bullet", "{killer} took out a {victim} with their {weapon} over a distance of {distance}."),
						new("Scientist", "Player", "*", "A {killer} shot down {victim}."),
						new("HeavyScientist", "Player", "*", "A {killer} shot down {victim}."),
						new("Sentry", "Player", "*", "{victim} broke the rules in a safezone and was killed by a {killer}."),
						new("-", "Player", "Fall", "{victim} fell to their death. Splat!"),
						new("HeatSource", "Player", "*", "{victim} was grilled on a {killer}."),
						new("Lock", "Player", "*", "{victim} was electrocuted by {owner}'s {killer}."),
						new("*", "Player", "Heat", "{victim} burned to death."),
						new("*", "Player", "Hunger", "{victim} forgot to eat and hungers for life."),
						new("*", "Player", "Thirst", "{victim} died of immense thirst."),
						new("*", "Player", "Radiation", "{victim} had a cheery, radioactive glow. Fatal, but cheery nonetheless."),
						new("*", "Player", "Cold", "{victim} turned into an ice statue."),
						new("*", "Player", "Drowned", "As {victim} just found out, breathing underwater is rather difficult."),
						new("Player", "Player", "Bleeding", "{victim} bled out after being attacked by {killer}."),
						new("Player", "Animal", "Collision", "{killer} ran over a {victim} with their {weapon}."),
						new("Player", "Player", "Collision", "{killer} ran over {victim} with their {weapon}."),
						new("Minicopter", "Player", "*", "{victim} tragically perished in a {killer} crash."),
						new("ScrapTransportHelicopter", "Player", "*", "{victim} tragically perished in a {killer} crash."),
						new("AttackHelicopter", "Player", "*", "{victim} tragically perished in a {killer} crash."),
						new("Player", "Player", "Suicide", "{victim} had enough of life.")
					};
				}

				_instance.Config.WriteObject( this );
			}

			public class DeathMessage
			{
				public string KillerType { get; set; }
				public string VictimType { get; set; }
				public string DamageType { get; set; }

				public string[] Messages { get; set; }

				protected bool Equals(DeathMessage other) => string.Equals(KillerType, other.KillerType) &&
															 string.Equals(VictimType, other.VictimType) &&
															 string.Equals(DamageType, other.DamageType);

				public DeathMessage(string killerType, string victimType, string damageType, string message)
				{
					KillerType = killerType;
					VictimType = victimType;
					DamageType = damageType;
					Messages = new[] {message};
				}
			}

			public class Translation
			{
				[JsonProperty("Death Messages")] public List<DeathMessage> Messages;

				[JsonProperty("Names")] public Dictionary<string, string> Names = new Dictionary<string, string>();

				[JsonProperty("Bodyparts")]
				public Dictionary<string, string> Bodyparts = new Dictionary<string, string>();

				[JsonProperty("Weapons")] public Dictionary<string, string> Weapons = new Dictionary<string, string>();

				[JsonProperty("Attachments")]
				public Dictionary<string, string> Attachments = new Dictionary<string, string>();
			}
		}

		#endregion
	}
}

// --- End of file: DeathNotes.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/dc-protect ---
// --- Original File Path: D/DCProtect/DCProtect.cs ---

ï»¿using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("DCProtect", "FireStorm78", "1.0.6")]
    [Description("Prevents players from looting other players that have disconnected for a specified time.")]
    class DCProtect : RustPlugin
    {

        #region Initialization

        List<string> PlayerList = new List<string>();

        void Init()
        {
            LoadDefaultConfig();
        }

        #endregion

        #region Configuration

        int DC_DelayInSeconds;
        int Start_DelayInSeconds;
        bool PreventLooting;
        bool PreventDamage;

        protected override void LoadDefaultConfig()
        {
            Config["DC_DelayInSeconds"] = DC_DelayInSeconds = GetConfig("DC_DelayInSeconds", 300);
            Config["Start_DelayInSeconds"] = Start_DelayInSeconds = GetConfig("Start_DelayInSeconds", 300);
            Config["PreventLooting"] = PreventLooting = GetConfig("PreventLooting", true);
            Config["PreventDamage"] = PreventDamage = GetConfig("PreventDamage", true);
            SaveConfig();
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {

            string Usage = "<size=30><color=blue>DC Protect</color></size> v{0}\nby {1}\n\n";
            Usage += "NOTE: All commands are meant for testing by a moderator or administrator.\n\n";
            Usage += "Usage Syntax:\n";
            Usage += "/DCP add - Manually add the player you are looking at to the protection list.\n";
            Usage += "/DCP remove - Manually remove the player you are looking at from the protection list.\n";
            Usage += "/DCP list - List all current protected players by SteamID.\n";
            Usage += "/DCP time - Show the number of seconds since the server has started.\n";

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "This player has just disconnected. They are protected for '{0}' seconds. This action has been logged.",
                ["ServerStart"] = "The server just started. All players are protected for '{0}' seconds. This action has been logged.",
                ["InvalidCommand"] = "[DCP] That is an invalid command.",
                ["ManualAdd"]= "[DCP] You are looking at player {0}|{1}. Manually adding protection.",
                ["ManualRemove"] = "[DCP] You are looking at player {0}|{1}. Manually removing protection.",
                ["ListTitle"] = "[DCP] Current Protected Player List",
                ["TimerComplete"] = "Timer Complete. Removing Player: {0}|{1}.",
                ["PlayerDisconnected"] = "Player Disconnected. Adding Player {0}|{1} to protection list.",
                ["LogViolation_DC_Loot"] = "Player {0}|{1} tried to loot {2}|{3} after they disconnected...tisk tisk.",
                ["LogViolation_ServerStart_Loot"] = "Player {0}|{1} tried to loot {2}|{3} after the server started...tisk tisk.",
                ["LogViolation_DC_Damage"] = "Player {0}|{1} tried to damage {2}|{3} after they disconnected...tisk tisk.",
                ["LogViolation_ServerStart_Damage"] = "Player {0}|{1} tried to damage {2}|{3} after the server started...tisk tisk.",
                ["Usage"] = Usage
            }, this);
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T defaultValue) => Config[name] == null ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private bool IsAdmin(BasePlayer player)
        {
            if (player == null) return false;
            if (player?.net?.connection == null) return true;
            return player.net.connection.authLevel > 0;
        }
        #endregion

        [ChatCommand("DCP")]
        private void cmdDCP(BasePlayer player, string command, string[] args)
        {
            if (args.Length > 0)
            {
                switch (args[0].ToLower())
                {
                    case "add":
                        cmdDCP_Add(player, command, args.Skip(1).ToArray());
                        break;
                    case "remove":
                        cmdDCP_Remove(player, command, args.Skip(1).ToArray());
                        break;
                    case "list":
                        cmdDCP_List(player, command, args.Skip(1).ToArray());
                        break;
                    case "time":
                        PrintToChat(player, Time.realtimeSinceStartup.ToString());
                        break;
                    default:
                        PrintToChat(player, Lang("InvalidCommand", player.UserIDString));
                        PrintToChat(player, Lang("Usage", player.UserIDString, this.Version, this.Author));
                        break;
                }
            }
            else
            {
                PrintToChat(player, Lang("Usage", player.UserIDString, this.Version, this.Author));
            }
        }

        private void cmdDCP_Add(BasePlayer player, string command, string[] args)
        {
            if (IsAdmin(player))
            {

                RaycastHit hit;
                if (Physics.Raycast(player.eyes.HeadRay(), out hit, 10f))
                {
                    BaseEntity closestEntity = hit.GetEntity();

                    if (closestEntity is BasePlayer)
                    {
                        BasePlayer target = (BasePlayer) closestEntity;
                        PrintToChat(player, Lang("ManualAdd", player.UserIDString, target.displayName, target.UserIDString));

                        PlayerList.Add(target.UserIDString);
                        timer.Once(DC_DelayInSeconds, () =>
                        {
                            PrintWarning(Lang("TimerComplete", null, target.UserIDString, target.displayName));
                            PlayerList.Remove(target.UserIDString);
                        });
                    }                    
                }
            }
        }

        private void cmdDCP_Remove(BasePlayer player, string command, string[] args)
        {
            if (IsAdmin(player))
            {
                RaycastHit hit;
                if (Physics.Raycast(player.eyes.HeadRay(), out hit, 10f))
                {
                    BaseEntity closestEntity = hit.GetEntity();
                    if (closestEntity is BasePlayer)
                    {
                        BasePlayer target = (BasePlayer)closestEntity;
                        PrintToChat(player, Lang("ManualRemove", player.UserIDString, target.displayName, target.UserIDString));
                        PlayerList.Remove(target.UserIDString);
                    }
                }
            }
        }

        private void cmdDCP_List(BasePlayer player, string command, string[] args)
        {
            if (IsAdmin(player))
            {
                PrintToChat(player, Lang("ListTitle", player.UserIDString));
                foreach (string item in PlayerList)
                {
                    SendReply(player, item);
                }
            }
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            PrintWarning(Lang("PlayerDisconnected", null, player.UserIDString, player.displayName));
            PlayerList.Add(player.UserIDString);
            timer.Once(DC_DelayInSeconds, () =>
            {
                PrintWarning(Lang("TimerComplete", null, player.UserIDString, player.displayName));
                PlayerList.Remove(player.UserIDString);
            });
        }

        bool CanLootPlayer(BasePlayer target, BasePlayer looter)
        {
            if (PreventLooting && target.userID != looter.userID)
            {
                if (Time.realtimeSinceStartup < Start_DelayInSeconds)
                {
                    PrintWarning(Lang("LogViolation_ServerStart_Loot", null, looter.UserIDString, looter.displayName, target.UserIDString, target.displayName));
                    PrintToChat(looter, Lang("ServerStart", looter.UserIDString, Start_DelayInSeconds));
                    return false;
                }
                else if (PlayerList.Contains(target.UserIDString))
                {
                    PrintWarning(Lang("LogViolation_DC_Loot", null, looter.UserIDString, looter.displayName, target.UserIDString, target.displayName));
                    PrintToChat(looter, Lang("NotAllowed", looter.UserIDString, DC_DelayInSeconds));
                    return false;
                }
            }
            return true;

        }

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (PreventDamage && entity is BasePlayer && (entity as BasePlayer).IsSleeping())
            {
                if (info.Initiator == null) return null;

                if (info.Initiator is BasePlayer)
                {
                    BasePlayer attacker = info.Initiator as BasePlayer;
                    BasePlayer target = entity as BasePlayer;

                    if (Time.realtimeSinceStartup < Start_DelayInSeconds)
                    {
                        PrintWarning(Lang("LogViolation_ServerStart_Damage", null, attacker.UserIDString, attacker.displayName, target.UserIDString, target.displayName));
                        PrintToChat(attacker, Lang("ServerStart", attacker.UserIDString, Start_DelayInSeconds));
                        return false;
                    }
                    else if (PlayerList.Contains(target.UserIDString))
                    {
                        PrintWarning(Lang("LogViolation_DC_Damage", null, attacker.UserIDString, attacker.displayName, target.UserIDString, target.displayName));
                        PrintToChat(attacker, Lang("NotAllowed", attacker.UserIDString, DC_DelayInSeconds));
                        return false;
                    }
                }
                else
                {
                    BaseEntity attacker = info.Initiator;
                    BasePlayer target = entity as BasePlayer;

                    if (Time.realtimeSinceStartup < Start_DelayInSeconds)
                    {
                        PrintWarning(Lang("LogViolation_ServerStart_Damage", null, "0", attacker.name, target.UserIDString, target.displayName));
                        return false;
                    }
                    else if (PlayerList.Contains(target.UserIDString))
                    {
                        PrintWarning(Lang("LogViolation_DC_Damage", null, "0", attacker.name, target.UserIDString, target.displayName));
                        return false;
                    }
                }
            }

            return null;
        }
    }
}


// --- End of file: DCProtect.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/data-logging-activity ---
// --- Original File Path: D/DataLoggingActivity/DataLoggingActivity.cs ---

ï»¿// Requires: DataLogging

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Data Logging: Activity", "Rustoholics", "0.1.0")]
    [Description("Log when some is connected/disconnect and AFK")]

    public class DataLoggingActivity : DataLogging
    {
        #region Object
        public class Activity
        {
            public Types Type;
            
            public DateTime Date = DateTime.Now;

            public string Notes;
            
            public enum Types
            {
                Connected,
                Disconnected,
                Active,
                Afk,
            }
        }
        
        public class ActivityData
        {
            public int PlayTime;
            public int AfkTime;
            public int ConnectedTime;

        }
        
        #endregion
        
        #region Language
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["InvalidPlayer"] = "Invalid Player",
                ["ActivityForPlayer"] = "Activity for {0}",
                ["ActivityAtTime"] = "{0} at {1}",
                ["SecondsConnected"] = "{0} seconds connected",
                ["SecondsActivity"] = "{0} seconds active",
                ["ActivityAndConnected"] = "{0} active for {1} seconds and connected for {2} seconds",
            }, this);
        }
        
        #endregion
        
        #region Setup / Config
        
        private class Configuration
        {
            public bool Debug = false;
        }

        private Configuration config;
        
        DataManager<Activity> _data;
        
        private Dictionary<string, Vector3> _positions = new Dictionary<string, Vector3>();

        private void OnServerInitialized()
        {
            _data = new DataManager<Activity>();
            
            SetupConfig(ref config);

            timer.Every(30f, () =>
            {
                List<string> connected = new List<string>();
                foreach (var player in covalence.Players.Connected)
                {
                    if (player.Id == null) continue;

                    connected.Add(player.Id);

                    var last = _data.GetDataLast(player.Id);
                    
                    if (last == null) continue;
                    var afk = IsAfk((BasePlayer) player.Object);
                    
                    if (last.Type == Activity.Types.Connected || (last.Type == Activity.Types.Active && afk) || last.Type == Activity.Types.Afk && !afk)
                    {
                        _data.AddData(player.Id, new Activity()
                        {
                            Type = afk ? Activity.Types.Afk : Activity.Types.Active
                        });
                    }
                }
                
                // Check that "connected" players are actually still connected
                foreach (var uid in _data.GetKeys())
                {
                    if (connected.Contains(uid)) continue;
                    
                    var most_recent = _data.GetDataLast(uid);
                    if (most_recent.Type != Activity.Types.Disconnected)
                    {
                        _data.AddData(uid, new Activity()
                        {
                            Type = Activity.Types.Disconnected,
                            Notes = "Non-hook disconnect"
                        });
                    }
                }
            });
        }

        private void Unload()
        {
            _data.Save();
        }
        
        private void OnServerSave() { 
            timer.Once(UnityEngine.Random.Range(0f, 60f), () =>
            {
            _data.Save();
            });
            
        }
        
        #endregion
        
        #region Hooks
        
        void OnPlayerConnected(BasePlayer player)
        {
            _data.AddData(player.UserIDString, new Activity()
            {
                Type = Activity.Types.Connected
            });
            IsAfk(player); // Set the position
        }
        
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            _data.AddData(player.UserIDString, new Activity()
            {
                Type = Activity.Types.Disconnected,
                Notes = reason
            });
        }
        
        #endregion
        
        #region Data Analysis
        

        public int TimeConnected(string playerId, DateTime startTime=default(DateTime))
        {
            var cachekey = "TimeConnected_" + playerId+(startTime != default(DateTime) ? "_"+startTime.ToString() : "");
            var cache = GetCache(cachekey);
            if (cache != null)
            {
                return (int)cache;
            }
            
            var data = _data.GetData(playerId).AsEnumerable();
            data = data.OrderBy(act => act.Date);

            DateTime? clock = null;
            var timer = 0d;
            foreach (var activity in data)
            {
                if (activity.Type == Activity.Types.Connected)
                {
                    clock = activity.Date;
                }else if (activity.Type == Activity.Types.Disconnected)
                {
                    if (clock != null)
                    {
                        if (startTime == default(DateTime) || activity.Date > startTime)
                        {
                            if (startTime != default(DateTime) && clock< startTime) clock = startTime;
                            
                            timer += (activity.Date - (DateTime) clock).TotalSeconds;
                        }

                        clock = null;
                    }
                }
            }

            if (clock != null)
            {
                if (startTime != default(DateTime) && clock< startTime) clock = startTime;
                timer += (DateTime.Now - (DateTime) clock).TotalSeconds;
            }
            var intval = (int)Math.Floor(timer);
            AddCache(cachekey, intval, 60);

            return intval;
        }
        
        public int TimeActive(string playerId, DateTime startTime = default(DateTime))
        {
            var cachekey = "TimeActive" + playerId+(startTime != default(DateTime) ? "_"+startTime.ToString() : "");
            var cache = GetCache(cachekey);
            if (cache != null)
            {
                return (int)cache;
            }
            
            var data = _data.GetData(playerId).AsEnumerable();
            if (startTime != default(DateTime))
            {
                data = data.Where(act => act.Date > startTime);
            }
            data = data.OrderBy(act => act.Date);

            DateTime? clock = null;
            var timer = 0d;
            Activity.Types state = Activity.Types.Disconnected;
            
            foreach (var activity in data)
            {
                if (activity.Type == Activity.Types.Connected || activity.Type == Activity.Types.Active)
                {
                    if(clock == null || state == Activity.Types.Active) clock = activity.Date;
                }else if (activity.Type == Activity.Types.Disconnected || activity.Type == Activity.Types.Afk)
                {
                    if (clock != null)
                    {
                        if (startTime == default(DateTime) || activity.Date > startTime)
                        {
                            if (startTime != default(DateTime) && clock < startTime) clock = startTime;
                            
                            timer += (activity.Date - (DateTime) clock).TotalSeconds;
                        }

                        clock = null;
                    }
                }
                state = activity.Type;
            }

            if (clock != null && (state == Activity.Types.Active || state == Activity.Types.Connected))
            {
                if (startTime != default(DateTime) && clock< startTime) clock = startTime;
                timer += (DateTime.Now - (DateTime) clock).TotalSeconds;
            }
            var intval = (int)Math.Floor(timer);
            AddCache(cachekey, intval, 60);

            return intval;
        }

        public Dictionary<string, ActivityData> GetAllActivity(DateTime startDate = default(DateTime))
        {
            Dictionary<string, ActivityData> results = new Dictionary<string, ActivityData>();
            foreach (var uid in _data.GetKeys())
            {
                var playtime = TimeActive(uid, startDate);
                var connectedtime = TimeConnected(uid, startDate);
                if (playtime > 0 || connectedtime > 0)
                {
                    results.Add(uid, new ActivityData()
                    {
                        PlayTime = playtime,
                        ConnectedTime = connectedtime
                    });
                }
            }

            return results;
        }

        #endregion
        
        #region Commands

        [Command("datalogging.activity")]
        private void ActivityCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = GetCommandPlayer(iplayer, args);
            
            if (player == null) {
                iplayer.Reply(Lang("InvalidPlayer", iplayer.Id));
                return;
            }
            
            iplayer.Reply(Lang("ActivityForPlayer", iplayer.Id, player.Name));
            var data = _data.GetData(player.Id);
            foreach (var activity in data)
            {
                iplayer.Reply(Lang("ActivityAtTime", iplayer.Id, activity.Type.ToString(), activity.Date));
            }

        }
        
        [Command("datalogging.activetime")]
        private void TimeActiveCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = GetCommandPlayer(iplayer, args);
            
            if (player == null) {
                iplayer.Reply(Lang("InvalidPlayer", iplayer.Id));
                return;
            }
            
            iplayer.Reply(Lang("ActivityForPlayer", iplayer.Id, player.Name));
            iplayer.Reply(Lang("SecondsConnected",iplayer.Id, TimeConnected(player.Id)));
            iplayer.Reply(Lang("SecondsActivity",iplayer.Id, TimeActive(player.Id)));
        }
        
        [Command("datalogging.allactivity")]
        private void AllActivityCommand(IPlayer iplayer, string command, string[] args)
        {

            foreach (var allactivity in GetAllActivity().OrderByDescending(act => act.Value.PlayTime))
            {
                var playername = players.FindPlayer(allactivity.Key);
                if (playername == null) continue;
                iplayer.Reply(Lang("ActivityAndConnected", iplayer.Id, playername.Name, allactivity.Value.PlayTime, allactivity.Value.ConnectedTime));                
            }
        }

        
        #endregion
        
        #region Helpers

        private bool IsAfk(BasePlayer player)
        {
            var pos = player.transform.position;

            if (!_positions.ContainsKey(player.UserIDString))
            {
                _positions.Add(player.UserIDString, pos);
                return false;
            }
            
            if (pos.Equals(_positions[player.UserIDString]))
            {
                return true;
            }

            _positions[player.UserIDString] = pos;
            
            return false;
        }
        
        #endregion

        #region API

        private JObject API_GetAllActivity(DateTime startDate = default(DateTime))
        {
            return JObject.FromObject(GetAllActivity(startDate));
        }

        private int API_GetActiveTime(string playerId)
        {
            return TimeActive(playerId);
        }

        private int API_GetConnectedTime(string playerId)
        {
            return TimeConnected(playerId);
        }

        #endregion
    }
}

// --- End of file: DataLoggingActivity.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-presence ---
// --- Original File Path: D/DiscordPresence/DiscordPresence.cs ---

ï»¿using System;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;

namespace Oxide.Plugins
{
    [Info("Discord Presence", "MJSU", "3.0.1")]
    [Description("Updates the Discord bot status message")]
    internal class DiscordPresence : CovalencePlugin, IDiscordPlugin
    {
        #region Class Fields
        public DiscordClient Client { get; set; }

        private PluginConfig _pluginConfig;

        private int _index;

        private readonly DiscordPlaceholders _placeholders = GetLibrary<DiscordPlaceholders>();

        private readonly UpdatePresenceCommand _command = new()
        {
            Afk = false,
            Since = 0,
            Status = UserStatusType.Online
        };

        private readonly DiscordActivity _activity = new();
        private Action _updatePresence;

        private bool _serverInit;
        private bool _gatewayReady;
        private DateTime _nextApiSend;
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _command.Activities = new List<DiscordActivity> {_activity};
            _updatePresence = UpdatePresence;
            if (_pluginConfig.UpdateRate < 1f)
            {
                _pluginConfig.UpdateRate = 1f;
            }

            Unsubscribe(nameof(OnUserConnected));
            Unsubscribe(nameof(OnUserDisconnected));
        }

        [HookMethod(DiscordExtHooks.OnDiscordClientCreated)]
        private void OnDiscordClientCreated()
        {
            if (string.IsNullOrEmpty(_pluginConfig.Token))
            {
                PrintWarning("Please enter your bot token in the config and reload the plugin.");
                return;
            }
            
            Client.Connect(new BotConnection
            {
                ApiToken = _pluginConfig.Token,
                LogLevel = _pluginConfig.ExtensionDebugging,
                Intents = GatewayIntents.None
            });
        }

        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            _gatewayReady = true;
            Puts($"{Title} Ready");
            if (_pluginConfig.EnableLoadingMessage && !_serverInit)
            {
                SendLoadingMessage();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        public PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.LoadingMessage = new MessageSettings(config.LoadingMessage ?? new MessageSettings("Server is booting", ActivityType.Game));
            config.StatusMessages ??= new List<MessageSettings>
            {
                new($"{DefaultKeys.Server.Name}", ActivityType.Custom),
                new($"{DefaultKeys.Server.Players}/{DefaultKeys.Server.MaxPlayers} Players", ActivityType.Custom),
                new("{server.players.sleepers} Sleepers", ActivityType.Custom),
                new("{server.players.stored} Total Players", ActivityType.Custom),
                new("Server FPS {server.fps}", ActivityType.Custom),
                new("{server.entities} Entities", ActivityType.Custom),
                new("{server.players.total} Lifetime Players", ActivityType.Custom),
#if RUST
                new MessageSettings("{server.players.queued} Queued", ActivityType.Custom),
                new MessageSettings("{server.players.loading} Joining", ActivityType.Custom),
                new MessageSettings("Wiped: {server.map.wipe.last!local}", ActivityType.Custom),
                new MessageSettings("Size: {world.size} Seed: {world.seed}", ActivityType.Custom)
#endif
            };

            for (int index = 0; index < config.StatusMessages.Count; index++)
            {
                config.StatusMessages[index] = new MessageSettings(config.StatusMessages[index]);
            }

            return config;
        }
        
        private void OnServerInitialized()
        {
            _serverInit = true;
            if (Client.IsConnected())
            {
                timer.In(2.5f, UpdatePresence);
            }

            if (_pluginConfig.EnableUpdateInterval)
            {
                timer.Every(_pluginConfig.UpdateRate, UpdatePresence);
            }
            
            if (_pluginConfig.UpdateOnPlayerStateChange)
            {
                Subscribe(nameof(OnUserConnected));
                Subscribe(nameof(OnUserDisconnected));
            }
        }
        #endregion
        
        #region Hooks
        private void OnUserConnected(IPlayer player) => UpdatePresence();

        private void OnUserDisconnected(IPlayer player) => NextTick(_updatePresence);
        
        private void OnDiscordGatewayResumed() => UpdatePresence();
        private void OnDiscordGatewayReconnected() => UpdatePresence();
        #endregion

        #region Message Handling
        public void SendLoadingMessage()
        {
            SendUpdate(_pluginConfig.LoadingMessage);
        }
        
        public void UpdatePresence()
        {
            if (!_serverInit || !_gatewayReady)
            {
                return;
            }
            
            if (_pluginConfig.StatusMessages.Count == 0)
            {
                PrintError("Presence Text formats contains no values. Please add some to your config");
                return;
            }
            
            SendUpdate(_pluginConfig.StatusMessages[_index]);
            _index = ++_index % _pluginConfig.StatusMessages.Count;
        }

        public void SendUpdate(MessageSettings settings) => SendUpdate(settings.Message, settings.Type);

        public void SendUpdate(string message, ActivityType type)
        {
            _activity.Name = null;
            _activity.State = null;
            string text = _placeholders.ProcessPlaceholders(message, GetDefault());
            if (type == ActivityType.Custom)
            {
                _activity.State = text;
            }

            _activity.Name = text;
            _activity.Type = type;
            Client?.UpdateStatus(_command);
        }

        public PlaceholderData GetDefault() => _placeholders.CreateData(this);
        #endregion

        #region API
        private void API_SendUpdateMessage(string message, int activity = (int)ActivityType.Custom)
        {
            if (_nextApiSend <= DateTime.UtcNow)
            {
                _nextApiSend = DateTime.UtcNow + TimeSpan.FromSeconds(1);
                SendUpdate(message, (ActivityType)activity);
            }
        }
        #endregion

        #region Classes
        public class PluginConfig
        {
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Application Bot Token")]
            public string Token { get; set; }
            
            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Enable Sending Message Per Update Rate")]
            public bool EnableUpdateInterval { get; set; }
            
            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Enable Sending Message On Player Leave/Join")]
            public bool UpdateOnPlayerStateChange { get; set; }
            
            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Enable Sending Server Loading Message")]
            public bool EnableLoadingMessage { get; set; }
            
            [DefaultValue(15f)]
            [JsonProperty(PropertyName = "Update Rate (Seconds)")]
            public float UpdateRate { get; set; }

            [JsonProperty(PropertyName = "Status Messages")]
            public List<MessageSettings> StatusMessages { get; set; }
            
            [JsonProperty(PropertyName = "Server Loading Message")]
            public MessageSettings LoadingMessage { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; }
        }

        public class MessageSettings
        {
            public string Message { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(ActivityType.Custom)]
            public ActivityType Type { get; set; }

            [JsonConstructor]
            public MessageSettings() { }
            
            public MessageSettings(string message, ActivityType type)
            {
                Message = message;
                Type = type;
            }
            
            public MessageSettings(MessageSettings settings)
            {
                Message = settings?.Message ?? string.Empty;
                Type = settings?.Type ?? ActivityType.Game;
            }
        }
        #endregion
    }
}

// --- End of file: DiscordPresence.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-group ---
// --- Original File Path: D/DiscordGroup/DiscordGroup.cs ---

ï»¿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;

namespace Oxide.Plugins
{
    [Info("Discord Group", "MJSU", "2.1.0")]
    [Description("Grants players rewards for linking their game and discord accounts")]
    internal class DiscordGroup : CovalencePlugin, IDiscordPlugin
    {
        #region Class Fields
        public DiscordClient Client { get; set; }

        private PluginConfig _pluginConfig;
        private StoredData _storedData;
        private DiscordRole _role;
        private DiscordGuild _guild;
        
        private readonly Queue<SyncData> _processQueue = new();
        
        private readonly DiscordLink _link = Interface.Oxide.GetLibrary<DiscordLink>();

        private Action _processNext;
        private bool _initialized;
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            Unsubscribe(nameof(OnUserConnected));
            _processNext = ProcessNext;
        }
        
        private void OnServerInitialized()
        {
            if (string.IsNullOrEmpty(_pluginConfig.DiscordApiKey))
            {
                PrintWarning("Please set the Discord Bot Token and reload the plugin");
                return;
            }
            
            Client.Connect(new BotConnection
            {
                Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers,
                ApiToken = _pluginConfig.DiscordApiKey,
                LogLevel = _pluginConfig.ExtensionDebugging
            });
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Commands ??= new List<string>
            {
                "inventory.giveto {steamid} wood 100",
            };
            return config;
        }
        
        private void OnNewSave(string filename)
        {
            if (_pluginConfig.ResetRewardsOnWipe)
            {
                _storedData = new StoredData();
                SaveData();
            }
        }

        private void Unload()
        {
            SaveData();
        }
        #endregion

        #region Discord Hooks
        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            if (ready.Guilds.Count == 0)
            {
                PrintError("Your bot was not found in any discord servers. Please invite it to a server and reload the plugin.");
                return;
            }

            _guild = null;
            if (ready.Guilds.Count == 1 && !_pluginConfig.GuildId.IsValid())
            {
                _guild = ready.Guilds.Values.FirstOrDefault();
            }

            _guild ??= ready.Guilds[_pluginConfig.GuildId];
            if (_guild == null)
            {
                PrintError("Failed to find a matching guild for the Discord Server Id. " +
                           "Please make sure your guild Id is correct and the bot is in the discord server.");
            }
        }

        [HookMethod(DiscordExtHooks.OnDiscordBotFullyLoaded)]
        private void OnDiscordBotFullyLoaded()
        {
            if (_pluginConfig.DiscordRole.IsValid())
            {
                _role = _guild.Roles[_pluginConfig.DiscordRole];
                if (_role == null)
                {
                    PrintWarning($"Discord Role '{_pluginConfig.DiscordRole}' does not exist. Please set the role name or id in the config.");
                    return;
                }
            }
            
            if (!string.IsNullOrEmpty(_pluginConfig.OxideGroup) && !permission.GroupExists(_pluginConfig.OxideGroup))
            {
                PrintWarning($"Oxide group '{_pluginConfig.OxideGroup}' does not exist. Please add the oxide group or set the correct group in the config.");
                return;
            }
            
            if (!_initialized)
            {
                foreach (KeyValuePair<PlayerId, Snowflake> link in _link.PlayerToDiscordIds)
                {
                    IPlayer player = link.Key.Player;
                    if (player.IsDummyPlayer())
                    {
                       continue;
                    }
                    
                    DiscordUser user = _link.GetDiscordUser(link.Key);
                    _processQueue.Enqueue(new SyncData(player, user, SyncAction.Link));
                }
            
                Subscribe(nameof(OnUserConnected));
                timer.In(1f, ProcessNext);
                Puts($"{Title} Ready");
                _initialized = true;
            }
        }
        
        private void OnUserConnected(IPlayer player)
        {
            DiscordUser user = player.GetDiscordUser();
            if (user == null)
            {
                return;
            }

            if (_guild.Members.ContainsKey(user.Id))
            {
                HandlePlayerLinked(player, user);
            }
        }

        [HookMethod(DiscordExtHooks.OnDiscordPlayerLinked)]
        private void OnDiscordPlayerLinked(IPlayer player, DiscordUser user)
        {
            if (_processQueue.Count > 2)
            {
                _processQueue.Enqueue(new SyncData(player, user, SyncAction.Link));
            }
            else
            {
                HandlePlayerLinked(player, user);
            }
        }

        [HookMethod(DiscordExtHooks.OnDiscordPlayerUnlinked)]
        private void OnDiscordPlayerUnlinked(IPlayer player, DiscordUser user)
        {
            if (_processQueue.Count > 2)
            {
                _processQueue.Enqueue(new SyncData(player, user, SyncAction.Unlink));
            }
            else
            {
                HandlePlayerUnlinked(player, user);
            }
        }
        #endregion

        #region Helpers
        public void ProcessNext()
        {
            if (_processQueue.Count == 0)
            {
                return;
            }

            SyncData link = _processQueue.Dequeue();
            
            try
            {
                switch (link.Action)
                {
                    case SyncAction.Link:
                        HandlePlayerLinked(link.Player, link.User);
                        break;
                    case SyncAction.Unlink:
                        HandlePlayerUnlinked(link.Player, link.User);
                        break;
                }
            }
            catch (Exception ex)
            {
                PrintError($"An error occured performing sync for: {link.Player?.Name}({link.Player?.Id}) User: {link.User?.GlobalName}({link.User?.Id}) Action: {link.Action}\n{ex}");
            }

            timer.In(_pluginConfig.UpdateRate, _processNext);
        }
        
        private void HandlePlayerLinked(IPlayer player, DiscordUser user)
        {
            if (!string.IsNullOrEmpty(_pluginConfig.OxideGroup))
            {
                AddToOxideGroup(player);
            }

            if (_role != null)
            {
                AddToDiscordRole(player, user);
            }

            if (_pluginConfig.RunCommands && player.IsConnected)
            {
                RunCommands(player);
            }
        }

        private void AddToOxideGroup(IPlayer player)
        {
            if (!permission.UserHasGroup(player.Id, _pluginConfig.OxideGroup))
            {
                Puts($"Adding player {player.Name}({player.Id}) to oxide group {_pluginConfig.OxideGroup}");
                permission.AddUserGroup(player.Id, _pluginConfig.OxideGroup);
            }
        }

        private void AddToDiscordRole(IPlayer player, DiscordUser user)
        {
            if (user == null || !user.Id.IsValid())
            {
                return;
            }

            _guild.GetMember(Client, user.Id).Then(member =>
            {
                if (_role != null && !member.Roles.Contains(_role.Id))
                {
                    _guild.AddMemberRole(Client, user.Id, _role.Id);
                    Puts($"Adding player {player.Name}({player.Id}) to discord role {_role.Name}");
                }
            }).Catch<ResponseError>(e => e.SuppressErrorMessage());
        }

        private void HandlePlayerUnlinked(IPlayer player, DiscordUser user)
        {
            if (!string.IsNullOrEmpty(_pluginConfig.OxideGroup))
            {
                RemoveFromOxide(player);
            }

            if (_role != null)
            {
                RemoveFromDiscord(player, user);
            }
        }

        private void RemoveFromOxide(IPlayer player)
        {
            Puts($"Removing player {player.Name}({player.Id}) from oxide group {_pluginConfig.OxideGroup}");
            permission.RemoveUserGroup(player.Id, _pluginConfig.OxideGroup);
        }

        private void RemoveFromDiscord(IPlayer player, DiscordUser user)
        {
            if (user == null || !user.Id.IsValid())
            {
                return;
            }

            if (_guild.Members.ContainsKey(user.Id))
            {
                _guild.RemoveMemberRole(Client, user.Id, _role.Id);
                Puts($"Removing player {player.Name}({player.Id}) from discord role {_role.Name}");
            }
        }

        private void RunCommands(IPlayer player)
        {
            if (_storedData.RewardedPlayers.Contains(player.Id))
            {
                return;
            }

            foreach (string command in _pluginConfig.Commands)
            {
                string execCommand = command.Replace("{steamid}", player.Id)
                    .Replace("{name}", player.Name);
                
                server.Command(execCommand);
            }

            _storedData.RewardedPlayers.Add(player.Id);
            NextTick(SaveData);
        }
        
        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string DiscordApiKey { get; set; }
            
            [JsonProperty(PropertyName = "Discord Server ID (Optional if bot only in 1 guild)")]
            public Snowflake GuildId { get; set; }
            
            [JsonProperty("Add To Discord Role (Role ID)")]
            public Snowflake DiscordRole { get; set; }
            
            [DefaultValue("")]
            [JsonProperty("Add To Server Group")]
            public string OxideGroup { get; set; }
            
            [DefaultValue(2f)]
            [JsonProperty("Update Rate (Seconds)")]
            public float UpdateRate { get; set; }
            
            [DefaultValue(false)]
            [JsonProperty("Run Commands On Link")]
            public bool RunCommands { get; set; }
            
            [JsonProperty("Commands To Run")]
            public List<string> Commands { get; set; }

            [DefaultValue(false)]
            [JsonProperty("Reset Rewards On Wipe")]
            public bool ResetRewardsOnWipe { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; }
        }

        private class StoredData
        {
            public HashSet<string> RewardedPlayers = new HashSet<string>();
        }
        
        public readonly struct SyncData
        {
            public readonly IPlayer Player;
            public readonly DiscordUser User;
            public readonly SyncAction Action;

            public SyncData(IPlayer player, DiscordUser user, SyncAction action)
            {
                Player = player;
                User = user;
                Action = action;
            }
        }

        public enum SyncAction : byte
        {
            Link,
            Unlink
        }
        #endregion
    }
}


// --- End of file: DiscordGroup.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/drop-remover ---
// --- Original File Path: D/DropRemover/DropRemover.cs ---

ï»¿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Drop Remover", "Ryan", "1.0.21")]
    [Description("Removes world items from the map with no effect on server performance")]

    public class DropRemover : RustPlugin
    {
        #region Declaration

        private bool ConfigChanged;
        private List<string> ItemBlacklist;

        #endregion

        #region Config

        protected override void LoadDefaultConfig() => PrintWarning("Generating default configuration file...");

        private void InitConfig()
        {
            ItemBlacklist = GetConfig(new List<string>()
            {
                "cctv.camera",
                "targeting.computer"
            }, "Item Blacklist");

            if (ConfigChanged)
            {
                PrintWarning("Updated configuration file with new/changed values.");
                SaveConfig();
            }
        }

        private T GetConfig<T>(T defaultVal, params string[] path)
        {
            var data = Config.Get(path);
            if (data != null)
            {
                return Config.ConvertValue<T>(data);
            }

            Config.Set(path.Concat(new object[] { defaultVal }).ToArray());
            ConfigChanged = true;
            return defaultVal;
        }

        #endregion

        #region Lang

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Permission"] = "You don't have permission to use that command",
                ["Removing"] = "Removing all dropped items on the map...",
                ["Removed"] = "Removed {0} dropped items on the map",
                ["CategoryRemove"] = "Removing all dropped items in the {0} category",
                ["Category"] = " in the '{0}' category",
                ["ItemRemove"] = "Removing all dropped {0}'s on the map",
                ["ItemRemoved"] = "Removed {0}x {1} from the map",
                ["NoDrops"] = "No drops found",
                ["InvalidArgs"] = "Invalid arguments",
                ["NoItem"] = "No item found with input '{0}'",
                ["NoCategory"] = "No category found with input '{0}'"
            }, this);
        }

        #endregion

        #region Methods

        private IEnumerator Delete(IEnumerable<BaseNetworkable> list, string userId, ItemCategory? category = null, Item item = null)
        {
            var count = 0;
            foreach (var listEntry in list)
            {
                var droppedItem = listEntry.GetComponent<DroppedItem>();
                if (droppedItem != null)
                {
                    if (ItemBlacklist.Contains(droppedItem.item.name))
                    {
                        continue;
                    }

                    if (item == null && category == null)
                    {
                        count++;
                        droppedItem.DestroyItem();
                        droppedItem.Kill();
                        yield return new WaitWhile(() => !droppedItem.IsDestroyed);
                    }
                    if (item != null && droppedItem.item.info.shortname == item.info.shortname)
                    {
                        count++;
                        droppedItem.DestroyItem();
                        droppedItem.Kill();
                        yield return new WaitWhile(() => !droppedItem.IsDestroyed);
                    }
                    if (category != null && droppedItem.item.info.category.Equals(category))
                    {
                        count++;
                        droppedItem.DestroyItem();
                        droppedItem.Kill();
                        yield return new WaitWhile(() => !droppedItem.IsDestroyed);
                    }
                }
            }

            var message = string.Format(lang.GetMessage("Removed", this, userId), count);

            if (category != ItemCategory.All && category != null)
            {
                message += string.Format(lang.GetMessage("Category", this, userId), category);
            }

            if (item != null)
            {
                message = string.Format(lang.GetMessage("ItemRemoved", this, userId), count, item.info.displayName.english);
            }

            if (count == 0)
            {
                message = lang.GetMessage("NoDrops", this, userId);
            }

            foreach (var admin in BasePlayer.activePlayerList.Where(p => p.IsAdmin))
            {
                PrintToChat(admin, message);
            }

            Puts(message);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            InitConfig();
        }

        #endregion

        #region Commands

        [ConsoleCommand("drops.remove")]
        private void DropRemoveCommand(ConsoleSystem.Arg arg)
        {
            var userId = arg.Connection?.userid.ToString();
            if (string.IsNullOrEmpty(userId))
                userId = "0";
            if (arg.Connection != null && arg.Connection.authLevel < 2)
            {
                arg.ReplyWith(lang.GetMessage("Permission", this, userId));
                return;
            }
            arg.ReplyWith(lang.GetMessage("Removing", this, userId));
            ServerMgr.Instance.StartCoroutine(Delete(BaseNetworkable.serverEntities, userId));
        }

        [ConsoleCommand("drops.itemremove")]
        private void ItemRemove(ConsoleSystem.Arg arg)
        {
            var userId = arg.Connection?.userid.ToString();
            if (string.IsNullOrEmpty(userId))
                userId = "0";
            if (arg.Connection != null && arg.Connection.authLevel < 2)
            {
                arg.ReplyWith(lang.GetMessage("Permission", this, userId));
                return;
            }
            var itemName = arg.GetString(0);
            if (!string.IsNullOrEmpty(itemName))
            {
                var createdItem = ItemManager.CreateByPartialName(itemName);
                if (createdItem != null)
                {
                    arg.ReplyWith(string.Format(lang.GetMessage("ItemRemove", this, userId), createdItem.info.displayName.english));
                    ServerMgr.Instance.StartCoroutine(Delete(BaseNetworkable.serverEntities, userId, item: createdItem));
                    return;
                }
                arg.ReplyWith(string.Format(lang.GetMessage("NoItem", this, userId), itemName));
                return;
            }
            arg.ReplyWith(lang.GetMessage("InvalidArgs", this, userId));
        }

        [ConsoleCommand("drops.categoryremove")]
        private void CategoryRemove(ConsoleSystem.Arg arg)
        {
            var userId = arg.Connection?.userid.ToString();
            if (string.IsNullOrEmpty(userId))
                userId = "0";
            if (arg.Connection != null && arg.Connection.authLevel < 2)
            {
                arg.ReplyWith(lang.GetMessage("Permission", this, userId));
                return;
            }
            var categoryName = arg.GetString(0);
            if (!string.IsNullOrEmpty(categoryName))
            {
                var foundCategory = ItemCategory.All;
                foreach (var itemCategory in Enum.GetValues(typeof(ItemCategory)))
                {
                    if (itemCategory.ToString().ToLower().Equals(categoryName.ToLower()))
                        foundCategory = (ItemCategory) itemCategory;
                }
                if (foundCategory != ItemCategory.All)
                {
                    arg.ReplyWith(string.Format(lang.GetMessage("CategoryRemove", this, userId), foundCategory));
                    ServerMgr.Instance.StartCoroutine(Delete(BaseNetworkable.serverEntities, userId, foundCategory));
                    return;
                }
                arg.ReplyWith(string.Format(lang.GetMessage("NoCategory", this, userId), categoryName));
                return;
            }
            arg.ReplyWith(lang.GetMessage("InvalidArgs", this, userId));
        }

        #endregion
    }
}

// --- End of file: DropRemover.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/dynamic-slots-limit ---
// --- Original File Path: D/DynamicSlotsLimit/DynamicSlotsLimit.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Dynamic Slots Limit", "Orange", "1.0.5")]
    [Description("Modifies maximal server slots based on current players count")]
    public class DynamicSlotsLimit : CovalencePlugin
    {
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            CheckSlots();
        }
        
        private void OnUserConnected(IPlayer player)
        {
            CheckSlots();
        }

        private void OnUserDisconnected(IPlayer player)
        {
            CheckSlots();
        }

        private void Unload()
        {
            config = null;
        }

        #endregion

        #region Core

        private void CheckSlots()
        {
            var occupiedSlots = server.Players;
            if (occupiedSlots == 0)
            {
                server.MaxPlayers = config.slotsMin;
                return;
            }
            
            var maximalSlots = server.MaxPlayers;
            var freeSlots = maximalSlots - occupiedSlots;
            var change = freeSlots < config.triggerStep ? config.changeStep : -config.changeStep;
            var targetSlots = maximalSlots + change;
            if (targetSlots > config.slotsMin && targetSlots < config.slotsMax)
            {
                server.MaxPlayers += change;
            }
        }

        #endregion
        
        #region Configuration | 24.05.2020

        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Minimal slots")]
            public int slotsMin = 100;

            [JsonProperty(PropertyName = "Maximal slots")]
            public int slotsMax = 200;
            
            [JsonProperty(PropertyName = "Step rate")]
            public int changeStep = 5;
            
            [JsonProperty(PropertyName = "Trigger when X slots left")]
            public int triggerStep = 10;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }
                
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: DynamicSlotsLimit.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-core ---
// --- Original File Path: D/DiscordCore/DiscordCore.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.Builders;
using Oxide.Ext.Discord.Cache;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Helpers;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;
using Oxide.Ext.Discord.Types;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;

//DiscordCore created with PluginMerge v(1.0.9.0) by MJSU @ https://github.com/dassjosh/Plugin.Merge
namespace Oxide.Plugins
{
    [Info("Discord Core", "MJSU", "3.0.2")]
    [Description("Creates a link between a player and discord")]
    public partial class DiscordCore : CovalencePlugin, IDiscordPlugin, IDiscordLink
    {
        #region Plugins\DiscordCore.Fields.cs
        public DiscordClient Client { get; set; }
        
        private PluginData _pluginData;
        private PluginConfig _pluginConfig;
        
        private DiscordUser _bot;
        
        public DiscordGuild Guild;
        
        private readonly BotConnection _discordSettings = new()
        {
            Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers
        };
        
        private readonly DiscordLink _link = GetLibrary<DiscordLink>();
        private readonly DiscordMessageTemplates _templates = GetLibrary<DiscordMessageTemplates>();
        private readonly DiscordPlaceholders _placeholders = GetLibrary<DiscordPlaceholders>();
        private readonly DiscordLocales _lang = GetLibrary<DiscordLocales>();
        private readonly DiscordCommandLocalizations _local = GetLibrary<DiscordCommandLocalizations>();
        private readonly StringBuilder _sb = new();
        
        private JoinHandler _joinHandler;
        private JoinBanHandler _banHandler;
        private LinkHandler _linkHandler;
        
        private const string UsePermission = "discordcore.use";
        private static readonly DiscordColor AccentColor = new("de8732");
        private static readonly DiscordColor Success = new("43b581");
        private static readonly DiscordColor Danger = new("f04747");
        private const string PlayerArg = "player";
        private const string UserArg = "user";
        private const string CodeArg = "code";
        
        private DiscordApplicationCommand _appCommand;
        private string _allowedChannels;
        
        public static DiscordCore Instance;
        #endregion

        #region Plugins\DiscordCore.Setup.cs
        // ReSharper disable once UnusedMember.Local
        private void Init()
        {
            Instance = this;
            _pluginData = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
            
            permission.RegisterPermission(UsePermission, this);
            
            _banHandler = new JoinBanHandler(_pluginConfig.LinkBanSettings);
            _linkHandler = new LinkHandler(_pluginData, _pluginConfig);
            _joinHandler = new JoinHandler(_pluginConfig.LinkSettings, _linkHandler, _banHandler);
            
            _discordSettings.ApiToken = _pluginConfig.ApiKey;
            _discordSettings.LogLevel = _pluginConfig.ExtensionDebugging;
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }
        
        public PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.LinkSettings = new LinkSettings(config.LinkSettings);
            config.WelcomeMessageSettings = new WelcomeMessageSettings(config.WelcomeMessageSettings);
            config.LinkMessageSettings = new GuildMessageSettings(config.LinkMessageSettings);
            config.PermissionSettings = new LinkPermissionSettings(config.PermissionSettings);
            config.LinkBanSettings = new LinkBanSettings(config.LinkBanSettings);
            return config;
        }
        
        // ReSharper disable once UnusedMember.Local
        private void OnServerInitialized()
        {
            RegisterChatLangCommand(nameof(DiscordCoreChatCommand), ServerLang.Commands.DcCommand);
            
            if (string.IsNullOrEmpty(_pluginConfig.ApiKey))
            {
                PrintWarning("Please set the Discord Bot Token in the config and reload the plugin");
                return;
            }
            
            foreach (DiscordInfo info in _pluginData.PlayerDiscordInfo.Values)
            {
                if (info.LastOnline == DateTime.MinValue)
                {
                    info.LastOnline = DateTime.UtcNow;
                }
            }
            
            _link.AddLinkPlugin(this);
            RegisterPlaceholders();
            ValidateGroups();
            
            Client.Connect(_discordSettings);
        }
        
        public void ValidateGroups()
        {
            foreach (string group in _pluginConfig.PermissionSettings.LinkGroups)
            {
                if (!permission.GroupExists(group))
                {
                    PrintWarning($"`{group}` is set as the link group but group does not exist");
                }
            }
            
            foreach (string group in _pluginConfig.PermissionSettings.UnlinkGroups)
            {
                if (!permission.GroupExists(group))
                {
                    PrintWarning($"`{group}` is set as the unlink group but group does not exist");
                }
            }
            
            foreach (string perm in _pluginConfig.PermissionSettings.LinkPermissions)
            {
                if (!permission.PermissionExists(perm))
                {
                    PrintWarning($"`{perm}` is set as the link permission but group does not exist");
                }
            }
            
            foreach (string perm in _pluginConfig.PermissionSettings.UnlinkPermissions)
            {
                if (!permission.PermissionExists(perm))
                {
                    PrintWarning($"`{perm}` is set as the unlink permission but group does not exist");
                }
            }
        }
        
        // ReSharper disable once UnusedMember.Local
        private void Unload()
        {
            SaveData();
            Instance = null;
        }
        #endregion

        #region Plugins\DiscordCore.Lang.cs
        public void Chat(IPlayer player, string key, PlaceholderData data = null)
        {
            if (player.IsConnected)
            {
                player.Reply(string.Format(Lang(ServerLang.Format, player), Lang(key, player, data)));
            }
        }
        
        public void BroadcastMessage(string key, PlaceholderData data)
        {
            string message = Lang(key);
            message = _placeholders.ProcessPlaceholders(message, data);
            if (string.IsNullOrEmpty(message))
            {
                return;
            }
            
            message = string.Format(Lang(ServerLang.Format), message);
            server.Broadcast(message);
        }
        
        public string Lang(string key, IPlayer player = null, PlaceholderData data = null)
        {
            string message = lang.GetMessage(key, this, player?.Id);
            if (data != null)
            {
                message = _placeholders.ProcessPlaceholders(message, data);
            }
            
            return message;
        }
        
        public void RegisterChatLangCommand(string command, string langKey)
        {
            HashSet<string> registeredCommands = new();
            foreach (string langType in lang.GetLanguages(this))
            {
                Dictionary<string, string> langKeys = lang.GetMessages(langType, this);
                string commandValue;
                if (langKeys.TryGetValue(langKey, out commandValue) && !string.IsNullOrEmpty(commandValue) && registeredCommands.Add(commandValue))
                {
                    AddCovalenceCommand(commandValue, command);
                }
            }
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [ServerLang.Format] = $"[#CCCCCC][[{AccentColor.ToHex()}]{Title}[/#]] {{0}}[/#]",
                [ServerLang.NoPermission] = "You do not have permission to use this command",
                
                [ServerLang.Commands.DcCommand] = "dc",
                [ServerLang.Commands.CodeCommand] = "code",
                [ServerLang.Commands.UserCommand] = "user",
                [ServerLang.Commands.LeaveCommand] = "leave",
                [ServerLang.Commands.AcceptCommand] = "accept",
                [ServerLang.Commands.DeclineCommand] = "decline",
                [ServerLang.Commands.LinkCommand] = "link",
                
                [ServerLang.Commands.Code.LinkInfo] = $"To complete your activation please open Discord use the following command: [{AccentColor.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Discord.DiscordCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Discord.LinkCommand)} {PlaceholderKeys.LinkCode}[/#].\n",
                [ServerLang.Commands.Code.LinkServer] = $"In order to use this command you must be in the {DefaultKeys.Guild.Name.Color(AccentColor)} discord server. " +
                $"You can join @ {$"{PlaceholderKeys.InviteUrl}".Color(AccentColor)}.\n",
                [ServerLang.Commands.Code.LinkInGuild] = $"This command can be used in the following guild channels {PlaceholderKeys.CommandChannels}.\n",
                [ServerLang.Commands.Code.LinkInDm] = $"This command can be used in the following in a direct message to {DefaultKeys.User.Username.Color(AccentColor)} bot",
                
                [ServerLang.Commands.User.MatchFound] = $"We found a match by username. " +
                $"We have a sent a discord message to {DefaultKeys.User.Fullname.Color(AccentColor)} to complete the link.\n" +
                $"If you haven't received a message make sure you allow DM's from {DefaultKeys.Bot.Fullname.Color(AccentColor)}.",
                [ServerLang.Commands.User.Errors.InvalidSyntax] = "Invalid User Join Syntax.\n" +
                $"[{AccentColor.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.UserCommand)} username[/#] to start the link process by your discord username\n" +
                $"[{AccentColor.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.UserCommand)} userid[/#] to start the link process by your discord user ID",
                [ServerLang.Commands.User.Errors.UserIdNotFound] = $"Failed to find a discord user in the {DefaultKeys.Guild.Name.Color(AccentColor)} Discord server with user ID {DefaultKeys.Snowflake.Id.Color(Danger)}",
                [ServerLang.Commands.User.Errors.UserNotFound] = $"Failed to find a any discord users in the {DefaultKeys.Guild.Name.Color(AccentColor)} Discord server with the username {PlaceholderKeys.NotFound.Color(Danger)}",
                [ServerLang.Commands.User.Errors.MultipleUsersFound] = $"Multiple discord users found in the the {DefaultKeys.Guild.Name.Color(AccentColor)} Discord server matching {PlaceholderKeys.NotFound.Color(Danger)}. " +
                "Please include more of the username and/or the discriminator in your search.",
                [ServerLang.Commands.User.Errors.SearchError] = "An error occured while trying to search by username. " +
                "Please try a different username or try again later. " +
                "If the issue persists please notify an admin.",
                
                [ServerLang.Commands.Leave.Errors.NotLinked] = "We were unable to unlink your account as you do not appear to have been linked.",
                
                [ServerLang.Announcements.Link.Command] = $"{DefaultKeys.Player.Name.Color(AccentColor)} has successfully linked their game account with their discord user {DefaultKeys.User.Fullname.Color(AccentColor)}. If you would would like to be linked type /{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} to learn more.",
                [ServerLang.Announcements.Link.Admin] = $"{DefaultKeys.Player.Name.Color(AccentColor)} has successfully been linked by an admin to discord user {DefaultKeys.User.Fullname.Color(AccentColor)}.",
                [ServerLang.Announcements.Link.Api] = $"{DefaultKeys.Player.Name.Color(AccentColor)} has successfully linked their game account with their discord user {DefaultKeys.User.Fullname.Color(AccentColor)}. If you would would like to be linked type /{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} to learn more.",
                [ServerLang.Announcements.Link.GuildRejoin] = $"{DefaultKeys.Player.Name.Color(AccentColor)} has been relinked with discord user {DefaultKeys.User.Fullname.Color(AccentColor)} for rejoining the {DefaultKeys.Guild.Name.Color(AccentColor)} discord server",
                [ServerLang.Announcements.Link.InactiveRejoin] = $"{DefaultKeys.Player.Name.Color(AccentColor)} has been relinked with discord user {DefaultKeys.User.Fullname.Color(AccentColor)} for rejoining the {DefaultKeys.Server.Name.Color(AccentColor)} game server",
                [ServerLang.Announcements.Unlink.Command] = $"{DefaultKeys.Player.Name.Color(AccentColor)} has successfully unlinked their game account from their discord user {DefaultKeys.User.Fullname.Color(AccentColor)}.",
                [ServerLang.Announcements.Unlink.Admin] = $"{DefaultKeys.Player.Name.Color(AccentColor)} has successfully been unlinked by an admin from discord user {DefaultKeys.User.Fullname.Color(AccentColor)}.",
                [ServerLang.Announcements.Unlink.Api] = $"{DefaultKeys.Player.Name.Color(AccentColor)} has successfully unlinked their game account from their discord user {DefaultKeys.User.Fullname.Color(AccentColor)}.",
                [ServerLang.Announcements.Unlink.LeftGuild] = $"{DefaultKeys.Player.Name.Color(AccentColor)} has been unlinked from discord user {DefaultKeys.User.Fullname.Color(AccentColor)} they left the {DefaultKeys.Guild.Name.Color(AccentColor)} Discord server",
                [ServerLang.Announcements.Unlink.Inactive] = $"{DefaultKeys.Player.Name.Color(AccentColor)} has been unlinked from discord user {DefaultKeys.User.Fullname.Color(AccentColor)} because they haven't been active on {DefaultKeys.Server.Name.Color(AccentColor)} game server for {DefaultKeys.Timespan.TotalDays.Color(AccentColor)} days",
                
                [ServerLang.Link.Completed.Command] = $"You have successfully linked your player {DefaultKeys.Player.Name.Color(AccentColor)} with discord user {DefaultKeys.User.Fullname.Color(AccentColor)}",
                [ServerLang.Link.Completed.Admin] = $"You have been successfully linked by an admin with player {DefaultKeys.Player.Name.Color(AccentColor)} and discord user {DefaultKeys.User.Fullname.Color(AccentColor)}",
                [ServerLang.Link.Completed.Api] = $"You have successfully linked your player {DefaultKeys.Player.Name.Color(AccentColor)} with discord user {DefaultKeys.User.Fullname.Color(AccentColor)}",
                [ServerLang.Link.Completed.GuildRejoin] = $"Your player {DefaultKeys.Player.Name.Color(AccentColor)} has been relinked with discord user {DefaultKeys.User.Fullname.Color(AccentColor)} because rejoined the {DefaultKeys.Guild.Name.Color(AccentColor)} Discord server",
                [ServerLang.Link.Completed.InactiveRejoin] = $"Your player {DefaultKeys.Player.Name.Color(AccentColor)} has been relinked with discord user {DefaultKeys.User.Fullname.Color(AccentColor)} because rejoined {DefaultKeys.Server.Name.Color(AccentColor)} server",
                [ServerLang.Unlink.Completed.Command] = $"You have successfully unlinked your player {DefaultKeys.Player.Name.Color(AccentColor)} from discord user {DefaultKeys.User.Fullname.Color(AccentColor)}",
                [ServerLang.Unlink.Completed.Admin] = $"You have been successfully unlinked by an admin from discord user {DefaultKeys.User.Fullname.Color(AccentColor)}",
                [ServerLang.Unlink.Completed.Api] = $"You have successfully unlinked your player {DefaultKeys.Player.Name.Color(AccentColor)} from discord user {DefaultKeys.User.Fullname.Color(AccentColor)}",
                [ServerLang.Unlink.Completed.LeftGuild] = $"Your player {DefaultKeys.Player.Name.Color(AccentColor)} has been unlinked from discord user {DefaultKeys.User.Fullname.Color(AccentColor)} because you left the {DefaultKeys.Guild.Name.Color(AccentColor)} Discord server",
                
                [ServerLang.Link.Declined.JoinWithPlayer] = $"We have declined the discord link between {DefaultKeys.Player.Name.Color(AccentColor)} and {DefaultKeys.User.Fullname.Color(AccentColor)}",
                [ServerLang.Link.Declined.JoinWithUser] = $"{DefaultKeys.User.Fullname.Color(AccentColor)} has declined your link to {DefaultKeys.Player.Name.Color(AccentColor)}",
                
                [ServerLang.Link.Errors.InvalidSyntax] = "Invalid Link Syntax. Please type the command you were given in Discord. " +
                "Command should be in the following format:" +
                $"[{AccentColor.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.LinkCommand)} {{code}}[/#] where {{code}} is the code sent to you in Discord.",
                
                [ServerLang.Banned.IsUserBanned] = "You have been banned from joining by Discord user due to multiple declined join attempts. " +
                $"Your ban will end in {DefaultKeys.Timespan.Days} days {DefaultKeys.Timespan.Hours} hours {DefaultKeys.Timespan.Minutes} minutes {DefaultKeys.Timespan.Seconds} Seconds.",
                
                [ServerLang.Join.ByPlayer] = $"{DefaultKeys.User.Fullname.Color(AccentColor)} is trying to link their Discord account with your game account. " +
                $"If you wish to [{Success.ToHex()}]accept[/#] this link please type [{Success.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.AcceptCommand)}[/#]. " +
                $"If you wish to [{Danger.ToHex()}]decline[/#] this link please type [{Danger.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DeclineCommand)}[/#]",
                [ServerLang.Discord.DiscordCommand] = "dc",
                [ServerLang.Discord.LinkCommand] = "link",
                
                [ServerLang.Join.Errors.PlayerJoinActivationNotFound] = "There are no pending joins in progress for this game account. Please start the link in Discord and try again.",
                
                [ServerLang.Errors.PlayerAlreadyLinked] = $"This player is already linked to Discord user {DefaultKeys.User.Fullname.Color(AccentColor)}. " +
                $"If you wish to link yourself to another account please type [{AccentColor.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.LeaveCommand)}[/#]",
                [ServerLang.Errors.DiscordAlreadyLinked] = $"This Discord user is already linked to player {DefaultKeys.Player.Name.Color(AccentColor)}. " +
                $"If you wish to link yourself to another account please type [{AccentColor.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.LeaveCommand)}[/#]",
                [ServerLang.Errors.ActivationNotFound] = $"We failed to find any pending joins with code [{AccentColor.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)}[/#]. " +
                "Please verify the code is correct and try again.",
                [ServerLang.Errors.MustBeCompletedInDiscord] = "You need to complete the steps provided in Discord since you started the link from the game server.",
                [ServerLang.Errors.ConsolePlayerNotSupported] = "This command cannot be ran in the server console. ",
                
                [ServerLang.Commands.HelpMessage] = "Allows players to link their player and discord accounts together. " +
                $"Players must first join the {DefaultKeys.Guild.Name.Color(AccentColor)} Discord @ [{AccentColor.ToHex()}]{PlaceholderKeys.InviteUrl}[/#]\n" +
                $"[{AccentColor.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.CodeCommand)}[/#] to start the link process using a code\n" +
                $"[{AccentColor.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.UserCommand)} username[/#] to start the link process by your discord username\n" +
                $"[{AccentColor.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.UserCommand)} userid[/#] to start the link process by your discord user ID\n" +
                $"[{AccentColor.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.LeaveCommand)}[/#] to to unlink yourself from discord\n" +
                $"[{AccentColor.ToHex()}]/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)}[/#] to see this message again",
            }, this);
        }
        #endregion

        #region Plugins\DiscordCore.ChatCommands.cs
        // ReSharper disable once UnusedParameter.Local
        private void DiscordCoreChatCommand(IPlayer player, string cmd, string[] args)
        {
            if (!player.HasPermission(UsePermission))
            {
                Chat(player, ServerLang.NoPermission);
                return;
            }
            
            if (player.Id == "server_console")
            {
                Chat(player, ServerLang.Errors.ConsolePlayerNotSupported, GetDefault(player));
                return;
            }
            
            if (args.Length == 0)
            {
                DisplayHelp(player);
                return;
            }
            
            string subCommand = args[0];
            if (subCommand.Equals(Lang(ServerLang.Commands.CodeCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                HandleServerCodeJoin(player);
                return;
            }
            
            if (subCommand.Equals(Lang(ServerLang.Commands.UserCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                HandleServerUserJoin(player, args);
                return;
            }
            
            if (subCommand.Equals(Lang(ServerLang.Commands.LeaveCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                HandleServerLeave(player);
                return;
            }
            
            if (subCommand.Equals(Lang(ServerLang.Commands.AcceptCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                HandleUserJoinAccept(player);
                return;
            }
            
            if (subCommand.Equals(Lang(ServerLang.Commands.DeclineCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                HandleUserJoinDecline(player);
                return;
            }
            
            if (subCommand.Equals(Lang(ServerLang.Commands.LinkCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                HandleServerCompleteLink(player, args);
                return;
            }
            
            DisplayHelp(player);
        }
        
        public void DisplayHelp(IPlayer player)
        {
            Chat(player, ServerLang.Commands.HelpMessage, GetDefault(player));
        }
        
        public void HandleServerCodeJoin(IPlayer player)
        {
            if (player.IsLinked())
            {
                Chat(player, ServerLang.Errors.PlayerAlreadyLinked, GetDefault(player, player.GetDiscordUser()));
                return;
            }
            
            //Puts("A");
            
            JoinData join = _joinHandler.CreateActivation(player);
            //Puts("B");
            using (PlaceholderData data = GetDefault(player).AddUser(_bot).Add(PlaceholderDataKeys.Code, join.Code))
            {
                data.ManualPool();
                _sb.Clear();
                _sb.Append(LangPlaceholder(ServerLang.Commands.Code.LinkInfo, data));
                _sb.Append(LangPlaceholder(ServerLang.Commands.Code.LinkServer, data));
                if (!string.IsNullOrEmpty(_allowedChannels))
                {
                    _sb.Append(LangPlaceholder(ServerLang.Commands.Code.LinkInGuild, data));
                }
                
                if (_appCommand?.DmPermission is true)
                {
                    _sb.Append(LangPlaceholder(ServerLang.Commands.Code.LinkInDm, data));
                }
            }
            
            Chat(player, _sb.ToString());
        }
        
        public void HandleServerUserJoin(IPlayer player, string[] args)
        {
            if (player.IsLinked())
            {
                Chat(player, ServerLang.Errors.PlayerAlreadyLinked, GetDefault(player, player.GetDiscordUser()));
                return;
            }
            
            if (_banHandler.IsBanned(player))
            {
                Chat(player, ServerLang.Banned.IsUserBanned, GetDefault(player).AddTimeSpan(_banHandler.GetRemainingDuration(player)));
                return;
            }
            
            if (args.Length < 2)
            {
                Chat(player, ServerLang.Commands.User.Errors.InvalidSyntax, GetDefault(player));
                return;
            }
            
            string search = args[1];
            
            Snowflake id;
            if (Snowflake.TryParse(search, out id))
            {
                GuildMember member = Guild.Members[id];
                if (member == null)
                {
                    Chat(player, ServerLang.Commands.User.Errors.UserIdNotFound, GetDefault(player).AddSnowflake(id));
                    return;
                }
                
                UserSearchMatchFound(player, member.User);
                return;
            }
            
            int discriminatorIndex = search.LastIndexOf('#');
            string userName;
            string discriminator;
            if (discriminatorIndex == -1)
            {
                userName = search;
                discriminator = null;
            }
            else
            {
                userName = search.Substring(0, discriminatorIndex);
                discriminator = search.Substring(discriminatorIndex, search.Length - discriminatorIndex);
            }
            
            GuildSearchMembers guildSearch = new()
            {
                Query = userName,
                Limit = 1000
            };
            
            Guild.SearchMembers(Client, guildSearch).Then(members =>
            {
                HandleChatJoinUserResults(player, members, userName, discriminator);
            }).Catch(error =>
            {
                Chat(player, ServerLang.Commands.User.Errors.SearchError, GetDefault(player));
            });
        }
        
        public void HandleChatJoinUserResults(IPlayer player, List<GuildMember> members, string userName, string discriminator)
        {
            if (members.Count == 0)
            {
                string name = !string.IsNullOrEmpty(discriminator) ? $"{userName}#{discriminator}" : userName;
                Chat(player, ServerLang.Commands.User.Errors.UserNotFound, GetDefault(player).Add(PlaceholderDataKeys.NotFound, name));
                return;
            }
            
            if (members.Count == 1)
            {
                UserSearchMatchFound(player, members[0].User);
                return;
            }
            
            DiscordUser user = null;
            
            int count = 0;
            for (int index = 0; index < members.Count; index++)
            {
                GuildMember member = members[index];
                DiscordUser searchUser = member.User;
                if (discriminator == null)
                {
                    if (searchUser.Username.StartsWith(userName, StringComparison.OrdinalIgnoreCase))
                    {
                        user = searchUser;
                        count++;
                        if (count > 1)
                        {
                            break;
                        }
                    }
                }
                #pragma warning disable CS0618
                else if (searchUser.Username.Equals(userName, StringComparison.OrdinalIgnoreCase) && (searchUser.HasUpdatedUsername || searchUser.Discriminator.Equals(discriminator)))
                #pragma warning restore CS0618
                {
                    user = searchUser;
                    break;
                }
            }
            
            if (user == null || count > 1)
            {
                string name = !string.IsNullOrEmpty(discriminator) ? $"{userName}#{discriminator}" : userName;
                Chat(player, ServerLang.Commands.User.Errors.MultipleUsersFound, GetDefault(player).Add(PlaceholderDataKeys.NotFound, name));
                return;
            }
            
            UserSearchMatchFound(player, user);
        }
        
        public void UserSearchMatchFound(IPlayer player, DiscordUser user)
        {
            _joinHandler.CreateActivation(player, user, JoinSource.Server);
            using (PlaceholderData data = GetDefault(player, user))
            {
                data.ManualPool();
                Chat(player, ServerLang.Commands.User.MatchFound, data);
                SendTemplateMessage(TemplateKeys.Join.CompleteLink, user, player, data);
            }
        }
        
        public void HandleServerLeave(IPlayer player)
        {
            DiscordUser user = player.GetDiscordUser();
            if (user == null)
            {
                Chat(player, ServerLang.Commands.Leave.Errors.NotLinked, GetDefault(player));
                return;
            }
            
            _linkHandler.HandleUnlink(player, user, UnlinkedReason.Command, null);
        }
        
        public void HandleUserJoinAccept(IPlayer player)
        {
            JoinData join = _joinHandler.FindCompletedByPlayer(player);
            if (join == null)
            {
                Chat(player, ServerLang.Join.Errors.PlayerJoinActivationNotFound, GetDefault(player));
                return;
            }
            
            if (join.From == JoinSource.Server)
            {
                Chat(player, ServerLang.Errors.MustBeCompletedInDiscord, GetDefault(player));
                return;
            }
            
            _joinHandler.CompleteLink(join, null);
        }
        
        public void HandleUserJoinDecline(IPlayer player)
        {
            JoinData join = _joinHandler.FindCompletedByPlayer(player);
            if (join == null)
            {
                Chat(player, ServerLang.Join.Errors.PlayerJoinActivationNotFound, GetDefault(player));
                return;
            }
            
            _joinHandler.DeclineLink(join, null);
        }
        
        public void HandleServerCompleteLink(IPlayer player, string[] args)
        {
            if (player.IsLinked())
            {
                Chat(player, ServerLang.Errors.PlayerAlreadyLinked, GetDefault(player, player.GetDiscordUser()));
                return;
            }
            
            if (args.Length < 2)
            {
                Chat(player, ServerLang.Link.Errors.InvalidSyntax, GetDefault(player));
                return;
            }
            
            string code = args[1];
            JoinData join = _joinHandler.FindByCode(code);
            if (join == null)
            {
                Chat(player, ServerLang.Errors.MustBeCompletedInDiscord, GetDefault(player));
                return;
            }
            
            if (join.From == JoinSource.Server)
            {
                Chat(player, ServerLang.Errors.MustBeCompletedInDiscord, GetDefault(player));
                return;
            }
            
            if (join.Discord.IsLinked())
            {
                Chat(player, ServerLang.Errors.DiscordAlreadyLinked, GetDefault(player, join.Discord));
                return;
            }
            
            join.Player = player;
            _joinHandler.CompleteLink(join, null);
        }
        #endregion

        #region Plugins\DiscordCore.Hooks.cs
        // ReSharper disable once UnusedMember.Local
        private void OnUserConnected(IPlayer player)
        {
            _linkHandler.OnUserConnected(player);
        }
        #endregion

        #region Plugins\DiscordCore.DiscordHooks.cs
        // ReSharper disable once UnusedMember.Local
        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            _bot = ready.User;
            
            DiscordGuild guild = null;
            if (ready.Guilds.Count == 1 && !_pluginConfig.GuildId.IsValid())
            {
                guild = ready.Guilds.Values.FirstOrDefault();
            }
            
            if (guild == null)
            {
                guild = ready.Guilds[_pluginConfig.GuildId];
                if (guild == null)
                {
                    PrintError("Failed to find a matching guild for the Discord Server Id. " +
                    "Please make sure your guild Id is correct and the bot is in the discord server.");
                    return;
                }
            }
            
            Guild = guild;
            
            DiscordApplication app = Client.Bot.Application;
            if (!app.HasApplicationFlag(ApplicationFlags.GatewayGuildMembersLimited) && !app.HasApplicationFlag(ApplicationFlags.GatewayGuildMembers))
            {
                PrintError($"You need to enable \"Server Members Intent\" for {Client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n" +
                $"{Name} will not function correctly until that is fixed. Once updated please reload {Name}.");
                return;
            }
            
            Puts($"Connected to bot: {_bot.Username}");
        }
        
        // ReSharper disable once UnusedMember.Local
        [HookMethod(DiscordExtHooks.OnDiscordBotFullyLoaded)]
        private void OnDiscordBotFullyLoaded()
        {
            RegisterTemplates();
            RegisterUserApplicationCommands();
            RegisterAdminApplicationCommands();
            _linkHandler.ProcessLeaveAndRejoin();
            SetupGuildWelcomeMessage();
            foreach (Snowflake role in _pluginConfig.PermissionSettings.LinkRoles)
            {
                if (!Guild?.Roles.ContainsKey(role) ?? false)
                {
                    PrintWarning($"`{role}` is set as the link role but role does not exist");
                }
            }
            
            foreach (Snowflake role in _pluginConfig.PermissionSettings.UnlinkRoles)
            {
                if (!Guild?.Roles.ContainsKey(role) ?? false)
                {
                    PrintWarning($"`{role}` is set as the unlink role but role does not exist");
                }
            }
        }
        
        // ReSharper disable once UnusedMember.Local
        [HookMethod(DiscordExtHooks.OnDiscordGuildMemberAdded)]
        private void OnDiscordGuildMemberAdded(GuildMemberAddedEvent member, DiscordGuild guild)
        {
            if (Guild?.Id != guild.Id)
            {
                return;
            }
            
            _linkHandler.OnGuildMemberJoin(member.User);
            if (!_pluginConfig.WelcomeMessageSettings.EnableWelcomeMessage || !_pluginConfig.WelcomeMessageSettings.SendOnGuildJoin)
            {
                return;
            }
            
            if (member.User.IsLinked())
            {
                return;
            }
            
            SendGlobalTemplateMessage(TemplateKeys.WelcomeMessage.PmWelcomeMessage, member.User);
        }
        
        // ReSharper disable once UnusedMember.Local
        [HookMethod(DiscordExtHooks.OnDiscordGuildMemberRemoved)]
        private void OnDiscordGuildMemberRemoved(GuildMemberRemovedEvent member, DiscordGuild guild)
        {
            if (Guild?.Id != guild.Id)
            {
                return;
            }
            
            _linkHandler.OnGuildMemberLeft(member.User);
        }
        
        // ReSharper disable once UnusedMember.Local
        [HookMethod(DiscordExtHooks.OnDiscordGuildMemberRoleAdded)]
        private void OnDiscordGuildMemberRoleAdded(GuildMember member, Snowflake roleId, DiscordGuild guild)
        {
            if (Guild?.Id != guild.Id)
            {
                return;
            }
            
            if (!_pluginConfig.WelcomeMessageSettings.EnableWelcomeMessage || !_pluginConfig.WelcomeMessageSettings.SendOnRoleAdded.Contains(roleId))
            {
                return;
            }
            
            if (member.User.IsLinked())
            {
                return;
            }
            
            SendGlobalTemplateMessage(TemplateKeys.WelcomeMessage.PmWelcomeMessage, member.User);
        }
        #endregion

        #region Plugins\DiscordCore.UserAppCommands.cs
        public void RegisterUserApplicationCommands()
        {
            ApplicationCommandBuilder builder = new ApplicationCommandBuilder(UserAppCommands.Command, "Discord Core Commands", ApplicationCommandType.ChatInput)
            .AddDefaultPermissions(PermissionFlags.None);
            
            AddUserCodeCommand(builder);
            AddUserUserCommand(builder);
            AddUserLeaveCommand(builder);
            AddUserLinkCommand(builder);
            
            CommandCreate build = builder.Build();
            DiscordCommandLocalization localization = builder.BuildCommandLocalization();
            
            TemplateKey template = new("User");
            _local.RegisterCommandLocalizationAsync(this, template, localization, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0)).Then(_ =>
            {
                _local.ApplyCommandLocalizationsAsync(this, build, template).Then(() =>
                {
                    Client.Bot.Application.CreateGlobalCommand(Client, build).Then(command =>
                    {
                        _appCommand = command;
                        CreateAllowedChannels(command);
                    });
                });
            });
        }
        
        public void AddUserCodeCommand(ApplicationCommandBuilder builder)
        {
            builder.AddSubCommand(UserAppCommands.CodeCommand, "Start the link between discord and the game server using a link code");
        }
        
        public void AddUserUserCommand(ApplicationCommandBuilder builder)
        {
            builder.AddSubCommand(UserAppCommands.UserCommand, "Start the link between discord and the game server by game server player name", sub =>
            {
                sub.AddOption(CommandOptionType.String, PlayerArg, "Player name on the game server",
                options => options.AutoComplete().Required());
            });
        }
        
        public void AddUserLeaveCommand(ApplicationCommandBuilder builder)
        {
            builder.AddSubCommand(UserAppCommands.LeaveCommand, "Unlink your discord and game server accounts");
        }
        
        public void AddUserLinkCommand(ApplicationCommandBuilder builder)
        {
            builder.AddSubCommand(UserAppCommands.LinkCommand, "Complete the link using the given link code", sub =>
            {
                sub.AddOption(CommandOptionType.String, CodeArg, "Code to complete the link",
                options => options.Required()
                .MinLength(_pluginConfig.LinkSettings.LinkCodeLength)
                .MaxLength(_pluginConfig.LinkSettings.LinkCodeLength));
            });
        }
        
        public void CreateAllowedChannels(DiscordApplicationCommand command)
        {
            timer.In(1f, () =>
            {
                command.GetPermissions(Client, Guild.Id)
                .Then(CreateAllowedChannels)
                .Catch<ResponseError>(error =>
                {
                    error.SuppressErrorMessage();
                });
            });
        }
        
        public void CreateAllowedChannels(GuildCommandPermissions permissions)
        {
            List<string> channels = new();
            for (int index = 0; index < permissions.Permissions.Count; index++)
            {
                CommandPermissions perm = permissions.Permissions[index];
                if (perm.Type == CommandPermissionType.Channel)
                {
                    string name = Guild.Channels[perm.Id]?.Name;
                    if (!string.IsNullOrEmpty(name))
                    {
                        channels.Add(name);
                    }
                }
            }
            
            _allowedChannels = string.Join(", ", channels);
            _placeholders.RegisterPlaceholder(this, PlaceholderKeys.CommandChannels, _allowedChannels);
        }
        
        // ReSharper disable once UnusedMember.Local
        // ReSharper disable once UnusedParameter.Local
        [DiscordApplicationCommand(UserAppCommands.Command, UserAppCommands.CodeCommand)]
        private void DiscordCodeCommand(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            DiscordUser user = interaction.User;
            if (user.IsLinked())
            {
                SendTemplateMessage(TemplateKeys.Errors.UserAlreadyLinked, interaction, GetDefault(user.Player, user));
                return;
            }
            
            JoinData join = _joinHandler.CreateActivation(user);
            SendTemplateMessage(TemplateKeys.Commands.Code.Success, interaction, GetDefault(user).Add(PlaceholderDataKeys.Code, join.Code));
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordApplicationCommand(UserAppCommands.Command, UserAppCommands.UserCommand)]
        private void DiscordUserCommand(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            DiscordUser user = interaction.User;
            if (user.IsLinked())
            {
                SendTemplateMessage(TemplateKeys.Errors.UserAlreadyLinked, interaction, GetDefault(user));
                return;
            }
            
            if (_banHandler.IsBanned(user))
            {
                SendTemplateMessage(TemplateKeys.Banned.PlayerBanned, interaction,GetDefault(user).AddTimestamp(_banHandler.GetBannedEndDate(user)));
                return;
            }
            
            string playerId = parsed.Args.GetString(PlayerArg);
            IPlayer player = covalence.Players.FindPlayerById(playerId);
            if (player == null)
            {
                SendTemplateMessage(TemplateKeys.Commands.User.Error.PlayerIsInvalid, interaction, GetDefault(user));
                return;
            }
            
            if (player.IsLinked())
            {
                SendTemplateMessage(TemplateKeys.Errors.PlayerAlreadyLinked, interaction, GetDefault(player, user));
                return;
            }
            
            if (!player.IsConnected)
            {
                SendTemplateMessage(TemplateKeys.Commands.User.Error.PlayerNotConnected, interaction, GetDefault(player, user));
                return;
            }
            
            _joinHandler.CreateActivation(player, user, JoinSource.Discord);
            
            using (PlaceholderData data = GetDefault(player, user))
            {
                data.ManualPool();
                Chat(player, ServerLang.Join.ByPlayer, data);
                SendTemplateMessage(TemplateKeys.Commands.User.Success, interaction, data);
            }
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordAutoCompleteCommand(UserAppCommands.Command, PlayerArg, UserAppCommands.UserCommand)]
        private void HandleNameAutoComplete(DiscordInteraction interaction, InteractionDataOption focused)
        {
            string search = focused.GetString();
            InteractionAutoCompleteBuilder response = interaction.GetAutoCompleteBuilder();
            response.AddAllOnlineFirstPlayers(search, PlayerNameFormatter.ClanName);
            interaction.CreateResponse(Client, response);
        }
        
        // ReSharper disable once UnusedMember.Local
        // ReSharper disable once UnusedParameter.Local
        [DiscordApplicationCommand(UserAppCommands.Command, UserAppCommands.LeaveCommand)]
        private void DiscordLeaveCommand(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            DiscordUser user = interaction.User;
            if (!user.IsLinked())
            {
                SendTemplateMessage(TemplateKeys.Commands.Leave.Error.UserNotLinked, interaction, GetDefault(user));
                return;
            }
            
            IPlayer player = user.Player;
            _linkHandler.HandleUnlink(player, user, UnlinkedReason.Command, interaction);
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordApplicationCommand(UserAppCommands.Command, UserAppCommands.LinkCommand)]
        private void DiscordLinkCommand(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            DiscordUser user = interaction.User;
            if (user.IsLinked())
            {
                SendTemplateMessage(TemplateKeys.Errors.UserAlreadyLinked, interaction, GetDefault(user.Player, user));
                return;
            }
            
            string code = parsed.Args.GetString(CodeArg);
            JoinData join = _joinHandler.FindByCode(code);
            if (join == null)
            {
                SendTemplateMessage(TemplateKeys.Errors.CodeActivationNotFound, interaction, GetDefault(user).Add(PlaceholderDataKeys.Code, code));
                return;
            }
            
            if (join.From == JoinSource.Discord)
            {
                SendTemplateMessage(TemplateKeys.Errors.MustBeCompletedInServer, interaction, GetDefault(user).Add(PlaceholderDataKeys.Code, code));
                return;
            }
            
            join.Discord = user;
            
            _joinHandler.CompleteLink(join, interaction);
        }
        #endregion

        #region Plugins\DiscordCore.MessageComponentCommands.cs
        private const string WelcomeMessageLinkAccountsButtonId = nameof(DiscordCore) + "_PmLinkAccounts";
        private const string GuildWelcomeMessageLinkAccountsButtonId = nameof(DiscordCore) + "_GuildLinkAccounts";
        private const string AcceptLinkButtonId = nameof(DiscordCore) + "_AcceptLink";
        private const string DeclineLinkButtonId = nameof(DiscordCore) + "_DeclineLink";
        
        // ReSharper disable once UnusedMember.Local
        [DiscordMessageComponentCommand(WelcomeMessageLinkAccountsButtonId)]
        private void HandleWelcomeMessageLinkAccounts(DiscordInteraction interaction)
        {
            DiscordUser user = interaction.User;
            if (user.IsLinked())
            {
                SendTemplateMessage(TemplateKeys.Errors.UserAlreadyLinked,interaction, GetDefault(user.Player, user));
                return;
            }
            
            JoinData join = _joinHandler.CreateActivation(user);
            SendTemplateMessage(TemplateKeys.Link.WelcomeMessage.DmLinkAccounts, interaction, GetDefault(user).Add(PlaceholderDataKeys.Code, join.Code));
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordMessageComponentCommand(GuildWelcomeMessageLinkAccountsButtonId)]
        private void HandleGuildWelcomeMessageLinkAccounts(DiscordInteraction interaction)
        {
            DiscordUser user = interaction.User;
            if (user.IsLinked())
            {
                SendTemplateMessage(TemplateKeys.Errors.UserAlreadyLinked, interaction, GetDefault(user.Player, user));
                return;
            }
            
            JoinData join = _joinHandler.CreateActivation(user);
            SendTemplateMessage(TemplateKeys.Link.WelcomeMessage.GuildLinkAccounts, interaction, GetDefault(user).Add(PlaceholderDataKeys.Code, join.Code));
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordMessageComponentCommand(AcceptLinkButtonId)]
        private void HandleAcceptLinkButton(DiscordInteraction interaction)
        {
            DiscordUser user = interaction.User;
            if (user.IsLinked())
            {
                SendTemplateMessage(TemplateKeys.Errors.UserAlreadyLinked, interaction, GetDefault(user.Player, user));
                return;
            }
            
            JoinData join = _joinHandler.FindCompletedByUser(user);
            if (join == null)
            {
                SendTemplateMessage(TemplateKeys.Errors.LookupActivationNotFound, interaction, GetDefault(user));
                return;
            }
            
            _joinHandler.CompleteLink(join, interaction);
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordMessageComponentCommand(DeclineLinkButtonId)]
        private void HandleDeclineLinkButton(DiscordInteraction interaction)
        {
            DiscordUser user = interaction.User;
            if (user.IsLinked())
            {
                SendTemplateMessage(TemplateKeys.Errors.UserAlreadyLinked, interaction, GetDefault(user.Player, user));
                return;
            }
            
            JoinData join = _joinHandler.FindCompletedByUser(user);
            if (join == null)
            {
                SendTemplateMessage(TemplateKeys.Errors.LookupActivationNotFound, interaction, GetDefault(user));
                return;
            }
            
            _joinHandler.DeclineLink(join, interaction);
        }
        #endregion

        #region Plugins\DiscordCore.AdminAppCommands.cs
        public void RegisterAdminApplicationCommands()
        {
            ApplicationCommandBuilder builder = new ApplicationCommandBuilder(AdminAppCommands.Command, "Discord Core Admin Commands", ApplicationCommandType.ChatInput)
            .AddDefaultPermissions(PermissionFlags.None);
            builder.AllowInDirectMessages(false);
            
            AddAdminLinkCommand(builder);
            AddAdminUnlinkCommand(builder);
            AddAdminSearchGroupCommand(builder);
            AddAdminUnbanGroupCommand(builder);
            
            CommandCreate build = builder.Build();
            DiscordCommandLocalization localization = builder.BuildCommandLocalization();
            
            TemplateKey template = new("Admin");
            _local.RegisterCommandLocalizationAsync(this, template, localization, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0)).Then(_ =>
            {
                _local.ApplyCommandLocalizationsAsync(this, build, template).Then(() =>
                {
                    Client.Bot.Application.CreateGlobalCommand(Client, build);
                });
            });
        }
        
        public void AddAdminLinkCommand(ApplicationCommandBuilder builder)
        {
            builder.AddSubCommand(AdminAppCommands.LinkCommand, "admin link player game account and Discord user", sub =>
            {
                sub.AddOption(CommandOptionType.String, PlayerArg, "player to link",
                options => options.AutoComplete().Required());
                
                sub.AddOption(CommandOptionType.User, UserArg, "user to link",
                options => options.Required());
            });
        }
        
        public void AddAdminUnlinkCommand(ApplicationCommandBuilder builder)
        {
            builder.AddSubCommand(AdminAppCommands.UnlinkCommand, "admin unlink player game account and Discord user", sub =>
            {
                sub.AddOption(CommandOptionType.String, PlayerArg, "player to unlink",
                options => options.AutoComplete());
                
                sub.AddOption(CommandOptionType.User, UserArg, "user to unlink");
            });
        }
        
        public void AddAdminSearchGroupCommand(ApplicationCommandBuilder builder)
        {
            builder.AddSubCommandGroup(AdminAppCommands.SearchCommand, "search linked accounts by discord or player", group =>
            {
                AddAdminSearchByPlayerCommand(group);
                AddAdminSearchByUserCommand(group);
            });
        }
        
        public void AddAdminSearchByPlayerCommand(ApplicationCommandGroupBuilder builder)
        {
            builder.AddSubCommand(AdminAppCommands.PlayerCommand, "search by player", sub =>
            {
                sub.AddOption(CommandOptionType.String, PlayerArg, "player to search",
                options => options.AutoComplete());
            });
        }
        
        public void AddAdminSearchByUserCommand(ApplicationCommandGroupBuilder builder)
        {
            builder.AddSubCommand(AdminAppCommands.UserCommand, "search by user", sub =>
            {
                sub.AddOption(CommandOptionType.User, UserArg, "user to search");
            });
        }
        
        public void AddAdminUnbanGroupCommand(ApplicationCommandBuilder builder)
        {
            builder.AddSubCommandGroup(AdminAppCommands.Unban, "unban player who is link banned", group =>
            {
                AddAdminUnbanByPlayerCommand(group);
                AddAdminUnbanByUserCommand(group);
            });
        }
        
        public void AddAdminUnbanByPlayerCommand(ApplicationCommandGroupBuilder builder)
        {
            builder.AddSubCommand(AdminAppCommands.PlayerCommand, "unban by player", sub =>
            {
                sub.AddOption(CommandOptionType.String, PlayerArg, "player to unban",
                options => options.AutoComplete());
            });
        }
        
        public void AddAdminUnbanByUserCommand(ApplicationCommandGroupBuilder builder)
        {
            builder.AddSubCommand(AdminAppCommands.UserCommand, "unban by user", sub =>
            {
                sub.AddOption(CommandOptionType.User, UserArg, "user to unban");
            });
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordApplicationCommand(AdminAppCommands.Command, AdminAppCommands.LinkCommand)]
        private void DiscordAdminLinkCommand(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            string playerId = parsed.Args.GetString(PlayerArg);
            DiscordUser user = parsed.Args.GetUser(UserArg);
            IPlayer player = players.FindPlayerById(playerId);
            if (player == null)
            {
                SendTemplateMessage(TemplateKeys.Commands.Admin.Link.Error.PlayerNotFound, interaction, GetDefault(ServerPlayerCache.Instance.GetPlayerById(playerId), user));
                return;
            }
            
            if (player.IsLinked())
            {
                SendTemplateMessage(TemplateKeys.Commands.Admin.Link.Error.PlayerAlreadyLinked, interaction, GetDefault(player, user));
                return;
            }
            
            if (user.IsLinked())
            {
                SendTemplateMessage(TemplateKeys.Commands.Admin.Link.Error.UserAlreadyLinked, interaction, GetDefault(player, user));
                return;
            }
            
            _linkHandler.HandleLink(player, user, LinkReason.Admin, null);
            SendTemplateMessage(TemplateKeys.Commands.Admin.Link.Success, interaction, GetDefault(player, user));
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordApplicationCommand(AdminAppCommands.Command, AdminAppCommands.UnlinkCommand)]
        private void DiscordAdminUnlinkCommand(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            string playerId = parsed.Args.GetString(PlayerArg);
            IPlayer player = players.FindPlayerById(playerId);
            DiscordUser user = parsed.Args.GetUser(UserArg);
            
            if (player == null && user == null)
            {
                SendTemplateMessage(TemplateKeys.Commands.Admin.Unlink.Error.MustSpecifyOne, interaction, GetDefault(ServerPlayerCache.Instance.GetPlayerById(playerId)));
                return;
            }
            
            bool isPlayerLinked = player?.IsLinked() ?? false;
            bool isUserLinked = user?.IsLinked() ?? false;
            
            if (player != null && !isPlayerLinked)
            {
                SendTemplateMessage(TemplateKeys.Commands.Admin.Unlink.Error.PlayerIsNotLinked, interaction, GetDefault(player));
                return;
            }
            
            if (user != null && !isUserLinked)
            {
                SendTemplateMessage(TemplateKeys.Commands.Admin.Unlink.Error.UserIsNotLinked, interaction, GetDefault(user));
                return;
            }
            
            DiscordUser linkedUser = player.GetDiscordUser();
            if (player != null && user != null && linkedUser.Id != user.Id)
            {
                IPlayer otherPlayer = user.Player;
                SendTemplateMessage(TemplateKeys.Commands.Admin.Unlink.Error.LinkNotSame, interaction, GetDefault(player, user).AddTarget(otherPlayer).AddUserTarget(linkedUser));
                return;
            }
            
            if (player != null && user == null)
            {
                user = player.GetDiscordUser();
            }
            else if (user != null && player == null)
            {
                player = user.Player;
            }
            
            _linkHandler.HandleUnlink(player, user, UnlinkedReason.Admin, null);
            SendTemplateMessage(TemplateKeys.Commands.Admin.Unlink.Success, interaction, GetDefault(player, user));
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordApplicationCommand(AdminAppCommands.Command, AdminAppCommands.PlayerCommand, AdminAppCommands.SearchCommand)]
        private void DiscordAdminSearchByPlayer(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            string playerId = parsed.Args.GetString(PlayerArg);
            IPlayer player = !string.IsNullOrEmpty(playerId) ? players.FindPlayerById(playerId) : null;
            if (player == null)
            {
                SendTemplateMessage(TemplateKeys.Commands.Admin.Search.Error.PlayerNotFound, interaction, GetDefault().Add(PlaceholderDataKeys.NotFound, playerId));
                return;
            }
            
            DiscordUser user = player.GetDiscordUser();
            SendTemplateMessage(TemplateKeys.Commands.Admin.Search.Success, interaction, GetDefault(player, user));
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordApplicationCommand(AdminAppCommands.Command, AdminAppCommands.UserCommand, AdminAppCommands.Unban)]
        private void DiscordAdminUnbanByUser(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            DiscordUser user = parsed.Args.GetUser(UserArg);
            if (!_banHandler.Unban(user))
            {
                SendTemplateMessage(TemplateKeys.Commands.Admin.Unban.Error.UserNotBanned, interaction, GetDefault(user));
                return;
            }
            
            SendTemplateMessage(TemplateKeys.Commands.Admin.Unban.User, interaction, GetDefault(user));
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordApplicationCommand(AdminAppCommands.Command, AdminAppCommands.PlayerCommand, AdminAppCommands.Unban)]
        private void DiscordAdminUnbanByPlayer(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            string playerId = parsed.Args.GetString(PlayerArg);
            IPlayer player = !string.IsNullOrEmpty(playerId) ? players.FindPlayerById(playerId) : null;
            if (player == null)
            {
                SendTemplateMessage(TemplateKeys.Commands.Admin.Unban.Error.PlayerNotFound, interaction, GetDefault().Add(PlaceholderDataKeys.NotFound, playerId));
                return;
            }
            
            if (!_banHandler.Unban(player))
            {
                SendTemplateMessage(TemplateKeys.Commands.Admin.Unban.Error.PlayerNotBanned, interaction, GetDefault(player));
                return;
            }
            
            SendTemplateMessage(TemplateKeys.Commands.Admin.Unban.Player, interaction, GetDefault(player));
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordApplicationCommand(AdminAppCommands.Command, AdminAppCommands.UserCommand, AdminAppCommands.SearchCommand)]
        private void DiscordAdminSearchByUser(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            DiscordUser user = parsed.Args.GetUser(UserArg);
            IPlayer player = user.Player;
            SendTemplateMessage(TemplateKeys.Commands.Admin.Search.Success, interaction, GetDefault(player, user));
        }
        
        // ReSharper disable once UnusedMember.Local
        [DiscordAutoCompleteCommand(AdminAppCommands.Command, PlayerArg, AdminAppCommands.PlayerCommand, AdminAppCommands.Unban)]
        [DiscordAutoCompleteCommand(AdminAppCommands.Command, PlayerArg, AdminAppCommands.PlayerCommand, AdminAppCommands.SearchCommand)]
        [DiscordAutoCompleteCommand(AdminAppCommands.Command, PlayerArg, AdminAppCommands.LinkCommand)]
        [DiscordAutoCompleteCommand(AdminAppCommands.Command, PlayerArg, AdminAppCommands.UnlinkCommand)]
        private void HandleAdminNameAutoComplete(DiscordInteraction interaction, InteractionDataOption focused)
        {
            string search = focused.GetString();
            //Puts($"HandleAdminNameAutoComplete - {search}");
            InteractionAutoCompleteBuilder response = interaction.GetAutoCompleteBuilder();
            response.AddAllOnlineFirstPlayers(search, PlayerNameFormatter.All);
            interaction.CreateResponse(Client, response);
        }
        #endregion

        #region Plugins\DiscordCore.Templates.cs
        private const string AcceptEmoji = "â";
        private const string DeclineEmoji = "â";
        
        public void RegisterTemplates()
        {
            RegisterAnnouncements();
            RegisterWelcomeMessages();
            RegisterCommandMessages();
            RegisterAdminCommandMessages();
            RegisterLinkMessages();
            RegisterBanMessages();
            RegisterJoinMessages();
            RegisterErrorMessages();
        }
        
        public void RegisterAnnouncements()
        {
            DiscordMessageTemplate linkCommand = CreateTemplateEmbed($"Player {DefaultKeys.Player.NamePlayerId} has {DiscordFormatting.Bold("linked")} with discord {DefaultKeys.User.Mention}", DiscordColor.Success);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Announcements.Link.Command, linkCommand, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate linkAdmin = CreateTemplateEmbed($"Player {DefaultKeys.Player.NamePlayerId} was {DiscordFormatting.Bold("linked")} with discord {DefaultKeys.User.Mention} by an admin", DiscordColor.Success);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Announcements.Link.Admin, linkAdmin, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate linkApi = CreateTemplateEmbed($"Player {DefaultKeys.Player.NamePlayerId} has {DiscordFormatting.Bold("linked")} with discord {DefaultKeys.User.Mention}", DiscordColor.Success);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Announcements.Link.Api, linkApi, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate linkGuildRejoin = CreateTemplateEmbed($"Player {DefaultKeys.Player.NamePlayerId} has {DiscordFormatting.Bold("linked")} with discord {DefaultKeys.User.Mention} because they rejoined the {DiscordFormatting.Bold(DefaultKeys.Guild.Name)} Discord server", DiscordColor.Success);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Announcements.Link.GuildRejoin, linkGuildRejoin, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate linkInactiveRejoin = CreateTemplateEmbed($"Player {DefaultKeys.Player.NamePlayerId} has {DiscordFormatting.Bold("linked")} with discord {DefaultKeys.User.Mention} because they rejoined the {DiscordFormatting.Bold(DefaultKeys.Server.Name)} game server", DiscordColor.Success);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Announcements.Link.InactiveRejoin, linkInactiveRejoin, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unlinkCommand = CreateTemplateEmbed($"Player {DefaultKeys.Player.NamePlayerId} has {DiscordFormatting.Bold("unlinked")} from discord {DefaultKeys.User.Mention}", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Announcements.Unlink.Command, unlinkCommand, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unlinkAdmin = CreateTemplateEmbed($"Player {DefaultKeys.Player.NamePlayerId} was {DiscordFormatting.Bold("unlinked")} from discord {DefaultKeys.User.Mention} by an admin", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Announcements.Unlink.Admin, unlinkAdmin, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unlinkApi = CreateTemplateEmbed($"Player {DefaultKeys.Player.NamePlayerId}has {DiscordFormatting.Bold("unlinked")} from discord {DefaultKeys.User.Mention}", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Announcements.Unlink.Api, unlinkApi, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unlinkLeftGuild = CreateTemplateEmbed($"Player {DefaultKeys.Player.NamePlayerId} has {DiscordFormatting.Bold("unlinked")} from discord {DefaultKeys.User.Fullname}({DefaultKeys.User.Id}) because they left the {DiscordFormatting.Bold(DefaultKeys.Guild.Name)} Discord server", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Announcements.Unlink.LeftGuild, unlinkLeftGuild, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unlinkInactive = CreateTemplateEmbed($"Player {DefaultKeys.Player.NamePlayerId} has {DiscordFormatting.Bold("unlinked")} from discord {DefaultKeys.User.Fullname}({DefaultKeys.User.Id}) because they were inactive since {DefaultKeys.Timestamp.LongDateTime}", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Announcements.Unlink.Inactive, unlinkInactive, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate playerBanned = CreateTemplateEmbed($"Player {DefaultKeys.Player.NamePlayerId} has been linked banned for too many declined link attempts. The players ban will end on {DefaultKeys.Timestamp.LongDateTime}.", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Announcements.Ban.PlayerBanned, playerBanned, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate userBanned = CreateTemplateEmbed($"User {DefaultKeys.User.Mention} has been linked banned for too many declined link attempts. The players ban will end on {DefaultKeys.Timestamp.LongDateTime}.", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Announcements.Ban.UserBanned, userBanned, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
        }
        
        public void RegisterWelcomeMessages()
        {
            DiscordMessageTemplate pmWelcomeMessage = CreateTemplateEmbed($"Welcome to the {DiscordFormatting.Bold(DefaultKeys.Guild.Name)} Discord server. " +
            $"If you would like to link your player and Discord accounts please click on the {DiscordFormatting.Bold("Link Accounts")} button below to start the process." +
            $"{DiscordFormatting.Underline("\nNote: You must be in game to complete the link.")}", DiscordColor.Success);
            pmWelcomeMessage.Components = new List<BaseComponentTemplate>
            {
                new ButtonTemplate("Link Accounts", ButtonStyle.Success, WelcomeMessageLinkAccountsButtonId, AcceptEmoji)
            };
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.WelcomeMessage.PmWelcomeMessage, pmWelcomeMessage, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate guildWelcomeMessage = CreateTemplateEmbed($"Welcome to the {DiscordFormatting.Bold(DefaultKeys.Guild.Name)} Discord server. " +
            "This server supports linking your Discord and in game accounts. " +
            $"If you would like to link your player and Discord accounts please click on the {DiscordFormatting.Bold("Link Accounts")} button below to start the process." +
            $"{DiscordFormatting.Underline("\nNote: You must be in game to complete the link.")}", DiscordColor.Success);
            guildWelcomeMessage.Components = new List<BaseComponentTemplate>
            {
                new ButtonTemplate("Link Accounts", ButtonStyle.Success, GuildWelcomeMessageLinkAccountsButtonId, AcceptEmoji)
            };
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.WelcomeMessage.GuildWelcomeMessage, guildWelcomeMessage, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate welcomeMessageAlreadyLinked = CreateTemplateEmbed($"You are unable to link your {DefaultKeys.User.Mention} Discord user because you're already linked to {DefaultKeys.Player.Name}", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.WelcomeMessage.Error.AlreadyLinked, welcomeMessageAlreadyLinked, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
        }
        
        public void RegisterCommandMessages()
        {
            DiscordMessageTemplate codeSuccess = CreateTemplateEmbed($"Please join the {DiscordFormatting.Bold(DefaultKeys.Server.Name)} game server and type {DiscordFormatting.Bold($"/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.LinkCommand)} {PlaceholderKeys.LinkCode}")} in server chat.", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Code.Success, codeSuccess, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate userSuccess = CreateTemplateEmbed($"We have sent a message to {DiscordFormatting.Bold(DefaultKeys.Player.Name)} on the {DiscordFormatting.Bold(DefaultKeys.Server.Name)} server. Please follow the directions to complete your link.", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.User.Success, userSuccess, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate userInvalidPlayer = CreateTemplateEmbed($"You have not selected a valid player from the dropdown. Please try the command again.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.User.Error.PlayerIsInvalid, userInvalidPlayer, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate userNotConnected = CreateTemplateEmbed($"Player {DiscordFormatting.Bold(DefaultKeys.Player.Name)} is not connected to the {DiscordFormatting.Bold(DefaultKeys.Server.Name)} server. Please join the server and try the command again.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.User.Error.PlayerNotConnected, userNotConnected, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate leaveNotLinked = CreateTemplateEmbed($"You are not able to unlink because you are not currently linked.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Leave.Error.UserNotLinked, leaveNotLinked, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
        }
        
        public void RegisterAdminCommandMessages()
        {
            DiscordMessageTemplate playerNotFound = CreateTemplateEmbed($"Failed to link. Player with '{DiscordFormatting.Bold(DefaultKeys.Player.Name)}' ID was not found.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Link.Error.PlayerNotFound, playerNotFound, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate playerAlreadyLinked = CreateTemplateEmbed($"Failed to link. Player '{DiscordFormatting.Bold($"{DefaultKeys.Player.NamePlayerId}")}' is already linked to {DefaultKeys.User.Mention}. If you would like to link this player please unlink first.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Link.Error.PlayerAlreadyLinked, playerAlreadyLinked, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate userAlreadyLinked = CreateTemplateEmbed($"Failed to link. User {DefaultKeys.User.Mention} is already linked to {DefaultKeys.Player.NamePlayerId}. If you would like to link this user please unlink them first.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Link.Error.UserAlreadyLinked, userAlreadyLinked, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate adminLinkSuccess = CreateTemplateEmbed($"You have successfully linked Player '{DiscordFormatting.Bold($"{DefaultKeys.Player.NamePlayerId}")}' to {DefaultKeys.User.Mention}", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Link.Success, adminLinkSuccess, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unlinkMustSpecify = CreateTemplateEmbed($"Failed to unlink. You must specify either player or user or both.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Unlink.Error.MustSpecifyOne, unlinkMustSpecify, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unlinkPlayerNotLinked = CreateTemplateEmbed($"Failed to unlink.'{DiscordFormatting.Bold($"{DefaultKeys.Player.NamePlayerId}")}' is not linked.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Unlink.Error.PlayerIsNotLinked, unlinkPlayerNotLinked, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unlinkUserNotLinked = CreateTemplateEmbed($"Failed to unlink. {DefaultKeys.User.Mention} is not linked.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Unlink.Error.UserIsNotLinked, unlinkUserNotLinked, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unlinkNotSame = CreateTemplateEmbed($"Failed to unlink. The specified player and user are not linked to each other.\n" +
            $"Player '{DiscordFormatting.Bold($"{DefaultKeys.Player.NamePlayerId}")}' is linked to {DefaultKeys.UserTarget.Mention}.\n" +
            $"User {DefaultKeys.User.Mention} is linked to '{DiscordFormatting.Bold($"{DefaultKeys.PlayerTarget.Name}({DefaultKeys.PlayerTarget.Id})")}'", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Unlink.Error.LinkNotSame, unlinkNotSame, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate adminUnlinkSuccess = CreateTemplateEmbed($"You have successfully unlink Player '{DiscordFormatting.Bold($"{DefaultKeys.Player.NamePlayerId}")}' from {DefaultKeys.User.Mention}", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Unlink.Success, adminUnlinkSuccess, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate playerUnbanSuccess = CreateTemplateEmbed($"You have successfully unbanned Player '{DiscordFormatting.Bold($"{DefaultKeys.Player.NamePlayerId}")}'. The player can now link again.", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Unban.Player, playerUnbanSuccess, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate userUnbanSuccess = CreateTemplateEmbed($"You have successfully unbanned User {DefaultKeys.User.Mention}. The user can now link again.", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Unban.User, userUnbanSuccess, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate playerUnbanNotFound = CreateTemplateEmbed($"Failed to find Player with '{DiscordFormatting.Bold(PlaceholderKeys.NotFound)}' ID", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Unban.Error.PlayerNotFound, playerUnbanNotFound, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate playerUnbanNotBanned = CreateTemplateEmbed($"Failed to find unban player '{DiscordFormatting.Bold(DefaultKeys.Player.NamePlayerId)}' because they are not banned", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Unban.Error.PlayerNotBanned, playerUnbanNotBanned, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate userUnbanNotBanned = CreateTemplateEmbed($"Failed to find unban user {DefaultKeys.User.Mention} because they are not banned", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Unban.Error.UserNotBanned, userUnbanNotBanned, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate playerSearchNotFound = CreateTemplateEmbed($"Failed to find Player with '{DiscordFormatting.Bold(PlaceholderKeys.NotFound)}' ID", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Search.Error.PlayerNotFound, playerSearchNotFound, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate searchSuccess = new()
            {
                Embeds = new List<DiscordEmbedTemplate>
                {
                    new()
                    {
                        Color = DiscordColor.Danger.ToHex(),
                        Fields =
                        {
                            new DiscordEmbedFieldTemplate("Player", DefaultKeys.Player.NameClan),
                            new DiscordEmbedFieldTemplate("Player ID", DefaultKeys.Player.Id),
                            new DiscordEmbedFieldTemplate("User", DefaultKeys.User.Fullname),
                            new DiscordEmbedFieldTemplate("Is Linked", DefaultKeys.Player.IsLinked),
                        }
                    }
                },
                Components =
                {
                    new ButtonTemplate("Steam Profile", ButtonStyle.Link, DefaultKeys.Player.SteamProfile),
                    new ButtonTemplate("BattleMetrics Profile", ButtonStyle.Link, DefaultKeys.Player.BattleMetricsPlayerId),
                    new ButtonTemplate("Server Armor", ButtonStyle.Link, DefaultKeys.Player.ServerArmorProfile),
                }
            };
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Admin.Search.Success, searchSuccess, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
        }
        
        public void RegisterLinkMessages()
        {
            DiscordMessageTemplate linkCommand = CreateTemplateEmbed($"You have successfully linked {DiscordFormatting.Bold(DefaultKeys.Player.Name)} with your Discord user {DefaultKeys.User.Mention}", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Link.Completed.Command, linkCommand, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate linkAdmin = CreateTemplateEmbed($"You have been successfully linked with {DiscordFormatting.Bold(DefaultKeys.Player.Name)} and Discord user {DefaultKeys.User.Mention} by an admin", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Link.Completed.Admin, linkAdmin, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate linkApi = CreateTemplateEmbed($"You have successfully linked {DiscordFormatting.Bold(DefaultKeys.Player.Name)} with your Discord user {DefaultKeys.User.Mention}", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Link.Completed.Api, linkApi, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate linkRejoin = CreateTemplateEmbed($"Your {DiscordFormatting.Bold(DefaultKeys.Player.Name)} game account has been relinked with your Discord user {DefaultKeys.User.Mention} because you rejoined the {DiscordFormatting.Bold(DefaultKeys.Guild.Name)} Discord server", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Link.Completed.GuildRejoin, linkRejoin, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate linkInactive = CreateTemplateEmbed($"Your {DiscordFormatting.Bold(DefaultKeys.Player.Name)} game account has been relinked with your Discord user {DefaultKeys.User.Mention} because you rejoined the {DiscordFormatting.Bold(DefaultKeys.Server.Name)} game server", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Link.Completed.InactiveRejoin, linkInactive, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unlinkCommand = CreateTemplateEmbed($"You have successfully unlinked {DiscordFormatting.Bold(DefaultKeys.Player.Name)} from your Discord user {DefaultKeys.User.Mention}", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Unlink.Completed.Command, unlinkCommand, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unlinkAdmin = CreateTemplateEmbed($"You have successfully been unlinked {DiscordFormatting.Bold(DefaultKeys.Player.Name)} from your Discord user {DefaultKeys.User.Mention} by an admin", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Unlink.Completed.Admin, unlinkAdmin, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unlinkApi = CreateTemplateEmbed($"You have successfully unlinked {DiscordFormatting.Bold(DefaultKeys.Player.Name)} from your Discord user {DefaultKeys.User.Mention}", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Unlink.Completed.Api, unlinkApi, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate unlinkInactive = CreateTemplateEmbed($"You have been successfully unlinked from {DiscordFormatting.Bold(DefaultKeys.Player.Name)} and Discord user {DefaultKeys.User.Mention} because you have been inactive since {DefaultKeys.Timestamp.LongDateTime}", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Unlink.Completed.Inactive, unlinkInactive, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate declineUser = CreateTemplateEmbed($"We have successfully declined the link request from {DefaultKeys.Player.Name}. We're sorry for the inconvenience.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Link.Declined.JoinWithUser, declineUser, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate declinePlayer = CreateTemplateEmbed($"{DefaultKeys.Player.Name} has declined your link request. Repeated declined attempts may result in a link ban.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Link.Declined.JoinWithPlayer, declinePlayer, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate dmLinkAccounts = CreateTemplateEmbed($"To complete the link process please join the {DiscordFormatting.Bold(DefaultKeys.Server.Name)} game server and type {DiscordFormatting.Bold($"/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.LinkCommand)} {PlaceholderKeys.LinkCode}")} in server chat.", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Link.WelcomeMessage.DmLinkAccounts, dmLinkAccounts, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate guildLinkAccounts = CreateTemplateEmbed($"To complete the link process please join the {DiscordFormatting.Bold(DefaultKeys.Server.Name)} game server and type {DiscordFormatting.Bold($"/{DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.DcCommand)} {DefaultKeys.Plugin.Lang.WithFormat(ServerLang.Commands.LinkCommand)} {PlaceholderKeys.LinkCode}")} in server chat.", DiscordColor.Success);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Link.WelcomeMessage.GuildLinkAccounts, guildLinkAccounts, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
        }
        
        public void RegisterBanMessages()
        {
            DiscordMessageTemplate banned = CreateTemplateEmbed($"You have been banned from making any more player link requests for until {DefaultKeys.Timestamp.LongDateTime} due to multiple declined requests.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Banned.PlayerBanned, banned, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
        }
        
        public void RegisterJoinMessages()
        {
            DiscordMessageTemplate byUsername = CreateTemplateEmbed($"The player {DiscordFormatting.Bold(DefaultKeys.Player.Name)} is trying to link their game account to this discord user.\n" +
            $"If you would like to accept please click on the {DiscordFormatting.Bold("Accept")} button.\n" +
            $"If you did not initiate this link please click on the {DiscordFormatting.Bold("Decline")} button", DiscordColor.Success);
            byUsername.Components = new List<BaseComponentTemplate>
            {
                new ButtonTemplate("Accept", ButtonStyle.Success, AcceptLinkButtonId, AcceptEmoji),
                new ButtonTemplate("Decline", ButtonStyle.Danger, DeclineLinkButtonId, DeclineEmoji)
            };
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Join.CompleteLink, byUsername, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
        }
        
        public void RegisterErrorMessages()
        {
            DiscordMessageTemplate userAlreadyLinked = CreateTemplateEmbed($"You are unable to link because you are already linked to player {DiscordFormatting.Bold(DefaultKeys.Player.Name)}", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.UserAlreadyLinked, userAlreadyLinked, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate playerAlreadyLinked = CreateTemplateEmbed($"You are unable to link to player {DiscordFormatting.Bold(DefaultKeys.Player.Name)} because they are already linked", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.PlayerAlreadyLinked, playerAlreadyLinked, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate codeActivationNotFound = CreateTemplateEmbed($"We failed to find a pending link activation for the code {DiscordFormatting.Bold(PlaceholderKeys.LinkCode.Placeholder)}. Please confirm you have the correct code and try again.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.CodeActivationNotFound, codeActivationNotFound, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate lookupActivationNotFound = CreateTemplateEmbed($"We failed to find a pending link activation for user {DiscordFormatting.Bold(DefaultKeys.User.Fullname)}. Please confirm you have started that activation from the game server for this user.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.LookupActivationNotFound, lookupActivationNotFound, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate mustBeCompletedInServer = CreateTemplateEmbed($"The link must be completed on the game server. Please join the server and use the command in came to complete the link.", DiscordColor.Danger);
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.MustBeCompletedInServer, mustBeCompletedInServer, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
        }
        
        public DiscordMessageTemplate CreateTemplateEmbed(string description, DiscordColor color)
        {
            return new DiscordMessageTemplate
            {
                Embeds = new List<DiscordEmbedTemplate>
                {
                    new()
                    {
                        Description = $"[{DefaultKeys.Plugin.Title}] {description}",
                        Color = color.ToHex()
                    }
                }
            };
        }
        
        public void SendTemplateMessage(TemplateKey templateName, DiscordInteraction interaction, PlaceholderData placeholders = null)
        {
            InteractionCallbackData response = new()
            {
                AllowedMentions = AllowedMentions.None
            };
            if (interaction.GuildId.HasValue)
            {
                response.Flags = MessageFlags.Ephemeral;
            }
            
            interaction.CreateTemplateResponse(Client, InteractionResponseType.ChannelMessageWithSource, templateName, response, placeholders);
        }
        
        public void SendTemplateMessage(TemplateKey templateName, DiscordUser user, IPlayer player = null, PlaceholderData placeholders = null)
        {
            AddDefaultPlaceholders(ref placeholders, user, player);
            user.SendTemplateDirectMessage(Client, templateName, _lang.GetPlayerLanguage(player).Id, new MessageCreate
            {
                AllowedMentions = AllowedMentions.None
            }, placeholders);
        }
        
        public void SendGlobalTemplateMessage(TemplateKey templateName, DiscordUser user, IPlayer player = null, PlaceholderData placeholders = null)
        {
            AddDefaultPlaceholders(ref placeholders, user, player);
            user.SendGlobalTemplateDirectMessage(Client, templateName, new MessageCreate
            {
                AllowedMentions = AllowedMentions.None
            }, placeholders);
        }
        
        public IPromise<DiscordMessage> SendGlobalTemplateMessage(TemplateKey templateName, Snowflake channelId, DiscordUser user = null, IPlayer player = null, PlaceholderData placeholders = null)
        {
            DiscordChannel channel = Guild.Channels[channelId];
            if (channel != null)
            {
                AddDefaultPlaceholders(ref placeholders, user, player);
                return channel.CreateGlobalTemplateMessage(Client, templateName, new MessageCreate
                {
                    AllowedMentions = AllowedMentions.None
                }, placeholders);
            }
            
            return Promise<DiscordMessage>.Rejected(new Exception("Channel Not Found"));
        }
        
        public void UpdateGuildTemplateMessage(TemplateKey templateName, DiscordMessage message, PlaceholderData placeholders = null)
        {
            AddDefaultPlaceholders(ref placeholders, null, null);
            message.EditGlobalTemplateMessage(Client, templateName, placeholders);
        }
        
        private void AddDefaultPlaceholders(ref PlaceholderData placeholders, DiscordUser user, IPlayer player)
        {
            placeholders = placeholders ?? GetDefault();
            placeholders.AddUser(user).AddPlayer(player).AddGuild(Guild);
        }
        #endregion

        #region Plugins\DiscordCore.Placeholders.cs
        public void RegisterPlaceholders()
        {
            if (!string.IsNullOrEmpty(_pluginConfig.ServerNameOverride))
            {
                _placeholders.RegisterPlaceholder(this, new PlaceholderKey("guild.name"), _pluginConfig.ServerNameOverride);
            }
            
            _placeholders.RegisterPlaceholder(this, PlaceholderKeys.InviteUrl, _pluginConfig.InviteUrl);
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.LinkCode, PlaceholderDataKeys.Code);
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.NotFound, PlaceholderDataKeys.NotFound);
        }
        
        public string LangPlaceholder(string key, PlaceholderData data)
        {
            return _placeholders.ProcessPlaceholders(Lang(key), data);
        }
        
        public PlaceholderData GetDefault()
        {
            return _placeholders.CreateData(this).AddGuild(Guild);
        }
        
        public PlaceholderData GetDefault(IPlayer player)
        {
            return GetDefault().AddPlayer(player);
        }
        
        public PlaceholderData GetDefault(DiscordUser user)
        {
            return GetDefault().AddUser(user);
        }
        
        public PlaceholderData GetDefault(IPlayer player, DiscordUser user)
        {
            return GetDefault(player).AddUser(user);
        }
        #endregion

        #region Plugins\DiscordCore.Link.cs
        public IDictionary<PlayerId, Snowflake> GetPlayerIdToDiscordIds()
        {
            Hash<PlayerId, Snowflake> data = new();
            foreach (DiscordInfo info in _pluginData.PlayerDiscordInfo.Values)
            {
                data[new PlayerId(info.PlayerId)] = info.DiscordId;
            }
            
            return data;
        }
        #endregion

        #region Plugins\DiscordCore.API.cs
        // ReSharper disable once UnusedMember.Local
        private string API_Link(IPlayer player, DiscordUser user)
        {
            if (player.IsLinked())
            {
                return ApiErrorCodes.PlayerIsLinked;
            }
            
            if (user.IsLinked())
            {
                return  ApiErrorCodes.UserIsLinked;
            }
            
            _linkHandler.HandleLink(player, user, LinkReason.Api, null);
            return null;
        }
        
        // ReSharper disable once UnusedMember.Local
        private string API_Unlink(IPlayer player, DiscordUser user)
        {
            if (!player.IsLinked())
            {
                return  ApiErrorCodes.PlayerIsNotLinked;
            }
            
            if (!user.IsLinked())
            {
                return ApiErrorCodes.UserIsNotLinked;
            }
            
            _linkHandler.HandleUnlink(player, user, UnlinkedReason.Api, null);
            return null;
        }
        #endregion

        #region Plugins\DiscordCore.Helpers.cs
        public void SaveData()
        {
            if (_pluginData != null)
            {
                Interface.Oxide.DataFileSystem.WriteObject(Name, _pluginData);
            }
        }
        #endregion

        #region Plugins\DiscordCore.DiscordSetup.cs
        //Define:FileOrder=25
        public void SetupGuildWelcomeMessage()
        {
            GuildMessageSettings settings = _pluginConfig.LinkMessageSettings;
            if (!settings.Enabled)
            {
                return;
            }
            
            if (!settings.ChannelId.IsValid())
            {
                PrintWarning("Link message is enabled but link message channel ID is not valid");
                return;
            }
            
            DiscordChannel channel = Guild.Channels[settings.ChannelId];
            if (channel == null)
            {
                PrintWarning($"Link message failed to find channel with ID {settings.ChannelId}");
                return;
            }
            
            if (_pluginData.MessageData == null)
            {
                CreateGuildWelcomeMessage(settings);
                return;
            }
            
            channel.GetMessage(Client, _pluginData.MessageData.MessageId).Then(message =>
            {
                UpdateGuildTemplateMessage(TemplateKeys.WelcomeMessage.GuildWelcomeMessage, message);
            }).Catch<ResponseError>(error =>
            {
                if (error.HttpStatusCode == DiscordHttpStatusCode.NotFound)
                {
                    error.SuppressErrorMessage();
                    PrintWarning("The previous link message has been removed. Recreating the message.");
                    CreateGuildWelcomeMessage(settings);
                }
            });
        }
        
        private void CreateGuildWelcomeMessage(GuildMessageSettings settings)
        {
            SendGlobalTemplateMessage(TemplateKeys.WelcomeMessage.GuildWelcomeMessage, settings.ChannelId).Then(message =>
            {
                _pluginData.MessageData = new LinkMessageData(message.ChannelId, message.Id);
            });
        }
        #endregion

        #region Api\ApiErrorCodes.cs
        public static class ApiErrorCodes
        {
            public const string PlayerIsLinked = "Error.Player.IsLinked";
            public const string PlayerIsNotLinked = "Error.Player.IsNotLinked";
            public const string UserIsLinked = "Error.User.IsLinked";
            public const string UserIsNotLinked = "Error.User.IsNotLinked";
        }
        #endregion

        #region AppCommands\AdminAppCommands.cs
        public static class AdminAppCommands
        {
            public const string Command = "dca";
            public const string LinkCommand = "link";
            public const string UnlinkCommand = "unlink";
            public const string SearchCommand = "search";
            public const string PlayerCommand = "player";
            public const string UserCommand = "user";
            public const string Unban = "unban";
        }
        #endregion

        #region AppCommands\UserAppCommands.cs
        public static class UserAppCommands
        {
            public const string Command = "dc";
            public const string CodeCommand = "code";
            public const string UserCommand = "user";
            public const string LeaveCommand = "leave";
            public const string LinkCommand = "link";
        }
        #endregion

        #region Configuration\GuildMessageSettings.cs
        public class GuildMessageSettings
        {
            [JsonProperty(PropertyName = "Enable Guild Link Message")]
            public bool Enabled { get; set; }
            
            [JsonProperty(PropertyName = "Message Channel ID")]
            public Snowflake ChannelId { get; set; }
            
            public GuildMessageSettings(GuildMessageSettings settings)
            {
                Enabled = settings?.Enabled ?? false;
                ChannelId = settings?.ChannelId ?? default(Snowflake);
            }
        }
        #endregion

        #region Configuration\InactiveSettings.cs
        public class InactiveSettings
        {
            [JsonProperty(PropertyName = "Automatically Unlink Inactive Players")]
            public bool UnlinkInactive { get; set; }
            
            [JsonProperty(PropertyName = "Player Considered Inactive After X (Days)")]
            public float UnlinkInactiveDays { get; set; }
            
            [JsonProperty(PropertyName = "Automatically Relink Inactive Players On Game Server Join")]
            public bool AutoRelinkInactive { get; set; }
            
            public InactiveSettings(InactiveSettings settings)
            {
                UnlinkInactive = settings?.UnlinkInactive ?? false;
                UnlinkInactiveDays = settings?.UnlinkInactiveDays ?? 90;
                AutoRelinkInactive = settings?.AutoRelinkInactive ?? true;
            }
        }
        #endregion

        #region Configuration\LinkBanSettings.cs
        public class LinkBanSettings
        {
            [JsonProperty(PropertyName = "Enable Link Ban")]
            public bool EnableLinkBanning { get; set; }
            
            [JsonProperty(PropertyName = "Ban Announcement Channel ID")]
            public Snowflake BanAnnouncementChannel { get; set; }
            
            [JsonProperty(PropertyName = "Ban Link After X Join Declines")]
            public int BanDeclineAmount { get; set; }
            
            [JsonProperty(PropertyName = "Ban Duration (Hours)")]
            public int BanDuration { get; set; }
            
            public LinkBanSettings(LinkBanSettings settings)
            {
                EnableLinkBanning = settings?.EnableLinkBanning ?? true;
                BanAnnouncementChannel = settings?.BanAnnouncementChannel ?? default(Snowflake);
                BanDeclineAmount = settings?.BanDeclineAmount ?? 3;
                BanDuration = settings?.BanDuration ?? 24;
            }
        }
        #endregion

        #region Configuration\LinkPermissionSettings.cs
        public class LinkPermissionSettings
        {
            [JsonProperty(PropertyName = "On Link Server Permissions To Add")]
            public List<string> LinkPermissions { get; set; }
            
            [JsonProperty(PropertyName = "On Unlink Server Permissions To Remove")]
            public List<string> UnlinkPermissions { get; set; }
            
            [JsonProperty(PropertyName = "On Link Server Groups To Add")]
            public List<string> LinkGroups { get; set; }
            
            [JsonProperty(PropertyName = "On Unlink Server Groups To Remove")]
            public List<string> UnlinkGroups { get; set; }
            
            [JsonProperty(PropertyName = "On Link Discord Roles To Add")]
            public List<Snowflake> LinkRoles { get; set; }
            
            [JsonProperty(PropertyName = "On Unlink Discord Roles To Remove")]
            public List<Snowflake> UnlinkRoles { get; set; }
            
            public LinkPermissionSettings(LinkPermissionSettings settings)
            {
                LinkPermissions = settings?.LinkPermissions ?? new List<string>();
                LinkGroups = settings?.LinkGroups ?? new List<string>();
                LinkRoles = settings?.LinkRoles ?? new List<Snowflake>();
                UnlinkPermissions = settings?.UnlinkPermissions ?? new List<string>();
                UnlinkGroups = settings?.UnlinkGroups ?? new List<string>();
                UnlinkRoles = settings?.UnlinkRoles ?? new List<Snowflake>();
            }
        }
        #endregion

        #region Configuration\LinkSettings.cs
        public class LinkSettings
        {
            [JsonProperty(PropertyName = "Announcement Channel Id")]
            public Snowflake AnnouncementChannel { get; set; }
            
            [JsonProperty(PropertyName = "Link Code Generator Characters")]
            public string LinkCodeCharacters { get; set; }
            
            [JsonProperty(PropertyName = "Link Code Generator Length")]
            public int LinkCodeLength { get; set; }
            
            [JsonProperty(PropertyName = "Automatically Relink A Player If They Leave And Rejoin The Discord Server")]
            public bool AutoRelinkPlayer { get; set; }
            
            [JsonProperty(PropertyName = "Inactive Settings")]
            public InactiveSettings InactiveSettings { get; set; }
            
            public LinkSettings(LinkSettings settings)
            {
                AnnouncementChannel = settings?.AnnouncementChannel ?? default(Snowflake);
                LinkCodeCharacters = settings?.LinkCodeCharacters ?? "123456789";
                LinkCodeLength = settings?.LinkCodeLength ?? 6;
                if (LinkCodeLength <= 0)
                {
                    LinkCodeLength = 6;
                }
                AutoRelinkPlayer = settings?.AutoRelinkPlayer ?? true;
                InactiveSettings = new InactiveSettings(settings?.InactiveSettings);
            }
        }
        #endregion

        #region Configuration\PluginConfig.cs
        public class PluginConfig
        {
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string ApiKey { get; set; } = string.Empty;
            
            [JsonProperty(PropertyName = "Discord Server ID (Optional if bot only in 1 guild)")]
            public Snowflake GuildId { get; set; }
            
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Server Name Override")]
            public string ServerNameOverride { get; set; } = string.Empty;
            
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Server Invite Url")]
            public string InviteUrl { get; set; } = string.Empty;
            
            [JsonProperty(PropertyName = "Link Settings")]
            public LinkSettings LinkSettings { get; set; }
            
            [JsonProperty(PropertyName = "Welcome Message Settings")]
            public WelcomeMessageSettings WelcomeMessageSettings { get; set; }
            
            [JsonProperty(PropertyName = "Guild Link Message Settings")]
            public GuildMessageSettings LinkMessageSettings { get; set; }
            
            [JsonProperty(PropertyName = "Link Permission Settings")]
            public LinkPermissionSettings PermissionSettings { get; set; }
            
            [JsonProperty(PropertyName = "Link Ban Settings")]
            public LinkBanSettings LinkBanSettings { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; }
        }
        #endregion

        #region Configuration\WelcomeMessageSettings.cs
        public class WelcomeMessageSettings
        {
            [JsonProperty(PropertyName = "Enable Welcome DM Message")]
            public bool EnableWelcomeMessage { get; set; }
            
            [JsonProperty(PropertyName = "Send Welcome Message On Discord Server Join")]
            public bool SendOnGuildJoin { get; set; }
            
            [JsonProperty(PropertyName = "Send Welcome Message On Role ID Added")]
            public List<Snowflake> SendOnRoleAdded { get; set; }
            
            [JsonProperty(PropertyName = "Add Link Accounts Button In Welcome Message")]
            public bool EnableLinkButton { get; set; }
            
            public WelcomeMessageSettings(WelcomeMessageSettings settings)
            {
                EnableWelcomeMessage = settings?.EnableWelcomeMessage ?? true;
                SendOnGuildJoin = settings?.SendOnGuildJoin ?? false;
                SendOnRoleAdded = settings?.SendOnRoleAdded ?? new List<Snowflake> {new(1234567890)};
                EnableLinkButton = settings?.EnableLinkButton ?? true;
            }
        }
        #endregion

        #region Data\DiscordInfo.cs
        public class DiscordInfo
        {
            public Snowflake DiscordId { get; set; }
            public string PlayerId { get; set; }
            public DateTime LastOnline { get; set; } = DateTime.UtcNow;
            
            [JsonConstructor]
            public DiscordInfo() { }
            
            public DiscordInfo(IPlayer player, DiscordUser user)
            {
                PlayerId = player.Id;
                DiscordId = user.Id;
            }
        }
        #endregion

        #region Data\LinkMessageData.cs
        public class LinkMessageData
        {
            public Snowflake ChannelId { get; set; }
            public Snowflake MessageId { get; set; }
            
            [JsonConstructor]
            public LinkMessageData() { }
            
            public LinkMessageData(Snowflake channelId, Snowflake messageId)
            {
                ChannelId = channelId;
                MessageId = messageId;
            }
        }
        #endregion

        #region Data\PluginData.cs
        public class PluginData
        {
            public Hash<string, DiscordInfo> PlayerDiscordInfo = new();
            public Hash<Snowflake, DiscordInfo> LeftPlayerInfo = new();
            public Hash<string, DiscordInfo> InactivePlayerInfo = new();
            public LinkMessageData MessageData;
        }
        #endregion

        #region Enums\JoinSource.cs
        public enum JoinSource
        {
            Server,
            Discord
        }
        #endregion

        #region Enums\LinkReason.cs
        public enum LinkReason
        {
            Command,
            Admin,
            Api,
            GuildRejoin,
            InactiveRejoin
        }
        #endregion

        #region Enums\UnlinkedReason.cs
        public enum UnlinkedReason
        {
            Command,
            Admin,
            Api,
            LeftGuild,
            Inactive
        }
        #endregion

        #region Link\JoinBanData.cs
        public class JoinBanData
        {
            public int Times { get; private set; }
            private DateTime _bannedUntil;
            
            public void AddDeclined()
            {
                Times++;
            }
            
            public bool IsBanned()
            {
                return _bannedUntil > DateTime.UtcNow;
            }
            
            public TimeSpan GetRemainingBan()
            {
                return _bannedUntil - DateTime.UtcNow;
            }
            
            public void SetBanDuration(float hours)
            {
                _bannedUntil = DateTime.UtcNow.AddHours(hours);
            }
        }
        #endregion

        #region Link\JoinBanHandler.cs
        public class JoinBanHandler
        {
            private readonly Hash<string, JoinBanData> _playerBans = new();
            private readonly Hash<Snowflake, JoinBanData> _discordBans = new();
            private readonly LinkBanSettings _settings;
            
            public JoinBanHandler(LinkBanSettings settings)
            {
                _settings = settings;
            }
            
            public void AddBan(IPlayer player)
            {
                if (!_settings.EnableLinkBanning)
                {
                    return;
                }
                
                JoinBanData ban = GetBan(player);
                
                ban.AddDeclined();
                if (ban.Times >= _settings.BanDeclineAmount)
                {
                    ban.SetBanDuration(_settings.BanDuration);
                    DiscordCore.Instance.SendGlobalTemplateMessage(TemplateKeys.Announcements.Ban.PlayerBanned, _settings.BanAnnouncementChannel, null, player, DiscordCore.Instance.GetDefault(player).AddTimestamp(GetBannedEndDate(player)));
                }
            }
            
            public void AddBan(DiscordUser user)
            {
                if (!_settings.EnableLinkBanning)
                {
                    return;
                }
                
                JoinBanData ban = GetBan(user);
                
                ban.AddDeclined();
                if (ban.Times >= _settings.BanDeclineAmount)
                {
                    ban.SetBanDuration(_settings.BanDuration);
                    DiscordCore.Instance.SendGlobalTemplateMessage(TemplateKeys.Announcements.Ban.UserBanned, _settings.BanAnnouncementChannel, user, null, DiscordCore.Instance.GetDefault(user).AddTimestamp(GetBannedEndDate(user)));
                }
            }
            
            public bool Unban(IPlayer player)
            {
                return _playerBans.Remove(player.Id);
            }
            
            public bool Unban(DiscordUser user)
            {
                return _discordBans.Remove(user.Id);
            }
            
            public bool IsBanned(IPlayer player)
            {
                if (!_settings.EnableLinkBanning)
                {
                    return false;
                }
                
                JoinBanData ban = _playerBans[player.Id];
                return ban != null && ban.IsBanned();
            }
            
            public bool IsBanned(DiscordUser user)
            {
                if (!_settings.EnableLinkBanning)
                {
                    return false;
                }
                
                JoinBanData ban = _discordBans[user.Id];
                return ban != null && ban.IsBanned();
            }
            
            public TimeSpan GetRemainingDuration(IPlayer player)
            {
                if (!_settings.EnableLinkBanning)
                {
                    return TimeSpan.Zero;
                }
                
                return _playerBans[player.Id]?.GetRemainingBan() ?? TimeSpan.Zero;
            }
            
            public DateTimeOffset GetBannedEndDate(IPlayer player)
            {
                return DateTimeOffset.UtcNow + GetRemainingDuration(player);
            }
            
            public TimeSpan GetRemainingDuration(DiscordUser user)
            {
                if (!_settings.EnableLinkBanning)
                {
                    return TimeSpan.Zero;
                }
                
                return _discordBans[user.Id]?.GetRemainingBan() ?? TimeSpan.Zero;
            }
            
            public DateTimeOffset GetBannedEndDate(DiscordUser user)
            {
                return DateTimeOffset.UtcNow + GetRemainingDuration(user);
            }
            
            private JoinBanData GetBan(IPlayer player)
            {
                JoinBanData ban = _playerBans[player.Id];
                if (ban == null)
                {
                    ban = new JoinBanData();
                    _playerBans[player.Id] = ban;
                }
                
                return ban;
            }
            
            private JoinBanData GetBan(DiscordUser user)
            {
                JoinBanData ban = _discordBans[user.Id];
                if (ban == null)
                {
                    ban = new JoinBanData();
                    _discordBans[user.Id] = ban;
                }
                
                return ban;
            }
        }
        #endregion

        #region Link\JoinData.cs
        public class JoinData
        {
            public IPlayer Player { get; set; }
            public DiscordUser Discord { get; set; }
            public string Code { get; private set; }
            public JoinSource From { get; private set; }
            
            private JoinData() { }
            
            public static JoinData CreateServerActivation(IPlayer player, string code)
            {
                return new JoinData
                {
                    From = JoinSource.Server,
                    Code = code,
                    Player = player
                };
            }
            
            public static JoinData CreateDiscordActivation(DiscordUser user, string code)
            {
                return new JoinData
                {
                    From = JoinSource.Discord,
                    Code = code,
                    Discord = user
                };
            }
            
            public static JoinData CreateLinkedActivation(JoinSource source, IPlayer player, DiscordUser user)
            {
                return new JoinData
                {
                    From = source,
                    Player = player,
                    Discord = user
                };
            }
            
            public bool IsCompleted() => Player != null && Discord != null && Discord.Id.IsValid();
            
            public bool IsMatch(IPlayer player) => Player != null && player != null && Player.Id == player.Id;
            
            public bool IsMatch(DiscordUser user) => Discord != null && user != null && Discord.Id == user.Id;
        }
        #endregion

        #region Link\JoinHandler.cs
        public class JoinHandler
        {
            private readonly List<JoinData> _activations = new();
            private readonly LinkSettings _settings;
            private readonly LinkHandler _linkHandler;
            private readonly JoinBanHandler _ban;
            private readonly DiscordCore _plugin = DiscordCore.Instance;
            private readonly StringBuilder _sb = new();
            
            public JoinHandler(LinkSettings settings, LinkHandler linkHandler, JoinBanHandler ban)
            {
                _settings = settings;
                _linkHandler = linkHandler;
                _ban = ban;
            }
            
            public JoinData FindByCode(string code)
            {
                for (int index = 0; index < _activations.Count; index++)
                {
                    JoinData activation = _activations[index];
                    if (activation.Code?.Equals(code, StringComparison.OrdinalIgnoreCase) ?? false)
                    {
                        return activation;
                    }
                }
                
                return null;
            }
            
            public JoinData FindCompletedByPlayer(IPlayer player)
            {
                for (int index = 0; index < _activations.Count; index++)
                {
                    JoinData activation = _activations[index];
                    if (activation.IsCompleted() && activation.Player.Id.Equals(player.Id, StringComparison.OrdinalIgnoreCase))
                    {
                        return activation;
                    }
                }
                
                return null;
            }
            
            public JoinData FindCompletedByUser(DiscordUser user)
            {
                for (int index = 0; index < _activations.Count; index++)
                {
                    JoinData activation = _activations[index];
                    if (activation.IsCompleted() && activation.Discord.Id == user.Id)
                    {
                        return activation;
                    }
                }
                
                return null;
            }
            
            public void RemoveByPlayer(IPlayer player)
            {
                for (int index = _activations.Count - 1; index >= 0; index--)
                {
                    JoinData activation = _activations[index];
                    if (activation.IsMatch(player))
                    {
                        _activations.RemoveAt(index);
                    }
                }
            }
            
            public void RemoveByUser(DiscordUser user)
            {
                for (int index = _activations.Count - 1; index >= 0; index--)
                {
                    JoinData activation = _activations[index];
                    if (activation.IsMatch(user))
                    {
                        _activations.RemoveAt(index);
                    }
                }
            }
            
            public JoinData CreateActivation(IPlayer player)
            {
                if (player == null) throw new ArgumentNullException(nameof(player));
                
                RemoveByPlayer(player);
                JoinData activation = JoinData.CreateServerActivation(player, GenerateCode());
                _activations.Add(activation);
                return activation;
            }
            
            public JoinData CreateActivation(DiscordUser user)
            {
                if (user == null) throw new ArgumentNullException(nameof(user));
                
                RemoveByUser(user);
                JoinData activation = JoinData.CreateDiscordActivation(user, GenerateCode());
                _activations.Add(activation);
                return activation;
            }
            
            public JoinData CreateActivation(IPlayer player, DiscordUser user, JoinSource from)
            {
                if (user == null) throw new ArgumentNullException(nameof(user));
                
                RemoveByPlayer(player);
                RemoveByUser(user);
                JoinData activation = JoinData.CreateLinkedActivation(from, player, user);
                _activations.Add(activation);
                return activation;
            }
            
            private string GenerateCode()
            {
                _sb.Clear();
                for (int i = 0; i < _settings.LinkCodeLength; i++)
                {
                    _sb.Append(_settings.LinkCodeCharacters[Oxide.Core.Random.Range(0, _settings.LinkCodeCharacters.Length)]);
                }
                
                return _sb.ToString();
            }
            
            public void CompleteLink(JoinData data, DiscordInteraction interaction)
            {
                IPlayer player = data.Player;
                DiscordUser user = data.Discord;
                
                _activations.Remove(data);
                RemoveByPlayer(data.Player);
                RemoveByUser(data.Discord);
                
                _linkHandler.HandleLink(player, user, LinkReason.Command, interaction);
            }
            
            public void DeclineLink(JoinData data, DiscordInteraction interaction)
            {
                _activations.Remove(data);
                
                if (data.From == JoinSource.Server)
                {
                    _ban.AddBan(data.Player);
                    RemoveByPlayer(data.Player);
                    using PlaceholderData placeholders = _plugin.GetDefault(data.Player, data.Discord);
                    placeholders.ManualPool();
                    _plugin.Chat(data.Player, ServerLang.Link.Declined.JoinWithUser, placeholders);
                    _plugin.SendTemplateMessage(TemplateKeys.Link.Declined.JoinWithUser, interaction, placeholders);
                }
                else if (data.From == JoinSource.Discord)
                {
                    _ban.AddBan(data.Discord);
                    RemoveByUser(data.Discord);
                    using PlaceholderData placeholders = _plugin.GetDefault(data.Player, data.Discord);
                    placeholders.ManualPool();
                    _plugin.Chat(data.Player, ServerLang.Link.Declined.JoinWithPlayer, placeholders);
                    _plugin.SendTemplateMessage(TemplateKeys.Link.Declined.JoinWithPlayer, data.Discord, data.Player, placeholders);
                }
            }
        }
        #endregion

        #region Link\LinkHandler.cs
        public class LinkHandler
        {
            private readonly PluginData _pluginData;
            private readonly LinkPermissionSettings _permissionSettings;
            private readonly LinkSettings _settings;
            private readonly DiscordLink _link = Interface.Oxide.GetLibrary<DiscordLink>();
            private readonly IPlayerManager _players = Interface.Oxide.GetLibrary<Covalence>().Players;
            private readonly DiscordCore _plugin = DiscordCore.Instance;
            private readonly Hash<LinkReason, LinkMessage> _linkMessages = new();
            private readonly Hash<UnlinkedReason, LinkMessage> _unlinkMessages = new();
            
            public LinkHandler(PluginData pluginData, PluginConfig config)
            {
                _pluginData = pluginData;
                _settings = config.LinkSettings;
                _permissionSettings = config.PermissionSettings;
                LinkSettings link = config.LinkSettings;
                
                _linkMessages[LinkReason.Command] = new LinkMessage(ServerLang.Link.Completed.Command, ServerLang.Announcements.Link.Command, TemplateKeys.Link.Completed.Command, TemplateKeys.Announcements.Link.Command, _plugin, link);
                _linkMessages[LinkReason.Admin] = new LinkMessage(ServerLang.Link.Completed.Admin, ServerLang.Announcements.Link.Admin, TemplateKeys.Link.Completed.Admin, TemplateKeys.Announcements.Link.Admin, _plugin, link);
                _linkMessages[LinkReason.Api] = new LinkMessage(ServerLang.Link.Completed.Api, ServerLang.Announcements.Link.Api, TemplateKeys.Link.Completed.Api, TemplateKeys.Announcements.Link.Api, _plugin, link);
                _linkMessages[LinkReason.GuildRejoin] = new LinkMessage(ServerLang.Link.Completed.GuildRejoin, ServerLang.Announcements.Link.GuildRejoin, TemplateKeys.Link.Completed.GuildRejoin, TemplateKeys.Announcements.Link.GuildRejoin, _plugin, link);
                _linkMessages[LinkReason.InactiveRejoin] = new LinkMessage(ServerLang.Link.Completed.InactiveRejoin, ServerLang.Announcements.Link.InactiveRejoin, TemplateKeys.Link.Completed.InactiveRejoin, TemplateKeys.Announcements.Link.InactiveRejoin, _plugin, link);
                
                _unlinkMessages[UnlinkedReason.Command] = new LinkMessage(ServerLang.Unlink.Completed.Command, ServerLang.Announcements.Unlink.Command, TemplateKeys.Unlink.Completed.Command, TemplateKeys.Announcements.Unlink.Command, _plugin, link);
                _unlinkMessages[UnlinkedReason.Admin] = new LinkMessage(ServerLang.Unlink.Completed.Admin, ServerLang.Announcements.Unlink.Admin, TemplateKeys.Unlink.Completed.Admin, TemplateKeys.Announcements.Unlink.Admin, _plugin, link);
                _unlinkMessages[UnlinkedReason.Api] = new LinkMessage(ServerLang.Unlink.Completed.Api, ServerLang.Announcements.Unlink.Api, TemplateKeys.Unlink.Completed.Api, TemplateKeys.Announcements.Unlink.Api, _plugin, link);
                _unlinkMessages[UnlinkedReason.LeftGuild] = new LinkMessage(ServerLang.Unlink.Completed.LeftGuild, ServerLang.Announcements.Unlink.LeftGuild, default, TemplateKeys.Announcements.Unlink.LeftGuild, _plugin, link);
                _unlinkMessages[UnlinkedReason.Inactive] = new LinkMessage(null, ServerLang.Announcements.Unlink.Inactive, TemplateKeys.Unlink.Completed.Inactive, TemplateKeys.Announcements.Unlink.Inactive, _plugin, link);
            }
            
            public void HandleLink(IPlayer player, DiscordUser user, LinkReason reason, DiscordInteraction interaction)
            {
                if (player == null) throw new ArgumentNullException(nameof(player));
                if (user == null) throw new ArgumentNullException(nameof(user));
                _pluginData.InactivePlayerInfo.Remove(player.Id);
                _pluginData.LeftPlayerInfo.Remove(user.Id);
                _pluginData.PlayerDiscordInfo[player.Id] = new DiscordInfo(player, user);
                _link.OnLinked(_plugin, player, user);
                PlaceholderData data = _plugin.GetDefault(player, user);
                _linkMessages[reason]?.SendMessages(player, user, interaction, data);
                AddPermissions(player, user);
                _plugin.SaveData();
            }
            
            public void HandleUnlink(IPlayer player, DiscordUser user, UnlinkedReason reason, DiscordInteraction interaction)
            {
                if (player == null || user == null || !user.Id.IsValid())
                {
                    return;
                }
                
                DiscordInfo info = _pluginData.PlayerDiscordInfo[player.Id];
                if (info == null)
                {
                    return;
                }
                
                PlaceholderData data = _plugin.GetDefault(player, user);
                if (reason == UnlinkedReason.LeftGuild)
                {
                    _pluginData.LeftPlayerInfo[info.DiscordId] = info;
                }
                else if (reason == UnlinkedReason.Inactive)
                {
                    _pluginData.InactivePlayerInfo[info.PlayerId] = info;
                    data.AddTimeSpan(TimeSpan.FromDays(_settings.InactiveSettings.UnlinkInactiveDays));
                }
                
                _pluginData.PlayerDiscordInfo.Remove(player.Id);
                _link.OnUnlinked(_plugin, player, user);
                _unlinkMessages[reason]?.SendMessages(player, user, interaction, data);
                RemovePermissions(player, user, reason);
                _plugin.SaveData();
            }
            
            public void OnUserConnected(IPlayer player)
            {
                DiscordInfo info = _pluginData.PlayerDiscordInfo[player.Id];
                if (info != null)
                {
                    info.LastOnline = DateTime.UtcNow;
                    return;
                }
                
                if (_settings.InactiveSettings.AutoRelinkInactive)
                {
                    info = _pluginData.InactivePlayerInfo[player.Id];
                    if (info != null)
                    {
                        info.LastOnline = DateTime.UtcNow;
                        DiscordUser user = _plugin.Guild.Members[info.DiscordId]?.User;
                        if (user == null)
                        {
                            _pluginData.LeftPlayerInfo[info.DiscordId] = info;
                            return;
                        }
                        
                        HandleLink(player, user, LinkReason.InactiveRejoin, null);
                    }
                }
            }
            
            public void OnGuildMemberLeft(DiscordUser user)
            {
                IPlayer player = user.Player;
                if (player != null)
                {
                    HandleUnlink(player, user, UnlinkedReason.LeftGuild, null);
                }
            }
            
            public void OnGuildMemberJoin(DiscordUser user)
            {
                if (!_settings.AutoRelinkPlayer)
                {
                    return;
                }
                
                DiscordInfo info = _pluginData.LeftPlayerInfo[user.Id];
                if (info == null)
                {
                    return;
                }
                
                _pluginData.PlayerDiscordInfo[info.PlayerId] = info;
                _pluginData.LeftPlayerInfo.Remove(info.DiscordId);
                
                IPlayer player = _players.FindPlayerById(info.PlayerId);
                if (player == null)
                {
                    return;
                }
                
                HandleLink(player, user, LinkReason.GuildRejoin, null);
            }
            
            public void ProcessLeaveAndRejoin()
            {
                List<DiscordInfo> possiblyLeftPlayers = new();
                foreach (DiscordInfo info in _pluginData.PlayerDiscordInfo.Values.ToList())
                {
                    if (_settings.InactiveSettings.UnlinkInactive && info.LastOnline + TimeSpan.FromDays(_settings.InactiveSettings.UnlinkInactiveDays) < DateTime.UtcNow)
                    {
                        IPlayer player = _link.GetPlayer(info.DiscordId);
                        DiscordUser user = player.GetDiscordUser();
                        HandleUnlink(player, user, UnlinkedReason.LeftGuild, null);
                        continue;
                    }
                    
                    if (!_plugin.Guild.Members.ContainsKey(info.DiscordId))
                    {
                        possiblyLeftPlayers.Add(info);
                    }
                }
                
                ProcessLeftPlayers(possiblyLeftPlayers);
                
                if (_settings.AutoRelinkPlayer)
                {
                    foreach (DiscordInfo info in _pluginData.LeftPlayerInfo.Values.ToList())
                    {
                        GuildMember member = _plugin.Guild.Members[info.DiscordId];
                        if (member != null)
                        {
                            OnGuildMemberJoin(member.User);
                        }
                    }
                }
            }
            
            private void ProcessLeftPlayers(List<DiscordInfo> possiblyLeftPlayers)
            {
                if (possiblyLeftPlayers.Count != 0)
                {
                    int index = possiblyLeftPlayers.Count - 1;
                    DiscordInfo info = possiblyLeftPlayers[index];
                    possiblyLeftPlayers.RemoveAt(index);
                    ProcessLeftPlayer(info, possiblyLeftPlayers);
                }
            }
            
            private void ProcessLeftPlayer(DiscordInfo info, List<DiscordInfo> remaining)
            {
                DiscordCore.Instance.Guild.GetMember(DiscordCore.Instance.Client, info.DiscordId)
                .Catch<ResponseError>(error =>
                {
                    if (error.DiscordError is { Code: 10013 } or { Code: 10007 })
                    {
                        error.SuppressErrorMessage();
                        IPlayer player = _link.GetPlayer(info.DiscordId);
                        DiscordUser user = player.GetDiscordUser();
                        HandleUnlink(player, user, UnlinkedReason.LeftGuild, null);
                    }
                }).Finally(() => ProcessLeftPlayers(remaining));
            }
            
            private void AddPermissions(IPlayer player, DiscordUser user)
            {
                for (int index = 0; index < _permissionSettings.LinkPermissions.Count; index++)
                {
                    string permission = _permissionSettings.LinkPermissions[index];
                    player.GrantPermission(permission);
                }
                
                for (int index = 0; index < _permissionSettings.LinkGroups.Count; index++)
                {
                    string group = _permissionSettings.LinkGroups[index];
                    player.AddToGroup(group);
                }
                
                for (int index = 0; index < _permissionSettings.LinkRoles.Count; index++)
                {
                    Snowflake role = _permissionSettings.LinkRoles[index];
                    DiscordCore.Instance.Guild.AddMemberRole(_plugin.Client, user.Id, role);
                }
            }
            
            private void RemovePermissions(IPlayer player, DiscordUser user, UnlinkedReason reason)
            {
                for (int index = 0; index < _permissionSettings.UnlinkPermissions.Count; index++)
                {
                    string permission = _permissionSettings.UnlinkPermissions[index];
                    player.RevokePermission(permission);
                }
                
                for (int index = 0; index < _permissionSettings.UnlinkGroups.Count; index++)
                {
                    string group = _permissionSettings.UnlinkGroups[index];
                    player.RemoveFromGroup(group);
                }
                
                if (reason != UnlinkedReason.LeftGuild)
                {
                    for (int index = 0; index < _permissionSettings.UnlinkRoles.Count; index++)
                    {
                        Snowflake role = _permissionSettings.UnlinkRoles[index];
                        DiscordCore.Instance.Guild.RemoveMemberRole(_plugin.Client, user.Id, role);
                    }
                }
            }
        }
        #endregion

        #region Link\LinkMessage.cs
        public class LinkMessage
        {
            private readonly string _chatLang;
            private readonly string _chatAnnouncement;
            private readonly TemplateKey _discordTemplate;
            private readonly TemplateKey _announcementTemplate;
            private readonly DiscordCore _plugin;
            private readonly LinkSettings _link;
            
            public LinkMessage(string chatLang, string chatAnnouncement, TemplateKey discordTemplate, TemplateKey announcementTemplate, DiscordCore plugin, LinkSettings link)
            {
                _chatLang = chatLang;
                _chatAnnouncement = chatAnnouncement;
                _discordTemplate = discordTemplate;
                _announcementTemplate = announcementTemplate;
                _plugin = plugin;
                _link = link;
            }
            
            public void SendMessages(IPlayer player, DiscordUser user, DiscordInteraction interaction, PlaceholderData data)
            {
                using (data)
                {
                    data.ManualPool();
                    _plugin.BroadcastMessage(_chatAnnouncement, data);
                    _plugin.Chat(player, _chatLang, data);
                    if (_discordTemplate.IsValid)
                    {
                        if (interaction != null)
                        {
                            _plugin.SendTemplateMessage(_discordTemplate, interaction, data);
                        }
                        else
                        {
                            _plugin.SendTemplateMessage(_discordTemplate, user, player, data);
                        }
                    }
                    
                    _plugin.SendGlobalTemplateMessage(_announcementTemplate, _link.AnnouncementChannel, user, player, data);
                }
            }
        }
        #endregion

        #region Localization\ServerLang.cs
        public static class ServerLang
        {
            public const string Format = nameof(Format);
            public const string NoPermission = nameof(NoPermission);
            
            public static class Announcements
            {
                private const string Base = nameof(Announcements) + ".";
                
                public static class Link
                {
                    private const string Base = Announcements.Base + nameof(Link) + ".";
                    public const string Command = Base + nameof(Command);
                    public const string Admin = Base + nameof(Admin);
                    public const string Api = Base + nameof(Api);
                    public const string GuildRejoin = Base + nameof(GuildRejoin);
                    public const string InactiveRejoin = Base + nameof(InactiveRejoin);
                }
                
                public static class Unlink
                {
                    private const string Base = Announcements.Base + nameof(Unlink) + ".";
                    
                    public const string Command = Base + nameof(Command);
                    public const string Admin = Base + nameof(Admin);
                    public const string Api = Base + nameof(Api);
                    public const string LeftGuild = Base + nameof(LeftGuild);
                    public const string Inactive = Base + nameof(Inactive);
                }
            }
            
            public static class Commands
            {
                private const string Base = nameof(Commands) + ".";
                
                public const string DcCommand = Base + nameof(DcCommand);
                public const string CodeCommand = Base + nameof(CodeCommand);
                public const string UserCommand = Base + nameof(UserCommand);
                public const string LeaveCommand = Base + nameof(LeaveCommand);
                public const string AcceptCommand = Base + nameof(AcceptCommand);
                public const string DeclineCommand = Base + nameof(DeclineCommand);
                public const string LinkCommand = Base + nameof(LinkCommand);
                public const string HelpMessage = Base + nameof(HelpMessage);
                
                public static class Code
                {
                    private const string Base = Commands.Base + nameof(Code) + ".";
                    
                    public const string LinkInfo = Base + nameof(LinkInfo);
                    public const string LinkServer = Base + nameof(LinkServer);
                    public const string LinkInGuild = Base + nameof(LinkInGuild);
                    public const string LinkInDm = Base + nameof(LinkInDm);
                }
                
                public static class User
                {
                    private const string Base = Commands.Base + nameof(User) + ".";
                    
                    public const string MatchFound = Base + nameof(MatchFound);
                    
                    public static class Errors
                    {
                        private const string Base = User.Base + nameof(Errors) + ".";
                        
                        public const string InvalidSyntax = Base + nameof(InvalidSyntax);
                        public const string UserIdNotFound = Base + nameof(UserIdNotFound);
                        public const string UserNotFound = Base + nameof(UserNotFound);
                        public const string MultipleUsersFound = Base + nameof(MultipleUsersFound);
                        public const string SearchError = Base + nameof(SearchError);
                    }
                }
                
                public static class Leave
                {
                    private const string Base = Commands.Base + nameof(Leave) + ".";
                    
                    public static class Errors
                    {
                        private const string Base = Leave.Base + nameof(Errors) + ".";
                        
                        public const string NotLinked = Base + nameof(NotLinked);
                    }
                }
            }
            
            public static class Link
            {
                private const string Base = nameof(Link) + ".";
                public static class Completed
                {
                    private const string Base = Link.Base + nameof(Completed) + ".";
                    
                    public const string Command = Base + nameof(Command);
                    public const string Admin = Base + nameof(Admin);
                    public const string Api = Base + nameof(Api);
                    public const string GuildRejoin = Base + nameof(GuildRejoin);
                    public const string InactiveRejoin = Base + nameof(InactiveRejoin);
                }
                
                public static class Declined
                {
                    private const string Base = Link.Base + nameof(Declined) + ".";
                    
                    public const string JoinWithPlayer = Base + nameof(JoinWithPlayer);
                    public const string JoinWithUser = Base + nameof(JoinWithUser);
                }
                
                public static class Errors
                {
                    private const string Base = Link.Base + nameof(Errors) + ".";
                    
                    public const string InvalidSyntax = Base + nameof(InvalidSyntax);
                }
            }
            
            public static class Unlink
            {
                private const string Base = nameof(Unlink) + ".";
                
                public static class Completed
                {
                    private const string Base = Unlink.Base + nameof(Completed) + ".";
                    
                    public const string Command = Base + nameof(Command);
                    public const string LeftGuild = Base + nameof(LeftGuild);
                    public const string Admin = Base + nameof(Admin);
                    public const string Api = Base + nameof(Api);
                }
            }
            
            public static class Banned
            {
                private const string Base = nameof(Banned) + ".";
                
                public const string IsUserBanned = Base + nameof(IsUserBanned);
            }
            
            public static class Join
            {
                private const string Base = nameof(Join) + ".";
                
                public const string ByPlayer = Base + nameof(ByPlayer);
                
                public static class Errors
                {
                    private const string Base = Join.Base + nameof(Errors) + ".";
                    
                    public const string PlayerJoinActivationNotFound = Base + nameof(PlayerJoinActivationNotFound);
                }
            }
            
            public static class Discord
            {
                private const string Base = nameof(Discord) + ".";
                
                public const string DiscordCommand = Base + nameof(DiscordCommand);
                public const string LinkCommand = Base + nameof(LinkCommand);
            }
            
            public static class Errors
            {
                private const string Base = nameof(Errors) + ".";
                
                public const string PlayerAlreadyLinked = Base + nameof(PlayerAlreadyLinked);
                public const string DiscordAlreadyLinked = Base + nameof(DiscordAlreadyLinked);
                public const string ActivationNotFound = Base + nameof(ActivationNotFound);
                public const string MustBeCompletedInDiscord = Base + nameof(MustBeCompletedInDiscord);
                public const string ConsolePlayerNotSupported = Base + nameof(ConsolePlayerNotSupported);
            }
        }
        #endregion

        #region Placeholders\PlaceholderDataKeys.cs
        public class PlaceholderDataKeys
        {
            public static readonly PlaceholderDataKey Code = new("dc.code");
            public static readonly PlaceholderDataKey NotFound = new("dc.notfound");
        }
        #endregion

        #region Placeholders\PlaceholderKeys.cs
        public class PlaceholderKeys
        {
            public static readonly PlaceholderKey InviteUrl = new(nameof(DiscordCore), "invite.url");
            public static readonly PlaceholderKey LinkCode = new(nameof(DiscordCore), "link.code");
            public static readonly PlaceholderKey CommandChannels = new(nameof(DiscordCore), "command.channels");
            public static readonly PlaceholderKey NotFound = new(nameof(DiscordCore), "notfound");
        }
        #endregion

        #region Templates\TemplateKeys.cs
        public static class TemplateKeys
        {
            public static class Announcements
            {
                private const string Base = nameof(Announcements) + ".";
                
                public static class Link
                {
                    private const string Base = Announcements.Base + nameof(Link) + ".";
                    public static readonly TemplateKey Command = new(Base + nameof(Command));
                    public static readonly TemplateKey Admin = new(Base + nameof(Admin));
                    public static readonly TemplateKey Api = new(Base + nameof(Api));
                    public static readonly TemplateKey GuildRejoin = new(Base + nameof(GuildRejoin));
                    public static readonly TemplateKey InactiveRejoin = new(Base + nameof(InactiveRejoin));
                }
                
                public static class Unlink
                {
                    private const string Base = Announcements.Base + nameof(Unlink) + ".";
                    
                    public static readonly TemplateKey Command = new(Base + nameof(Command));
                    public static readonly TemplateKey Admin = new(Base + nameof(Admin));
                    public static readonly TemplateKey Api = new(Base + nameof(Api));
                    public static readonly TemplateKey LeftGuild = new(Base + nameof(LeftGuild));
                    public static readonly TemplateKey Inactive = new(Base + nameof(Inactive));
                }
                
                public static class Ban
                {
                    private const string Base = Announcements.Base + nameof(Ban) + ".";
                    
                    public static readonly TemplateKey PlayerBanned = new(Base + nameof(PlayerBanned));
                    public static readonly TemplateKey UserBanned = new(Base + nameof(UserBanned));
                }
            }
            
            public static class WelcomeMessage
            {
                private const string Base = nameof(WelcomeMessage) + ".";
                
                public static readonly TemplateKey PmWelcomeMessage = new(Base + nameof(PmWelcomeMessage));
                public static readonly TemplateKey GuildWelcomeMessage = new(Base + nameof(GuildWelcomeMessage));
                
                public static class Error
                {
                    private const string Base = WelcomeMessage.Base + nameof(Error) + ".";
                    
                    public static readonly TemplateKey AlreadyLinked = new(Base + nameof(AlreadyLinked));
                }
            }
            
            public static class Commands
            {
                private const string Base = nameof(Commands) + ".";
                
                public static class Code
                {
                    private const string Base = Commands.Base + nameof(Code) + ".";
                    
                    public static readonly TemplateKey Success = new(Base + nameof(Success));
                }
                
                public static class User
                {
                    private const string Base = Commands.Base + nameof(User) + ".";
                    
                    public static readonly TemplateKey Success = new(Base + nameof(Success));
                    
                    public static class Error
                    {
                        private const string Base = User.Base + nameof(Error) + ".";
                        
                        public static readonly TemplateKey PlayerIsInvalid = new(Base + nameof(PlayerIsInvalid));
                        public static readonly TemplateKey PlayerNotConnected = new(Base + nameof(PlayerNotConnected));
                    }
                }
                
                public static class Leave
                {
                    private const string Base = Commands.Base + nameof(Leave) + ".";
                    
                    public static class Error
                    {
                        private const string Base = Leave.Base + nameof(Error) + ".";
                        
                        public static readonly TemplateKey UserNotLinked = new(Base + nameof(UserNotLinked));
                    }
                }
                
                public static class Admin
                {
                    private const string Base = Commands.Base + nameof(Admin) + ".";
                    
                    public static class Link
                    {
                        private const string Base = Admin.Base + nameof(Link) + ".";
                        
                        public static readonly TemplateKey Success = new(Base + nameof(Success));
                        
                        public static class Error
                        {
                            private const string Base = Link.Base + nameof(Error) + ".";
                            
                            public static readonly TemplateKey PlayerNotFound = new(Base + nameof(PlayerNotFound));
                            public static readonly TemplateKey PlayerAlreadyLinked = new(Base + nameof(PlayerAlreadyLinked));
                            public static readonly TemplateKey UserAlreadyLinked = new(Base + nameof(UserAlreadyLinked));
                        }
                    }
                    
                    public static class Unlink
                    {
                        private const string Base = Admin.Base + nameof(Unlink) + ".";
                        
                        public static readonly TemplateKey Success = new(Base + nameof(Success));
                        
                        public static class Error
                        {
                            private const string Base = Unlink.Base + nameof(Error) + ".";
                            
                            public static readonly TemplateKey MustSpecifyOne = new(Base + nameof(MustSpecifyOne));
                            public static readonly TemplateKey PlayerIsNotLinked = new(Base + nameof(PlayerIsNotLinked));
                            public static readonly TemplateKey UserIsNotLinked = new(Base + nameof(UserIsNotLinked));
                            public static readonly TemplateKey LinkNotSame = new(Base + nameof(LinkNotSame));
                        }
                    }
                    
                    public static class Search
                    {
                        private const string Base = Admin.Base + nameof(Search) + ".";
                        
                        public static readonly TemplateKey Success = new(Base + nameof(Success));
                        
                        public static class Error
                        {
                            private const string Base = Search.Base + nameof(Error) + ".";
                            
                            public static readonly TemplateKey PlayerNotFound = new(Base + nameof(PlayerNotFound));
                        }
                    }
                    
                    
                    public static class Unban
                    {
                        private const string Base = nameof(Unban) + ".";
                        
                        public static readonly TemplateKey Player = new(Base + nameof(Player));
                        public static readonly TemplateKey User = new(Base + nameof(User));
                        
                        public static class Error
                        {
                            private const string Base = Unban.Base + nameof(Error) + ".";
                            
                            public static readonly TemplateKey PlayerNotFound = new(Base + nameof(PlayerNotFound));
                            public static readonly TemplateKey PlayerNotBanned = new(Base + nameof(PlayerNotBanned));
                            public static readonly TemplateKey UserNotBanned = new(Base + nameof(UserNotBanned));
                        }
                    }
                }
            }
            
            public static class Link
            {
                private const string Base = nameof(Link) + ".";
                
                public static class Completed
                {
                    private const string Base = Link.Base + nameof(Completed) + ".";
                    
                    public static readonly TemplateKey Command = new(Base + nameof(Command));
                    public static readonly TemplateKey Admin = new(Base + nameof(Admin));
                    public static readonly TemplateKey Api = new(Base + nameof(Api));
                    public static readonly TemplateKey GuildRejoin = new(Base + nameof(GuildRejoin));
                    public static readonly TemplateKey InactiveRejoin = new(Base + nameof(InactiveRejoin));
                }
                
                public static class Declined
                {
                    private const string Base = Link.Base + nameof(Declined) + ".";
                    
                    public static readonly TemplateKey JoinWithUser = new(Base + nameof(JoinWithUser));
                    public static readonly TemplateKey JoinWithPlayer = new(Base + nameof(JoinWithPlayer));
                }
                
                public static class WelcomeMessage
                {
                    private const string Base = Link.Base + nameof(WelcomeMessage) + ".";
                    
                    public static readonly TemplateKey DmLinkAccounts = new(Base + nameof(DmLinkAccounts));
                    public static readonly TemplateKey GuildLinkAccounts = new(Base + nameof(GuildLinkAccounts));
                }
            }
            
            public static class Unlink
            {
                private const string Base = nameof(Unlink) + ".";
                
                public static class Completed
                {
                    private const string Base = Unlink.Base + nameof(Completed) + ".";
                    public static readonly TemplateKey Command = new(Base + nameof(Command));
                    public static readonly TemplateKey Admin = new(Base + nameof(Admin));
                    public static readonly TemplateKey Api = new(Base + nameof(Api));
                    public static readonly TemplateKey Inactive = new(Base + nameof(Inactive));
                }
            }
            
            public static class Banned
            {
                private const string Base = nameof(Banned) + ".";
                
                public static readonly TemplateKey PlayerBanned = new(Base + nameof(PlayerBanned));
            }
            
            public static class Join
            {
                private const string Base = nameof(Join) + ".";
                
                public static readonly TemplateKey CompleteLink = new(Base + nameof(CompleteLink));
            }
            
            public static class Errors
            {
                private const string Base = nameof(Errors) + ".";
                
                public static readonly TemplateKey UserAlreadyLinked = new(Base + nameof(UserAlreadyLinked));
                public static readonly TemplateKey PlayerAlreadyLinked = new(Base + nameof(PlayerAlreadyLinked));
                public static readonly TemplateKey CodeActivationNotFound = new(Base + nameof(CodeActivationNotFound));
                public static readonly TemplateKey LookupActivationNotFound = new(Base + nameof(LookupActivationNotFound));
                public static readonly TemplateKey MustBeCompletedInServer = new(Base + nameof(MustBeCompletedInServer));
            }
        }
        #endregion

    }

}


// --- End of file: DiscordCore.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-connect ---
// --- Original File Path: D/DiscordConnect/DiscordConnect.cs ---

ï»¿using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.DiscordObjects;

namespace Oxide.Plugins
{
    [Info("Discord Connect", "Iv Misticos", "1.0.11")]
    [Description("Discord account connection with API")]
    public class DiscordConnect : CovalencePlugin
    {
        #region Variables
        
        [DiscordClient]
        private DiscordClient _client = null;

        private static List<KeyInfo> _keys = new List<KeyInfo>();

        private static List<PlayerData> _data = new List<PlayerData>();

        private static DiscordConnect _ins;

        private static Time _time = GetLibrary<Time>();
        
        #endregion

        #region Configuration

        private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string Token = string.Empty;
            
            [JsonProperty(PropertyName = "Channel ID For Authentication Log")]
            public string AuthLogChannel = string.Empty;
            
            [JsonProperty(PropertyName = "Enable Bot Status")]
            public bool EnableStatus = true;
            
            [JsonProperty(PropertyName = "Bot Status")]
            public string Status = "Send me your code";
            
            [JsonProperty(PropertyName = "Group To Assign Once Connected")]
            public string GroupConnected = "discord-connected";
            
            [JsonProperty(PropertyName = "Group To Revoke Once Left")]
            public string GroupLeft = "discord-connected";
            
            [JsonProperty(PropertyName = "Delete Data On Discord Leave")]
            public bool DeleteData = false;
            
            [JsonProperty(PropertyName = "Allow Data Overwrite")]
            public bool OverwriteData = true;
            
            [JsonProperty(PropertyName = "Chat Prefix")]
            public string Prefix = "Auth";
            
            [JsonProperty(PropertyName = "Auth Command")]
            public string Command = "auth";
            
            [JsonProperty(PropertyName = "Code Lifetime")]
            public string CodeLifetime = "15m";

            [JsonIgnore] public uint ParsedCodeLifetime;
            
            [JsonProperty(PropertyName = "Code Length")]
            public int CodeLength = 6;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();
        
        #endregion

        #region Work with Data

        // Temporary
        private class KeyInfo
        {
            public IPlayer Player;
            public string Key;

            public uint ValidUntil;

            public static KeyInfo FindByID(string userId)
            {
                for (var i = 0; i < _keys.Count; i++)
                {
                    if (_keys[i].Player.Id == userId)
                        return _keys[i];
                }

                return null;
            }

            public static KeyInfo FindByKey(string key)
            {
                for (var i = 0; i < _keys.Count; i++)
                {
                    if (_keys[i].Key == key)
                        return _keys[i];
                }

                return null;
            }

            public void ExpireMessage()
            {
                Player.Reply(GetMsg("Code Expired", Player.Id), _config.Prefix);
            }

            public void ResetValidUntil()
            {
                ValidUntil = _time.GetUnixTimestamp() + _config.ParsedCodeLifetime;
            }
        }

        // Non-Temporary
        private class PlayerData
        {
            public string GameId;
            public string DiscordId;

            public static PlayerData FindByGame(string id)
            {
                for (var i = 0; i < _data.Count; i++)
                {
                    if (_data[i].GameId == id)
                        return _data[i];
                }

                return null;
            }

            public static PlayerData FindByDiscord(string id)
            {
                for (var i = 0; i < _data.Count; i++)
                {
                    if (_data[i].DiscordId == id)
                        return _data[i];
                }

                return null;
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _data);

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<List<PlayerData>>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null) _data = new List<PlayerData>();
        }
        
        #endregion
        
        #region Hooks
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Code Generation", "Here is your code: {code}"},
                {"Code Expired", "Your code has expired!"},
                {"Authenticated", "Thank you for authenticating your account!"},
                {"Already Authenticated", "You have already authenticated your account, no need to do it again!"},
                {"Unable To Find Code", "Sorry, we couldn't find your code. Try to authenticate again."},
                {"Log", "{discordName} ({discordId}) has authenticated his account to in-game {gameName} ({gameId})"},
                {"Discord Overwrite", "Your old connection with this Discord account will be overwritten!"},
                {"In-Game Overwrite", "Your old connection with this in-game account will be overwritten!"},
                {"Authentication Denied By Plugin", "Your authentication was denied by a plugin"}
            }, this);
        }

        private void Init()
        {
            _ins = this;
            
            var parsed = ConvertToSeconds(_config.CodeLifetime, out _config.ParsedCodeLifetime);
            if (!parsed)
            {
                PrintError("Unable to parse code lifetime");
                _config.ParsedCodeLifetime = 60;
            }

            if (!string.IsNullOrEmpty(_config.Token))
            {
                Discord.CreateClient(this, _config.Token);

                if (_config.EnableStatus)
                {
                    _client?.UpdateStatus(new Presence
                    {
                        Game = new Ext.Discord.DiscordObjects.Game
                        {
                            Name = _config.Status,
                            Type = ActivityType.Game
                        }
                    });
                }
            }
            
            AddCovalenceCommand(_config.Command, nameof(CommandAuth));
            
            LoadData();
            timer.Every(1f, DoExpiration);
        }

        private void OnServerSave() => SaveData();

        private void Unload()
        {
            SaveData();
            Discord.CloseClient(_client);
        }
        
        #region Discord Hooks
        
        // Called when a member leaves the Discord server
        private void Discord_MemberRemoved(GuildMember member)
        {
            // No user found
            var found = PlayerData.FindByDiscord(member?.user?.id);
            if (found == null)
                return;

            if (!string.IsNullOrEmpty(_config.GroupLeft))
            {
                var player = players.FindPlayerById(found.GameId);
                player?.RemoveFromGroup(_config.GroupLeft);
            }

            Interface.Oxide.CallHook("OnDiscordAuthLeave", found.GameId, found.DiscordId);

            // Disabled in config
            if (!_config.DeleteData)
                return;

            _data.Remove(found);
        }
        
        // Called when a message is created on the Discord server
        private void Discord_MessageCreate(Message message)
        {
            // Bot-check
            if (message.author.bot == true)
                return;

            Channel.GetChannel(_client, message.channel_id, channel =>
            {
                // DM-check
                if (channel.type != ChannelType.DM)
                    return;

                // No code found
                var info = KeyInfo.FindByKey(message.content);
                if (info == null)
                {
                    channel.CreateMessage(_client, GetMsg("Unable To Find Code"));
                    return;
                }

                var canAuthenticate = Interface.Oxide.CallHook("CanDiscordAuthenticate", info.Player.Id, message.author.id);
                if (canAuthenticate is bool && !(bool) canAuthenticate)
                {
                    channel.CreateMessage(_client, GetMsg("Authentication Denied By Plugin", info.Player.Id));
                    return;
                }

                // Already authenticated-check
                var data1 = PlayerData.FindByGame(info.Player.Id);
                var data2 = PlayerData.FindByDiscord(message.author.id);

                if (!_config.OverwriteData && (data1 != null || data2 != null))
                {
                    channel.CreateMessage(_client, GetMsg("Already Authenticated"));
                }
                else
                {
                    if (data1 != null)
                    {
                        channel.CreateMessage(_client, GetMsg("In-Game Overwrite", info.Player.Id));
                        Interface.Oxide.CallHook("OnDiscordAuthOverwrite", data1.GameId, info.Player.Id, data1.DiscordId,
                            message.author.id);
                        
                        _data.Remove(data1);
                    }

                    if (data2 != null)
                    {
                        channel.CreateMessage(_client, GetMsg("Discord Overwrite", info.Player.Id));
                        Interface.Oxide.CallHook("OnDiscordAuthOverwrite", data2.GameId, info.Player.Id, data2.DiscordId,
                            message.author.id);
                        
                        _data.Remove(data2);
                    }
                }

                // Adds to data file
                _data.Add(new PlayerData
                {
                    DiscordId = message.author.id,
                    GameId = info.Player.Id
                });

                channel.CreateMessage(_client, GetMsg("Authenticated", info.Player.Id));

                if (!string.IsNullOrEmpty(_config.AuthLogChannel))
                {
                    Channel.GetChannel(_client, _config.AuthLogChannel, logChannel =>
                    {
                        logChannel?.CreateMessage(_client,
                            new StringBuilder(GetMsg("Log")).Replace("{discordName}", message.author.username)
                                .Replace("{discordId}", message.author.id).Replace("{gameId}", info.Player.Id)
                                .Replace("{gameName}", info.Player.Name).ToString());
                    });
                }

                if (!string.IsNullOrEmpty(_config.GroupConnected))
                {
                    info.Player.AddToGroup(_config.GroupConnected);
                }
                
                Interface.Oxide.CallHook("OnDiscordAuthenticate", info.Player.Id, message.author.id);
            });
        }

        #endregion
        
        #endregion

        #region Commands
        
        private void CommandAuth(IPlayer player, string command, string[] args)
        {
            // Already authenticated-check
            if (PlayerData.FindByGame(player.Id) != null)
            {
                player.Reply(GetMsg("Already Authenticated", player.Id), _config.Prefix);
                return;
            }

            var info = KeyInfo.FindByID(player.Id);
            var code = GenerateCode();
            if (info == null)
            {
                info = new KeyInfo();
                _keys.Add(info);
            }

            info.Key = code;
            info.Player = player;
            info.ResetValidUntil();
            
            player.Reply(GetMsg("Code Generation", player.Id).Replace("{code}", code));
        }
        
        #endregion

        #region API

        private string GetDiscordOf(string id) => PlayerData.FindByGame(id)?.DiscordId;
        
        private string GetGameOf(string id) => PlayerData.FindByDiscord(id)?.GameId;

        #endregion
        
        #region Code Expiration

        private void DoExpiration()
        {
            var time = _time.GetUnixTimestamp();
            for (var i = _keys.Count - 1; i >= 0; i--)
            {
                var key = _keys[i];
                if (key.ValidUntil > time) continue;

                key.ExpireMessage();
                _keys.RemoveAt(i);
            }
        }
        
        #endregion

        #region Helpers
        
        private string GenerateCode()
        {
            var builder = new StringBuilder();
            while (builder.Length < _config.CodeLength)
            {
                builder.Append(Guid.NewGuid().ToString().Replace("-", ""));
            }

            builder.Length = _config.CodeLength;
            return builder.ToString();
        }

        private static string GetMsg(string key, string userId = null) => _ins.lang.GetMessage(key, _ins, userId);
        
        #endregion
        
        #region Parsers
        
        private static readonly Regex RegexStringTime = new Regex(@"(\d+)([dhms])", RegexOptions.Compiled);
        private static bool ConvertToSeconds(string time, out uint seconds)
        {
            seconds = 0;
            if (time == "0" || string.IsNullOrEmpty(time)) return true;
            var matches = RegexStringTime.Matches(time);
            if (matches.Count == 0) return false;
            for (var i = 0; i < matches.Count; i++)
            {
                var match = matches[i];
                // ReSharper disable once SwitchStatementMissingSomeCases
                switch (match.Groups[2].Value)
                {
                    case "d":
                    {
                        seconds += uint.Parse(match.Groups[1].Value) * 24 * 60 * 60;
                        break;
                    }
                    case "h":
                    {
                        seconds += uint.Parse(match.Groups[1].Value) * 60 * 60;
                        break;
                    }
                    case "m":
                    {
                        seconds += uint.Parse(match.Groups[1].Value) * 60;
                        break;
                    }
                    case "s":
                    {
                        seconds += uint.Parse(match.Groups[1].Value);
                        break;
                    }
                }
            }
            return true;
        }
        
        #endregion
    }
}


// --- End of file: DiscordConnect.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/death-notes-toggle ---
// --- Original File Path: D/DeathNotesToggle/DeathNotesToggle.cs ---

// Requires: DeathNotes

using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Death Notes Toggle", "0x2422", "0.0.7")]
    [Description("Allows players to toggle DeathNotes")]
    class DeathNotesToggle : RustPlugin
    {
        [PluginReference] private Plugin DeathNotes;
        
        private bool ShowInConsole => DeathNotes.Config.Get<bool>("Show Kills in Console");
        private bool ShowInChat => DeathNotes.Config.Get<bool>("Show Kills in Chat");
        private string ChatFormat => DeathNotes.Config.Get<string>("Chat Format");
        private string ChatIcon => DeathNotes.Config.Get<string>("Chat Icon (SteamID)");
        private int MessageRadius => DeathNotes.Config.Get<int>("Message Broadcast Radius (in meters)");
        private bool RequirePermission => DeathNotes.Config.Get<bool>("Require Permission (deathnotes.cansee)");

        #region Hooks

        private void Init() => LoadData();
        private void Unload() => SaveData(); 
        private void OnServerSave() => timer.Once(UnityEngine.Random.Range(0f, 60f), SaveData);
        
        private void Loaded()
        {
            if (DeathNotes == null)
                Interface.Oxide.LogError("Death Notes is not loaded!");
        }

        #endregion
        
        #region Commands

        [ChatCommand("dnt")]
        private void CmdToggleDeathNotes(BasePlayer player, string command, string[] args)
        {
            if (_storedData.PlayerData.ContainsKey(player.userID))
                _storedData.PlayerData[player.userID] = !_storedData.PlayerData[player.userID];
            else
                _storedData.PlayerData.Add(player.userID, false);

            var statusKey = _storedData.PlayerData[player.userID] ? "On" : "Off";
            var status = GetMessage(player, statusKey);
            Player.Message(player, GetMessage(player, "ToggleStatus", status));
        }
        #endregion
        
        #region DeathNotesHook

        object OnDeathNotice(Dictionary<string, object> data, string message)
        {
            var subscribers = new Dictionary<ulong, bool>();
            foreach (var player in _storedData.PlayerData)
                subscribers.Add(player.Key, player.Value);

            if (ShowInChat)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (subscribers.Keys.Contains(player.userID) && !subscribers[player.userID])
                        continue;

                    if (RequirePermission && !permission.UserHasPermission(player.UserIDString, DeathNotesCopy.Permission))
                        continue;

                    if (MessageRadius != -1 && player.Distance(data["VictimEntity"] as BaseCombatEntity) > MessageRadius)
                        continue;

                    var formattedMessage = ChatFormat == null ? message : ChatFormat.Replace("{message}", message);
                    Player.Message(player, formattedMessage, ulong.Parse(ChatIcon));
                }
            }

            if (ShowInConsole)
                DeathNotesCopy.Puts((string)DeathNotes.Call("StripRichText", message));
            
            return false;
        }

        private static class DeathNotesCopy
        {
            internal const string Permission = "deathnotes.cansee";

            public static void Puts(string format, params object[] args) => 
                Interface.Oxide.LogInfo("[{0}] {1}", "Death Notes", args.Length != 0 ? string.Format(format, args) : format);
        }

        #endregion
        
        #region Data

        private StoredData _storedData;

        private class StoredData
        {
            public readonly Dictionary<ulong, bool> PlayerData = new Dictionary<ulong, bool>();
        }

        private void LoadData()
        {
            try { _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name); }
            catch { _storedData = null; }
            finally { if (_storedData == null) ClearData(); }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);

        private void ClearData()
        {
            _storedData = new StoredData();
            SaveData();
        }

        #endregion

        #region l18n
        
        private string GetMessage(BasePlayer player, string key, params object[] args) => 
            string.Format(lang.GetMessage(key, this, player.UserIDString), args);

        protected override void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                ["ToggleStatus"] = "Death Notes are now {0}.",
                ["Off"] = "off",
                ["On"] = "on",
            };
            lang.RegisterMessages(messages, this);
        }

        #endregion
    }
}

// --- End of file: DeathNotesToggle.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-wipe ---
// --- Original File Path: D/DiscordWipe/DiscordWipe.cs ---

ï»¿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

#if RUST
using UnityEngine.Networking;
using System.Collections;
using System.IO;
using ConVar;
#endif

namespace Oxide.Plugins;

[Info("Discord Wipe", "MJSU", "2.4.3")]
[Description("Sends a notification to a discord channel when the server wipes or protocol changes")]
internal class DiscordWipe : CovalencePlugin
{
    #region Class Fields

    [PluginReference] private Plugin RustMapApi, PlaceholderAPI;
        
    private PluginConfig _pluginConfig; //Plugin Config
    private StoredData _storedData; //Plugin Data

    private const string DefaultUrl = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
    private const string DefaultRustMapsApiKey = "Get Your API Key @ https://rustmaps.com/dashboard";
    private const string AdminPermission = "discordwipe.admin";
    private const string AttachmentBase = "attachment://";
    private const string MapAttachment = AttachmentBase + MapFilename;
    private const string MapFilename = "map.jpg";
    private const int MaxImageSize = 8 * 1024 * 1024;
        
    private string _protocol;
    private string _previousProtocol;
    private bool _hasStarted;

    private readonly StringBuilder _parser = new();
    private Action<IPlayer, StringBuilder, bool> _replacer;
        
    private enum DebugEnum {Message, None, Error, Warning, Info}
    public enum SendMode {Always, Random}
    private enum EncodingMode {Jpg = 1, Png = 2}

#if RUST
    private enum RustMapMode {None, RustMaps, RustMapApi}
    private RustMapsResponse _rustMapsResponse;
#endif
    #endregion

    #region Setup & Loading
    private void Init()
    {
        UnsubscribeAll();
        AddCovalenceCommand(_pluginConfig.Command, nameof(SendWipeCommand));

        _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
        _previousProtocol = _storedData.Protocol;
            
        permission.RegisterPermission(AdminPermission, this);
            
        _pluginConfig.ProtocolWebhook = UpdateWebhookUrl(_pluginConfig.ProtocolWebhook);
        _pluginConfig.WipeWebhook =  UpdateWebhookUrl(_pluginConfig.WipeWebhook);

        foreach (DiscordMessageConfig embed in _pluginConfig.WipeEmbeds)
        {
            if (!string.IsNullOrEmpty(embed.WebhookOverride) && embed.WebhookOverride != DefaultUrl)
            {
                embed.WebhookOverride = UpdateWebhookUrl(embed.WebhookOverride);
            }
        }
            
        foreach (DiscordMessageConfig embed in _pluginConfig.ProtocolEmbeds)
        {
            if (!string.IsNullOrEmpty(embed.WebhookOverride) && embed.WebhookOverride != DefaultUrl)
            {
                embed.WebhookOverride = UpdateWebhookUrl(embed.WebhookOverride);
            }
        }

#if RUST
        _rustMapGenerateHeaders["X-API-Key"] = _pluginConfig.ImageSettings.RustMaps.ApiKey;
        _rustMapGetHeaders["X-API-Key"] = _pluginConfig.ImageSettings.RustMaps.ApiKey;
#endif
            
    }

    public string UpdateWebhookUrl(string url)
    {
        return url.Replace("/api/webhooks", "/api/v10/webhooks").Replace("https://discordapp.com/", "https://discord.com/");
    }
        
    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            [LangKeys.NoPermission] = "You do not have permission to use this command",
            [LangKeys.SentWipe] = "You have sent a test wipe message",
            [LangKeys.SentProtocol] = "You have sent a test protocol message",
            [LangKeys.Help] = "Sends test message for plugin\n" +
                              "{0}{1} wipe - sends a wipe test message\n" +
                              "{0}{1} protocol - sends a protocol test message\n" +
                              "{0}{1} - displays this help text again" ,
        }, this);
    }
        
    protected override void LoadDefaultConfig()
    {
        PrintWarning("Loading Default Config");
    }

    protected override void LoadConfig()
    {
        base.LoadConfig();
        Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
        _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
        Config.WriteObject(_pluginConfig);
    }

    private PluginConfig AdditionalConfig(PluginConfig config)
    {
        config.WipeEmbeds ??= new List<DiscordMessageConfig> { 
            new()
            {
                Content = "@everyone",
                SendMode = SendMode.Always,
                Embed = new EmbedConfig
                {
                    Title = "{server.name}",
                    Description = "The server has wiped!",
                    Url = string.Empty,
                    Color = "#de8732",
                    Image = MapAttachment,
                    Thumbnail = string.Empty,
                    Fields = new List<FieldConfig>
                    {
#if RUST
                        new()
                        {
                            Title = "Seed",
                            Value = "[{world.seed}](https://rustmaps.com/map/{world.size}_{world.seed})",
                            Inline = true,
                            Enabled = true
                        },
                        new()
                        {
                            Title = "Size",
                            Value = "{world.size}M ({world.size!km^2}km^2)",
                            Inline = true,
                            Enabled = true
                        },
                        new()
                        {
                            Title = "Protocol",
                            Value = "{server.protocol.network}",
                            Inline = true,
                            Enabled = true
                        },
#endif
                        new()
                        {
                            Title = "Click & Connect",
                            Value = "steam://connect/{server.address}:{server.port}",
                            Inline = false,
                            Enabled = true
                        }
                    },
                    Footer = new FooterConfig
                    {
                        IconUrl = string.Empty,
                        Text = string.Empty,
                        Enabled = true
                    },
                    Enabled = true
                }
            }};
            
        config.ProtocolEmbeds ??= new List<DiscordMessageConfig> { 
            new()
            {
                Content = "@everyone",
                SendMode = SendMode.Always,
                Embed = new EmbedConfig
                {
                    Title = "{server.name}",
                    Description = "The server protocol has changed!",
                    Url = string.Empty,
                    Color = "#de8732",
                    Image = string.Empty,
                    Thumbnail = string.Empty,
                    Fields = new List<FieldConfig>
                    {
                        new()
                        {
                            Title = "Protocol",
                            Value = "{server.protocol.network}",
                            Inline = true,
                            Enabled = true
                        },
                        new()
                        {
                            Title = "Previous Protocol",
                            Value = "{server.protocol.previous}",
                            Inline = true,
                            Enabled = true
                        },
                        new()
                        {
                            Title = "Mandatory Client Update",
                            Value = "This update requires a mandatory client update in order to be able to play on the server",
                            Inline = false,
                            Enabled = true
                        },
                        new()
                        {
                            Title = "Click & Connect",
                            Value = "steam://connect/{server.address}:{server.port}",
                            Inline = false,
                            Enabled = true
                        }
                    },
                    Footer = new FooterConfig
                    {
                        IconUrl = string.Empty,
                        Text = string.Empty,
                        Enabled = true
                    },
                    Enabled = true
                }
            }};

#if RUST
        config.ImageSettings = new RustMapImageSettings
        {
            MapMode = config.ImageSettings?.MapMode ?? (RustMapApi != null ? RustMapMode.RustMapApi : RustMapMode.None),
            RustMapApi = new RustMapApiSettings
            {
                Name = config.ImageSettings?.RustMapApi?.Name ?? "Icons",
                Scale = config.ImageSettings?.RustMapApi?.Scale ?? 0.5f,
                FileType = config.ImageSettings?.RustMapApi?.FileType ?? EncodingMode.Jpg
            },
            RustMaps = new RustMapSettings
            {
                ApiKey = config.ImageSettings?.RustMaps?.ApiKey ?? "Get Your API Key @ https://rustmaps.com/user/profile",
                Staging = config.ImageSettings?.RustMaps?.Staging ?? false
            }
        };
#endif

        foreach (DiscordMessageConfig embed in config.WipeEmbeds)
        {
            if (string.IsNullOrEmpty(embed.WebhookOverride))
            {
                embed.WebhookOverride = DefaultUrl;
            }
        }
            
        foreach (DiscordMessageConfig embed in config.ProtocolEmbeds)
        {
            if (string.IsNullOrEmpty(embed.WebhookOverride))
            {
                embed.WebhookOverride = DefaultUrl;
            }
        }

        return config;
    }
        
    private void OnServerInitialized()
    {
        _protocol = GetProtocol();
        if (PlaceholderAPI is not { IsLoaded: true })
        {
            PrintError("Missing plugin dependency PlaceholderAPI: https://umod.org/plugins/placeholder-api");
            return;
        }
            
        if(PlaceholderAPI.Version < new VersionNumber(2, 2, 0))
        {
            PrintError("Placeholder API plugin must be version 2.2.0 or higher");
            return;
        }

#if RUST
        if (IsRustMapApiLoaded() && _pluginConfig.ImageSettings.MapMode == RustMapMode.RustMapApi)
        {
            if(RustMapApi.Version < new VersionNumber(1,3,2))
            {
                PrintError("RustMapApi plugin must be version 1.3.2 or higher");
                return;
            }
                
            if (!IsRustMapApiReady())
            {
                Debug(DebugEnum.Info, "Waiting for Rust Maps Api Plugin to be Ready");
                SubscribeAll();
                return;
            }
        }

        if (_pluginConfig.ImageSettings.MapMode == RustMapMode.RustMaps && !string.IsNullOrEmpty(_pluginConfig.ImageSettings.RustMaps.ApiKey) && _pluginConfig.ImageSettings.RustMaps.ApiKey != DefaultRustMapsApiKey)
        {
            Debug(DebugEnum.Info, "Loading Map from RustMaps.com");
            GetRustMapsMap();
            //timer.In(15 * 60f, HandleStartup);
            return;
        }
#endif

        //Delayed so PlaceholderAPI can be ready before we call
        timer.In(1f, () => HandleStartup("OnServerInit"));
    }

    private void OnRustMapApiReady()
    {
        HandleStartup("OnRustMapApiReady");
    }
        
    private void HandleStartup(string source)
    {
        Debug(DebugEnum.Info, $"HandleStartup - {source}");
        if (_hasStarted)
        {
            Debug(DebugEnum.Info, "HandleStartup - Skipping as already started");
            return;
        }

        _hasStarted = true;
            
        if (string.IsNullOrEmpty(_storedData.Protocol))
        {
            Debug(DebugEnum.Info, $"HandleStartup - Protocol is not set setting protocol to: {_protocol}");
            _storedData.Protocol = _protocol;
            SaveData();
        }
        else if (_storedData.Protocol != _protocol)
        {
            Debug(DebugEnum.Info, $"HandleStartup - Protocol has changed {_storedData.Protocol} -> {_protocol}");
            if (_pluginConfig.SendProtocolAutomatically)
            {
                SendProtocol();
            }
            _storedData.Protocol = _protocol;
            SaveData();
            Puts("Protocol notification sent");
        }
        else
        {
            Debug(DebugEnum.Info, "HandleStartup - Protocol has not changed");
        }
            
        if (_storedData.IsWipe)
        {
            if (_pluginConfig.SendWipeAutomatically)
            {
                Debug(DebugEnum.Info, "HandleStartup - IsWipe is set. Sending wipe message.");
                SendWipe();
                Puts("Wipe notification sent");
            }
            else
            {
                Debug(DebugEnum.Info, "SendWipeAutomatically is disabled");
            }
            _storedData.IsWipe = false;
            SaveData();
        }
        else
        {
            Debug(DebugEnum.Info, "HandleStartup - Not a wipe");
        }
    }

    private void OnNewSave()
    {
        _storedData.IsWipe = true;
        Debug(DebugEnum.Info, "OnNewSave - Wipe Detected");
        SaveData();
    }

    private void Unload()
    {
        SaveData();
    }
        
    private string GetProtocol()
    {
#if RUST
        return Rust.Protocol.network.ToString();
#else 
            return covalence.Server.Protocol;
#endif
    }
    #endregion

    #region Command
    private bool SendWipeCommand(IPlayer player, string cmd, string[] args)
    {
        if (!HasPermission(player, AdminPermission))
        {
            player.Message(Lang(LangKeys.NoPermission, player));
            return true;
        }

        Debug(DebugEnum.Info, $"SendWipeCommand command called: {string.Join(" ", args)}");
            
        string commandPrefix = player.IsServer ? "" : "/";
        if (args.Length == 0)
        {
            player.Message(Lang(LangKeys.Help, player, commandPrefix, _pluginConfig.Command));
            return true;
        }
            
        switch (args[0].ToLower())
        {
            case "wipe":
                SendWipe();
                player.Message(Lang(LangKeys.SentWipe, player));
                break;
                
            case "protocol":
                SendProtocol();
                player.Message(Lang(LangKeys.SentProtocol, player));
                break;
                
            default:
                player.Message(Lang(LangKeys.Help, player,commandPrefix, _pluginConfig.Command));
                break;
        }
            
        return true;
    }
    #endregion

    #region Message Handling
    private void SendWipe()
    {
        Debug(DebugEnum.Info, "SendWipe - Sending wipe message");
        if (string.IsNullOrEmpty(_pluginConfig.WipeWebhook) || _pluginConfig.WipeWebhook == DefaultUrl)
        {
            Debug(DebugEnum.Info, "SendWipe - Wipe message not sent due to Wipe Webhook being blank or matching the default url");
            return;
        }

        List<DiscordMessageConfig> messages = _pluginConfig.WipeEmbeds
            .Where(w => w.SendMode == SendMode.Always)
            .ToList();
            
        DiscordMessageConfig random = _pluginConfig.WipeEmbeds
            .Where(w => w.SendMode == SendMode.Random)
            .OrderBy(w => Guid.NewGuid())
            .FirstOrDefault();

        if (random != null)
        {
            messages.Add(random);
        }

        SendMessage(_pluginConfig.WipeWebhook, messages);
        Debug(DebugEnum.Message, "");
    }

    private void SendProtocol()
    {
        Debug(DebugEnum.Info, "SendProtocol - Sending protocol message");
        if (string.IsNullOrEmpty(_pluginConfig.ProtocolWebhook) || _pluginConfig.ProtocolWebhook == DefaultUrl)
        {
            Debug(DebugEnum.Info, "SendProtocol - Protocol message not sent due to Protocol Webhook being blank or matching the default url");
            return;
        }
            
        List<DiscordMessageConfig> messages = _pluginConfig.ProtocolEmbeds
            .Where(w => w.SendMode == SendMode.Always)
            .ToList();
            
        DiscordMessageConfig random = _pluginConfig.ProtocolEmbeds
            .Where(w => w.SendMode == SendMode.Random)
            .OrderBy(w => Guid.NewGuid())
            .FirstOrDefault();

        if (random != null)
        {
            messages.Add(random);
        }
            
        SendMessage(_pluginConfig.ProtocolWebhook, messages);
    }

    private void SendMessage(string url, List<DiscordMessageConfig> messageConfigs)
    {
        for (int index = 0; index < messageConfigs.Count; index++)
        {
            DiscordMessageConfig messageConfig = messageConfigs[index];
            DiscordMessage message = ParseMessage(messageConfig);

            timer.In(index + 1, () =>
            {
#if RUST
                List<Attachment> attachments = new();

                Debug(DebugEnum.Info, $"SendMessage - MapMode={_pluginConfig.ImageSettings.MapMode.ToString()}");
                if (_pluginConfig.ImageSettings.MapMode == RustMapMode.RustMapApi)
                {
                    AttachMap(attachments, messageConfig);
                }

                if (!string.IsNullOrEmpty(messageConfig.WebhookOverride) && messageConfig.WebhookOverride != DefaultUrl)
                {
                    url = messageConfig.WebhookOverride;
                }
                    
                SendDiscordAttachmentMessage(url, message, attachments);
#else
                SendDiscordMessage(url, message);
#endif
            });
        }
    }
    #endregion
        
#if RUST
    private void AttachMap(List<Attachment> attachments, DiscordMessageConfig messageConfig)
    {
        Debug(DebugEnum.Info, $"Can attach map? RustMapApi Loaded: {IsRustMapApiLoaded()} RustMapApiReady: {IsRustMapApiReady()} Attachment Base:{messageConfig.Embed.Image.StartsWith(AttachmentBase)}");
        if (IsRustMapApiLoaded() && IsRustMapApiReady() && messageConfig.Embed.Image.StartsWith(AttachmentBase))
        {
            Debug(DebugEnum.Info, "AttachMap - RustMapApi is ready, attaching map");
            List<string> maps = RustMapApi.Call<List<string>>("GetSavedMaps");
            string mapName = _pluginConfig.ImageSettings.RustMapApi.Name;
            if (maps != null)
            {
                mapName = maps.FirstOrDefault(m => m.Equals(mapName, StringComparison.InvariantCultureIgnoreCase));
                if (string.IsNullOrEmpty(mapName))
                {
                    PrintWarning($"Map name not found {_pluginConfig.ImageSettings.RustMapApi.Name}. Valid names are {string.Join(", ", maps.ToArray())}");
                    mapName = "Icons";
                }
            }
                
            Debug(DebugEnum.Info, $"AttachMap - RustMapApi map name set to: {mapName}");
            int resolution = (int) (World.Size * _pluginConfig.ImageSettings.RustMapApi.Scale);
            AttachmentContentType contentType = _pluginConfig.ImageSettings.RustMapApi.FileType == EncodingMode.Jpg ? AttachmentContentType.Jpg : AttachmentContentType.Png; 
            object response = RustMapApi.Call("CreatePluginImage", this, mapName, resolution, (int)_pluginConfig.ImageSettings.RustMapApi.FileType);
            if (response is string)
            {
                PrintError($"An error occurred creating the plugin image: {response}");
                return;
            }

            Hash<string, object> map = response as Hash<string, object>;
            if (map?["image"] is byte[] mapData)
            {
                if (mapData.Length >= 8 * 1024 * 1024)
                {
                    PrintError( "Map Image too large. " +
                                $"Image size is {mapData.Length / 1024.0 / 1024.0:0.00}MB. " +
                                $"Max size is {MaxImageSize / 1024 / 1024}MB. " +
                                "Please reduce the \"Image Resolution Scale\"");
                }
                else
                {
                    attachments.Add(new Attachment(mapData, MapFilename, contentType));
                    Debug(DebugEnum.Info, "AttachMap - Successfully attached map");
                }
                    
            }
            else
            {
                Debug(DebugEnum.Warning, "AttachMap - MapData was null!!!");
            }
        }
    }

    #region RustMaps.com
    private readonly Dictionary<string, string> _rustMapGenerateHeaders = new()
    {
        ["Content-Type"] = "application/json",
    };
        
    private readonly Dictionary<string, string> _rustMapGetHeaders = new();

    public void GetRustMapsMap()
    {
        Debug(DebugEnum.Info, $"{nameof(GetRustMapsMap)} - Convar.Server.levelurl: \"{ConVar.Server.levelurl}\"");
        if (string.IsNullOrEmpty(ConVar.Server.levelurl) || (ConVar.Server.levelurl.StartsWith("https://files.facepunch.com/rust/maps") && ConVar.Server.levelurl.Contains("proceduralmap.")))
        {
            uint seed = World.Seed;
            uint size = World.Size;
            
            string url = $"https://api.rustmaps.com/v4/maps/{size}/{seed}?staging={_pluginConfig.ImageSettings.RustMaps.Staging}";
            Debug(DebugEnum.Info, $"RustMaps.com Requesting Rust Map. Url: {url}");
            webrequest.Enqueue(url, null, (code, response) => RustMapsGetCallback(code, response, false), this, RequestMethod.GET, _rustMapGetHeaders);
        }
        else if(ConVar.Server.levelurl.StartsWith("https://maps.rustmaps.com"))
        {
            Regex regex = new(@"https:\/\/maps\.rustmaps\.com\/\d*\/([a-z\d]*)\/");
            string match = regex.Match(ConVar.Server.levelurl).Groups[1].Value;
            if (!string.IsNullOrEmpty(match))
            {
                string url = $"https://api.rustmaps.com/v4/maps/{match}";
                Debug(DebugEnum.Info, $"RustMaps.com Requesting Rust Map. Url: {url}");
                webrequest.Enqueue(url, null, (code, response) => RustMapsGetCallback(code, response, true), this, RequestMethod.GET, _rustMapGetHeaders);
            }
        }
    }

    private void RustMapsGetCallback(int code, string response, bool isCustom)
    {
        if (code == 409)
        {
            Debug(DebugEnum.Message, "RustMaps.com is still generating the map image. Trying again in 60 seconds.");
            timer.In(60f, GetRustMapsMap);
        }
        else if (!isCustom && code == 404)
        {
            Debug(DebugEnum.Message, $"RustMaps.com map does not exist. Requesting Generation.\n{response}");
            RustMapsRequestMap();
        }
        else if (code == 200)
        {
            Debug(DebugEnum.Info, "RustMaps.com map image found.");
            _rustMapsResponse = JsonConvert.DeserializeObject<RustMapsResponse>(response);
            HandleStartup("RustMapsGetCallback");
        }
        else
        {
            Debug(DebugEnum.Error,$"An error occured trying to get map image from RustMaps.com - Code:{code} Response:\n{response}");
            timer.In(60f, GetRustMapsMap);
        }
    }

    public void RustMapsRequestMap()
    {
        Debug(DebugEnum.Info, "RustMaps.com Generating Rust Map.");
        RustMapsApiRequest request = new()
        {
            Size = World.Size,
            Seed = World.Seed,
            Staging = _pluginConfig.ImageSettings.RustMaps.Staging
        };

        string json = JsonConvert.SerializeObject(request);
        Debug(DebugEnum.Info, json);
            
        webrequest.Enqueue("https://api.rustmaps.com/v4/maps", json, RustMapsPostCallback, this, RequestMethod.POST, _rustMapGenerateHeaders);
    }

    private void RustMapsPostCallback(int code, string response)
    {
        if (code == 201)
        {
            Debug(DebugEnum.Info, "RustMaps.com image requested successfully.");
            timer.In(60f, GetRustMapsMap);
        }
        else if (code == 409)
        {
            Debug(DebugEnum.Info, "RustMaps.com map already exists. Requesting image.");
            GetRustMapsMap();
        }
        else
        {
            Debug(DebugEnum.Error,$"An error occured trying to request map generation from RustMaps.com - Code:{code} Response:\n{response}");
            timer.In(60f, GetRustMapsMap);
        }
    }
    #endregion
#endif
        
    #region PlaceholderAPI
    private string ParseField(string field)
    {
        _parser.Length = 0;
        _parser.Append(field);
        GetReplacer()?.Invoke(null, _parser, false);
        return _parser.ToString();
    }
        
    private void OnPluginUnloaded(Plugin plugin)
    {
        if (plugin?.Name == "PlaceholderAPI")
        {
            _replacer = null;
        }
    }
        
    private void OnPlaceholderAPIReady()
    {
        RegisterPlaceholder("server.protocol.previous", (player, s) => _previousProtocol, "Displays the previous protocol version if it changed during the last restart", double.MaxValue);
        RegisterPlaceholder("timestamp.now", (player, s) => UnixTimeNow(), "Displays the current unix timestamp", double.MaxValue);
#if RUST
        RegisterPlaceholder("rustmaps.com.map", (player, s) => _rustMapsResponse?.Data?.ImageUrl ?? string.Empty, "RustMaps.com map image url", double.MaxValue);
        RegisterPlaceholder("rustmaps.com.icons", (player, s) => _rustMapsResponse?.Data?.ImageIconUrl ?? string.Empty, "RustMaps.com icon map image url", double.MaxValue);
        RegisterPlaceholder("rustmaps.com.thumbnail", (player, s) => _rustMapsResponse?.Data?.ThumbnailUrl ?? string.Empty, "RustMaps.com thumbnail map image url", double.MaxValue);
#endif
    }

    private void RegisterPlaceholder(string key, Func<IPlayer, string, object> action, string description = null, double ttl = double.NaN)
    {
        if (IsPlaceholderApiLoaded())
        {
            PlaceholderAPI.Call("AddPlaceholder", this, key, action, description, ttl);
        }
    }
        
    private Action<IPlayer, StringBuilder, bool> GetReplacer()
    {
        if (!IsPlaceholderApiLoaded())
        {
            return _replacer;
        }
            
        return _replacer ?? (_replacer = PlaceholderAPI.Call<Action<IPlayer, StringBuilder, bool>>("GetProcessPlaceholders", 1));
    }

    private bool IsPlaceholderApiLoaded() => PlaceholderAPI != null && PlaceholderAPI.IsLoaded;
    #endregion

    #region Helpers
    public long UnixTimeNow()
    {
        TimeSpan timeSpan = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0);
        return (long)timeSpan.TotalSeconds;
    }
        
    public void UnsubscribeAll()
    {
        Unsubscribe(nameof(OnRustMapApiReady));
    }

    public void SubscribeAll()
    {
        Subscribe(nameof(OnRustMapApiReady));
    }
        
    private void Debug(DebugEnum level, string message)
    {
        if (level > _pluginConfig.DebugLevel)
        {
            return;
        }

        switch (level)
        {
            case DebugEnum.Error:
                PrintError(message);
                break;
            case DebugEnum.Warning:
                PrintWarning(message);
                break;
            default:
                Puts($"{level}: {message}");
                break;
        }
    }

    private string Lang(string key, IPlayer player = null, params object[] args)
    {
        try
        {
            return string.Format(lang.GetMessage(key, this, player?.Id), args);
        }
        catch(Exception ex)
        {
            PrintError($"Lang Key '{key}' threw exception\n:{ex.Message}");
            throw;
        }
    }

    private bool IsRustMapApiLoaded() => RustMapApi is { IsLoaded: true };
    private bool IsRustMapApiReady() => RustMapApi.Call<bool>("IsReady");

    private void SaveData()
    {
        if (_storedData != null)
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);
        }
    }

    private bool HasPermission(IPlayer player, string perm) => permission.UserHasPermission(player.Id, perm);
    #endregion

    #region Classes
    private class PluginConfig
    {
        [JsonConverter(typeof(StringEnumConverter))]
        [DefaultValue(DebugEnum.Warning)]
        [JsonProperty(PropertyName = "Debug Level (None, Error, Warning, Info)")]
        public DebugEnum DebugLevel { get; set; }
            
        [DefaultValue("dw")]
        [JsonProperty(PropertyName = "Command")]
        public string Command { get; set; }
            
#if RUST
        [JsonProperty(PropertyName = "Rust Map Image Settings")]
        public RustMapImageSettings ImageSettings { get; set; }
#endif
            
        [DefaultValue(true)]
        [JsonProperty(PropertyName = "Send wipe message when server wipes")]
        public bool SendWipeAutomatically { get; set; }
            
        [DefaultValue(DefaultUrl)]
        [JsonProperty(PropertyName = "Wipe Webhook url")]
        public string WipeWebhook { get; set; }
            
        [DefaultValue(true)]
        [JsonProperty(PropertyName = "Send protocol message when server protocol changes")]
        public bool SendProtocolAutomatically { get; set; }
            
        [DefaultValue(DefaultUrl)]
        [JsonProperty(PropertyName = "Protocol Webhook url")]
        public string ProtocolWebhook { get; set; }
            
        [JsonProperty(PropertyName = "Wipe messages")]
        public List<DiscordMessageConfig> WipeEmbeds { get; set; }
            
        [JsonProperty(PropertyName = "Protocol messages")]
        public List<DiscordMessageConfig> ProtocolEmbeds { get; set; }
    }
        
    public class RustMapsApiRequest
    {
        [JsonProperty("size")]
        public uint Size { get; set; }

        [JsonProperty("seed")]
        public uint Seed { get; set; }

        [JsonProperty("staging")]
        public bool Staging { get; set; }

        [JsonProperty("barren")]
        public bool Barren { get; set; }
    }


#if RUST
    private class RustMapImageSettings
    {
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "Map Image Source (None, RustMaps, RustMapApi)")]
        public RustMapMode MapMode { get; set; }
            
        [JsonProperty(PropertyName = "RustMaps.com Settings")]
        public RustMapSettings RustMaps { get; set; }
            
        [JsonProperty(PropertyName = "RustMapApi Settings")]
        public RustMapApiSettings RustMapApi { get; set; }
    }

    private class RustMapSettings
    {
        [JsonProperty(PropertyName = "RustMap.com API Key")]
        public string ApiKey { get; set; }
            
        [JsonProperty(PropertyName = "Generate Staging Map")]
        public bool Staging { get; set; }
    }

    private class RustMapApiSettings
    {
        [DefaultValue("Icons")]
        [JsonProperty(PropertyName = "Render Name")]
        public string Name { get; set; }
            
        [DefaultValue(0.5f)]
        [JsonProperty(PropertyName = "Image Resolution Scale")]
        public float Scale { get; set; }            
            
        [JsonConverter(typeof(StringEnumConverter))]
        [DefaultValue(EncodingMode.Jpg)]
        [JsonProperty(PropertyName = "File Type (Jpg, Png")]
        public EncodingMode FileType { get; set; }
    }

    public class RustMapsResponse
    {
        [JsonProperty("data")]
        public RustMapsData Data { get; set; }
    }
        
    public class RustMapsData
    {
        [JsonProperty("imageUrl")]
        public string ImageUrl { get; set; }
            
        [JsonProperty("imageIconUrl")]
        public string ImageIconUrl { get; set; }
            
        [JsonProperty("thumbnailUrl")]
        public string ThumbnailUrl { get; set; }
    }
#endif
        
    private class StoredData
    {
        public bool IsWipe { get; set; }
        public string Protocol { get; set; }
    }

    private class LangKeys
    {
        public const string NoPermission = "NoPermission";
        public const string SentWipe = "SentWipe";
        public const string SentProtocol = "SentProtocol";
        public const string Help = "Help";
    }
    #endregion
        
    #region Discord Embed
    #region Send Embed Methods
    /// <summary>
    /// Headers when sending an embeded message
    /// </summary>
    private readonly Dictionary<string, string> _headers = new()
    {
        {"Content-Type", "application/json"}
    };

    /// <summary>
    /// Sends the DiscordMessage to the specified webhook url
    /// </summary>
    /// <param name="url">Webhook url</param>
    /// <param name="message">Message being sent</param>
    private void SendDiscordMessage(string url, DiscordMessage message)
    {
        StringBuilder json = message.ToJson();
        if (_pluginConfig.DebugLevel >= DebugEnum.Info)
        {
            Debug(DebugEnum.Info, $"{nameof(SendDiscordMessage)} message.ToJson()\n{json}");
        }
            
        webrequest.Enqueue(url, json.ToString(), SendDiscordMessageCallback, this, RequestMethod.POST, _headers);
    }

    /// <summary>
    /// Callback when sending the embed if any errors occured
    /// </summary>
    /// <param name="code">HTTP response code</param>
    /// <param name="message">Response message</param>
    private void SendDiscordMessageCallback(int code, string message)
    {
        if (code != 204)
        {
            PrintError(message);
        }
    }

#if RUST
    /// <summary>
    /// Sends the DiscordMessage to the specified webhook url with attachments
    /// </summary>
    /// <param name="url">Webhook url</param>
    /// <param name="message">Message being sent</param>
    /// <param name="files">Attachments to be added to the DiscordMessage</param>
    private void SendDiscordAttachmentMessage(string url, DiscordMessage message, List<Attachment> files)
    {
        StringBuilder json = message.ToJson();
        if (_pluginConfig.DebugLevel >= DebugEnum.Info)
        {
            Debug(DebugEnum.Info, $"{nameof(SendDiscordAttachmentMessage)} message.ToJson()\n{json}");
        }

        List<IMultipartFormSection> formData = new()
        {
            new MultipartFormDataSection("payload_json", json.ToString())
        };

        for (int i = 0; i < files.Count; i++)
        {
            Attachment attachment = files[i];
            formData.Add(new MultipartFormFileSection($"file{i + 1}", attachment.Data, attachment.Filename, attachment.ContentType));
        }

        InvokeHandler.Instance.StartCoroutine(SendDiscordAttachmentMessageHandler(url, formData));
    }

    private IEnumerator SendDiscordAttachmentMessageHandler(string url, List<IMultipartFormSection> data)
    {
        UnityWebRequest www = UnityWebRequest.Post(url, data);
        yield return www.SendWebRequest();

        if (www.isNetworkError || www.isHttpError)
        {
            PrintError($"CODE: {www.error} ERROR: {www.downloadHandler.text}");
        }
    }
#endif
    #endregion
        
    #region Helper Methods

    private const string OwnerIcon = "https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/47/47db946f27bc76d930ac82f1656f7a10707bb67d_full.jpg";

    private void AddPluginInfoFooter(Embed embed)
    {
        embed.AddFooter($"{Title} V{Version} by {Author}", OwnerIcon);
    }

    private string GetPositionField(Vector3 pos)
    {
        return $"{pos.x:0.00} {pos.y:0.00} {pos.z:0.00}";
    }
    #endregion
        
    #region Embed Classes

    private class DiscordMessage
    {
        /// <summary>
        /// The name of the user sending the message changing this will change the webhook bots name
        /// </summary>
        [JsonProperty("username")]
        private string Username { get; set; }

        /// <summary>
        /// The avatar url of the user sending the message changing this will change the webhook bots avatar
        /// </summary>
        [JsonProperty("avatar_url")]
        private string AvatarUrl { get; set; }

        /// <summary>
        /// String only content to be sent
        /// </summary>
        [JsonProperty("content")]
        private string Content { get; set; }

        /// <summary>
        /// Embeds to be sent
        /// </summary>
        [JsonProperty("embeds")]
        private List<Embed> Embeds { get; }

        public DiscordMessage(string username = null, string avatarUrl = null)
        {
            Username = username;
            AvatarUrl = avatarUrl;
            Embeds = new List<Embed>();
        }

        public DiscordMessage(string content, string username = null, string avatarUrl = null)
        {
            Content = content;
            Username = username;
            AvatarUrl = avatarUrl;
            Embeds = new List<Embed>();
        }

        public DiscordMessage(Embed embed, string username = null, string avatarUrl = null)
        {
            Embeds = new List<Embed> {embed};
            Username = username;
            AvatarUrl = avatarUrl;
        }

        /// <summary>
        /// Adds a new embed to the list of embed to send
        /// </summary>
        /// <param name="embed">Embed to add</param>
        /// <returns>This</returns>
        /// <exception cref="IndexOutOfRangeException">Thrown if more than 10 embeds are added in a send as that is the discord limit</exception>
        public DiscordMessage AddEmbed(Embed embed)
        {
            if (Embeds.Count >= 10)
            {
                throw new IndexOutOfRangeException("Only 10 embed are allowed per message");
            }

            Embeds.Add(embed);
            return this;
        }

        /// <summary>
        /// Adds string content to the message
        /// </summary>
        /// <param name="content"></param>
        /// <returns></returns>
        public DiscordMessage AddContent(string content)
        {
            Content = content;
            return this;
        }

        /// <summary>
        /// Changes the username and avatar image for the bot sending the message
        /// </summary>
        /// <param name="username">username to change</param>
        /// <param name="avatarUrl">avatar img url to change</param>
        /// <returns>This</returns>
        public DiscordMessage AddSender(string username, string avatarUrl)
        {
            Username = username;
            AvatarUrl = avatarUrl;
            return this;
        }

        /// <summary>
        /// Returns message as JSON to be sent in the web request
        /// </summary>
        /// <returns></returns>
        public StringBuilder ToJson() => new(JsonConvert.SerializeObject(this, Formatting.None,
            new JsonSerializerSettings {NullValueHandling = NullValueHandling.Ignore}));
    }

    private class Embed
    {
        /// <summary>
        /// Color of the left side bar of the embed message
        /// </summary>
        [JsonProperty("color")]
        private int Color { get; set; }

        /// <summary>
        /// Fields to be added to the embed message
        /// </summary>
        [JsonProperty("fields")]
        private List<Field> Fields { get; } = new();

        /// <summary>
        /// Title of the embed message
        /// </summary>
        [JsonProperty("title")]
        private string Title { get; set; }

        /// <summary>
        /// Description of the embed message
        /// </summary>
        [JsonProperty("description")]
        private string Description { get; set; }
            
        /// <summary>
        /// Description of the embed message
        /// </summary>
        [JsonProperty("url")]
        private string Url { get; set; }

        /// <summary>
        /// Image to added to the embed message. Appears at the bottom of the message above the footer
        /// </summary>
        [JsonProperty("image")]
        private Image Image { get; set; }

        /// <summary>
        /// Thumbnail image added to the embed message. Appears in the top right corner
        /// </summary>
        [JsonProperty("thumbnail")]
        private Image Thumbnail { get; set; }

        /// <summary>
        /// Video to add to the embed message
        /// </summary>
        [JsonProperty("video")]
        private Video Video { get; set; }

        /// <summary>
        /// Author to add to the embed message. Appears above the title.
        /// </summary>
        [JsonProperty("author")]
        private AuthorInfo Author { get; set; }

        /// <summary>
        /// Footer to add to the embed message. Appears below all content.
        /// </summary>
        [JsonProperty("footer")]
        private Footer Footer { get; set; }

        /// <summary>
        /// Adds a title to the embed message
        /// </summary>
        /// <param name="title">Title to add</param>
        /// <returns>This</returns>
        public Embed AddTitle(string title)
        {
            Title = title;
            return this;
        }

        /// <summary>
        /// Adds a description to the embed message
        /// </summary>
        /// <param name="description">description to add</param>
        /// <returns>This</returns>
        public Embed AddDescription(string description)
        {
            Description = description;
            return this;
        }

        /// <summary>
        /// Adds a url to the embed message
        /// </summary>
        /// <param name="url"></param>
        /// <returns>This</returns>
        public Embed AddUrl(string url)
        {
            Url = url;
            return this;
        }

        /// <summary>
        /// Adds an author to the embed message. The author will appear above the title
        /// </summary>
        /// <param name="name">Name of the author</param>
        /// <param name="iconUrl">Icon Url to use for the author</param>
        /// <param name="url">Url to go to when the authors name is clicked on</param>
        /// <param name="proxyIconUrl">Backup icon url. Can be left null if you only have one icon url</param>
        /// <returns>This</returns>
        public Embed AddAuthor(string name, string iconUrl = null, string url = null, string proxyIconUrl = null)
        {
            Author = new AuthorInfo(name, iconUrl, url, proxyIconUrl);
            return this;
        }

        /// <summary>
        /// Adds a footer to the embed message
        /// </summary>
        /// <param name="text">Text to be added to the footer</param>
        /// <param name="iconUrl">Icon url to add in the footer. Appears to the left of the text</param>
        /// <param name="proxyIconUrl">Backup icon url. Can be left null if you only have one icon url</param>
        /// <returns>This</returns>
        public Embed AddFooter(string text, string iconUrl = null, string proxyIconUrl = null)
        {
            Footer = new Footer(text, iconUrl, proxyIconUrl);

            return this;
        }

        /// <summary>
        /// Adds an int based color to the embed. Color appears as a bar on the left side of the message
        /// </summary>
        /// <param name="color"></param>
        /// <returns></returns>
        public Embed AddColor(int color)
        {
            if (color < 0x0 || color > 0xFFFFFF)
            {
                throw new Exception($"Color '{color}' is outside the valid color range");
            }
                
            Color = color;
            return this;
        }

        /// <summary>
        /// Adds a hex based color. Color appears as a bar on the left side of the message
        /// </summary>
        /// <param name="color">Color in string hex format</param>
        /// <returns>This</returns>
        /// <exception cref="Exception">Exception thrown if color is outside of range</exception>
        public Embed AddColor(string color)
        {
            int parsedColor = int.Parse(color.TrimStart('#'), NumberStyles.AllowHexSpecifier);
            if (parsedColor < 0x0 || parsedColor > 0xFFFFFF)
            {
                throw new Exception($"Color '{color}' is outside the valid color range");
            }

            Color = parsedColor;
            return this;
        }

        /// <summary>
        /// Adds a RGB based color. Color appears as a bar on the left side of the message
        /// </summary>
        /// <param name="red">Red value between 0 - 255</param>
        /// <param name="green">Green value between 0 - 255</param>
        /// <param name="blue">Blue value between 0 - 255</param>
        /// <returns>This</returns>
        /// <exception cref="Exception">Thrown if red, green, or blue is outside of range</exception>
        public Embed AddColor(int red, int green, int blue)
        {
            if (red < 0 || red > 255 || green < 0 || green > 255 || green < 0 || green > 255)
            {
                throw new Exception($"Color Red:{red} Green:{green} Blue:{blue} is outside the valid color range. Must be between 0 - 255");
            }

            Color = red * 65536 + green * 256 + blue;;
            return this;
        }

        /// <summary>
        /// Adds a blank field.
        /// If inline it will add a blank column.
        /// If not inline will add a blank row
        /// </summary>
        /// <param name="inline">If the field is inline</param>
        /// <returns>This</returns>
        public Embed AddBlankField(bool inline)
        {
            Fields.Add(new Field("\u200b", "\u200b", inline));
            return this;
        }

        /// <summary>
        /// Adds a new field with the name as the title and value as the value.
        /// If inline will add a new column. If row will add in a new row.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="value"></param>
        /// <param name="inline"></param>
        /// <returns></returns>
        public Embed AddField(string name, string value, bool inline)
        {
            Fields.Add(new Field(name, value, inline));
            return this;
        }

        /// <summary>
        /// Adds an image to the embed. The url should point to the url of the image.
        /// If using attachment image you can make the url: "attachment://{image name}.{image extension}
        /// </summary>
        /// <param name="url">Url for the image</param>
        /// <param name="width">width of the image</param>
        /// <param name="height">height of the image</param>
        /// <param name="proxyUrl">Backup url for the image</param>
        /// <returns></returns>
        public Embed AddImage(string url, int? width = null, int? height = null, string proxyUrl = null)
        {
            Image = new Image(url, width, height, proxyUrl);
            return this;
        }

        /// <summary>
        /// Adds a thumbnail in the top right corner of the embed
        /// If using attachment image you can make the url: "attachment://{image name}.{image extension}
        /// </summary>
        /// <param name="url">Url for the image</param>
        /// <param name="width">width of the image</param>
        /// <param name="height">height of the image</param>
        /// <param name="proxyUrl">Backup url for the image</param>
        /// <returns></returns>
        public Embed AddThumbnail(string url, int? width = null, int? height = null, string proxyUrl = null)
        {
            Thumbnail = new Image(url, width, height, proxyUrl);
            return this;
        }

        /// <summary>
        /// Adds a video to the embed
        /// </summary>
        /// <param name="url">Url for the video</param>
        /// <param name="width">Width of the video</param>
        /// <param name="height">Height of the video</param>
        /// <returns></returns>
        public Embed AddVideo(string url, int? width = null, int? height = null)
        {
            Video = new Video(url, width, height);
            return this;
        }
    }

    /// <summary>
    /// Field for and embed message
    /// </summary>
    private class Field
    {
        /// <summary>
        /// Name of the field
        /// </summary>
        [JsonProperty("name")]
        private string Name { get; }

        /// <summary>
        /// Value for the field
        /// </summary>
        [JsonProperty("value")]
        private string Value { get; }

        /// <summary>
        /// If the field should be in the same row or a new row
        /// </summary>
        [JsonProperty("inline")]
        private bool Inline { get; }

        public Field(string name, string value, bool inline)
        {
            Name = name;
            Value = value;
            Inline = inline;
        }
    }

    /// <summary>
    /// Image for an embed message
    /// </summary>
    private class Image
    {
        /// <summary>
        /// Url for the image
        /// </summary>
        [JsonProperty("url")]
        private string Url { get; }

        /// <summary>
        /// Width for the image
        /// </summary>
        [JsonProperty("width")]
        private int? Width { get; }

        /// <summary>
        /// Height for the image
        /// </summary>
        [JsonProperty("height")]
        private int? Height { get; }

        /// <summary>
        /// Proxy url for the image
        /// </summary>
        [JsonProperty("proxyURL")]
        private string ProxyUrl { get; }

        public Image(string url, int? width, int? height, string proxyUrl)
        {
            Url = url;
            Width = width;
            Height = height;
            ProxyUrl = proxyUrl;
        }
    }

    /// <summary>
    /// Video for an embed message
    /// </summary>
    private class Video
    {
        /// <summary>
        /// Url to the video
        /// </summary>
        [JsonProperty("url")]
        private string Url { get; }

        /// <summary>
        /// Width of the video
        /// </summary>
        [JsonProperty("width")]
        private int? Width { get; }

        /// <summary>
        /// Height of the video
        /// </summary>
        [JsonProperty("height")]
        private int? Height { get; }

        public Video(string url, int? width, int? height)
        {
            Url = url;
            Width = width;
            Height = height;
        }
    }

    /// <summary>
    /// Author of an embed message
    /// </summary>
    private class AuthorInfo
    {
        /// <summary>
        /// Name of the author
        /// </summary>
        [JsonProperty("name")]
        private string Name { get; }

        /// <summary>
        /// Url to go to when clicking on the authors name
        /// </summary>
        [JsonProperty("url")]
        private string Url { get; }

        /// <summary>
        /// Icon url for the author
        /// </summary>
        [JsonProperty("icon_url")]
        private string IconUrl { get; }

        /// <summary>
        /// Proxy icon url for the author
        /// </summary>
        [JsonProperty("proxy_icon_url")]
        private string ProxyIconUrl { get; }

        public AuthorInfo(string name, string iconUrl, string url, string proxyIconUrl)
        {
            Name = name;
            Url = url;
            IconUrl = iconUrl;
            ProxyIconUrl = proxyIconUrl;
        }
    }

    /// <summary>
    /// Footer for an embed message
    /// </summary>
    private class Footer
    {
        /// <summary>
        /// Text for the footer
        /// </summary>
        [JsonProperty("text")]
        private string Text { get; }

        /// <summary>
        /// Icon url for the footer
        /// </summary>
        [JsonProperty("icon_url")]
        private string IconUrl { get; }

        /// <summary>
        /// Proxy icon url for the footer
        /// </summary>
        [JsonProperty("proxy_icon_url")]
        private string ProxyIconUrl { get; }

        public Footer(string text, string iconUrl, string proxyIconUrl)
        {
            Text = text;
            IconUrl = iconUrl;
            ProxyIconUrl = proxyIconUrl;
        }
    }

    #endregion

    #region Attachment Classes
    /// <summary>
    /// Enum for attachment content type
    /// </summary>
    private enum AttachmentContentType
    {
        Png,
        Jpg
    }

    private class Attachment
    {
        /// <summary>
        /// Attachment data
        /// </summary>
        public byte[] Data { get; }
            
        /// <summary>
        /// File name for the attachment.
        /// Used in the url field of an image
        /// </summary>
        public string Filename { get; }
            
        /// <summary>
        /// Content type for the attachment
        /// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types
        /// </summary>
        public string ContentType { get; }

        public Attachment(byte[] data, string filename, AttachmentContentType contentType)
        {
            Data = data;
            Filename = filename;

            switch (contentType)
            {
                case AttachmentContentType.Jpg:
                    ContentType = "image/jpeg";
                    break;
                    
                case AttachmentContentType.Png:
                    ContentType = "image/png";
                    break;
            }
        }

        public Attachment(byte[] data, string filename, string contentType)
        {
            Data = data;
            Filename = filename;
            ContentType = contentType;
        }
    }
        
    #endregion

    #region Config Classes

    public class DiscordMessageConfig
    {
        public string Content { get; set; }
            
        [JsonProperty("Webhook Override (Overrides the default webhook for this message)")]
        public string WebhookOverride { get; set; }
            
        [JsonProperty("Send Mode (Always, Random)")]
        [JsonConverter(typeof(StringEnumConverter))]
        public SendMode SendMode { get; set; }
            
        public EmbedConfig Embed { get; set; }
    }
        
    public class EmbedConfig
    {
        [JsonProperty("Enabled")]
        public bool Enabled { get; set; }
            
        [JsonProperty("Title")]
        public string Title { get; set; }
            
        [JsonProperty("Description")]
        public string Description { get; set; }
            
        [JsonProperty("Url")]
        public string Url { get; set; }
            
        [JsonProperty("Embed Color")]
        public string Color { get; set; }
            
        [JsonProperty("Image Url")]
        public string Image { get; set; }
            
        [JsonProperty("Thumbnail Url")]
        public string Thumbnail { get; set; }
            
        [JsonProperty("Fields")]
        public List<FieldConfig> Fields { get; set; }
            
        [JsonProperty("Footer")]
        public FooterConfig Footer { get; set; }
    }
        
    public class FieldConfig
    {
        [JsonProperty("Title")]
        public string Title { get; set; }
            
        [JsonProperty("Value")]
        public string Value { get; set; }
            
        [JsonProperty("Inline")]
        public bool Inline { get; set; }

        [JsonProperty("Enabled")]
        public bool Enabled { get; set; }
    }

    public class FooterConfig
    {
        [JsonProperty("Icon Url")]
        public string IconUrl { get; set; }
            
        [JsonProperty("Text")]
        public string Text { get; set; }
            
        [JsonProperty("Enabled")]
        public bool Enabled { get; set; }
    }
    #endregion
        
    #region Config Methods
    private DiscordMessage ParseMessage(DiscordMessageConfig config)
    {
        DiscordMessage message = new();

        if (!string.IsNullOrEmpty(config.Content))
        {
            message.AddContent(ParseField(config.Content));
        }

        EmbedConfig embedConfig = config.Embed;
        if (embedConfig != null && embedConfig.Enabled)
        {
            Embed embed = new();
            string title = ParseField(config.Embed.Title);
            if (!string.IsNullOrEmpty(title))
            {
                embed.AddTitle(title);
            }

            string description = ParseField(embedConfig.Description);
            if (!string.IsNullOrEmpty(description))
            {
                embed.AddDescription(description);
            }

            string url = ParseField(embedConfig.Url);
            if (!string.IsNullOrEmpty(url))
            {
                embed.AddUrl(url);
            }

            string color = ParseField(embedConfig.Color);
            if (!string.IsNullOrEmpty(color))
            {
                embed.AddColor(color);
            }

            string img = ParseField(embedConfig.Image);
            if (!string.IsNullOrEmpty(img))
            {
                embed.AddImage(img);
            }

            string thumbnail = ParseField(embedConfig.Thumbnail);
            if (!string.IsNullOrEmpty(thumbnail))
            {
                embed.AddThumbnail(thumbnail);
            }

            foreach (FieldConfig field in embedConfig.Fields.Where(f => f.Enabled))
            {
                string value = ParseField(field.Value);
                if (string.IsNullOrEmpty(value))
                {
                    //PrintWarning($"Field: {field.Title} was skipped because the value was null or empty.");
                    continue;
                }

                embed.AddField(field.Title, value, field.Inline);
            }

            if (embedConfig.Footer != null && embedConfig.Footer.Enabled)
            {
                if (string.IsNullOrEmpty(embedConfig.Footer.Text) &&
                    string.IsNullOrEmpty(embedConfig.Footer.IconUrl))
                {
                    AddPluginInfoFooter(embed);
                }
                else
                {
                    string text = ParseField(embedConfig.Footer.Text);
                    string footerUrl = ParseField(embedConfig.Footer.IconUrl);
                    embed.AddFooter(text, footerUrl);
                }
            }

            message.AddEmbed(embed);
        }

        return message;
    }
    #endregion
    #endregion
}

// --- End of file: DiscordWipe.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-linker ---
// --- Original File Path: D/DiscordLinker/DiscordLinker.cs ---

#region

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

#endregion

namespace Oxide.Plugins
{
    [Info("Discord Linker", "mrcameron999", "2.1.1")]
    [Description("Provides a way of linking a players' Discord and Steam accounts")]
    public class DiscordLinker : CovalencePlugin
    {
        private readonly Dictionary<IPlayer, CachedPlayer> _cachedJoins = new Dictionary<IPlayer, CachedPlayer>();
        private readonly Dictionary<string, string> _headers = new Dictionary<string, string>();
        private readonly string connection = "https://api.gameservertools.com/";
        private readonly float timeout = 1000f;
        private string _groupName = "DiscordLinked";
        private string _groupNitro = "Nitro";

        //OnDiscordUserAddedToGroup user has been linked
        //OnDiscordUserUnLinked user unlinked
        private bool _showClaimMessage;

        private void Init()
        {
            LoadConfigData();
            permission.CreateGroup(_groupName, "linked", 0);
            permission.CreateGroup(_groupNitro, "nitro", 0);
            permission.RegisterPermission("discordLinker.linked", this);
            permission.GrantGroupPermission(_groupName, "discordLinker.linked", this);
        }

        private void LoadConfigData()
        {
            _groupName = Config["OxideGroupName"].ToString();

            if (!(bool) Config["CheckLinkOnConnect"])
            {
                Unsubscribe("OnPlayerConnected");
            }

            string apiKey = Config["APIKEY"].ToString();

            if (apiKey == "")
                LogError("NO API KEY PROVIDED! Please ensure you have added your api key in the config file");
            else
                _headers.Add("ApiKey", apiKey);


            if (Config["OxideGroupNameForNitro"] == null)
            {
                Config["OxideGroupNameForNitro"] = "Nitro";
                SaveConfig();
            }

            _groupNitro = Config["OxideGroupNameForNitro"].ToString();
            _showClaimMessage = (bool) Config["DisplayMessageOnClaimRewards"];
            if (string.IsNullOrEmpty(lang.GetMessage("NitroLostMessage", this)))
            {
                Dictionary<string, string> messages = lang.GetMessages("en", this);

                messages.Add("NitroLostMessage", "You are no longer nitro boosting this amazing server!");
                messages.Add("NitroGainMessage", "You are now nitro boosting this amazing server you will now get this awsome thing!");
                lang.RegisterMessages(messages, this);
            }
        }

        #region Hooks

        private void OnUserConnected(IPlayer player)
        {
            webrequest.Enqueue($"{connection}api/Link/GetLinkData?steamId={player.Id}", null, (code, response) =>
            {
                if (code == 200)
                {
                    LinkModel linkData = JsonConvert.DeserializeObject<LinkModel>(response);
                    //check if they have left the discord here

                    if (linkData.LinkId == 0) // not linked
                    {
                        string joinMessageNotLinked = lang.GetMessage("JoinMessageNotLinked", this, player.Id);
                        player.Reply($"{joinMessageNotLinked}");

                        bool userHasGroup = player.BelongsToGroup(_groupName);
                        if (userHasGroup)
                        {
                            player.RemoveFromGroup(_groupName);
                            player.RemoveFromGroup(_groupNitro);
                            Interface.CallHook("OnDiscordUserUnLinked", player);
                        }
                    }
                    else if (linkData.LinkId != 0 && !linkData.InDiscord) // left discord
                    {
                        string joinMessageLeft = lang.GetMessage("JoinMessageLeft", this, player.Id);
                        player.Reply($"{joinMessageLeft}");
                        //removes the from the group encase they unlinked their account

                        bool userHasGroup = player.BelongsToGroup(_groupName);
                        if (userHasGroup)
                        {
                            player.RemoveFromGroup(_groupName);
                            player.RemoveFromGroup(_groupNitro);
                            Interface.CallHook("OnDiscordUserUnLinked", player);
                        }
                    }
                    else // Linked
                    {
                        string joinMessageLinked = lang.GetMessage("JoinMessageLinked", this, player.Id);
                        player.Reply($"{joinMessageLinked}");
                        bool userHasGroup = player.BelongsToGroup(_groupName);
                        if (!userHasGroup)
                        {
                            player.AddToGroup(_groupName);
                            Interface.CallHook("OnDiscordUserAddedToGroup", player);
                        }

                        // Check for nitro rewards
                        bool userHasNitro = player.BelongsToGroup(_groupNitro);
                        if (userHasNitro && !linkData.NitroBoosted)
                        {
                            string noLongerBoostingMessage = lang.GetMessage("NitroLostMessage", this, player.Id);

                            player.Reply(noLongerBoostingMessage);

                            player.RemoveFromGroup(_groupNitro);
                            Interface.CallHook("OnNitroBoostRemove", player);
                            // Do discord nitro stuff here
                        }
                        else if (!userHasNitro && linkData.NitroBoosted)
                        {
                            string nowBoostingMessage = lang.GetMessage("NitroGainMessage", this, player.Id);
                            player.Reply(nowBoostingMessage);

                            player.AddToGroup(_groupNitro);
                            Interface.CallHook("OnNitroBoost", player);
                        }
                    }

                    return;
                }

                player.Reply("Something went wrong with this command. Please contact the admin of the server");
                Debug.LogError($"Error checking link: {response} {code}");
            }, this, RequestMethod.GET, _headers, timeout);
        }

        #endregion Hooks

        #region helpers

        private void MessageAllPlayers(string message)
        {
            foreach (IPlayer player in players.Connected)
            {
                player.Message(message);
            }
        }

        #endregion helpers

        #region Commands

        [Command("checklink")] //Used by gst to automatically check a users account
        private void CheckLinkCommand(IPlayer iplayer, string command, string[] args)
        {
            if (!iplayer.IsServer) return;

            BasePlayer player = BasePlayer.Find(args[0]);
            if (player == null || !player.IsConnected)
            {
                return;
            }

            if (args.Length > 1)
            {
                if (_showClaimMessage)
                {
                    string messageReplaced = lang.GetMessage("BroadcastMessage", this, iplayer.Id);
                    string newMessage = messageReplaced.Replace("@userName", player.displayName);
                    MessageAllPlayers(newMessage);
                }
            }

            OnUserConnected(player.IPlayer);
        }

        [Command("nitro", "linked")]
        private void NitroCheck(IPlayer iplayer, string command, string[] args)
        {
            CachedPlayer data;
            if (_cachedJoins.TryGetValue(iplayer, out data))
            {
                TimeSpan timeSinceAdd = DateTime.Now - data.TimeOfAdd;
                if (timeSinceAdd.TotalMinutes < 1)
                {
                    string message = lang.GetMessage("RecentlyUsedThisCommand", this, iplayer.Id);
                    iplayer.Reply(message);
                    return;
                }

                _cachedJoins.Remove(iplayer);
            }

            _cachedJoins.Add(iplayer, new CachedPlayer());


            string messageCheckingAccount = lang.GetMessage("CheckingAccount", this, iplayer.Id);
            iplayer.Reply(messageCheckingAccount);

            OnUserConnected(iplayer);
        }

        #endregion Commands

        #region classes

        public class LinkModel
        {
            public int LinkId { get; set; }
            public long SteamId { get; set; }
            public long DiscordId { get; set; }
            public int OrgId { get; set; }
            public DateTime LinkDate { get; set; }
            public bool InDiscord { get; set; }
            public bool ClaimedRewards { get; set; }
            public int? NitroBoostId { get; set; }
            public bool NitroBoosted { get; set; }
        }

        private class CachedPlayer
        {
            public CachedPlayer()
            {
                TimeOfAdd = DateTime.UtcNow;
            }

            public DateTime TimeOfAdd { get; }
        }

        #endregion classes

        #region config

        protected override void LoadDefaultConfig()
        {
            Config["APIKEY"] = "";
            Config["OxideGroupName"] = "Discord Linked";
            Config["OxideGroupNameForNitro"] = "Discord Linked";
            Config["DisplayMessageOnClaimRewards"] = true;
            Config["CheckLinkOnConnect"] = true;
            Config["LogOnLink"] = true;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BroadcastMessage"] = "@userName has just claimed some really cool  reward for linkking his account head to discordlinker.com to claim yours",
                ["JoinMessageLinked"] = "Your account is linked!",
                ["JoinMessageNotLinked"] = "Your account is NOT linked!",
                ["JoinMessageLeft"] = "Your left our discord :( You will no longer get rewards",
                ["RecentlyUsedThisCommand"] = "You recently used this command",
                ["CheckingAccount"] = "Checking your account...",
                ["AccountLinkSuccess"] = "Account Link successfull!",
                ["AlreadyLinked"] = "Your account has not been linked! Link your account at discordlinker.com/",
                ["UnkownError"] = "Unkown error",
                ["NitroLostMessage"] = "You are no longer nitro boosting this amazing server!",
                ["NitroGainMessage"] = "You are now nitro boosting this amazing server you will now get this awsome thing!"
            }, this);
        }

        #endregion config
    }
}

// --- End of file: DiscordLinker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/dangerous-treasures ---
// --- Original File Path: D/DangerousTreasures/DangerousTreasures.cs ---

ï»¿using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Plugins.DangerousTreasuresExtensionMethods;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.SceneManagement;

namespace Oxide.Plugins
{
    [Info("Dangerous Treasures", "nivex", "2.4.7")]
    [Description("Event with treasure chests.")]
    internal class DangerousTreasures : RustPlugin
    {
        [PluginReference] Plugin ZoneManager, Economics, ServerRewards, GUIAnnouncements, MarkerManager, Kits, Duelist, RaidableBases, AbandonedBases, Notify, AdvancedAlerts, Clans, Friends;

        private new const string Name = "Dangerous Treasures";
        private bool wipeChestsSeed;
        private StoredData data = new();
        private List<int> BlockedLayers = new() { (int)Layer.Water, (int)Layer.Construction, (int)Layer.Trigger, (int)Layer.Prevent_Building, (int)Layer.Deployed, (int)Layer.Tree, (int)Layer.Clutter };
        private Dictionary<ulong, HumanoidBrain> HumanoidBrains = new();
        private Dictionary<string, MonumentInfoEx> allowedMonuments = new();
        private List<MonumentInfoEx> monuments = new();
        private Dictionary<Vector3, ZoneInfo> managedZones = new();
        private Dictionary<NetworkableId, TreasureChest> treasureChests = new();
        private Dictionary<NetworkableId, string> looters = new();
        private Dictionary<string, ItemDefinition> _definitions = new();
        private Dictionary<string, SkinInfo> Skins = new();
        private List<ulong> newmanProtections = new();
        private List<ulong> indestructibleWarnings = new(); // indestructible messages limited to once every 10 seconds
        private List<ulong> drawGrants = new(); // limit draw to once every 15 seconds by default
        private List<int> obstructionLayers = new() { Layers.Mask.Player_Server, Layers.Mask.Construction, Layers.Mask.Deployed };
        private List<string> _blockedColliders = new() { "powerline_", "invisible_", "TopCol", "train", "swamp_", "floating_" };
        private List<string> underground = new() { "Cave", "Sewer Branch", "Military Tunnel", "Underwater Lab", "Train Tunnel" };
        private HashSet<Vector3> _gridPositions = new();
        private const int TARGET_MASK = 8454145;
        private const int targetMask = Layers.Mask.World | Layers.Mask.Terrain | Layers.Mask.Default;
        private const int visibleMask = Layers.Mask.Deployed | Layers.Mask.Construction | targetMask;
        private const int obstructionLayer = Layers.Mask.Player_Server | Layers.Mask.Construction | Layers.Mask.Deployed;
        private const int heightLayer = TARGET_MASK | Layers.Mask.Construction | Layers.Mask.Deployed | Layers.Mask.Clutter;
        private StringBuilder _sb = new();
        private Vector3 sd_customPos;

        public class ZoneInfo
        {
            public Vector3 Position;
            public Vector3 Size;
            public float Distance;
            public OBB OBB;
        }

        public class SkinInfo
        {
            public List<ulong> skins = new();
            public List<ulong> workshopSkins = new();
            public List<ulong> importedSkins = new();
            public List<ulong> allSkins = new();
        }

        private class PlayerInfo
        {
            public int StolenChestsTotal;
            public int StolenChestsSeed;
            public PlayerInfo() { }
        }

        private class StoredData
        {
            public Dictionary<string, PlayerInfo> Players = new();
            public double SecondsUntilEvent = double.MinValue;
            public string CustomPosition;
            public int TotalEvents = 0;
            public StoredData() { }
        }

        public class HumanoidNPC : ScientistNPC
        {
            public new HumanoidBrain Brain;

            public Configuration config => Brain.Instance.config;

            public new Translate.Phrase LootPanelTitle => displayName;

            public override string Categorize() => "Humanoid";

            public override bool ShouldDropActiveItem() => false;

            public override string displayName => Brain == null ? "HumanoidNPC" : Brain.displayName;

            public override void AttackerInfo(ProtoBuf.PlayerLifeStory.DeathInfo info)
            {
                info.attackerName = displayName;
                info.attackerSteamID = userID;
                info.inflictorName = inventory.containerBelt.GetSlot(0).info.shortname;
                info.attackerDistance = Vector3.Distance(Brain.ServerPosition, Brain.AttackPosition);
            }

            public override void OnDied(HitInfo info)
            {
                Brain.DisableShouldThink();

                if (Brain.tc == null)
                {
                    return;
                }

                if (Brain.isMurderer && config.NPC.Murderers.DespawnInventory || !Brain.isMurderer && config.NPC.Scientists.DespawnInventory)
                {
                    inventory?.Strip();
                }

                svActiveItemID = default;
                SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                Brain.tc.npcs.Remove(this);

                if (Brain.tc.whenNpcsDie && Brain.tc.npcs.Count == 0)
                {
                    Brain.tc.Unlock();
                }

                if (config.Unlock.LockToPlayerOnNpcDeath)
                {
                    Brain.tc.TrySetOwner(info);
                }

                base.OnDied(info);
            }
        }

        public class HumanoidBrain : ScientistBrain
        {
            public void DisableShouldThink()
            {
                ThinkMode = AIThinkMode.FixedUpdate;
                thinkRate = float.MaxValue;
                lastWarpTime = float.MaxValue;
                lastThinkTime = 0f;
                sleeping = true;
                isKilled = true;
                SetEnabled(false);
            }

            internal DangerousTreasures Instance;

            internal enum AttackType { BaseProjectile, FlameThrower, Melee, Water, None }
            internal string displayName;
            internal Transform NpcTransform;
            internal HumanoidNPC npc;
            internal AttackEntity _attackEntity;
            internal FlameThrower flameThrower;
            internal LiquidWeapon liquidWeapon;
            internal BaseMelee baseMelee;
            internal BaseProjectile baseProjectile;
            internal BasePlayer AttackTarget;
            internal Transform AttackTransform;
            internal TreasureChest tc;
            internal NpcSettings Settings;
            internal List<Vector3> positions;
            internal Vector3 DestinationOverride;
            internal bool isKilled;
            internal bool isMurderer;
            internal ulong uid;
            internal float lastWarpTime;
            internal float softLimitSenseRange;
            internal float nextAttackTime;
            internal float attackRange;
            internal float attackCooldown;
            internal AttackType attackType = AttackType.None;
            internal BaseNavigator.NavigationSpeed CurrentSpeed = BaseNavigator.NavigationSpeed.Normal;

            internal Vector3 AttackPosition => AttackTransform == null ? default : AttackTransform.position;

            internal Vector3 ServerPosition => NpcTransform == null ? default : NpcTransform.position;

            private Configuration config => Instance.config;

            internal AttackEntity AttackEntity
            {
                get
                {
                    if (_attackEntity.IsNull())
                    {
                        IdentifyWeapon();
                    }

                    return _attackEntity;
                }
            }

            public void UpdateWeapon(AttackEntity attackEntity, ItemId uid)
            {
                npc.UpdateActiveItem(uid);

                if (attackEntity is Chainsaw cs)
                {
                    cs.ServerNPCStart();
                }

                npc.damageScale = 1f;

                attackEntity.TopUpAmmo();
                attackEntity.SetHeld(true);
            }

            internal void IdentifyWeapon()
            {
                _attackEntity = GetEntity().GetAttackEntity();

                attackRange = 0f;
                attackCooldown = 99999f;
                attackType = AttackType.None;
                baseMelee = null;
                flameThrower = null;
                liquidWeapon = null;

                if (_attackEntity.IsNull())
                {
                    return;
                }

                Action action = _attackEntity.ShortPrefabName switch
                {
                    "double_shotgun.entity" or "shotgun_pump.entity" or "shotgun_waterpipe.entity" or "spas12.entity" => () =>
                    {
                        SetAttackRestrictions(AttackType.BaseProjectile, 30f, 0f, 30f);
                    }
                    ,
                    "ak47u.entity" or "ak47u_ice.entity" or "bolt_rifle.entity" or "glock.entity" or "hmlmg.entity" or "l96.entity" or "lr300.entity" or "m249.entity" or "m39.entity" or "m92.entity" or "mp5.entity" or "nailgun.entity" or "pistol_eoka.entity" or "pistol_revolver.entity" or "pistol_semiauto.entity" or "python.entity" or "semi_auto_rifle.entity" or "thompson.entity" or "smg.entity" => () =>
                    {
                        SetAttackRestrictions(AttackType.BaseProjectile, 300f, 0f, 150f);
                    }
                    ,
                    "snowballgun.entity" => () =>
                    {
                        SetAttackRestrictions(AttackType.BaseProjectile, 15f, 0.1f, 15f);
                    }
                    ,
                    "chainsaw.entity" or "jackhammer.entity" => () =>
                    {
                        baseMelee = _attackEntity as BaseMelee;
                        SetAttackRestrictions(AttackType.Melee, 2.5f, (_attackEntity.animationDelay + _attackEntity.deployDelay) * 2f);
                    }
                    ,
                    "axe_salvaged.entity" or "bone_club.entity" or "butcherknife.entity" or "candy_cane.entity" or "hammer_salvaged.entity" or "hatchet.entity" or "icepick_salvaged.entity" or "knife.combat.entity" or "knife_bone.entity" or "longsword.entity" or "mace.baseballbat" or "mace.entity" or "machete.weapon" or "pickaxe.entity" or "pitchfork.entity" or "salvaged_cleaver.entity" or "salvaged_sword.entity" or "sickle.entity" or "spear_stone.entity" or "spear_wooden.entity" or "stone_pickaxe.entity" or "stonehatchet.entity" => () =>
                    {
                        baseMelee = _attackEntity as BaseMelee;
                        SetAttackRestrictions(AttackType.Melee, 2.5f, _attackEntity.animationDelay + _attackEntity.deployDelay);
                    }
                    ,
                    "flamethrower.entity" => () =>
                    {
                        flameThrower = _attackEntity as FlameThrower;
                        SetAttackRestrictions(AttackType.FlameThrower, 10f, (_attackEntity.animationDelay + _attackEntity.deployDelay) * 2f);
                    }
                    ,
                    "compound_bow.entity" or "crossbow.entity" or "speargun.entity" or "bow_hunting.entity" => () =>
                    {
                        SetAttackRestrictions(AttackType.BaseProjectile, 200f, (_attackEntity.animationDelay + _attackEntity.deployDelay) * 1.25f, 150f);
                    }
                    ,
                    "watergun.entity" or "waterpistol.entity" => () =>
                    {
                        if ((liquidWeapon = _attackEntity as LiquidWeapon) != null)
                        {
                            liquidWeapon.AutoPump = true;
                            SetAttackRestrictions(AttackType.Water, 10f, 2f);
                        }
                    }
                    ,
                    _ => () => _attackEntity = null
                };

                action();
            }

            private void SetAttackRestrictions(AttackType attackType, float attackRange, float attackCooldown, float effectiveRange = 0f)
            {
                if (attackType == AttackType.BaseProjectile)
                {
                    baseProjectile = _attackEntity as BaseProjectile;
                    if (baseProjectile != null)
                    {
                        baseProjectile.MuzzlePoint ??= baseProjectile.transform;
                    }
                }

                if (effectiveRange != 0f)
                {
                    _attackEntity.effectiveRange = effectiveRange;
                }

                this.attackType = attackType;
                this.attackRange = attackRange;
                this.attackCooldown = attackCooldown;
            }

            public bool ValidTarget => AttackTransform != null && !AttackTarget.IsKilled() && !ShouldForgetTarget(AttackTarget);

            public override void OnDestroy()
            {
                if (!Rust.Application.isQuitting)
                {
                    BaseEntity.Query.Server.RemoveBrain(GetEntity());
                    LeaveGroup();
                }

                Instance?.HumanoidBrains?.Remove(uid);
                try { CancelInvoke(); } catch { }
            }

            public override void InitializeAI()
            {
                base.InitializeAI();
                base.ForceSetAge(0f);

                NpcTransform = GetEntity().transform;
                Pet = false;
                sleeping = false;
                UseAIDesign = true;
                AllowedToSleep = false;
                HostileTargetsOnly = false;
                AttackRangeMultiplier = 2f;
                MaxGroupSize = 0;

                Senses.Init(
                    owner: GetEntity(),
                    brain: this,
                    memoryDuration: 5f,
                    range: 50f,
                    targetLostRange: 75f,
                    visionCone: -1f,
                    checkVision: false,
                    checkLOS: true,
                    ignoreNonVisionSneakers: true,
                    listenRange: 15f,
                    hostileTargetsOnly: false,
                    senseFriendlies: false,
                    ignoreSafeZonePlayers: false,
                    senseTypes: EntityType.Player,
                    refreshKnownLOS: true
                );
                //senseTypes: config.Settings.Management.TargetNpcs? EntityType.Player | EntityType.BasePlayerNPC : EntityType.Player,

                CanUseHealingItems = true;
            }

            public override void AddStates()
            {
                base.AddStates();

                states[AIState.Attack] = new AttackState(this);
            }

            public class AttackState : BaseAttackState
            {
                private new HumanoidBrain brain;
                private global::HumanNPC npc;
                private Transform NpcTransform;

                private IAIAttack attack => brain.Senses.ownerAttack;

                public AttackState(HumanoidBrain humanoidBrain)
                {
                    base.brain = brain = humanoidBrain;
                    base.AgrresiveState = true;
                    npc = brain.GetBrainBaseEntity() as global::HumanNPC;
                    NpcTransform = npc.transform;
                }

                public override void StateEnter(BaseAIBrain _brain, BaseEntity _entity)
                {
                    if (_brain != null && NpcTransform != null && brain.ValidTarget)
                    {
                        if (InAttackRange())
                        {
                            StartAttacking();
                        }
                        if (brain.CanUseNavMesh())
                        {
                            brain.Navigator.SetDestination(brain.DestinationOverride, BaseNavigator.NavigationSpeed.Fast, 0f, 0f);
                        }
                    }
                }

                public override void StateLeave(BaseAIBrain _brain, BaseEntity _entity)
                {

                }

                private void StopAttacking()
                {
                    if (attack != null)
                    {
                        attack.StopAttacking();
                        brain.AttackTarget = null;
                        brain.AttackTransform = null;
                        brain.Navigator.ClearFacingDirectionOverride();
                    }
                }

                public override StateStatus StateThink(float delta, BaseAIBrain _brain, BaseEntity _entity)
                {
                    if (_brain == null || NpcTransform == null || attack == null)
                    {
                        return StateStatus.Error;
                    }
                    if (!brain.ValidTarget || brain.isKilled)
                    {
                        StopAttacking();

                        return StateStatus.Finished;
                    }
                    if (brain.Senses.ignoreSafeZonePlayers && brain.AttackTarget.InSafeZone())
                    {
                        return StateStatus.Error;
                    }
                    if (brain.CanUseNavMesh() && !brain.Navigator.SetDestination(brain.DestinationOverride, BaseNavigator.NavigationSpeed.Fast, 0f, 0f))
                    {
                        return StateStatus.Error;
                    }
                    if (!brain.CanShoot())
                    {
                        brain.Forget();

                        StopAttacking();

                        return StateStatus.Finished;
                    }
                    if (InAttackRange())
                    {
                        StartAttacking();
                    }
                    return StateStatus.Running;
                }

                private bool InAttackRange()
                {
                    return !npc.IsWounded() && brain.AttackTransform != null && attack.CanAttack(brain.AttackTarget) && brain.IsInAttackRange() && brain.CanSeeTarget(brain.AttackTarget);
                }

                private void StartAttacking()
                {
                    if (brain.AttackTransform == null)
                    {
                        return;
                    }

                    brain.SetAimDirection();

                    if (!brain.CanShoot() || brain.IsAttackOnCooldown())
                    {
                        return;
                    }

                    if (brain.attackType == AttackType.BaseProjectile)
                    {
                        RealisticShotTest();
                    }
                    else if (brain.attackType == AttackType.FlameThrower)
                    {
                        brain.UseFlameThrower();
                    }
                    else if (brain.attackType == AttackType.Water)
                    {
                        brain.UseWaterGun();
                    }
                    else brain.MeleeAttack();
                }

                private void RealisticShotTest()
                {
                    if (NpcTransform == null || brain.baseProjectile == null || brain.baseProjectile.primaryMagazine == null)
                    {
                        return;
                    }
                    if (brain.AttackTarget.IsNpc)
                    {
                        var faction = brain.AttackTarget.faction;
                        brain.AttackTarget.faction = BaseCombatEntity.Faction.Horror;
                        npc.ShotTest(brain.AttackPosition.Distance(brain.ServerPosition));
                        if (brain.AttackTarget != null) brain.AttackTarget.faction = faction;
                    }
                    else npc.ShotTest(brain.AttackPosition.Distance(brain.ServerPosition));
                }
            }

            private bool init;

            public void Init()
            {
                if (init) return;
                init = true;
                lastWarpTime = Time.time;
                npc.spawnPos = tc.containerPos;
                npc.AdditionalLosBlockingLayer = visibleMask;
                SetupNavigator(GetEntity(), GetComponent<BaseNavigator>(), tc.Radius);
            }

            private void Converge()
            {
                foreach (var brain in Instance.HumanoidBrains.Values)
                {
                    if (brain != null && brain.NpcTransform != null && brain != this && brain.attackType == attackType && brain.CanConverge(npc))
                    {
                        brain.SetTarget(AttackTarget, false);
                    }
                }
            }

            public void Forget()
            {
                Senses.Players.Clear();
                Senses.Memory.All.Clear();
                Senses.Memory.Threats.Clear();
                Senses.Memory.Targets.Clear();
                Senses.Memory.Players.Clear();
                Navigator.ClearFacingDirectionOverride();
                DestinationOverride = GetRandomRoamPosition();

                SenseRange = ListenRange = isMurderer ? Settings.Murderers.AggressionRange : Settings.Scientists.AggressionRange;
                Senses.targetLostRange = TargetLostRange = SenseRange * 1.25f;
                AttackTarget = null;
                AttackTransform = null;

                TryReturnHome();
            }

            private void RandomMove(float radius)
            {
                var to = AttackPosition + UnityEngine.Random.onUnitSphere * radius;

                to.y = TerrainMeta.HeightMap.GetHeight(to);

                SetDestination(to);
            }

            public void SetupNavigator(BaseCombatEntity owner, BaseNavigator navigator, float distance)
            {
                navigator.CanUseNavMesh = !Rust.Ai.AiManager.nav_disable;

                navigator.MaxRoamDistanceFromHome = navigator.BestMovementPointMaxDistance = navigator.BestRoamPointMaxDistance = distance * 0.85f;
                navigator.DefaultArea = "Walkable";
                navigator.topologyPreference = ((TerrainTopology.Enum)TerrainTopology.EVERYTHING);
                navigator.Agent.agentTypeID = NavMesh.GetSettingsByIndex(1).agentTypeID; // 0:0, 1: -1372625422, 2: 1479372276, 3: -1923039037
                navigator.MaxWaterDepth = 3f;

                if (navigator.CanUseNavMesh)
                {
                    navigator.Init(owner, navigator.Agent);
                }
            }

            public Vector3 GetAimDirection()
            {
                if (Navigator.IsOverridingFacingDirection)
                {
                    return Navigator.FacingDirectionOverride;
                }
                if (InRange2D(AttackPosition, ServerPosition, 1f))
                {
                    return npc.eyes.BodyForward();
                }
                return (AttackPosition - ServerPosition).normalized;
            }

            private void SetAimDirection()
            {
                Navigator.SetFacingDirectionEntity(AttackTarget);
                npc.SetAimDirection(GetAimDirection());
            }

            private void SetDestination()
            {
                SetDestination(GetRandomRoamPosition());
            }

            private void SetDestination(Vector3 destination)
            {
                if (!CanLeave(destination))
                {
                    if (attackType != AttackType.BaseProjectile)
                    {
                        destination = ((destination.XZ3D() - tc.containerPos.XZ3D()).normalized * (tc.Radius * 0.75f)) + tc.containerPos;

                        destination += UnityEngine.Random.onUnitSphere * (tc.Radius * 0.2f);
                    }
                    else
                    {
                        destination = GetRandomRoamPosition();
                    }

                    CurrentSpeed = BaseNavigator.NavigationSpeed.Normal;
                }

                if (destination != DestinationOverride)
                {
                    destination.y = TerrainMeta.HeightMap.GetHeight(destination);

                    DestinationOverride = destination;
                }

                Navigator.SetCurrentSpeed(CurrentSpeed);

                if (Navigator.CurrentNavigationType == BaseNavigator.NavigationType.None && !Rust.Ai.AiManager.ai_dormant && !Rust.Ai.AiManager.nav_disable)
                {
                    Navigator.SetCurrentNavigationType(BaseNavigator.NavigationType.NavMesh);
                }

                if (CanUseNavMesh() && !Navigator.SetDestination(destination, CurrentSpeed))
                {
                    Navigator.Destination = destination;
                    npc.finalDestination = destination;
                }
            }

            public bool CanUseNavMesh() => Navigator.CanUseNavMesh && !Navigator.StuckOffNavmesh;

            public bool SetTarget(BasePlayer player, bool converge = true)
            {
                if (NpcTransform == null)
                {
                    DisableShouldThink();
                    Destroy(this);
                    return false;
                }

                if (player.IsKilled() || player.limitNetworking)
                {
                    return false;
                }

                if (AttackTarget == player)
                {
                    return true;
                }

                if (npc.lastGunShotTime < Time.time + 2f)
                {
                    npc.nextTriggerTime = Time.time + 0.2f;
                    nextAttackTime = Time.realtimeSinceStartup + 0.2f;
                }

                Senses.Memory.SetKnown(player, npc, null);
                npc.lastAttacker = player;
                AttackTarget = player;
                AttackTransform = player.transform;

                if (!IsInSenseRange(AttackPosition))
                {
                    SenseRange = ListenRange = (isMurderer ? Settings.Murderers.AggressionRange : Settings.Scientists.AggressionRange) + AttackPosition.Distance(ServerPosition);
                    TargetLostRange = SenseRange + (SenseRange * 0.25f);
                }
                else
                {
                    SenseRange = ListenRange = softLimitSenseRange;
                    TargetLostRange = softLimitSenseRange * 1.25f;
                }

                if (converge)
                {
                    Converge();
                }

                return true;
            }
            private void TryReturnHome()
            {
                if (Settings.CanLeave && !IsInHomeRange())
                {
                    CurrentSpeed = BaseNavigator.NavigationSpeed.Normal;

                    Warp();
                }
            }

            private void TryToAttack() => TryToAttack(null);

            private void TryToAttack(BasePlayer attacker)
            {
                if ((attacker ??= GetBestTarget()).IsNull())
                {
                    return;
                }

                if (ShouldForgetTarget(attacker))
                {
                    Forget();

                    return;
                }

                if (!SetTarget(attacker) || AttackTransform == null || !CanSeeTarget(attacker))
                {
                    return;
                }

                if (attackType == AttackType.BaseProjectile)
                {
                    TryScientistActions();
                }
                else
                {
                    TryMurdererActions();
                }

                SwitchToState(AIState.Attack, -1);
            }

            private void TryMurdererActions()
            {
                CurrentSpeed = BaseNavigator.NavigationSpeed.Fast;

                if (!IsInReachableRange())
                {
                    RandomMove(15f);
                }
                else if (!IsInAttackRange())
                {
                    if (attackType == AttackType.FlameThrower)
                    {
                        RandomMove(attackRange);
                    }
                    else
                    {
                        SetDestination(AttackPosition);
                    }
                }
            }

            private void TryScientistActions()
            {
                CurrentSpeed = BaseNavigator.NavigationSpeed.Fast;

                SetDestination();
            }

            public void SetupMovement(List<Vector3> positions)
            {
                this.positions = positions;

                InvokeRepeating(TryToRoam, 0f, 7.5f);
                InvokeRepeating(TryToAttack, 1f, 1f);
            }

            private void TryToRoam()
            {
                if (Settings.KillUnderwater && npc.IsSwimming())
                {
                    DisableShouldThink();
                    npc.Kill();
                    Destroy(this);
                    return;
                }

                if (ValidTarget)
                {
                    return;
                }

                if (IsStuck())
                {
                    Warp();

                    Navigator.stuckTimer = 0f;
                }

                CurrentSpeed = BaseNavigator.NavigationSpeed.Normal;

                SetDestination();
            }

            private bool IsStuck() => false; //InRange(npc.transform.position, Navigator.stuckCheckPosition, Navigator.StuckDistance);

            public void Warp()
            {
                if (Time.time < lastWarpTime)
                {
                    return;
                }

                lastWarpTime = Time.time + 1f;

                DestinationOverride = GetRandomRoamPosition();

                Navigator.Warp(DestinationOverride);
            }

            private void UseFlameThrower()
            {
                if (flameThrower.ammo < flameThrower.maxAmmo * 0.25)
                {
                    flameThrower.SetFlameState(false);
                    flameThrower.ServerReload();
                    return;
                }
                npc.triggerEndTime = Time.time + attackCooldown;
                flameThrower.SetFlameState(true);
                flameThrower.Invoke(() => flameThrower.SetFlameState(false), 2f);
            }

            private void UseWaterGun()
            {
                if (Physics.Raycast(npc.eyes.BodyRay(), out var hit, 10f, 1218652417))
                {
                    WaterBall.DoSplash(hit.point, 2f, ItemManager.FindItemDefinition("water"), 10);
                    DamageUtil.RadiusDamage(npc, liquidWeapon.LookupPrefab(), hit.point, 0.15f, 0.15f, new(), 131072, true);
                }
            }

            private void UseChainsaw()
            {
                AttackEntity.TopUpAmmo();
                AttackEntity.ServerUse();
                AttackTarget.Hurt(10f * AttackEntity.npcDamageScale, DamageType.Bleeding, npc);
            }

            private void MeleeAttack()
            {
                if (baseMelee.IsNull())
                {
                    return;
                }

                if (AttackEntity is Chainsaw)
                {
                    UseChainsaw();
                    return;
                }

                Vector3 position = AttackPosition;
                AttackEntity.StartAttackCooldown(AttackEntity.repeatDelay * 2f);
                npc.SignalBroadcast(BaseEntity.Signal.Attack, string.Empty, null);
                if (baseMelee.swingEffect.isValid)
                {
                    Effect.server.Run(baseMelee.swingEffect.resourcePath, position, Vector3.forward, npc.Connection, false);
                }
                HitInfo hitInfo = new()
                {
                    damageTypes = new(),
                    DidHit = true,
                    Initiator = npc,
                    HitEntity = AttackTarget,
                    HitPositionWorld = position,
                    HitPositionLocal = AttackTransform.InverseTransformPoint(position),
                    HitNormalWorld = npc.eyes.BodyForward(),
                    HitMaterial = StringPool.Get("Flesh"),
                    PointStart = ServerPosition,
                    PointEnd = position,
                    Weapon = AttackEntity,
                    WeaponPrefab = AttackEntity
                };

                hitInfo.damageTypes.Set(DamageType.Slash, baseMelee.TotalDamage() * AttackEntity.npcDamageScale);
                Effect.server.ImpactEffect(hitInfo);
                AttackTarget.OnAttacked(hitInfo);
            }

            private bool CanConverge(global::HumanNPC other)
            {
                if (ValidTarget || other.IsKilled() || other.IsDead()) return false;
                return IsInTargetRange(other.transform.position);
            }

            private bool CanLeave(Vector3 destination)
            {
                return Settings.CanLeave || IsInLeaveRange(destination);
            }

            private bool CanSeeTarget(BasePlayer target)
            {
                if (Navigator.CurrentNavigationType == BaseNavigator.NavigationType.None && (attackType == AttackType.FlameThrower || attackType == AttackType.Melee))
                {
                    return true;
                }

                if (ServerPosition.Distance(target.ServerPosition) < 10f || Senses.Memory.IsLOS(target))
                {
                    return true;
                }

                nextAttackTime = Time.realtimeSinceStartup + 1f;

                return false;
            }

            public bool CanRoam(Vector3 destination)
            {
                return destination == DestinationOverride && IsInSenseRange(destination);
            }

            private bool CanShoot()
            {
                if (attackType == AttackType.None)
                {
                    return false;
                }

                return true;
            }

            public BasePlayer GetBestTarget()
            {
                if (npc.IsWounded())
                {
                    return null;
                }
                float delta = -1f;
                BasePlayer target = null;
                foreach (var player in Senses.Memory.Targets.OfType<BasePlayer>())
                {
                    if (ShouldForgetTarget(player) || !player.IsHuman() && !config.NPC.TargetNpcs) continue;
                    float dist = player.transform.position.Distance(npc.transform.position);
                    float rangeDelta = 1f - Mathf.InverseLerp(1f, SenseRange, dist);
                    rangeDelta += (CanSeeTarget(player) ? 2f : 0f);
                    if (rangeDelta <= delta) continue;
                    target = player;
                    delta = rangeDelta;
                }
                return target;
            }

            private Vector3 GetRandomRoamPosition()
            {
                return positions.GetRandom();
            }

            private bool IsAttackOnCooldown()
            {
                if (attackType == AttackType.None || Time.realtimeSinceStartup < nextAttackTime)
                {
                    return true;
                }

                if (attackCooldown > 0f)
                {
                    nextAttackTime = Time.realtimeSinceStartup + attackCooldown;
                }

                return false;
            }

            private bool IsInAttackRange(float range = 0f)
            {
                return InRange(ServerPosition, AttackPosition, range == 0f ? attackRange : range);
            }

            private bool IsInHomeRange()
            {
                return InRange(ServerPosition, tc.containerPos, Mathf.Max(tc.Radius, TargetLostRange));
            }

            private bool IsInLeaveRange(Vector3 destination)
            {
                return InRange(tc.containerPos, destination, tc.Radius);
            }

            private bool IsInReachableRange()
            {
                if (AttackPosition.y - ServerPosition.y > attackRange)
                {
                    return false;
                }

                return attackType != AttackType.Melee || InRange(AttackPosition, ServerPosition, 15f);
            }

            private bool IsInSenseRange(Vector3 destination)
            {
                return InRange2D(tc.containerPos, destination, SenseRange);
            }

            private bool IsInTargetRange(Vector3 destination)
            {
                return InRange2D(tc.containerPos, destination, TargetLostRange);
            }

            private bool ShouldForgetTarget(BasePlayer target)
            {
                return target.IsKilled() || target.health <= 0f || target.limitNetworking || target.IsDead() || target.skinID == 14922524 || !IsInTargetRange(target.transform.position);
            }
        }

        private class GuidanceSystem : FacepunchBehaviour
        {
            private TimedExplosive missile;
            private ServerProjectile projectile;
            private BaseEntity target;
            private Vector3 launchPos;
            private List<ulong> newmans = new();
            internal DangerousTreasures Instance;

            private Configuration config => Instance.config;

            private void Awake()
            {
                missile = GetComponent<TimedExplosive>();
                projectile = missile.GetComponent<ServerProjectile>();

                launchPos = missile.transform.position;
                launchPos.y = TerrainMeta.HeightMap.GetHeight(launchPos);

                projectile.gravityModifier = 0f;
                projectile.speed = 0.1f;
                projectile.InitializeVelocity(Vector3.up);

                missile.explosionRadius = 0f;

                missile.damageTypes = new(); // no damage
            }

            public void SetTarget(BaseEntity target)
            {
                this.target = target;
            }

            public void Launch(float targettingTime)
            {
                missile.timerAmountMin = config.MissileLauncher.Lifetime;
                missile.timerAmountMax = config.MissileLauncher.Lifetime;

                missile.Spawn();

                Instance.timer.Once(targettingTime, () =>
                {
                    if (missile.IsKilled())
                        return;

                    using var list = Pool.Get<PooledList<BasePlayer>>();
                    using var players = FindEntitiesOfType<BasePlayer>(launchPos, config.Event.Radius + config.MissileLauncher.Distance, Layers.Mask.Player_Server);

                    for (int i = 0; i < players.Count; i++)
                    {
                        var player = players[i];

                        if (player.IsKilled() || !player.IsHuman() || !player.CanInteract())
                            continue;

                        if (config.MissileLauncher.IgnoreFlying && player.IsFlying)
                            continue;

                        if (newmans.Contains(player.userID) || Instance.newmanProtections.Contains(player.userID))
                            continue;

                        list.Add(player); // acquire a player target 
                    }

                    if (list.Count > 0)
                    {
                        target = list.GetRandom(); // pick a random player
                    }
                    else if (!config.MissileLauncher.TargetChest)
                    {
                        missile.SafelyKill();
                        return;
                    }

                    projectile.speed = config.Rocket.Speed * 2f;
                    InvokeRepeating(GuideMissile, 0.1f, 0.1f);
                });
            }

            public void Exclude(List<ulong> newmans)
            {
                if (newmans != null && newmans.Count > 0)
                {
                    this.newmans = newmans.ToList();
                }
            }

            private void GuideMissile()
            {
                if (target == null)
                    return;

                if (target.IsDestroyed)
                {
                    missile.SafelyKill();
                    return;
                }

                if (missile.IsKilled() || projectile == null)
                {
                    Destroy(this);
                    return;
                }

                if (InRange(target.transform.position, missile.transform.position, 1f))
                {
                    missile.Explode();
                    return;
                }

                var direction = (target.transform.position - missile.transform.position) + Vector3.down; // direction to guide the missile
                projectile.InitializeVelocity(direction); // guide the missile to the target's position
            }

            private void OnDestroy()
            {
                try { CancelInvoke(); } catch { }
                Destroy(this);
            }
        }

        public class TreasureChest : FacepunchBehaviour
        {
            internal DangerousTreasures Instance;
            internal ulong userid;
            internal GameObject go;
            internal StorageContainer container;
            internal Vector3 containerPos;
            internal Vector3 lastFirePos;
            internal int npcMaxAmountMurderers;
            internal int npcMaxAmountScientists;
            internal int npcSpawnedAmount;
            internal int countdownTime;
            internal bool started;
            internal bool opened;
            internal bool firstEntered;
            internal bool markerCreated;
            internal bool killed;
            internal bool IsUnloading;
            internal bool requireAllNpcsDie;
            internal bool whenNpcsDie;
            internal float claimTime;
            internal float _radius;
            internal long _unlockTime;
            internal NetworkableId uid;

            private Dictionary<string, List<string>> npcKits = Pool.Get<Dictionary<string, List<string>>>();
            private Dictionary<ulong, float> fireticks = Pool.Get<Dictionary<ulong, float>>();
            private List<FireBall> fireballs = Pool.Get<List<FireBall>>();
            private List<ulong> newmans = Pool.Get<List<ulong>>();
            private List<ulong> traitors = Pool.Get<List<ulong>>();
            private List<ulong> protects = Pool.Get<List<ulong>>();
            private List<ulong> players = Pool.Get<List<ulong>>();
            private List<TimedExplosive> missiles = Pool.Get<List<TimedExplosive>>();
            private List<int> times = Pool.Get<List<int>>();
            private List<SphereEntity> spheres = Pool.Get<List<SphereEntity>>();
            private List<Vector3> missilePositions = Pool.Get<List<Vector3>>();
            private List<Vector3> firePositions = Pool.Get<List<Vector3>>();
            public List<HumanoidNPC> npcs = Pool.Get<List<HumanoidNPC>>();
            private Timer destruct, unlock, countdown, announcement;
            private MapMarkerExplosion explosionMarker;
            private MapMarkerGenericRadius genericMarker;
            private VendingMachineMapMarker vendingMarker;

            private string FormatGridReference(Vector3 position) => Instance.FormatGridReference(position, config.Settings.ShowGrid);

            private void Message(BasePlayer player, string key, params object[] args) => Instance.Message(player, key, args);

            private Configuration config => Instance.config;

            public float Radius
            {
                get
                {
                    return _radius;
                }
                set
                {
                    _radius = value;
                    Awaken();
                }
            }

            private void Free()
            {
                fireballs.ResetToPool();
                newmans.ResetToPool();
                traitors.ResetToPool();
                protects.ResetToPool();
                missiles.ResetToPool();
                times.ResetToPool();
                spheres.ResetToPool();
                missilePositions.ResetToPool();
                firePositions.ResetToPool();
                npcKits.ResetToPool();
                destruct?.Destroy();
                unlock?.Destroy();
                countdown?.Destroy();
                announcement?.Destroy();
            }

            private class NewmanTracker : FacepunchBehaviour
            {
                BasePlayer player;
                TreasureChest chest;
                DangerousTreasures Instance;
                Configuration config => Instance.config;
                private void Message(BasePlayer player, string key, params object[] args) => Instance.Message(player, key, args);

                private void Awake()
                {
                    player = GetComponent<BasePlayer>();
                }

                public void Assign(DangerousTreasures instance, TreasureChest chest)
                {
                    Instance = instance;
                    this.chest = chest;
                    InvokeRepeating(Track, 1f, 0.1f);
                }

                private void Track()
                {
                    if (chest == null || chest.started || player.IsKilled() || !player.IsConnected || !chest.players.Contains(player.userID))
                    {
                        Destroy(this);
                        return;
                    }

                    if (!InRange2D(player.transform.position, chest.containerPos, chest.Radius))
                    {
                        return;
                    }

                    if (config.NewmanMode.Aura || config.NewmanMode.Harm)
                    {
                        List<Item> itemList = Pool.Get<List<Item>>();
                        player.inventory.GetAllItems(itemList);
                        int sum = itemList.Sum(item => player.IsHostileItem(item) ? 1 : 0);
                        Pool.FreeUnmanaged(ref itemList);

                        if (sum == 0)
                        {
                            if (config.NewmanMode.Aura && !chest.newmans.Contains(player.userID) && !chest.traitors.Contains(player.userID))
                            {
                                Message(player, "Newman Enter");
                                chest.newmans.Add(player.userID);
                            }

                            if (config.NewmanMode.Harm && !Instance.newmanProtections.Contains(player.userID) && !chest.protects.Contains(player.userID) && !chest.traitors.Contains(player.userID))
                            {
                                Message(player, "Newman Protect");
                                Instance.newmanProtections.Add(player.userID);
                                chest.protects.Add(player.userID);
                            }

                            if (!chest.traitors.Contains(player.userID))
                            {
                                return;
                            }
                        }

                        if (chest.newmans.Remove(player.userID))
                        {
                            Message(player, config.Fireballs.Enabled ? "Newman Traitor Burn" : "Newman Traitor");

                            if (!chest.traitors.Contains(player.userID))
                                chest.traitors.Add(player.userID);

                            Instance.newmanProtections.Remove(player.userID);
                            chest.protects.Remove(player.userID);
                        }
                    }

                    if (!config.Fireballs.Enabled || player.IsFlying)
                    {
                        return;
                    }

                    var stamp = Time.realtimeSinceStartup;

                    if (!chest.fireticks.ContainsKey(player.userID))
                    {
                        chest.fireticks[player.userID] = stamp + config.Fireballs.SecondsBeforeTick;
                    }

                    if (chest.fireticks[player.userID] - stamp <= 0)
                    {
                        chest.fireticks[player.userID] = stamp + config.Fireballs.SecondsBeforeTick;
                        chest.SpawnFire(player.transform.position);
                    }
                }

                private void OnDestroy()
                {
                    try { CancelInvoke(Track); } catch { }
                    Destroy(this);
                }
            }

            public void Kill(bool isUnloading)
            {
                Instance.treasureChests.Remove(uid);
                IsUnloading = isUnloading;
                if (killed) return;
                killed = true;

                if (!container.IsKilled())
                {
                    container.inventory.Clear();
                    ItemManager.DoRemoves();
                    container.Kill();
                }

                RemoveMapMarkers();
                KillNpc();
                CancelInvoke();
                DestroyLauncher();
                DestroySphere();
                DestroyFire();
                Interface.CallHook("OnDangerousEventEnded", containerPos);
                Destroy(go);
                Destroy(this);
            }

            public bool HasRustMarker
            {
                get
                {
                    return explosionMarker != null || vendingMarker != null;
                }
            }

            public void Awaken()
            {
                SetupNpcKits();

                var collider = gameObject.GetComponent<SphereCollider>() ?? gameObject.AddComponent<SphereCollider>();
                collider.center = Vector3.zero;
                collider.radius = Radius;
                collider.isTrigger = true;
                collider.enabled = true;

                requireAllNpcsDie = config.Unlock.RequireAllNpcsDie;
                whenNpcsDie = config.Unlock.WhenNpcsDie;

                if (config.Event.Spheres && config.Event.SphereAmount > 0)
                {
                    for (int i = 0; i < config.Event.SphereAmount; i++)
                    {
                        var sphere = GameManager.server.CreateEntity(StringPool.Get(3211242734), containerPos) as SphereEntity;

                        if (sphere == null)
                        {
                            Puts(Instance._("Invalid Constant", null, 3211242734));
                            config.Event.Spheres = false;
                            break;
                        }

                        sphere.currentRadius = 1f;
                        sphere.Spawn();
                        sphere.LerpRadiusTo(Radius * 2f, 5f);
                        spheres.Add(sphere);
                    }
                }

                if (config.Rocket.Enabled)
                {
                    foreach (var position in GetRandomPositions(containerPos, Radius * 3f, config.Rocket.Amount, 0f))
                    {
                        var prefab = config.Rocket.FireRockets ? "assets/prefabs/ammo/rocket/rocket_fire.prefab" : "assets/prefabs/ammo/rocket/rocket_basic.prefab";
                        var missile = GameManager.server.CreateEntity(prefab, position) as TimedExplosive;
                        var gs = missile.gameObject.AddComponent<GuidanceSystem>();

                        gs.Instance = Instance;
                        gs.SetTarget(container);
                        gs.Launch(0.1f);
                    }
                }

                if (config.Fireballs.Enabled)
                {
                    firePositions = GetRandomPositions(containerPos, Radius, 25, containerPos.y + 25f);

                    if (firePositions.Count > 0)
                        InvokeRepeating(SpawnFire, 0.1f, config.Fireballs.SecondsBeforeTick);
                }

                if (config.MissileLauncher.Enabled)
                {
                    missilePositions = GetRandomPositions(containerPos, Radius, 25, 1);

                    if (missilePositions.Count > 0)
                    {
                        InvokeRepeating(LaunchMissile, 0.1f, config.MissileLauncher.Frequency);
                        LaunchMissile();
                    }
                }

                InvokeRepeating(UpdateMarker, 5f, 30f);
                Interface.CallHook("OnDangerousEventStarted", containerPos);
            }

            void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                container = GetComponent<StorageContainer>();
                container.OwnerID = 0;
                container.dropsLoot = false;
                containerPos = container.transform.position;
                uid = container.net.ID;
                container.inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);
            }

            public void SpawnLoot(StorageContainer container, List<LootItem> treasure)
            {
                if (container.IsKilled() || treasure == null || treasure.Count == 0)
                {
                    return;
                }

                var loot = treasure.ToList();
                int j = 0;

                container.inventory.Clear();
                container.inventory.capacity = Math.Min(config.Event.TreasureAmount, loot.Count);

                while (j++ < container.inventory.capacity && loot.Count > 0)
                {
                    var lootItem = loot.GetRandom();
                    var definition = ItemManager.FindItemDefinition(lootItem.shortname);

                    loot.Remove(lootItem);

                    if (UnityEngine.Random.value > lootItem.probability)
                    {
                        continue;
                    }

                    if (definition == null)
                    {
                        Instance.PrintError("Invalid shortname in config: {0}", lootItem.shortname);
                        continue;
                    }

                    int amount = UnityEngine.Random.Range(lootItem.amountMin, lootItem.amount + 1);

                    if (amount <= 0)
                    {
                        j--;
                        continue;
                    }

                    if (definition.stackable == 1 || (definition.condition.enabled && definition.condition.max > 0f))
                    {
                        amount = 1;
                    }

                    ulong skin = lootItem.skins.Count > 0 ? lootItem.skins.GetRandom() : lootItem.skin;
                    Item item = ItemManager.CreateByName(definition.shortname, amount, skin);

                    if (item.info.stackable > 1 && !item.hasCondition)
                    {
                        item.amount = Instance.GetPercentIncreasedAmount(amount);
                    }

                    if (item.hasCondition)
                    {
                        item.condition = lootItem.condition * item.info.condition.max;
                    }

                    if (config.Treasure.RandomSkins && skin == 0)
                    {
                        item.skin = GetItemSkin(definition, lootItem.skin, false);
                    }

                    if (skin != 0 && item.GetHeldEntity())
                    {
                        item.GetHeldEntity().skinID = skin;
                    }

                    if (!string.IsNullOrEmpty(lootItem.name))
                    {
                        item.name = lootItem.name;
                    }

                    item.MarkDirty();

                    if (!item.MoveToContainer(container.inventory, -1, true))
                    {
                        item.Remove(0.1f);
                    }
                }
            }

            private Dictionary<string, ulong> skinIds { get; set; } = new();

            private bool IsBlacklistedSkin(ItemDefinition def, int num)
            {
                var skinId = ItemDefinition.FindSkin(def.isRedirectOf?.itemid ?? def.itemid, num);
                var dirSkin = def.isRedirectOf == null ? def.skins.FirstOrDefault(x => (ulong)x.id == skinId) : def.isRedirectOf.skins.FirstOrDefault(x => (ulong)x.id == skinId);
                var itemSkin = (dirSkin.id == 0) ? null : (dirSkin.invItem as ItemSkin);

                return itemSkin?.Redirect != null || def.isRedirectOf != null;
            }

            public ulong GetItemSkin(ItemDefinition def, ulong defaultSkin, bool unique)
            {
                ulong skin = defaultSkin;

                if (def.shortname != "explosive.satchel" && def.shortname != "grenade.f1")
                {
                    if (!skinIds.TryGetValue(def.shortname, out skin)) // apply same skin once randomly chosen so items with skins can stack properly
                    {
                        skin = defaultSkin;
                    }

                    if (!unique || skin == 0)
                    {
                        var si = GetItemSkins(def);
                        var random = new List<ulong>();

                        if ((def.shortname == "box.wooden.large" && config.Skins.RandomWorkshopSkins) || (def.shortname != "box.wooden.large" && config.Treasure.RandomWorkshopSkins))
                        {
                            if (si.workshopSkins.Count > 0)
                            {
                                random.Add(si.workshopSkins.GetRandom());
                            }
                        }

                        if (config.Skins.RandomSkins && si.skins.Count > 0)
                        {
                            random.Add(si.skins.GetRandom());
                        }

                        if (random.Count != 0)
                        {
                            skinIds[def.shortname] = skin = random.GetRandom();
                        }
                    }
                }

                return skin;
            }

            public SkinInfo GetItemSkins(ItemDefinition def)
            {
                if (!Instance.Skins.TryGetValue(def.shortname, out var si))
                {
                    Instance.Skins[def.shortname] = si = new();

                    foreach (var skin in def.skins)
                    {
                        if (IsBlacklistedSkin(def, skin.id))
                        {
                            continue;
                        }

                        var id = Convert.ToUInt64(skin.id);

                        si.skins.Add(id);
                        si.allSkins.Add(id);
                    }

                    if (def.skins2 == null)
                    {
                        return si;
                    }

                    foreach (var skin in def.skins2)
                    {
                        if (IsBlacklistedSkin(def, (int)skin.WorkshopId))
                        {
                            continue;
                        }

                        if (!si.workshopSkins.Contains(skin.WorkshopId))
                        {
                            si.workshopSkins.Add(skin.WorkshopId);
                            si.allSkins.Add(skin.WorkshopId);
                        }
                    }
                }

                return si;
            }

            void OnTriggerEnter(Collider col)
            {
                var player = col.ToBaseEntity() as BasePlayer;

                if (player == null || !player.IsHuman())
                    return;

                if (players.Contains(player.userID))
                    return;

                Interface.CallHook("OnPlayerEnteredDangerousEvent", player, containerPos, config.TruePVE.AllowPVPAtEvents);

                if (started)
                    return;

                if (config.Unlock.LockToPlayerFirstEntered && !userid.IsSteamId())
                {
                    userid = player.userID;
                }

                if (config.EventMessages.FirstEntered && !firstEntered && !player.IsFlying)
                {
                    firstEntered = true;
                    foreach (var target in BasePlayer.activePlayerList)
                    {
                        Message(target, "OnFirstPlayerEntered", player.displayName, FormatGridReference(containerPos));
                    }
                }

                if (config.EventMessages.NoobWarning)
                {
                    Message(player, whenNpcsDie && npcSpawnedAmount > 0 ? "Npc Event" : requireAllNpcsDie && npcSpawnedAmount > 0 ? "Timed Npc Event" : "Timed Event");
                }
                else if (config.EventMessages.Entered)
                {
                    Message(player, config.Fireballs.Enabled ? "Dangerous Zone Protected" : "Dangerous Zone Unprotected");
                }

                var tracker = player.gameObject.GetComponent<NewmanTracker>() ?? player.gameObject.AddComponent<NewmanTracker>();

                tracker.Assign(Instance, this);

                players.Add(player.userID);
            }

            void OnTriggerExit(Collider col)
            {
                var player = col.ToBaseEntity() as BasePlayer;

                if (!player.IsValid())
                    return;

                if (player.IsHuman())
                    Interface.CallHook("OnPlayerExitedDangerousEvent", player, containerPos, config.TruePVE.AllowPVPAtEvents);
                else if (player is HumanoidNPC npc && npcs.Contains(npc))
                {
                    if (npc.NavAgent != null && npc.NavAgent.isOnNavMesh)
                        npc.NavAgent.SetDestination(containerPos);

                    npc.finalDestination = containerPos;
                }

                if (config.NewmanMode.Harm)
                {
                    if (protects.Remove(player.userID))
                    {
                        Instance.newmanProtections.Remove(player.userID);
                        Message(player, "Newman Protect Fade");
                    }

                    newmans.Remove(player.userID);
                }
            }

            public void SpawnNpcs()
            {
                container.SendNetworkUpdate();

                npcMaxAmountMurderers = config.NPC.Murderers.SpawnAmount > 0 ? UnityEngine.Random.Range(config.NPC.Murderers.SpawnMinAmount, config.NPC.Murderers.SpawnAmount + 1) : config.NPC.Murderers.SpawnAmount;
                npcMaxAmountScientists = config.NPC.Scientists.SpawnAmount > 0 ? UnityEngine.Random.Range(config.NPC.Scientists.SpawnMinAmount, config.NPC.Scientists.SpawnAmount + 1) : config.NPC.Scientists.SpawnAmount;

                if (npcMaxAmountMurderers > 0)
                {
                    for (int i = 0; i < npcMaxAmountMurderers; i++)
                    {
                        SpawnNpc(true);
                    }
                }

                if (npcMaxAmountScientists > 0)
                {
                    for (int i = 0; i < npcMaxAmountScientists; i++)
                    {
                        SpawnNpc(false);
                    }
                }

                npcSpawnedAmount = npcs.Count;
            }

            private NavMeshHit _navHit;

            private Vector3 FindPointOnNavmesh(Vector3 target, float radius)
            {
                int tries = 0;

                while (++tries < 100)
                {
                    if (NavMesh.SamplePosition(target, out _navHit, radius, NavMesh.AllAreas))
                    {
                        float y = TerrainMeta.HeightMap.GetHeight(_navHit.position);

                        if (_navHit.position.y < y || !IsAcceptableWaterDepth(_navHit.position))
                        {
                            continue;
                        }

                        if (!InRange2D(_navHit.position, containerPos, Radius - 2.5f))
                        {
                            continue;
                        }

                        if (TestInsideRock(_navHit.position) || TestInsideObject(_navHit.position))
                        {
                            continue;
                        }

                        return _navHit.position;
                    }
                }

                return Vector3.zero;
            }

            private RaycastHit _hit;

            private bool IsAcceptableWaterDepth(Vector3 position)
            {
                return WaterLevel.GetOverallWaterDepth(position, true, true, null) <= 0.75f;
            }

            private bool TestInsideObject(Vector3 position)
            {
                return GamePhysics.CheckSphere(position, 0.5f, Layers.Mask.Player_Server | Layers.Server.Deployed, QueryTriggerInteraction.Ignore);
            }

            private bool TestInsideRock(Vector3 a)
            {
                Physics.queriesHitBackfaces = true;

                bool flag = IsRockFaceUpwards(a);

                Physics.queriesHitBackfaces = false;

                return flag || IsRockFaceDownwards(a);
            }

            private bool IsRockFaceDownwards(Vector3 a)
            {
                Vector3 b = a + new Vector3(0f, 20f, 0f);
                Vector3 d = a - b;
                RaycastHit[] hits = Physics.RaycastAll(b, d, d.magnitude, TARGET_MASK);
                return hits.Exists(hit => IsRock(hit.collider.name));
            }

            private bool IsRockFaceUpwards(Vector3 point)
            {
                if (!Physics.Raycast(point, Vector3.up, out _hit, 20f, TARGET_MASK)) return false;
                return IsRock(_hit.collider.gameObject.name);
            }

            private bool IsRock(string name) => _prefabs.Exists(value => name.Contains(value, CompareOptions.OrdinalIgnoreCase));

            private List<string> _prefabs = new() { "rock", "formation", "junk", "cliff", "invisible" };

            private static void CopySerializableFields<T>(T src, T dst)
            {
                var srcFields = typeof(T).GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
                foreach (var field in srcFields)
                {
                    object value = field.GetValue(src);
                    field.SetValue(dst, value);
                }
            }

            private bool InstantiateEntity(Vector3 position, bool isMurderer, out HumanoidBrain humanoidBrain, out HumanoidNPC npc)
            {
                var prefabName = StringPool.Get(1536035819);
                var prefab = GameManager.server.FindPrefab(prefabName);
                var go = Facepunch.Instantiate.GameObject(prefab, position, Quaternion.identity);

                go.SetActive(false);

                go.name = prefabName;

                ScientistBrain scientistBrain = go.GetComponent<ScientistBrain>();
                ScientistNPC scientistNpc = go.GetComponent<ScientistNPC>(); 
                
                npc = go.AddComponent<HumanoidNPC>();

                humanoidBrain = go.AddComponent<HumanoidBrain>();
                humanoidBrain.Instance = Instance;
                humanoidBrain.DestinationOverride = position;
                humanoidBrain.CheckLOS = humanoidBrain.RefreshKnownLOS = true;
                humanoidBrain.SenseRange = isMurderer ? config.NPC.Murderers.AggressionRange : config.NPC.Scientists.AggressionRange;
                humanoidBrain.softLimitSenseRange = humanoidBrain.SenseRange + (humanoidBrain.SenseRange * 0.25f);
                humanoidBrain.TargetLostRange = humanoidBrain.SenseRange * 1.25f;
                humanoidBrain.Settings = config.NPC;
                humanoidBrain.UseAIDesign = false;
                humanoidBrain._baseEntity = npc;
                humanoidBrain.tc = this;
                humanoidBrain.npc = npc;
                humanoidBrain.states ??= new();
                npc.Brain = humanoidBrain;

                CopySerializableFields(scientistNpc, npc);
                DestroyImmediate(scientistBrain, true);
                DestroyImmediate(scientistNpc, true);

                SceneManager.MoveGameObjectToScene(go, Rust.Server.EntityScene);

                go.SetActive(true);

                return npc != null;
            }

            private Vector3 RandomPosition(float radius)
            {
                return RandomWanderPositions(Radius * 0.9f).FirstOrDefault();
            }

            private List<Vector3> RandomWanderPositions(float radius)
            {
                var positions = new List<Vector3>();

                for (int i = 0; i < 10; i++)
                {
                    var target = GetRandomPoint(radius);
                    var vector = FindPointOnNavmesh(target, radius);

                    if (vector != Vector3.zero)
                    {
                        positions.Add(vector);
                    }
                }

                return positions;
            }

            private Vector3 GetRandomPoint(float radius)
            {
                var vector = containerPos + UnityEngine.Random.onUnitSphere * radius;

                vector.y = TerrainMeta.HeightMap.GetHeight(vector);

                return vector;
            }

            private HumanoidNPC SpawnNpc(bool isMurderer)
            {
                var positions = RandomWanderPositions(Radius * 0.9f);

                if (positions.Count == 0)
                {
                    return null;
                }

                var position = RandomPosition(Radius * 0.9f);

                if (position == Vector3.zero)
                {
                    return null;
                }

                if (!InstantiateEntity(position, isMurderer, out var brain, out var npc))
                {
                    return null;
                }

                brain.isMurderer = isMurderer;
                npc.skinID = 14922525;
                npc.userID = (ulong)UnityEngine.Random.Range(0, 10000000);
                npc.UserIDString = npc.userID.ToString();
                Instance.HumanoidBrains[brain.uid = npc.userID] = brain;

                if (isMurderer)
                {
                    brain.displayName = config.NPC.Murderers.RandomNames.Count > 0 ? config.NPC.Murderers.RandomNames.GetRandom() : RandomUsernames.Get(npc.userID);
                }
                else brain.displayName = config.NPC.Scientists.RandomNames.Count > 0 ? config.NPC.Scientists.RandomNames.GetRandom() : RandomUsernames.Get(npc.userID);

                npc.displayName = brain.displayName;

                BasePlayer.bots.Add(npc);

                npc.loadouts = new PlayerInventoryProperties[0];

                npc.Spawn();

                npc.CancelInvoke(npc.EquipTest);

                npcs.Add(npc);

                SetupNpc(npc, brain, isMurderer, positions);

                return npc;
            }

            public class Loadout
            {
                public List<PlayerInventoryProperties.ItemAmountSkinned> belt = new();
                public List<PlayerInventoryProperties.ItemAmountSkinned> main = new();
                public List<PlayerInventoryProperties.ItemAmountSkinned> wear = new();
            }

            private PlayerInventoryProperties GetLoadout(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer)
            {
                var loadout = CreateLoadout(npc, brain, isMurderer);
                var pip = ScriptableObject.CreateInstance<PlayerInventoryProperties>();

                pip.belt = loadout.belt;
                pip.main = loadout.main;
                pip.wear = loadout.wear;

                return pip;
            }

            private Loadout CreateLoadout(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer)
            {
                var loadout = new Loadout();
                var items = isMurderer ? config.NPC.Murderers.Items : config.NPC.Scientists.Items;

                AddItemAmountSkinned(loadout.wear, items.Boots);
                AddItemAmountSkinned(loadout.wear, items.Gloves);
                AddItemAmountSkinned(loadout.wear, items.Helm);
                AddItemAmountSkinned(loadout.wear, items.Pants);
                AddItemAmountSkinned(loadout.wear, items.Shirt);
                AddItemAmountSkinned(loadout.wear, items.Torso);
                if (!items.Torso.Exists(v => v.Contains("suit")))
                {
                    AddItemAmountSkinned(loadout.wear, items.Kilts);
                }
                AddItemAmountSkinned(loadout.belt, items.Weapon);

                return loadout;
            }

            private void AddItemAmountSkinned(List<PlayerInventoryProperties.ItemAmountSkinned> source, List<string> shortnames)
            {
                if (shortnames.Count == 0)
                {
                    return;
                }

                string shortname = shortnames.GetRandom();

                if (string.IsNullOrEmpty(shortname))
                {
                    return;
                }

                ItemDefinition def = ItemManager.FindItemDefinition(shortname);

                if (def == null)
                {
                    Puts("Invalid shortname: {0}", shortname);
                    return;
                }

                ulong skin = 0uL;
                if (config.Skins.Npcs)
                {
                    skin = GetItemSkin(def, 0uL, config.Skins.UniqueNpcs);
                }

                source.Add(new()
                {
                    amount = 1,
                    itemDef = def,
                    skinOverride = skin,
                    startAmount = 1
                });
            }

            private void SetupNpc(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer, List<Vector3> positions)
            {
                if (isMurderer && config.NPC.Murderers.DespawnInventory || !isMurderer && config.NPC.Scientists.DespawnInventory)
                {
                    npc.LootSpawnSlots = Array.Empty<LootContainer.LootSpawnSlot>();
                }

                var alternate = isMurderer ? config.NPC.Murderers.Alternate : config.NPC.Scientists.Alternate;

                if (!alternate.None)
                {
                    if (alternate.Enabled && alternate.IDs.Count > 0)
                    {
                        var id = alternate.GetRandom();
                        var lootSpawnSlots = GameManager.server.FindPrefab(StringPool.Get(id))?.GetComponent<ScientistNPC>()?.LootSpawnSlots;

                        if (lootSpawnSlots != null)
                        {
                            npc.LootSpawnSlots = lootSpawnSlots;
                        }
                    }
                }
                else npc.LootSpawnSlots = Array.Empty<LootContainer.LootSpawnSlot>();

                npc.CancelInvoke(npc.PlayRadioChatter);
                npc.DeathEffects = Array.Empty<GameObjectRef>();
                npc.RadioChatterEffects = Array.Empty<GameObjectRef>();
                npc.radioChatterType = ScientistNPC.RadioChatterType.NONE;
                npc.startHealth = isMurderer ? config.NPC.Murderers.Health : config.NPC.Scientists.Health;
                npc.InitializeHealth(npc.startHealth, npc.startHealth);
                npc.Invoke(() => UpdateItems(npc, brain, isMurderer), 0.2f);
                npc.Invoke(() => brain.SetupMovement(positions), 0.3f);
                GiveKit(npc, brain, isMurderer);
            }

            private void GiveKit(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer)
            {
                brain.isMurderer = isMurderer;

                if (npcKits.TryGetValue(isMurderer ? "murderer" : "scientist", out var kits) && kits.Count > 0)
                {
                    string kit = kits.GetRandom();

                    if (Instance.Kits?.Call("GiveKit", npc, kit) is string val)
                    {
                        if (val.Contains("Couldn't find the player"))
                        {
                            val = "Npcs cannot use the CopyPasteFile field in Kits";
                        }
                        Puts("Invalid kit '{0}' ({1})", kit, val);
                    }
                }

                List<Item> itemList = Pool.Get<List<Item>>();
                bool isInventoryEmpty = npc.inventory.GetAllItems(itemList) == 0;
                Pool.FreeUnmanaged(ref itemList);

                if (isInventoryEmpty)
                {
                    var loadout = GetLoadout(npc, brain, isMurderer);

                    if (loadout.belt.Count > 0 || loadout.main.Count > 0 || loadout.wear.Count > 0)
                    {
                        npc.loadouts = new PlayerInventoryProperties[1];
                        npc.loadouts[0] = loadout;
                        npc.EquipLoadout(npc.loadouts);
                        isInventoryEmpty = false;
                    }
                }

                if (isInventoryEmpty)
                {
                    npc.inventory.GiveItem(ItemManager.CreateByName(isMurderer ? "halloween.surgeonsuit" : "hazmatsuit.spacesuit", 1, 0uL), npc.inventory.containerWear);
                    npc.inventory.GiveItem(ItemManager.CreateByName(isMurderer ? "knife.combat" : "pistol.python", 1, isMurderer ? 1703079727uL : 2241854552uL), npc.inventory.containerBelt);
                }
            }

            private void UpdateItems(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer)
            {
                brain.Init();
                brain.isMurderer = isMurderer;

                EquipWeapon(npc, brain);

                if (!ToggleNpcMinerHat(npc, TOD_Sky.Instance?.IsNight == true))
                {
                    npc.inventory.ServerUpdate(0f);
                }
            }

            private bool ToggleNpcMinerHat(HumanoidNPC npc, bool state)
            {
                if (npc.IsNull() || npc.inventory == null || npc.IsDead())
                {
                    return false;
                }

                var slot = npc.inventory.FindItemByItemName("hat.miner");

                if (slot == null)
                {
                    return false;
                }

                if (state && slot.contents != null)
                {
                    slot.contents.AddItem(ItemManager.FindItemDefinition("lowgradefuel"), 50);
                }

                slot.SwitchOnOff(state);
                npc.inventory.ServerUpdate(0f);
                return true;
            }

            public void EquipWeapon(HumanoidNPC npc, HumanoidBrain brain)
            {
                bool isHoldingProjectileWeapon = false;

                List<Item> itemList = Pool.Get<List<Item>>();
                npc.inventory.GetAllItems(itemList);
                try
                {
                    foreach (Item item in itemList)
                    {
                        if (item.GetHeldEntity() is HeldEntity e && e.IsValid())
                        {
                            if (item.skin != 0)
                            {
                                e.skinID = item.skin;
                                e.SendNetworkUpdate();
                            }

                            if (e.ShortPrefabName == "rocket_launcher.entity" || e.ShortPrefabName == "mgl.entity")
                            {
                                continue;
                            }

                            if (e is not AttackEntity attackEntity)
                            {
                                continue;
                            }

                            if (!isHoldingProjectileWeapon && attackEntity.hostileScore >= 2f && item.GetRootContainer() == npc.inventory.containerBelt && brain._attackEntity.IsNull())
                            {
                                isHoldingProjectileWeapon = e is BaseProjectile;

                                brain.UpdateWeapon(attackEntity, item.uid);
                            }
                        }

                        item.MarkDirty();
                    }
                }
                finally
                {
                    Pool.FreeUnmanaged(ref itemList);
                    brain.IdentifyWeapon();
                }
            }

            void SetupNpcKits()
            {
                npcKits = new()
                {
                    { "murderer", config.NPC.Murderers.Kits.Where(kit => IsKit(kit)).ToList() },
                    { "scientist", config.NPC.Scientists.Kits.Where(kit => IsKit(kit)).ToList() }
                };
            }

            bool IsKit(string kit)
            {
                return Convert.ToBoolean(Instance.Kits?.Call("isKit", kit));
            }

            public void UpdateMarker()
            {
                if (!config.Event.MarkerVending && !config.Event.MarkerExplosion)
                {
                    CancelInvoke(UpdateMarker);
                }

                if (markerCreated)
                {
                    if (!explosionMarker.IsKilled())
                    {
                        explosionMarker.SendNetworkUpdate();
                    }

                    if (!genericMarker.IsKilled())
                    {
                        genericMarker.SendUpdate();
                    }

                    if (!vendingMarker.IsKilled())
                    {
                        vendingMarker.transform.position = containerPos;
                        vendingMarker.markerShopName = config.Event.MarkerName;
                        vendingMarker.SendNetworkUpdate();
                    }

                    return;
                }

                if (config.Event.MarkerManager && Instance.MarkerManager.CanCall())
                {
                    Interface.CallHook("API_CreateMarker", container as BaseEntity, "DangerousTreasures", 0, 10f, 0.25f, config.Event.MarkerName, "FF0000", "00FFFFFF");
                    markerCreated = true;
                    return;
                }

                if (Instance.treasureChests.Sum(e => e.Value.HasRustMarker ? 1 : 0) > 10)
                {
                    return;
                }

                //explosionmarker cargomarker ch47marker cratemarker
                if (config.Event.MarkerVending)
                {
                    vendingMarker = GameManager.server.CreateEntity(StringPool.Get(3459945130), containerPos) as VendingMachineMapMarker;

                    if (vendingMarker != null)
                    {
                        vendingMarker.enabled = false;
                        vendingMarker.markerShopName = config.Event.MarkerName;
                        vendingMarker.Spawn();
                    }

                    CreateGenericMarker();
                }
                else if (config.Event.MarkerExplosion)
                {
                    explosionMarker = GameManager.server.CreateEntity(StringPool.Get(4060989661), containerPos) as MapMarkerExplosion;

                    if (explosionMarker != null)
                    {
                        explosionMarker.Spawn();
                        explosionMarker.Invoke(() => explosionMarker.CancelInvoke(explosionMarker.DelayedDestroy), 1f);
                    }

                    CreateGenericMarker();
                }

                markerCreated = true;
            }

            private void CreateGenericMarker()
            {
                genericMarker = GameManager.server.CreateEntity(StringPool.Get(2849728229), containerPos) as MapMarkerGenericRadius;

                if (genericMarker != null)
                {
                    genericMarker.alpha = 0.75f;
                    genericMarker.color2 = __(config.Event.MarkerColor);
                    genericMarker.radius = Mathf.Min(1f, World.Size <= 3600 ? config.Event.MarkerRadiusSmall : config.Event.MarkerRadius);
                    genericMarker.Spawn();
                    genericMarker.SendUpdate();
                }
            }

            private void SafelyKill(HumanoidNPC npc)
            {
                if (!npc.IsRealNull() && Instance.HumanoidBrains.TryGetValue(npc.userID, out var brain))
                {
                    brain.DisableShouldThink();
                }
                npc.SafelyKill();
            }

            private void KillNpc()
            {
                npcs.ForEach(SafelyKill);
            }

            public void RemoveMapMarkers()
            {
                if (!explosionMarker.IsKilled())
                {
                    explosionMarker.CancelInvoke(explosionMarker.DelayedDestroy);
                    explosionMarker.Kill(BaseNetworkable.DestroyMode.None);
                }

                genericMarker.SafelyKill();
                vendingMarker.SafelyKill();
            }

            private void OnDestroy()
            {
                DestroyMe();
            }

            public void DestroyMe()
            {
                Kill(IsUnloading);

                if (!IsUnloading && Instance.treasureChests.Count == 0)
                {
                    Instance.SubscribeHooks(false);
                }

                Free();
            }

            public void LaunchMissile()
            {
                if (!config.MissileLauncher.Enabled)
                {
                    DestroyLauncher();
                    return;
                }

                var missilePos = missilePositions.GetRandom();
                float y = TerrainMeta.HeightMap.GetHeight(missilePos) + 15f;
                missilePos.y = 200f;

                if (Physics.Raycast(missilePos, Vector3.down, out var hit, heightLayer)) // don't want the missile to explode before it leaves its spawn location
                    missilePos.y = Mathf.Max(hit.point.y, y);

                var prefab = config.Rocket.FireRockets ? "assets/prefabs/ammo/rocket/rocket_fire.prefab" : "assets/prefabs/ammo/rocket/rocket_basic.prefab";
                var missile = GameManager.server.CreateEntity(prefab, missilePos) as TimedExplosive;

                if (missile == null)
                {
                    config.MissileLauncher.Enabled = false;
                    DestroyLauncher();
                    return;
                }

                missiles.Add(missile);
                missiles.RemoveAll(x => x.IsKilled());

                var gs = missile.gameObject.AddComponent<GuidanceSystem>();

                gs.Instance = Instance;
                gs.Exclude(newmans);
                gs.SetTarget(container);
                gs.Launch(config.MissileLauncher.TargettingTime);
            }

            void SpawnFire()
            {
                var firePos = firePositions.GetRandom();
                int retries = firePositions.Count;

                while (InRange2D(firePos, lastFirePos, Radius * 0.35f) && --retries > 0)
                {
                    firePos = firePositions.GetRandom();
                }

                SpawnFire(firePos);
                lastFirePos = firePos;
            }

            void SpawnFire(Vector3 firePos)
            {
                if (!config.Fireballs.Enabled)
                    return;

                if (fireballs.Count >= 6) // limit fireballs
                {
                    foreach (var entry in fireballs)
                    {
                        entry.SafelyKill();
                        fireballs.Remove(entry);
                        break;
                    }
                }

                var fireball = GameManager.server.CreateEntity(StringPool.Get(3550347674), firePos) as FireBall;

                if (fireball == null)
                {
                    Puts(Instance._("Invalid Constant", null, 3550347674));
                    config.Fireballs.Enabled = false;
                    CancelInvoke(SpawnFire);
                    firePositions.Clear();
                    return;
                }

                fireball.Spawn();
                fireball.damagePerSecond = config.Fireballs.DamagePerSecond;
                fireball.generation = config.Fireballs.Generation;
                fireball.lifeTimeMax = config.Fireballs.LifeTimeMax;
                fireball.lifeTimeMin = config.Fireballs.LifeTimeMin;
                fireball.radius = config.Fireballs.Radius;
                fireball.tickRate = config.Fireballs.TickRate;
                fireball.waterToExtinguish = config.Fireballs.WaterToExtinguish;
                fireball.SendNetworkUpdate();
                fireball.Think();

                float lifeTime = UnityEngine.Random.Range(config.Fireballs.LifeTimeMin, config.Fireballs.LifeTimeMax);
                Instance.timer.Once(lifeTime, () => fireball?.Extinguish());

                fireballs.Add(fireball);
            }

            public void Destruct()
            {
                if (config.EventMessages.Destruct)
                {
                    var posStr = FormatGridReference(containerPos);

                    foreach (var target in BasePlayer.activePlayerList)
                        Message(target, "OnChestDespawned", posStr);
                }

                container.SafelyKill();
            }

            void Unclaimed()
            {
                if (!started)
                    return;

                float time = claimTime - Time.realtimeSinceStartup;

                if (time < 60f)
                    return;

                string eventPos = FormatGridReference(containerPos);

                foreach (var target in BasePlayer.activePlayerList)
                    Message(target, "DestroyingTreasure", eventPos, Instance.FormatTime(time, target.UserIDString), config.Settings.DistanceChatCommand);
            }

            public string GetUnlockTime(string userID = null)
            {
                return started ? null : Instance.FormatTime(_unlockTime - Time.realtimeSinceStartup, userID);
            }

            public void Unlock()
            {
                if (unlock != null && !unlock.Destroyed)
                {
                    unlock.Destroy();
                }

                if (!started)
                {
                    started = true;

                    if (config.Event.DestroySphereOnStart)
                    {
                        DestroySphere();
                    }

                    DestroyFire();

                    DestroyLauncher();

                    if (config.Event.DestructTime > 0f && destruct == null)
                        destruct = Instance.timer.Once(config.Event.DestructTime, Destruct);

                    if (config.EventMessages.Started)
                    {
                        var posStr = FormatGridReference(containerPos);
                        foreach (var target in BasePlayer.activePlayerList)
                        {
                            Message(target, requireAllNpcsDie && npcSpawnedAmount > 0 ? "StartedNpcs" : "Started", posStr);
                        }
                        Puts(Instance._(requireAllNpcsDie && npcSpawnedAmount > 0 ? "StartedNpcs" : "Started", null, Instance.FormatGridReference(containerPos, true)));
                    }

                    if (config.UnlootedAnnouncements.Enabled)
                    {
                        claimTime = Time.realtimeSinceStartup + config.Event.DestructTime;
                        announcement = Instance.timer.Repeat(config.UnlootedAnnouncements.Interval * 60f, 0, Unclaimed);
                    }
                }

                if (requireAllNpcsDie && npcSpawnedAmount > 0 && npcs != null)
                {
                    npcs.RemoveAll(npc => npc.IsKilled() || npc.IsDead());

                    if (npcs.Count > 0)
                    {
                        Invoke(Unlock, 1f);
                        return;
                    }
                }

                container.SetFlag(BaseEntity.Flags.Locked, false);
                container.SetFlag(BaseEntity.Flags.OnFire, false);
            }

            public void SetUnlockTime(float time)
            {
                countdownTime = Convert.ToInt32(time);
                _unlockTime = Convert.ToInt64(Time.realtimeSinceStartup + time);

                if (npcSpawnedAmount == 0 && config.NPC.Murderers.SpawnAmount + config.NPC.Scientists.SpawnAmount > 0 && config.NPC.Enabled)
                {
                    if (requireAllNpcsDie || whenNpcsDie)
                    {
                        whenNpcsDie = false;
                        requireAllNpcsDie = false;
                    }
                }

                unlock = Instance.timer.Once(time, Unlock);

                if (config.Countdown.Enabled && !config.Countdown.Times.IsNullOrEmpty() && countdownTime > 0)
                {
                    if (times.Count == 0)
                        times.AddRange(config.Countdown.Times);

                    countdown = Instance.timer.Repeat(1f, 0, () =>
                    {
                        countdownTime--;

                        if (started || times.Count == 0)
                        {
                            countdown.Destroy();
                            return;
                        }

                        if (times.Remove(countdownTime))
                        {
                            string eventPos = FormatGridReference(containerPos);

                            foreach (var target in BasePlayer.activePlayerList)
                                Message(target, "Countdown", eventPos, Instance.FormatTime(countdownTime, target.UserIDString));
                        }
                    });
                }
            }

            public void TrySetOwner(HitInfo hitInfo)
            {
                if (hitInfo == null || userid.IsSteamId()) return;
                var attacker = hitInfo.Initiator as BasePlayer;
                if (attacker == null || !attacker.userID.IsSteamId()) return;
                userid = attacker.userID;
            }

            private void SafelyKill(BaseEntity e) => e.SafelyKill();

            public void DestroyLauncher()
            {
                if (missilePositions.Count > 0)
                {
                    CancelInvoke(LaunchMissile);
                    missilePositions.Clear();
                }

                if (missiles.Count > 0)
                {
                    missiles.ForEach(SafelyKill);
                    missiles.Clear();
                }
            }

            public void DestroySphere()
            {
                if (spheres.Count > 0)
                {
                    spheres.ForEach(SafelyKill);
                    spheres.Clear();
                }
            }

            public void DestroyFire()
            {
                CancelInvoke(SpawnFire);
                firePositions.Clear();

                if (fireballs.Count > 0)
                {
                    fireballs.ForEach(SafelyKill);
                    fireballs.Clear();
                }

                Instance.newmanProtections.RemoveAll(protects.Contains);
                traitors.Clear();
                newmans.Clear();
                protects.Clear();
            }
        }

        void OnNewSave(string filename) => wipeChestsSeed = true;

        void Init()
        {
            SubscribeHooks(false);
        }

        void OnServerInitialized(bool isStartup)
        {
            LoadData();
            TryWipeData();
            BlockZoneManagerZones(true);
            InitializeMonuments();
            InitializeSkins();
            timer.Repeat(Mathf.Clamp(config.EventMessages.Interval, 1f, 60f), 0, CheckNotifications);
        }

        void Unload()
        {
            foreach (var chest in treasureChests.Values.ToList())
            {
                if (chest != null)
                {
                    Puts(_("Destroyed Treasure Chest", null, chest.containerPos));

                    chest.Kill(true);
                }
            }

            if (_cmc != null)
                ServerMgr.Instance.StopCoroutine(_cmc);

            DangerousTreasuresExtensionMethods.ExtensionMethods.p = null;
        }

        object canTeleport(BasePlayer player)
        {
            return EventTerritory(player.transform.position) ? msg("CannotTeleport", player.UserIDString) : null;
        }

        object CanTeleport(BasePlayer player)
        {
            return EventTerritory(player.transform.position) ? msg("CannotTeleport", player.UserIDString) : null;
        }

        object CanBradleyApcTarget(BradleyAPC apc, HumanoidNPC npc)
        {
            return npc != null && HasNPC(npc.userID) ? (object)false : null;
        }

        object OnEntityEnter(TriggerBase trigger, BasePlayer player)
        {
            if (player.IsValid())
            {
                if (newmanProtections.Contains(player.userID) || HasNPC(player.userID))
                {
                    return true;
                }
            }

            return null;
        }

        private object OnNpcDuck(HumanoidNPC npc) => npc != null && HasNPC(npc.userID) ? true : (object)null;

        private object OnNpcDestinationSet(HumanoidNPC npc, Vector3 newDestination)
        {
            if (npc.IsNull() || npc.NavAgent == null || !npc.NavAgent.enabled || !npc.NavAgent.isOnNavMesh)
            {
                return true;
            }

            if (!HumanoidBrains.TryGetValue(npc.userID, out var brain) || brain.CanRoam(newDestination))
            {
                return null;
            }

            return true;
        }

        private object OnNpcResume(HumanoidNPC npc)
        {
            if (npc.IsNull())
            {
                return null;
            }

            if (!HumanoidBrains.TryGetValue(npc.userID, out var brain))
            {
                return null;
            }

            return true;
        }

        object OnNpcTarget(BasePlayer player, BasePlayer target)
        {
            if (player == null || target == null)
            {
                return null;
            }

            if (HasNPC(player.userID) && !target.userID.IsSteamId())
            {
                return true;
            }
            else if (HasNPC(target.userID) && !player.userID.IsSteamId())
            {
                return true;
            }
            else if (newmanProtections.Contains(target.userID))
            {
                return true;
            }

            return null;
        }

        object OnNpcTarget(BaseNpc npc, BasePlayer target)
        {
            if (npc == null || target == null)
            {
                return null;
            }

            if (HasNPC(target.userID) || newmanProtections.Contains(target.userID))
            {
                return true;
            }

            return null;
        }

        object OnNpcTarget(BasePlayer target, BaseNpc npc) => OnNpcTarget(npc, target);

        void OnEntitySpawned(BaseLock entity)
        {
            NextTick(() =>
            {
                if (!entity.IsKilled())
                {
                    foreach (var x in treasureChests.Values)
                    {
                        if (entity.HasParent() && entity.GetParentEntity() == x.container)
                        {
                            entity.SafelyKill();
                            break;
                        }
                    }
                }
            });
        }

        void OnEntitySpawned(NPCPlayerCorpse corpse)
        {
            if (!config.NPC.Enabled || corpse == null)
            {
                return;
            }

            if (!HumanoidBrains.TryGetValue(corpse.playerSteamID, out var brain) || brain.tc == null)
            {
                return;
            }

            brain.tc.npcs.RemoveAll(npc => npc.IsKilled() || npc.userID == corpse.playerSteamID);

            if (brain.isMurderer && config.NPC.Murderers.DespawnInventory || !brain.isMurderer && config.NPC.Scientists.DespawnInventory)
            {
                corpse.Invoke(corpse.SafelyKill, brain.isMurderer ? config.NPC.Murderers.DespawnInventoryTime : config.NPC.Scientists.DespawnInventoryTime);
            }
            else corpse.Invoke(corpse.SafelyKill, brain.isMurderer ? config.NPC.Murderers.CorpseDespawnTime : config.NPC.Scientists.CorpseDespawnTime);

            brain.DisableShouldThink();
            UnityEngine.Object.DestroyImmediate(brain);

            if (!treasureChests.Values.Exists(x => x.npcs.Count > 0))
            {
                Unsubscribe(nameof(OnNpcTarget));
                Unsubscribe(nameof(OnNpcResume));
                Unsubscribe(nameof(OnNpcDestinationSet));
                Unsubscribe(nameof(CanBradleyApcTarget));
            }
        }

        void OnEntitySpawned(DroppedItemContainer backpack)
        {
            if (config.Event.PlayersLootable && !backpack.IsKilled() && backpack.ShortPrefabName == "item_drop_backpack" && EventTerritory(backpack.transform.position))
            {
                NextTick(() =>
                {
                    if (!backpack.IsKilled() && backpack.playerSteamID.IsSteamId())
                    {
                        backpack.playerSteamID = 0;
                    }
                });
            }
        }

        void OnEntitySpawned(PlayerCorpse corpse)
        {
            if (config.Event.PlayersLootable && !corpse.IsKilled() && EventTerritory(corpse.transform.position))
            {
                NextTick(() =>
                {
                    if (!corpse.IsKilled() && corpse.playerSteamID.IsSteamId())
                    {
                        corpse.playerSteamID = 0;
                    }
                });
            }
        }

        object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            var player = planner?.GetOwnerPlayer();

            if (player == null || player.IsAdmin) return null;

            var chest = Get(player.transform.position);

            if (chest != null)
            {
                Message(player, "Building is blocked!");
                return false;
            }

            return null;
        }

        private bool IsAlly(ulong playerId, ulong targetId)
        {
            if (playerId == targetId)
            {
                return true;
            }

            if (RelationshipManager.ServerInstance.playerToTeam.TryGetValue(playerId, out var team) && team.members.Contains(targetId))
            {
                return true;
            }

            if (Clans.CanCall() && Convert.ToBoolean(Clans?.Call("IsMemberOrAlly", playerId, targetId)))
            {
                return true;
            }

            if (Friends.CanCall() && Convert.ToBoolean(Friends?.Call("AreFriends", playerId.ToString(), targetId.ToString())))
            {
                return true;
            }

            return false;
        }

        private object CanLootEntity(BasePlayer player, BoxStorage container)
        {
            if (player == null || !container.IsValid() || !treasureChests.ContainsKey(container.net.ID))
                return null;

            if (player.isMounted)
            {
                Message(player, "CannotBeMounted");
                return true;
            }
            else looters[container.net.ID] = player.UserIDString;

            var chest = treasureChests[container.net.ID];

            if (chest.userid.IsSteamId() && !IsAlly(chest.userid, player.userID))
            {
                Message(player, "CannotBeLooted");
                return true;
            }

            if (chest.opened || !config.EventMessages.FirstOpened)
            {
                return null;
            }

            chest.opened = true;
            var posStr = FormatGridReference(container.transform.position, config.Settings.ShowGrid);

            foreach (var target in BasePlayer.activePlayerList)
            {
                Message(target, "OnChestOpened", player.displayName, posStr);
            }

            return null;
        }

        private void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            if (container?.entityOwner == null || !(container.entityOwner is StorageContainer))
                return;

            NextTick(() =>
            {
                var box = container?.entityOwner as StorageContainer;

                if (!box.IsValid() || !treasureChests.ContainsKey(box.net.ID))
                    return;

                var looter = item.GetOwnerPlayer();

                if (looter != null)
                {
                    looters[box.net.ID] = looter.UserIDString;
                }

                if (box.inventory.itemList.Count == 0)
                {
                    if (looter == null && looters.ContainsKey(box.net.ID))
                        looter = BasePlayer.Find(looters[box.net.ID]);

                    if (looter != null)
                    {
                        if (config.RankedLadder.Enabled)
                        {
                            if (!data.Players.TryGetValue(looter.UserIDString, out var pi))
                                data.Players.Add(looter.UserIDString, pi = new());

                            pi.StolenChestsTotal++;
                            pi.StolenChestsSeed++;
                            SaveData();
                        }

                        Puts(_("Thief", null, FormatGridReference(looter.transform.position, true), looter.displayName));

                        if (config.EventMessages.Thief)
                        {
                            var posStr = FormatGridReference(looter.transform.position, config.Settings.ShowGrid);

                            foreach (var target in BasePlayer.activePlayerList)
                            {
                                Message(target, "Thief", posStr, looter.displayName);
                            }
                        }

                        looter.EndLooting();

                        if (config.Rewards.Economics && config.Rewards.Money > 0 && Economics.CanCall())
                        {
                            Economics?.Call("Deposit", looter.UserIDString, config.Rewards.Money);
                            Message(looter, "EconomicsDeposit", config.Rewards.Money);
                        }

                        if (config.Rewards.ServerRewards && config.Rewards.Points > 0 && ServerRewards.CanCall())
                        {
                            if (Convert.ToBoolean(ServerRewards?.Call("AddPoints", looter.userID, (int)config.Rewards.Points)))
                            {
                                Message(looter, "ServerRewardPoints", (int)config.Rewards.Points);
                            }
                        }

                        Interface.CallHook("OnDangerousEventWon", looter);
                    }

                    box.SafelyKill();

                    if (treasureChests.Count == 0)
                        SubscribeHooks(false);
                }
            });
        }

        private object CanEntityBeTargeted(BasePlayer player, BaseEntity target)
        {
            return !player.IsKilled() && player.IsHuman() && EventTerritory(player.transform.position) && !target.IsKilled() && IsTrueDamage(target) ? (object)true : null;
        }

        private object CanEntityTrapTrigger(BaseTrap trap, BasePlayer player)
        {
            return !player.IsKilled() && player.IsHuman() && EventTerritory(player.transform.position) ? (object)true : null;
        }

        private object CanEntityTakeDamage(BaseEntity entity, HitInfo hitInfo) // TruePVE!!!! <3 @ignignokt84
        {
            if (entity.IsKilled() || hitInfo == null || hitInfo.Initiator == null || entity.skinID == 14922524)
            {
                return null;
            }

            var attacker = hitInfo.Initiator as BasePlayer;

            if (attacker != null && attacker.skinID == 14922524)
            {
                return null;
            }

            if (Convert.ToBoolean(RaidableBases?.Call("EventTerritory", hitInfo.Initiator.ServerPosition)))
            {
                return null;
            }

            if (Convert.ToBoolean(RaidableBases?.Call("EventTerritory", entity.ServerPosition)))
            {
                return null;
            }

            if (entity is HumanoidNPC && HasNPC(entity.ToPlayer().userID))
            {
                return true;
            }

            if (config.TruePVE.ServerWidePVP && treasureChests.Count > 0 && attacker != null && entity is BasePlayer) // 1.2.9 & 1.3.3 & 1.6.4
            {
                return true;
            }

            if (EventTerritory(entity.transform.position)) // 1.5.8 & 1.6.4
            {
                if (entity is NPCPlayerCorpse || IsTrueDamage(hitInfo.Initiator))
                {
                    return true;
                }

                if (config.TruePVE.AllowPVPAtEvents && entity is BasePlayer && attacker != null && EventTerritory(attacker.transform.position)) // 1.2.9
                {
                    return true;
                }

                if (config.TruePVE.AllowBuildingDamageAtEvents && entity.name.Contains("building") && attacker != null && EventTerritory(attacker.transform.position)) // 1.3.3
                {
                    return true;
                }
            }

            return null; // 1.6.4 rewrite
        }

        private void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || hitInfo == null)
            {
                return;
            }

            if (HasNPC(player.userID))
            {
                NpcDamageHelper(player, hitInfo);
                return;
            }

            if (newmanProtections.Contains(player.userID))
            {
                ProtectionDamageHelper(hitInfo, "Newman Protected");
                return;
            }

            var attacker = hitInfo.Initiator as BasePlayer;

            if (attacker == null)
            {
                return;
            }

            if (HumanoidBrains.TryGetValue(attacker.userID, out var brain) && brain != null && (brain.isMurderer && UnityEngine.Random.Range(0f, 100f) > config.NPC.Murderers.Accuracy.Get(brain) || !brain.isMurderer && UnityEngine.Random.Range(0f, 100f) > config.NPC.Scientists.Accuracy.Get(brain)))
            {
                hitInfo.damageTypes = new();
                hitInfo.DidHit = false;
                hitInfo.DoHitEffects = false;
            }
        }

        private void OnEntityTakeDamage(BoxStorage box, HitInfo hitInfo)
        {
            if (hitInfo != null && box.IsValid() && treasureChests.ContainsKey(box.net.ID))
            {
                ProtectionDamageHelper(hitInfo, "Indestructible");
                hitInfo.damageTypes.ScaleAll(0f);
            }
        }

        private void ProtectionDamageHelper(HitInfo hitInfo, string key)
        {
            var attacker = hitInfo.Initiator as BasePlayer;

            if (attacker.IsValid() && attacker.IsHuman() && !indestructibleWarnings.Contains(attacker.userID))
            {
                ulong uid = attacker.userID;
                indestructibleWarnings.Add(uid);
                timer.Once(10f, () => indestructibleWarnings.Remove(uid));
                Message(attacker, key);
            }

            hitInfo.damageTypes.ScaleAll(0f);
        }

        private object OnNpcKits(ulong targetId)
        {
            return HasNPC(targetId) ? true : (object)null;
        }

        private bool HasNPC(ulong userID)
        {
            return HumanoidBrains.ContainsKey(userID);
        }

        private TreasureChest Get(Vector3 target)
        {
            foreach (var x in treasureChests.Values)
            {
                if (InRange2D(x.containerPos, target, x.Radius))
                {
                    return x;
                }
            }
            return null;
        }

        private bool IsTrueDamage(BaseEntity entity)
        {
            if (entity.IsNull())
            {
                return false;
            }

            return entity is AutoTurret || entity is BearTrap || entity is FlameTurret || entity is Landmine || entity is GunTrap || entity is ReactiveTarget || entity.name.Contains("spikes.floor") || entity is FireBall;
        }

        private bool EventTerritory(Vector3 target)
        {
            foreach (var x in treasureChests.Values)
            {
                if ((x.containerPos - target).SqrMagnitude2D() <= x.Radius * x.Radius)
                {
                    return true;
                }
            }

            return false;
        }

        private void LoadData()
        {
            try { data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name); } catch { }
            data ??= new();
            data.Players ??= new();
            sd_customPos = string.IsNullOrEmpty(data.CustomPosition) ? Vector3.zero : data.CustomPosition.ToVector3();
        }

        void TryWipeData()
        {
            if (wipeChestsSeed)
            {
                if (data.Players.Count > 0)
                {
                    var ladder = data.Players.Where(kvp => kvp.Value.StolenChestsSeed > 0).ToDictionary(kvp => kvp.Key, kvp => kvp.Value.StolenChestsSeed).ToList();

                    if (ladder.Count > 0 && AssignTreasureHunters(ladder))
                    {
                        foreach (var pi in data.Players.Values.ToList())
                        {
                            pi.StolenChestsSeed = 0;
                        }
                    }
                }

                data.CustomPosition = string.Empty;
                sd_customPos = Vector3.zero;
                wipeChestsSeed = false;
                SaveData();
            }
        }

        void BlockZoneManagerZones(bool show)
        {
            managedZones.Clear();

            if (!ZoneManager.CanCall())
            {
                return;
            }

            timer.Once(30f, () => BlockZoneManagerZones(false));

            var zoneIds = ZoneManager?.Call("GetZoneIDs") as string[];

            if (zoneIds == null)
            {
                return;
            }

            foreach (string zoneId in zoneIds)
            {
                var zoneLoc = ZoneManager.Call("GetZoneLocation", zoneId);

                if (zoneLoc is not Vector3 position || position == default)
                {
                    continue;
                }

                var zoneInfo = new ZoneInfo();
                var radius = ZoneManager.Call("GetZoneRadius", zoneId);

                if (radius is float r)
                {
                    zoneInfo.Distance = r;
                }

                var size = ZoneManager.Call("GetZoneSize", zoneId);

                if (size is Vector3 s)
                {
                    zoneInfo.Size = s;
                }

                zoneInfo.Position = position;
                zoneInfo.OBB = new OBB(zoneInfo.Position, zoneInfo.Size, Quaternion.identity);
                managedZones[position] = zoneInfo;
            }

            if (show && managedZones.Count > 0)
            {
                Puts("Blocked {0} zone manager zones", managedZones.Count);
            }
        }

        private class MonumentInfoEx
        {
            public MonumentInfo monument;
            public Vector3 position;
            public float radius;
            public string name;
            public string prefab;
            public MonumentInfoEx() { }
            public MonumentInfoEx(MonumentInfo monument, Vector3 position, float radius, string name, string prefab)
            {
                this.monument = monument;
                this.position = position;
                this.radius = radius;
                this.name = name;
                this.prefab = prefab;
            }
            public bool IsInBounds(Vector3 target)
            {
                if (Vector3Ex.Distance2D(target, position) <= radius)
                {
                    return true;
                }
                return monument != null && monument.transform.position.y < 0f && TerrainMeta.HeightMap.GetHeight(target) < 0f && monument.IsInBounds(target);
            }
        }

        private Coroutine _cmc;

        private void InitializeMonuments() => _cmc = ServerMgr.Instance.StartCoroutine(SetupMonuments());

        private IEnumerator SetupMonuments()
        {
            int checks = 0;
            foreach (var prefab in World.Serialization.world.prefabs)
            {
                if (prefab.id == 1724395471 && prefab.category != "IGNORE_MONUMENT")
                {
                    yield return CalculateMonumentSize(null, new(prefab.position.x, prefab.position.y, prefab.position.z), prefab.category, "monument_marker");
                }
                if (++checks >= 1000)
                {
                    yield return CoroutineEx.waitForSeconds(0.0025f);
                    checks = 0;
                }
            }
            foreach (var monument in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                if (monument.name.Contains("monument_marker"))
                {
                    foreach (var m in monuments)
                    {
                        if (m.monument == null && monument.transform.position == m.position)
                        {
                            m.monument = monument;
                            break;
                        }
                    }
                    continue;
                }
                var monPos = monument.transform.position;
                var name = monument.displayPhrase.english.TrimEnd();
                if (string.IsNullOrEmpty(name))
                {
                    if (monument.name.Contains("cave"))
                    {
                        name = monument.name.Contains("cave_small") ? "Small Cave" : monument.name.Contains("cave_medium") ? "Medium Cave" : "Large Cave";
                    }
                    else name = monument.name;
                }
                if (name.Contains("/"))
                {
                    name = Utility.GetFileNameWithoutExtension(monument.name);
                }
                yield return CalculateMonumentSize(monument, monument.transform.position, name, monument.name);
            }
            SortMonuments();
            _cmc = null;
        }

        public IEnumerator CalculateMonumentSize(MonumentInfo monument, Vector3 from, string text, string prefab)
        {
            int checks = 0;
            float radius = 15f;
            while (radius < World.Size / 2f)
            {
                int pointsOfTopology = 0;
                foreach (var to in GetCircumferencePositions(from, radius, 30f))
                {
                    if (ContainsTopology(TerrainTopology.Enum.Building | TerrainTopology.Enum.Monument, to, 5f))
                    {
                        pointsOfTopology++;
                    }
                    if (++checks >= 25)
                    {
                        yield return CoroutineEx.waitForSeconds(0.0025f);
                        checks = 0;
                    }
                }
                if (pointsOfTopology < 4)
                {
                    break;
                }
                radius += 15f;
            }
            if (radius == 15f)
            {
                radius = 100f;
            }
            monuments.Add(new(monument, from, radius, text, prefab));
        }

        public bool ContainsTopology(TerrainTopology.Enum mask, Vector3 position, float radius)
        {
            return (TerrainMeta.TopologyMap.GetTopology(position, radius) & (int)mask) != 0;
        }

        public List<Vector3> GetCircumferencePositions(Vector3 center, float radius, float next)
        {
            float degree = 0f;
            float angleInRadians = 2f * Mathf.PI;
            List<Vector3> positions = new();

            while (degree < 360)
            {
                float radian = (angleInRadians / 360) * degree;
                float x = center.x + radius * Mathf.Cos(radian);
                float z = center.z + radius * Mathf.Sin(radian);
                Vector3 a = new(x, 0f, z);
                a.y = Mathf.Max(center.y, WaterSystem.OceanLevel, TerrainMeta.HeightMap.GetHeight(a));
                positions.Add(a);

                degree += next;
            }

            return positions;
        }

        private void SortMonuments()
        {
            int num1 = config.Monuments.Blacklist.Count;
            int num2 = config.NPC.BlacklistedMonuments.Count;

            foreach (var monument in monuments)
            {
                if (monument.name.Contains("cave") || monument.name.Contains("power_sub"))
                {
                    continue;
                }
                if (!string.IsNullOrEmpty(monument.name) && !config.NPC.BlacklistedMonuments.ContainsKey(monument.name))
                {
                    config.NPC.BlacklistedMonuments.Add(monument.name, false);
                }
            }

            if (monuments.Count > 0)
            {
                allowedMonuments = monuments.ToDictionary(k => k.name, k => k);
            }

            foreach (var value in allowedMonuments.Keys.ToList())
            {
                if (string.IsNullOrEmpty(value))
                {
                    continue;
                }
                if (!config.Monuments.Blacklist.TryGetValue(value, out var disabled))
                {
                    config.Monuments.Blacklist.Add(value, disabled = false);
                }
                else if (disabled)
                {
                    allowedMonuments.Remove(value);
                }
                if (!config.Monuments.Underground && underground.Exists(x => x.Contains(value, CompareOptions.OrdinalIgnoreCase)))
                {
                    allowedMonuments.Remove(value);
                }
            }

            if (config.Monuments.Blacklist.Count != num1 || config.NPC.BlacklistedMonuments.Count != num2)
            {
                config.Monuments.Blacklist = System.Linq.Enumerable.OrderBy(config.Monuments.Blacklist, x => x.Key).ToDictionary(x => x.Key, x => x.Value);
                config.NPC.BlacklistedMonuments = System.Linq.Enumerable.OrderBy(config.NPC.BlacklistedMonuments, x => x.Key).ToDictionary(x => x.Key, x => x.Value);
                SaveConfig();
            }

            StartAutomation();
        }

        void InitializeSkins()
        {
            foreach (var def in ItemManager.GetItemDefinitions())
            {
                if (def.TryGetComponent<ItemModDeployable>(out var imd))
                {
                    _definitions[imd.entityPrefab.resourcePath] = def;
                }
            }
        }

        void StartAutomation()
        {
            if (config.Event.Automated)
            {
                if (data.SecondsUntilEvent != double.MinValue)
                    if (data.SecondsUntilEvent - Facepunch.Math.Epoch.Current > config.Event.IntervalMax) // Allows users to lower max event time
                        data.SecondsUntilEvent = double.MinValue;

                timer.Once(1f, CheckSecondsUntilEvent);
            }
        }

        private static PooledList<T> FindEntitiesOfType<T>(Vector3 a, float n, int m = -1) where T : BaseEntity
        {
            PooledList<T> entities = Pool.Get<PooledList<T>>();
            Vis.Entities(a, n, entities, m, QueryTriggerInteraction.Collide);
            entities.RemoveAll(x => x == null || x.IsDestroyed);
            return entities;
        }

        void NpcDamageHelper(BasePlayer player, HitInfo hitInfo)
        {
            if (!HumanoidBrains.TryGetValue(player.userID, out var brain))
            {
                return;
            }

            if (config.NPC.Range > 0f && hitInfo.ProjectileDistance > config.NPC.Range || hitInfo.hasDamage && !(hitInfo.Initiator is BasePlayer) && !(hitInfo.Initiator is AutoTurret)) // immune to fire/explosions/other
            {
                hitInfo.damageTypes = new();
                hitInfo.DidHit = false;
                hitInfo.DoHitEffects = false;
            }
            else if (hitInfo.isHeadshot && (brain.isMurderer && config.NPC.Murderers.Headshot || !brain.isMurderer && config.NPC.Scientists.Headshot))
            {
                player.Die(hitInfo);
            }
            else if (hitInfo.Initiator is BasePlayer attacker)
            {
                var e = attacker.HasParent() ? attacker.GetParentEntity() : null;

                if (!(e == null) && (e is ScrapTransportHelicopter || e is HotAirBalloon || e is CH47Helicopter))
                {
                    hitInfo.damageTypes.ScaleAll(0f);
                    return;
                }

                brain.SetTarget(attacker);
            }
        }

        private static bool InRange2D(Vector3 a, Vector3 b, float distance)
        {
            return (new Vector3(a.x, 0f, a.z) - new Vector3(b.x, 0f, b.z)).sqrMagnitude <= distance * distance;
        }

        private static bool InRange(Vector3 a, Vector3 b, float distance)
        {
            return (a - b).sqrMagnitude <= distance * distance;
        }

        bool IsMelee(BasePlayer player)
        {
            var attackEntity = player.GetHeldEntity() as AttackEntity;

            if (attackEntity == null)
            {
                return false;
            }

            return attackEntity is BaseMelee;
        }

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, data);

        protected new static void Puts(string format, params object[] args)
        {
            Interface.Oxide.LogInfo("[{0}] {1}", Name, (args.Length != 0) ? string.Format(format, args) : format);
        }

        void SubscribeHooks(bool flag)
        {
            if (flag)
            {
                if (config.NPC.Enabled)
                {
                    if (config.NPC.BlockNpcKits)
                    {
                        Subscribe(nameof(OnNpcKits));
                    }
                }

                Subscribe(nameof(CanEntityTakeDamage));
                Subscribe(nameof(OnNpcTarget));
                Subscribe(nameof(OnNpcResume));
                Subscribe(nameof(OnNpcDestinationSet));
                Subscribe(nameof(OnEntitySpawned));
                Subscribe(nameof(CanBradleyApcTarget));
                Subscribe(nameof(OnEntityTakeDamage));
                Subscribe(nameof(OnItemRemovedFromContainer));
                Subscribe(nameof(CanLootEntity));
                Subscribe(nameof(CanBuild));
                Subscribe(nameof(CanTeleport));
                Subscribe(nameof(canTeleport));
                Subscribe(nameof(OnEntityEnter));
            }
            else
            {
                Unsubscribe(nameof(OnNpcKits));
                Unsubscribe(nameof(CanTeleport));
                Unsubscribe(nameof(canTeleport));
                Unsubscribe(nameof(OnEntityEnter));
                Unsubscribe(nameof(CanEntityTakeDamage));
                Unsubscribe(nameof(CanBradleyApcTarget));
                Unsubscribe(nameof(OnNpcTarget));
                Unsubscribe(nameof(OnNpcResume));
                Unsubscribe(nameof(OnEntitySpawned));
                Unsubscribe(nameof(OnEntityTakeDamage));
                Unsubscribe(nameof(OnItemRemovedFromContainer));
                Unsubscribe(nameof(CanLootEntity));
                Unsubscribe(nameof(CanBuild));
            }
        }

        private static List<Vector3> GetRandomPositions(Vector3 destination, float radius, int amount, float y)
        {
            var positions = new List<Vector3>();

            if (amount <= 0)
                return positions;

            int retries = 100;
            float space = (radius / amount); // space each rocket out from one another

            for (int i = 0; i < amount; i++)
            {
                var position = destination + UnityEngine.Random.insideUnitSphere * radius;

                position.y = y != 0f ? y : UnityEngine.Random.Range(100f, 200f);

                var match = Vector3.zero;

                foreach (var p in positions)
                {
                    if (InRange2D(p, position, space))
                    {
                        match = p;
                        break;
                    }
                }

                if (match != Vector3.zero)
                {
                    if (--retries < 0)
                        break;

                    i--;
                    continue;
                }

                retries = 100;
                positions.Add(position);
            }

            return positions;
        }

        private bool IsInsideBounds(OBB obb, Vector3 worldPos)
        {
            return obb.ClosestPoint(worldPos) == worldPos;
        }

        public Vector3 GetEventPosition()
        {
            if (sd_customPos != Vector3.zero)
            {
                return sd_customPos;
            }

            var maxRetries = 500;
            var eventPos = TryGetMonumentDropPosition();

            if (eventPos != Vector3.zero)
            {
                return eventPos;
            }

            bool isDuelist = Duelist.CanCall();
            bool isRaidable = RaidableBases.CanCall();
            bool isAbandoned = AbandonedBases.CanCall();

            do
            {
                var r = RandomDropPosition();

                eventPos = GetSafeDropPosition(r);

                if (eventPos == Vector3.zero)
                {
                    _gridPositions.Remove(r);
                    continue;
                }

                if (IsTooClose(eventPos))
                {
                    eventPos = Vector3.zero;
                }
                else if (IsZoneBlocked(eventPos))
                {
                    eventPos = Vector3.zero;
                }
                else if (IsMonumentPosition(eventPos))
                {
                    eventPos = Vector3.zero;
                }
                else if (isDuelist && Convert.ToBoolean(Duelist?.Call("DuelistTerritory", eventPos)))
                {
                    eventPos = Vector3.zero;
                }
                else if (isRaidable && Convert.ToBoolean(RaidableBases?.Call("EventTerritory", eventPos)))
                {
                    eventPos = Vector3.zero;
                }
                else if (isAbandoned && Convert.ToBoolean(AbandonedBases?.Call("EventTerritory", eventPos)))
                {
                    eventPos = Vector3.zero;
                }
            } while (eventPos == Vector3.zero && --maxRetries > 0);

            return eventPos;
        }

        Vector3 TryGetMonumentDropPosition()
        {
            if (allowedMonuments.Count == 0)
            {
                return Vector3.zero;
            }

            if (config.Monuments.Only)
            {
                return GetMonumentDropPosition();
            }

            if (config.Monuments.Chance > 0f)
            {
                var value = UnityEngine.Random.value;

                if (value <= config.Monuments.Chance)
                {
                    return GetMonumentDropPosition();
                }
            }

            return Vector3.zero;
        }

        bool IsTooClose(Vector3 vector, float multi = 2f)
        {
            foreach (var x in treasureChests.Values)
            {
                if (InRange2D(x.containerPos, vector, x.Radius * multi))
                {
                    return true;
                }
            }

            return false;
        }

        bool IsZoneBlocked(Vector3 vector)
        {
            foreach (var zone in managedZones)
            {
                if (zone.Value.Size != Vector3.zero)
                {
                    if (IsInsideBounds(zone.Value.OBB, vector))
                    {
                        return true;
                    }
                }
                else if (InRange2D(zone.Key, vector, zone.Value.Distance))
                {
                    return true;
                }
            }

            return false;
        }

        bool IsSafeZone(Vector3 a)
        {
            return TriggerSafeZone.allSafeZones.Exists(triggerSafeZone => InRange2D(triggerSafeZone.transform.position, a, 200f));
        }

        Vector3 GetSafeDropPosition(Vector3 position)
        {
            position.y += 200f;

            if (!Physics.Raycast(position, Vector3.down, out var hit, 1000f, heightLayer, QueryTriggerInteraction.Collide))
            {
                return Vector3.zero;
            }

            if (BlockedLayers.Contains(hit.collider.gameObject.layer))
            {
                return Vector3.zero;
            }

            if (IsSafeZone(hit.point))
            {
                return Vector3.zero;
            }

            if (hit.collider.name.StartsWith("powerline_") || hit.collider.name.StartsWith("invisible_"))
            {
                return Vector3.zero;
            }

            float h = TerrainMeta.HeightMap.GetHeight(position);

            position.y = Mathf.Max(hit.point.y, GetSpawnHeight(position));

            if (TerrainMeta.WaterMap.GetHeight(position) - h > 0.1f)
            {
                return Vector3.zero;
            }

            if (IsLayerBlocked(position, config.Event.Radius + 10f, obstructionLayer))
            {
                return Vector3.zero;
            }

            return position;
        }

        float GetSpawnHeight(Vector3 target, bool flag = true, bool draw = false)
        {
            float y = TerrainMeta.HeightMap.GetHeight(target);
            float w = TerrainMeta.WaterMap.GetHeight(target);
            float p = TerrainMeta.HighestPoint.y + 250f;

            if (Physics.Raycast(target.WithY(p), Vector3.down, out var hit, ++p, TARGET_MASK, QueryTriggerInteraction.Ignore))
            {
                if (!_blockedColliders.Exists(hit.collider.name.StartsWith))
                {
                    y = Mathf.Max(y, hit.point.y);
                }
            }

            return flag ? Mathf.Max(y, w) : y;
        }

        bool IsLayerBlocked(Vector3 position, float radius, int mask)
        {
            using var entities = FindEntitiesOfType<BaseEntity>(position, radius, mask);
            entities.RemoveAll(entity => entity.IsNpc || !entity.OwnerID.IsSteamId());
            bool blocked = entities.Count > 0;
            return blocked;
        }

        Vector3 GetRandomMonumentDropPosition(Vector3 position)
        {
            foreach (var monument in allowedMonuments.Values)
            {
                if (!InRange2D(monument.position, position, 75f))
                {
                    continue;
                }

                int attempts = 100;

                while (--attempts > 0)
                {
                    var randomPoint = monument.position + UnityEngine.Random.insideUnitSphere * 75f;
                    randomPoint.y = 100f;

                    if (!Physics.Raycast(randomPoint, Vector3.down, out var hit, 100.5f, Layers.Solid, QueryTriggerInteraction.Ignore))
                    {
                        continue;
                    }

                    if (IsSafeZone(hit.point))
                    {
                        continue;
                    }

                    if (hit.point.y - TerrainMeta.HeightMap.GetHeight(hit.point) > 3f)
                    {
                        continue;
                    }

                    if (IsLayerBlocked(hit.point, config.Event.Radius + 10f, obstructionLayer) || IsPositionBlocked(hit.point))
                    {
                        continue;
                    }

                    return hit.point;
                }
            }

            return Vector3.zero;
        }

        bool IsMonumentPosition(Vector3 target)
        {
            foreach (var monument in monuments)
            {
                if (monument.IsInBounds(target))
                {
                    return true;
                }
            }

            return false;
        }

        Vector3 GetMonumentDropPosition(int retry = 0)
        {
            if (retry >= 100)
            {
                return Vector3.zero;
            }

            var list = allowedMonuments.ToList();
            var position = Vector3.zero;

            while (position == Vector3.zero && list.Count > 0)
            {
                var mon = list.GetRandom();
                var pos = mon.Value.position;

                if (!IsTooClose(pos, 1f) && !IsZoneBlocked(pos) && !IsLayerBlocked(pos, config.Event.Radius + 10f, obstructionLayer) && !IsPositionBlocked(pos))
                {
                    position = pos;
                    break;
                }

                list.Remove(mon);
            }

            if (position == Vector3.zero)
            {
                return Vector3.zero;
            }

            using var entities = Pool.Get<PooledList<BaseEntity>>();
            Vis.Entities(position, config.Event.Radius, entities);

            entities.RemoveAll(e =>
            {
                if (e.IsKilled() || e.OwnerID != 0 || e.skinID != 0 || e.HasParent()) return true;
                if (e is NPCPlayer) return false;
                if (!(e is LootContainer)) return true;
                if (e.ShortPrefabName.Contains("loot-barrel")) return false;
                if (e.ShortPrefabName.Contains("loot_barrel")) return false;
                if (e.ShortPrefabName.StartsWith("crate_")) return false;
                return true;
            });

            if (!config.Monuments.Underground)
            {
                entities.RemoveAll(e => e.IsKilled() || e.transform.position.y < position.y || IsPositionBlocked(e.transform.position));
            }
            else entities.RemoveAll(e => e.IsKilled() || IsPositionBlocked(e.transform.position));

            if (entities.Count < 2)
            {
                position = GetRandomMonumentDropPosition(position);

                return position == Vector3.zero ? GetMonumentDropPosition(++retry) : position;
            }

            var entity = entities.GetRandom();

            position = entity.transform.position;

            if (entity is NPCPlayer || entity is LootContainer)
            {
                entity.Invoke(entity.SafelyKill, 0.1f);
            }

            return position;
        }

        private void SetupPositions()
        {
            int minPos = (int)(World.Size / -2f);
            int maxPos = (int)(World.Size / 2f);

            for (float x = minPos; x < maxPos; x += 25f)
            {
                for (float z = minPos; z < maxPos; z += 25f)
                {
                    var pos = new Vector3(x, 0f, z);

                    pos.y = GetSpawnHeight(pos);

                    if (pos.y >= 0 && !IsPositionBlocked(pos))
                    {
                        _gridPositions.Add(pos);
                    }
                }
            }
        }

        private bool IsPositionBlocked(Vector3 pos)
        {
            if (config.Settings.BlockedPositions.Count > 0 && config.Settings.BlockedPositions.Exists(a => InRange2D(pos, a.position, a.radius)))
            {
                return true;
            }
            if (config.Settings.BlockedGrids.Count > 0)
            {
                string grid = MapHelper.PositionToString(pos);
                return config.Settings.BlockedGrids.Exists(blockedGrid => grid.Equals(blockedGrid, StringComparison.OrdinalIgnoreCase));
            }
            return false;
        }

        public Vector3 RandomDropPosition()
        {
            if (_gridPositions.Count < 5000)
            {
                SetupPositions();
            }

            return _gridPositions.ElementAt(UnityEngine.Random.Range(0, _gridPositions.Count));
        }

        TreasureChest TryOpenEvent(BasePlayer player = null)
        {
            var eventPos = Vector3.zero;

            if (!player.IsKilled())
            {
                if (!Physics.Raycast(player.eyes.HeadRay(), out var hit, Mathf.Infinity, -1, QueryTriggerInteraction.Ignore))
                {
                    return null;
                }

                eventPos = hit.point;
            }
            else
            {
                var randomPos = GetEventPosition();

                if (randomPos == Vector3.zero)
                {
                    return null;
                }

                eventPos = randomPos;
            }

            var container = GameManager.server.CreateEntity(StringPool.Get(2206646561), eventPos) as StorageContainer;

            if (container == null)
            {
                return null;
            }

            container.dropsLoot = false;
            container.enableSaving = false;
            container.Spawn();
            container.SetFlag(BaseEntity.Flags.OnFire, true);
            container.SetFlag(BaseEntity.Flags.Locked, true);

            var chest = container.gameObject.AddComponent<TreasureChest>();
            chest.go = chest.gameObject;
            chest.Instance = this;
            chest.Radius = config.Event.Radius;

            chest.SpawnLoot(container, ChestLoot);

            if (config.Skins.PresetSkin != 0uL)
            {
                container.skinID = config.Skins.PresetSkin;
            }
            else if (config.Skins.Custom.Count > 0)
            {
                container.skinID = config.Skins.Custom.GetRandom();
                container.SendNetworkUpdate();
            }
            else if (config.Skins.RandomSkins)
            {
                var skin = chest.GetItemSkin(ItemManager.FindItemDefinition("box.wooden.large"), 0, false);

                container.skinID = skin;
                container.SendNetworkUpdate();
            }

            var uid = container.net.ID;
            float unlockTime = UnityEngine.Random.Range(config.Unlock.MinTime, config.Unlock.MaxTime);

            SubscribeHooks(true);
            treasureChests[uid] = chest;

            var posStr = FormatGridReference(container.transform.position, config.Settings.ShowGrid);
            Puts("{0}: {1}", FormatGridReference(container.transform.position, true), string.Join(", ", container.inventory.itemList.Select(item => string.Format("{0} ({1})", item.info.displayName.translated, item.amount))));

            //if (!_config.Event.SpawnMax && treasureChests.Count > 1)
            //{
            //    AnnounceEventSpawn(container, unlockTime, posStr);
            //}

            foreach (var target in BasePlayer.activePlayerList)
            {
                double distance = Math.Round(target.transform.position.Distance(container.transform.position), 2);
                string unlockStr = FormatTime(unlockTime, target.UserIDString);

                if (config.EventMessages.Opened)
                {
                    Message(target, "Opened", posStr, unlockStr, distance, config.Settings.DistanceChatCommand);
                }

                if (config.GUIAnnouncement.Enabled && GUIAnnouncements.CanCall() && distance <= config.GUIAnnouncement.Distance)
                {
                    string message = msg("Opened", target.UserIDString, posStr, unlockStr, distance, config.Settings.DistanceChatCommand);
                    GUIAnnouncements?.Call("CreateAnnouncement", message, config.GUIAnnouncement.TintColor, config.GUIAnnouncement.TextColor, target);
                }

                if (config.Rocket.Enabled && config.EventMessages.Barrage)
                {
                    Message(target, "Barrage", config.Rocket.Amount);
                }

                if (config.Event.DrawTreasureIfNearby && config.Event.AutoDrawDistance > 0f && distance <= config.Event.AutoDrawDistance)
                {
                    DrawText(target, container.transform.position, msg("Treasure Chest", target.UserIDString, distance));
                }
            }

            var position = container.transform.position;
            data.TotalEvents++;
            SaveData();

            bool canSpawnNpcs = true;

            if (sd_customPos == Vector3.zero)
            {
                foreach (var x in monuments)
                {
                    if (x.IsInBounds(position))
                    {
                        foreach (var (monument, value) in config.NPC.BlacklistedMonuments)
                        {
                            if (value && x.name.Trim() == monument.Trim())
                            {
                                canSpawnNpcs = false;
                                break;
                            }
                        }
                        break;
                    }
                }
            }

            if (!Rust.Ai.AiManager.nav_disable && canSpawnNpcs) chest.Invoke(chest.SpawnNpcs, 1f);
            chest.Invoke(() => chest.SetUnlockTime(unlockTime), 2f);

            return chest;
        }

        void AnnounceEventSpawn()
        {
            foreach (var target in BasePlayer.activePlayerList)
            {
                string message = msg("OpenedX", target.UserIDString, config.Settings.DistanceChatCommand);

                if (config.EventMessages.Opened)
                {
                    Player.Message(target, message);
                }

                if (config.GUIAnnouncement.Enabled && GUIAnnouncements.CanCall())
                {
                    foreach (var chest in treasureChests.Values)
                    {
                        double distance = Math.Round(target.transform.position.Distance(chest.containerPos), 2);
                        string unlockStr = FormatTime(chest.countdownTime, target.UserIDString);
                        var posStr = FormatGridReference(chest.containerPos, config.Settings.ShowGrid);
                        string text = msg2("Opened", target.UserIDString, posStr, unlockStr, distance, config.Settings.DistanceChatCommand);

                        if (distance <= config.GUIAnnouncement.Distance)
                        {
                            GUIAnnouncements?.Call("CreateAnnouncement", text, config.GUIAnnouncement.TintColor, config.GUIAnnouncement.TextColor, target);
                        }

                        if (config.Event.DrawTreasureIfNearby && config.Event.AutoDrawDistance > 0f && distance <= config.Event.AutoDrawDistance)
                        {
                            DrawText(target, chest.containerPos, msg2("Treasure Chest", target.UserIDString, distance));
                        }
                    }
                }

                if (config.Rocket.Enabled && config.EventMessages.Barrage)
                    Message(target, "Barrage", config.Rocket.Amount);
            }
        }

        void AnnounceEventSpawn(StorageContainer container, float unlockTime, string posStr)
        {
            foreach (var target in BasePlayer.activePlayerList)
            {
                double distance = Math.Round(target.transform.position.Distance(container.transform.position), 2);
                string unlockStr = FormatTime(unlockTime, target.UserIDString);
                string message = msg("Opened", target.UserIDString, posStr, unlockStr, distance, config.Settings.DistanceChatCommand);

                if (config.EventMessages.Opened)
                {
                    Player.Message(target, message);
                }

                if (config.GUIAnnouncement.Enabled && GUIAnnouncements.CanCall() && distance <= config.GUIAnnouncement.Distance)
                {
                    GUIAnnouncements?.Call("CreateAnnouncement", message, config.GUIAnnouncement.TintColor, config.GUIAnnouncement.TextColor, target);
                }

                if (config.Rocket.Enabled && config.EventMessages.Barrage)
                {
                    Message(target, "Barrage", config.Rocket.Amount);
                }

                if (config.Event.DrawTreasureIfNearby && config.Event.AutoDrawDistance > 0f && distance <= config.Event.AutoDrawDistance)
                {
                    DrawText(target, container.transform.position, msg2("Treasure Chest", target.UserIDString, distance));
                }
            }
        }

        void API_SetContainer(StorageContainer container, float radius, bool spawnNpcs) // Expansion Mode for Raidable Bases plugin
        {
            if (!container.IsValid())
            {
                return;
            }

            container.SetFlag(BaseEntity.Flags.Locked, true);
            container.SetFlag(BaseEntity.Flags.OnFire, true);

            var chest = container.gameObject.AddComponent<TreasureChest>();
            chest.markerCreated = true;
            chest.go = chest.gameObject;
            chest.Instance = this;
            float unlockTime = UnityEngine.Random.Range(config.Unlock.MinTime, config.Unlock.MaxTime);

            chest.Radius = radius;
            treasureChests[container.net.ID] = chest;
            chest.Invoke(() => chest.SetUnlockTime(unlockTime), 2f);
            data.TotalEvents++;
            SaveData();

            Subscribe(nameof(OnEntityTakeDamage));
            Subscribe(nameof(OnItemRemovedFromContainer));
            Subscribe(nameof(CanLootEntity));

            if (spawnNpcs)
            {
                Subscribe(nameof(OnNpcTarget));
                Subscribe(nameof(OnNpcResume));
                Subscribe(nameof(OnNpcDestinationSet));
                Subscribe(nameof(OnEntityEnter));
                Subscribe(nameof(OnEntitySpawned));
                Subscribe(nameof(CanBradleyApcTarget));
                chest.Invoke(chest.SpawnNpcs, 1f);
            }
            else if (config.NewmanMode.Harm)
            {
                Subscribe(nameof(OnEntityEnter));
            }
        }

        void CheckSecondsUntilEvent()
        {
            var eventInterval = UnityEngine.Random.Range(config.Event.IntervalMin, config.Event.IntervalMax);
            float stamp = Facepunch.Math.Epoch.Current;
            float time = 1f;

            if (data.SecondsUntilEvent == double.MinValue) // first time users
            {
                data.SecondsUntilEvent = stamp + eventInterval;
                Puts(_("Next Automated Event", null, FormatTime(eventInterval), DateTime.Now.AddSeconds(eventInterval).ToString()));
                SaveData();
            }

            if (config.Event.Automated && data.SecondsUntilEvent - stamp <= 0 && treasureChests.Count < config.Event.Max && BasePlayer.activePlayerList.Count >= config.Event.PlayerLimit)
            {
                bool save = false;

                if (config.Event.SpawnMax)
                {
                    save = TryOpenEvent() != null && treasureChests.Count >= config.Event.Max;
                }
                else save = TryOpenEvent() != null;

                if (save)
                {
                    if (config.Event.SpawnMax && treasureChests.Count > 1)
                    {
                        AnnounceEventSpawn();
                    }

                    data.SecondsUntilEvent = stamp + eventInterval;
                    Puts(_("Next Automated Event", null, FormatTime(eventInterval), DateTime.Now.AddSeconds(eventInterval).ToString()));
                    SaveData();
                }
                else time = config.Event.Stagger;
            }

            timer.Once(time, CheckSecondsUntilEvent);
        }

        public string FormatGridReference(Vector3 position, bool showGrid)
        {
            string monumentName = null;
            float distance = 10000f;

            foreach (var x in monuments) // request MrSmallZzy
            {
                float magnitude = x.position.Distance(position);

                if (magnitude <= x.radius && magnitude < distance)
                {
                    monumentName = x.name;
                    distance = magnitude;
                }
            }

            if (config.Settings.ShowXZ)
            {
                return string.IsNullOrEmpty(monumentName) ? $"{position.x:N2} {position.z:N2}" : $"{monumentName} ({position.x:N2} {position.z:N2})";
            }

            if (showGrid)
            {
                return string.IsNullOrEmpty(monumentName) ? MapHelper.PositionToString(position) : $"{monumentName} ({MapHelper.PositionToString(position)})";
            }

            return string.IsNullOrEmpty(monumentName) ? string.Empty : monumentName;
        }

        private string FormatTime(double seconds, string id = null)
        {
            if (seconds == 0)
            {
                return BasePlayer.activePlayerList.Count < config.Event.PlayerLimit ? msg2("Not Enough Online", id, config.Event.PlayerLimit) : "0s";
            }

            var ts = TimeSpan.FromSeconds(seconds);

            return string.Format("{0:D2}h {1:D2}m {2:D2}s", ts.Hours, ts.Minutes, ts.Seconds);
        }

        bool AssignTreasureHunters(List<KeyValuePair<string, int>> ladder)
        {
            foreach (var target in covalence.Players.All)
            {
                if (target == null || string.IsNullOrEmpty(target.Id))
                {
                    continue;
                }

                if (target.HasPermission(config.RankedLadder.Permission))
                {
                    permission.RevokeUserPermission(target.Id, config.RankedLadder.Permission);
                }

                if (target.UserHasGroup(config.RankedLadder.Group))
                {
                    permission.RemoveUserGroup(target.Id, config.RankedLadder.Group);
                }
            }

            if (!config.RankedLadder.Enabled)
            {
                return true;
            }

            ladder.Sort((x, y) => y.Value.CompareTo(x.Value));

            foreach (var kvp in ladder.Take(config.RankedLadder.Amount))
            {
                var userid = kvp.Key;

                if (permission.UserHasPermission(userid, "dangeroustreasures.notitle"))
                {
                    continue;
                }

                var target = covalence.Players.FindPlayerById(userid);

                if (target != null && target.IsBanned)
                {
                    continue;
                }

                permission.GrantUserPermission(userid, config.RankedLadder.Permission, this);
                permission.AddUserGroup(userid, config.RankedLadder.Group);

                LogToFile("treasurehunters", DateTime.Now.ToString() + " : " + msg("Log Stolen", null, target?.Name ?? userid, userid, kvp.Value), this, true);
                Puts(_("Log Granted", null, target?.Name ?? userid, userid, config.RankedLadder.Permission, config.RankedLadder.Group));
            }

            string file = string.Format("{0}{1}{2}_{3}-{4}.txt", Interface.Oxide.LogDirectory, System.IO.Path.DirectorySeparatorChar, Name, "treasurehunters", DateTime.Now.ToString("yyyy-MM-dd"));
            Puts(_("Log Saved", null, file));

            return true;
        }

        void DrawText(BasePlayer player, Vector3 drawPos, string text)
        {
            if (player == null || !player.IsConnected || drawPos == Vector3.zero || string.IsNullOrEmpty(text) || config.Event.DrawTime < 1f)
                return;

            bool isAdmin = player.IsAdmin;

            try
            {
                if (config.Event.GrantDraw && !player.IsAdmin)
                {
                    var uid = player.userID;

                    if (!drawGrants.Contains(uid))
                    {
                        drawGrants.Add(uid);
                        timer.Once(config.Event.DrawTime, () => drawGrants.Remove(uid));
                    }

                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                    player.SendNetworkUpdateImmediate();
                }

                if (player.IsAdmin || drawGrants.Contains(player.userID))
                    player.SendConsoleCommand("ddraw.text", config.Event.DrawTime, Color.yellow, drawPos, text);
            }
            catch (Exception ex)
            {
                config.Event.GrantDraw = false;
                Puts("DrawText Exception: {0}", ex);
                Puts("Disabled drawing for players!");
            }

            if (!isAdmin)
            {
                if (player.HasPlayerFlag(BasePlayer.PlayerFlags.IsAdmin))
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                    player.SendNetworkUpdateImmediate();
                }
            }
        }

        void AddItem(BasePlayer player, string[] args)
        {
            if (args.Length >= 2)
            {
                string shortname = args[0];
                var itemDef = ItemManager.FindItemDefinition(shortname);

                if (itemDef == null)
                {
                    Message(player, "InvalidItem", shortname, config.Settings.DistanceChatCommand);
                    return;
                }

                if (int.TryParse(args[1], out var amount))
                {
                    if (itemDef.stackable == 1 || (itemDef.condition.enabled && itemDef.condition.max > 0f) || amount < 1)
                        amount = 1;

                    ulong skin = 0uL;

                    if (args.Length >= 3)
                    {
                        if (ulong.TryParse(args[2], out var num)) skin = num;
                        else Message(player, "InvalidValue", args[2]);
                    }

                    int minAmount = amount;
                    if (args.Length >= 4)
                    {
                        if (int.TryParse(args[3], out var num))
                            minAmount = num;
                        else
                            Message(player, "InvalidValue", args[3]);
                    }

                    foreach (var loot in ChestLoot)
                    {
                        if (loot.shortname == shortname)
                        {
                            loot.amount = amount;
                            loot.skin = skin;
                            loot.amountMin = minAmount;
                        }
                    }

                    SaveConfig();
                    Message(player, "AddedItem", shortname, amount, skin);
                }
                else
                    Message(player, "InvalidValue", args[2]);

                return;
            }

            Message(player, "InvalidItem", args.Length >= 1 ? args[0] : "?", config.Settings.DistanceChatCommand);
        }

        void cmdTreasureHunter(BasePlayer player, string command, string[] args)
        {
            if (drawGrants.Contains(player.userID))
                return;
            if (args.Contains("spm") && player.IsAdmin)
            {
                foreach (var mi in monuments)
                {
                    player.SendConsoleCommand("ddraw.sphere", 30f, Color.red, mi.position, mi.radius);
                    player.SendConsoleCommand("ddraw.text", 30f, Color.blue, mi.position, $"<size=22>{mi.name}</size>");
                }
                return;
            }
            if (config.RankedLadder.Enabled)
            {
                if (args.Length >= 1 && (args[0].ToLower() == "ladder" || args[0].ToLower() == "lifetime"))
                {
                    if (data.Players.Count == 0)
                    {
                        Message(player, "Ladder Insufficient Players");
                        return;
                    }

                    if (args.Length == 2 && args[1] == "resetme")
                        if (data.Players.ContainsKey(player.UserIDString))
                            data.Players[player.UserIDString].StolenChestsSeed = 0;

                    int rank = 0;
                    var sb = new StringBuilder();
                    var ladder = data.Players.ToDictionary(k => k.Key, v => args[0].ToLower() == "ladder" ? v.Value.StolenChestsSeed : v.Value.StolenChestsTotal).Where(kvp => kvp.Value > 0).ToList();
                    ladder.Sort((x, y) => y.Value.CompareTo(x.Value));

                    var ranked = msg2(args[0].ToLower() == "ladder" ? "Ladder" : "Ladder Total", player.UserIDString);

                    if (!string.IsNullOrEmpty(ranked))
                    {
                        sb.AppendLine(ranked);
                    }

                    foreach (var kvp in ladder.Take(10))
                    {
                        string name = covalence.Players.FindPlayerById(kvp.Key)?.Name ?? kvp.Key;
                        string value = kvp.Value.ToString("N0");

                        sb.AppendLine(msg2("TreasureHunter", player.UserIDString, ++rank, name, value));
                    }

                    Message(player, sb.ToString());
                    return;
                }

                Message(player, "Wins", data.Players.ContainsKey(player.UserIDString) ? data.Players[player.UserIDString].StolenChestsSeed : 0, config.Settings.DistanceChatCommand);
            }

            if (args.Length >= 1 && player.IsAdmin)
            {
                if (args[0] == "wipe")
                {
                    Message(player, "Log Saved", "treasurehunters");
                    wipeChestsSeed = true;
                    TryWipeData();
                    return;
                }
                else if (args[0] == "resettime")
                {
                    data.SecondsUntilEvent = double.MinValue;
                    return;
                }
                else if (args[0] == "now")
                {
                    data.SecondsUntilEvent = Facepunch.Math.Epoch.Current;
                    return;
                }
                else if (args[0] == "tp" && treasureChests.Count > 0)
                {
                    float dist = float.MaxValue;
                    var position = Vector3.zero;

                    foreach (var entry in treasureChests)
                    {
                        var v3 = entry.Value.containerPos.Distance(player.transform.position);

                        if (treasureChests.Count > 1 && v3 < 25f) // 0.2.0 fix - move admin to the next nearest chest
                            continue;

                        if (v3 < dist)
                        {
                            dist = v3;
                            position = entry.Value.containerPos;
                        }
                    }

                    if (position != Vector3.zero)
                    {
                        if (player.IsFlying)
                        {
                            player.Teleport(position.y > player.transform.position.y ? position : position.WithY(player.transform.position.y));
                        }
                        else player.Teleport(position);
                    }
                }
                else if (args[0].Equals("additem", StringComparison.OrdinalIgnoreCase))
                {
                    AddItem(player, args.Skip(1));
                    return;
                }
                else if (args[0].Equals("showdebuggrid", StringComparison.OrdinalIgnoreCase))
                {
                    if (_gridPositions.Count < 5000) SetupPositions();
                    _gridPositions.ToList().ForEach(pos =>
                    {
                        if (player.Distance(pos) > 1000f) return;
                        player.SendConsoleCommand("ddraw.text", 30f, Color.green, pos, "X");
                    });
                    return;
                }
                else if (args[0].Equals("testblocked", StringComparison.OrdinalIgnoreCase))
                {
                    Player.Message(player, $"IsLayerBlocked: {IsLayerBlocked(player.transform.position, 25f, obstructionLayer)}");
                    Player.Message(player, $"SafeZone: {IsSafeZone(player.transform.position)}");

                    var entities = new List<BaseNetworkable>();

                    foreach (var e in BaseNetworkable.serverEntities.OfType<BaseEntity>())
                    {
                        if (!entities.Contains(e) && InRange2D(e.transform.position, player.transform.position, config.Event.Radius))
                        {
                            if (e.IsNpc || e is LootContainer)
                            {
                                entities.Add(e);
                                player.SendConsoleCommand("ddraw.text", 30f, Color.green, e.transform.position, e.ShortPrefabName);
                            }
                        }
                    }

                    return;
                }
            }

            if (treasureChests.Count == 0)
            {
                double time = Math.Max(0, data.SecondsUntilEvent - Facepunch.Math.Epoch.Current);
                Message(player, "Next", FormatTime(time, player.UserIDString));
                return;
            }

            foreach (var chest in treasureChests.Values)
            {
                double distance = Math.Round(player.transform.position.Distance(chest.containerPos), 2);
                string posStr = FormatGridReference(chest.containerPos, config.Settings.ShowGrid);

                if (chest.GetUnlockTime() != null)
                {
                    Message(player, "Info", chest.GetUnlockTime(player.UserIDString), posStr, distance, config.Settings.DistanceChatCommand);
                }
                else Message(player, "Already", posStr, distance, config.Settings.DistanceChatCommand);

                if (config.Settings.AllowDrawText)
                {
                    DrawText(player, chest.containerPos, msg2("Treasure Chest", player.UserIDString, distance));
                }
            }
        }

        private void ccmdDangerousTreasures(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            var args = arg.Args ?? new string[0];

            if (!arg.IsAdmin)
            {
                if (player == null || !permission.UserHasPermission(player.UserIDString, config.Settings.PermName))
                {
                    Message(arg, "No Permission");
                    return;
                }
            }

            if (args.Length == 1)
            {
                if (args[0].ToLower() == "help")
                {
                    if (player == null)
                    {
                        Puts("Monuments:");
                        foreach (var m in monuments) Puts(m.name);
                    }

                    Message(arg, "Help", config.Settings.EventChatCommand);
                }
                else if (args[0].ToLower() == "5sec") data.SecondsUntilEvent = Facepunch.Math.Epoch.Current + 5f;

                return;
            }

            var position = Vector3.zero;
            bool isTeleport = false;
            int num = 0, amount = 0;

            for (int i = 0; i < args.Length; i++)
            {
                if (int.TryParse(args[i], out var num2))
                {
                    amount = num2;
                }
                else if (args[i].Equals("tp", StringComparison.OrdinalIgnoreCase))
                {
                    isTeleport = true;
                }
            }

            if (amount < 1)
            {
                amount = 1;
            }

            for (int i = 0; i < amount; i++)
            {
                if (treasureChests.Count >= config.Event.Max && !arg.IsAdmin)
                {
                    Message(arg, "Max Manual Events", config.Event.Max);
                    break;
                }

                var chest = TryOpenEvent();

                if (chest != null)
                {
                    position = chest.containerPos;
                    num++;
                }
            }

            if (position != Vector3.zero)
            {
                if (args.Length > 0 && isTeleport && !player.IsKilled() && player.IsAdmin)
                {
                    if (player.IsFlying)
                    {
                        player.Teleport(position.y > player.transform.position.y ? position : position.WithY(player.transform.position.y));
                    }
                    else player.Teleport(position);
                }
            }
            else Message(arg, "Manual Event Failed");

            if (num > 1)
            {
                Message(arg, "OpenedEvents", num, amount);
            }
        }

        void cmdDangerousTreasures(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, config.Settings.PermName) && !player.IsAdmin)
            {
                Message(player, "No Permission");
                return;
            }

            if (args.Length == 1)
            {
                var arg = args[0].ToLower();

                if (arg == "help")
                {
                    Message(player, "Monuments: " + string.Join(", ", monuments.Select(m => m.name)));
                    Message(player, "Help", config.Settings.EventChatCommand);
                    return;
                }
                else if (player.IsAdmin)
                {
                    if (arg == "custom")
                    {
                        if (string.IsNullOrEmpty(data.CustomPosition))
                        {
                            data.CustomPosition = player.transform.position.ToString();
                            sd_customPos = player.transform.position;
                            Message(player, "CustomPositionSet", data.CustomPosition);
                        }
                        else
                        {
                            data.CustomPosition = string.Empty;
                            sd_customPos = Vector3.zero;
                            Message(player, "CustomPositionRemoved");
                        }
                        SaveData();
                        return;
                    }
                }
            }

            if (treasureChests.Count >= config.Event.Max && player.net.connection.authLevel < 2)
            {
                Message(player, "Max Manual Events", config.Event.Max);
                return;
            }

            var chest = TryOpenEvent(args.Length == 1 && args[0] == "me" && player.IsAdmin ? player : null);

            if (chest != null)
            {
                if (args.Length == 1 && args[0].ToLower() == "tp" && player.IsAdmin)
                {
                    if (player.IsFlying)
                    {
                        player.Teleport(chest.containerPos.y > player.transform.position.y ? chest.containerPos : chest.containerPos.WithY(player.transform.position.y));
                    }
                    else player.Teleport(chest.containerPos);
                }
            }
            else
            {
                Message(player, "Manual Event Failed");
            }
        }

        #region Config

        Dictionary<string, string> GetMessages()
        {
            return new()
            {
                {"No Permission", "You do not have permission to use this command."},
                {"Building is blocked!", "<color=#FF0000>Building is blocked near treasure chests!</color>"},
                {"Max Manual Events", "Maximum number of manual events <color=#FF0000>{0}</color> has been reached!"},
                {"Dangerous Zone Protected", "<color=#FF0000>You have entered a dangerous zone protected by a fire aura! You must leave before you die!</color>"},
                {"Dangerous Zone Unprotected", "<color=#FF0000>You have entered a dangerous zone!</color>"},
                {"Manual Event Failed", "Event failed to start! Unable to obtain a valid position. Please try again."},
                {"Help", "/{0} <tp> - start a manual event, and teleport to the position if TP argument is specified and you are an admin."},
                {"Started", "<color=#C0C0C0>The event has started at <color=#FFFF00>{0}</color>! The protective fire aura has been obliterated!</color>"},
                {"StartedNpcs", "<color=#C0C0C0>The event has started at <color=#FFFF00>{0}</color>! The protective fire aura has been obliterated! Npcs must be killed before the treasure will become lootable.</color>"},
                {"Opened", "<color=#C0C0C0>An event has opened at <color=#FFFF00>{0}</color>! Event will start in <color=#FFFF00>{1}</color>. You are <color=#FFA500>{2}m</color> away. Use <color=#FFA500>/{3}</color> for help.</color>"},
                {"OpenedX", "<color=#C0C0C0><color=#FFFF00>Multiple events have opened! Use <color=#FFA500>/{0}</color> for help.</color>"},
                {"Barrage", "<color=#C0C0C0>A barrage of <color=#FFFF00>{0}</color> rockets can be heard at the location of the event!</color>"},
                {"Info", "<color=#C0C0C0>Event will start in <color=#FFFF00>{0}</color> at <color=#FFFF00>{1}</color>. You are <color=#FFA500>{2}m</color> away.</color>"},
                {"Already", "<color=#C0C0C0>The event has already started at <color=#FFFF00>{0}</color>! You are <color=#FFA500>{1}m</color> away.</color>"},
                {"Next", "<color=#C0C0C0>No events are open. Next event in <color=#FFFF00>{0}</color></color>"},
                {"Thief", "<color=#C0C0C0>The treasures at <color=#FFFF00>{0}</color> have been stolen by <color=#FFFF00>{1}</color>!</color>"},
                {"Wins", "<color=#C0C0C0>You have stolen <color=#FFFF00>{0}</color> treasure chests! View the ladder using <color=#FFA500>/{1} ladder</color> or <color=#FFA500>/{1} lifetime</color></color>"},
                {"Ladder", "<color=#FFFF00>[ Top 10 Treasure Hunters (This Wipe) ]</color>:"},
                {"Ladder Total", "<color=#FFFF00>[ Top 10 Treasure Hunters (Lifetime) ]</color>:"},
                {"Ladder Insufficient Players", "<color=#FFFF00>No players are on the ladder yet!</color>"},
                {"Event At", "Event at {0}"},
                {"Next Automated Event", "Next automated event in {0} at {1}"},
                {"Not Enough Online", "Not enough players online ({0} minimum)"},
                {"Treasure Chest", "Treasure Chest <color=#FFA500>{0}m</color>"},
                {"Invalid Constant", "Invalid constant {0} - please notify the author!"},
                {"Destroyed Treasure Chest", "Destroyed a left over treasure chest at {0}"},
                {"Indestructible", "<color=#FF0000>Treasure chests are indestructible!</color>"},
                {"Newman Enter", "<color=#FF0000>To walk with clothes is to set one-self on fire. Tread lightly.</color>"},
                {"Newman Traitor Burn", "<color=#FF0000>Tempted by the riches you have defiled these grounds. Vanish from these lands or PERISH!</color>"},
                {"Newman Traitor", "<color=#FF0000>Tempted by the riches you have defiled these grounds. Vanish from these lands!</color>"},
                {"Newman Protected", "<color=#FF0000>This newman is temporarily protected on these grounds!</color>"},
                {"Newman Protect", "<color=#FF0000>You are protected on these grounds. Do not defile them.</color>"},
                {"Newman Protect Fade", "<color=#FF0000>Your protection has faded.</color>"},
                {"Log Stolen", "{0} ({1}) chests stolen {2}"},
                {"Log Granted", "Granted {0} ({1}) permission {2} for group {3}"},
                {"Log Saved", "Treasure Hunters have been logged to: {0}"},
                {"MessagePrefix", "[ <color=#406B35>Dangerous Treasures</color> ] "},
                {"Countdown", "<color=#C0C0C0>Event at <color=#FFFF00>{0}</color> will start in <color=#FFFF00>{1}</color>!</color>"},
                {"RestartDetected", "Restart detected. Next event in {0} minutes."},
                {"DestroyingTreasure", "<color=#C0C0C0>The treasure at <color=#FFFF00>{0}</color> will be destroyed by fire in <color=#FFFF00>{1}</color> if not looted! Use <color=#FFA500>/{2}</color> to find this chest.</color>"},
                {"EconomicsDeposit", "You have received <color=#FFFF00>${0}</color> for stealing the treasure!"},
                {"ServerRewardPoints", "You have received <color=#FFFF00>{0} RP</color> for stealing the treasure!"},
                {"InvalidItem", "Invalid item shortname: {0}. Use /{1} additem <shortname> <amount> [skin]"},
                {"AddedItem", "Added item: {0} amount: {1}, skin: {2}"},
                {"CustomPositionSet", "Custom event spawn location set to: {0}"},
                {"CustomPositionRemoved", "Custom event spawn location removed."},
                {"OpenedEvents", "Opened {0}/{1} events."},
                {"OnFirstPlayerEntered", "<color=#FFFF00>{0}</color> is the first to enter the dangerous treasure event at <color=#FFFF00>{1}</color>"},
                {"OnChestOpened", "<color=#FFFF00>{0}</color> is the first to see the treasures at <color=#FFFF00>{1}</color>!</color>"},
                {"OnChestDespawned", "The treasures at <color=#FFFF00>{0}</color> have been lost forever! Better luck next time."},
                {"CannotBeMounted", "You cannot loot the treasure while mounted!"},
                {"CannotBeLooted", "This treasure does not belong to you!"},
                {"CannotTeleport", "You are not allowed to teleport from this event."},
                {"TreasureHunter", "<color=#ADD8E6>{0}</color>. <color=#C0C0C0>{1}</color> (<color=#FFFF00>{2}</color>)"},
                {"Timed Event", "<color=#FFFF00>You cannot loot until the fire aura expires! Tread lightly, the fire aura is very deadly!</color>)"},
                {"Timed Npc Event", "<color=#FFFF00>You cannot loot until you kill all of the npcs and wait for the fire aura to expire! Tread lightly, the fire aura is very deadly!</color>)"},
                {"Npc Event", "<color=#FFFF00>You cannot loot until you kill all of the npcs surrounding the fire aura! Tread lightly, the fire aura is very deadly!</color>)"},
            };
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(GetMessages(), this);
        }

        private int GetPercentIncreasedAmount(int amount)
        {
            if (config.Treasure.UseDOWL && !config.Treasure.Increased && config.Treasure.PercentLoss > 0m)
            {
                return UnityEngine.Random.Range(Convert.ToInt32(amount - (amount * config.Treasure.PercentLoss)), amount + 1);
            }

            decimal percentIncrease = 0m;

            switch (DateTime.Now.DayOfWeek)
            {
                case DayOfWeek.Monday:
                    {
                        percentIncrease = config.Treasure.PercentIncreaseOnMonday;
                        break;
                    }
                case DayOfWeek.Tuesday:
                    {
                        percentIncrease = config.Treasure.PercentIncreaseOnTuesday;
                        break;
                    }
                case DayOfWeek.Wednesday:
                    {
                        percentIncrease = config.Treasure.PercentIncreaseOnWednesday;
                        break;
                    }
                case DayOfWeek.Thursday:
                    {
                        percentIncrease = config.Treasure.PercentIncreaseOnThursday;
                        break;
                    }
                case DayOfWeek.Friday:
                    {
                        percentIncrease = config.Treasure.PercentIncreaseOnFriday;
                        break;
                    }
                case DayOfWeek.Saturday:
                    {
                        percentIncrease = config.Treasure.PercentIncreaseOnSaturday;
                        break;
                    }
                case DayOfWeek.Sunday:
                    {
                        percentIncrease = config.Treasure.PercentIncreaseOnSunday;
                        break;
                    }
            }

            if (percentIncrease > 1m)
            {
                percentIncrease /= 100;
            }

            if (percentIncrease > 0m)
            {
                amount = Convert.ToInt32(amount + (amount * percentIncrease));

                if (config.Treasure.PercentLoss > 0m)
                {
                    amount = UnityEngine.Random.Range(Convert.ToInt32(amount - (amount * config.Treasure.PercentLoss)), amount + 1);
                }
            }

            return amount;
        }

        public static Color __(string hex)
        {
            return ColorUtility.TryParseHtmlString(hex.StartsWith("#") ? hex : $"#{hex}", out var color) ? color : Color.red;
        }

        private string _(string key, string id = null, params object[] args)
        {
            return RemoveFormatting(msg(key, id, args));
        }

        private Regex IndexRegex = new Regex(@"\{(\d+)\}", RegexOptions.Compiled);

        public string Format(string format, params object[] args)
        {
            return IndexRegex.Replace(format, match =>
            {
                if (int.TryParse(match.Groups[1].Value, out int index) && index < args.Length)
                {
                    return args[index] != null ? args[index].ToString() : string.Empty;
                }

                return match.Value;
            });
        }

        private string msg(string key, string id = null, params object[] args)
        {
            string message = config.EventMessages.Prefix && id != null && id != "server_console" ? lang.GetMessage("MessagePrefix", this, null) + lang.GetMessage(key, this, id) : lang.GetMessage(key, this, id);

            return args.Length > 0 ? Format(message, args) : message;
        }

        private string msg2(string key, string id, params object[] args)
        {
            string message = lang.GetMessage(key, this, id);

            return args.Length > 0 ? Format(message, args) : message;
        }

        private string RemoveFormatting(string source) => source.Contains(">") ? System.Text.RegularExpressions.Regex.Replace(source, "<.*?>", string.Empty) : source;

        private void Message(BasePlayer player, string key, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            string message = msg(key, player.UserIDString, args);

            if (string.IsNullOrEmpty(message))
            {
                return;
            }

            if (config.EventMessages.Message)
            {
                Player.Message(player, message, 0uL);
            }

            if (config.EventMessages.AA.Enabled || config.EventMessages.NotifyType != -1)
            {
                if (!_notifications.TryGetValue(player.userID, out var notifications))
                {
                    _notifications[player.userID] = notifications = new();
                }

                notifications.Add(new()
                {
                    player = player,
                    messageEx = message
                });
            }
        }

        private void Message(IPlayer user, string key, params object[] args)
        {
            if (user != null)
            {
                user.Reply(msg2(key, user.Id, args));
            }
        }

        private void Message(ConsoleSystem.Arg arg, string key, params object[] args)
        {
            if (arg != null)
            {
                arg.ReplyWith(msg2(key, arg.Player()?.UserIDString, args));
            }
        }

        public class Notification
        {
            public BasePlayer player;
            public string messageEx;
        }

        private Dictionary<ulong, List<Notification>> _notifications = new();

        private void CheckNotifications()
        {
            if (_notifications.Count > 0)
            {
                foreach (var entry in _notifications.ToList())
                {
                    var notification = entry.Value.ElementAt(0);

                    SendNotification(notification);

                    entry.Value.Remove(notification);

                    if (entry.Value.Count == 0)
                    {
                        _notifications.Remove(entry.Key);
                    }
                }
            }
        }

        private void SendNotification(Notification notification)
        {
            if (!notification.player.IsReallyConnected())
            {
                return;
            }

            if (config.EventMessages.AA.Enabled && AdvancedAlerts.CanCall())
            {
                AdvancedAlerts?.Call("SpawnAlert", notification.player, "hook", notification.messageEx, config.EventMessages.AA.AnchorMin, config.EventMessages.AA.AnchorMax, config.EventMessages.AA.Time);
            }

            if (config.EventMessages.NotifyType != -1 && Notify.CanCall())
            {
                Notify?.Call("SendNotify", notification.player, config.EventMessages.NotifyType, notification.messageEx);
            }
        }

        #endregion

        #region Configuration

        private Configuration config;

        private static List<LootItem> DefaultLoot
        {
            get
            {
                return new()
                {
                    new() { shortname = "ammo.pistol", amount = 40, skin = 0, amountMin = 40 },
                    new() { shortname = "ammo.pistol.fire", amount = 40, skin = 0, amountMin = 40 },
                    new() { shortname = "ammo.pistol.hv", amount = 40, skin = 0, amountMin = 40 },
                    new() { shortname = "ammo.rifle", amount = 60, skin = 0, amountMin = 60 },
                    new() { shortname = "ammo.rifle.explosive", amount = 60, skin = 0, amountMin = 60 },
                    new() { shortname = "ammo.rifle.hv", amount = 60, skin = 0, amountMin = 60 },
                    new() { shortname = "ammo.rifle.incendiary", amount = 60, skin = 0, amountMin = 60 },
                    new() { shortname = "ammo.shotgun", amount = 24, skin = 0, amountMin = 24 },
                    new() { shortname = "ammo.shotgun.slug", amount = 40, skin = 0, amountMin = 40 },
                    new() { shortname = "surveycharge", amount = 20, skin = 0, amountMin = 20 },
                    new() { shortname = "metal.refined", amount = 150, skin = 0, amountMin = 150 },
                    new() { shortname = "bucket.helmet", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "cctv.camera", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "coffeecan.helmet", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "explosive.timed", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "metal.facemask", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "metal.plate.torso", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "pistol.m92", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "rifle.ak", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "rifle.bolt", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "rifle.lr300", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "smg.2", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "smg.mp5", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "smg.thompson", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "supply.signal", amount = 1, skin = 0, amountMin = 1 },
                    new() { shortname = "targeting.computer", amount = 1, skin = 0, amountMin = 1 },
                };
            }
        }

        public class PluginSettings
        {
            [JsonProperty(PropertyName = "Permission Name")]
            public string PermName { get; set; } = "dangeroustreasures.use";

            [JsonProperty(PropertyName = "Event Chat Command")]
            public string EventChatCommand { get; set; } = "dtevent";

            [JsonProperty(PropertyName = "Distance Chat Command")]
            public string DistanceChatCommand { get; set; } = "dtd";

            [JsonProperty(PropertyName = "Draw Location On Screen With Distance Command")]
            public bool AllowDrawText { get; set; } = true;

            [JsonProperty(PropertyName = "Event Console Command")]
            public string EventConsoleCommand { get; set; } = "dtevent";

            [JsonProperty(PropertyName = "Show X Z Coordinates")]
            public bool ShowXZ { get; set; } = false;

            [JsonProperty(PropertyName = "Show Grid Coordinates")]
            public bool ShowGrid { get; set; } = true;

            [JsonProperty(PropertyName = "Grids To Block Spawns At", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> BlockedGrids = new();

            [JsonProperty(PropertyName = "Block Spawns At Positions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ManagementSettingsLocations> BlockedPositions = new() { new(Vector3.zero, 1f) };
        }

        public class ManagementSettingsLocations
        {
            [JsonProperty(PropertyName = "position")]
            [JsonConverter(typeof(UnityVector3Converter))]
            public Vector3 position;
            public float radius;
            public ManagementSettingsLocations() { }
            public ManagementSettingsLocations(Vector3 position, float radius)
            {
                (this.position, this.radius) = (position, radius);
            }
        }

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    var values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                var o = Newtonsoft.Json.Linq.JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }

        public class CountdownSettings
        {
            [JsonProperty(PropertyName = "Use Countdown Before Event Starts")]
            public bool Enabled { get; set; } = false;

            [JsonProperty(PropertyName = "Time In Seconds", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<int> Times { get; set; } = new() { 120, 60, 30, 15 };
        }

        public class EventSettings
        {
            [JsonProperty(PropertyName = "Allow Player Bags To Be Lootable At Events")]
            public bool PlayersLootable;

            [JsonProperty(PropertyName = "Automated")]
            public bool Automated { get; set; } = false;

            [JsonProperty(PropertyName = "Every Min Seconds")]
            public float IntervalMin { get; set; } = 3600f;

            [JsonProperty(PropertyName = "Every Max Seconds")]
            public float IntervalMax { get; set; } = 7200f;

            [JsonProperty(PropertyName = "Use Vending Map Marker")]
            public bool MarkerVending { get; set; } = true;

            [JsonProperty(PropertyName = "Use Marker Manager Plugin")]
            public bool MarkerManager { get; set; }

            [JsonProperty(PropertyName = "Use Explosion Map Marker")]
            public bool MarkerExplosion { get; set; } = false;

            [JsonProperty(PropertyName = "Marker Color")]
            public string MarkerColor { get; set; } = "#FF0000";

            [JsonProperty(PropertyName = "Marker Radius")]
            public float MarkerRadius { get; set; } = 0.25f;

            [JsonProperty(PropertyName = "Marker Radius (Smaller Maps)")]
            public float MarkerRadiusSmall { get; set; } = 0.5f;

            [JsonProperty(PropertyName = "Marker Event Name")]
            public string MarkerName { get; set; } = "Dangerous Treasures Event";

            [JsonProperty(PropertyName = "Max Manual Events")]
            public int Max { get; set; } = 1;

            [JsonProperty(PropertyName = "Always Spawn Max Manual Events")]
            public bool SpawnMax { get; set; }

            [JsonProperty(PropertyName = "Stagger Spawns Every X Seconds")]
            public float Stagger { get; set; } = 10f;

            [JsonProperty(PropertyName = "Amount Of Items To Spawn")]
            public int TreasureAmount { get; set; } = 6;

            [JsonProperty(PropertyName = "Use Spheres")]
            public bool Spheres { get; set; } = true;

            [JsonProperty(PropertyName = "Amount Of Spheres")]
            public int SphereAmount { get; set; } = 5;

            [JsonProperty(PropertyName = "Destroy Spheres When Event Starts")]
            public bool DestroySphereOnStart { get; set; } = true;

            [JsonProperty(PropertyName = "Player Limit For Event")]
            public int PlayerLimit { get; set; } = 1;

            [JsonProperty(PropertyName = "Fire Aura Radius (Advanced Users Only)")]
            public float Radius { get; set; } = 25f;

            [JsonProperty(PropertyName = "Auto Draw On New Event For Nearby Players")]
            public bool DrawTreasureIfNearby { get; set; } = false;

            [JsonProperty(PropertyName = "Auto Draw Minimum Distance")]
            public float AutoDrawDistance { get; set; } = 300f;

            [JsonProperty(PropertyName = "Grant DDRAW temporarily to players")]
            public bool GrantDraw { get; set; } = true;

            [JsonProperty(PropertyName = "Grant Draw Time")]
            public float DrawTime { get; set; } = 15f;

            [JsonProperty(PropertyName = "Time To Loot")]
            public float DestructTime { get; set; } = 900f;
        }

        public class UIAdvancedAlertSettings
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; } = true;

            [JsonProperty(PropertyName = "Anchor Min")]
            public string AnchorMin { get; set; } = "0.35 0.85";

            [JsonProperty(PropertyName = "Anchor Max")]
            public string AnchorMax { get; set; } = "0.65 0.95";

            [JsonProperty(PropertyName = "Time Shown")]
            public float Time { get; set; } = 5f;
        }

        public class EventMessageSettings
        {
            [JsonProperty(PropertyName = "Advanced Alerts UI")]
            public UIAdvancedAlertSettings AA { get; set; } = new();

            [JsonProperty(PropertyName = "Notify Plugin - Type (-1 = disabled)")]
            public int NotifyType { get; set; }

            [JsonProperty(PropertyName = "UI Popup Interval")]
            public float Interval { get; set; } = 1f;

            [JsonProperty(PropertyName = "Show Noob Warning Message")]
            public bool NoobWarning { get; set; }

            [JsonProperty(PropertyName = "Show Barrage Message")]
            public bool Barrage { get; set; } = true;

            [JsonProperty(PropertyName = "Show Despawn Message")]
            public bool Destruct { get; set; } = true;

            [JsonProperty(PropertyName = "Show You Have Entered")]
            public bool Entered { get; set; } = true;

            [JsonProperty(PropertyName = "Show First Player Entered")]
            public bool FirstEntered { get; set; } = false;

            [JsonProperty(PropertyName = "Show First Player Opened")]
            public bool FirstOpened { get; set; } = false;

            [JsonProperty(PropertyName = "Show Opened Message")]
            public bool Opened { get; set; } = true;

            [JsonProperty(PropertyName = "Show Prefix")]
            public bool Prefix { get; set; } = true;

            [JsonProperty(PropertyName = "Show Started Message")]
            public bool Started { get; set; } = true;

            [JsonProperty(PropertyName = "Show Thief Message")]
            public bool Thief { get; set; } = true;

            [JsonProperty(PropertyName = "Send Messages To Player")]
            public bool Message { get; set; } = true;
        }

        public class FireballSettings
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; } = true;

            [JsonProperty(PropertyName = "Damage Per Second")]
            public float DamagePerSecond { get; set; } = 10f;

            [JsonProperty(PropertyName = "Lifetime Min")]
            public float LifeTimeMin { get; set; } = 7.5f;

            [JsonProperty(PropertyName = "Lifetime Max")]
            public float LifeTimeMax { get; set; } = 10f;

            [JsonProperty(PropertyName = "Radius")]
            public float Radius { get; set; } = 1f;

            [JsonProperty(PropertyName = "Tick Rate")]
            public float TickRate { get; set; } = 1f;

            [JsonProperty(PropertyName = "Generation")]
            public float Generation { get; set; } = 5f;

            [JsonProperty(PropertyName = "Water To Extinguish")]
            public int WaterToExtinguish { get; set; } = 25;

            [JsonProperty(PropertyName = "Spawn Every X Seconds")]
            public int SecondsBeforeTick { get; set; } = 5;
        }

        public class GUIAnnouncementSettings
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; } = false;

            [JsonProperty(PropertyName = "Text Color")]
            public string TextColor { get; set; } = "White";

            [JsonProperty(PropertyName = "Banner Tint Color")]
            public string TintColor { get; set; } = "Grey";

            [JsonProperty(PropertyName = "Maximum Distance")]
            public float Distance { get; set; } = 300f;
        }

        public class MissileLauncherSettings
        {
            [JsonProperty(PropertyName = "Acquire Time In Seconds")]
            public float TargettingTime { get; set; } = 10f;

            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; } = false;

            [JsonProperty(PropertyName = "Damage Per Missile")]
            public float Damage { get; set; } = 0.0f;

            [JsonProperty(PropertyName = "Detection Distance")]
            public float Distance { get; set; } = 15f;

            [JsonProperty(PropertyName = "Life Time In Seconds")]
            public float Lifetime { get; set; } = 60f;

            [JsonProperty(PropertyName = "Ignore Flying Players")]
            public bool IgnoreFlying { get; set; } = true;

            [JsonProperty(PropertyName = "Spawn Every X Seconds")]
            public float Frequency { get; set; } = 15f;

            [JsonProperty(PropertyName = "Target Chest If No Player Target")]
            public bool TargetChest { get; set; } = false;
        }

        public class MonumentSettings
        {
            [JsonProperty(PropertyName = "Blacklisted Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, bool> Blacklist { get; set; } = new()
            {
                ["Bandit Camp"] = true,
                ["Barn"] = true,
                ["Fishing Village"] = true,
                ["Junkyard"] = true,
                ["Large Barn"] = true,
                ["Large Fishing Village"] = true,
                ["Outpost"] = true,
                ["Ranch"] = true,
                ["Train Tunnel"] = true,
                ["Underwater Lab"] = true,
            };

            [JsonProperty(PropertyName = "Auto Spawn At Monuments Only")]
            public bool Only { get; set; } = false;

            [JsonProperty(PropertyName = "Chance To Spawn At Monuments Instead")]
            public float Chance { get; set; } = 0.0f;

            [JsonProperty(PropertyName = "Allow Treasure Loot Underground")]
            public bool Underground { get; set; } = false;
        }

        public class NewmanModeSettings
        {
            [JsonProperty(PropertyName = "Protect Nakeds From Fire Aura")]
            public bool Aura { get; set; } = false;

            [JsonProperty(PropertyName = "Protect Nakeds From Other Harm")]
            public bool Harm { get; set; } = false;
        }

        public class NpcKitSettings
        {
            [JsonProperty(PropertyName = "Helm", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Helm = new();

            [JsonProperty(PropertyName = "Torso", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Torso = new();

            [JsonProperty(PropertyName = "Pants", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Pants = new();

            [JsonProperty(PropertyName = "Gloves", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Gloves = new();

            [JsonProperty(PropertyName = "Boots", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Boots = new();

            [JsonProperty(PropertyName = "Shirt", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Shirt = new();

            [JsonProperty(PropertyName = "Kilts", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Kilts = new();

            [JsonProperty(PropertyName = "Weapon", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Weapon = new();
        }

        public class NpcLootSettings
        {
            [JsonProperty(PropertyName = "Prefab ID List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> IDs { get; set; } = new() { "cargo", "turret_any", "ch47_gunner", "excavator", "full_any", "heavy", "junkpile_pistol", "oilrig", "patrol", "peacekeeper", "roam", "roamtethered" };

            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; }

            [JsonProperty(PropertyName = "Disable All Prefab Loot Spawns")]
            public bool None { get; set; }

            public uint GetRandom()
            {
                if (IDs.Count > 0)
                {
                    switch (IDs.GetRandom())
                    {
                        case "cargo": return 3623670799;
                        case "turret_any": return 1639447304;
                        case "ch47_gunner": return 1017671955;
                        case "excavator": return 4293908444;
                        case "full_any": return 1539172658;
                        case "heavy": return 1536035819;
                        case "junkpile_pistol": return 2066159302;
                        case "cargo_turret": return 881071619;
                        case "oilrig": return 548379897;
                        case "patrol": return 4272904018;
                        case "peacekeeper": return 2390854225;
                        case "roam": return 4199494415;
                        case "roamtethered": return 529928930;
                    }
                }

                return 1536035819;
            }
        }

        public class NpcSettingsAccuracy
        {
            [JsonProperty(PropertyName = "AK47")]
            public double AK47 { get; set; }

            [JsonProperty(PropertyName = "AK47 ICE")]
            public double AK47ICE { get; set; }

            [JsonProperty(PropertyName = "Bolt Rifle")]
            public double BOLT_RIFLE { get; set; }

            [JsonProperty(PropertyName = "Compound Bow")]
            public double COMPOUND_BOW { get; set; }

            [JsonProperty(PropertyName = "Crossbow")]
            public double CROSSBOW { get; set; }

            [JsonProperty(PropertyName = "Double Barrel Shotgun")]
            public double DOUBLE_SHOTGUN { get; set; }

            [JsonProperty(PropertyName = "Eoka")]
            public double EOKA { get; set; }

            [JsonProperty(PropertyName = "Glock")]
            public double GLOCK { get; set; }

            [JsonProperty(PropertyName = "HMLMG")]
            public double HMLMG { get; set; }

            [JsonProperty(PropertyName = "L96")]
            public double L96 { get; set; }

            [JsonProperty(PropertyName = "LR300")]
            public double LR300 { get; set; }

            [JsonProperty(PropertyName = "M249")]
            public double M249 { get; set; }

            [JsonProperty(PropertyName = "M39")]
            public double M39 { get; set; }

            [JsonProperty(PropertyName = "M92")]
            public double M92 { get; set; }

            [JsonProperty(PropertyName = "MP5")]
            public double MP5 { get; set; }

            [JsonProperty(PropertyName = "Nailgun")]
            public double NAILGUN { get; set; }

            [JsonProperty(PropertyName = "Pump Shotgun")]
            public double PUMP_SHOTGUN { get; set; }

            [JsonProperty(PropertyName = "Python")]
            public double PYTHON { get; set; }

            [JsonProperty(PropertyName = "Revolver")]
            public double REVOLVER { get; set; }

            [JsonProperty(PropertyName = "Semi Auto Pistol")]
            public double SEMI_AUTO_PISTOL { get; set; }

            [JsonProperty(PropertyName = "Semi Auto Rifle")]
            public double SEMI_AUTO_RIFLE { get; set; }

            [JsonProperty(PropertyName = "Spas12")]
            public double SPAS12 { get; set; }

            [JsonProperty(PropertyName = "Speargun")]
            public double SPEARGUN { get; set; }

            [JsonProperty(PropertyName = "SMG")]
            public double SMG { get; set; }

            [JsonProperty(PropertyName = "Snowball Gun")]
            public double SNOWBALL_GUN { get; set; }

            [JsonProperty(PropertyName = "Thompson")]
            public double THOMPSON { get; set; }

            [JsonProperty(PropertyName = "Waterpipe Shotgun")]
            public double WATERPIPE_SHOTGUN { get; set; }

            public NpcSettingsAccuracy(double accuracy)
            {
                AK47 = AK47ICE = BOLT_RIFLE = COMPOUND_BOW = CROSSBOW = DOUBLE_SHOTGUN = EOKA = GLOCK = HMLMG = L96 = LR300 = M249 = M39 = M92 = MP5 = NAILGUN = PUMP_SHOTGUN = PYTHON = REVOLVER = SEMI_AUTO_PISTOL = SEMI_AUTO_RIFLE = SPAS12 = SPEARGUN = SMG = SNOWBALL_GUN = THOMPSON = WATERPIPE_SHOTGUN = accuracy;
            }

            public double Get(HumanoidBrain brain)
            {
                switch (brain.AttackEntity?.ShortPrefabName)
                {
                    case "ak47u.entity": return AK47;
                    case "ak47u_ice.entity": return AK47ICE;
                    case "bolt_rifle.entity": return BOLT_RIFLE;
                    case "compound_bow.entity": return COMPOUND_BOW;
                    case "crossbow.entity": return CROSSBOW;
                    case "bow_hunting.entity": return CROSSBOW;
                    case "double_shotgun.entity": return DOUBLE_SHOTGUN;
                    case "glock.entity": return GLOCK;
                    case "hmlmg.entity": return HMLMG;
                    case "l96.entity": return L96;
                    case "lr300.entity": return LR300;
                    case "m249.entity": return M249;
                    case "m39.entity": return M39;
                    case "m92.entity": return M92;
                    case "mp5.entity": return MP5;
                    case "nailgun.entity": return NAILGUN;
                    case "pistol_eoka.entity": return EOKA;
                    case "pistol_revolver.entity": return REVOLVER;
                    case "pistol_semiauto.entity": return SEMI_AUTO_PISTOL;
                    case "python.entity": return PYTHON;
                    case "semi_auto_rifle.entity": return SEMI_AUTO_RIFLE;
                    case "shotgun_pump.entity": return PUMP_SHOTGUN;
                    case "shotgun_waterpipe.entity": return WATERPIPE_SHOTGUN;
                    case "spas12.entity": return SPAS12;
                    case "speargun.entity": return SPEARGUN;
                    case "smg.entity": return SMG;
                    case "snowballgun.entity": return SNOWBALL_GUN;
                    case "thompson.entity": default: return THOMPSON;
                }
            }
        }

        public class NpcSettingsMurderer
        {
            [JsonProperty(PropertyName = "Random Names", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> RandomNames { get; set; } = new();

            [JsonProperty(PropertyName = "Items)")]
            public NpcKitSettings Items { get; set; } = new()
            {
                Helm = { "metal.facemask" },
                Torso = { "metal.plate.torso" },
                Pants = { "pants" },
                Gloves = { "tactical.gloves" },
                Boots = { "boots.frog" },
                Shirt = { "tshirt" },
                Weapon = { "machete" }
            };

            [JsonProperty(PropertyName = "Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Kits { get; set; } = new() { "murderer_kit_1", "murderer_kit_2" };

            [JsonProperty(PropertyName = "Spawn Alternate Loot")]
            public NpcLootSettings Alternate { get; set; } = new();

            [JsonProperty(PropertyName = "Weapon Accuracy (0 - 100)")]
            public NpcSettingsAccuracy Accuracy { get; set; } = new(100);

            [JsonProperty(PropertyName = "Aggression Range")]
            public float AggressionRange { get; set; } = 70f;

            [JsonProperty(PropertyName = "Despawn Inventory On Death")]
            public bool DespawnInventory { get; set; } = true;

            [JsonProperty(PropertyName = "Corpse Despawn Time When Despawn Inventory On Death")]
            public float DespawnInventoryTime { get; set; } = 30f;

            [JsonProperty(PropertyName = "Corpse Despawn Time Otherwise")]
            public float CorpseDespawnTime { get; set; } = 300f;

            [JsonProperty(PropertyName = "Die Instantly From Headshots")]
            public bool Headshot { get; set; }

            [JsonProperty(PropertyName = "Amount To Spawn (min)")]
            public int SpawnMinAmount { get; set; } = 2;

            [JsonProperty(PropertyName = "Amount To Spawn (max)")]
            public int SpawnAmount { get; set; } = 2;

            [JsonProperty(PropertyName = "Health")]
            public float Health { get; set; } = 150f;
        }

        public class NpcSettingsScientist
        {
            [JsonProperty(PropertyName = "Random Names", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> RandomNames { get; set; } = new();

            [JsonProperty(PropertyName = "Items")]
            public NpcKitSettings Items { get; set; } = new()
            {
                Torso = { "hazmatsuit_scientist_peacekeeper" },
                Weapon = { "rifle.ak" }
            };

            [JsonProperty(PropertyName = "Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Kits { get; set; } = new() { "scientist_kit_1", "scientist_kit_2" };

            [JsonProperty(PropertyName = "Spawn Alternate Loot")]
            public NpcLootSettings Alternate { get; set; } = new();

            [JsonProperty(PropertyName = "Weapon Accuracy (0 - 100)")]
            public NpcSettingsAccuracy Accuracy { get; set; } = new(20);

            [JsonProperty(PropertyName = "Aggression Range")]
            public float AggressionRange { get; set; } = 70f;

            [JsonProperty(PropertyName = "Despawn Inventory On Death")]
            public bool DespawnInventory { get; set; } = true;

            [JsonProperty(PropertyName = "Corpse Despawn Time When Despawn Inventory On Death")]
            public float DespawnInventoryTime { get; set; } = 30f;

            [JsonProperty(PropertyName = "Corpse Despawn Time Otherwise")]
            public float CorpseDespawnTime { get; set; } = 300f;

            [JsonProperty(PropertyName = "Die Instantly From Headshots")]
            public bool Headshot { get; set; }

            [JsonProperty(PropertyName = "Amount To Spawn (min)")]
            public int SpawnMinAmount { get; set; } = 2;

            [JsonProperty(PropertyName = "Amount To Spawn (max)")]
            public int SpawnAmount { get; set; } = 2;

            [JsonProperty(PropertyName = "Health (100 min, 5000 max)")]
            public float Health { get; set; } = 150f;
        }

        public class NpcSettings
        {
            [JsonProperty(PropertyName = "Blacklisted Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, bool> BlacklistedMonuments { get; set; } = new()
            {
                ["Bandit Camp"] = true,
                ["Barn"] = true,
                ["Fishing Village"] = true,
                ["Junkyard"] = true,
                ["Large Barn"] = true,
                ["Large Fishing Village"] = true,
                ["Outpost"] = true,
                ["Ranch"] = true,
                ["Train Tunnel"] = true,
                ["Underwater Lab"] = true,
            };

            [JsonProperty(PropertyName = "Murderers")]
            public NpcSettingsMurderer Murderers { get; set; } = new();

            [JsonProperty(PropertyName = "Scientists")]
            public NpcSettingsScientist Scientists { get; set; } = new();

            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Npcs To Leave Dome When Attacking")]
            public bool CanLeave { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Npcs To Target Other Npcs")]
            public bool TargetNpcs { get; set; }

            [JsonProperty(PropertyName = "Block Damage From Players Beyond X Distance (0 = disabled)")]
            public float Range { get; set; } = 0f;

            [JsonProperty(PropertyName = "Block Npc Kits Plugin")]
            public bool BlockNpcKits { get; set; }

            [JsonProperty(PropertyName = "Kill Underwater Npcs")]
            public bool KillUnderwater { get; set; } = true;
        }

        public class PasteOption
        {
            [JsonProperty(PropertyName = "Option")]
            public string Key { get; set; }

            [JsonProperty(PropertyName = "Value")]
            public string Value { get; set; }
        }

        public class RankedLadderSettings
        {
            [JsonProperty(PropertyName = "Award Top X Players On Wipe")]
            public int Amount { get; set; } = 3;

            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; } = true;

            [JsonProperty(PropertyName = "Group Name")]
            public string Group { get; set; } = "treasurehunter";

            [JsonProperty(PropertyName = "Permission Name")]
            public string Permission { get; set; } = "dangeroustreasures.th";
        }

        public class RewardSettings
        {
            [JsonProperty(PropertyName = "Economics Money")]
            public double Money { get; set; } = 0;

            [JsonProperty(PropertyName = "ServerRewards Points")]
            public double Points { get; set; } = 0;

            [JsonProperty(PropertyName = "Use Economics")]
            public bool Economics { get; set; } = false;

            [JsonProperty(PropertyName = "Use ServerRewards")]
            public bool ServerRewards { get; set; } = false;
        }

        public class RocketOpenerSettings
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; } = true;

            [JsonProperty(PropertyName = "Rockets")]
            public int Amount { get; set; } = 8;

            [JsonProperty(PropertyName = "Speed")]
            public float Speed { get; set; } = 5f;

            [JsonProperty(PropertyName = "Use Fire Rockets")]
            public bool FireRockets { get; set; } = false;
        }

        public class SkinSettings
        {
            [JsonProperty(PropertyName = "Custom Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> Custom { get; set; } = new();

            [JsonProperty(PropertyName = "Use Random Skin")]
            public bool RandomSkins { get; set; } = true;

            [JsonProperty(PropertyName = "Preset Skin")]
            public ulong PresetSkin { get; set; } = 0;

            [JsonProperty(PropertyName = "Include Workshop Skins")]
            public bool RandomWorkshopSkins { get; set; } = true;

            [JsonProperty(PropertyName = "Randomize Npc Item Skins")]
            public bool Npcs { get; set; } = true;

            [JsonProperty(PropertyName = "Use Identical Skins For All Npcs")]
            public bool UniqueNpcs { get; set; } = true;
        }

        public class LootItem
        {
            public string shortname { get; set; } = "";
            public string name { get; set; } = "";
            public int amount { get; set; }
            public ulong skin { get; set; }
            public int amountMin { get; set; }
            public float condition { get; set; } = 1f;
            public float probability { get; set; } = 1f;
            [JsonProperty(PropertyName = "Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> skins { get; set; } = new();
        }

        public class TreasureSettings
        {
            [JsonProperty(PropertyName = "Loot", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<LootItem> Loot { get; set; } = DefaultLoot;

            [JsonProperty(PropertyName = "Minimum Percent Loss")]
            public decimal PercentLoss { get; set; } = 0;

            [JsonProperty(PropertyName = "Percent Increase When Using Day Of Week Loot")]
            public bool Increased { get; set; } = false;

            [JsonProperty(PropertyName = "Use Random Skins")]
            public bool RandomSkins { get; set; } = false;

            [JsonProperty(PropertyName = "Include Workshop Skins")]
            public bool RandomWorkshopSkins { get; set; } = false;

            [JsonProperty(PropertyName = "Day Of Week Loot Monday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<LootItem> DOWL_Monday { get; set; } = new();

            [JsonProperty(PropertyName = "Day Of Week Loot Tuesday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<LootItem> DOWL_Tuesday { get; set; } = new();

            [JsonProperty(PropertyName = "Day Of Week Loot Wednesday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<LootItem> DOWL_Wednesday { get; set; } = new();

            [JsonProperty(PropertyName = "Day Of Week Loot Thursday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<LootItem> DOWL_Thursday { get; set; } = new();

            [JsonProperty(PropertyName = "Day Of Week Loot Friday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<LootItem> DOWL_Friday { get; set; } = new();

            [JsonProperty(PropertyName = "Day Of Week Loot Saturday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<LootItem> DOWL_Saturday { get; set; } = new();

            [JsonProperty(PropertyName = "Day Of Week Loot Sunday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<LootItem> DOWL_Sunday { get; set; } = new();

            [JsonProperty(PropertyName = "Use Day Of Week Loot")]
            public bool UseDOWL { get; set; } = false;

            [JsonProperty(PropertyName = "Percent Increase On Monday")]
            public decimal PercentIncreaseOnMonday { get; set; } = 0;

            [JsonProperty(PropertyName = "Percent Increase On Tuesday")]
            public decimal PercentIncreaseOnTuesday { get; set; } = 0;

            [JsonProperty(PropertyName = "Percent Increase On Wednesday")]
            public decimal PercentIncreaseOnWednesday { get; set; } = 0;

            [JsonProperty(PropertyName = "Percent Increase On Thursday")]
            public decimal PercentIncreaseOnThursday { get; set; } = 0;

            [JsonProperty(PropertyName = "Percent Increase On Friday")]
            public decimal PercentIncreaseOnFriday { get; set; } = 0;

            [JsonProperty(PropertyName = "Percent Increase On Saturday")]
            public decimal PercentIncreaseOnSaturday { get; set; } = 0;

            [JsonProperty(PropertyName = "Percent Increase On Sunday")]
            public decimal PercentIncreaseOnSunday { get; set; } = 0;
        }

        public class TruePVESettings
        {
            [JsonProperty(PropertyName = "Allow Building Damage At Events")]
            public bool AllowBuildingDamageAtEvents { get; set; } = false;

            [JsonProperty(PropertyName = "Allow PVP At Events")]
            public bool AllowPVPAtEvents { get; set; } = true;

            [JsonProperty(PropertyName = "Allow PVP Server-Wide During Events")]
            public bool ServerWidePVP { get; set; } = false;
        }

        public class UnlockSettings
        {
            [JsonProperty(PropertyName = "Min Seconds")]
            public float MinTime { get; set; } = 300f;

            [JsonProperty(PropertyName = "Max Seconds")]
            public float MaxTime { get; set; } = 480f;

            [JsonProperty(PropertyName = "Unlock When Npcs Die")]
            public bool WhenNpcsDie { get; set; } = false;

            [JsonProperty(PropertyName = "Require All Npcs Die Before Unlocking")]
            public bool RequireAllNpcsDie { get; set; } = false;

            [JsonProperty(PropertyName = "Lock Event To Player On Npc Death")]
            public bool LockToPlayerOnNpcDeath { get; set; } = false;

            [JsonProperty(PropertyName = "Lock Event To Player On First Entered")]
            public bool LockToPlayerFirstEntered { get; set; } = false;
        }

        public class UnlootedAnnouncementSettings
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; } = false;

            [JsonProperty(PropertyName = "Notify Every X Minutes (Minimum 1)")]
            public float Interval { get; set; } = 3f;
        }

        public class Configuration
        {
            [JsonProperty(PropertyName = "Settings")]
            public PluginSettings Settings = new();

            [JsonProperty(PropertyName = "Countdown")]
            public CountdownSettings Countdown = new();

            [JsonProperty(PropertyName = "Events")]
            public EventSettings Event = new();

            [JsonProperty(PropertyName = "Event Messages")]
            public EventMessageSettings EventMessages = new();

            [JsonProperty(PropertyName = "Fireballs")]
            public FireballSettings Fireballs = new();

            [JsonProperty(PropertyName = "GUIAnnouncements")]
            public GUIAnnouncementSettings GUIAnnouncement = new();

            [JsonProperty(PropertyName = "Monuments")]
            public MonumentSettings Monuments = new();

            [JsonProperty(PropertyName = "Newman Mode")]
            public NewmanModeSettings NewmanMode = new();

            [JsonProperty(PropertyName = "NPCs")]
            public NpcSettings NPC = new();

            [JsonProperty(PropertyName = "Missile Launcher")]
            public MissileLauncherSettings MissileLauncher = new();

            [JsonProperty(PropertyName = "Ranked Ladder")]
            public RankedLadderSettings RankedLadder = new();

            [JsonProperty(PropertyName = "Rewards")]
            public RewardSettings Rewards = new();

            [JsonProperty(PropertyName = "Rocket Opener")]
            public RocketOpenerSettings Rocket = new();

            [JsonProperty(PropertyName = "Skins")]
            public SkinSettings Skins = new();

            [JsonProperty(PropertyName = "Treasure")]
            public TreasureSettings Treasure = new();

            [JsonProperty(PropertyName = "TruePVE")]
            public TruePVESettings TruePVE = new();

            [JsonProperty(PropertyName = "Unlock Time")]
            public UnlockSettings Unlock = new();

            [JsonProperty(PropertyName = "Unlooted Announcements")]
            public UnlootedAnnouncementSettings UnlootedAnnouncements = new();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            canSaveConfig = false;
            try
            {
                config = Config.ReadObject<Configuration>();
                config ??= new();
                ValidateConfig();
                canSaveConfig = true;
                SaveConfig();
            }
            catch (Exception ex)
            {
                Puts(ex.ToString());
                LoadDefaultConfig();
            }
        }

        private void ValidateConfig()
        {
            if (config.Rocket.Speed > 0.1f) config.Rocket.Speed = 0.1f;
            if (config.Treasure.PercentLoss > 0) config.Treasure.PercentLoss /= 100m;
            if (config.Monuments.Chance < 0) config.Monuments.Chance = 0f;
            if (config.Monuments.Chance > 1f) config.Monuments.Chance /= 100f;
            if (config.Event.Radius < 10f) config.Event.Radius = 10f;
            if (config.Event.Radius > 150f) config.Event.Radius = 150f;
            if (config.MissileLauncher.Distance < 1f) config.MissileLauncher.Distance = 15f;
            if (config.MissileLauncher.Distance > config.Event.Radius * 15) config.MissileLauncher.Distance = config.Event.Radius * 2;

            if (config.NPC.Murderers.Accuracy.GLOCK == 0f)
            {
                config.NPC.Murderers.Accuracy.AK47ICE = config.NPC.Murderers.Accuracy.GLOCK = config.NPC.Murderers.Accuracy.HMLMG = 100f;
            }

            if (config.NPC.Scientists.Accuracy.GLOCK == 0f)
            {
                config.NPC.Scientists.Accuracy.AK47ICE = config.NPC.Scientists.Accuracy.GLOCK = config.NPC.Scientists.Accuracy.HMLMG = 20f;
            }

            if (!string.IsNullOrEmpty(config.Settings.PermName) && !permission.PermissionExists(config.Settings.PermName)) permission.RegisterPermission(config.Settings.PermName, this);
            if (!string.IsNullOrEmpty(config.Settings.EventChatCommand)) cmd.AddChatCommand(config.Settings.EventChatCommand, this, cmdDangerousTreasures);
            if (!string.IsNullOrEmpty(config.Settings.DistanceChatCommand)) cmd.AddChatCommand(config.Settings.DistanceChatCommand, this, cmdTreasureHunter);
            if (!string.IsNullOrEmpty(config.Settings.EventConsoleCommand)) cmd.AddConsoleCommand(config.Settings.EventConsoleCommand, this, nameof(ccmdDangerousTreasures));
            if (string.IsNullOrEmpty(config.RankedLadder.Permission)) config.RankedLadder.Permission = "dangeroustreasures.th";
            if (string.IsNullOrEmpty(config.RankedLadder.Group)) config.RankedLadder.Group = "treasurehunter";

            if (!string.IsNullOrEmpty(config.RankedLadder.Permission))
            {
                if (!permission.PermissionExists(config.RankedLadder.Permission))
                    permission.RegisterPermission(config.RankedLadder.Permission, this);

                if (!string.IsNullOrEmpty(config.RankedLadder.Group))
                {
                    permission.CreateGroup(config.RankedLadder.Group, config.RankedLadder.Group, 0);
                    permission.GrantGroupPermission(config.RankedLadder.Group, config.RankedLadder.Permission, this);
                }
            }

            permission.RegisterPermission("dangeroustreasures.notitle", this);

            if (config.UnlootedAnnouncements.Interval < 1f) config.UnlootedAnnouncements.Interval = 1f;
            if (config.Event.AutoDrawDistance < 0f) config.Event.AutoDrawDistance = 0f;
            if (config.Event.AutoDrawDistance > ConVar.Server.worldsize) config.Event.AutoDrawDistance = ConVar.Server.worldsize;
            if (config.GUIAnnouncement.TintColor.ToLower() == "black") config.GUIAnnouncement.TintColor = "grey";
            if (config.NPC.Murderers.SpawnAmount + config.NPC.Scientists.SpawnAmount < 1) config.NPC.Enabled = false;
            if (config.NPC.Murderers.SpawnAmount > 25) config.NPC.Murderers.SpawnAmount = 25;
            if (config.NPC.Scientists.SpawnAmount > 25) config.NPC.Scientists.SpawnAmount = 25;
        }

        List<LootItem> ChestLoot
        {
            get
            {
                if (config.Treasure.UseDOWL)
                {
                    switch (DateTime.Now.DayOfWeek)
                    {
                        case DayOfWeek.Monday: return config.Treasure.DOWL_Monday;
                        case DayOfWeek.Tuesday: return config.Treasure.DOWL_Tuesday;
                        case DayOfWeek.Wednesday: return config.Treasure.DOWL_Wednesday;
                        case DayOfWeek.Thursday: return config.Treasure.DOWL_Thursday;
                        case DayOfWeek.Friday: return config.Treasure.DOWL_Friday;
                        case DayOfWeek.Saturday: return config.Treasure.DOWL_Saturday;
                        case DayOfWeek.Sunday: return config.Treasure.DOWL_Sunday;
                    }
                }

                return config.Treasure.Loot;
            }
        }

        private bool canSaveConfig = true;

        protected override void SaveConfig()
        {
            if (canSaveConfig)
            {
                Config.WriteObject(config);
            }
        }

        protected override void LoadDefaultConfig() => config = new();

        #endregion
    }
}

namespace Oxide.Plugins.DangerousTreasuresExtensionMethods
{
    public static class ExtensionMethods
    {
        internal static Core.Libraries.Permission p;
        public static bool All<T>(this IEnumerable<T> a, Func<T, bool> b) { foreach (T c in a) { if (!b(c)) { return false; } } return true; }
        public static T ElementAt<T>(this IEnumerable<T> a, int b) { using (var c = a.GetEnumerator()) { while (c.MoveNext()) { if (b == 0) { return c.Current; } b--; } } return default(T); }
        public static bool Exists<T>(this IEnumerable<T> a, Func<T, bool> b = null) { using (var c = a.GetEnumerator()) { while (c.MoveNext()) { if (b == null || b(c.Current)) { return true; } } } return false; }
        public static T FirstOrDefault<T>(this IEnumerable<T> a, Func<T, bool> b = null) { using (var c = a.GetEnumerator()) { while (c.MoveNext()) { if (b == null || b(c.Current)) { return c.Current; } } } return default; }
        public static IEnumerable<V> Select<T, V>(this IEnumerable<T> a, Func<T, V> b) { var c = new List<V>(); using (var d = a.GetEnumerator()) { while (d.MoveNext()) { c.Add(b(d.Current)); } } return c; }
        public static string[] Skip(this string[] a, int b) { if (a.Length == 0) { return Array.Empty<string>(); } string[] c = new string[a.Length - b]; int n = 0; for (int i = 0; i < a.Length; i++) { if (i < b) continue; c[n] = a[i]; n++; } return c; }
        public static List<T> Take<T>(this IList<T> a, int b) { var c = new List<T>(); for (int i = 0; i < a.Count; i++) { if (c.Count == b) { break; } c.Add(a[i]); } return c; }
        public static Dictionary<T, V> ToDictionary<S, T, V>(this IEnumerable<S> a, Func<S, T> b, Func<S, V> c) { var d = new Dictionary<T, V>(); using (var e = a.GetEnumerator()) { while (e.MoveNext()) { d[b(e.Current)] = c(e.Current); } } return d; }
        public static List<T> ToList<T>(this IEnumerable<T> a) { var b = new List<T>(); if (a == null) { return b; } using (var c = a.GetEnumerator()) { while (c.MoveNext()) { b.Add(c.Current); } } return b; }
        public static List<T> Where<T>(this IEnumerable<T> a, Func<T, bool> b) { var c = new List<T>(); using (var d = a.GetEnumerator()) { while (d.MoveNext()) { if (b(d.Current)) { c.Add(d.Current); } } } return c; }
        public static List<T> OfType<T>(this IEnumerable<BaseNetworkable> a) where T : BaseEntity { var b = new List<T>(); using (var c = a.GetEnumerator()) { while (c.MoveNext()) { if (c.Current is T) { b.Add(c.Current as T); } } } return b; }
        public static int Sum<T>(this IEnumerable<T> a, Func<T, int> b) { int c = 0; foreach (T d in a) { c = checked(c + b(d)); } return c; }
        public static bool UserHasGroup(this string a, string b) { if (string.IsNullOrEmpty(a)) return false; if (p == null) { p = Interface.Oxide.GetLibrary<Core.Libraries.Permission>(null); } return p.UserHasGroup(a, b); }
        public static bool UserHasGroup(this IPlayer a, string b) { return !(a == null) && a.Id.UserHasGroup(b); }
        public static bool IsReallyConnected(this BasePlayer a) { return a.IsReallyValid() && a.net.connection != null; }
        public static bool IsKilled(this BaseNetworkable a) => a == null || a.IsDestroyed || !a.IsFullySpawned();
        public static bool IsNull<T>(this T a) where T : class { return a == null; }
        public static bool IsNull(this BasePlayer a) => a == null || a.IsDestroyed;
        public static bool IsReallyValid(this BaseNetworkable a) { return !(a == null || a.IsDestroyed || !a.IsFullySpawned() || a.net == null); }
        public static void SafelyKill(this BaseNetworkable a) { if (a.IsKilled()) { return; } a.Kill(BaseNetworkable.DestroyMode.None); }
        public static bool CanCall(this Plugin o) { return o != null && o.IsLoaded; }
        public static bool IsHuman(this BasePlayer a) { return !(a.IsNpc || !a.userID.IsSteamId()); }
        public static float Distance(this Vector3 a, Vector3 b) => (a - b).magnitude;
        public static void ResetToPool<K, V>(this Dictionary<K, V> obj) { if (obj == null) return; obj.Clear(); Pool.FreeUnmanaged(ref obj); }
        public static void ResetToPool<T>(this List<T> obj) { if (obj == null) return; obj.Clear(); Pool.FreeUnmanaged(ref obj); }
    }
}


// --- End of file: DangerousTreasures.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/dynamic-pvp ---
// --- Original File Path: D/DynamicPVP/DynamicPVP.cs ---

ï»¿//Requires: ZoneManager

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;
using IEnumerator = System.Collections.IEnumerator;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
  [Info("Dynamic PVP", "HunterZ/CatMeat/Arainrr", "4.5.0", ResourceId = 2728)]
  [Description("Creates temporary PvP zones on certain actions/events")]
  public class DynamicPVP : RustPlugin
  {
    #region Fields

    [PluginReference]
    private readonly Plugin BotReSpawn, TruePVE, ZoneManager;

    private const string PermissionAdmin = "dynamicpvp.admin";
    private const string PrefabLargeOilRig =
      "assets/bundled/prefabs/autospawn/monument/offshore/oilrig_1.prefab";
    private const string PrefabOilRig =
      "assets/bundled/prefabs/autospawn/monument/offshore/oilrig_2.prefab";
    private const string PrefabSphere =
      "assets/prefabs/visualization/sphere.prefab";
    private const string ZoneName = "DynamicPVP";

    private readonly Dictionary<string, Timer> _eventTimers = new();
    private readonly Dictionary<ulong, LeftZone> _pvpDelays = new();
    //ID -> EventName
    private readonly Dictionary<string, string> _activeDynamicZones = new();

    private bool _dataChanged;
    private Vector3 _oilRigPosition = Vector3.zero;
    private Vector3 _largeOilRigPosition = Vector3.zero;
    private Coroutine _createEventsCoroutine;
    private bool _useExcludePlayer;
    private bool _subscribedCommands;
    private bool _subscribedDamage;
    private bool _subscribedZones;

    public static DynamicPVP Instance { get; private set; }

    private sealed class LeftZone : Pool.IPooled
    {
      public string zoneId;
      public string eventName;
      public Timer zoneTimer;

      public void EnterPool()
      {
        zoneId = null;
        eventName = null;
        zoneTimer?.Destroy();
        zoneTimer = null;
      }

      public void LeavePool()
      {
      }
    }

    [Flags]
    [JsonConverter(typeof(StringEnumConverter))]
    private enum PvpDelayTypes
    {
      None = 0,
      ZonePlayersCanDamageDelayedPlayers = 1,
      DelayedPlayersCanDamageZonePlayers = 1 << 1,
      DelayedPlayersCanDamageDelayedPlayers = 1 << 2
    }

    private enum GeneralEventType
    {
      Bradley,
      Helicopter,
      SupplyDrop,
      SupplySignal,
      CargoShip,
      HackableCrate,
      ExcavatorIgnition
    }

    [Flags]
    private enum HookCheckReasons
    {
      None         = 0,
      DelayAdded   = 1 << 0,
      DelayRemoved = 1 << 1,
      ZoneAdded    = 1 << 2,
      ZoneRemoved  = 1 << 3
    }

    #endregion Fields

    #region Oxide Hooks

    private void Init()
    {
      Instance = this;
      LoadData();
      permission.RegisterPermission(PermissionAdmin, this);
      AddCovalenceCommand(configData.Chat.Command, nameof(CmdDynamicPVP));
      Unsubscribe(nameof(CanEntityTakeDamage));
      Unsubscribe(nameof(OnCargoPlaneSignaled));
      Unsubscribe(nameof(OnCargoShipEgress));
      Unsubscribe(nameof(OnCargoShipHarborApproach));
      Unsubscribe(nameof(OnCargoShipHarborArrived));
      Unsubscribe(nameof(OnCargoShipHarborLeave));
      Unsubscribe(nameof(OnCrateHack));
      Unsubscribe(nameof(OnCrateHackEnd));
      Unsubscribe(nameof(OnDieselEngineToggled));
      Unsubscribe(nameof(OnEnterZone));
      Unsubscribe(nameof(OnEntityDeath));
      Unsubscribe(nameof(OnEntityKill));
      Unsubscribe(nameof(OnEntitySpawned));
      Unsubscribe(nameof(OnExitZone));
      Unsubscribe(nameof(OnLootEntity));
      Unsubscribe(nameof(OnPlayerCommand));
      Unsubscribe(nameof(OnServerCommand));
      Unsubscribe(nameof(OnSupplyDropLanded));
      if (configData.Global.LogToFile)
      {
        _debugStringBuilder = Pool.Get<StringBuilder>();
      }
      // setup new TruePVE "ExcludePlayer" support
      _useExcludePlayer = configData.Global.UseExcludePlayer;
      // if ExcludePlayer is disabled in config but is supported...
      if (!_useExcludePlayer &&
          null != TruePVE &&
          TruePVE.Version >= new VersionNumber(2, 2, 3))
      {
        // ...and all PVP delays are enabled, auto-enable internally and warn
        if ((PvpDelayTypes.ZonePlayersCanDamageDelayedPlayers |
             PvpDelayTypes.DelayedPlayersCanDamageZonePlayers |
             PvpDelayTypes.DelayedPlayersCanDamageDelayedPlayers) ==
            configData.Global.PvpDelayFlags)
        {
          _useExcludePlayer = true;
          Puts("All PVP delay flags active and TruePVE 2.2.3+ detected, so TruePVE PVP delays will be used for performance and cross-plugin support; please consider enabling TruePVE PVP Delay API in the config file to skip this check");
        }
        // else just nag, since settings are not compatible
        else
        {
          Puts("Some/all PVP delay flags NOT active, but TruePVE 2.2.3+ detected; please consider switching to TruePVE PVP Delay API in the config file for performance and cross-plugin support");
        }
      } // else ExcludePlayer is already enabled, or TruePVE 2.2.3+ not running
      _subscribedCommands = _subscribedDamage = _subscribedZones = false;
    }

    private void OnServerInitialized()
    {
      DeleteOldDynamicZones();
      if (configData.GeneralEvents.ExcavatorIgnition.Enabled)
      {
        Subscribe(nameof(OnDieselEngineToggled));
      }
      if (configData.GeneralEvents.PatrolHelicopter.Enabled ||
          configData.GeneralEvents.BradleyApc.Enabled)
      {
        Subscribe(nameof(OnEntityDeath));
      }
      if (configData.GeneralEvents.SupplySignal.Enabled ||
          configData.GeneralEvents.TimedSupply.Enabled)
      {
        Subscribe(nameof(OnCargoPlaneSignaled));
        // this is now subscribed regardless of start on spawn-vs-landing, as we
        //  need to tether the zone to the drop on landing in both cases
        Subscribe(nameof(OnSupplyDropLanded));
      }
      if (configData.GeneralEvents.HackableCrate.Enabled &&
          configData.GeneralEvents.HackableCrate.TimerStartWhenUnlocked)
      {
        Subscribe(nameof(OnCrateHackEnd));
      }
      if ((configData.GeneralEvents.TimedSupply.Enabled &&
           configData.GeneralEvents.TimedSupply.TimerStartWhenLooted) ||
          (configData.GeneralEvents.SupplySignal.Enabled &&
           configData.GeneralEvents.SupplySignal.TimerStartWhenLooted) ||
          (configData.GeneralEvents.HackableCrate.Enabled &&
           configData.GeneralEvents.HackableCrate.TimerStartWhenLooted))
      {
        Subscribe(nameof(OnLootEntity));
      }
      if (configData.GeneralEvents.HackableCrate.Enabled &&
          !configData.GeneralEvents.HackableCrate.StartWhenSpawned)
      {
        Subscribe(nameof(OnCrateHack));
      }
      if ((configData.GeneralEvents.TimedSupply.Enabled &&
           configData.GeneralEvents.TimedSupply.StartWhenSpawned) ||
          (configData.GeneralEvents.SupplySignal.Enabled &&
           configData.GeneralEvents.SupplySignal.StartWhenSpawned) ||
          (configData.GeneralEvents.HackableCrate.Enabled &&
           configData.GeneralEvents.HackableCrate.StartWhenSpawned))
      {
        Subscribe(nameof(OnEntitySpawned));
      }
      if ((configData.GeneralEvents.TimedSupply.Enabled &&
           configData.GeneralEvents.TimedSupply.StopWhenKilled) ||
          (configData.GeneralEvents.SupplySignal.Enabled &&
           configData.GeneralEvents.SupplySignal.StopWhenKilled) ||
          (configData.GeneralEvents.HackableCrate.Enabled &&
           configData.GeneralEvents.HackableCrate.StopWhenKilled))
      {
        Subscribe(nameof(OnEntityKill));
      }
      if (configData.GeneralEvents.CargoShip.Enabled)
      {
        Subscribe(nameof(OnCargoShipEgress));
        Subscribe(nameof(OnCargoShipHarborApproach));
        Subscribe(nameof(OnCargoShipHarborArrived));
        Subscribe(nameof(OnCargoShipHarborLeave));
        Subscribe(nameof(OnEntityKill));
        Subscribe(nameof(OnEntitySpawned));
      }
      _createEventsCoroutine =
        ServerMgr.Instance.StartCoroutine(CreateEvents());
    }

    private void Unload()
    {
      if (_createEventsCoroutine != null)
      {
        ServerMgr.Instance.StopCoroutine(_createEventsCoroutine);
      }

      if (_activeDynamicZones.Count > 0)
      {
        PrintDebug($"Deleting {_activeDynamicZones.Count} active zones");
        foreach (var entry in _activeDynamicZones.ToArray())
        {
          DeleteDynamicZone(entry.Key);
        }
      }

      var leftZones = _pvpDelays.Values.ToArray();
      for (var i = leftZones.Length - 1; i >= 0; i--)
      {
        var value = leftZones[i];
        Pool.Free(ref value);
      }

      var spheres = _zoneSpheres.Values.ToArray();
      for (var i = spheres.Length - 1; i >= 0; i--)
      {
        var sphereEntities = spheres[i];
        foreach (var sphereEntity in sphereEntities)
        {
          if (sphereEntity && !sphereEntity.IsDestroyed)
          {
            sphereEntity.KillMessage();
          }
        }
        Pool.FreeUnmanaged(ref sphereEntities);
      }

      SaveData();
      SaveDebug();
      Pool.Directory.TryRemove(typeof(LeftZone), out _);
      Instance = null;

      if (null == _debugStringBuilder) return;
      Pool.FreeUnmanaged(ref _debugStringBuilder);
      _debugStringBuilder = null;
    }

    private void OnServerSave() => timer.Once(Random.Range(0f, 60f), () =>
    {
      SaveDebug();
      if (!_dataChanged) return;
      SaveData();
      _dataChanged = false;
    });

    private void OnPlayerRespawned(BasePlayer player)
    {
      if (!player || !player.userID.IsSteamId())
      {
        PrintDebug("OnPlayerRespawned(): Ignoring respawn of null/NPC player");
        return;
      }
      TryRemovePVPDelay(player);
    }

    #endregion Oxide Hooks

    #region Methods

    private void TryRemoveEventTimer(string zoneId)
    {
      if (_eventTimers.Remove(zoneId, out var value))
      {
        value?.Destroy();
      }
    }

    private LeftZone GetOrAddPVPDelay(
      BasePlayer player, string zoneId, string eventName)
    {
      PrintDebug($"Adding {player.displayName} to pvp delay");
      var added = false;
      if (_pvpDelays.TryGetValue(player.userID, out var leftZone))
      {
        leftZone.zoneTimer?.Destroy();
      }
      else
      {
        added = true;
        leftZone = Pool.Get<LeftZone>();
        _pvpDelays.Add(player.userID, leftZone);
      }
      leftZone.zoneId = zoneId;
      leftZone.eventName = eventName;
      if (added)
      {
        CheckHooks(HookCheckReasons.DelayAdded);
      }
      return leftZone;
    }

    private bool TryRemovePVPDelay(BasePlayer player)
    {
      PrintDebug($"Removing {player.displayName} from pvp delay");
      var playerId = player.userID.Get();
      if (!_pvpDelays.Remove(playerId, out var leftZone)) return false;
      Interface.CallHook("OnPlayerRemovedFromPVPDelay",
        playerId, leftZone.zoneId, player);
      Pool.Free(ref leftZone);
      CheckHooks(HookCheckReasons.DelayRemoved);
      return true;
    }

    private bool CheckEntityOwner(BaseEntity baseEntity)
    {
      if (!configData.Global.CheckEntityOwner ||
          !baseEntity.OwnerID.IsSteamId() ||
          // HeliSignals and BradleyDrops exception
          baseEntity.skinID != 0)
      {
        return true;
      }
      PrintDebug($"Skipping event creation because baseEntity={baseEntity} is owned by player={baseEntity.OwnerID}");
      return false;
    }

    private bool CanCreateDynamicPVP(string eventName, BaseEntity entity)
    {
      if (Interface.CallHook("OnCreateDynamicPVP", eventName, entity) == null)
      {
        return true;
      }
      PrintDebug($"Skipping event creation for eventName={eventName} due to OnCreateDynamicPVP hook result");
      return false;
    }

    private bool HasCommands()
    {
      // track which events we've checked, to avoid redundant calls to
      //  GetBaseEvent(); note that use of pool API means we need to free this
      //  on every return
      var checkedEvents = Pool.Get<HashSet<string>>();
      // check for command-containing zones referenced by PVP delays, which
      //  either work when PVP delayed, or are an active zone
      // HZ: I guess this is really trying to catch the corner case of players
      //  in PVP delay because a zone expired?
      foreach (var leftZone in _pvpDelays.Values)
      {
        var baseEvent = GetBaseEvent(leftZone.eventName);
        if (baseEvent == null || baseEvent.CommandList.Count <= 0)
        {
          continue;
        }
        if (baseEvent.CommandWorksForPVPDelay ||
            _activeDynamicZones.ContainsValue(leftZone.eventName))
        {
          Pool.FreeUnmanaged(ref checkedEvents);
          return true;
        }
        checkedEvents.Add(leftZone.eventName);
      }
      foreach (var eventName in _activeDynamicZones.Values)
      {
        // optimization: skip if we've already checked this in the other loop
        if (checkedEvents.Contains(eventName))
        {
          continue;
        }
        var baseEvent = GetBaseEvent(eventName);
        if (null == baseEvent || baseEvent.CommandList.Count <= 0) continue;
        Pool.FreeUnmanaged(ref checkedEvents);
        return true;
      }
      Pool.FreeUnmanaged(ref checkedEvents);
      return false;
    }

    private void CheckCommandHooks(bool added)
    {
      // optimization: abort if adding a delayzone and already subscribed, or if
      //  removing a delay/zone and already unsubscribed
      if (added == _subscribedCommands)
      {
        return;
      }
      // also return if subscription status already matches command status
      if (HasCommands() == _subscribedCommands)
      {
        return;
      }
      // subscription status needs to change, so toggle things
      if (_subscribedCommands)
      {
        Unsubscribe(nameof(OnPlayerCommand));
        Unsubscribe(nameof(OnServerCommand));
      }
      else
      {
        Subscribe(nameof(OnPlayerCommand));
        Subscribe(nameof(OnServerCommand));
      }
      _subscribedCommands = !_subscribedCommands;
    }

    private void CheckPvpDelayHooks(bool added)
    {
      // optimization: abort if using TruePVE's ExcludePlayer API
      if (_useExcludePlayer)
      {
        // ...ensure we're unsubscribed from damage hook, just in case
        if (!_subscribedDamage) return;
        Unsubscribe(nameof(CanEntityTakeDamage));
        _subscribedDamage = false;
        return;
      }
      // optimization: abort if adding a delay and already subscribed, or if
      //  removing a delay and already unsubscribed
      if (added == _subscribedDamage)
      {
        return;
      }
      // also return if subscription status already matches delay status
      if (_pvpDelays.Count > 0 == _subscribedDamage)
      {
        return;
      }
      // subscription status needs to change, so toggle things
      if (_subscribedDamage)
      {
        Unsubscribe(nameof(CanEntityTakeDamage));
      }
      else
      {
        Subscribe(nameof(CanEntityTakeDamage));
      }
      _subscribedDamage = !_subscribedDamage;
    }

    private void CheckZoneHooks(bool added)
    {
      // optimization: abort if adding a zone and already subscribed, or if
      //  removing a zone and already unsubscribed
      if (added == _subscribedZones)
      {
        return;
      }
      // also return if subscription status already matches zone status
      if (_activeDynamicZones.Count > 0 == _subscribedZones)
      {
        return;
      }
      // subscription status needs to change, so toggle things
      if (_subscribedZones)
      {
        Unsubscribe(nameof(OnEnterZone));
        Unsubscribe(nameof(OnExitZone));
      }
      else
      {
        Subscribe(nameof(OnEnterZone));
        Subscribe(nameof(OnExitZone));
      }
      _subscribedZones = !_subscribedZones;
    }

    private void CheckHooks(HookCheckReasons reasons)
    {
      if (reasons.HasFlag(HookCheckReasons.DelayAdded))
      {
        CheckPvpDelayHooks(true);
      }
      else if (reasons.HasFlag(HookCheckReasons.DelayRemoved))
      {
        CheckPvpDelayHooks(false);
      }

      if (reasons.HasFlag(HookCheckReasons.ZoneAdded))
      {
        CheckZoneHooks(true);
      }
      else if (reasons.HasFlag(HookCheckReasons.ZoneRemoved))
      {
        CheckZoneHooks(false);
      }

      if (reasons.HasFlag(HookCheckReasons.DelayAdded) ||
          reasons.HasFlag(HookCheckReasons.ZoneAdded))
      {
        CheckCommandHooks(true);
      }
      else if (reasons.HasFlag(HookCheckReasons.DelayRemoved) ||
               reasons.HasFlag(HookCheckReasons.ZoneRemoved))
      {
        CheckCommandHooks(false);
      }
    }

    private BaseEvent GetBaseEvent(string eventName)
    {
      if (string.IsNullOrEmpty(eventName))
      {
        throw new ArgumentNullException(nameof(eventName));
      }
      if (Interface.CallHook("OnGetBaseEvent", eventName)
          is BaseEvent externalEvent)
      {
        return externalEvent;
      }
      if (Enum.IsDefined(typeof(GeneralEventType), eventName) &&
          Enum.TryParse(eventName, true, out GeneralEventType generalEventType))
      {
        switch (generalEventType)
        {
          case GeneralEventType.Bradley:
            return configData.GeneralEvents.BradleyApc;
          case GeneralEventType.HackableCrate:
            return configData.GeneralEvents.HackableCrate;
          case GeneralEventType.Helicopter:
            return configData.GeneralEvents.PatrolHelicopter;
          case GeneralEventType.SupplyDrop:
            return configData.GeneralEvents.TimedSupply;
          case GeneralEventType.SupplySignal:
            return configData.GeneralEvents.SupplySignal;
          case GeneralEventType.ExcavatorIgnition:
            return configData.GeneralEvents.ExcavatorIgnition;
          case GeneralEventType.CargoShip:
            return configData.GeneralEvents.CargoShip;
          default:
            PrintDebug($"ERROR: Missing BaseEvent lookup for generalEventType={generalEventType} for eventName={eventName}.", DebugLevel.Error);
            return null;
        }
      }
      if (storedData.autoEvents.TryGetValue(eventName, out var autoEvent))
      {
        return autoEvent;
      }
      if (storedData.timedEvents.TryGetValue(eventName, out var timedEvent))
      {
        return timedEvent;
      }
      if (configData.MonumentEvents.TryGetValue(
            eventName, out var monumentEvent))
      {
        return monumentEvent;
      }
      PrintDebug($"ERROR: Failed to get base event settings for {eventName}", DebugLevel.Error);
      return null;
    }

    #endregion Methods

    #region Events

    #region Startup

    // coroutine to orchestrate creation of all relevant events on startup
    private IEnumerator CreateEvents()
    {
      yield return CreateGeneralEvents();
      yield return CreateMonumentEvents();
      yield return CreateAutoEvents();
      _createEventsCoroutine = null;
    }

    #endregion Startup

    #region General Event

    // coroutine to determine whether any General Events should be created based
    //  on currently existing entities of interest
    // this is expected to only be called on startup
    private IEnumerator CreateGeneralEvents()
    {
      // determine up-front whether there are any general events to create,
      //  because iterating over all net entities is not cheap
      var checkGeneralEvents = false;
      // TODO: Bradley, Patrol Helicopter, Supply Drop, Timed Supply
      checkGeneralEvents |= configData.GeneralEvents.CargoShip.Enabled;
      // NOTE: StopWhenKilled is checked because we don't want to start events
      //  whose end is determined by a timer, as we don't know elapsed times
      checkGeneralEvents |=
        configData.GeneralEvents.HackableCrate.Enabled &&
        configData.GeneralEvents.HackableCrate.StopWhenKilled;
      checkGeneralEvents |= configData.GeneralEvents.ExcavatorIgnition.Enabled;
      if (checkGeneralEvents)
      {
        foreach (var serverEntity in BaseNetworkable.serverEntities)
        {
          switch (serverEntity)
          {
            // Cargo Ship Event
            case CargoShip cargoShip:
              StartupCargoShip(cargoShip);
              yield return CoroutineEx.waitForFixedUpdate;
              break;
            // Excavator Ignition Event
            case DieselEngine dieselEngine:
              StartupDieselEngine(dieselEngine);
              yield return CoroutineEx.waitForFixedUpdate;
              break;
            // Hackable Crate Event
            case HackableLockedCrate hackableLockedCrate:
              StartupHackableLockedCrate(hackableLockedCrate);
              yield return CoroutineEx.waitForFixedUpdate;
              break;
          }
        }
      }

      yield return null;
    }

    #region ExcavatorIgnition Event

    // invoke appropriate hook handler for current DieselEngine state
    // this is only used on startup, to (re)create events for already-existing
    //  DieselEngine entities
    private void StartupDieselEngine(DieselEngine dieselEngine)
    {
      if (!dieselEngine)
      {
        PrintDebug("DieselEngine is null");
        return;
      }
      if (!configData.GeneralEvents.ExcavatorIgnition.Enabled)
      {
        PrintDebug("Excavator Ignition Event is disabled");
        return;
      }
      if (!dieselEngine.IsOn())
      {
        PrintDebug("DieselEngine is off");
        return;
      }
      PrintDebug("Found activated Giant Excavator");
      OnDieselEngineToggled(dieselEngine);
    }

    private void OnDieselEngineToggled(DieselEngine dieselEngine)
    {
      if (!dieselEngine || null == dieselEngine.net)
      {
        PrintDebug("ERROR: OnDieselEngineToggled(): Engine or Net is null", DebugLevel.Error);
        return;
      }
      var zoneId = dieselEngine.net.ID.ToString();
      if (dieselEngine.IsOn())
      {
        PrintDebug($"OnDieselEngineToggled(): Requesting 'just-in-case' delete of zoneId={zoneId} due to excavator enable");
        DeleteDynamicZone(zoneId);
        HandleGeneralEvent(
          GeneralEventType.ExcavatorIgnition, dieselEngine, true);
      }
      else
      {
        PrintDebug($"OnDieselEngineToggled(): Scheduling delete of zoneId={zoneId} due to excavator disable");
        HandleDeleteDynamicZone(zoneId);
      }
    }

    #endregion ExcavatorIgnition Event

    #region HackableLockedCrate Event

    // invoke appropriate hook handler for current HackableLockedCrate state
    // this is only used on startup, to (re)create events for already-existing
    //  HackableLockedCrate entities
    private void StartupHackableLockedCrate(
      HackableLockedCrate hackableLockedCrate)
    {
      if (!hackableLockedCrate)
      {
        PrintDebug("HackableLockedCrate is null");
        return;
      }
      if (!configData.GeneralEvents.HackableCrate.Enabled)
      {
        PrintDebug("Hackable Crate Event is disabled");
        return;
      }
      if (!configData.GeneralEvents.HackableCrate.StopWhenKilled)
      {
        PrintDebug("Hackable Crate Event doesn't stop when killed");
        return;
      }
      if (0 != hackableLockedCrate.FirstLooterId &&
          configData.GeneralEvents.HackableCrate.TimerStartWhenLooted)
      {
        // looted and stop after time since loot enabled
        // we don't know elapsed time, so err on the side of assuming the event
        //  has already ended
        PrintDebug("Found looted hackable locked crate, and TimerStartWhenLooted set; ignoring because elapsed time unknown");
      }
      else if (
        hackableLockedCrate.HasFlag(HackableLockedCrate.Flag_FullyHacked) &&
        configData.GeneralEvents.HackableCrate.TimerStartWhenUnlocked)
      {
        // unlocked and stop after time since unlock enabled
        // we don't know elapsed time, so err on the side of assuming the event
        //  has already ended
        PrintDebug("Found unlocked hackable locked crate and TimerStartWhenUnlocked set; ignoring because elapsed time unknown");
      }
      else if (hackableLockedCrate.HasFlag(HackableLockedCrate.Flag_Hacking) &&
               !configData.GeneralEvents.HackableCrate.StartWhenSpawned)
      {
        // hacking and start on hacking enabled
        PrintDebug("Found hacking hackable locked crate and StartWhenSpawned NOT set; triggering OnCrateHack()");
        OnCrateHack(hackableLockedCrate);
      }
      else if (configData.GeneralEvents.HackableCrate.StartWhenSpawned)
      {
        // any other state and start on spawn + stop when killed enabled
        PrintDebug("Found hackable locked crate, and StartWhenSpawned set; triggering OnEntitySpawned()");
        OnEntitySpawned(hackableLockedCrate);
      }
      else
      {
        PrintDebug("Found hackable locked crate, but ignoring because of either start on hack, or stop on timer with elapsed time unknown");
      }
    }

    private void OnEntitySpawned(HackableLockedCrate hackableLockedCrate)
    {
      if (!hackableLockedCrate || null == hackableLockedCrate.net)
      {
        PrintDebug("ERROR: OnEntitySpawned(HackableLockedCrate): Crate or Net is null", DebugLevel.Error);
        return;
      }

      if (!configData.GeneralEvents.HackableCrate.Enabled ||
          !configData.GeneralEvents.HackableCrate.StartWhenSpawned)
      {
        PrintDebug("OnEntitySpawned(HackableLockedCrate): Ignoring due to event or spawn start disabled");
        return;
      }

      PrintDebug("Trying to create hackable crate spawn event");
      NextTick(() => LockedCrateEvent(hackableLockedCrate));
    }

    private void OnCrateHack(HackableLockedCrate hackableLockedCrate)
    {
      if (!hackableLockedCrate || null == hackableLockedCrate.net)
      {
        PrintDebug("ERROR: OnCrateHack(): Crate or Net is null", DebugLevel.Error);
        return;
      }
      PrintDebug("OnCrateHack(): Trying to create hackable crate hack event");
      NextTick(() => LockedCrateEvent(hackableLockedCrate));
    }

    private void OnCrateHackEnd(HackableLockedCrate hackableLockedCrate)
    {
      if (!hackableLockedCrate || null == hackableLockedCrate.net)
      {
        PrintDebug("ERROR: OnCrateHackEnd(): Crate or Net is null", DebugLevel.Error);
        return;
      }
      var zoneId = hackableLockedCrate.net.ID.ToString();
      PrintDebug($"OnCrateHackEnd(): Scheduling delete of zoneId={zoneId} in {configData.GeneralEvents.HackableCrate.Duration}s");
      HandleDeleteDynamicZone(
        zoneId,
        configData.GeneralEvents.HackableCrate.Duration,
        GeneralEventType.HackableCrate.ToString());
    }

    private void OnLootEntity(BasePlayer player, HackableLockedCrate hackableLockedCrate)
    {
      if (!hackableLockedCrate || null == hackableLockedCrate.net)
      {
        PrintDebug("ERROR: OnLootEntity(HackableLockedCrate): Crate or Net is null", DebugLevel.Error);
        return;
      }
      if (!configData.GeneralEvents.HackableCrate.Enabled ||
          !configData.GeneralEvents.HackableCrate.TimerStartWhenLooted)
      {
        PrintDebug("OnLootEntity(HackableLockedCrate): Ignoring due to event or loot delay disabled");
        return;
      }
      var zoneId = hackableLockedCrate.net.ID.ToString();
      PrintDebug($"OnLootEntity(HackableLockedCrate): Scheduling delete of zoneId={zoneId} in {configData.GeneralEvents.HackableCrate.Duration}s");
      HandleDeleteDynamicZone(
        zoneId,
        configData.GeneralEvents.HackableCrate.Duration,
        GeneralEventType.HackableCrate.ToString());
    }

    private void OnEntityKill(HackableLockedCrate hackableLockedCrate)
    {
      if (!hackableLockedCrate || null == hackableLockedCrate.net)
      {
        PrintDebug("ERROR: OnEntityKill(HackableLockedCrate): Crate or Net is null", DebugLevel.Error);
        return;
      }

      if (!configData.GeneralEvents.HackableCrate.Enabled ||
          !configData.GeneralEvents.HackableCrate.StopWhenKilled)
      {
        PrintDebug("OnEntityKill(HackableLockedCrate): Ignoring due to event or kill stop disabled");
        return;
      }
      var zoneId = hackableLockedCrate.net.ID.ToString();
      //When the timer starts, don't stop the event immediately
      if (_eventTimers.ContainsKey(zoneId))
      {
        PrintDebug($"OnEntityKill(HackableLockedCrate): Ignoring due to event timer already active for zoneId={zoneId}");
        return;
      }
      PrintDebug($"OnEntityKill(HackableLockedCrate): Scheduling delete of zoneId={zoneId}");
      HandleDeleteDynamicZone(zoneId);
    }

    private void LockedCrateEvent(HackableLockedCrate hackableLockedCrate)
    {
      if (!CheckEntityOwner(hackableLockedCrate))
      {
        return;
      }
      if (configData.GeneralEvents.HackableCrate.ExcludeOilRig &&
          IsOnTheOilRig(hackableLockedCrate))
      {
        PrintDebug("The hackable locked crate is on an oil rig. Skipping event creation.");
        return;
      }
      if (configData.GeneralEvents.HackableCrate.ExcludeCargoShip &&
          IsOnTheCargoShip(hackableLockedCrate))
      {
        PrintDebug("The hackable locked crate is on a cargo ship. Skipping event creation.");
        return;
      }
      // call this here, because otherwise it's difficult to ensure that we call
      //  it exactly once
      var eventName = GeneralEventType.HackableCrate.ToString();
      if (!CanCreateDynamicPVP(eventName, hackableLockedCrate))
      {
        return;
      }
      // NOTE: we are already NextTick() protected here
      HandleParentedEntityEvent(
        eventName, hackableLockedCrate, parentOnCreate: true);
    }

    private static bool IsOnTheCargoShip(
      HackableLockedCrate hackableLockedCrate)
    {
      return hackableLockedCrate.GetComponentInParent<CargoShip>();
    }

    private bool IsOnTheOilRig(HackableLockedCrate hackableLockedCrate)
    {
      // this may now get called before monument event creation if hackable
      //  crates exist on startup, so populate oilrig positions here if needed
      if (Vector3.zero == _oilRigPosition ||
          Vector3.zero == _largeOilRigPosition)
      {
        foreach (LandmarkInfo landmarkInfo in TerrainMeta.Path.Landmarks)
        {
          switch (landmarkInfo.name)
          {
            case PrefabLargeOilRig:
              _largeOilRigPosition = landmarkInfo.transform.position;
              break;
            case PrefabOilRig:
              _oilRigPosition = landmarkInfo.transform.position;
              break;
          }
          if (Vector3.zero != _oilRigPosition &&
              Vector3.zero != _largeOilRigPosition)
          {
            break;
          }
        }
      }

      if (_oilRigPosition != Vector3.zero && Vector3Ex.Distance2D(
            hackableLockedCrate.transform.position, _oilRigPosition) < 50f)
      {
        return true;
      }

      if (_largeOilRigPosition != Vector3.zero && Vector3Ex.Distance2D(
            hackableLockedCrate.transform.position, _largeOilRigPosition) < 50f)
      {
        return true;
      }

      return false;
    }

    #endregion HackableLockedCrate Event

    #region PatrolHelicopter And BradleyAPC Event

    private void OnEntityDeath(PatrolHelicopter patrolHelicopter, HitInfo info)
    {
      if (!patrolHelicopter || null == patrolHelicopter.net)
      {
        return;
      }
      PatrolHelicopterEvent(patrolHelicopter);
    }

    private void OnEntityDeath(BradleyAPC bradleyApc, HitInfo info)
    {
      if (!bradleyApc || null == bradleyApc.net)
      {
        return;
      }
      BradleyApcEvent(bradleyApc);
    }

    private void PatrolHelicopterEvent(PatrolHelicopter patrolHelicopter)
    {
      if (!configData.GeneralEvents.PatrolHelicopter.Enabled)
      {
        return;
      }
      PrintDebug("Trying to create Patrol Helicopter killed event.");
      if (!CheckEntityOwner(patrolHelicopter))
      {
        return;
      }
      HandleGeneralEvent(GeneralEventType.Helicopter, patrolHelicopter, false);
    }

    private void BradleyApcEvent(BradleyAPC bradleyAPC)
    {
      if (!configData.GeneralEvents.BradleyApc.Enabled)
      {
        return;
      }
      PrintDebug("Trying to create Bradley APC killed event.");
      if (!CheckEntityOwner(bradleyAPC))
      {
        return;
      }
      HandleGeneralEvent(GeneralEventType.Bradley, bradleyAPC, false);
    }

    #endregion PatrolHelicopter And BradleyAPC Event

    #region SupplyDrop And SupplySignal Event

    // TODO: seems dodgy that Vector3 is being used as a key, because comparing
    //  floats is fraught; consider using network ID or something instead, and
    //  storing the location as data if needed
    private readonly Dictionary<Vector3, Timer> activeSupplySignals = new();

    private void OnCargoPlaneSignaled(
      CargoPlane cargoPlane, SupplySignal supplySignal) => NextTick(() =>
    {
      if (!supplySignal || !cargoPlane)
      {
        return;
      }
      var dropPosition = cargoPlane.dropPosition;
      if (activeSupplySignals.ContainsKey(dropPosition))
      {
        return;
      }
      // TODO: why is this a hard-coded 15-minute delay?
      activeSupplySignals.Add(dropPosition,
        timer.Once(900f, () => activeSupplySignals.Remove(dropPosition)));
      PrintDebug($"A supply signal is thrown at {dropPosition}");
    });

    private void OnEntitySpawned(SupplyDrop supplyDrop) => NextTick(() =>
      OnSupplyDropEvent(supplyDrop, false));

    private void OnSupplyDropLanded(SupplyDrop supplyDrop)
    {
      if (!supplyDrop || null == supplyDrop.net)
      {
        return;
      }
      var zoneId = supplyDrop.net.ID.ToString();
      if (_activeDynamicZones.TryGetValue(zoneId, out var eventName))
      {
        // event was already created on spawn; parent the event to the entity,
        //  so that they move together
        // NOTES:
        // - don't delete on failure, because leaving the existing zone on the
        //    ground is better than deleting it
        // - no need to delay parenting, as the zone presumably has already
        //    existed for a bit
        ParentEventToEntity(
          zoneId, GetBaseEvent(eventName), supplyDrop, deleteOnFailure: false,
          delay: false);
        return;
      }
      NextTick(() => OnSupplyDropEvent(supplyDrop, true));
    }

    private void OnLootEntity(BasePlayer _, SupplyDrop supplyDrop)
    {
      if (!supplyDrop || null == supplyDrop.net)
      {
        return;
      }
      var zoneId = supplyDrop.net.ID.ToString();
      if (!_activeDynamicZones.TryGetValue(zoneId, out var eventName))
      {
        // no active zone for this supply drop
        return;
      }

      var eventConfig = eventName switch
      {
        nameof(GeneralEventType.SupplySignal) =>
          configData.GeneralEvents.SupplySignal,
        nameof(GeneralEventType.SupplyDrop) =>
          configData.GeneralEvents.TimedSupply,
        _ => null
      };
      if (null == eventConfig)
      {
        // pathological
        PrintDebug($"Unknown SupplyDrop eventName={eventName} for zoneId={zoneId}", DebugLevel.Warning);
        return;
      }

      if (!eventConfig.Enabled || !eventConfig.TimerStartWhenLooted)
      {
        return;
      }
      HandleDeleteDynamicZone(zoneId, eventConfig.Duration, eventName);
    }

    private void OnEntityKill(SupplyDrop supplyDrop)
    {
      if (!supplyDrop || null == supplyDrop.net)
      {
        return;
      }
      var zoneId = supplyDrop.net.ID.ToString();
      if (!_activeDynamicZones.TryGetValue(zoneId, out var eventName))
      {
        // no active zone for this supply drop
        return;
      }

      var eventConfig = eventName switch
      {
        nameof(GeneralEventType.SupplySignal) =>
          configData.GeneralEvents.SupplySignal,
        nameof(GeneralEventType.SupplyDrop) =>
          configData.GeneralEvents.TimedSupply,
        _ => null
      };
      if (null == eventConfig)
      {
        // pathological
        PrintDebug($"Unknown SupplyDrop eventName={eventName} for zoneId={zoneId}", DebugLevel.Warning);
        return;
      }

      if (!eventConfig.Enabled || !eventConfig.StopWhenKilled)
      {
        return;
      }

      //When the timer starts, don't stop the event immediately
      if (!_eventTimers.ContainsKey(zoneId))
      {
        HandleDeleteDynamicZone(zoneId);
      }
    }

    private static string GetSupplyDropStateName(bool isLanded) =>
      isLanded ? "Landed" : "Spawned";

    private void OnSupplyDropEvent(SupplyDrop supplyDrop, bool isLanded)
    {
      if (!supplyDrop || null == supplyDrop.net)
      {
        return;
      }
      PrintDebug($"Trying to create supply drop {GetSupplyDropStateName(isLanded)} event at {supplyDrop.transform.position}.");
      if (!CheckEntityOwner(supplyDrop))
      {
        return;
      }

      var supplySignal = GetSupplySignalNear(supplyDrop.transform.position);
      if (null != supplySignal)
      {
        PrintDebug($"Supply drop is probably from supply signal");
        if (!configData.GeneralEvents.SupplySignal.Enabled)
        {
          PrintDebug("Event for supply signals disabled. Skipping event creation.");
          return;
        }
        if (isLanded == configData.GeneralEvents.SupplySignal.StartWhenSpawned)
        {
          PrintDebug($"{GetSupplyDropStateName(isLanded)} for supply signals disabled.");
          return;
        }
        var entry = supplySignal.Value;
        entry.Value?.Destroy();
        activeSupplySignals.Remove(entry.Key);
        PrintDebug($"Removing Supply signal from active list. Active supply signals remaining: {activeSupplySignals.Count}");
        var eventNameSS = GeneralEventType.SupplySignal.ToString();
        if (!CanCreateDynamicPVP(eventNameSS, supplyDrop))
        {
          return;
        }
        HandleParentedEntityEvent(
          eventNameSS, supplyDrop, parentOnCreate: isLanded);
        return;
      }

      PrintDebug($"Supply drop is probably NOT from supply signal");
      if (!configData.GeneralEvents.TimedSupply.Enabled)
      {
        PrintDebug("Event for timed supply disabled. Skipping event creation.");
        return;
      }
      if (isLanded == configData.GeneralEvents.TimedSupply.StartWhenSpawned)
      {
        PrintDebug($"{GetSupplyDropStateName(isLanded)} for timed supply disabled.");
        return;
      }
      var eventNameSD = GeneralEventType.SupplyDrop.ToString();
      if (!CanCreateDynamicPVP(eventNameSD, supplyDrop))
      {
        return;
      }
      HandleParentedEntityEvent(
        eventNameSD, supplyDrop, parentOnCreate: isLanded);
    }

    private KeyValuePair<Vector3, Timer>? GetSupplySignalNear(Vector3 position)
    {
      PrintDebug($"Checking {activeSupplySignals.Count} active supply signals");
      if (activeSupplySignals.Count <= 0)
      {
        PrintDebug("No active signals, must be from a timed event cargo plane");
        return null;
      }

      foreach (var entry in activeSupplySignals)
      {
        var distance = Vector3Ex.Distance2D(entry.Key, position);
        PrintDebug($"Found a supply signal at {entry.Key} located {distance}m away.");
        if (distance > configData.Global.CompareRadius) continue;
        PrintDebug("Found matching a supply signal.");
        return entry;
      }

      PrintDebug("No matches found, probably from a timed event cargo plane");
      return null;
    }

    #endregion SupplyDrop And SupplySignal Event

    #region CargoShip Event

    // invoke appropriate hook handler for current CargoShip state
    // this is only used on startup, to (re)create events for already-existing
    //  CargoShip entities
    private void StartupCargoShip(CargoShip cargoShip)
    {
      if (!cargoShip)
      {
        PrintDebug("CargoShip is null");
        return;
      }
      if (!configData.GeneralEvents.CargoShip.Enabled)
      {
        PrintDebug("Cargo Ship Event is disabled");
        return;
      }
      if (cargoShip.IsShipDocked)
      {
        // docked
        PrintDebug("Found docked cargo ship");
        OnCargoShipHarborArrived(cargoShip);
      }
      else if (cargoShip.HasFlag(CargoShip.Egressing))
      {
        // leaving the map
        PrintDebug("Found egressing cargo ship");
        OnCargoShipEgress(cargoShip);
      }
      else if (
        cargoShip.isDoingHarborApproach && cargoShip.currentHarborApproachNode <
          cargoShip.harborApproachPath.nodes.Count / 2)
      {
        // approaching a Harbor
        PrintDebug("Found cargo ship approaching Harbor");
        OnCargoShipHarborApproach(cargoShip, null);
      }
      else if (cargoShip.HasFlag(CargoShip.HasDocked))
      {
        // not in any other state, but has previously docked, so this is
        //  equivalent to having most recently received an
        //  OnCargoShipHarborLeave hook call
        PrintDebug("Found cargo ship leaving Harbor");
        OnCargoShipHarborLeave(cargoShip);
      }
      else
      {
        // not docked, not egressing, not approaching, has never docked
        // this implies it has most recently spawned
        PrintDebug("Found spawned cargo ship");
        OnEntitySpawned(cargoShip);
      }
    }

    // create/update or attempt to delete CargoShip event zone, based on
    //  specified desired state
    private void HandleCargoState(CargoShip cargoShip, bool state)
    {
      if (!cargoShip || null == cargoShip.net)
      {
        return;
      }
      if (!configData.GeneralEvents.CargoShip.Enabled)
      {
        return;
      }
      // create/update or attempt to delete zone, based on desired state
      var zoneId = cargoShip.net.ID.ToString();
      var zoneExists = _activeDynamicZones.ContainsKey(zoneId);
      if (zoneExists == state)
      {
        PrintDebug($"CargoShip event {zoneId} is already in desired state={state}");
        return;
      }
      if (state)
      {
        PrintDebug($"Trying to create CargoShip post-spawn event {zoneId}");
        if (!CheckEntityOwner(cargoShip))
        {
          return;
        }
        var eventName = GeneralEventType.CargoShip.ToString();
        // call this here, because otherwise it's difficult to ensure that we
        //  call it exactly once
        if (!CanCreateDynamicPVP(eventName, cargoShip))
        {
          return;
        }
        NextTick(() => HandleParentedEntityEvent(
          eventName, cargoShip, parentOnCreate: true));
      }
      else
      {
        PrintDebug($"Trying to delete CargoShip post-spawn event {zoneId}");
        HandleDeleteDynamicZone(zoneId);
      }
    }

    private void OnEntitySpawned(CargoShip cargoShip)
    {
      if (!cargoShip || null == cargoShip.net)
      {
        // bad entity
        return;
      }
      if (!configData.GeneralEvents.CargoShip.Enabled ||
          !configData.GeneralEvents.CargoShip.SpawnState)
      {
        // not configured to create event on spawn
        return;
      }
      PrintDebug("Trying to create CargoShip spawn event");
      if (!CheckEntityOwner(cargoShip))
      {
        return;
      }
      var eventName = GeneralEventType.CargoShip.ToString();
      // call this here, because otherwise it's difficult to ensure that we call
      //  it exactly once
      if (!CanCreateDynamicPVP(eventName, cargoShip))
      {
        return;
      }
      NextTick(() =>
        HandleParentedEntityEvent(eventName, cargoShip, parentOnCreate: true));
    }

    private void OnEntityKill(CargoShip cargoShip)
    {
      if (!cargoShip || null == cargoShip.net)
      {
        return;
      }
      if (!configData.GeneralEvents.CargoShip.Enabled)
      {
        return;
      }
      HandleDeleteDynamicZone(cargoShip.net.ID.ToString());
    }

    private void OnCargoShipEgress(CargoShip cargoShip) => HandleCargoState(
      cargoShip, configData.GeneralEvents.CargoShip.EgressState);

    private void OnCargoShipHarborApproach(
      CargoShip cargoShip, CargoNotifier _) => HandleCargoState(
        cargoShip, configData.GeneralEvents.CargoShip.ApproachState);

    private void OnCargoShipHarborArrived(
      CargoShip cargoShip) => HandleCargoState(
        cargoShip, configData.GeneralEvents.CargoShip.DockState);

    private void OnCargoShipHarborLeave(
      CargoShip cargoShip) => HandleCargoState(
        cargoShip, configData.GeneralEvents.CargoShip.DepartState);

    #endregion CargoShip Event

    #endregion General Event

    #region Monument Event

    // add and/or start (create) the given monument event name
    // records via list modification whether it was added and/or created
    // NOTE: monument events currently default to disabled, but the code is
    //  structured to support auto-starting new events in case there is ever a
    //  desire to support this
    private IEnumerator CreateMonumentEvent(
      string monumentName, Transform transform,
      List<string> addedEvents, List<string> createdEvents)
    {
      if (!configData.MonumentEvents.TryGetValue(
            monumentName, out var monumentEvent))
      {
        monumentEvent = new MonumentEvent();
        configData.MonumentEvents.Add(monumentName, monumentEvent);
        addedEvents.Add(monumentName);
      }
      if (monumentEvent.Enabled && HandleMonumentEvent(
            monumentName, transform, monumentEvent))
      {
        createdEvents.Add(monumentName);
      }
      yield return CoroutineEx.waitForFixedUpdate;
    }

    // sub-coroutine to create (vanilla and custom map) map marker based
    //  monument events
    private IEnumerator CreateLandmarkMonumentEvents(
      List<string> addedEvents, List<string> createdEvents)
    {
      foreach (LandmarkInfo landmarkInfo in TerrainMeta.Path.Landmarks)
      {
        // only process map-visible landmarks
        if (!landmarkInfo.shouldDisplayOnMap)
        {
          continue;
        }
        var monumentName = landmarkInfo.displayPhrase.english.Trim();
        if (string.IsNullOrEmpty(monumentName))
        {
          // not a vanilla map monument; see if it's a custom one
          if (landmarkInfo.name.Contains("monument_marker.prefab"))
          {
            monumentName = landmarkInfo.transform.root.name;
          }
          if (string.IsNullOrEmpty(monumentName))
          {
            // TODO: this seems to trigger for moonpool modules at Underwater
            //  Labs - do we maybe want to support these as a special case?
            PrintDebug($"Skipping visible landmark because it has no map title: {landmarkInfo}");
            continue;
          }
        }
        switch (landmarkInfo.name)
        {
          case "assets/bundled/prefabs/autospawn/monument/harbor/harbor_1.prefab":
            monumentName += " A";
            break;
          case "assets/bundled/prefabs/autospawn/monument/harbor/harbor_2.prefab":
            monumentName += " B";
            break;
          case PrefabLargeOilRig:
            _largeOilRigPosition = landmarkInfo.transform.position;
            break;
          case PrefabOilRig:
            _oilRigPosition = landmarkInfo.transform.position;
            break;
        }
        yield return CreateMonumentEvent(
          monumentName, landmarkInfo.transform, addedEvents, createdEvents);
      }
      // wait for logging to catch up
      yield return CoroutineEx.waitForSeconds(0.5f);
    }

    // derive a user-friendly event name from a Train Tunnel section prefab name
    // returns empty string on failure, which is debug logged
    private string ToTunnelSectionEventName(string cellName)
    {
      if (!cellName.StartsWith("assets/bundled/prefabs/autospawn/tunnel"))
      {
        PrintDebug($"Skipping unsupported DungeonGridCell type due to non-tunnel: {cellName}");
        return "";
      }
      // NOTE: this must be returned to pool on any return from this method
      var stringBuilder = Pool.Get<StringBuilder>();
      stringBuilder.Clear().Append("Train Tunnel");
      // get the "tunnelXYZ" part of the name
      var slashSplit = cellName.Split("/");
      if (slashSplit.Length < 6)
      {
        PrintDebug($"Skipping unsupported DungeonGridCe